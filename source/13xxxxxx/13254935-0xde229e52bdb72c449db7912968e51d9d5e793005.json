{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@sherlock/v1-core/contracts/ForeignLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport './interfaces/ISherlock.sol';\\n\\nimport './NativeLock.sol';\\n\\ncontract ForeignLock is NativeLock {\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    IERC20 _sherlock,\\n    IERC20 _underlying\\n  ) NativeLock(_name, _symbol, _sherlock) {\\n    underlying = _underlying;\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal override {\\n    ISherlock(owner())._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/ISherlock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport 'diamond-2/contracts/interfaces/IERC173.sol';\\nimport 'diamond-2/contracts/interfaces/IDiamondLoupe.sol';\\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\\nimport './ISherX.sol';\\nimport './ISherXERC20.sol';\\nimport './IGov.sol';\\nimport './IGovDev.sol';\\nimport './IPayout.sol';\\nimport './IManager.sol';\\nimport './IPoolBase.sol';\\nimport './IPoolStake.sol';\\nimport './IPoolStrategy.sol';\\n\\ninterface ISherlock is\\n  IERC173,\\n  IDiamondLoupe,\\n  IDiamondCut,\\n  ISherX,\\n  ISherXERC20,\\n  IERC20,\\n  IGov,\\n  IGovDev,\\n  IPayout,\\n  IManager,\\n  IPoolBase,\\n  IPoolStake,\\n  IPoolStrategy\\n{}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/NativeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport './interfaces/ILock.sol';\\n\\ncontract NativeLock is ERC20, ILock, Ownable {\\n  IERC20 public override underlying;\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    IERC20 _sherlock\\n  ) ERC20(_name, _symbol) {\\n    transferOwnership(address(_sherlock));\\n    underlying = _sherlock;\\n  }\\n\\n  function getOwner() external view override returns (address) {\\n    return owner();\\n  }\\n\\n  function mint(address _account, uint256 _amount) external override onlyOwner {\\n    _mint(_account, _amount);\\n  }\\n\\n  function burn(address _account, uint256 _amount) external override onlyOwner {\\n    _burn(_account, _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-2/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"diamond-2/contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"diamond-2/contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/ISherX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '../interfaces/ILock.sol';\\n\\n/// @title SHERX Logic Controller\\n/// @author Evert Kors\\n/// @notice This contract is used to manage functions related to the SHERX token\\n/// @dev Contract is meant to be included as a facet in the diamond\\ninterface ISherX {\\n  //\\n  // Events\\n  //\\n\\n  /// @notice Sends an event whenever a staker \\\"harvests\\\" earned SHERX\\n  /// @notice Harvesting is when SHERX \\\"interest\\\" is staked in the SHERX pool\\n  /// @param user Address of the user for whom SHERX is harvested\\n  /// @param token Token which had accumulated the harvested SHERX\\n  event Harvest(address indexed user, IERC20 indexed token);\\n\\n  //\\n  // View methods\\n  //\\n\\n  /// @notice Returns the USD amount of tokens being added to the SHERX pool each block\\n  /// @return USD amount added to SHERX pool per block\\n  function getTotalUsdPerBlock() external view returns (uint256);\\n\\n  /// @notice Returns the internal USD amount of tokens represented by SHERX\\n  /// @return Last stored value of total internal USD underlying SHERX\\n  function getTotalUsdPoolStored() external view returns (uint256);\\n\\n  /// @notice Returns the total USD amount of tokens represented by SHERX\\n  /// @return Current total internal USD underlying SHERX\\n  function getTotalUsdPool() external view returns (uint256);\\n\\n  /// @notice Returns block number at which the total USD underlying SHERX was last stored\\n  /// @return Block number for stored USD underlying SHERX\\n  function getTotalUsdLastSettled() external view returns (uint256);\\n\\n  /// @notice Returns stored USD amount for `_token`\\n  /// @param _token Token used for protocol premiums\\n  /// @return Stored USD amount\\n  function getStoredUsd(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns SHERX that has not been minted yet\\n  /// @return Unminted amount of SHERX tokens\\n  function getTotalSherXUnminted() external view returns (uint256);\\n\\n  /// @notice Returns total amount of SHERX, including unminted\\n  /// @return Total amount of SHERX tokens\\n  function getTotalSherX() external view returns (uint256);\\n\\n  /// @notice Returns the amount of SHERX created per block\\n  /// @return SHERX per block\\n  function getSherXPerBlock() external view returns (uint256);\\n\\n  /// @notice Returns the total amount of SHERX accrued by the sender\\n  /// @return Total SHERX balance\\n  function getSherXBalance() external view returns (uint256);\\n\\n  /// @notice Returns the amount of SHERX accrued by `_user`\\n  /// @param _user address to get the SHERX balance of\\n  /// @return Total SHERX balance\\n  function getSherXBalance(address _user) external view returns (uint256);\\n\\n  /// @notice Returns the total supply of SHERX from storage (only used internally)\\n  /// @return Total supply of SHERX\\n  function getInternalTotalSupply() external view returns (uint256);\\n\\n  /// @notice Returns the block number when total SHERX supply was last set in storage\\n  /// @return block number of last write to storage for the total SHERX supply\\n  function getInternalTotalSupplySettled() external view returns (uint256);\\n\\n  /// @notice Returns the tokens and amounts underlying msg.sender's SHERX balance\\n  /// @return tokens Array of ERC-20 tokens representing the underlying\\n  /// @return amounts Corresponding amounts of the underlying tokens\\n  function calcUnderlying()\\n    external\\n    view\\n    returns (IERC20[] memory tokens, uint256[] memory amounts);\\n\\n  /// @notice Returns the tokens and amounts underlying `_user` SHERX balance\\n  /// @param _user Account whose underlying SHERX tokens should be queried\\n  /// @return tokens Array of ERC-20 tokens representing the underlying\\n  /// @return amounts Corresponding amounts of the underlying tokens\\n  function calcUnderlying(address _user)\\n    external\\n    view\\n    returns (IERC20[] memory tokens, uint256[] memory amounts);\\n\\n  /// @notice Returns the tokens and amounts underlying the given amount of SHERX\\n  /// @param _amount Amount of SHERX tokens to calculate the underlying tokens of\\n  /// @return tokens Array of ERC-20 tokens representing the underlying\\n  /// @return amounts Corresponding amounts of the underlying tokens\\n  function calcUnderlying(uint256 _amount)\\n    external\\n    view\\n    returns (IERC20[] memory tokens, uint256[] memory amounts);\\n\\n  /// @notice Returns the internal USD amount underlying senders SHERX\\n  /// @return USD value of SHERX accrued to sender\\n  function calcUnderlyingInStoredUSD() external view returns (uint256);\\n\\n  /// @notice Returns the internal USD amount underlying the given amount SHERX\\n  /// @param _amount Amount of SHERX tokens to find the underlying USD value of\\n  /// @return usd USD value of the given amount of SHERX\\n  function calcUnderlyingInStoredUSD(uint256 _amount) external view returns (uint256 usd);\\n\\n  //\\n  // State changing methods\\n  //\\n\\n  /// @notice Function called by lockTokens before transfer\\n  /// @param from Address from which lockTokens are being transferred\\n  /// @param to Address to which lockTokens are being transferred\\n  /// @param amount Amount of lockTokens to be transferred\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external;\\n\\n  /// @notice Set initial SHERX distribution to Watsons\\n  function setInitialWeight() external;\\n\\n  /// @notice Set SHERX distribution\\n  /// @param _tokens Array of tokens to set the weights of\\n  /// @param _weights Respective weighting for each token\\n  /// @param _watsons Weighting to set for the Watsons\\n  function setWeights(\\n    IERC20[] memory _tokens,\\n    uint16[] memory _weights,\\n    uint256 _watsons\\n  ) external;\\n\\n  /// @notice Harvest all tokens on behalf of the sender\\n  function harvest() external;\\n\\n  /// @notice Harvest `_token` on behalf of the sender\\n  /// @param _token Token to harvest accrued SHERX for\\n  function harvest(ILock _token) external;\\n\\n  /// @notice Harvest `_tokens` on behalf of the sender\\n  /// @param _tokens Array of tokens to harvest accrued SHERX for\\n  function harvest(ILock[] calldata _tokens) external;\\n\\n  /// @notice Harvest all tokens for `_user`\\n  /// @param _user Account for which to harvest SHERX\\n  function harvestFor(address _user) external;\\n\\n  /// @notice Harvest `_token` for `_user`\\n  /// @param _user Account for which to harvest SHERX\\n  /// @param _token Token to harvest\\n  function harvestFor(address _user, ILock _token) external;\\n\\n  /// @notice Harvest `_tokens` for `_user`\\n  /// @param _user Account for which to harvest SHERX\\n  /// @param _tokens Array of tokens to harvest accrued SHERX for\\n  function harvestFor(address _user, ILock[] calldata _tokens) external;\\n\\n  /// @notice Redeems SHERX tokens for the underlying collateral\\n  /// @param _amount Amount of SHERX tokens to redeem\\n  /// @param _receiver Address to send redeemed tokens to\\n  function redeem(uint256 _amount, address _receiver) external;\\n\\n  /// @notice Accrue SHERX based on internal weights\\n  function accrueSherX() external;\\n\\n  /// @notice Accrues SHERX to specific token\\n  /// @param _token Token to accure SHERX to.\\n  function accrueSherX(IERC20 _token) external;\\n\\n  /// @notice Accrues SHERX to the Watsons.\\n  function accrueSherXWatsons() external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/ISherXERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\ninterface ISherXERC20 {\\n  //\\n  // View methods\\n  //\\n\\n  /// @notice Get the token name\\n  /// @return The token name\\n  function name() external view returns (string memory);\\n\\n  /// @notice Get the token symbol\\n  /// @return The token symbol\\n  function symbol() external view returns (string memory);\\n\\n  /// @notice Get the amount of decimals\\n  /// @return Amount of decimals\\n  function decimals() external view returns (uint8);\\n\\n  //\\n  // State changing methods\\n  //\\n\\n  /// @notice Sets up the metadata and initial supply. Can be called by the contract owner\\n  /// @param _name Name of the token\\n  /// @param _symbol Symbol of the token\\n  function initializeSherXERC20(string memory _name, string memory _symbol) external;\\n\\n  /// @notice Increase the amount of tokens another address can spend\\n  /// @param _spender Spender\\n  /// @param _amount Amount to increase by\\n  function increaseAllowance(address _spender, uint256 _amount) external returns (bool);\\n\\n  /// @notice Decrease the amount of tokens another address can spend\\n  /// @param _spender Spender\\n  /// @param _amount Amount to decrease by\\n  function decreaseAllowance(address _spender, uint256 _amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IGov.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '../interfaces/ILock.sol';\\nimport '../interfaces/IRemove.sol';\\n\\n/// @title Sherlock Main Governance\\n/// @author Evert Kors\\n/// @notice This contract is used for managing tokens, protocols and more in Sherlock\\n/// @dev Contract is meant to be included as a facet in the diamond\\n/// @dev Storage library is used\\ninterface IGov {\\n  //\\n  // Events\\n  //\\n\\n  //\\n  // View methods\\n  //\\n\\n  /// @notice Returns the main governance address\\n  /// @return Main governance address\\n  function getGovMain() external view returns (address);\\n\\n  /// @notice Returns the compensation address for the Watsons\\n  /// @return Watsons address\\n  function getWatsons() external view returns (address);\\n\\n  /// @notice Returns the weight for the Watsons compensation\\n  /// @return Watsons compensation weight\\n  /// @dev Value is scaled by type(uint16).max\\n  function getWatsonsSherXWeight() external view returns (uint16);\\n\\n  /// @notice Returns the last block number the SherX was accrued to the Watsons\\n  /// @return Block number\\n  function getWatsonsSherxLastAccrued() external view returns (uint40);\\n\\n  /// @notice Returns the amount of SherX the Watsons receive per block\\n  /// @return Number of SherX per block\\n  function getWatsonsSherXPerBlock() external view returns (uint256);\\n\\n  /// @notice Returns the total amount of uminted SherX for the Watsons\\n  /// @return SherX to be minted\\n  /// @dev Based on current block, last accrued and the SherX per block\\n  function getWatsonsUnmintedSherX() external view returns (uint256);\\n\\n  /// @notice Returns the window of opportunity in blocks to unstake funds\\n  /// @notice Cooldown period has to be expired first to start the unstake window\\n  /// @return Amount of blocks\\n  function getUnstakeWindow() external view returns (uint40);\\n\\n  /// @notice Returns the cooldown period in blocks\\n  /// @notice After the cooldown period funds can be unstaked\\n  /// @return Amount of blocks\\n  function getCooldown() external view returns (uint40);\\n\\n  /// @notice Returns an array of tokens accounts are allowed to stake in\\n  /// @return Array of ERC20 tokens\\n  function getTokensStaker() external view returns (IERC20[] memory);\\n\\n  /// @notice Returns an array of tokens that are included in the SherX as underlying\\n  /// @notice Registered protocols use one or more of these tokens to compensate Sherlock\\n  /// @return Array of ERC20 tokens\\n  function getTokensSherX() external view returns (IERC20[] memory);\\n\\n  /// @notice Verify if a protocol is included in Sherlock\\n  /// @param _protocol Protocol identifier\\n  /// @return Boolean indicating if protocol is included\\n  function getProtocolIsCovered(bytes32 _protocol) external view returns (bool);\\n\\n  /// @notice Returns address responsible on behalf of Sherlock for the protocol\\n  /// @param _protocol Protocol identifier\\n  /// @return Address of account\\n  function getProtocolManager(bytes32 _protocol) external view returns (address);\\n\\n  /// @notice Returns address responsible on behalf of the protocol\\n  /// @param _protocol Protocol identifier\\n  /// @return Address of account\\n  /// @dev Account is able to withdraw protocol balance\\n  function getProtocolAgent(bytes32 _protocol) external view returns (address);\\n\\n  /// @notice Get the maximum of tokens to be in the SherX array\\n  /// @return Max maximum amount of tokens\\n  function getMaxTokensSherX() external view returns (uint8);\\n\\n  /// @notice Get the maximum of tokens to be in the Staker array\\n  /// @return Max maximum amount of tokens\\n  function getMaxTokensStaker() external view returns (uint8);\\n\\n  /// @notice Get the maximum of protocol to be in a single pool\\n  /// @return Max maximum amount of protocol\\n  function getMaxProtocolPool() external view returns (uint8);\\n\\n  //\\n  // State changing methods\\n  //\\n\\n  /// @notice Set initial main governance address\\n  /// @param _govMain The address of the main governance\\n  /// @dev Diamond deployer - GovDev - is able to call this function\\n  function setInitialGovMain(address _govMain) external;\\n\\n  /// @notice Transfer the main governance\\n  /// @param _govMain New address for the main governance\\n  function transferGovMain(address _govMain) external;\\n\\n  /// @notice Set the compensation address for the Watsons\\n  /// @param _watsons Address for Watsons\\n  function setWatsonsAddress(address _watsons) external;\\n\\n  /// @notice Set unstake window\\n  /// @param _unstakeWindow Unstake window in amount of blocks\\n  function setUnstakeWindow(uint40 _unstakeWindow) external;\\n\\n  /// @notice Set cooldown period\\n  /// @param _period Cooldown period in amount of blocks\\n  function setCooldown(uint40 _period) external;\\n\\n  /// @notice Add a new protocol to Sherlock\\n  /// @param _protocol Protocol identifier\\n  /// @param _eoaProtocolAgent Account to be registered as the agent\\n  /// @param _eoaManager Account to be registered as the manager\\n  /// @param _tokens Initial array of tokens the protocol is allowed to pay in\\n  /// @dev _tokens should first be initialized by calling tokenInit()\\n  function protocolAdd(\\n    bytes32 _protocol,\\n    address _eoaProtocolAgent,\\n    address _eoaManager,\\n    IERC20[] memory _tokens\\n  ) external;\\n\\n  /// @notice Update protocol agent and/or manager\\n  /// @param _protocol Protocol identifier\\n  /// @param _eoaProtocolAgent Account to be registered as the agent\\n  /// @param _eoaManager Account to be registered as the manager\\n  function protocolUpdate(\\n    bytes32 _protocol,\\n    address _eoaProtocolAgent,\\n    address _eoaManager\\n  ) external;\\n\\n  /// @notice Add tokens the protocol is allowed to pay in\\n  /// @param _protocol Protocol identifier\\n  /// @param _tokens Array of tokens to be added as valid protocol payment\\n  /// @dev _tokens should first be initialized by calling tokenInit()\\n  function protocolDepositAdd(bytes32 _protocol, IERC20[] memory _tokens) external;\\n\\n  /// @notice Remove protocol from the Sherlock registry\\n  /// @param _protocol Protocol identifier\\n  function protocolRemove(bytes32 _protocol) external;\\n\\n  /// @notice Initialize a new token\\n  /// @param _token Address of the token\\n  /// @param _govPool Account responsible for the token\\n  /// @param _lock Corresponding lock token, indicating staker token\\n  /// @param _isProtocolPremium Boolean indicating if token should be registered as protocol payment\\n  /// @dev Token can be reinitialiezd\\n  /// @dev Zero address for _lock will not enable stakers to deposit with the _token\\n  function tokenInit(\\n    IERC20 _token,\\n    address _govPool,\\n    ILock _lock,\\n    bool _isProtocolPremium\\n  ) external;\\n\\n  /// @notice Disable a token for stakers\\n  /// @param _token Address of the token\\n  /// @param _index Index of the token in storage array\\n  function tokenDisableStakers(IERC20 _token, uint256 _index) external;\\n\\n  /// @notice Disable a token for protocols\\n  /// @param _token Address of the token\\n  /// @param _index Index of the token in storage array\\n  /// @dev Removes the token as underlying from SherX\\n  function tokenDisableProtocol(IERC20 _token, uint256 _index) external;\\n\\n  /// @notice Unload tokens from Sherlock\\n  /// @param _token Address of the token\\n  /// @param _native Contract being used to swap existing token in Sherlock\\n  /// @param _remaining Account used to send the unallocated SherX and remaining balance for _token\\n  function tokenUnload(\\n    IERC20 _token,\\n    IRemove _native,\\n    address _remaining\\n  ) external;\\n\\n  /// @notice Remove a token from storage\\n  /// @param _token Address of the token\\n  function tokenRemove(IERC20 _token) external;\\n\\n  /// @notice Set the maximum of tokens to be in the SherX array\\n  /// @param _max maximum amount of tokens\\n  function setMaxTokensSherX(uint8 _max) external;\\n\\n  /// @notice Set the maximum of tokens to be in the Staker array\\n  /// @param _max maximum amount of tokens\\n  function setMaxTokensStaker(uint8 _max) external;\\n\\n  /// @notice Set the maximum of protocol to be in a single pool\\n  /// @param _max maximum amount of protocol\\n  function setMaxProtocolPool(uint8 _max) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IGovDev.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\\n\\n/// @title Sherlock Dev Controller\\n/// @author Evert Kors\\n/// @notice This contract is used during development for upgrading logic\\n/// @dev Contract is meant to be included as a facet in the diamond\\ninterface IGovDev {\\n  /// @notice Returns the dev controller address\\n  /// @return Dev address\\n  function getGovDev() external view returns (address);\\n\\n  /// @notice Transfer dev role to other account or renounce\\n  /// @param _govDev New dev address\\n  function transferGovDev(address _govDev) external;\\n\\n  /// @notice Renounce dev role\\n  function renounceGovDev() external;\\n\\n  /// @notice Delete, update or add functions\\n  /// @param _diamondCut Struct containing data of function mutation\\n  /// @param _init Address to call after pushing changes\\n  /// @param _calldata Data to call address with\\n  function updateSolution(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IPayout.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Sherlock Payout Controller\\n/// @author Evert Kors\\n/// @notice This contract is used for doing payouts\\n/// @dev Contract is meant to be included as a facet in the diamond\\n/// @dev Storage library is used\\ninterface IPayout {\\n  /// @notice Returns the governance address able to do payouts\\n  /// @return Payout governance address\\n  function getGovPayout() external view returns (address);\\n\\n  /// @notice Set initial payout governance address\\n  /// @param _govPayout The address of the payout governance\\n  /// @dev Diamond deployer - GovDev - is able to call this function\\n  function setInitialGovPayout(address _govPayout) external;\\n\\n  /// @notice Transfer the payout governance\\n  /// @param _govPayout New address for the payout governance\\n  function transferGovPayout(address _govPayout) external;\\n\\n  /// @notice Send `_tokens` to `_payout`\\n  /// @param _payout Account to receive payout\\n  /// @param _tokens Tokens to be paid out\\n  /// @param _firstMoneyOut Amount used from first money out\\n  /// @param _amounts Amount used staker balance\\n  /// @param _unallocatedSherX Amount of unallocated SHERX used\\n  /// @param _exclude Token excluded from payout\\n  function payout(\\n    address _payout,\\n    IERC20[] memory _tokens,\\n    uint256[] memory _firstMoneyOut,\\n    uint256[] memory _amounts,\\n    uint256[] memory _unallocatedSherX,\\n    address _exclude\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Sherlock Protocol Manager\\n/// @author Evert Kors\\n/// @notice Managing the amounts protocol are due to Sherlock\\ninterface IManager {\\n  //\\n  // State changing methods\\n  //\\n\\n  /// @notice Set internal price of `_token` to `_newUsd`\\n  /// @param _token Token to be updated\\n  /// @param _newUsd USD amount of token\\n  /// @dev Updating token price for 1 token\\n  function setTokenPrice(IERC20 _token, uint256 _newUsd) external;\\n\\n  /// @notice Set internal price of multiple tokens\\n  /// @param _token Array of token addresses\\n  /// @param _newUsd Array of USD amounts\\n  /// @dev Updating token price for 1+ tokens\\n  function setTokenPrice(IERC20[] memory _token, uint256[] memory _newUsd) external;\\n\\n  /// @notice Set `_token` premium for `_protocol` to `_premium` per block\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Token address\\n  /// @param _premium Amount of tokens to be paid per block\\n  /// @dev Updating protocol premium for 1 token\\n  function setProtocolPremium(\\n    bytes32 _protocol,\\n    IERC20 _token,\\n    uint256 _premium\\n  ) external;\\n\\n  /// @notice Set multiple token premiums for `_protocol`\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Array of token addresses\\n  /// @param _premium Array of amount of tokens to be paid per block\\n  /// @dev Updating protocol premium for 1+ tokens\\n  function setProtocolPremium(\\n    bytes32 _protocol,\\n    IERC20[] memory _token,\\n    uint256[] memory _premium\\n  ) external;\\n\\n  // NOTE: note implemented for now, same call with price has better use case\\n  // updating multiple protocol's premiums for 1 tokens\\n  // function setProtocolPremium(\\n  //   bytes32[] memory _protocol,\\n  //   IERC20 memory _token,\\n  //   uint256[] memory _premium\\n  // ) external;\\n\\n  /// @notice Set multiple tokens premium for multiple protocols\\n  /// @param _protocol Array of protocol identifiers\\n  /// @param _token 2 dimensional array of token addresses\\n  /// @param _premium 2 dimensional array of amount of tokens to be paid per block\\n  /// @dev Updating multiple protocol's premium for 1+ tokens\\n  function setProtocolPremium(\\n    bytes32[] memory _protocol,\\n    IERC20[][] memory _token,\\n    uint256[][] memory _premium\\n  ) external;\\n\\n  /// @notice Set `_token` premium for `_protocol` to `_premium` per block and internal price to `_newUsd`\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Token address\\n  /// @param _premium Amount of tokens to be paid per block\\n  /// @param _newUsd USD amount of token\\n  /// @dev Updating protocol premium and token price for 1 token\\n  function setProtocolPremiumAndTokenPrice(\\n    bytes32 _protocol,\\n    IERC20 _token,\\n    uint256 _premium,\\n    uint256 _newUsd\\n  ) external;\\n\\n  /// @notice Set multiple token premiums for `_protocol` and update internal prices\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Array of token addresses\\n  /// @param _premium Array of amount of tokens to be paid per block\\n  /// @param _newUsd Array of USD amounts\\n  /// @dev Updating protocol premiums and token price for 1+ token\\n  function setProtocolPremiumAndTokenPrice(\\n    bytes32 _protocol,\\n    IERC20[] memory _token,\\n    uint256[] memory _premium,\\n    uint256[] memory _newUsd\\n  ) external;\\n\\n  /// @notice Set `_token` premium for protocols and internal price to `_newUsd`\\n  /// @param _protocol Array of protocol identifiers\\n  /// @param _token Token address\\n  /// @param _premium Array of amount of tokens to be paid per block\\n  /// @param _newUsd USD amount\\n  /// @dev Updating multiple protocol premiums for 1 token, including price\\n  function setProtocolPremiumAndTokenPrice(\\n    bytes32[] memory _protocol,\\n    IERC20 _token,\\n    uint256[] memory _premium,\\n    uint256 _newUsd\\n  ) external;\\n\\n  /// @notice Update multiple token premiums and prices for multiple protocols\\n  /// @param _protocol Array of protocol identifiers\\n  /// @param _token 2 dimensional array of tokens\\n  /// @param _premium 2 dimensional array of amounts to be paid per block\\n  /// @param _newUsd 2 dimensional array of USD amounts\\n  /// @dev Updating multiple protocol premiums for multiple tokens, including price\\n  function setProtocolPremiumAndTokenPrice(\\n    bytes32[] memory _protocol,\\n    IERC20[][] memory _token,\\n    uint256[][] memory _premium,\\n    uint256[][] memory _newUsd\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IPoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '../storage/PoolStorage.sol';\\n\\n/// @title Sherlock Pool Controller\\n/// @author Evert Kors\\n/// @notice This contract is for every token pool\\n/// @dev Contract is meant to be included as a facet in the diamond\\n/// @dev Storage library is used\\n/// @dev Storage pointer is calculated based on last _token argument\\ninterface IPoolBase {\\n  //\\n  // Events\\n  //\\n\\n  //\\n  // View methods\\n  //\\n\\n  /// @notice Returns the fee used on `_token` cooldown activation\\n  /// @param _token Token used\\n  /// @return Cooldown fee scaled by type(uint32).max\\n  function getCooldownFee(IERC20 _token) external view returns (uint32);\\n\\n  /// @notice Returns SherX weight for `_token`\\n  /// @param _token Token used\\n  /// @return SherX weight scaled by type(uint16).max\\n  function getSherXWeight(IERC20 _token) external view returns (uint16);\\n\\n  /// @notice Returns account responsible for `_token`\\n  /// @param _token Token used\\n  /// @return Account address\\n  function getGovPool(IERC20 _token) external view returns (address);\\n\\n  /// @notice Returns boolean indicating if `_token` can be used for protocol payments\\n  /// @param _token Token used\\n  /// @return Premium boolean\\n  function isPremium(IERC20 _token) external view returns (bool);\\n\\n  /// @notice Returns boolean indicating if `_token` can be used for staking\\n  /// @param _token Token used\\n  /// @return Staking boolean\\n  function isStake(IERC20 _token) external view returns (bool);\\n\\n  /// @notice Returns current `_token` balance for `_protocol`\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Token used\\n  /// @return Current balance\\n  function getProtocolBalance(bytes32 _protocol, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns current `_token` premium for `_protocol`\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Token used\\n  /// @return Current premium per block\\n  function getProtocolPremium(bytes32 _protocol, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns linked lockToken for `_token`\\n  /// @param _token Token used\\n  /// @return Address of lockToken\\n  function getLockToken(IERC20 _token) external view returns (ILock);\\n\\n  /// @notice Returns if `_protocol` is whitelisted for `_token`\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Token used\\n  /// @return Boolean indicating whitelist status\\n  function isProtocol(bytes32 _protocol, IERC20 _token) external view returns (bool);\\n\\n  /// @notice Returns array of whitelisted protcols\\n  /// @param _token Token used\\n  /// @return Array protocol identifiers\\n  function getProtocols(IERC20 _token) external view returns (bytes32[] memory);\\n\\n  /// @notice Returns `_token` untake entry for `_staker` with id `_id`\\n  /// @param _staker Account that started unstake process\\n  /// @param _id ID of unstaking entry\\n  /// @param _token Token used\\n  /// @return Unstaking entry\\n  function getUnstakeEntry(\\n    address _staker,\\n    uint256 _id,\\n    IERC20 _token\\n  ) external view returns (PoolStorage.UnstakeEntry memory);\\n\\n  /// @notice Return total debt in  `_token` whitelisted protocols accrued\\n  /// @param _token Token used\\n  /// @return Total accrued debt\\n  function getTotalAccruedDebt(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Return current size of first money out pool\\n  /// @param _token Token used\\n  /// @return First money out size\\n  function getFirstMoneyOut(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Return debt in  `_token` `_protocol` accrued\\n  /// @param _protocol Protocol identifier\\n  /// @param _token Token used\\n  /// @return Accrued debt\\n  function getAccruedDebt(bytes32 _protocol, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Return total premium per block that whitelisted protocols are accrueing as debt\\n  /// @param _token Token used\\n  /// @return Total amount of premium\\n  function getTotalPremiumPerBlock(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns block debt was last accrued.\\n  /// @param _token Token used\\n  /// @return Block number\\n  function getPremiumLastPaid(IERC20 _token) external view returns (uint40);\\n\\n  /// @notice Return total amount of `_token` used as underlying for SHERX\\n  /// @param _token Token used\\n  /// @return Amount used as underlying\\n  function getSherXUnderlying(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Return total amount of `_staker` unstaking entries for `_token`\\n  /// @param _staker Account used\\n  /// @param _token Token used\\n  /// @return Amount of entries\\n  function getUnstakeEntrySize(address _staker, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns initial active unstaking enty for `_staker`\\n  /// @param _staker Account used\\n  /// @param _token Token used\\n  /// @return Initial ID of unstaking entry\\n  function getInitialUnstakeEntry(address _staker, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns amount staked in `_token` that is not included in a yield strategy\\n  /// @param _token Token used\\n  /// @return Amount staked\\n  function getUnactivatedStakersPoolBalance(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns amount staked in `_token` including yield strategy\\n  /// @param _token Token used\\n  /// @return Amount staked\\n  function getStakersPoolBalance(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns `_staker` amount staked in `_token`\\n  /// @param _staker Account used\\n  /// @param _token Token used\\n  /// @return Amount staked\\n  function getStakerPoolBalance(address _staker, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns unminted SHERX for `_token`\\n  /// @param _token Token used\\n  /// @return Unminted SHERX\\n  function getTotalUnmintedSherX(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns stored amount of SHERX not allocated to stakers\\n  /// @param _token Token used\\n  /// @return Unallocated amount of SHERX\\n  function getUnallocatedSherXStored(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns current amount of SHERX not allocated to stakers\\n  /// @param _token Token used\\n  /// @return Unallocated amount of SHERX\\n  function getUnallocatedSherXTotal(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns current amount of SHERX not allocated to `_user`\\n  /// @param _user Staker in token\\n  /// @param _token Token used\\n  /// @return Unallocated amount of SHERX\\n  function getUnallocatedSherXFor(address _user, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns SHERX distributed to `_token` stakers per block\\n  /// @param _token Token used\\n  /// @return Amount of SHERX distributed\\n  function getTotalSherXPerBlock(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns SHERX distributed per block to sender for staking in `_token`\\n  /// @param _token Token used\\n  /// @return Amount of SHERX distributed\\n  function getSherXPerBlock(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns SHERX distributed per block to `_user` for staking in `_token`\\n  /// @param _user Account used\\n  /// @param _token Token used\\n  /// @return Amount of SHERX distributed\\n  function getSherXPerBlock(address _user, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns SHERX distributed per block when staking `_amount` of `_token`\\n  /// @param _amount Amount of tokens\\n  /// @param _token Token used\\n  /// @return SHERX to be distrubuted if staked\\n  function getSherXPerBlock(uint256 _amount, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Returns block SHERX was last accrued to `_token`\\n  /// @param _token Token used\\n  /// @return Block last accrued\\n  function getSherXLastAccrued(IERC20 _token) external view returns (uint40);\\n\\n  /// @notice Current exchange rate from lockToken to `_token`\\n  /// @param _token Token used\\n  /// @return Current exchange rate\\n  function LockToTokenXRate(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Current exchange rate from lockToken to `_token` using `_amount`\\n  /// @param _amount Amount to be exchanged\\n  /// @param _token Token used\\n  /// @return Current exchange rate\\n  function LockToToken(uint256 _amount, IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Current exchange rate from `_token` to lockToken\\n  /// @param _token Token used\\n  /// @return Current exchange rate\\n  function TokenToLockXRate(IERC20 _token) external view returns (uint256);\\n\\n  /// @notice Current exchange rate from `_token` to lockToken using `_amount`\\n  /// @param _amount Amount to be exchanged\\n  /// @param _token Token used\\n  /// @return Current exchange rate\\n  function TokenToLock(uint256 _amount, IERC20 _token) external view returns (uint256);\\n\\n  //\\n  // State changing methods\\n  //\\n\\n  /// @notice Set `_fee` used for activating cooldowns on `_token`\\n  /// @param _fee Fee scaled by type(uint32).max\\n  /// @param _token Token used\\n  function setCooldownFee(uint32 _fee, IERC20 _token) external;\\n\\n  /// @notice Deposit `_amount` of `_token` on behalf of `_protocol`\\n  /// @param _protocol Protocol identifier\\n  /// @param _amount Amount of tokens\\n  /// @param _token Token used\\n  function depositProtocolBalance(\\n    bytes32 _protocol,\\n    uint256 _amount,\\n    IERC20 _token\\n  ) external;\\n\\n  /// @notice Withdraw `_amount` of `_token` on behalf of `_protocol` to `_receiver`\\n  /// @param _protocol Protocol identifier\\n  /// @param _amount Amount of tokens\\n  /// @param _receiver Address receiving the amount\\n  /// @param _token Token used\\n  function withdrawProtocolBalance(\\n    bytes32 _protocol,\\n    uint256 _amount,\\n    address _receiver,\\n    IERC20 _token\\n  ) external;\\n\\n  /// @notice Start unstaking flow for sender with `_amount` of lockTokens\\n  /// @param _amount Amount of lockTokens\\n  /// @param _token Token used\\n  /// @return ID of unstaking entry\\n  /// @dev e.g. _token is DAI, _amount is amount of lockDAI\\n  function activateCooldown(uint256 _amount, IERC20 _token) external returns (uint256);\\n\\n  /// @notice Cancel unstaking `_token` with entry `_id` for sender\\n  /// @param _id ID of unstaking entry\\n  /// @param _token Token used\\n  function cancelCooldown(uint256 _id, IERC20 _token) external;\\n\\n  /// @notice Returns lockTokens to _account if unstaking entry _id is expired\\n  /// @param _account Account that initiated unstaking flow\\n  /// @param _id ID of unstaking entry\\n  /// @param _token Token used\\n  function unstakeWindowExpiry(\\n    address _account,\\n    uint256 _id,\\n    IERC20 _token\\n  ) external;\\n\\n  /// @notice Unstake _token for sender with entry _id, send to _receiver\\n  /// @param _id ID of unstaking entry\\n  /// @param _receiver Account receiving the tokens\\n  /// @param _token Token used\\n  /// @return amount of tokens unstaked\\n  function unstake(\\n    uint256 _id,\\n    address _receiver,\\n    IERC20 _token\\n  ) external returns (uint256 amount);\\n\\n  /// @notice Pay off accrued debt of whitelisted protocols\\n  /// @param _token Token used\\n  function payOffDebtAll(IERC20 _token) external;\\n\\n  /// @notice Remove `_protocol` from `_token` whitelist, send remaining balance to `_receiver`\\n  /// @param _protocol Protocol indetifier\\n  /// @param _index Entry of protocol in storage array\\n  /// @param _forceDebt If protocol has outstanding debt, pay off\\n  /// @param _receiver Receiver of remaining deposited balance\\n  /// @param _token Token used\\n  function cleanProtocol(\\n    bytes32 _protocol,\\n    uint256 _index,\\n    bool _forceDebt,\\n    address _receiver,\\n    IERC20 _token\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IPoolStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IPoolStake {\\n  /// @notice Stake `_amount` of `_token`, send lockToken to `_receiver`\\n  /// @param _amount Amount to stake\\n  /// @param _receiver Account receiving the lockTokens\\n  /// @param _token Token used\\n  /// @return Amount of lockTokens representing deposited `_amount`\\n  function stake(\\n    uint256 _amount,\\n    address _receiver,\\n    IERC20 _token\\n  ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IPoolStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './IStrategy.sol';\\n\\n/// @title Sherlock Pool Strategy Controller\\n/// @author Evert Kors\\n/// @notice This contract is for every token pool\\n/// @dev Used for activate token assets for earning yield\\n/// @dev Contract is meant to be included as a facet in the diamond\\n/// @dev Storage library is used\\n/// @dev Storage pointer is calculated based on last _token argument\\ninterface IPoolStrategy {\\n  function getStrategy(IERC20 _token) external view returns (IStrategy);\\n\\n  function strategyRemove(\\n    IERC20 _token,\\n    address _receiver,\\n    IERC20[] memory _extraTokens\\n  ) external;\\n\\n  function strategyUpdate(IStrategy _strategy, IERC20 _token) external;\\n\\n  function strategyDeposit(uint256 _amount, IERC20 _token) external;\\n\\n  function strategyWithdraw(uint256 _amount, IERC20 _token) external;\\n\\n  function strategyWithdrawAll(IERC20 _token) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/ILock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Lock Token\\n/// @author Evert Kors\\n/// @notice Lock tokens represent a stake in Sherlock\\ninterface ILock is IERC20 {\\n  /// @notice Returns the owner of this contract\\n  /// @return Owner address\\n  /// @dev Should be equal to the Sherlock address\\n  function getOwner() external view returns (address);\\n\\n  /// @notice Returns token it represents\\n  /// @return Token address\\n  function underlying() external view returns (IERC20);\\n\\n  /// @notice Mint `_amount` tokens for `_account`\\n  /// @param _account Account to receive tokens\\n  /// @param _amount Amount to be minted\\n  function mint(address _account, uint256 _amount) external;\\n\\n  /// @notice Burn `_amount` tokens for `_account`\\n  /// @param _account Account to be burned\\n  /// @param _amount Amount to be burned\\n  function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IRemove.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IRemove {\\n  /// @notice Swap `_token` amounts\\n  /// @param _token Token to swap\\n  /// @param _fmo Amount of first money out pool swapped\\n  /// @param _sherXUnderlying Amount of underlying being swapped\\n  /// @return newToken Token being swapped to\\n  /// @return newFmo Share of `_fmo` in newToken\\n  /// @return newSherxUnderlying Share of `_sherXUnderlying` in newToken\\n  function swap(\\n    IERC20 _token,\\n    uint256 _fmo,\\n    uint256 _sherXUnderlying\\n  )\\n    external\\n    returns (\\n      IERC20 newToken,\\n      uint256 newFmo,\\n      uint256 newSherxUnderlying\\n    );\\n}\\n\"\r\n    },\r\n    \"diamond-2/contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* This is gas optimized by reducing storage reads and storage writes.\\n* This code is as complex as it is to reduce gas costs.\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // owner of the contract\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n        _;\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            require(_newFacetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            uint256 selectorSlotCount = _selectorCount / 8;\\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n                    // only useful if immutable functions exist\\n                    require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n                selectorInSlotIndex--;\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/storage/PoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '../interfaces/ILock.sol';\\nimport '../interfaces/IStrategy.sol';\\n\\n// TokenStorage\\nlibrary PoolStorage {\\n  bytes32 constant POOL_STORAGE_PREFIX = 'diamond.sherlock.pool.';\\n\\n  struct Base {\\n    address govPool;\\n    // Variable used to calculate the fee when activating the cooldown\\n    // Max value is type(uint32).max which creates a 100% fee on the withdrawal\\n    uint32 activateCooldownFee;\\n    // How much sherX is distributed to stakers of this token\\n    // The max value is type(uint16).max, which means 100% of the total SherX minted is allocated to this pool\\n    uint16 sherXWeight;\\n    // The last block the total amount of rewards were accrued.\\n    // Accrueing SherX increases the `unallocatedSherX` variable\\n    uint40 sherXLastAccrued;\\n    // Indicates if protocol are able to pay premiums with this token\\n    // If this value is true, the token is also included as underlying of the SherX\\n    bool premiums;\\n    // Protocol debt can only be settled at once for all the protocols at the same time\\n    // This variable is the block number the last time all the protocols debt was settled\\n    uint40 totalPremiumLastPaid;\\n    //\\n    // Staking\\n    //\\n    // Indicates if stakers can stake funds in the pool\\n    bool stakes;\\n    // Address of the lockToken. Representing stakes in this pool\\n    ILock lockToken;\\n    // The total amount staked by the stakers in this pool, including value of `firstMoneyOut`\\n    // if you exclude the `firstMoneyOut` from this value, you get the actual amount of tokens staked\\n    // This value is also excluding funds deposited in a strategy.\\n    uint256 stakeBalance;\\n    // All the withdrawals by an account\\n    // The values of the struct are all deleted if expiry() or unstake() function is called\\n    mapping(address => UnstakeEntry[]) unstakeEntries;\\n    // Represents the amount of tokens in the first money out pool\\n    uint256 firstMoneyOut;\\n    // If the `stakes` = true, the stakers can be rewarded by sherx\\n    // stakers can claim their rewards by calling the harvest() function\\n    // SherX could be minted before the stakers call the harvest() function\\n    // Minted SherX that is assigned as reward for the pool will be added to this value\\n    uint256 unallocatedSherX;\\n    // Non-native variables\\n    // These variables are used to calculate the right amount of SherX rewards for the token staked\\n    mapping(address => uint256) sWithdrawn;\\n    uint256 sWeight;\\n    // Storing the protocol token balance based on the protocols bytes32 indentifier\\n    mapping(bytes32 => uint256) protocolBalance;\\n    // Storing the protocol premium, the amount of debt the protocol builds up per block.\\n    // This is based on the bytes32 identifier of the protocol.\\n    mapping(bytes32 => uint256) protocolPremium;\\n    // The sum of all the protocol premiums, the total amount of debt that builds up in this token. (per block)\\n    uint256 totalPremiumPerBlock;\\n    // How much tokens are used as underlying for SherX\\n    uint256 sherXUnderlying;\\n    // Check if the protocol is included in the token pool\\n    // The protocol can deposit balances if this is the case\\n    mapping(bytes32 => bool) isProtocol;\\n    // Array of protocols that are registered in this pool\\n    bytes32[] protocols;\\n    // Active strategy for this token pool\\n    IStrategy strategy;\\n  }\\n\\n  struct UnstakeEntry {\\n    // The block number the cooldown is activated\\n    uint40 blockInitiated;\\n    // The amount of lock tokens to be withdrawn\\n    uint256 lock;\\n  }\\n\\n  function ps(IERC20 _token) internal pure returns (Base storage psx) {\\n    bytes32 position = keccak256(abi.encodePacked(POOL_STORAGE_PREFIX, _token));\\n    assembly {\\n      psx.slot := position\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@sherlock/v1-core/contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\n\\n/******************************************************************************\\\\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\\n* Sherlock Protocol: https://sherlock.xyz\\n/******************************************************************************/\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\ninterface IStrategy {\\n  function want() external view returns (ERC20);\\n\\n  function withdrawAll() external returns (uint256);\\n\\n  function withdraw(uint256 _amount) external;\\n\\n  function deposit() external;\\n\\n  function balanceOf() external view returns (uint256);\\n\\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"_sherlock\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlying\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ForeignLock","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000acbbe1d537bda855797776f969612df7bbb98215000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000000b4c6f636b6564205553444300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000086c6f636b55534443000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}