{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.6;\n\n\n\n// Part: IBetaOracle\n\ninterface IBetaOracle {\n  /// @dev Returns the given asset price in ETH (wei), multiplied by 2**112.\n  /// @param token The token to query for asset price\n  function getAssetETHPrice(address token) external returns (uint);\n\n  /// @dev Returns the given asset value in ETH (wei)\n  /// @param token The token to query for asset value\n  /// @param amount The amount of token to query\n  function getAssetETHValue(address token, uint amount) external returns (uint);\n\n  /// @dev Returns the conversion from amount of from` to `to`.\n  /// @param from The source token to convert.\n  /// @param to The destination token to convert.\n  /// @param amount The amount of token for conversion.\n  function convert(\n    address from,\n    address to,\n    uint amount\n  ) external returns (uint);\n}\n\n// Part: IExternalOracle\n\ninterface IExternalOracle {\n  /// @dev Returns the price in terms of ETH for the given token, multiplifed by 2**112.\n  function getETHPx(address token) external view returns (uint);\n}\n\n// Part: IUniswapV2Factory\n\ninterface IUniswapV2Factory {\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\n// Part: IUniswapV2Pair\n\ninterface IUniswapV2Pair {\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint);\n\n  function price1CumulativeLast() external view returns (uint);\n\n  function swap(\n    uint amount0Out,\n    uint amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n}\n\n// File: BetaOracleUniswapV2.sol\n\ncontract BetaOracleUniswapV2 is IBetaOracle {\n  event SetGovernor(address governor);\n  event SetPendingGovernor(address pendingGovernor);\n  event Initialize(address token);\n  event Observe(address indexed token, uint224 price);\n  event SetExternal(address indexed token, address ext);\n\n  struct Observation {\n    uint lastCumu;\n    uint224 lastPrice;\n    uint32 timestamp;\n  }\n\n  address public immutable weth;\n  address public immutable factory;\n  uint32 public immutable minTwapTime;\n\n  address public governor;\n  address public pendingGovernor;\n  mapping(address => Observation) public observations;\n  mapping(address => address) public exts;\n\n  /// @dev Initializes the oracle contract.\n  /// @param _weth WETH address.\n  /// @param _factory Uniswap V2 factory address.\n  /// @param _minTwapTime Minimum interval for TWAP time (in seconds).\n  constructor(\n    address _weth,\n    address _factory,\n    uint32 _minTwapTime\n  ) {\n    require(_weth != address(0), 'constructor/weth-zero-address');\n    require(_factory != address(0), 'constructor/factory-zero-address');\n    require(_minTwapTime != 0, 'constructor/min-twap-time-zero-value');\n    weth = _weth;\n    factory = _factory;\n    minTwapTime = _minTwapTime;\n    governor = msg.sender;\n    emit SetGovernor(msg.sender);\n  }\n\n  /// @dev Sets the next governor, which will be in effect when they accept.\n  /// @param _pendingGovernor The next governor address.\n  function setPendingGovernor(address _pendingGovernor) external {\n    require(msg.sender == governor, 'setPendingGovernor/not-governor');\n    pendingGovernor = _pendingGovernor;\n    emit SetPendingGovernor(_pendingGovernor);\n  }\n\n  /// @dev Accepts to become the next governor. Must only be called by the pending governor.\n  function acceptGovernor() external {\n    require(msg.sender == pendingGovernor, 'acceptGovernor/not-pending-governor');\n    pendingGovernor = address(0);\n    governor = msg.sender;\n    emit SetGovernor(msg.sender);\n  }\n\n  /// @dev Updates the external feed contract address for the given tokens by the governor.\n  /// @param _tokens The tokens to update external price oracle contract.\n  /// @param _ext The external price oracle contract.\n  function setExternalOracle(address[] calldata _tokens, address _ext) external {\n    require(msg.sender == governor, 'setExternalOracle/not-governor');\n    for (uint idx = 0; idx < _tokens.length; idx++) {\n      exts[_tokens[idx]] = _ext;\n      emit SetExternal(_tokens[idx], _ext);\n    }\n  }\n\n  /// @dev Initializes data points for price from pair for the given token.\n  /// @param token The token to initialize the price.\n  function initPriceFromPair(address token) public {\n    Observation storage obs = observations[token];\n    require(obs.timestamp == 0, 'initPriceFromPair/already-initialized');\n    address pair = IUniswapV2Factory(factory).getPair(token, weth);\n    obs.lastCumu = token < weth ? currentPrice0Cumu(pair) : currentPrice1Cumu(pair);\n    obs.lastPrice = 0;\n    obs.timestamp = uint32(block.timestamp);\n    emit Initialize(token);\n  }\n\n  /// @dev Utility functions to initialize multiple pair prices at once.\n  /// @param tokens Token list to mass initialize the prices.\n  function massInitPriceFromPair(address[] calldata tokens) external {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      initPriceFromPair(tokens[idx]);\n    }\n  }\n\n  /// @dev Updates price info for the given token and returns the last price.\n  /// @param token The token to update token-WETH pair price.\n  function updatePriceFromPair(address token) public returns (uint) {\n    Observation storage obs = observations[token];\n    uint32 lastObserved = obs.timestamp;\n    require(lastObserved > 0, 'updatePriceFromPair/uninitialized');\n    unchecked {\n      uint32 timeElapsed = uint32(block.timestamp) - lastObserved; // overflow is desired\n      if (timeElapsed < minTwapTime) {\n        uint lastPrice = obs.lastPrice;\n        require(lastPrice > 0, 'updatePriceFromPair/no-price');\n        return lastPrice;\n      }\n      address pair = IUniswapV2Factory(factory).getPair(token, weth);\n      uint currCumu = token < weth ? currentPrice0Cumu(pair) : currentPrice1Cumu(pair);\n      uint224 price = uint224((currCumu - obs.lastCumu) / timeElapsed); // overflow is desired\n      obs.lastPrice = price;\n      obs.lastCumu = currCumu;\n      obs.timestamp = uint32(block.timestamp);\n      emit Observe(token, price);\n      return price;\n    }\n  }\n\n  /// @dev Utility functions to update multiple pair prices at once.\n  /// @param tokens Token list to mass update prices.\n  function massUpdatePriceFromPair(address[] calldata tokens)\n    external\n    returns (uint[] memory prices)\n  {\n    prices = new uint[](tokens.length);\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      prices[idx] = updatePriceFromPair(tokens[idx]);\n    }\n  }\n\n  /// @dev Returns the price of the given asset in terms of ETH (wei), multiplied by 2**112.\n  /// @param token The token to get asset price of.\n  function getAssetETHPrice(address token) public override returns (uint) {\n    if (token == weth) {\n      return (1 << 112);\n    }\n    address ext = exts[token];\n    if (ext != address(0)) {\n      return IExternalOracle(ext).getETHPx(token);\n    }\n    return updatePriceFromPair(token);\n  }\n\n  /// @dev Returns the given asset value in ETH (wei)\n  /// @param token The token to query for asset value\n  /// @param amount The amount of token to query\n  function getAssetETHValue(address token, uint amount) external override returns (uint) {\n    uint price = getAssetETHPrice(token);\n    return (price * amount) >> 112;\n  }\n\n  /// @dev Returns the conversion from amount of from` to `to`.\n  /// @param from The source token to convert.\n  /// @param to The destination token to convert.\n  /// @param amount The amount of token for conversion.\n  function convert(\n    address from,\n    address to,\n    uint amount\n  ) external override returns (uint) {\n    uint fromPrice = getAssetETHPrice(from);\n    uint toPrice = getAssetETHPrice(to);\n    return (amount * fromPrice) / toPrice;\n  }\n\n  /// @dev Return the current price0 cumulative value on uniswap.\n  /// @param pair The uniswap pair to query for price0 cumulative value.\n  function currentPrice0Cumu(address pair) public view returns (uint price0Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    price0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n    // can use reserves without flash-manipulated risks because cumu changes if reserves change\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      unchecked {\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\n        price0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n      }\n    }\n  }\n\n  /// @dev Return the current price1 cumulative value on uniswap.\n  /// @param pair The uniswap pair to query for price1 cumulative value.\n  function currentPrice1Cumu(address pair) public view returns (uint price1Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    price1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n    // can use reserves without flash-manipulated risks because cumu changes if reserves change\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      unchecked {\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\n        price1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n      }\n    }\n  }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_minTwapTime\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"price\",\"type\":\"uint224\"}],\"name\":\"Observe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ext\",\"type\":\"address\"}],\"name\":\"SetExternal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"}],\"name\":\"SetGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernor\",\"type\":\"address\"}],\"name\":\"SetPendingGovernor\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"currentPrice0Cumu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price0Cumu\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"currentPrice1Cumu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price1Cumu\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getAssetETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAssetETHValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"initPriceFromPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"massInitPriceFromPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"massUpdatePriceFromPair\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTwapTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastCumu\",\"type\":\"uint256\"},{\"internalType\":\"uint224\",\"name\":\"lastPrice\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_ext\",\"type\":\"address\"}],\"name\":\"setExternalOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingGovernor\",\"type\":\"address\"}],\"name\":\"setPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"updatePriceFromPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BetaOracleUniswapV2","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000000000000000000000000000000000000000000e10","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}