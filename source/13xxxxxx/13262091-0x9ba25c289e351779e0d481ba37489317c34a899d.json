{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/l1/L1GovernanceRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../arbitrum/IInbox.sol\\\";\\n\\nimport \\\"./L1CrossDomainEnabled.sol\\\";\\nimport \\\"../l2/L2GovernanceRelay.sol\\\";\\n\\n// Relay a message from L1 to L2GovernanceRelay\\n// Sending L1->L2 message on arbitrum requires ETH balance. That's why this contract can receive ether.\\n// Excessive ether can be reclaimed by governance by calling reclaim function.\\n\\ncontract L1GovernanceRelay is L1CrossDomainEnabled {\\n  // --- Auth ---\\n  mapping(address => uint256) public wards;\\n\\n  function rely(address usr) external auth {\\n    wards[usr] = 1;\\n    emit Rely(usr);\\n  }\\n\\n  function deny(address usr) external auth {\\n    wards[usr] = 0;\\n    emit Deny(usr);\\n  }\\n\\n  modifier auth() {\\n    require(wards[msg.sender] == 1, \\\"L1GovernanceRelay/not-authorized\\\");\\n    _;\\n  }\\n\\n  address public immutable l2GovernanceRelay;\\n\\n  event Rely(address indexed usr);\\n  event Deny(address indexed usr);\\n\\n  constructor(address _inbox, address _l2GovernanceRelay) public L1CrossDomainEnabled(_inbox) {\\n    wards[msg.sender] = 1;\\n    emit Rely(msg.sender);\\n\\n    l2GovernanceRelay = _l2GovernanceRelay;\\n  }\\n\\n  // Allow contract to receive ether\\n  receive() external payable {}\\n\\n  // Allow governance to reclaim stored ether\\n  function reclaim(address receiver, uint256 amount) external auth {\\n    (bool sent, ) = receiver.call{value: amount}(\\\"\\\");\\n    require(sent, \\\"L1GovernanceRelay/failed-to-send-ether\\\");\\n  }\\n\\n  // Forward a call to be repeated on L2\\n  function relay(\\n    address target,\\n    bytes calldata targetData,\\n    uint256 l1CallValue,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 maxSubmissionCost\\n  ) external payable auth {\\n    bytes memory data = abi.encodeWithSelector(\\n      L2GovernanceRelay.relay.selector,\\n      target,\\n      targetData\\n    );\\n\\n    sendTxToL2NoAliasing(\\n      l2GovernanceRelay,\\n      l2GovernanceRelay, // send any excess ether to the L2 counterpart\\n      l1CallValue,\\n      maxSubmissionCost,\\n      maxGas,\\n      gasPriceBid,\\n      data\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/arbitrum/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n  function sendUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendL1FundedUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function sendL1FundedContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicket(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicketNoRefundAliasRewrite(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\n\\n  function bridge() external view returns (address);\\n\\n  function pauseCreateRetryables() external;\\n\\n  function unpauseCreateRetryables() external;\\n\\n  function startRewriteAddress() external;\\n\\n  function stopRewriteAddress() external;\\n}\\n\"\r\n    },\r\n    \"contracts/l1/L1CrossDomainEnabled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../arbitrum/IBridge.sol\\\";\\nimport \\\"../arbitrum/IInbox.sol\\\";\\nimport \\\"../arbitrum/IOutbox.sol\\\";\\n\\nabstract contract L1CrossDomainEnabled {\\n  IInbox public immutable inbox;\\n\\n  event TxToL2(address indexed from, address indexed to, uint256 indexed seqNum, bytes data);\\n\\n  constructor(address _inbox) public {\\n    inbox = IInbox(_inbox);\\n  }\\n\\n  modifier onlyL2Counterpart(address l2Counterpart) {\\n    // a message coming from the counterpart gateway was executed by the bridge\\n    address bridge = inbox.bridge();\\n    require(msg.sender == bridge, \\\"NOT_FROM_BRIDGE\\\");\\n\\n    // and the outbox reports that the L2 address of the sender is the counterpart gateway\\n    address l2ToL1Sender = IOutbox(IBridge(bridge).activeOutbox()).l2ToL1Sender();\\n    require(l2ToL1Sender == l2Counterpart, \\\"ONLY_COUNTERPART_GATEWAY\\\");\\n    _;\\n  }\\n\\n  function sendTxToL2(\\n    address target,\\n    address user,\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes memory data\\n  ) internal returns (uint256) {\\n    uint256 seqNum = inbox.createRetryableTicket{value: msg.value}(\\n      target,\\n      0, // we always assume that l2CallValue = 0\\n      maxSubmissionCost,\\n      user,\\n      user,\\n      maxGas,\\n      gasPriceBid,\\n      data\\n    );\\n    emit TxToL2(user, target, seqNum, data);\\n    return seqNum;\\n  }\\n\\n  function sendTxToL2NoAliasing(\\n    address target,\\n    address user,\\n    uint256 l1CallValue,\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes memory data\\n  ) internal returns (uint256) {\\n    uint256 seqNum = inbox.createRetryableTicketNoRefundAliasRewrite{value: l1CallValue}(\\n      target,\\n      0, // we always assume that l2CallValue = 0\\n      maxSubmissionCost,\\n      user,\\n      user,\\n      maxGas,\\n      gasPriceBid,\\n      data\\n    );\\n    emit TxToL2(user, target, seqNum, data);\\n    return seqNum;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/l2/L2GovernanceRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./L2CrossDomainEnabled.sol\\\";\\n\\n// Receive xchain message from L1 counterpart and execute given spell\\n\\ncontract L2GovernanceRelay is L2CrossDomainEnabled {\\n  address public immutable l1GovernanceRelay;\\n\\n  constructor(address _l1GovernanceRelay) public {\\n    l1GovernanceRelay = _l1GovernanceRelay;\\n  }\\n\\n  // Allow contract to receive ether\\n  receive() external payable {}\\n\\n  function relay(address target, bytes calldata targetData)\\n    external\\n    onlyL1Counterpart(l1GovernanceRelay)\\n  {\\n    (bool ok, ) = target.delegatecall(targetData);\\n    // note: even if a retryable call fails, it can be retried\\n    require(ok, \\\"L2GovernanceRelay/delegatecall-error\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/arbitrum/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IMessageProvider {\\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"contracts/arbitrum/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IBridge {\\n  event MessageDelivered(\\n    uint256 indexed messageIndex,\\n    bytes32 indexed beforeInboxAcc,\\n    address inbox,\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  );\\n\\n  event BridgeCallTriggered(\\n    address indexed outbox,\\n    address indexed destAddr,\\n    uint256 amount,\\n    bytes data\\n  );\\n\\n  event InboxToggle(address indexed inbox, bool enabled);\\n\\n  event OutboxToggle(address indexed outbox, bool enabled);\\n\\n  function deliverMessageToInbox(\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  ) external payable returns (uint256);\\n\\n  function executeCall(\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (bool success, bytes memory returnData);\\n\\n  // These are only callable by the admin\\n  function setInbox(address inbox, bool enabled) external;\\n\\n  function setOutbox(address inbox, bool enabled) external;\\n\\n  // View functions\\n\\n  function activeOutbox() external view returns (address);\\n\\n  function allowedInboxes(address inbox) external view returns (bool);\\n\\n  function allowedOutboxes(address outbox) external view returns (bool);\\n\\n  function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n  function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/arbitrum/IOutbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IOutbox {\\n  event OutboxEntryCreated(\\n    uint256 indexed batchNum,\\n    uint256 outboxEntryIndex,\\n    bytes32 outputRoot,\\n    uint256 numInBatch\\n  );\\n  event OutBoxTransactionExecuted(\\n    address indexed destAddr,\\n    address indexed l2Sender,\\n    uint256 indexed outboxEntryIndex,\\n    uint256 transactionIndex\\n  );\\n\\n  function l2ToL1Sender() external view returns (address);\\n\\n  function l2ToL1Block() external view returns (uint256);\\n\\n  function l2ToL1EthBlock() external view returns (uint256);\\n\\n  function l2ToL1Timestamp() external view returns (uint256);\\n\\n  function l2ToL1BatchNum() external view returns (uint256);\\n\\n  function l2ToL1OutputId() external view returns (bytes32);\\n\\n  function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\\n    external;\\n\\n  function outboxEntryExists(uint256 batchNum) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/l2/L2CrossDomainEnabled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../arbitrum/ArbSys.sol\\\";\\n\\nabstract contract L2CrossDomainEnabled {\\n  event TxToL1(address indexed from, address indexed to, uint256 indexed id, bytes data);\\n\\n  function sendTxToL1(\\n    address user,\\n    address to,\\n    bytes memory data\\n  ) internal returns (uint256) {\\n    // note: this method doesn't support sending ether to L1 together with a call\\n    uint256 id = ArbSys(address(100)).sendTxToL1(to, data);\\n\\n    emit TxToL1(user, to, id, data);\\n\\n    return id;\\n  }\\n\\n  modifier onlyL1Counterpart(address l1Counterpart) {\\n    require(msg.sender == applyL1ToL2Alias(l1Counterpart), \\\"ONLY_COUNTERPART_GATEWAY\\\");\\n    _;\\n  }\\n\\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n  // l1 addresses are transformed durng l1->l2 calls\\n  function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n    l2Address = address(uint160(l1Address) + offset);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/arbitrum/ArbSys.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.21 <0.7.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface ArbSys {\\n  /**\\n   * @notice Get internal version number identifying an ArbOS build\\n   * @return version number as int\\n   */\\n  function arbOSVersion() external pure returns (uint256);\\n\\n  function arbChainID() external view returns (uint256);\\n\\n  /**\\n   * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n   * @return block number as int\\n   */\\n  function arbBlockNumber() external view returns (uint256);\\n\\n  /**\\n   * @notice Send given amount of Eth to dest from sender.\\n   * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n   * @param destination recipient address on L1\\n   * @return unique identifier for this L2-to-L1 transaction.\\n   */\\n  function withdrawEth(address destination) external payable returns (uint256);\\n\\n  /**\\n   * @notice Send a transaction to L1\\n   * @param destination recipient address on L1\\n   * @param calldataForL1 (optional) calldata for L1 contract call\\n   * @return a unique identifier for this L2-to-L1 transaction.\\n   */\\n  function sendTxToL1(address destination, bytes calldata calldataForL1)\\n    external\\n    payable\\n    returns (uint256);\\n\\n  /**\\n   * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n   * @param account target account\\n   * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n   */\\n  function getTransactionCount(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice get the value of target L2 storage slot\\n   * This function is only callable from address 0 to prevent contracts from being able to call it\\n   * @param account target account\\n   * @param index target index of storage slot\\n   * @return stotage value for the given account at the given index\\n   */\\n  function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice check if current call is coming from l1\\n   * @return true if the caller of this was called directly from L1\\n   */\\n  function isTopLevelCall() external view returns (bool);\\n\\n  event EthWithdrawal(address indexed destAddr, uint256 amount);\\n\\n  event L2ToL1Transaction(\\n    address caller,\\n    address indexed destination,\\n    uint256 indexed uniqueId,\\n    uint256 indexed batchNumber,\\n    uint256 indexInBatch,\\n    uint256 arbBlockNum,\\n    uint256 ethBlockNum,\\n    uint256 timestamp,\\n    uint256 callvalue,\\n    bytes data\\n  );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_inbox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2GovernanceRelay\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"seqNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TxToL2\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"contract IInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2GovernanceRelay\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"targetData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"l1CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"L1GovernanceRelay","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004dbd4fc535ac27206064b68ffcf827b0a60bab3f00000000000000000000000010e6593cdda8c58a1d0f14c5164b376352a55f2f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}