{"status":"1","message":"OK","result":[{"SourceCode":"{\"FlatPoExtended.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {POE} from \\\"./PoE.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev These functions deal with verification of Merkle Trees proofs.\\r\\n *\\r\\n * The proofs can be generated using the JavaScript library\\r\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\r\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\r\\n *\\r\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\r\\n */\\r\\nlibrary MerkleProof {\\r\\n    /**\\r\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\r\\n     * defined by `root`. For this, a `proof` must be provided, containing\\r\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\r\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes32[] memory proof,\\r\\n        bytes32 root,\\r\\n        bytes32 leaf\\r\\n    ) internal pure returns (bool) {\\r\\n        bytes32 computedHash = leaf;\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\r\\n            bytes32 proofElement = proof[i];\\r\\n\\r\\n            if (computedHash \\u003c= proofElement) {\\r\\n                // Hash(current computed hash + current element of the proof)\\r\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\r\\n            } else {\\r\\n                // Hash(current element of the proof + current computed hash)\\r\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Check if the computed hash (root) is equal to the provided root\\r\\n        return computedHash == root;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n* @title PoExtended\\r\\n* @author Carson Case [carsonpcase@gmail.com]\\r\\n* @notice PoExtended is a POE token with owner delegated minters and a merkle claim system\\r\\n*/\\r\\nabstract contract PoExtended is POE, Ownable{\\r\\n    using MerkleProof for bytes32[];\\r\\n    /// @dev the merkle root which CAN be updated\\r\\n    address public merkleRoot;\\r\\n\\r\\n    mapping(address =\\u003e bool) approved_minters;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) POE(name_,symbol_){}\\r\\n\\r\\n    /// @dev some functions only callable by approved minters\\r\\n    modifier onlyMinter(){\\r\\n        require(approved_minters[msg.sender], \\\"must be approved by owner to call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Begin merkle root functions...\\r\\n\\r\\n    /// @dev function for owner to update merkle root\\r\\n    function updateMerkleRoot(address _new) external onlyMinter{\\r\\n        merkleRoot = _new;\\r\\n    }\\r\\n\\r\\n    /// @dev claim function. Any user can claim (and mint) with a verified merkle proof\\r\\n    function claim(bytes32[] memory proof) external{\\r\\n        bytes32 root = bytes20(merkleRoot) \\u003c\\u003c 12;\\r\\n        bytes32 leaf = bytes20(msg.sender) \\u003c\\u003c 12;\\r\\n        require(proof.verify(root,leaf), \\\"Address not eligible for claim\\\");\\r\\n        _mint(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @dev only owner can add minters\\r\\n    function addMinter(address _minter) external onlyOwner{\\r\\n        require(approved_minters[_minter] != true, \\\"Minter is already approved\\\");\\r\\n        approved_minters[_minter] = true;\\r\\n    }\\r\\n\\r\\n    /// @dev owner can remove them too\\r\\n    function removeMinter(address _minter) external onlyOwner{\\r\\n        require(approved_minters[_minter] != false, \\\"Minter is already not-approved\\\");\\r\\n        approved_minters[_minter] = false;\\r\\n    }\\r\\n\\r\\n    /// @dev A minter can forefit their minting status (useful for contracts)\\r\\n    function forefitMinterRole()external{\\r\\n        require(approved_minters[msg.sender] == true, \\\"msg.sender must be an approved minter\\\");\\r\\n        approved_minters[msg.sender] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints 1 POE token to the given address.\\r\\n     */\\r\\n    function mint(address account) external onlyMinter returns (bool) {\\r\\n        _mint(account);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Burns 1 POE token from the given address.\\r\\n     */\\r\\n    function burn(address account) external onlyOwner returns (bool) {\\r\\n        _burn(account, balanceOf(account));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Batch mint POE tokens to multiple addresses.\\r\\n     */\\r\\n    function mintMany(address[] memory accounts) external onlyMinter returns (bool) {\\r\\n        for (uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n            _mint(accounts[i]);\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    /** \\r\\n     * @dev Batch burn POE tokens from multiple addresses.\\r\\n     */\\r\\n    function burnMany(address[] memory accounts) external onlyOwner returns (bool) {\\r\\n        for (uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n            _burn(accounts[i], balanceOf(accounts[i]));\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\"},\"GovPOE.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./FlatPoExtended.sol\\\";\\r\\ncontract GovPOE is PoExtended{\\r\\n\\r\\n    /// @notice A record of each accounts delegate\\r\\n    mapping (address =\\u003e address) public delegates;\\r\\n\\r\\n    /// @notice A checkpoint for marking number of votes from a given block\\r\\n    struct Checkpoint {\\r\\n        uint32 fromBlock;\\r\\n        uint96 votes;\\r\\n    }\\r\\n\\r\\n    /// @notice A record of votes checkpoints for each account, by index\\r\\n    mapping (address =\\u003e mapping (uint32 =\\u003e Checkpoint)) public checkpoints;\\r\\n\\r\\n    /// @notice The number of checkpoints for each account\\r\\n    mapping (address =\\u003e uint32) public numCheckpoints;\\r\\n\\r\\n    /// @notice The EIP-712 typehash for the contract\\u0027s domain\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\r\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\r\\n\\r\\n    /// @notice A record of states for signing / validating signatures\\r\\n    mapping (address =\\u003e uint) public nonces;\\r\\n\\r\\n    /// @notice An event thats emitted when an account changes its delegate\\r\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\r\\n\\r\\n    /// @notice An event thats emitted when a delegate account\\u0027s vote balance changes\\r\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\r\\n\\r\\n    /**\\r\\n     * @notice Construct a new Gov token\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) PoExtended(name_,symbol_) {}\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\r\\n     * @param delegatee The address to delegate votes to\\r\\n     */\\r\\n    function delegate(address delegatee) public {\\r\\n        return _delegate(msg.sender, delegatee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegates votes from signatory to `delegatee`\\r\\n     * @param delegatee The address to delegate votes to\\r\\n     * @param nonce The contract state required to match the signature\\r\\n     * @param expiry The time at which to expire the signature\\r\\n     * @param v The recovery byte of the signature\\r\\n     * @param r Half of the ECDSA signature pair\\r\\n     * @param s Half of the ECDSA signature pair\\r\\n     */\\r\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\\r\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\\r\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\r\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\r\\n        address signatory = ecrecover(digest, v, r, s);\\r\\n        require(signatory != address(0), \\\"POE::delegateBySig: invalid signature\\\");\\r\\n        require(nonce == nonces[signatory]++, \\\"POE::delegateBySig: invalid nonce\\\");\\r\\n        require(block.timestamp \\u003c= expiry, \\\"POE::delegateBySig: signature expired\\\");\\r\\n        return _delegate(signatory, delegatee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current votes balance for `account`\\r\\n     * @param account The address to get votes balance\\r\\n     * @return The number of current votes for `account`\\r\\n     */\\r\\n    function getCurrentVotes(address account) external view returns (uint96) {\\r\\n        uint32 nCheckpoints = numCheckpoints[account];\\r\\n        return nCheckpoints \\u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine the prior number of votes for an account as of a block number\\r\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\r\\n     * @param account The address of the account to check\\r\\n     * @param blockNumber The block number to get the vote balance at\\r\\n     * @return The number of votes the account had as of the given block\\r\\n     */\\r\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\r\\n        require(blockNumber \\u003c block.number, \\\"POE::getPriorVotes: not yet determined\\\");\\r\\n\\r\\n        uint32 nCheckpoints = numCheckpoints[account];\\r\\n        if (nCheckpoints == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // First check most recent balance\\r\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \\u003c= blockNumber) {\\r\\n            return checkpoints[account][nCheckpoints - 1].votes;\\r\\n        }\\r\\n\\r\\n        // Next check implicit zero balance\\r\\n        if (checkpoints[account][0].fromBlock \\u003e blockNumber) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint32 lower = 0;\\r\\n        uint32 upper = nCheckpoints - 1;\\r\\n        while (upper \\u003e lower) {\\r\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\r\\n            Checkpoint memory cp = checkpoints[account][center];\\r\\n            if (cp.fromBlock == blockNumber) {\\r\\n                return cp.votes;\\r\\n            } else if (cp.fromBlock \\u003c blockNumber) {\\r\\n                lower = center;\\r\\n            } else {\\r\\n                upper = center - 1;\\r\\n            }\\r\\n        }\\r\\n        return checkpoints[account][lower].votes;\\r\\n    }\\r\\n\\r\\n    function _delegate(address delegator, address delegatee) internal {\\r\\n        address currentDelegate = delegates[delegator];\\r\\n        uint96 delegatorBalance = uint96(balanceOf(delegator));\\r\\n        delegates[delegator] = delegatee;\\r\\n\\r\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\r\\n\\r\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\r\\n    }\\r\\n\\r\\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\\r\\n        if (srcRep != dstRep \\u0026\\u0026 amount \\u003e 0) {\\r\\n            if (srcRep != address(0)) {\\r\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\r\\n                uint96 srcRepOld = srcRepNum \\u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\r\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"POE::_moveVotes: vote amount underflows\\\");\\r\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\r\\n            }\\r\\n\\r\\n            if (dstRep != address(0)) {\\r\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\r\\n                uint96 dstRepOld = dstRepNum \\u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\r\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"POE::_moveVotes: vote amount overflows\\\");\\r\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\r\\n      uint32 blockNumber = safe32(block.number, \\\"POE::_writeCheckpoint: block number exceeds 32 bits\\\");\\r\\n\\r\\n      if (nCheckpoints \\u003e 0 \\u0026\\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\r\\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\r\\n      } else {\\r\\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\r\\n          numCheckpoints[delegatee] = nCheckpoints + 1;\\r\\n      }\\r\\n\\r\\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\r\\n    }\\r\\n\\r\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(n \\u003c 2**32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\r\\n        require(n \\u003c 2**96, errorMessage);\\r\\n        return uint96(n);\\r\\n    }\\r\\n\\r\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\r\\n        uint96 c = a + b;\\r\\n        require(c \\u003e= a, errorMessage);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function getChainId() internal view returns (uint) {\\r\\n        uint256 chainId;\\r\\n        assembly { chainId := chainid() }\\r\\n        return chainId;\\r\\n    }\\r\\n}\\r\\n\"},\"PoE.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract POE{\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    event Transfer(address, address, uint);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The defaut value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor (string memory name_, string memory symbol_){\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() external view virtual returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() external view virtual returns (uint8) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    \\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n        require(balanceOf(account) == 0, \\\"User already holds a PoE token\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, 1);\\r\\n\\r\\n        _totalSupply += 1;\\r\\n        _balances[account] += 1;\\r\\n        emit Transfer(address(0), account, 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance \\u003e= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _balances[account] = accountBalance - amount;\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n    \\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"burnMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forefitMinterRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"mintMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GovPOE","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001250726f6f66206f66204578697374656e636500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003504f450000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://82026defb59b3f78c32b23a691cdb942b2958ee4f2707c1e72948daf9a954b0c"}]}