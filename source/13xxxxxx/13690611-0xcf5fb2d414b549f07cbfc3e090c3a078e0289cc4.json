{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-11-25\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2021-11-08\r\n*/\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.7.6;\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ncontract MerkleDistributor {\r\n  bytes32[] public merkleRoots;\r\n  bytes32 public pendingMerkleRoot;\r\n  uint256 public lastRoot;\r\n\r\n\r\n  address public constant rewardToken =0x8Ab17e2cd4F894F8641A31f99F673a5762F53c8e;\r\n  // admin address which can propose adding a new merkle root\r\n  address public proposalAuthority;\r\n  // admin address which approves or rejects a proposed merkle root\r\n  address public reviewAuthority;\r\n\r\n  event Claimed(\r\n    uint256 merkleIndex,\r\n    uint256 index,\r\n    address account,\r\n    uint256 amount\r\n  );\r\n\r\n  // This is a packed array of booleans.\r\n  mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMap;\r\n\r\n  constructor(address _proposalAuthority, address _reviewAuthority) public {\r\n    proposalAuthority = _proposalAuthority;\r\n    reviewAuthority = _reviewAuthority;\r\n  }\r\n\r\n  function setProposalAuthority(address _account) public {\r\n    require(msg.sender == proposalAuthority);\r\n    proposalAuthority = _account;\r\n  }\r\n\r\n  function setReviewAuthority(address _account) public {\r\n    require(msg.sender == reviewAuthority);\r\n    reviewAuthority = _account;\r\n  }\r\n\r\n  // we modify time between two merkle to10hrs\r\n  function proposeMerkleRoot(bytes32 _merkleRoot) public {\r\n    require(msg.sender == proposalAuthority);\r\n    require(pendingMerkleRoot == 0x00);\r\n    require(block.timestamp > lastRoot + 36000);\r\n    pendingMerkleRoot = _merkleRoot;\r\n  }\r\n\r\n  // After validating the correctness of the pending merkle root, the reviewing authority\r\n  // calls to confirm it and the distribution may begin.\r\n  function reviewPendingMerkleRoot(bool _approved) public {\r\n    require(msg.sender == reviewAuthority);\r\n    require(pendingMerkleRoot != 0x00);\r\n    if (_approved) {\r\n      merkleRoots.push(pendingMerkleRoot);\r\n      lastRoot = block.timestamp;\r\n    }\r\n    delete pendingMerkleRoot;\r\n  }\r\n\r\n  function isClaimed(uint256 merkleIndex, uint256 index)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 claimedWordIndex = index / 256;\r\n    uint256 claimedBitIndex = index % 256;\r\n    uint256 claimedWord = claimedBitMap[merkleIndex][claimedWordIndex];\r\n    uint256 mask = (1 << claimedBitIndex);\r\n    return claimedWord & mask == mask;\r\n  }\r\n\r\n  function _setClaimed(uint256 merkleIndex, uint256 index) private {\r\n    uint256 claimedWordIndex = index / 256;\r\n    uint256 claimedBitIndex = index % 256;\r\n    claimedBitMap[merkleIndex][claimedWordIndex] =\r\n      claimedBitMap[merkleIndex][claimedWordIndex] |\r\n      (1 << claimedBitIndex);\r\n  }\r\n\r\n  function claim(\r\n    uint256 merkleIndex,\r\n    uint256 index,\r\n    uint256 amount,\r\n    bytes32[] calldata merkleProof\r\n  ) external {\r\n    require(\r\n      merkleIndex < merkleRoots.length,\r\n      'MerkleDistributor: Invalid merkleIndex'\r\n    );\r\n    require(\r\n      !isClaimed(merkleIndex, index),\r\n      'MerkleDistributor: Drop already claimed.'\r\n    );\r\n\r\n    // Verify the merkle proof.\r\n    bytes32 node = keccak256(abi.encodePacked(index, msg.sender, amount));\r\n    require(\r\n      verify(merkleProof, merkleRoots[merkleIndex], node),\r\n      'MerkleDistributor: Invalid proof.'\r\n    );\r\n\r\n    // Mark it claimed and send the token.\r\n    _setClaimed(merkleIndex, index);\r\n    IERC20(rewardToken).transfer(msg.sender, amount);\r\n\r\n    emit Claimed(merkleIndex, index, msg.sender, amount);\r\n  }\r\n\r\n  function verify(\r\n    bytes32[] memory proof,\r\n    bytes32 root,\r\n    bytes32 leaf\r\n  ) internal pure returns (bool) {\r\n    bytes32 computedHash = leaf;\r\n\r\n    for (uint256 i = 0; i < proof.length; i++) {\r\n      bytes32 proofElement = proof[i];\r\n\r\n      if (computedHash <= proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == root;\r\n  }\r\n\r\n  function recoverFunds(address _token,uint256 _amount) public {\r\n    require(msg.sender == reviewAuthority);\r\n    IERC20(_token).transfer(msg.sender,_amount);\r\n    \r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposalAuthority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reviewAuthority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"proposeMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reviewAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"reviewPendingMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setProposalAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setReviewAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MerkleDistributor","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ba9ebdc5054a206b3d54d7cb7e7a5abd2810f6fe000000000000000000000000ba9ebdc5054a206b3d54d7cb7e7a5abd2810f6fe","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a4af121a5e1648ebb1882dae526924b4b1f293de24b690e01ee51b5550161b16"}]}