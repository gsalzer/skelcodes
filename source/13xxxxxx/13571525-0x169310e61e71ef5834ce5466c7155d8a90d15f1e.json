{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ninterface IEthemerals {\r\n\r\n  struct Meral {\r\n    uint16 score;\r\n    uint32 rewards;\r\n    uint16 atk;\r\n    uint16 def;\r\n    uint16 spd;\r\n  }\r\n\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n  function totalSupply() external view returns (uint256);\r\n  function changeScore(uint _tokenId, uint16 offset, bool add, uint32 amount) external;\r\n  function changeRewards(uint _tokenId, uint32 offset, bool add, uint8 action) external;\r\n  function getEthemeral(uint _tokenId) external view returns(Meral memory);\r\n}\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\ninterface IPriceFeedProvider {\r\n    /**\r\n     * Returns the latest price for a price feed.\r\n     * It reverts if the feed id is invalid: there was no price feed address provided for the given id yet\r\n     */\r\n    function getLatestPrice(uint8 _priceFeedId)\r\n        external\r\n        view\r\n        returns (int256);\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n */\r\ncontract ERC721Holder is IERC721Receiver {\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract EternalBattle is ERC721Holder {\r\n\r\n  event StakeCreated (uint indexed tokenId, uint priceFeedId, bool long);\r\n  event StakeCanceled (uint indexed tokenId, bool win);\r\n  event TokenRevived (uint indexed tokenId, uint reviver);\r\n  event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n  struct Stake {\r\n    address owner;\r\n    uint8 priceFeedId;\r\n    uint8 positionSize;\r\n    uint startingPrice;\r\n    bool long;\r\n  }\r\n\r\n  struct GamePair {\r\n    bool active;\r\n    uint16 longs;\r\n    uint16 shorts;\r\n  }\r\n\r\n  IEthemerals nftContract;\r\n  IPriceFeedProvider priceFeed;\r\n\r\n  uint16 public atkDivMod = 1800; // lower number higher multiplier\r\n  uint16 public defDivMod = 1400; // lower number higher multiplier\r\n  uint16 public spdDivMod = 400; // lower number higher multiplier\r\n  uint32 public reviverReward = 500; //500 tokens\r\n\r\n  address private admin;\r\n\r\n  // mapping tokenId to stake;\r\n  mapping (uint => Stake) private stakes;\r\n\r\n  // mapping of active longs/shorts to priceIds\r\n  mapping (uint8 => GamePair) private gamePairs;\r\n\r\n  constructor(address _nftAddress, address _priceFeedAddress) {\r\n    admin = msg.sender;\r\n    nftContract = IEthemerals(_nftAddress);\r\n    priceFeed = IPriceFeedProvider(_priceFeedAddress);\r\n  }\r\n\r\n  /**\r\n    * @dev\r\n    * sends token to contract\r\n    * requires price in range\r\n    * creates stakes struct,\r\n    */\r\n  function createStake(uint _tokenId, uint8 _priceFeedId, uint8 _positionSize, bool long) external {\r\n    require(gamePairs[_priceFeedId].active, 'not active');\r\n    uint price = uint(priceFeed.getLatestPrice(_priceFeedId));\r\n    require(price > 10000, 'pbounds');\r\n    require(_positionSize > 25 && _positionSize <= 255, 'bounds');\r\n    IEthemerals.Meral memory _meral = nftContract.getEthemeral(_tokenId);\r\n    require(_meral.rewards > reviverReward, 'needs ELF');\r\n    nftContract.safeTransferFrom(msg.sender, address(this), _tokenId);\r\n    stakes[_tokenId] = Stake(msg.sender, _priceFeedId, _positionSize, price, long);\r\n\r\n    _changeGamePair(_priceFeedId, long, true);\r\n    emit StakeCreated(_tokenId, _priceFeedId, long);\r\n  }\r\n\r\n\r\n  /**\r\n    * @dev\r\n    * adds / removes long shorts\r\n    * does not check underflow should be fine\r\n    */\r\n  function _changeGamePair(uint8 _priceFeedId, bool _long, bool _stake) internal {\r\n    GamePair memory _gamePair  = gamePairs[_priceFeedId];\r\n    if(_long) {\r\n      gamePairs[_priceFeedId].longs = _stake ? _gamePair.longs + 1 : _gamePair.longs -1;\r\n    } else {\r\n      gamePairs[_priceFeedId].shorts = _stake ? _gamePair.shorts + 1 : _gamePair.shorts -1;\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @dev\r\n    * gets price and score change\r\n    * returns token to owner\r\n    *\r\n    */\r\n  function cancelStake(uint _tokenId) external {\r\n    require(stakes[_tokenId].owner == msg.sender, 'only owner');\r\n    require(nftContract.ownerOf(_tokenId) == address(this), 'only staked');\r\n    (uint change, uint reward, bool win) = getChange(_tokenId);\r\n    nftContract.safeTransferFrom(address(this), stakes[_tokenId].owner, _tokenId);\r\n    nftContract.changeScore(_tokenId, uint16(change), win, uint32(reward)); // change in bps\r\n\r\n    _changeGamePair(stakes[_tokenId].priceFeedId, stakes[_tokenId].long, false);\r\n    emit StakeCanceled(_tokenId, win);\r\n  }\r\n\r\n  /**\r\n    * @dev\r\n    * allows second token1 to revive token0 and take rewards\r\n    * returns token1 to owner\r\n    *\r\n    */\r\n  function reviveToken(uint _id0, uint _id1) external {\r\n  require(nftContract.ownerOf(_id0) == address(this), 'only staked');\r\n    require(nftContract.ownerOf(_id1) == msg.sender, 'only owner');\r\n    // GET CHANGE\r\n    Stake storage _stake = stakes[_id0];\r\n    uint priceEnd = uint(priceFeed.getLatestPrice(_stake.priceFeedId));\r\n    IEthemerals.Meral memory _meral = nftContract.getEthemeral(_id0);\r\n    uint change = _stake.positionSize * calcBps(_stake.startingPrice, priceEnd);\r\n    bool win = _stake.long ? _stake.startingPrice < priceEnd : _stake.startingPrice > priceEnd;\r\n    change = ((change - (_meral.def * change / defDivMod)) ) / 1000; // BONUS DEF\r\n    uint scoreBefore = _meral.score;\r\n\r\n    require((win != true && scoreBefore <= (change + 35)), 'not dead');\r\n    nftContract.safeTransferFrom(address(this), stakes[_id0].owner, _id0);\r\n\r\n    if(scoreBefore < 100) {\r\n      nftContract.changeScore(_id0, uint16(100 - scoreBefore), true, 0); // reset scores to 100 // ###BUG can be NEGATIVE FIXED\r\n    } else {\r\n      nftContract.changeScore(_id0, uint16(scoreBefore - 100), false, 0); // reset scores to 100 // ###BUG can be NEGATIVE FIXED\r\n    }\r\n\r\n    nftContract.changeRewards(_id0, reviverReward, false, 1);\r\n    nftContract.changeRewards(_id1, reviverReward, true, 1);\r\n\r\n    _changeGamePair(_stake.priceFeedId, _stake.long, false);\r\n    emit TokenRevived(_id0, _id1);\r\n  }\r\n\r\n  /**\r\n    * @dev\r\n    * gets price difference in bps\r\n    * modifies the score change and rewards by atk/def/spd\r\n    * atk increase winning score change, def reduces losing score change, spd increase rewards\r\n    */\r\n  function getChange(uint _tokenId) public view returns (uint, uint, bool) {\r\n    Stake storage _stake = stakes[_tokenId];\r\n    IEthemerals.Meral memory _meral = nftContract.getEthemeral(_tokenId);\r\n    uint priceEnd = uint(priceFeed.getLatestPrice(_stake.priceFeedId));\r\n    uint reward;\r\n    bool win = _stake.long ? _stake.startingPrice < priceEnd : _stake.startingPrice > priceEnd;\r\n\r\n    uint change = _stake.positionSize * calcBps(_stake.startingPrice, priceEnd);\r\n    if(win) {\r\n      change = (_meral.atk * change / atkDivMod + change) / 1000; // BONUS ATK\r\n      // reward = (_meral.spd * change) / spdDivMod / 1000; // BONUS SPD\r\n      uint16 longs = gamePairs[stakes[_tokenId].priceFeedId].longs;\r\n      uint16 shorts = gamePairs[stakes[_tokenId].priceFeedId].shorts;\r\n      uint counterTradeBonus = 1;\r\n      if(!_stake.long && longs > shorts) {\r\n        counterTradeBonus = longs / shorts;\r\n      }\r\n      if(_stake.long && shorts > longs) {\r\n        counterTradeBonus = shorts / longs;\r\n      }\r\n      counterTradeBonus = counterTradeBonus > 5 ? 5 : counterTradeBonus;\r\n      reward = (_meral.spd * change / spdDivMod) * counterTradeBonus; // DOESNT MATCH JS WHY????\r\n\r\n    } else {\r\n      change = ((change - (_meral.def * change / defDivMod)) ) / 1000; // BONUS DEF\r\n    }\r\n    return (change, reward, win);\r\n  }\r\n\r\n  function calcBps(uint _x, uint _y) public pure returns (uint) {\r\n    // 1000 = 10% 100 = 1% 10 = 0.1% 1 = 0.01%\r\n    return _x < _y ? (_y - _x) * 10000 / _x : (_x - _y) * 10000 / _y;\r\n  }\r\n\r\n  function getStake(uint _tokenId) external view returns (Stake memory) {\r\n    return stakes[_tokenId];\r\n  }\r\n\r\n  function getGamePair(uint8 _gameIndex) external view returns (GamePair memory) {\r\n    return gamePairs[_gameIndex];\r\n  }\r\n\r\n  function resetGamePair(uint8 _gameIndex, bool _active) external onlyAdmin() { //admin\r\n    gamePairs[_gameIndex].active = _active;\r\n    gamePairs[_gameIndex].longs = 0;\r\n    gamePairs[_gameIndex].shorts = 0;\r\n  }\r\n\r\n  function cancelStakeAdmin(uint _tokenId) external onlyAdmin() { //admin\r\n    nftContract.safeTransferFrom(address(this), stakes[_tokenId].owner, _tokenId);\r\n\r\n    _changeGamePair(stakes[_tokenId].priceFeedId, stakes[_tokenId].long, false);\r\n    emit StakeCanceled(_tokenId, false);\r\n  }\r\n\r\n  function setReviverRewards(uint32 _reward) external onlyAdmin() { //admin\r\n    reviverReward = _reward;\r\n  }\r\n\r\n  function setStatsDivMod(uint16 _atkDivMod, uint16 _defDivMod, uint16 _spdDivMod) external onlyAdmin() { //admin\r\n    atkDivMod = _atkDivMod;\r\n    defDivMod = _defDivMod;\r\n    spdDivMod = _spdDivMod;\r\n  }\r\n\r\n  function transferOwnership(address newAdmin) external onlyAdmin() { //admin\r\n    admin = newAdmin;\r\n    emit OwnershipTransferred(admin, newAdmin);\r\n  }\r\n\r\n  function setPriceFeedContract(address _pfAddress) external onlyAdmin() { //admin\r\n    priceFeed = IPriceFeedProvider(_pfAddress);\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, 'admin only');\r\n    _;\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeedAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"win\",\"type\":\"bool\"}],\"name\":\"StakeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceFeedId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"long\",\"type\":\"bool\"}],\"name\":\"StakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reviver\",\"type\":\"uint256\"}],\"name\":\"TokenRevived\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"atkDivMod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_y\",\"type\":\"uint256\"}],\"name\":\"calcBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelStakeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_priceFeedId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_positionSize\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"long\",\"type\":\"bool\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defDivMod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameIndex\",\"type\":\"uint8\"}],\"name\":\"getGamePair\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"longs\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"shorts\",\"type\":\"uint16\"}],\"internalType\":\"struct EternalBattle.GamePair\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"priceFeedId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"positionSize\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"long\",\"type\":\"bool\"}],\"internalType\":\"struct EternalBattle.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_gameIndex\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"resetGamePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id1\",\"type\":\"uint256\"}],\"name\":\"reviveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reviverReward\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pfAddress\",\"type\":\"address\"}],\"name\":\"setPriceFeedContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_reward\",\"type\":\"uint32\"}],\"name\":\"setReviverRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_atkDivMod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_defDivMod\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_spdDivMod\",\"type\":\"uint16\"}],\"name\":\"setStatsDivMod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spdDivMod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EternalBattle","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ee8c0131aa6b66a2ce3cad6d2a039c1473a79a6d00000000000000000000000004302ef1c51dff4625cdec79f4400342ad27f559","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://38e5e16a07c5575053a2b05dac7b602b4c20430b1867f1a37c13ffb79db3752a"}]}