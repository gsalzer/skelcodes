{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/authorizers/RequesterAuthorizerWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../whitelist/WhitelistRolesWithAirnode.sol\\\";\\nimport \\\"./RequesterAuthorizer.sol\\\";\\nimport \\\"./interfaces/IRequesterAuthorizerWithAirnode.sol\\\";\\n\\n/// @title Authorizer contract that Airnodes can use to temporarily or\\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\\ncontract RequesterAuthorizerWithAirnode is\\n    WhitelistRolesWithAirnode,\\n    RequesterAuthorizer,\\n    IRequesterAuthorizerWithAirnode\\n{\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    )\\n        WhitelistRolesWithAirnode(_accessControlRegistry, _adminRoleDescription)\\n    {}\\n\\n    /// @notice Extends the expiration of the temporary whitelist of\\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\\n    /// whitelist expiration extender role\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function extendWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external override {\\n        require(\\n            hasWhitelistExpirationExtenderRoleOrIsAirnode(airnode, msg.sender),\\n            \\\"Not expiration extender\\\"\\n        );\\n        _extendWhitelistExpirationAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\\n    /// expiration setter role\\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function setWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external override {\\n        require(\\n            hasWhitelistExpirationSetterRoleOrIsAirnode(airnode, msg.sender),\\n            \\\"Not expiration setter\\\"\\n        );\\n        _setWhitelistExpirationAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the indefinite whitelist status of `requester` for the\\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\\n    /// whitelister role\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param status Indefinite whitelist status\\n    function setIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        bool status\\n    ) external override {\\n        require(\\n            hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, msg.sender),\\n            \\\"Not indefinite whitelister\\\"\\n        );\\n        _setIndefiniteWhitelistStatusAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            status\\n        );\\n    }\\n\\n    /// @notice Revokes the indefinite whitelist status granted by a specific\\n    /// account that no longer has the indefinite whitelister role\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param setter Setter of the indefinite whitelist status\\n    function revokeIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external override {\\n        require(\\n            !hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, setter),\\n            \\\"setter is indefinite whitelister\\\"\\n        );\\n        _revokeIndefiniteWhitelistStatusAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            setter\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/WhitelistRolesWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./WhitelistRoles.sol\\\";\\nimport \\\"./interfaces/IWhitelistRolesWithAirnode.sol\\\";\\nimport \\\"../access-control-registry/interfaces/IAccessControlRegistry.sol\\\";\\n\\n/// @title Contract that implements AccessControlRegistry roles for a whitelist\\n/// contract where each individual Airnode address is its own manager\\ncontract WhitelistRolesWithAirnode is\\n    WhitelistRoles,\\n    IWhitelistRolesWithAirnode\\n{\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    ) WhitelistRoles(_accessControlRegistry, _adminRoleDescription) {}\\n\\n    /// @notice Derives the admin role for the specific Airnode address\\n    /// @param airnode Airnode address\\n    /// @return adminRole Admin role\\n    function deriveAdminRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 adminRole)\\n    {\\n        adminRole = _deriveAdminRole(airnode);\\n    }\\n\\n    /// @notice Derives the whitelist expiration extender role for the specific\\n    /// Airnode address\\n    /// @param airnode Airnode address\\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\\n    /// role\\n    function deriveWhitelistExpirationExtenderRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 whitelistExpirationExtenderRole)\\n    {\\n        whitelistExpirationExtenderRole = _deriveWhitelistExpirationExtenderRole(\\n            airnode\\n        );\\n    }\\n\\n    /// @notice Derives the whitelist expiration setter role for the specific\\n    /// Airnode address\\n    /// @param airnode Airnode address\\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\\n    function deriveWhitelistExpirationSetterRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 whitelistExpirationSetterRole)\\n    {\\n        whitelistExpirationSetterRole = _deriveWhitelistExpirationSetterRole(\\n            airnode\\n        );\\n    }\\n\\n    /// @notice Derives the indefinite whitelister role for the specific\\n    /// Airnode address\\n    /// @param airnode Airnode address\\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\\n    function deriveIndefiniteWhitelisterRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 indefiniteWhitelisterRole)\\n    {\\n        indefiniteWhitelisterRole = _deriveIndefiniteWhitelisterRole(airnode);\\n    }\\n\\n    /// @dev Returns if the account has the whitelist expiration extender role\\n    /// or is the Airnode address\\n    /// @param airnode Airnode address\\n    /// @param account Account address\\n    /// @return If the account has the whitelist extender role or is the\\n    /// Airnode address\\n    function hasWhitelistExpirationExtenderRoleOrIsAirnode(\\n        address airnode,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            airnode == account ||\\n            IAccessControlRegistry(accessControlRegistry).hasRole(\\n                deriveWhitelistExpirationExtenderRole(airnode),\\n                account\\n            );\\n    }\\n\\n    /// @dev Returns if the account has the whitelist expriation setter role or\\n    /// is the Airnode address\\n    /// @param airnode Airnode address\\n    /// @param account Account address\\n    /// @return If the account has the whitelist setter role or is the Airnode\\n    /// address\\n    function hasWhitelistExpirationSetterRoleOrIsAirnode(\\n        address airnode,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            airnode == account ||\\n            IAccessControlRegistry(accessControlRegistry).hasRole(\\n                deriveWhitelistExpirationSetterRole(airnode),\\n                account\\n            );\\n    }\\n\\n    /// @dev Returns if the account has the indefinite whitelister role or is the\\n    /// Airnode address\\n    /// @param airnode Airnode address\\n    /// @param account Account address\\n    /// @return If the account has the indefinite whitelister role or is the\\n    /// Airnode addrss\\n    function hasIndefiniteWhitelisterRoleOrIsAirnode(\\n        address airnode,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            airnode == account ||\\n            IAccessControlRegistry(accessControlRegistry).hasRole(\\n                deriveIndefiniteWhitelisterRole(airnode),\\n                account\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/RequesterAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../whitelist/Whitelist.sol\\\";\\nimport \\\"./interfaces/IRequesterAuthorizer.sol\\\";\\n\\n/// @title Abstract contract that can be used to build Airnode authorizers that\\n/// temporarily or permanently whitelist requesters for Airnode–endpoint pairs\\nabstract contract RequesterAuthorizer is Whitelist, IRequesterAuthorizer {\\n    /// @notice Extends the expiration of the temporary whitelist of\\n    /// `requester` for the `airnode`–`endpointId` pair and emits an event\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _extendWhitelistExpirationAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        _extendWhitelistExpiration(\\n            deriveServiceId(airnode, endpointId),\\n            requester,\\n            expirationTimestamp\\n        );\\n        emit ExtendedWhitelistExpiration(\\n            airnode,\\n            endpointId,\\n            requester,\\n            msg.sender,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\\n    /// for the `airnode`–`endpointId` pair and emits an event\\n    /// @dev Unlike `_extendWhitelistExpiration()`, this can hasten expiration.\\n    /// Emits the event even if it does not change the state.\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _setWhitelistExpirationAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        _setWhitelistExpiration(\\n            deriveServiceId(airnode, endpointId),\\n            requester,\\n            expirationTimestamp\\n        );\\n        emit SetWhitelistExpiration(\\n            airnode,\\n            endpointId,\\n            requester,\\n            msg.sender,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the indefinite whitelist status of `requester` for the\\n    /// `airnode`–`endpointId` pair and emits an event\\n    /// @dev Emits the event even if it does not change the state.\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param status Indefinite whitelist status\\n    function _setIndefiniteWhitelistStatusAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        bool status\\n    ) internal {\\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\\n            deriveServiceId(airnode, endpointId),\\n            requester,\\n            status\\n        );\\n        emit SetIndefiniteWhitelistStatus(\\n            airnode,\\n            endpointId,\\n            requester,\\n            msg.sender,\\n            status,\\n            indefiniteWhitelistCount\\n        );\\n    }\\n\\n    /// @notice Revokes the indefinite whitelist status granted to `requester`\\n    /// for the `airnode`–`endpointId` pair by a specific account and emits an\\n    /// event\\n    /// @dev Only emits the event if it changes the state\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param setter Setter of the indefinite whitelist status\\n    function _revokeIndefiniteWhitelistStatusAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) internal {\\n        (\\n            bool revoked,\\n            uint192 indefiniteWhitelistCount\\n        ) = _revokeIndefiniteWhitelistStatus(\\n                deriveServiceId(airnode, endpointId),\\n                requester,\\n                setter\\n            );\\n        if (revoked) {\\n            emit RevokedIndefiniteWhitelistStatus(\\n                airnode,\\n                endpointId,\\n                requester,\\n                setter,\\n                msg.sender,\\n                indefiniteWhitelistCount\\n            );\\n        }\\n    }\\n\\n    /// @notice Returns if `requester` is whitelisted for the\\n    /// `airnode`–`endpointId` pair\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @return isWhitelisted If `requester` is whitelisted for the\\n    /// `airnode`–`endpointId` pair\\n    function requesterIsWhitelisted(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    ) public view override returns (bool isWhitelisted) {\\n        isWhitelisted = userIsWhitelisted(\\n            deriveServiceId(airnode, endpointId),\\n            requester\\n        );\\n    }\\n\\n    /// @notice Verifies the authorization status of a request\\n    /// @dev This method has redundant arguments because all authorizer\\n    /// contracts have to have the same interface and potential authorizer\\n    /// contracts may require to access the arguments that are redundant here\\n    /// @param requestId Request ID\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param sponsor Sponsor address\\n    /// @param requester Requester address\\n    /// @return Authorization status of the request\\n    function isAuthorized(\\n        bytes32 requestId, // solhint-disable-line no-unused-vars\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor, // solhint-disable-line no-unused-vars\\n        address requester\\n    ) external view override returns (bool) {\\n        return requesterIsWhitelisted(airnode, endpointId, requester);\\n    }\\n\\n    /// @notice Returns the whitelist status of `requester` for the\\n    /// `airnode`–`endpointId` pair\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @return expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    /// @return indefiniteWhitelistCount Number of times `requester` was\\n    /// whitelisted indefinitely for the `airnode`–`endpointId` pair\\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    )\\n        external\\n        view\\n        override\\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\\n    {\\n        WhitelistStatus\\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\\n                deriveServiceId(airnode, endpointId)\\n            ][requester];\\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\\n    }\\n\\n    /// @notice Returns if an account has indefinitely whitelisted `requester`\\n    /// for the `airnode`–`endpointId` pair\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param setter Address of the account that has potentially whitelisted\\n    /// `requester` for the `airnode`–`endpointId` pair indefinitely\\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\\n    /// whitelisted `requester` for the `airnode`–`endpointId` pair\\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external view override returns (bool indefiniteWhitelistStatus) {\\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\\n            deriveServiceId(airnode, endpointId)\\n        ][requester][setter];\\n    }\\n\\n    /// @notice Called privately to derive a service ID out of the Airnode\\n    /// address and the endpoint ID\\n    /// @dev This is done to re-use the more general Whitelist contract for\\n    /// the specific case of Airnode–endpoint pairs\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @return serviceId Service ID\\n    function deriveServiceId(address airnode, bytes32 endpointId)\\n        private\\n        pure\\n        returns (bytes32 serviceId)\\n    {\\n        serviceId = keccak256(abi.encodePacked(airnode, endpointId));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IRequesterAuthorizerWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../../whitelist/interfaces/IWhitelistRolesWithAirnode.sol\\\";\\nimport \\\"./IRequesterAuthorizer.sol\\\";\\n\\ninterface IRequesterAuthorizerWithAirnode is\\n    IWhitelistRolesWithAirnode,\\n    IRequesterAuthorizer\\n{}\\n\"\r\n    },\r\n    \"contracts/whitelist/WhitelistRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../access-control-registry/RoleDeriver.sol\\\";\\nimport \\\"../access-control-registry/AccessControlClient.sol\\\";\\nimport \\\"./interfaces/IWhitelistRoles.sol\\\";\\n\\n/// @title Contract that implements generic AccessControlRegistry roles for a\\n/// whitelist contract\\ncontract WhitelistRoles is RoleDeriver, AccessControlClient, IWhitelistRoles {\\n    // There are four roles implemented in this contract:\\n    // Root\\n    // └── (1) Admin (can grant and revoke the roles below)\\n    //     ├── (2) Whitelist expiration extender\\n    //     ├── (3) Whitelist expiration setter\\n    //     └── (4) Indefinite whitelister\\n    // Their IDs are derived from the descriptions below. Refer to\\n    // AccessControlRegistry for more information.\\n    string public override adminRoleDescription;\\n    string\\n        public constant\\n        override WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION =\\n        \\\"Whitelist expiration extender\\\";\\n    string\\n        public constant\\n        override WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION =\\n        \\\"Whitelist expiration setter\\\";\\n    string public constant override INDEFINITE_WHITELISTER_ROLE_DESCRIPTION =\\n        \\\"Indefinite whitelister\\\";\\n    bytes32 internal adminRoleDescriptionHash;\\n    bytes32\\n        internal constant WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH =\\n        keccak256(\\n            abi.encodePacked(WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION)\\n        );\\n    bytes32\\n        internal constant WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH =\\n        keccak256(\\n            abi.encodePacked(WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION)\\n        );\\n    bytes32 internal constant INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH =\\n        keccak256(abi.encodePacked(INDEFINITE_WHITELISTER_ROLE_DESCRIPTION));\\n\\n    /// @dev Contracts deployed with the same admin role descriptions will have\\n    /// the same roles, meaning that granting an account a role will authorize\\n    /// it in multiple contracts. Unless you want your deployed contract to\\n    /// reuse the role configuration of another contract, use a unique admin\\n    /// role description.\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    ) AccessControlClient(_accessControlRegistry) {\\n        require(\\n            bytes(_adminRoleDescription).length > 0,\\n            \\\"Admin role description empty\\\"\\n        );\\n        adminRoleDescription = _adminRoleDescription;\\n        adminRoleDescriptionHash = keccak256(\\n            abi.encodePacked(_adminRoleDescription)\\n        );\\n    }\\n\\n    /// @notice Derives the admin role for the specific manager address\\n    /// @param manager Manager address\\n    /// @return adminRole Admin role\\n    function _deriveAdminRole(address manager)\\n        internal\\n        view\\n        returns (bytes32 adminRole)\\n    {\\n        adminRole = _deriveRole(\\n            _deriveRootRole(manager),\\n            adminRoleDescriptionHash\\n        );\\n    }\\n\\n    /// @notice Derives the whitelist expiration extender role for the specific\\n    /// manager address\\n    /// @param manager Manager address\\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\\n    /// role\\n    function _deriveWhitelistExpirationExtenderRole(address manager)\\n        internal\\n        view\\n        returns (bytes32 whitelistExpirationExtenderRole)\\n    {\\n        whitelistExpirationExtenderRole = _deriveRole(\\n            _deriveAdminRole(manager),\\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\\n        );\\n    }\\n\\n    /// @notice Derives the whitelist expiration setter role for the specific\\n    /// manager address\\n    /// @param manager Manager address\\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\\n    function _deriveWhitelistExpirationSetterRole(address manager)\\n        internal\\n        view\\n        returns (bytes32 whitelistExpirationSetterRole)\\n    {\\n        whitelistExpirationSetterRole = _deriveRole(\\n            _deriveAdminRole(manager),\\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\\n        );\\n    }\\n\\n    /// @notice Derives the indefinite whitelister role for the specific\\n    /// manager address\\n    /// @param manager Manager address\\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\\n    function _deriveIndefiniteWhitelisterRole(address manager)\\n        internal\\n        view\\n        returns (bytes32 indefiniteWhitelisterRole)\\n    {\\n        indefiniteWhitelisterRole = _deriveRole(\\n            _deriveAdminRole(manager),\\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/interfaces/IWhitelistRolesWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./IWhitelistRoles.sol\\\";\\n\\ninterface IWhitelistRolesWithAirnode is IWhitelistRoles {\\n    function deriveAdminRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n\\n    function deriveWhitelistExpirationExtenderRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n\\n    function deriveWhitelistExpirationSetterRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n\\n    function deriveIndefiniteWhitelisterRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IAccessControlRegistry is IAccessControl {\\n    event InitializedManager(bytes32 indexed rootRole, address indexed manager);\\n\\n    event InitializedRole(\\n        bytes32 indexed role,\\n        bytes32 indexed adminRole,\\n        string description,\\n        address sender\\n    );\\n\\n    function initializeManager(address manager) external;\\n\\n    function initializeRole(bytes32 adminRole, string calldata description)\\n        external\\n        returns (bytes32 role);\\n\\n    function initializeAndGrantRoles(\\n        bytes32[] calldata adminRoles,\\n        string[] calldata descriptions,\\n        address[] calldata accounts\\n    ) external returns (bytes32[] memory roles);\\n\\n    function deriveRootRole(address manager)\\n        external\\n        pure\\n        returns (bytes32 rootRole);\\n\\n    function deriveRole(bytes32 adminRole, string calldata description)\\n        external\\n        pure\\n        returns (bytes32 role);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/RoleDeriver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/// @title Contract that implements the AccessControlRegistry role derivation\\n/// logic\\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\\n/// derive roles, it should inherit this contract instead of re-implementing\\n/// the logic\\ncontract RoleDeriver {\\n    /// @notice Derives the root role of the manager\\n    /// @param manager Manager address\\n    /// @return rootRole Root role\\n    function _deriveRootRole(address manager)\\n        internal\\n        pure\\n        returns (bytes32 rootRole)\\n    {\\n        rootRole = keccak256(abi.encodePacked(manager));\\n    }\\n\\n    /// @notice Derives the role using its admin role and description\\n    /// @dev This implies that roles adminned by the same role cannot have the\\n    /// same description\\n    /// @param adminRole Admin role\\n    /// @param description Human-readable description of the role\\n    /// @return role Role\\n    function _deriveRole(bytes32 adminRole, string memory description)\\n        internal\\n        pure\\n        returns (bytes32 role)\\n    {\\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\\n    }\\n\\n    /// @notice Derives the role using its admin role and description hash\\n    /// @dev This implies that roles adminned by the same role cannot have the\\n    /// same description\\n    /// @param adminRole Admin role\\n    /// @param descriptionHash Hash of the human-readable description of the\\n    /// role\\n    /// @return role Role\\n    function _deriveRole(bytes32 adminRole, bytes32 descriptionHash)\\n        internal\\n        pure\\n        returns (bytes32 role)\\n    {\\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/AccessControlClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./interfaces/IAccessControlClient.sol\\\";\\n\\ncontract AccessControlClient is IAccessControlClient {\\n    /// @notice Address of the AccessControlRegistry contract that keeps the\\n    /// roles\\n    address public immutable override accessControlRegistry;\\n\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    constructor(address _accessControlRegistry) {\\n        require(_accessControlRegistry != address(0), \\\"ACR address zero\\\");\\n        accessControlRegistry = _accessControlRegistry;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/interfaces/IWhitelistRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IWhitelistRoles {\\n    function adminRoleDescription() external view returns (string memory);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IAccessControlClient {\\n    function accessControlRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/// @title Contract that implements temporary and permanent whitelists for\\n/// multiple services identified with a hash\\n/// @notice This contract implements two kinds of whitelisting:\\n///   (1) Temporary, ends when the expiration timestamp is in the past\\n///   (2) Indefinite, ends when the indefinite whitelist count is zero\\n/// Multiple senders can idefinitely whitelist/unwhitelist independently. The\\n/// user will be considered whitelisted as long as there is at least one active\\n/// indefinite whitelisting.\\n/// @dev The interface of this contract is not implemented. It should be\\n/// inherited and its functions should be exposed with a sort of an\\n/// authorization scheme.\\ncontract Whitelist {\\n    struct WhitelistStatus {\\n        uint64 expirationTimestamp;\\n        uint192 indefiniteWhitelistCount;\\n    }\\n\\n    mapping(bytes32 => mapping(address => WhitelistStatus))\\n        internal serviceIdToUserToWhitelistStatus;\\n\\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\\n        internal serviceIdToUserToSetterToIndefiniteWhitelistStatus;\\n\\n    /// @notice Extends the expiration of the temporary whitelist of the user\\n    /// for the service\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _extendWhitelistExpiration(\\n        bytes32 serviceId,\\n        address user,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        require(\\n            expirationTimestamp >\\n                serviceIdToUserToWhitelistStatus[serviceId][user]\\n                    .expirationTimestamp,\\n            \\\"Does not extend expiration\\\"\\n        );\\n        serviceIdToUserToWhitelistStatus[serviceId][user]\\n            .expirationTimestamp = expirationTimestamp;\\n    }\\n\\n    /// @notice Sets the expiration of the temporary whitelist of the user for\\n    /// the service\\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _setWhitelistExpiration(\\n        bytes32 serviceId,\\n        address user,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        serviceIdToUserToWhitelistStatus[serviceId][user]\\n            .expirationTimestamp = expirationTimestamp;\\n    }\\n\\n    /// @notice Sets the indefinite whitelist status of the user for the\\n    /// service\\n    /// @dev As long as at least there is at least one account that has set the\\n    /// indefinite whitelist status of the user for the service as true, the\\n    /// user will be considered whitelisted.\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param status Indefinite whitelist status\\n    function _setIndefiniteWhitelistStatus(\\n        bytes32 serviceId,\\n        address user,\\n        bool status\\n    ) internal returns (uint192 indefiniteWhitelistCount) {\\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\\n            user\\n        ].indefiniteWhitelistCount;\\n        if (\\n            status &&\\n            !serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][\\n                user\\n            ][msg.sender]\\n        ) {\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                msg.sender\\n            ] = true;\\n            indefiniteWhitelistCount++;\\n            serviceIdToUserToWhitelistStatus[serviceId][user]\\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\\n        } else if (\\n            !status &&\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                msg.sender\\n            ]\\n        ) {\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                msg.sender\\n            ] = false;\\n            indefiniteWhitelistCount--;\\n            serviceIdToUserToWhitelistStatus[serviceId][user]\\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\\n        }\\n    }\\n\\n    /// @notice Revokes the indefinite whitelist status granted to the user for\\n    /// the service by a specific account\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param setter Setter of the indefinite whitelist status\\n    function _revokeIndefiniteWhitelistStatus(\\n        bytes32 serviceId,\\n        address user,\\n        address setter\\n    ) internal returns (bool revoked, uint192 indefiniteWhitelistCount) {\\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\\n            user\\n        ].indefiniteWhitelistCount;\\n        if (\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                setter\\n            ]\\n        ) {\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                setter\\n            ] = false;\\n            indefiniteWhitelistCount--;\\n            serviceIdToUserToWhitelistStatus[serviceId][user]\\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\\n            revoked = true;\\n        }\\n    }\\n\\n    /// @notice Returns if the user is whitelised to use the service\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @return isWhitelisted If the user is whitelisted\\n    function userIsWhitelisted(bytes32 serviceId, address user)\\n        internal\\n        view\\n        returns (bool isWhitelisted)\\n    {\\n        WhitelistStatus\\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\\n                serviceId\\n            ][user];\\n        return\\n            whitelistStatus.indefiniteWhitelistCount > 0 ||\\n            whitelistStatus.expirationTimestamp > block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IRequesterAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./IAuthorizer.sol\\\";\\n\\ninterface IRequesterAuthorizer is IAuthorizer {\\n    event ExtendedWhitelistExpiration(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed sender,\\n        uint256 expiration\\n    );\\n\\n    event SetWhitelistExpiration(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed sender,\\n        uint256 expiration\\n    );\\n\\n    event SetIndefiniteWhitelistStatus(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed sender,\\n        bool status,\\n        uint192 indefiniteWhitelistCount\\n    );\\n\\n    event RevokedIndefiniteWhitelistStatus(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed setter,\\n        address sender,\\n        uint192 indefiniteWhitelistCount\\n    );\\n\\n    function extendWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external;\\n\\n    function setWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external;\\n\\n    function setIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        bool status\\n    ) external;\\n\\n    function revokeIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external;\\n\\n    function requesterIsWhitelisted(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    ) external view returns (bool isWhitelisted);\\n\\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    )\\n        external\\n        view\\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\\n\\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external view returns (bool indefiniteWhitelistStatus);\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IAuthorizer {\\n    function isAuthorized(\\n        bytes32 requestId,\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accessControlRegistry\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_adminRoleDescription\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"ExtendedWhitelistExpiration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"indefiniteWhitelistCount\",\"type\":\"uint192\"}],\"name\":\"RevokedIndefiniteWhitelistStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"indefiniteWhitelistCount\",\"type\":\"uint192\"}],\"name\":\"SetIndefiniteWhitelistStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"SetWhitelistExpiration\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INDEFINITE_WHITELISTER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControlRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminRoleDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"}],\"name\":\"airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"indefiniteWhitelistStatus\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"airnodeToEndpointIdToRequesterToWhitelistStatus\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"indefiniteWhitelistCount\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveAdminRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"adminRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveIndefiniteWhitelisterRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"indefiniteWhitelisterRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveWhitelistExpirationExtenderRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"whitelistExpirationExtenderRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveWhitelistExpirationSetterRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"whitelistExpirationSetterRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"}],\"name\":\"extendWhitelistExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"requesterIsWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"}],\"name\":\"revokeIndefiniteWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setIndefiniteWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"}],\"name\":\"setWhitelistExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RequesterAuthorizerWithAirnode","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007471091fd3f158e7586a838bd70f1c7f19ca949700000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000024526571756573746572417574686f72697a6572576974684169726e6f64652061646d696e00000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}