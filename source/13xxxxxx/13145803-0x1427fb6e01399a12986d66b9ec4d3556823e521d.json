{"status":"1","message":"OK","result":[{"SourceCode":"// File: clubrare/Broker.sol\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2021-08-30\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2021-08-23\r\n*/\r\n\r\npragma solidity ^0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary TokenDetArrayLib{\r\n    // Using for array of strcutres for storing mintable address and token id \r\n    using TokenDetArrayLib for TokenDets;\r\n\r\n    struct  TokenDet {\r\n        address NFTAddress;\r\n        uint256 tokenID;\r\n    }\r\n\r\n    // custom type array TokenDets\r\n    struct TokenDets {\r\n        TokenDet[] array;\r\n    }\r\n\r\n    /**\r\n     * @notice push an tokenDet to the array\r\n     * @dev if the address already exists, it will not be added again\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function addTokenDet(TokenDets storage self,address _mintableaddress,uint256 _tokenID) public {\r\n        if(!self.exists(_mintableaddress, _tokenID)){\r\n            self.array.push(TokenDet(_mintableaddress, _tokenID));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice get the tokenDet at a specific index from array\r\n     * @dev revert if the index is out of bounds\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function getIndexByTokenDet(TokenDets storage self, address _mintableaddress,uint256 _tokenID) internal view returns(uint256, bool) {\r\n        uint256 index;\r\n        bool exists = false;\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _mintableaddress &&\r\n                self.array[i].tokenID == _tokenID\r\n            ) {\r\n                index =i;\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n        return (index, exists);\r\n    }    \r\n\r\n    /**\r\n     * @notice remove an tokenDet from the array\r\n     * @dev finds the tokenDet, swaps it with the last tokenDet, and then deletes it;\r\n     *      returns a boolean whether the tokenDet was found and deleted\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function removeTokenDet(TokenDets storage self, address _mintableaddress,uint256 _tokenID) internal returns (bool) {\r\n        \r\n            (uint256 i, bool exists)  = self.getIndexByTokenDet(_mintableaddress,_tokenID);\r\n            if (exists == true) {\r\n                self.array[i] = self.array[self.array.length - 1];\r\n                self.array.pop();\r\n                return true;\r\n            }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * @notice check if an tokenDet exist in the array\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function exists(TokenDets storage self, address _mintableaddress,uint256 _tokenID) internal view returns (bool) {\r\n        for (uint i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _mintableaddress &&\r\n                self.array[i].tokenID == _tokenID\r\n            ) {\r\n               return true;\r\n            }\r\n        }\r\n        return false;\r\n    }  \r\n}\r\n\r\n// Interface of ERC721Receiver\r\ncontract IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public returns (bytes4);\r\n}\r\n\r\n// Contract for Managing the ERC721 Holding\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// ERC721 Interface\r\ncontract MintableToken {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external;\r\n    function royalities(uint256 _tokenId) public view returns (uint256);\r\n    function creators(uint256 _tokenId) public view returns (address payable);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public;\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (address operator);\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// Broker Contract\r\ncontract Broker is ERC721Holder {\r\n    \r\n    using TokenDetArrayLib for TokenDetArrayLib.TokenDets;\r\n  \r\n    // events\r\n    event Bid(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address bidder,\r\n        uint256 amouont,\r\n        uint256 time\r\n    );\r\n    event Buy(\r\n        address indexed collection,\r\n        uint256 tokenId,\r\n        address indexed seller,\r\n        address indexed buyer,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event Collect(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address buyer,\r\n        address collector,\r\n        uint256 time\r\n    );\r\n    event OnSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event PriceUpdated(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 oldAmount,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event OffSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 time\r\n    );\r\n\r\n    address owner;\r\n    uint16 public brokerage;\r\n    mapping(address => mapping(uint256 => bool)) tokenOpenForSale;\r\n    mapping(address => TokenDetArrayLib.TokenDets) tokensForSalePerUser;\r\n    \r\n    TokenDetArrayLib.TokenDets  fixedPriceTokens;\r\n    TokenDetArrayLib.TokenDets  auctionTokens;\r\n    \r\n\r\n    //auction type :\r\n    // 1 : only direct buy\r\n    // 2 : only bid\r\n    // 3 : both buy and bid\r\n\r\n    struct auction {\r\n        address payable lastOwner;\r\n        uint256 currentBid;\r\n        address payable highestBidder;\r\n        uint256 auctionType;\r\n        uint256 startingPrice;\r\n        uint256 buyPrice;\r\n        bool buyer;\r\n        uint256 startingTime;\r\n        uint256 closingTime;\r\n    }\r\n\r\n    mapping(address => mapping(uint256 => auction)) public auctions;\r\n\r\n    TokenDetArrayLib.TokenDets  tokensForSale;\r\n\r\n    constructor(uint16 _brokerage) public {\r\n        owner = msg.sender;\r\n        brokerage = _brokerage;\r\n    }\r\n\r\n    function getTokensForSale() public view returns (TokenDetArrayLib.TokenDet[] memory) {\r\n        return tokensForSale.array;\r\n    }\r\n\r\n    function getFixedPriceTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return fixedPriceTokens.array;\r\n    }\r\n\r\n    function getAuctionTokensForSale() public view returns (TokenDetArrayLib.TokenDet[] memory) {\r\n        return auctionTokens.array;\r\n    }\r\n\r\n    function getTokensForSalePerUser(address _user)\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return tokensForSalePerUser[_user].array;\r\n    }\r\n\r\n    function setBrokerage(uint16 _brokerage) public onlyOwner {\r\n        brokerage = _brokerage;\r\n    }\r\n\r\n    function bid(uint256 tokenID, address _mintableToken) public payable {\r\n        MintableToken Token = MintableToken(_mintableToken);\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Not For Sale\"\r\n        );\r\n        require(\r\n            msg.value > auctions[_mintableToken][tokenID].currentBid,\r\n            \"Insufficient Payment\"\r\n        );\r\n        require(\r\n            block.timestamp < auctions[_mintableToken][tokenID].closingTime,\r\n            \"Auction Time Over!\"\r\n        );\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 1,\r\n            \"Auction Not For Bid\"\r\n        );\r\n\r\n        if (auctions[_mintableToken][tokenID].buyer == true) {\r\n            auctions[_mintableToken][tokenID].highestBidder.transfer(\r\n                auctions[_mintableToken][tokenID].currentBid\r\n            );\r\n        }\r\n\r\n        Token.safeTransferFrom(Token.ownerOf(tokenID), address(this), tokenID);\r\n        auctions[_mintableToken][tokenID].currentBid = msg.value;\r\n        auctions[_mintableToken][tokenID].buyer = true;\r\n        auctions[_mintableToken][tokenID].highestBidder = msg.sender;\r\n\r\n        // Bid event\r\n        emit Bid(\r\n            _mintableToken,\r\n            tokenID,\r\n            auctions[_mintableToken][tokenID].lastOwner,\r\n            msg.sender,\r\n            msg.value,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function collect(uint256 tokenID, address _mintableToken) public {\r\n        MintableToken Token = MintableToken(_mintableToken);\r\n        // Check expiry time\r\n        require(\r\n            block.timestamp > auctions[_mintableToken][tokenID].closingTime,\r\n            \"Auction Not Over!\"\r\n        );\r\n        // Get seller of the NFT\r\n        address payable lastOwner2 = auctions[_mintableToken][tokenID]\r\n            .lastOwner;\r\n        \r\n        // Check if this auction had even a single bid\r\n        if (auctions[_mintableToken][tokenID].buyer == true){\r\n            // Get royality and creator of NFT from collection\r\n            uint256 royalities = Token.royalities(tokenID);\r\n            address payable creator = Token.creators(tokenID);\r\n\r\n            // auctions[_mintableToken][tokenID].buyPrice = uint256(0);\r\n            // NFT transfer\r\n            Token.safeTransferFrom(\r\n                Token.ownerOf(tokenID),\r\n                auctions[_mintableToken][tokenID].highestBidder,\r\n                tokenID\r\n            );\r\n            // Royality transfer\r\n            creator.transfer(\r\n                (royalities * auctions[_mintableToken][tokenID].currentBid) / 10000\r\n            );\r\n            // Fund transfer after brockerage and royality charges\r\n            lastOwner2.transfer(\r\n                ((10000 - royalities - brokerage) *\r\n                    auctions[_mintableToken][tokenID].currentBid) / 10000\r\n            );\r\n\r\n            // Buy event\r\n            emit Buy(\r\n                _mintableToken,\r\n                tokenID,\r\n                lastOwner2,\r\n                auctions[_mintableToken][tokenID].highestBidder,\r\n                auctions[_mintableToken][tokenID].currentBid,\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        // Disabling the on sale status\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n        // Collect event\r\n        emit Collect(\r\n            _mintableToken,\r\n            tokenID,\r\n            lastOwner2,\r\n            auctions[_mintableToken][tokenID].highestBidder,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n\r\n        // Remove from sale list\r\n        tokensForSale.removeTokenDet(_mintableToken,tokenID);\r\n        // Remove from sale per user list\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(_mintableToken,tokenID);\r\n        // Remove form auctions list\r\n        auctionTokens.removeTokenDet(_mintableToken,tokenID);\r\n        // Delete the auction details\r\n        delete auctions[_mintableToken][tokenID];\r\n    }\r\n\r\n    function buy(uint256 tokenID, address _mintableToken) public payable {\r\n        MintableToken Token = MintableToken(_mintableToken);\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Not For Sale\"\r\n        );\r\n        require(\r\n            msg.value >= auctions[_mintableToken][tokenID].buyPrice,\r\n            \"Insufficient Payment\"\r\n        );\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 2,\r\n            \"Auction for Bid only!\"\r\n        );\r\n        address payable lastOwner2 = auctions[_mintableToken][tokenID]\r\n            .lastOwner;\r\n        uint256 royalities = Token.royalities(tokenID);\r\n        address payable creator = Token.creators(tokenID);\r\n\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n        auctions[_mintableToken][tokenID].buyer = true;\r\n        auctions[_mintableToken][tokenID].highestBidder = msg.sender;\r\n        auctions[_mintableToken][tokenID].currentBid = auctions[_mintableToken][\r\n            tokenID\r\n        ].buyPrice;\r\n\r\n        Token.safeTransferFrom(\r\n            Token.ownerOf(tokenID),\r\n            auctions[_mintableToken][tokenID].highestBidder,\r\n            tokenID\r\n        );\r\n        creator.transfer(\r\n            (royalities * auctions[_mintableToken][tokenID].currentBid) / 10000\r\n        );\r\n        lastOwner2.transfer(\r\n            ((10000 - royalities - brokerage) *\r\n                auctions[_mintableToken][tokenID].currentBid) / 10000\r\n        );\r\n\r\n        // Buy event\r\n        emit Buy(\r\n            _mintableToken,\r\n            tokenID,\r\n            lastOwner2,\r\n            msg.sender,\r\n            auctions[_mintableToken][tokenID].buyPrice,\r\n            block.timestamp\r\n        );\r\n\r\n       \r\n        tokensForSale.removeTokenDet(_mintableToken,tokenID);\r\n\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(_mintableToken,tokenID);\r\n        \r\n        fixedPriceTokens.removeTokenDet(_mintableToken,tokenID);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function putOnSale(\r\n        uint256 _tokenID,\r\n        uint256 _startingPrice,\r\n        uint256 _auctionType,\r\n        uint256 _buyPrice,\r\n        uint256 _duration,\r\n        address _mintableToken\r\n    ) public {\r\n        MintableToken Token = MintableToken(_mintableToken);\r\n        require(Token.ownerOf(_tokenID) == msg.sender, \"Permission Denied\");\r\n        require(\r\n            Token.getApproved(_tokenID) == address(this),\r\n            \"Broker Not approved\"\r\n        );\r\n        // Allow to put on sale to already on sale NFT \\\r\n        // only if it was on auction and have 0 bids and auction is over\r\n        if (tokenOpenForSale[_mintableToken][_tokenID] == true) {\r\n            require(\r\n                auctions[_mintableToken][_tokenID].auctionType == 2 \r\n                &&\r\n                auctions[_mintableToken][_tokenID].buyer == false \r\n                &&\r\n                block.timestamp > auctions[_mintableToken][_tokenID].closingTime,\r\n                \"This NFT is already on sale.\"\r\n            );\r\n        }\r\n\r\n        auction memory newAuction = auction(\r\n            msg.sender,\r\n            _startingPrice,\r\n            address(0),\r\n            _auctionType,\r\n            _startingPrice,\r\n            _buyPrice,\r\n            false,\r\n            block.timestamp,\r\n            block.timestamp + _duration\r\n        );\r\n\r\n        auctions[_mintableToken][_tokenID] = newAuction;\r\n\r\n        // Store data in all mappings if adding fresh token on sale\r\n        if (tokenOpenForSale[_mintableToken][_tokenID] == false){\r\n            tokenOpenForSale[_mintableToken][_tokenID] = true;\r\n            \r\n            tokensForSale.addTokenDet(_mintableToken, _tokenID);\r\n            tokensForSalePerUser[msg.sender].addTokenDet(_mintableToken, _tokenID);\r\n\r\n            // Add token to fixedPrice on Timed list\r\n            if (_auctionType == 1) {\r\n                fixedPriceTokens.addTokenDet(_mintableToken, _tokenID);\r\n            } else if (_auctionType == 2) {\r\n                auctionTokens.addTokenDet(_mintableToken, _tokenID);\r\n            }\r\n        }\r\n\r\n        // OnSale event\r\n        emit OnSale(\r\n            _mintableToken,\r\n            _tokenID,\r\n            msg.sender,\r\n            _auctionType,\r\n            _auctionType == 1 ? _buyPrice : _startingPrice,\r\n            block.timestamp\r\n        );\r\n\r\n    }\r\n\r\n    function updatePrice(uint256 tokenID, address _mintableToken, uint256 _newPrice) public {\r\n        MintableToken Token = MintableToken(_mintableToken);\r\n        // Sender will be owner only if no have bidded on auction.\r\n        require(\r\n            Token.ownerOf(tokenID) == msg.sender, \r\n            \"You must be owner and Token should not have any bid\"\r\n        );  \r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Must be on sale to change price\"\r\n        );\r\n        if (auctions[_mintableToken][tokenID].auctionType == 2){\r\n            require(\r\n                block.timestamp < auctions[_mintableToken][tokenID].closingTime,\r\n                \"Auction Time Over!\"\r\n            );\r\n        }\r\n        // Trigger event PriceUpdated with Old and new price\r\n        emit PriceUpdated(\r\n            _mintableToken,\r\n            tokenID,\r\n            auctions[_mintableToken][tokenID].lastOwner,\r\n            auctions[_mintableToken][tokenID].auctionType,\r\n            auctions[_mintableToken][tokenID].auctionType == 1 ? auctions[_mintableToken][tokenID].buyPrice : auctions[_mintableToken][tokenID].startingPrice,\r\n            _newPrice,\r\n            block.timestamp\r\n        );\r\n        // Update Price\r\n        if (auctions[_mintableToken][tokenID].auctionType == 1){\r\n            auctions[_mintableToken][tokenID].buyPrice = _newPrice;\r\n        }\r\n        else{\r\n            auctions[_mintableToken][tokenID].startingPrice = _newPrice;\r\n            auctions[_mintableToken][tokenID].currentBid = _newPrice;\r\n        }\r\n    }\r\n    \r\n    function putSaleOff(uint256 tokenID, address _mintableToken) public {\r\n        MintableToken Token = MintableToken(_mintableToken);\r\n        require(Token.ownerOf(tokenID) == msg.sender, \"Permission Denied\");\r\n        auctions[_mintableToken][tokenID].buyPrice = uint256(0);\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n\r\n        // OffSale event\r\n        emit OffSale(_mintableToken, tokenID, msg.sender, block.timestamp);\r\n\r\n       \r\n        tokensForSale.removeTokenDet(_mintableToken, tokenID);\r\n        \r\n      \r\n        tokensForSalePerUser[msg.sender].removeTokenDet(_mintableToken, tokenID);\r\n        // Remove token from list\r\n        if (auctions[_mintableToken][tokenID].auctionType == 1) {\r\n           \r\n            fixedPriceTokens.removeTokenDet(_mintableToken, tokenID);\r\n        } else if (auctions[_mintableToken][tokenID].auctionType == 2) {\r\n           \r\n            auctionTokens.removeTokenDet(_mintableToken, tokenID);\r\n        }\r\n    }\r\n\r\n    function getOnSaleStatus(address _mintableToken, uint256 tokenID)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return tokenOpenForSale[_mintableToken][tokenID];\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function() external payable {\r\n        //call your function here / implement your actions\r\n    }\r\n}","ABI":"[]","ContractName":"TokenDetArrayLib","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://055b8e2a6b8934c1b4954c9b93340b32f043208d81df768a264d701d4c06a48c"}]}