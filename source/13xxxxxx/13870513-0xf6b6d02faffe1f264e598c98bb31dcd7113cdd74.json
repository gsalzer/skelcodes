{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/PixelationsRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/*\\n\\n    ██████╗░██╗██╗░░██╗███████╗██╗░░░░░░█████╗░████████╗██╗░█████╗░███╗░░██╗░██████╗\\n    ██╔══██╗██║╚██╗██╔╝██╔════╝██║░░░░░██╔══██╗╚══██╔══╝██║██╔══██╗████╗░██║██╔════╝\\n    ██████╔╝██║░╚███╔╝░█████╗░░██║░░░░░███████║░░░██║░░░██║██║░░██║██╔██╗██║╚█████╗░\\n    ██╔═══╝░██║░██╔██╗░██╔══╝░░██║░░░░░██╔══██║░░░██║░░░██║██║░░██║██║╚████║░╚═══██╗\\n    ██║░░░░░██║██╔╝╚██╗███████╗███████╗██║░░██║░░░██║░░░██║╚█████╔╝██║░╚███║██████╔╝\\n    ╚═╝░░░░░╚═╝╚═╝░░╚═╝╚══════╝╚══════╝╚═╝░░╚═╝░░░╚═╝░░░╚═╝░╚════╝░╚═╝░░╚══╝╚═════╝░\\n\\n\\n    What are Pixelations?\\n\\n    Pixelations are an NFT collection of 32x32 pixelated images. There are 3,232 Pixelations,\\n    each 100% stored and rendered on-chain.\\n\\n    For this collection, we took a unique approach. Rather than designing the art ourselves,\\n    we are giving the minter the ability to provide the art. This image could be anything:\\n    an IRL photo, a painting, or a JPEG pulled off the internet.\\n\\n    How does it work?\\n\\n    Upon minting, we perform a number of image processing steps in order to viably store your\\n    image on chain, and also reduce minting gas fees as much as possible. At a high level we\\n    do the following off chain:\\n\\n    1. Convert the image into 32x32 pixels.\\n\\n    2. Extract the 32 colors that best represent the image via k-means clustering.\\n\\n    3. Compress the image via bit-packing since we now only need 5-bits to represent it's 32 colors.\\n\\n    After these off chain steps, your image is roughly 700 bytes of data that we store in\\n    our custom ERC-721 smart contract. When sites like OpenSea attempt to fetch your\\n    Pixelation's metadata and image, our contract renders an SVG at run-time.\\n\\n    ----------------------------------------------------------------------------\\n\\n    Special shoutout to Chainrunners and Blitmap for the inspiration and help.\\n    We used a lot of the same techniques in order to perform efficient rendering.\\n*/\\n\\ncontract PixelationsRenderer {\\n    struct SVGRowBuffer {\\n        string one;\\n        string two;\\n        string three;\\n        string four;\\n        string five;\\n        string six;\\n        string seven;\\n        string eight;\\n    }\\n\\n    struct SVGCursor {\\n        uint8 x;\\n        uint8 y;\\n        string color1;\\n        string color2;\\n        string color3;\\n        string color4;\\n    }\\n\\n    constructor() {}\\n\\n    // This returns the base64-encoded JSON metadata for the given token.  Metadata looks like this:\\n    //\\n    //  {\\n    //      \\\"image_data\\\": \\\"<svg>...</svg>\\\",\\n    //      \\\"name\\\": \\\"Pixelation #32\\\",\\n    //      \\\"description\\\": \\\"A 32x32 pixelated image, stored and rendered completely on chain.\\\"\\n    //  }\\n    //\\n    // As you'll see in the rest of this contract, we try to keep everything pre base64-encoded.\\n    function tokenURI(uint256 tokenId, bytes memory tokenData) public view virtual returns (string memory) {\\n        string[4] memory buffer = tokenSvgDataOf(tokenData);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,eyAgImltYWdlX2RhdGEiOiAiPHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMjAgMzIwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHNoYXBlLXJlbmRlcmluZz0nY3Jpc3BFZGdlcyc+\\\",\\n                    buffer[0],\\n                    buffer[1],\\n                    buffer[2],\\n                    buffer[3],\\n                    \\\"PHN0eWxlPnJlY3R7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDt9PC9zdHlsZT48L3N2Zz4iLCAgIm5hbWUiOiAiUGl4ZWxhdGlvbiAj\\\",\\n                    Base64.encode(uintToByteString(tokenId, 6)),\\n                    \\\"IiwgImRlc2NyaXB0aW9uIjogIkEgMzJ4MzIgcGl4ZWxhdGVkIGltYWdlLCBzdG9yZWQgYW5kIHJlbmRlcmVkIGNvbXBsZXRlbHkgb24gY2hhaW4uIn0g\\\"\\n                )\\n            );\\n    }\\n\\n    // Handy function for only rendering the svg.\\n    function tokenSVG(bytes memory tokenData) public pure returns (string memory) {\\n        string[4] memory buffer = tokenSvgDataOf(tokenData);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"PHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMjAgMzIwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHNoYXBlLXJlbmRlcmluZz0nY3Jpc3BFZGdlcyc+\\\",\\n                    buffer[0],\\n                    buffer[1],\\n                    buffer[2],\\n                    buffer[3],\\n                    \\\"PHN0eWxlPnJlY3R7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDt9PC9zdHlsZT48L3N2Zz4\\\"\\n                )\\n            );\\n    }\\n\\n    // In order to convert the Pixelations's tokenData into a valid svg, we need\\n    // to loop over every pixel, grab the color for that pixel, and generate an svg rect for\\n    // that pixel.  The difficulty is doing this in a gas efficient manner.\\n    //\\n    // The naive approach would be to store the output in a string, and continually append\\n    // svg rects to that string via abi.encodePacked.  However calling abi.encodePacked on\\n    // a successively larger output string is expensive.  And so the solution here is to\\n    // build up a series of buffers of strings.  The first buffer contains 8 strings where\\n    // each string is a single row of svg rects.  The second buffer contains 4 strings\\n    // where each string is 8 rows of svg rects (really its just the concatenation of the\\n    // previous buffer).\\n    //\\n    // At the end we return this buffer of 4 strings, and it is up to the caller to concatenate\\n    // those strings together in order to form the resulting svg.\\n    //\\n    // Shoutout to Chainrunners for the help here.\\n    function tokenSvgDataOf(bytes memory tokenData) private pure returns (string[4] memory) {\\n        SVGCursor memory cursor;\\n\\n        SVGRowBuffer memory cursorRow;\\n\\n        string[8] memory bufferOfRows;\\n        uint8 indexIntoBufferOfRows;\\n\\n        string[4] memory bufferOfEightRows;\\n        uint8 indexIntoBufferOfEightRows;\\n\\n        // base64-encoded svg coordinates from 010 to 310\\n        string[32] memory coordinateLookup = [\\n            \\\"MDAw\\\", \\\"MDEw\\\", \\\"MDIw\\\", \\\"MDMw\\\", \\\"MDQw\\\", \\\"MDUw\\\", \\\"MDYw\\\", \\\"MDcw\\\", \\\"MDgw\\\", \\\"MDkw\\\", \\\"MTAw\\\", \\\"MTEw\\\", \\\"MTIw\\\", \\\"MTMw\\\", \\\"MTQw\\\", \\\"MTUw\\\", \\\"MTYw\\\", \\\"MTcw\\\", \\\"MTgw\\\", \\\"MTkw\\\", \\\"MjAw\\\", \\\"MjEw\\\", \\\"MjIw\\\", \\\"MjMw\\\", \\\"MjQw\\\", \\\"MjUw\\\", \\\"MjYw\\\", \\\"Mjcw\\\", \\\"Mjgw\\\", \\\"Mjkw\\\", \\\"MzAw\\\", \\\"MzEw\\\"\\n        ];\\n\\n        for (uint256 dataIndex = 0; dataIndex < 1024; ) {\\n            cursor.color1 = getColor(tokenData, dataIndex, 0);\\n            cursor.color2 = getColor(tokenData, dataIndex, 1);\\n            cursor.color3 = getColor(tokenData, dataIndex, 2);\\n            cursor.color4 = getColor(tokenData, dataIndex, 3);\\n            cursorRow.one = fourPixels(coordinateLookup, cursor);\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 4);\\n            cursor.color2 = getColor(tokenData, dataIndex, 5);\\n            cursor.color3 = getColor(tokenData, dataIndex, 6);\\n            cursor.color4 = getColor(tokenData, dataIndex, 7);\\n            cursorRow.two = fourPixels(coordinateLookup, cursor);\\n\\n            dataIndex += 8;\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 0);\\n            cursor.color2 = getColor(tokenData, dataIndex, 1);\\n            cursor.color3 = getColor(tokenData, dataIndex, 2);\\n            cursor.color4 = getColor(tokenData, dataIndex, 3);\\n            cursorRow.three = fourPixels(coordinateLookup, cursor);\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 4);\\n            cursor.color2 = getColor(tokenData, dataIndex, 5);\\n            cursor.color3 = getColor(tokenData, dataIndex, 6);\\n            cursor.color4 = getColor(tokenData, dataIndex, 7);\\n            cursorRow.four = fourPixels(coordinateLookup, cursor);\\n\\n            dataIndex += 8;\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 0);\\n            cursor.color2 = getColor(tokenData, dataIndex, 1);\\n            cursor.color3 = getColor(tokenData, dataIndex, 2);\\n            cursor.color4 = getColor(tokenData, dataIndex, 3);\\n            cursorRow.five = fourPixels(coordinateLookup, cursor);\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 4);\\n            cursor.color2 = getColor(tokenData, dataIndex, 5);\\n            cursor.color3 = getColor(tokenData, dataIndex, 6);\\n            cursor.color4 = getColor(tokenData, dataIndex, 7);\\n            cursorRow.six = fourPixels(coordinateLookup, cursor);\\n\\n            dataIndex += 8;\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 0);\\n            cursor.color2 = getColor(tokenData, dataIndex, 1);\\n            cursor.color3 = getColor(tokenData, dataIndex, 2);\\n            cursor.color4 = getColor(tokenData, dataIndex, 3);\\n            cursorRow.seven = fourPixels(coordinateLookup, cursor);\\n\\n            cursor.x += 4;\\n            cursor.color1 = getColor(tokenData, dataIndex, 4);\\n            cursor.color2 = getColor(tokenData, dataIndex, 5);\\n            cursor.color3 = getColor(tokenData, dataIndex, 6);\\n            cursor.color4 = getColor(tokenData, dataIndex, 7);\\n            cursorRow.eight = fourPixels(coordinateLookup, cursor);\\n\\n            dataIndex += 8;\\n\\n            bufferOfRows[indexIntoBufferOfRows++] = string(\\n                abi.encodePacked(\\n                    cursorRow.one,\\n                    cursorRow.two,\\n                    cursorRow.three,\\n                    cursorRow.four,\\n                    cursorRow.five,\\n                    cursorRow.six,\\n                    cursorRow.seven,\\n                    cursorRow.eight\\n                )\\n            );\\n            cursor.x = 0;\\n            cursor.y += 1;\\n\\n            if (indexIntoBufferOfRows >= 8) {\\n                bufferOfEightRows[indexIntoBufferOfEightRows++] = string(\\n                    abi.encodePacked(\\n                        bufferOfRows[0],\\n                        bufferOfRows[1],\\n                        bufferOfRows[2],\\n                        bufferOfRows[3],\\n                        bufferOfRows[4],\\n                        bufferOfRows[5],\\n                        bufferOfRows[6],\\n                        bufferOfRows[7]\\n                    )\\n                );\\n                indexIntoBufferOfRows = 0;\\n            }\\n        }\\n\\n        return bufferOfEightRows;\\n    }\\n\\n    // Extracts the base64-encoded hex color for a single pixel.\\n    function getColor(\\n        bytes memory tokenData,\\n        uint256 dataIndex,\\n        uint256 offset\\n    ) internal pure returns (string memory) {\\n        uint256 pixelIndex = dataIndex + offset;\\n        uint256 indexIntoColors = getColorIndexFromPixelIndex(tokenData, pixelIndex);\\n        bytes memory rgbBytes = subBytesOfLength3(tokenData, indexIntoColors * 3 + 640);\\n\\n        uint256 n = uint256(uint8(rgbBytes[0]));\\n        n = (n << 8) + uint256(uint8(rgbBytes[1]));\\n        n = (n << 8) + uint256(uint8(rgbBytes[2]));\\n\\n        return Base64.encode(uintToHexBytes6(n));\\n    }\\n\\n    // Unpack the 5-bit value representing the color index for a given pixel. A bunch of bitwise operations\\n    // needed to pull this off. Code is confusing af, just trust me that the math works out here.\\n    function getColorIndexFromPixelIndex(bytes memory tokenData, uint256 pixelIndex) internal pure returns (uint8) {\\n        uint256 indexIntoBytes = (5 * pixelIndex) / 8;\\n        uint8 indexIntoByte = uint8((5 * pixelIndex) % 8);\\n\\n        uint8 value = 0;\\n        uint8 indexedByte = uint8(tokenData[indexIntoBytes]);\\n\\n        if (indexIntoByte >= 3) {\\n            uint8 mod = uint8(2**(8 - indexIntoByte));\\n            uint8 shift = (indexIntoByte - 3);\\n            value = (indexedByte % mod) << shift;\\n        } else {\\n            uint8 mod = (3 - indexIntoByte);\\n            value = (indexedByte >> mod) % 32;\\n        }\\n\\n        if (indexIntoByte > 3) {\\n            uint8 leftoverBits = indexIntoByte - 3;\\n            uint8 nextByte = uint8(tokenData[indexIntoBytes + 1]);\\n\\n            value += nextByte >> (8 - leftoverBits);\\n        }\\n\\n        return value;\\n    }\\n\\n    function subBytesOfLength3(bytes memory bb, uint256 startIndex) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(3);\\n        for (uint256 i = startIndex; i < startIndex + 3; i++) {\\n            result[i - startIndex] = bb[i];\\n        }\\n\\n        return result;\\n    }\\n\\n    // Rather than constructing each svg rect one at a time, let's save on gas and construct four at a time.\\n    // Unfortunately we can't construct more than four pixels at a time, otherwise we would\\n    // run into \\\"stack too deep\\\" errors at compile time.\\n    //\\n    // In order to get this to compile correctly, make sure to have the following compiler settings:\\n    //\\n    //      optimizer: {\\n    //          enabled: true,\\n    //          runs: 2000,\\n    //          details: {\\n    //              yul: true,\\n    //              yulDetails: {\\n    //                  stackAllocation: true,\\n    //                  optimizerSteps: \\\"dhfoDgvulfnTUtnIf\\\"\\n    //              }\\n    //          }\\n    //      }\\n    function fourPixels(string[32] memory coordinateLookup, SVGCursor memory pos) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"PHJlY3QgICBmaWxsPScj\\\",\\n                    pos.color1,\\n                    \\\"JyAgeD0n\\\",\\n                    coordinateLookup[pos.x],\\n                    \\\"JyAgeT0n\\\",\\n                    coordinateLookup[pos.y],\\n                    \\\"JyAvPjxyZWN0ICBmaWxsPScj\\\",\\n                    pos.color2,\\n                    \\\"JyAgeD0n\\\",\\n                    coordinateLookup[pos.x + 1],\\n                    \\\"JyAgeT0n\\\",\\n                    coordinateLookup[pos.y],\\n                    \\\"JyAvPjxyZWN0ICBmaWxsPScj\\\",\\n                    pos.color3,\\n                    \\\"JyAgeD0n\\\",\\n                    coordinateLookup[pos.x + 2],\\n                    \\\"JyAgeT0n\\\",\\n                    coordinateLookup[pos.y],\\n                    \\\"JyAvPjxyZWN0ICBmaWxsPScj\\\",\\n                    pos.color4,\\n                    \\\"JyAgeD0n\\\",\\n                    coordinateLookup[pos.x + 3],\\n                    \\\"JyAgeT0n\\\",\\n                    coordinateLookup[pos.y],\\n                    \\\"JyAgIC8+\\\"\\n                )\\n            );\\n    }\\n\\n    function uintToHexBytes6(uint256 a) public pure returns (bytes memory) {\\n        string memory str = uintToHexString2(a);\\n        if (bytes(str).length == 2) {\\n            return abi.encodePacked(\\\"0000\\\", str);\\n        } else if (bytes(str).length == 3) {\\n            return abi.encodePacked(\\\"000\\\", str);\\n        } else if (bytes(str).length == 4) {\\n            return abi.encodePacked(\\\"00\\\", str);\\n        } else if (bytes(str).length == 5) {\\n            return abi.encodePacked(\\\"0\\\", str);\\n        }\\n\\n        return bytes(str);\\n    }\\n\\n    /*\\n    Convert uint to hex string, padding to 2 hex nibbles\\n    */\\n    function uintToHexString2(uint256 a) public pure returns (string memory) {\\n        uint256 count = 0;\\n        uint256 b = a;\\n        while (b != 0) {\\n            count++;\\n            b /= 16;\\n        }\\n        bytes memory res = new bytes(count);\\n        for (uint256 i = 0; i < count; ++i) {\\n            b = a % 16;\\n            res[count - i - 1] = uintToHexDigit(uint8(b));\\n            a /= 16;\\n        }\\n\\n        string memory str = string(res);\\n        if (bytes(str).length == 0) {\\n            return \\\"00\\\";\\n        } else if (bytes(str).length == 1) {\\n            return string(abi.encodePacked(\\\"0\\\", str));\\n        }\\n        return str;\\n    }\\n\\n    function uintToHexDigit(uint8 d) public pure returns (bytes1) {\\n        if (0 <= d && d <= 9) {\\n            return bytes1(uint8(bytes1(\\\"0\\\")) + d);\\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\\n            return bytes1(uint8(bytes1(\\\"a\\\")) + d - 10);\\n        }\\n        revert();\\n    }\\n\\n    function uintToByteString(uint256 a, uint256 fixedLen) internal pure returns (bytes memory _uintAsString) {\\n        uint256 j = a;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(fixedLen);\\n        j = fixedLen;\\n        if (a == 0) {\\n            bstr[0] = \\\"0\\\";\\n            len = 1;\\n        }\\n        while (j > len) {\\n            j = j - 1;\\n            bstr[j] = bytes1(\\\" \\\");\\n        }\\n        uint256 k = len;\\n        while (a != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(a - (a / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            a /= 10;\\n        }\\n        return bstr;\\n    }\\n}\\n\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tokenData\",\"type\":\"bytes\"}],\"name\":\"tokenSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tokenData\",\"type\":\"bytes\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"uintToHexBytes6\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"d\",\"type\":\"uint8\"}],\"name\":\"uintToHexDigit\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"uintToHexString2\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"PixelationsRenderer","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"0","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}