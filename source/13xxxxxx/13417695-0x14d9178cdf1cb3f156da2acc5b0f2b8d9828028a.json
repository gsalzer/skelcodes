{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/IFO/FixPrice.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../ProxyClones/OwnableForClones.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n\\n    ✩░▒▓▆▅▃▂▁𝐌𝐞𝐭𝐚𝐆𝐚𝐦𝐞𝐇𝐮𝐛▁▂▃▅▆▓▒░✩\\n\\n*/\\n\\n\\ncontract MGHPublicOffering is OwnableForClones {\\n\\n  // chainlink impl. to get any kind of pricefeed\\n  AggregatorV3Interface internal priceFeed;\\n\\n  // The LP token used\\n  IERC20 public lpToken;\\n\\n  // The offering token\\n  IERC20 public offeringToken;\\n\\n  // The block number when IFO starts\\n  uint256 public startBlock;\\n\\n  // The block number when IFO ends\\n  uint256 public endBlock;\\n\\n  //after this block harvesting is possible\\n  uint256 private harvestBlock;\\n\\n  // maps the user-address to the deposited amount in that Pool\\n  mapping(address => uint256) private amount;\\n\\n  // amount of tokens offered for the pool (in offeringTokens)\\n  uint256 private offeringAmount;\\n\\n  // price in MGH/USDT => for 1 MGH/USDT price would be 10**12; 10MGH/USDT would be 10**13\\n  uint256 private _price;\\n\\n  // total amount deposited in the Pool (in LP tokens); resets when new Start and EndBlock are set\\n  uint256 private totalAmount;\\n\\n  // Admin withdraw event\\n  event AdminWithdraw(uint256 amountLP, uint256 amountOfferingToken, uint256 amountWei);\\n\\n  // Admin recovers token\\n  event AdminTokenRecovery(address tokenAddress, uint256 amountTokens);\\n\\n  // Deposit event\\n  event Deposit(address indexed user, uint256 amount);\\n\\n  // Harvest event\\n  event Harvest(address indexed user, uint256 offeringAmount);\\n\\n  // Event for new start & end blocks\\n  event NewStartAndEndBlocks(uint256 startBlock, uint256 endBlock);\\n\\n  // parameters are set for the pool\\n  event PoolParametersSet(uint256 offeringAmount, uint256 price);\\n\\n  // timeLock ensures that users have enough time to harvest before Admin withdraws tokens,\\n  // sets new Start and EndBlocks or changes Pool specifications\\n  modifier timeLock() {\\n    require(block.number > harvestBlock + 10000, \\\"admin must wait before calling this function\\\");\\n    _;\\n  }\\n\\n  /**\\n    * @dev It can only be called once.\\n    * @param _lpToken the LP token used\\n    * @param _offeringToken the token that is offered for the IFO\\n    * @param _offeringAmount amount without decimals\\n    * @param __price the price in OfferingToken/LPToken adjusted already by 6 decimal places\\n    * @param _startBlock start of sale time\\n    * @param _endBlock end of sale time\\n    * @param _harvestBlock start of harvest time\\n    * @param _adminAddress the admin address\\n  */\\n  function initialize(\\n    address _lpToken,\\n    address _offeringToken,\\n    address _priceFeed,\\n    address _adminAddress,\\n    uint256 _offeringAmount,\\n    uint256 __price,\\n    uint256 _startBlock,\\n    uint256 _endBlock,\\n    uint256 _harvestBlock\\n    )\\n    external initializer\\n    {\\n    __Ownable_init();\\n    lpToken = IERC20(_lpToken);\\n    offeringToken = IERC20(_offeringToken);\\n    priceFeed = AggregatorV3Interface(_priceFeed);\\n    setPool(_offeringAmount*10**18, __price*10**6);\\n    updateStartAndEndBlocks(_startBlock, _endBlock, _harvestBlock);\\n    transferOwnership(_adminAddress);\\n  }\\n\\n  /**\\n    * @notice It allows users to deposit LP tokens opr ether to pool\\n    * @param _amount: the number of LP token used (6 decimals)\\n  */\\n  function deposit(uint256 _amount) external payable {\\n\\n    // Checks whether the block number is not too early\\n    require(block.number > startBlock && block.number < endBlock, \\\"Not sale time\\\");\\n\\n    // Transfers funds to this contract\\n    if (_amount > 0) {\\n      require(lpToken.transferFrom(address(msg.sender), address(this), _amount));\\n  \\t}\\n    // Updates the totalAmount for pool\\n    if (msg.value > 0) {\\n      _amount += uint256(getLatestEthPrice()) * msg.value / 1e20;\\n    }\\n    totalAmount += _amount;\\n\\n    // if its pool1, check if new total amount will be smaller or equal to OfferingAmount / price\\n    require(\\n      offeringAmount >= totalAmount * _price,\\n      \\\"not enough tokens left\\\"\\n    );\\n\\n    // Update the user status\\n    amount[msg.sender] += _amount;\\n\\n    emit Deposit(msg.sender, _amount);\\n  }\\n\\n  /**\\n    * @notice It allows users to harvest from pool\\n    * @notice if user is not whitelisted and the whitelist is active, the user is refunded in lpTokens\\n  */\\n  function harvest() external {\\n    // buffer time between end of deposit and start of harvest for admin to whitelist (~7 hours)\\n    require(block.number > harvestBlock, \\\"Too early to harvest\\\");\\n\\n    // Checks whether the user has participated\\n    require(amount[msg.sender] > 0, \\\"already harvested\\\");\\n\\n    // Initialize the variables for offering and refunding user amounts\\n    uint256 offeringTokenAmount = _calculateOfferingAmount(msg.sender);\\n\\n    amount[msg.sender] = 0;\\n\\n    require(offeringToken.transfer(address(msg.sender), offeringTokenAmount));\\n\\n    emit Harvest(msg.sender, offeringTokenAmount);\\n  }\\n\\n\\n  /**\\n    * @notice It allows the admin to withdraw funds\\n    * @notice the offering token can only be withdrawn 10000 blocks after harvesting\\n    * @param _lpAmount: the number of LP token to withdraw (18 decimals)\\n    * @param _offerAmount: the number of offering amount to withdraw\\n    * @param _weiAmount: the amount of Wei to withdraw\\n    * @dev This function is only callable by admin.\\n  */\\n  function finalWithdraw(uint256 _lpAmount, uint256 _offerAmount, uint256 _weiAmount) external  onlyOwner {\\n\\n    if (_lpAmount > 0) {\\n      lpToken.transfer(address(msg.sender), _lpAmount);\\n    }\\n\\n    if (_offerAmount > 0) {\\n      require(block.number > harvestBlock + 10000, \\\"too early to withdraw offering token\\\");\\n      offeringToken.transfer(address(msg.sender), _offerAmount);\\n    }\\n\\n    if (_weiAmount > 0) {\\n      payable(address(msg.sender)).transfer(_weiAmount);\\n    }\\n\\n    emit AdminWithdraw(_lpAmount, _offerAmount, _weiAmount);\\n  }\\n\\n  /**\\n    * @notice It allows the admin to recover wrong tokens sent to the contract\\n    * @param _tokenAddress: the address of the token to withdraw (18 decimals)\\n    * @param _tokenAmount: the number of token amount to withdraw\\n    * @dev This function is only callable by admin.\\n  */\\n  function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\\n    require(_tokenAddress != address(lpToken), \\\"Cannot be LP token\\\");\\n    require(_tokenAddress != address(offeringToken), \\\"Cannot be offering token\\\");\\n\\n    IERC20(_tokenAddress).transfer(address(msg.sender), _tokenAmount);\\n\\n    emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\\n  }\\n\\n  /**\\n    * @notice timeLock\\n    * @notice It sets parameters for pool\\n    * @param _offeringAmount offering amount with all decimals\\n    * @dev This function is only callable by admin\\n  */\\n  function setPool(\\n    uint256 _offeringAmount,\\n    uint256 __price\\n   ) public onlyOwner timeLock\\n   {\\n    offeringAmount = _offeringAmount;\\n    _price = __price;\\n    emit PoolParametersSet(_offeringAmount, _price);\\n  }\\n\\n  /**\\n    * @notice It allows the admin to update start and end blocks\\n    * @notice automatically resets the totalAmount in the Pool to 0, but not userAmounts\\n    * @notice timeLock\\n    * @param _startBlock: the new start block\\n    * @param _endBlock: the new end block\\n  */\\n  function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock, uint256 _harvestBlock) public onlyOwner timeLock {\\n    require(_startBlock < _endBlock, \\\"New startBlock must be lower than new endBlock\\\");\\n    require(block.number < _startBlock, \\\"New startBlock must be higher than current block\\\");\\n    totalAmount = 0;\\n    startBlock = _startBlock;\\n    endBlock = _endBlock;\\n    harvestBlock = _harvestBlock;\\n\\n    emit NewStartAndEndBlocks(_startBlock, _endBlock);\\n  }\\n\\n  /**\\n    * @notice It returns the pool information\\n    * @return offeringAmountPool: amount of tokens offered for the pool (in offeringTokens)\\n    * @return _price the price in OfferingToken/LPToken, 10**12 means 1:1 because of different decimal places\\n    * @return totalAmountPool: total amount pool deposited (in LP tokens)\\n  */\\n  function viewPoolInformation()\\n    external\\n    view\\n    returns(\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n    {\\n    return (\\n      offeringAmount,\\n      _price,\\n      totalAmount\\n    );\\n  }\\n\\n  /**\\n    * @notice External view function to see user amount in pool\\n    * @param _user: user address\\n  */\\n  function viewUserAmount(address _user)\\n    external\\n    view\\n    returns(uint256)\\n  {\\n    return (amount[_user]);\\n  }\\n\\n  /**\\n    * @notice External view function to see user offering amounts\\n    * @param _user: user address\\n  */\\n  function viewUserOfferingAmount(address _user)\\n    external\\n    view\\n    returns(uint256)\\n  {\\n    return _calculateOfferingAmount(_user);\\n  }\\n\\n  /**\\n    * @notice It calculates the offering amount for a user and the number of LP tokens to transfer back.\\n    * @param _user: user address\\n    * @return the amount of OfferingTokens _user receives as of now\\n  */\\n  function _calculateOfferingAmount(address _user)\\n    internal\\n    view\\n    returns(uint256)\\n  {\\n    return amount[_user] * _price;\\n  }\\n\\n  function setToken(address _lpToken, address _offering) public onlyOwner timeLock {\\n    lpToken = IERC20(_lpToken);\\n    offeringToken = IERC20(_offering);\\n  }\\n\\n  /**\\n    * @return returns the price from the AggregatorV3 contract specified in initialization \\n  */\\n  function getLatestEthPrice() public view returns(int) {\\n    (\\n      uint80 roundID,\\n      int price,\\n      uint startedAt,\\n      uint timeStamp,\\n      uint80 answeredInRound\\n    ) = priceFeed.latestRoundData();\\n    return price;\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/ProxyClones/OwnableForClones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ContextForClones.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableForClones is ContextForClones {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ProxyClones/ContextForClones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextForClones is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"/contracts/IFO/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n  );\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOfferingToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"AdminWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offeringAmount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"NewStartAndEndBlocks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offeringAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PoolParametersSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"finalWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestEthPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_offeringToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offeringAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"__price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_harvestBlock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offeringToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offeringAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"__price\",\"type\":\"uint256\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_offering\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_harvestBlock\",\"type\":\"uint256\"}],\"name\":\"updateStartAndEndBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolInformation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserOfferingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MGHPublicOffering","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}