{"status":"1","message":"OK","result":[{"SourceCode":"{\"Hash.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\n/**\\n  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.\\n  Also to produce / verify hashed and signed Orders.\\n  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\\n  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\\n*/\\n\\nlibrary Hash {\\n  /// @dev struct represents the attributes of an offchain Swivel.Order\\n  struct Order {\\n    bytes32 key;\\n    address maker;\\n    address underlying;\\n    bool vault;\\n    bool exit;\\n    uint256 principal;\\n    uint256 premium;\\n    uint256 maturity;\\n    uint256 expiry;\\n  }\\n\\n  // EIP712 Domain Separator typeHash\\n  // keccak256(abi.encodePacked(\\n  //     \\u0027EIP712Domain(\\u0027,\\n  //     \\u0027string name,\\u0027,\\n  //     \\u0027string version,\\u0027,\\n  //     \\u0027uint256 chainId,\\u0027,\\n  //     \\u0027address verifyingContract\\u0027,\\n  //     \\u0027)\\u0027\\n  // ));\\n  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n  // EIP712 typeHash of an Order \\n  // keccak256(abi.encodePacked(\\n  //     \\u0027Order(\\u0027,\\n  //     \\u0027bytes32 key,\\u0027,\\n  //     \\u0027address maker,\\u0027,\\n  //     \\u0027address underlying,\\u0027,\\n  //     \\u0027bool vault,\\u0027,\\n  //     \\u0027bool exit,\\u0027,\\n  //     \\u0027uint256 principal,\\u0027,\\n  //     \\u0027uint256 premium,\\u0027,\\n  //     \\u0027uint256 maturity,\\u0027,\\n  //     \\u0027uint256 expiry\\u0027,\\n  //     \\u0027)\\u0027\\n  // ));\\n  bytes32 constant internal ORDER_TYPEHASH = 0x7ddd38ab5ed1c16b61ca90eeb9579e29da1ba821cf42d8cdef8f30a31a6a4146;\\n\\n  /// @param n EIP712 domain name\\n  /// @param version EIP712 semantic version string\\n  /// @param i Chain ID\\n  /// @param verifier address of the verifying contract\\n  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {\\n    bytes32 hash;\\n\\n    assembly {\\n      let nameHash := keccak256(add(n, 32), mload(n))\\n      let versionHash := keccak256(add(version, 32), mload(version))\\n      let pointer := mload(64)\\n      mstore(pointer, DOMAIN_TYPEHASH)\\n      mstore(add(pointer, 32), nameHash)\\n      mstore(add(pointer, 64), versionHash)\\n      mstore(add(pointer, 96), i)\\n      mstore(add(pointer, 128), verifier)\\n      hash := keccak256(pointer, 160)\\n    }\\n\\n    return hash;\\n  }\\n\\n  /// @param d Type hash of the domain separator (see Hash.domain)\\n  /// @param h EIP712 hash struct (order for example)\\n  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {\\n    bytes32 hash;\\n\\n    assembly {\\n      let pointer := mload(64)\\n      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n      mstore(add(pointer, 2), d)\\n      mstore(add(pointer, 34), h)\\n      hash := keccak256(pointer, 66)\\n    }\\n\\n    return hash;\\n  }\\n\\n  /// @param o A Swivel Order\\n  function order(Order calldata o) internal pure returns (bytes32) {\\n    // TODO assembly\\n    return keccak256(abi.encode(\\n      ORDER_TYPEHASH,\\n      o.key,\\n      o.maker,\\n      o.underlying,\\n      o.vault,\\n      o.exit,\\n      o.principal,\\n      o.premium,\\n      o.maturity,\\n      o.expiry\\n    ));\\n  }\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\ninterface Erc20 {\\n\\tfunction approve(address, uint256) external returns (bool);\\n\\tfunction transfer(address, uint256) external returns (bool);\\n\\tfunction balanceOf(address) external returns (uint256);\\n\\tfunction transferFrom(address, address, uint256) external returns (bool);\\n}\\n\\ninterface CErc20 {\\n\\tfunction mint(uint256) external returns (uint256);\\n\\tfunction redeemUnderlying(uint256) external returns (uint256);\\n}\\n\\ninterface MarketPlace {\\n  // adds notional and mints zctokens\\n  function mintZcTokenAddingNotional(address, uint256, address, uint256) external returns (bool);\\n  // removes notional and burns zctokens\\n  function burnZcTokenRemovingNotional(address, uint256, address, uint256) external returns (bool);\\n  // returns the amount of underlying principal to send\\n  function redeemZcToken(address, uint256, address, uint256) external returns (uint256);\\n  // returns the amount of underlying interest to send\\n  function redeemVaultInterest(address, uint256, address) external returns (uint256);\\n  // returns the cToken address for a given market\\n  function cTokenAddress(address, uint256) external returns (address);\\n  // EVFZE FF EZFVE call this which would then burn zctoken and remove notional\\n  function custodialExit(address, uint256, address, address, uint256) external returns (bool);\\n  // IVFZI \\u0026\\u0026 IZFVI call this which would then mint zctoken and add notional\\n  function custodialInitiate(address, uint256, address, address, uint256) external returns (bool);\\n  // IZFZE \\u0026\\u0026 EZFZI call this, tranferring zctoken from one party to another\\n  function p2pZcTokenExchange(address, uint256, address, address, uint256) external returns (bool);\\n  // IVFVE \\u0026\\u0026 EVFVI call this, removing notional from one party and adding to the other\\n  function p2pVaultExchange(address, uint256, address, address, uint256) external returns (bool);\\n  // IVFZI \\u0026\\u0026 IVFVE call this which then transfers notional from msg.sender (taker) to swivel\\n  function transferVaultNotionalFee(address, uint256, address, uint256) external returns (bool);\\n}\\n\"},\"Safe.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\\npragma solidity 0.8.4;\\n\\nimport {Erc20} from \\\"./Interfaces.sol\\\";\\n/**\\n  @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n  @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n  @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n*/\\n\\nlibrary Safe {\\n  /// @param e Erc20 token to execute the call with\\n  /// @param t To address\\n  /// @param a Amount being transferred\\n  function approve(Erc20 e, address t, uint256 a) internal {\\n    bool result;\\n\\n    assembly {\\n      // Get a pointer to some free memory.\\n      let pointer := mload(0x40)\\n\\n      // Write the abi-encoded calldata to memory piece by piece:\\n      mstore(pointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n      mstore(add(pointer, 4), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n      mstore(add(pointer, 36), a) // Finally append the \\\"amount\\\" argument. No mask as it\\u0027s a full 32 byte value.\\n\\n      // Call the token and store if it succeeded or not.\\n      // We use 68 because the calldata length is 4 + 32 * 2.\\n      result := call(gas(), e, 0, pointer, 68, 0, 0)\\n    }\\n\\n    require(success(result), \\\"approve failed\\\");\\n  }\\n\\n  /// @param e Erc20 token to execute the call with\\n  /// @param t To address\\n  /// @param a Amount being transferred\\n  function transfer(Erc20 e, address t, uint256 a) internal {\\n    bool result;\\n\\n    assembly {\\n      // Get a pointer to some free memory.\\n      let pointer := mload(0x40)\\n\\n      // Write the abi-encoded calldata to memory piece by piece:\\n      mstore(pointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n      mstore(add(pointer, 4), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n      mstore(add(pointer, 36), a) // Finally append the \\\"amount\\\" argument. No mask as it\\u0027s a full 32 byte value.\\n\\n      // Call the token and store if it succeeded or not.\\n      // We use 68 because the calldata length is 4 + 32 * 2.\\n      result := call(gas(), e, 0, pointer, 68, 0, 0)\\n    }\\n\\n    require(success(result), \\\"transfer failed\\\");\\n  }\\n\\n  /// @param e Erc20 token to execute the call with\\n  /// @param f From address\\n  /// @param t To address\\n  /// @param a Amount being transferred\\n  function transferFrom(Erc20 e, address f, address t, uint256 a) internal {\\n    bool result;\\n\\n    assembly {\\n      // Get a pointer to some free memory.\\n      let pointer := mload(0x40)\\n\\n      // Write the abi-encoded calldata to memory piece by piece:\\n      mstore(pointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n      mstore(add(pointer, 4), and(f, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n      mstore(add(pointer, 36), and(t, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n      mstore(add(pointer, 68), a) // Finally append the \\\"amount\\\" argument. No mask as it\\u0027s a full 32 byte value.\\n\\n      // Call the token and store if it succeeded or not.\\n      // We use 100 because the calldata length is 4 + 32 * 3.\\n      result := call(gas(), e, 0, pointer, 100, 0, 0)\\n    }\\n\\n    require(success(result), \\\"transfer from failed\\\");\\n  }\\n\\n  /// @notice normalize the acceptable values of true or null vs the unacceptable value of false (or something malformed)\\n  /// @param r Return value from the assembly `call()` to Erc20[\\u0027selector\\u0027]\\n  function success(bool r) private pure returns (bool) {\\n    bool result;\\n\\n    assembly {\\n      // Get how many bytes the call returned.\\n      let returnDataSize := returndatasize()\\n\\n      // If the call reverted:\\n      if iszero(r) {\\n        // Copy the revert message into memory.\\n        returndatacopy(0, 0, returnDataSize)\\n\\n        // Revert with the same message.\\n        revert(0, returnDataSize)\\n      }\\n\\n      switch returnDataSize\\n      case 32 {\\n        // Copy the return data into memory.\\n        returndatacopy(0, 0, returnDataSize)\\n\\n        // Set success to whether it returned true.\\n        result := iszero(iszero(mload(0)))\\n      }\\n      case 0 {\\n        // There was no return data.\\n        result := 1\\n      }\\n      default {\\n        // It returned some malformed input.\\n        result := 0\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\"},\"Sig.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\nlibrary Sig {\\n  /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature\\n  struct Components {\\n    uint8 v;  \\n    bytes32 r;\\n    bytes32 s;\\n  }\\n\\n  /// @param h Hashed data which was originally signed\\n  /// @param c signature struct containing V,R and S\\n  /// @return The recovered address\\n  function recover(bytes32 h, Components calldata c) internal pure returns (address) {\\n    // EIP-2 and malleable signatures...\\n    // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n    require(uint256(c.s) \\u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\u0027invalid signature \\\"s\\\" value\\u0027);\\n    require(c.v == 27 || c.v == 28, \\u0027invalid signature \\\"v\\\" value\\u0027);\\n\\n    return ecrecover(h, c.v, c.r, c.s);\\n  }\\n\\n  /// @param h Hashed data which was originally signed\\n  /// @param sig Valid ECDSA signature\\n  /// @dev splitAndRecover should only be used if it is known that the resulting \\n  /// verifying bit (V) will be 27 || 28. Otherwise use recover, possibly calling split first.\\n  /// @return The recovered address\\n  function splitAndRecover(bytes32 h, bytes memory sig) internal pure returns (address) {\\n    (uint8 v, bytes32 r, bytes32 s) = split(sig);\\n\\n    return ecrecover(h, v, r, s);\\n  }\\n\\n  /// @param sig Valid ECDSA signature\\n  /// @return v The verification bit\\n  /// @return r First 32 bytes\\n  /// @return s Next 32 bytes\\n  function split(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {\\n    require(sig.length == 65, \\u0027invalid signature length\\u0027);\\n\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n\\n    assembly {\\n      r := mload(add(sig, 32))\\n      s := mload(add(sig, 64))\\n      v := byte(0, mload(add(sig, 96)))\\n    }\\n\\n    return (v, r, s);\\n  }\\n}\\n\"},\"Swivel.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\nimport \\u0027./Interfaces.sol\\u0027;\\nimport \\u0027./Hash.sol\\u0027;\\nimport \\u0027./Sig.sol\\u0027;\\nimport \\u0027./Safe.sol\\u0027;\\n\\ncontract Swivel {\\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\\n  mapping (bytes32 =\\u003e bool) public cancelled;\\n  /// @dev maps the key of an order to an amount representing its taken volume\\n  mapping (bytes32 =\\u003e uint256) public filled;\\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\\n  mapping (address =\\u003e uint256) public withdrawals;\\n\\n  string constant public NAME = \\u0027Swivel Finance\\u0027;\\n  string constant public VERSION = \\u00272.0.0\\u0027;\\n  uint256 constant public HOLD = 3 days;\\n  bytes32 public immutable domain;\\n  address public immutable marketPlace;\\n  address public admin;\\n  uint16 constant public MIN_FEENOMINATOR = 33;\\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\\n  uint16[4] public feenominators;\\n\\n  /// @notice Emitted on order cancellation\\n  event Cancel (bytes32 indexed key, bytes32 hash);\\n  /// @notice Emitted on any initiate*\\n  /// @dev filled is \\u0027principalFilled\\u0027 when (vault:false, exit:false) \\u0026\\u0026 (vault:true, exit:true)\\n  /// @dev filled is \\u0027premiumFilled\\u0027 when (vault:true, exit:false) \\u0026\\u0026 (vault:false, exit:true)\\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\\n  /// @notice Emitted on any exit*\\n  /// @dev filled is \\u0027principalFilled\\u0027 when (vault:false, exit:false) \\u0026\\u0026 (vault:true, exit:true)\\n  /// @dev filled is \\u0027premiumFilled\\u0027 when (vault:true, exit:false) \\u0026\\u0026 (vault:false, exit:true)\\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\\n  /// @notice Emitted on token withdrawal scheduling\\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\\n  /// @notice Emitted on token withdrawal blocking\\n  event BlockWithdrawal(address indexed token);\\n  /// @notice Emitted on a change to the feenominators array\\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\\n\\n  /// @param m deployed MarketPlace contract address\\n  constructor(address m) {\\n    admin = msg.sender;\\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\\n    marketPlace = m;\\n    feenominators = [200, 600, 400, 200];\\n  }\\n\\n  // ********* INITIATING *************\\n\\n  /// @notice Allows a user to initiate a position\\n  /// @param o Array of offline Swivel.Orders\\n  /// @param a Array of order volume (principal) amounts relative to passed orders\\n  /// @param c Array of Components from valid ECDSA signatures\\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\\n    uint256 len = o.length;\\n    // for each order filled, routes the order to the right interaction depending on its params\\n    for (uint256 i; i \\u003c len; i++) {\\n      Hash.Order memory order = o[i];\\n      if (!order.exit) {\\n        if (!order.vault) {\\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\\n        } else {\\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\\n        }\\n      } else {\\n        if (!order.vault) {\\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\\n        } else {\\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (premium) being filled by the taker\\u0027s initiate\\n  /// @param c Components of a valid ECDSA signature\\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    // checks order signature, order cancellation and order expiry\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    // checks the side, and the amount compared to available\\n    require((a + filled[hash]) \\u003c= o.premium, \\u0027taker amount \\u003e available volume\\u0027);\\n    \\n    filled[hash] += a;\\n\\n    // transfer underlying tokens\\n    Erc20 uToken = Erc20(o.underlying);\\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\\n\\n    uint256 principalFilled = (a * o.principal) / o.premium;\\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\\n\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    // mint tokens\\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(principalFilled) == 0, \\u0027minting CToken failed\\u0027);\\n    // alert marketplace\\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), \\u0027custodial initiate failed\\u0027);\\n\\n    // transfer fee in vault notional to swivel (from msg.sender)\\n    uint256 fee = principalFilled / feenominators[2];\\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \\u0027notional fee transfer failed\\u0027);\\n\\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\\n  }\\n\\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (principal) being filled by the taker\\u0027s initiate\\n  /// @param c Components of a valid ECDSA signature\\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.principal, \\u0027taker amount \\u003e available volume\\u0027);\\n\\n    filled[hash] += a;\\n\\n    Erc20 uToken = Erc20(o.underlying);\\n\\n    uint256 premiumFilled = (a * o.premium) / o.principal;\\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\\n\\n    // transfer principal + fee in underlying to swivel (from sender)\\n    uint256 fee = premiumFilled / feenominators[0];\\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\\n\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    // mint tokens\\n    require(CErc20(mPlace.cTokenAddress(o.underlying, o.maturity)).mint(a) == 0, \\u0027minting CToken Failed\\u0027);\\n    // alert marketplace \\n    require(mPlace.custodialInitiate(o.underlying, o.maturity, msg.sender, o.maker, a), \\u0027custodial initiate failed\\u0027);\\n\\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\\n  }\\n\\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (principal) being filled by the taker\\u0027s initiate \\n  /// @param c Components of a valid ECDSA signature\\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.principal, \\u0027taker amount \\u003e available volume\\u0027);\\n\\n    filled[hash] += a;\\n\\n    uint256 premiumFilled = (a * o.premium) / o.principal;\\n\\n    Erc20 uToken = Erc20(o.underlying);\\n    // transfer underlying tokens, then take fee\\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\\n\\n    uint256 fee = premiumFilled / feenominators[0];\\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\\n\\n    // alert marketplace\\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), \\u0027zcToken exchange failed\\u0027);\\n            \\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\\n  }\\n\\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (interest) being filled by the taker\\u0027s exit\\n  /// @param c Components of a valid ECDSA signature\\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.premium, \\u0027taker amount \\u003e available volume\\u0027);\\n\\n    filled[hash] += a;\\n\\n    Safe.transferFrom(Erc20(o.underlying), msg.sender, o.maker, a);\\n\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    uint256 principalFilled = (a * o.principal) / o.premium;\\n    // alert marketplace\\n    require(mPlace.p2pVaultExchange(o.underlying, o.maturity, o.maker, msg.sender, principalFilled), \\u0027vault exchange failed\\u0027);\\n\\n    // transfer fee (in vault notional) to swivel\\n    uint256 fee = principalFilled / feenominators[2];\\n    require(mPlace.transferVaultNotionalFee(o.underlying, o.maturity, msg.sender, fee), \\\"notional fee transfer failed\\\");\\n\\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\\n  }\\n\\n  // ********* EXITING ***************\\n\\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\\n  /// @param o Array of offline Swivel.Orders\\n  /// @param a Array of order volume (principal) amounts relative to passed orders\\n  /// @param c Components of a valid ECDSA signature\\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\\n    uint256 len = o.length;\\n    // for each order filled, routes the order to the right interaction depending on its params\\n    for (uint256 i; i \\u003c len; i++) {\\n      Hash.Order memory order = o[i];\\n      // if the order being filled is not an exit\\n      if (!order.exit) {\\n        // if the order being filled is a vault initiate or a zcToken initiate\\n          if (!order.vault) {\\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\\n          } else {\\n            // if filling a vault initiate with an exit, one is exiting vault notional\\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\\n          }\\n      } else {\\n        // if the order being filled is a vault exit or a zcToken exit\\n        if (!order.vault) {\\n          // if filling a zcToken exit with an exit, one is exiting vault\\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\\n        } else {\\n          // if filling a vault exit with an exit, one is exiting zcTokens\\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\\n        }   \\n      }   \\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (interest) being filled by the taker\\u0027s exit\\n  /// @param c Components of a valid ECDSA signature\\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.premium, \\u0027taker amount \\u003e available volume\\u0027);\\n\\n    filled[hash] += a;       \\n\\n    Erc20 uToken = Erc20(o.underlying);\\n\\n    uint256 principalFilled = (a * o.principal) / o.premium;\\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\\n    Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\\n\\n    // transfer fee in underlying to swivel\\n    uint256 fee = principalFilled / feenominators[1];\\n    Safe.transferFrom(uToken, o.maker, address(this), fee);\\n\\n    // alert marketplace\\n    require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), \\u0027zcToken exchange failed\\u0027);\\n\\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\\n  }\\n  \\n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (principal) being filled by the taker\\u0027s exit\\n  /// @param c Components of a valid ECDSA signature\\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.principal, \\u0027taker amount \\u003e available volume\\u0027);\\n    \\n    filled[hash] += a;\\n        \\n    Erc20 uToken = Erc20(o.underlying);\\n\\n    // transfer premium from maker to sender\\n    uint256 premiumFilled = (a * o.premium) / o.principal;\\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\\n\\n    uint256 fee = premiumFilled / feenominators[3];\\n    // transfer fee in underlying to swivel from sender\\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\\n\\n    // transfer \\u003ca\\u003e notional from sender to maker\\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), \\u0027vault exchange failed\\u0027);\\n\\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\\n  }\\n\\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (principal) being filled by the taker\\u0027s exit\\n  /// @param c Components of a valid ECDSA signature\\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.principal, \\u0027taker amount \\u003e available volume\\u0027);\\n\\n    filled[hash] += a;\\n\\n    // redeem underlying on Compound and burn cTokens\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \\\"compound redemption error\\\");\\n\\n    Erc20 uToken = Erc20(o.underlying);\\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\\n    uint256 premiumFilled = (a * o.premium) / o.principal;\\n    Safe.transfer(uToken, o.maker, a - premiumFilled);\\n\\n    // transfer premium-fee to floating exit party\\n    uint256 fee = premiumFilled / feenominators[3];\\n    Safe.transfer(uToken, msg.sender, premiumFilled - fee);\\n\\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\\n    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), \\u0027custodial exit failed\\u0027);\\n\\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\\n  }\\n\\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\\n  /// @param o Order being filled\\n  /// @param a Amount of volume (interest) being filled by the taker\\u0027s exit\\n  /// @param c Components of a valid ECDSA signature\\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require((a + filled[hash]) \\u003c= o.premium, \\u0027taker amount \\u003e available volume\\u0027);\\n    \\n    filled[hash] += a;\\n\\n    // redeem underlying on Compound and burn cTokens\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n\\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\\n    uint256 principalFilled = (a * o.principal) / o.premium;\\n    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), \\\"compound redemption error\\\");\\n\\n    Erc20 uToken = Erc20(o.underlying);\\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\\n    uint256 fee = principalFilled / feenominators[1];\\n    Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\\n    Safe.transfer(uToken, o.maker, a);\\n\\n    // burn \\u003cprincipalFilled\\u003e zcTokens + nTokens from msg.sender and o.maker respectively\\n    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), \\u0027custodial exit failed\\u0027);\\n\\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\\n  }\\n\\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\\n  /// @param o Order being cancelled\\n  /// @param c Components of a valid ECDSA signature\\n  function cancel(Hash.Order calldata o, Sig.Components calldata c) external returns (bool) {\\n    bytes32 hash = validOrderHash(o, c);\\n\\n    require(msg.sender == o.maker, \\u0027sender must be maker\\u0027);\\n\\n    cancelled[hash] = true;\\n\\n    emit Cancel(o.key, hash);\\n\\n    return true;\\n  }\\n\\n  // ********* ADMINISTRATIVE ***************\\n\\n  /// @param a Address of a new admin\\n  function transferAdmin(address a) external authorized(admin) returns (bool) {\\n    admin = a;\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows the admin to schedule the withdrawal of tokens\\n  /// @param e Address of (erc20) token to withdraw\\n  function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\\n    uint256 when = block.timestamp + HOLD;\\n    withdrawals[e] = when;\\n\\n    emit ScheduleWithdrawal(e, when);\\n\\n    return true;\\n  }\\n\\n  /// @notice Emergency function to block unplanned withdrawals\\n  /// @param e Address of token withdrawal to block\\n  function blockWithdrawal(address e) external authorized(admin) returns (bool) {\\n      withdrawals[e] = 0;\\n\\n      emit BlockWithdrawal(e);\\n\\n      return true;\\n  }\\n\\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\\n  /// @param e Address of token to withdraw\\n  function withdraw(address e) external authorized(admin) returns (bool) {\\n    uint256 when = withdrawals[e];\\n    require (when != 0, \\u0027no withdrawal scheduled\\u0027);\\n\\n    require (block.timestamp \\u003e= when, \\u0027withdrawal still on hold\\u0027);\\n\\n    withdrawals[e] = 0;\\n\\n    Erc20 token = Erc20(e);\\n    Safe.transfer(token, admin, token.balanceOf(address(this)));\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows the admin to set a new fee denominator\\n  /// @param i The index of the new fee denominator\\n  /// @param d The new fee denominator\\n  function setFee(uint16 i, uint16 d) external authorized(admin) returns (bool) {\\n    require(d \\u003e= MIN_FEENOMINATOR, \\u0027fee too high\\u0027);\\n\\n    feenominators[i] = d;\\n\\n    emit SetFee(i, d);\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows the admin to bulk approve given compound addresses at the underlying token, saving marginal approvals\\n  /// @param u array of underlying token addresses\\n  /// @param c array of compound token addresses\\n  function approveUnderlying(address[] calldata u, address[] calldata c) external authorized(admin) returns (bool) {\\n    uint256 len = u.length;\\n    require (len == c.length, \\u0027array length mismatch\\u0027);\\n\\n    uint256 max = 2**256 - 1;\\n\\n    for (uint256 i; i \\u003c len; i++) {\\n      Erc20 uToken = Erc20(u[i]);\\n      Safe.approve(uToken, c[i], max);\\n    }\\n\\n    return true;\\n  }\\n\\n  // ********* PROTOCOL UTILITY ***************\\n\\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \\n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param a Amount of underlying being deposited\\n  function splitUnderlying(address u, uint256 m, uint256 a) external returns (bool) {\\n    Erc20 uToken = Erc20(u);\\n    Safe.transferFrom(uToken, msg.sender, address(this), a);\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    require(CErc20(mPlace.cTokenAddress(u, m)).mint(a) == 0, \\u0027minting CToken Failed\\u0027);\\n    require(mPlace.mintZcTokenAddingNotional(u, m, msg.sender, a), \\u0027mint ZcToken adding Notional failed\\u0027);\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\\n  /// in the process \\\"combining\\\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param a Amount of zcTokens being redeemed\\n  function combineTokens(address u, uint256 m, uint256 a) external returns (bool) {\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    require(mPlace.burnZcTokenRemovingNotional(u, m, msg.sender, a), \\u0027burn ZcToken removing Notional failed\\u0027);\\n    address cTokenAddr = mPlace.cTokenAddress(u, m);\\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \\\"compound redemption error\\\");\\n    Safe.transfer(Erc20(u), msg.sender, a);\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param a Amount of zcTokens being redeemed\\n  function redeemZcToken(address u, uint256 m, uint256 a) external returns (bool) {\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    // call marketplace to determine the amount redeemed\\n    uint256 redeemed = mPlace.redeemZcToken(u, m, msg.sender, a);\\n    // redeem underlying from compound\\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, \\u0027compound redemption failed\\u0027);\\n    // transfer underlying back to msg.sender\\n    Safe.transfer(Erc20(u), msg.sender, redeemed);\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  function redeemVaultInterest(address u, uint256 m) external returns (bool) {\\n    MarketPlace mPlace = MarketPlace(marketPlace);\\n    // call marketplace to determine the amount redeemed\\n    uint256 redeemed = mPlace.redeemVaultInterest(u, m, msg.sender);\\n    // redeem underlying from compound\\n    require(CErc20(mPlace.cTokenAddress(u, m)).redeemUnderlying(redeemed) == 0, \\u0027compound redemption failed\\u0027);\\n    // transfer underlying back to msg.sender\\n    Safe.transfer(Erc20(u), msg.sender, redeemed);\\n\\n    return true;\\n  }\\n\\n  /// @notice Varifies the validity of an order and it\\u0027s signature.\\n  /// @param o An offline Swivel.Order\\n  /// @param c Components of a valid ECDSA signature\\n  /// @return the hashed order.\\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\\n    bytes32 hash = Hash.order(o);\\n\\n    require(!cancelled[hash], \\u0027order cancelled\\u0027);\\n    require(o.expiry \\u003e= block.timestamp, \\u0027order expired\\u0027);\\n    require(o.maker == Sig.recover(Hash.message(domain, hash), c), \\u0027invalid signature\\u0027);\\n\\n    return hash;\\n  }\\n\\n  modifier authorized(address a) {\\n    require(msg.sender == a, \\u0027sender must be authorized\\u0027);\\n    _;\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"BlockWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"filled\",\"type\":\"uint256\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"filled\",\"type\":\"uint256\"}],\"name\":\"Initiate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hold\",\"type\":\"uint256\"}],\"name\":\"ScheduleWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"feenominator\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEENOMINATOR\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"u\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"c\",\"type\":\"address[]\"}],\"name\":\"approveUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"name\":\"blockWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Hash.Order\",\"name\":\"o\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Sig.Components\",\"name\":\"c\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"combineTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Hash.Order[]\",\"name\":\"o\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Sig.Components[]\",\"name\":\"c\",\"type\":\"tuple[]\"}],\"name\":\"exit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feenominators\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Hash.Order[]\",\"name\":\"o\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Sig.Components[]\",\"name\":\"c\",\"type\":\"tuple[]\"}],\"name\":\"initiate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPlace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"redeemVaultInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"redeemZcToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"name\":\"scheduleWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"i\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"d\",\"type\":\"uint16\"}],\"name\":\"setFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"splitUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Swivel","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"15000","ConstructorArguments":"000000000000000000000000998689650d4d55822b4bdd4b7db5f596bf6b3570","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://399cfcee4297233bd3ab15dc3390dcea90e5d7b9fd69c351dfc659b989cc5b29"}]}