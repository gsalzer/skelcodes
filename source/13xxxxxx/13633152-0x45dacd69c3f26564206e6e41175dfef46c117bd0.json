{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n\r\nlibrary Address {\r\n\tfunction isContract(address account) internal view returns(bool) {\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data) internal returns(bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns(bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns(bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns(bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\tfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns(bytes memory) {\r\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns(bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {\r\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns(bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nlibrary Strings {\r\n\tbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n\tfunction toString(uint256 value) internal pure returns(string memory) {\r\n\t\tif (value == 0) {\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\tfunction toHexString(uint256 value) internal pure returns(string memory) {\r\n\t\tif (value == 0) {\r\n\t\t\treturn \"0x00\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 length = 0;\r\n\t\twhile (temp != 0) {\r\n\t\t\tlength++;\r\n\t\t\ttemp >>= 8;\r\n\t\t}\r\n\t\treturn toHexString(value, length);\r\n\t}\r\n\r\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns(string memory) {\r\n\t\tbytes memory buffer = new bytes(2 * length + 2);\r\n\t\tbuffer[0] = \"0\";\r\n\t\tbuffer[1] = \"x\";\r\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\t\t\tbuffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n\t\t\tvalue >>= 4;\r\n\t\t}\r\n\t\trequire(value == 0, \"Strings: hex length insufficient\");\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns(address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns(bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n\r\ninterface IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceId) external view returns(bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\r\n\tfunction balanceOf(address owner) external view returns(uint256 balance);\r\n\r\n\tfunction ownerOf(uint256 tokenId) external view returns(address owner);\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\r\n\tfunction getApproved(uint256 tokenId) external view returns(address operator);\r\n\r\n\tfunction setApprovalForAll(address operator, bool _approved) external;\r\n\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns(bool);\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IERC721Receiver {\r\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n\tfunction name() external view returns(string memory);\r\n\r\n\tfunction symbol() external view returns(string memory);\r\n\r\n\tfunction tokenURI(uint256 tokenId) external view returns(string memory);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns(bool) {\r\n\t\treturn interfaceId == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns(uint256);\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) external view returns(uint256);\r\n}\r\n\r\n\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n\tusing Address for address;\r\n\tusing Strings for uint256;\r\n\r\n\tstring private _name;\r\n\tstring private _symbol;\r\n\r\n\tmapping(uint256 => address) private _owners;\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(uint256 => address) private _tokenApprovals;\r\n\tmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n\tconstructor(string memory name_, string memory symbol_) {\r\n\t\t_name = name_;\r\n\t\t_symbol = symbol_;\r\n\t}\r\n\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns(bool) {\r\n\t\treturn\r\n\t\t\tinterfaceId == type(IERC721).interfaceId ||\r\n\t\t\tinterfaceId == type(IERC721Metadata).interfaceId ||\r\n\t\t\tsuper.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) public view virtual override returns(uint256) {\r\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns(address) {\r\n\t\taddress owner = _owners[tokenId];\r\n\t\trequire(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction name() public view virtual override returns(string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol() public view virtual override returns(string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns(string memory) {\r\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n\t\tstring memory baseURI = _baseURI();\r\n\t\treturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n\t}\r\n\r\n\tfunction _baseURI() internal view virtual returns(string memory) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tfunction approve(address to, uint256 tokenId) public virtual override {\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\r\n\r\n\t\trequire(\r\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\r\n\t\t);\r\n\r\n\t\t_approve(to, tokenId);\r\n\t}\r\n\r\n\tfunction getApproved(uint256 tokenId) public view virtual override returns(address) {\r\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n\t\treturn _tokenApprovals[tokenId];\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\r\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns(bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n\t\t//solhint-disable-next-line max-line-length\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\t\t_safeTransfer(from, to, tokenId, _data);\r\n\t}\r\n\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\t\t_transfer(from, to, tokenId);\r\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t}\r\n\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns(bool) {\r\n\t\treturn _owners[tokenId] != address(0);\r\n\t}\r\n\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns(bool) {\r\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n\t\t_safeMint(to, tokenId, \"\");\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\t\t_mint(to, tokenId);\r\n\r\n\t\trequire(\r\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\r\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\r\n\t\t);\r\n\t}\r\n\r\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\r\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\r\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\r\n\t\temit Transfer(address(0), to, tokenId);\r\n\t}\r\n\r\n\tfunction _burn(uint256 tokenId) internal virtual {\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\r\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\t_balances[owner] -= 1;\r\n\t\tdelete _owners[tokenId];\r\n\r\n\t\temit Transfer(owner, address(0), tokenId);\r\n\t}\r\n\r\n\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n\t\trequire(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(from, to, tokenId);\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\t_balances[from] -= 1;\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\r\n\t\t_tokenApprovals[tokenId] = to;\r\n\t\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n\t}\r\n\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns(bool) {\r\n\t\tif (to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns(bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif (reason.length == 0) {\r\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from,address to,uint256 tokenId) internal virtual {}\r\n}\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n\tmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\tmapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n\tuint256[] private _allTokens;\r\n\tmapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns(bool) {\r\n\t\treturn interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns(uint256) {\r\n\t\trequire(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n\t\treturn _ownedTokens[owner][index];\r\n\t}\r\n\r\n\tfunction totalSupply() public view virtual override returns(uint256) {\r\n\t\treturn _allTokens.length;\r\n\t}\r\n\r\n\tfunction tokenByIndex(uint256 index) public view virtual override returns(uint256) {\r\n\t\trequire(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n\t\treturn _allTokens[index];\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from,address to,uint256 tokenId) internal virtual override {\r\n\t\tsuper._beforeTokenTransfer(from, to, tokenId);\r\n\r\n\t\tif (from == address(0)) {\r\n\t\t\t_addTokenToAllTokensEnumeration(tokenId);\r\n\t\t} else if (from != to) {\r\n\t\t\t_removeTokenFromOwnerEnumeration(from, tokenId);\r\n\t\t}\r\n\t\tif (to == address(0)) {\r\n\t\t\t_removeTokenFromAllTokensEnumeration(tokenId);\r\n\t\t} else if (to != from) {\r\n\t\t\t_addTokenToOwnerEnumeration(to, tokenId);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n\t\tuint256 length = ERC721.balanceOf(to);\r\n\t\t_ownedTokens[to][length] = tokenId;\r\n\t\t_ownedTokensIndex[tokenId] = length;\r\n\t}\r\n\r\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n\t\t_allTokensIndex[tokenId] = _allTokens.length;\r\n\t\t_allTokens.push(tokenId);\r\n\t}\r\n\r\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n\t\tuint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n\t\tuint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n\t\tif (tokenIndex != lastTokenIndex) {\r\n\t\t\tuint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n\t\t\t_ownedTokens[from][tokenIndex] = lastTokenId;\r\n\t\t\t_ownedTokensIndex[lastTokenId] = tokenIndex;\r\n\t\t}\r\n\r\n\t\tdelete _ownedTokensIndex[tokenId];\r\n\t\tdelete _ownedTokens[from][lastTokenIndex];\r\n\t}\r\n\r\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n\t\tuint256 lastTokenIndex = _allTokens.length - 1;\r\n\t\tuint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n\t\tuint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n\t\t_allTokens[tokenIndex] = lastTokenId;\r\n\t\t_allTokensIndex[lastTokenId] = tokenIndex;\r\n\r\n\t\tdelete _allTokensIndex[tokenId];\r\n\t\t_allTokens.pop();\r\n\t}\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// NFT Contract\r\n\r\ncontract OneEyeIsland is ERC721Enumerable, Ownable {\r\n\tusing Strings for uint256;\r\n\r\n\tstring private baseURI;\r\n\tstring private unrevealedURI;\r\n\tbool public paused;\r\n\tbool public revealed;\r\n\tuint256 public cost;\r\n\tuint256 public maxSupply;\r\n\tuint256 public maxMintAmount;\r\n\r\n\tmapping(address => uint16) private freeMints;\r\n\r\n\tevent Mint(address minter, address indexed to, uint256 amount, uint256 timestmap);\r\n\r\n\r\n\tconstructor(string memory _initbaseURI, string memory _initunrevealedURI) ERC721(\"One Eye Island\", \"OEI\") {\r\n\t\tcost = 0.07 ether;\r\n\t\tmaxSupply = 7000;\r\n\t\tmaxMintAmount = 10;\r\n\t\tpaused = true;\r\n\t\trevealed = false;\r\n\r\n\t\tsetBaseURI(_initbaseURI);\r\n\t\tsetUnrevealedURI(_initunrevealedURI);\r\n\t}\r\n\r\n\r\n\tfunction mint(uint16 amount) public payable {\r\n\t\tuint256 supply = totalSupply();\r\n\r\n\t\trequire(!paused, \"Minting is currently disabled!\");\r\n\t\trequire(amount > 0, \"Mint amount must be larger than 0!\");\r\n\t\trequire(supply + amount <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n\r\n\t\tif (freeMints[msg.sender] != 0) {\r\n\t\t\tuint16 freeMintAmount = freeMints[msg.sender];\r\n\r\n\t\t\trequire(amount <= freeMintAmount);\r\n\r\n\t\t\tfreeMints[msg.sender] -= amount;\r\n\t\t}\r\n\r\n\t\telse if (msg.sender != owner()) {\r\n\t\t\trequire(amount <= maxMintAmount);\r\n\t\t\trequire(msg.value >= cost * amount);\r\n\t\t}\r\n\r\n\r\n\t\tfor (uint256 i = 1; i <= amount; i++) {\r\n\t\t\t_safeMint(msg.sender, supply + i);\r\n\t\t}\r\n\r\n\t\temit Mint(msg.sender, msg.sender, amount, block.timestamp);\r\n\t}\r\n\r\n\tfunction mintFor(address wallet, uint16 amount) public payable {\r\n\t\tuint256 supply = totalSupply();\r\n\r\n\t\trequire(!paused, \"Minting is currently disabled!\");\r\n\t\trequire(amount > 0, \"Mint amount must be larger than 0!\");\r\n\t\trequire(supply + amount <= maxSupply, \"Number of tokens exceeded max supply!\");\r\n\r\n\t\tif (freeMints[msg.sender] != 0) {\r\n\t\t\tuint16 freeMintAmount = freeMints[msg.sender];\r\n\r\n\t\t\trequire(amount <= freeMintAmount);\r\n\r\n\t\t\tfreeMints[msg.sender] -= amount;\r\n\t\t}\r\n\r\n\t\telse if (msg.sender != owner()) {\r\n\t\t\trequire(amount <= maxMintAmount);\r\n\t\t\trequire(msg.value >= cost * amount);\r\n\t\t}\r\n\r\n\r\n\t\tfor (uint256 i = 1; i <= amount; i++) {\r\n\t\t\t_safeMint(wallet, supply + i);\r\n\t\t}\r\n\r\n\t\temit Mint(msg.sender, wallet, amount, block.timestamp);\r\n\t}\r\n\r\n\tfunction walletOfOwner(address _owner) public view returns(uint256[] memory) {\r\n\t\tuint256 ownerTokenCount = balanceOf(_owner);\r\n\t\tuint256[] memory tokenIds = new uint256[](ownerTokenCount);\r\n\r\n\t\tfor (uint256 i; i < ownerTokenCount; i++) {\r\n\t\t\ttokenIds[i] = tokenOfOwnerByIndex(_owner, i);\r\n\t\t}\r\n\r\n\t\treturn tokenIds;\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns(string memory) {\r\n\t\trequire(_exists(tokenId), \"ERC721 Metadata: URI query for nonexistent token!\");\r\n\r\n\t\tif (!revealed) return unrevealedURI;\r\n\r\n\t\treturn string( abi.encodePacked(baseURI, tokenId.toString(), \".json\") );\r\n\t}\r\n\r\n\tfunction setPause(bool state) public onlyOwner {\r\n\t\tpaused = state;\r\n\t}\r\n\r\n\tfunction setMaxSupply(uint256 newAmount) public onlyOwner {\r\n\t\tmaxSupply = newAmount;\r\n\t}\r\n\r\n\tfunction reveal() public onlyOwner {\r\n\t\trevealed = true;\r\n\t}\r\n\r\n\tfunction withdraw() public payable onlyOwner {\r\n\t\t(bool os, ) = payable( owner() ).call{value: address(this).balance}(\"\");\r\n\r\n\t\trequire(os);\r\n\t}\r\n\r\n\tfunction setFreeMintsForAddress(address _address, uint16 amount) public onlyOwner {\r\n\t\tfreeMints[_address] = amount;\r\n\t}\r\n\r\n\r\n\t// Utility functions\r\n\r\n\tfunction _baseURI() internal view virtual override returns(string memory) {\r\n\t\treturn baseURI;\r\n\t}\r\n\r\n\tfunction setCost(uint256 newCost) public onlyOwner {\r\n\t\tcost = newCost;\r\n\t}\r\n\r\n\tfunction setBaseURI(string memory newBaseURI) public onlyOwner {\r\n\t\tbaseURI = newBaseURI;\r\n\t}\r\n\r\n\tfunction setUnrevealedURI(string memory newUnrevealedURI) public onlyOwner {\r\n\t\tunrevealedURI = newUnrevealedURI;\r\n\t}\r\n\r\n\tfunction setMaxMintAmount(uint256 newAmount) public onlyOwner {\r\n\t\tmaxMintAmount = newAmount;\r\n\t}\r\n\r\n\tfunction getBalance() public view onlyOwner returns(uint256) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n\tfunction getFreeMintsOfAddress(address _address) public view returns(uint16) {\r\n\t\treturn freeMints[_address];\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_initbaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_initunrevealedURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestmap\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getFreeMintsOfAddress\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"mintFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"setFreeMintsForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxMintAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUnrevealedURI\",\"type\":\"string\"}],\"name\":\"setUnrevealedURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"OneEyeIsland","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d636333353474697966693659737169593769584d786a466d34674b4455714575586e544b505742504b47506d2f000000000000000000000000000000000000000000000000000000000000000000000000000000000035697066733a2f2f516d5462765839326655437932774e32534541346b384856643851637635643147426d38373271724d7756636e550000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ec7a2271a80ce378a428671e38cac0680b613ccc8762522471816f3dc184df97"}]}