{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/libwallet/ERC20Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../thirdparty/SafeERC20.sol\\\";\\nimport \\\"../../lib/ERC20.sol\\\";\\nimport \\\"../../lib/MathUint.sol\\\";\\nimport \\\"../../lib/AddressUtil.sol\\\";\\nimport \\\"../../iface/PriceOracle.sol\\\";\\nimport \\\"./WhitelistLib.sol\\\";\\nimport \\\"./QuotaLib.sol\\\";\\nimport \\\"./ApprovalLib.sol\\\";\\n\\n\\n/// @title ERC20Lib\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary ERC20Lib\\n{\\n    using AddressUtil   for address;\\n    using MathUint      for uint;\\n    using WhitelistLib  for Wallet;\\n    using QuotaLib      for Wallet;\\n    using ApprovalLib   for Wallet;\\n    using SafeERC20     for ERC20;\\n\\n    event Transfered     (address token, address to,      uint amount, bytes logdata);\\n    event Approved       (address token, address spender, uint amount);\\n    event ContractCalled (address to,    uint    value,   bytes data);\\n\\n    bytes32 public constant TRANSFER_TOKEN_TYPEHASH = keccak256(\\n        \\\"transferToken(address wallet,uint256 validUntil,address token,address to,uint256 amount,bytes logdata)\\\"\\n    );\\n    bytes32 public constant APPROVE_TOKEN_TYPEHASH = keccak256(\\n        \\\"approveToken(address wallet,uint256 validUntil,address token,address to,uint256 amount)\\\"\\n    );\\n    bytes32 public constant CALL_CONTRACT_TYPEHASH = keccak256(\\n        \\\"callContract(address wallet,uint256 validUntil,address to,uint256 value,bytes data)\\\"\\n    );\\n    bytes32 public constant APPROVE_THEN_CALL_CONTRACT_TYPEHASH = keccak256(\\n        \\\"approveThenCallContract(address wallet,uint256 validUntil,address token,address to,uint256 amount,uint256 value,bytes data)\\\"\\n    );\\n\\n    function transferToken(\\n        Wallet storage wallet,\\n        PriceOracle    priceOracle,\\n        address        token,\\n        address        to,\\n        uint           amount,\\n        bytes calldata logdata,\\n        bool           forceUseQuota\\n        )\\n        external\\n    {\\n        if (forceUseQuota || !wallet.isAddressWhitelisted(to)) {\\n            wallet.checkAndAddToSpent(priceOracle, token, amount);\\n        }\\n        _transferWithEvent(token, to, amount, logdata);\\n    }\\n\\n    function transferTokenWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address           token,\\n        address           to,\\n        uint              amount,\\n        bytes    calldata logdata\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                TRANSFER_TOKEN_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                token,\\n                to,\\n                amount,\\n                keccak256(logdata)\\n            )\\n        );\\n\\n        _transferWithEvent(token, to, amount, logdata);\\n    }\\n\\n    function callContract(\\n        Wallet  storage  wallet,\\n        PriceOracle      priceOracle,\\n        address          to,\\n        uint             value,\\n        bytes   calldata data,\\n        bool             forceUseQuota\\n        )\\n        external\\n        returns (bytes memory returnData)\\n    {\\n        if (forceUseQuota || !wallet.isAddressWhitelisted(to)) {\\n            wallet.checkAndAddToSpent(priceOracle, address(0), value);\\n        }\\n\\n        return _callContractInternal(to, value, data, priceOracle);\\n    }\\n\\n    function callContractWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address           to,\\n        uint              value,\\n        bytes    calldata data\\n        )\\n        external\\n        returns (bytes32 approvedHash, bytes memory returnData)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                CALL_CONTRACT_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                to,\\n                value,\\n                keccak256(data)\\n            )\\n        );\\n\\n        returnData = _callContractInternal(to, value, data, PriceOracle(0));\\n    }\\n\\n    function approveToken(\\n        Wallet      storage wallet,\\n        PriceOracle         priceOracle,\\n        address             token,\\n        address             to,\\n        uint                amount,\\n        bool                forceUseQuota\\n        )\\n        external\\n    {\\n        uint additionalAllowance = _approveInternal(token, to, amount);\\n\\n        if (forceUseQuota || !wallet.isAddressWhitelisted(to)) {\\n            wallet.checkAndAddToSpent(priceOracle, token, additionalAllowance);\\n        }\\n    }\\n\\n    function approveTokenWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address           token,\\n        address           to,\\n        uint              amount\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                APPROVE_TOKEN_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                token,\\n                to,\\n                amount\\n            )\\n        );\\n\\n        _approveInternal(token, to, amount);\\n    }\\n\\n    function approveThenCallContract(\\n        Wallet  storage  wallet,\\n        PriceOracle      priceOracle,\\n        address          token,\\n        address          to,\\n        uint             amount,\\n        uint             value,\\n        bytes   calldata data,\\n        bool             forceUseQuota\\n        )\\n        external\\n        returns (bytes memory returnData)\\n    {\\n        uint additionalAllowance = _approveInternal(token, to, amount);\\n\\n        if (forceUseQuota || !wallet.isAddressWhitelisted(to)) {\\n            wallet.checkAndAddToSpent(priceOracle, token, additionalAllowance);\\n            wallet.checkAndAddToSpent(priceOracle, address(0), value);\\n        }\\n\\n        return _callContractInternal(to, value, data, priceOracle);\\n    }\\n\\n    function approveThenCallContractWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address           token,\\n        address           to,\\n        uint              amount,\\n        uint              value,\\n        bytes    calldata data\\n        )\\n        external\\n        returns (bytes32 approvedHash, bytes memory returnData)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                APPROVE_THEN_CALL_CONTRACT_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                token,\\n                to,\\n                amount,\\n                value,\\n                keccak256(data)\\n            )\\n        );\\n\\n        _approveInternal(token, to, amount);\\n        returnData = _callContractInternal(to, value, data, PriceOracle(0));\\n    }\\n\\n    function transfer(\\n        address token,\\n        address to,\\n        uint    amount\\n        )\\n        public\\n    {\\n        if (token == address(0)) {\\n            to.sendETHAndVerify(amount, gasleft());\\n        } else {\\n            ERC20(token).safeTransfer(to, amount);\\n        }\\n    }\\n\\n    // --- Internal functions ---\\n\\n    function _transferWithEvent(\\n        address token,\\n        address to,\\n        uint    amount,\\n        bytes   calldata logdata\\n        )\\n        private\\n    {\\n        transfer(token, to, amount);\\n        emit Transfered(token, to, amount, logdata);\\n    }\\n\\n    function _approveInternal(\\n        address token,\\n        address spender,\\n        uint    amount\\n        )\\n        private\\n        returns (uint additionalAllowance)\\n    {\\n        // Current allowance\\n        uint allowance = ERC20(token).allowance(address(this), spender);\\n\\n        if (amount != allowance) {\\n            // First reset the approved amount if needed\\n            if (allowance > 0) {\\n                ERC20(token).safeApprove(spender, 0);\\n            }\\n            // Now approve the requested amount\\n            ERC20(token).safeApprove(spender, amount);\\n        }\\n\\n        // If we increased the allowance, calculate by how much\\n        if (amount > allowance) {\\n            additionalAllowance = amount.sub(allowance);\\n        }\\n        emit Approved(token, spender, amount);\\n    }\\n\\n    function _callContractInternal(\\n        address              to,\\n        uint                 value,\\n        bytes       calldata txData,\\n        PriceOracle          priceOracle\\n        )\\n        private\\n        returns (bytes memory returnData)\\n    {\\n        require(to != address(this), \\\"SELF_CALL_DISALLOWED\\\");\\n\\n        if (priceOracle != PriceOracle(0)) {\\n            // Disallow general calls to token contracts (for tokens that have price data\\n            // so the quota is actually used).\\n            require(priceOracle.tokenValue(to, 1e18) == 0, \\\"CALL_DISALLOWED\\\");\\n        }\\n\\n        bool success;\\n        (success, returnData) = to.call{value: value}(txData);\\n        require(success, \\\"CALL_FAILED\\\");\\n\\n        emit ContractCalled(to, value, txData);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"../lib/ERC20.sol\\\";\\nimport \\\"../lib/MathUint.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using MathUint for uint256;\\n    using Address  for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title ERC20 Token Interface\\n/// @dev see https://github.com/ethereum/EIPs/issues/20\\n/// @author Daniel Wang - <daniel@loopring.org>\\nabstract contract ERC20\\n{\\n    function totalSupply()\\n        public\\n        view\\n        virtual\\n        returns (uint);\\n\\n    function balanceOf(\\n        address who\\n        )\\n        public\\n        view\\n        virtual\\n        returns (uint);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n        )\\n        public\\n        view\\n        virtual\\n        returns (uint);\\n\\n    function transfer(\\n        address to,\\n        uint value\\n        )\\n        public\\n        virtual\\n        returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint    value\\n        )\\n        public\\n        virtual\\n        returns (bool);\\n\\n    function approve(\\n        address spender,\\n        uint    value\\n        )\\n        public\\n        virtual\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MathUint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for uint\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary MathUint\\n{\\n    function mul(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a * b;\\n        require(a == 0 || c / a == b, \\\"MUL_OVERFLOW\\\");\\n    }\\n\\n    function sub(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        require(b <= a, \\\"SUB_UNDERFLOW\\\");\\n        return a - b;\\n    }\\n\\n    function add(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for addresses\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary AddressUtil\\n{\\n    using AddressUtil for *;\\n\\n    function isContract(\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(addr) }\\n        return (codehash != 0x0 &&\\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\n    }\\n\\n    function toPayable(\\n        address addr\\n        )\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return payable(addr);\\n    }\\n\\n    // Works like address.send but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETH(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        if (amount == 0) {\\n            return true;\\n        }\\n        address payable recipient = to.toPayable();\\n        /* solium-disable-next-line */\\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\\\"\\\");\\n    }\\n\\n    // Works like address.transfer but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETHAndVerify(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        success = to.sendETH(amount, gasLimit);\\n        require(success, \\\"TRANSFER_FAILURE\\\");\\n    }\\n\\n    // Works like call but is slightly more efficient when data\\n    // needs to be copied from memory to do the call.\\n    function fastCall(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bool success, bytes memory returnData)\\n    {\\n        if (to != address(0)) {\\n            assembly {\\n                // Do the call\\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\\n                // Copy the return data\\n                let size := returndatasize()\\n                returnData := mload(0x40)\\n                mstore(returnData, size)\\n                returndatacopy(add(returnData, 32), 0, size)\\n                // Update free memory pointer\\n                mstore(0x40, add(returnData, add(32, size)))\\n            }\\n        }\\n    }\\n\\n    // Like fastCall, but throws when the call is unsuccessful.\\n    function fastCallAndVerify(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bytes memory returnData)\\n    {\\n        bool success;\\n        (success, returnData) = fastCall(to, gasLimit, value, data);\\n        if (!success) {\\n            assembly {\\n                revert(add(returnData, 32), mload(returnData))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/iface/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title PriceOracle\\ninterface PriceOracle\\n{\\n    // @dev Return's the token's value in ETH\\n    function tokenValue(address token, uint amount)\\n        external\\n        view\\n        returns (uint value);\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/WhitelistLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ApprovalLib.sol\\\";\\nimport \\\"./WalletData.sol\\\";\\nimport \\\"../../lib/MathUint.sol\\\";\\n\\n\\n/// @title WhitelistLib\\n/// @dev This store maintains a wallet's whitelisted addresses.\\nlibrary WhitelistLib\\n{\\n    using MathUint          for uint;\\n    using WhitelistLib      for Wallet;\\n    using ApprovalLib       for Wallet;\\n\\n    uint public constant WHITELIST_PENDING_PERIOD = 1 days;\\n\\n    bytes32 public constant ADD_TO_WHITELIST_TYPEHASH = keccak256(\\n        \\\"addToWhitelist(address wallet,uint256 validUntil,address addr)\\\"\\n    );\\n\\n    event Whitelisted(\\n        address addr,\\n        bool    whitelisted,\\n        uint    effectiveTime\\n    );\\n\\n    function addToWhitelist(\\n        Wallet  storage wallet,\\n        address         addr\\n        )\\n        external\\n    {\\n        wallet._addToWhitelist(\\n            addr,\\n            block.timestamp.add(WHITELIST_PENDING_PERIOD)\\n        );\\n    }\\n\\n    function addToWhitelistWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address           addr\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                ADD_TO_WHITELIST_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                addr\\n            )\\n        );\\n\\n        wallet._addToWhitelist(\\n            addr,\\n            block.timestamp\\n        );\\n    }\\n\\n    function removeFromWhitelist(\\n        Wallet  storage  wallet,\\n        address          addr\\n        )\\n        external\\n    {\\n        wallet._removeFromWhitelist(addr);\\n    }\\n\\n    function isAddressWhitelisted(\\n        Wallet storage wallet,\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        uint effectiveTime = wallet.whitelisted[addr];\\n        return effectiveTime > 0 && effectiveTime <= block.timestamp;\\n    }\\n\\n    // --- Internal functions ---\\n\\n    function _addToWhitelist(\\n        Wallet storage wallet,\\n        address        addr,\\n        uint           effectiveTime\\n        )\\n        internal\\n    {\\n        require(wallet.whitelisted[addr] == 0, \\\"ADDRESS_ALREADY_WHITELISTED\\\");\\n        uint effective = effectiveTime >= block.timestamp ? effectiveTime : block.timestamp;\\n        wallet.whitelisted[addr] = effective;\\n        emit Whitelisted(addr, true, effective);\\n    }\\n\\n    function _removeFromWhitelist(\\n        Wallet storage wallet,\\n        address        addr\\n        )\\n        internal\\n    {\\n        delete wallet.whitelisted[addr];\\n        emit Whitelisted(addr, false, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/QuotaLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ApprovalLib.sol\\\";\\nimport \\\"./WalletData.sol\\\";\\nimport \\\"../../iface/PriceOracle.sol\\\";\\nimport \\\"../../lib/MathUint.sol\\\";\\nimport \\\"../../thirdparty/SafeCast.sol\\\";\\n\\n\\n/// @title QuotaLib\\n/// @dev This store maintains daily spending quota for each wallet.\\n///      A rolling daily limit is used.\\nlibrary QuotaLib\\n{\\n    using MathUint      for uint;\\n    using SafeCast      for uint;\\n    using ApprovalLib   for Wallet;\\n\\n    uint128 public constant MAX_QUOTA = uint128(-1);\\n    uint    public constant QUOTA_PENDING_PERIOD = 1 days;\\n\\n    bytes32 public constant CHANGE_DAILY_QUOTE_TYPEHASH = keccak256(\\n        \\\"changeDailyQuota(address wallet,uint256 validUntil,uint256 newQuota)\\\"\\n    );\\n\\n    event QuotaScheduled(\\n        address wallet,\\n        uint    pendingQuota,\\n        uint64  pendingUntil\\n    );\\n\\n    function changeDailyQuota(\\n        Wallet storage wallet,\\n        uint           newQuota\\n        )\\n        public\\n    {\\n        setQuota(wallet, newQuota, block.timestamp.add(QUOTA_PENDING_PERIOD));\\n    }\\n\\n    function changeDailyQuotaWA(\\n        Wallet   storage   wallet,\\n        bytes32            domainSeparator,\\n        Approval calldata  approval,\\n        uint               newQuota\\n        )\\n        public\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                CHANGE_DAILY_QUOTE_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                newQuota\\n            )\\n        );\\n        setQuota(wallet, newQuota, 0);\\n    }\\n\\n    function checkAndAddToSpent(\\n        Wallet      storage wallet,\\n        PriceOracle         priceOracle,\\n        address             token,\\n        uint                amount\\n        )\\n        internal\\n    {\\n        Quota memory q = wallet.quota;\\n        uint available = _availableQuota(q);\\n        if (available != MAX_QUOTA) {\\n            uint value = (token == address(0)) ?\\n                amount :\\n                ((address(priceOracle) == address(0)) ?\\n                 0 :\\n                 priceOracle.tokenValue(token, amount));\\n\\n            if (value > 0) {\\n                require(available >= value, \\\"QUOTA_EXCEEDED\\\");\\n                _addToSpent(wallet, q, value);\\n            }\\n        }\\n    }\\n\\n    // 0 for newQuota indicates unlimited quota, or daily quota is disabled.\\n    function setQuota(\\n        Wallet storage wallet,\\n        uint           newQuota,\\n        uint           effectiveTime\\n        )\\n        internal\\n    {\\n        require(newQuota <= MAX_QUOTA, \\\"INVALID_VALUE\\\");\\n        if (newQuota == MAX_QUOTA) {\\n            newQuota = 0;\\n        }\\n\\n        uint __currentQuota = currentQuota(wallet);\\n        // Always allow the quota to be changed immediately when the quota doesn't increase\\n        if ((__currentQuota >= newQuota && newQuota != 0) || __currentQuota == 0) {\\n            effectiveTime = 0;\\n        }\\n\\n        Quota storage quota = wallet.quota;\\n        quota.currentQuota = __currentQuota.toUint128();\\n        quota.pendingQuota = newQuota.toUint128();\\n        quota.pendingUntil = effectiveTime.toUint64();\\n\\n        emit QuotaScheduled(\\n            address(this),\\n            newQuota,\\n            quota.pendingUntil\\n        );\\n    }\\n\\n    // Returns 0 to indiciate unlimited quota\\n    function currentQuota(Wallet storage wallet)\\n        internal\\n        view\\n        returns (uint)\\n    {\\n        return _currentQuota(wallet.quota);\\n    }\\n\\n    // Returns 0 to indiciate unlimited quota\\n    function pendingQuota(Wallet storage wallet)\\n        internal\\n        view\\n        returns (\\n            uint __pendingQuota,\\n            uint __pendingUntil\\n        )\\n    {\\n        return _pendingQuota(wallet.quota);\\n    }\\n\\n    function spentQuota(Wallet storage wallet)\\n        internal\\n        view\\n        returns (uint)\\n    {\\n        return _spentQuota(wallet.quota);\\n    }\\n\\n    function availableQuota(Wallet storage wallet)\\n        internal\\n        view\\n        returns (uint)\\n    {\\n        return _availableQuota(wallet.quota);\\n    }\\n\\n    function hasEnoughQuota(\\n        Wallet storage wallet,\\n        uint               requiredAmount\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _hasEnoughQuota(wallet.quota, requiredAmount);\\n    }\\n\\n    // --- Internal functions ---\\n\\n    function _currentQuota(Quota memory q)\\n        private\\n        view\\n        returns (uint)\\n    {\\n        return q.pendingUntil <= block.timestamp ? q.pendingQuota : q.currentQuota;\\n    }\\n\\n    function _pendingQuota(Quota memory q)\\n        private\\n        view\\n        returns (\\n            uint __pendingQuota,\\n            uint __pendingUntil\\n        )\\n    {\\n        if (q.pendingUntil > 0 && q.pendingUntil > block.timestamp) {\\n            __pendingQuota = q.pendingQuota;\\n            __pendingUntil = q.pendingUntil;\\n        }\\n    }\\n\\n    function _spentQuota(Quota memory q)\\n        private\\n        view\\n        returns (uint)\\n    {\\n        uint timeSinceLastSpent = block.timestamp.sub(q.spentTimestamp);\\n        if (timeSinceLastSpent < 1 days) {\\n            return uint(q.spentAmount).sub(timeSinceLastSpent.mul(q.spentAmount) / 1 days);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _availableQuota(Quota memory q)\\n        private\\n        view\\n        returns (uint)\\n    {\\n        uint quota = _currentQuota(q);\\n        if (quota == 0) {\\n            return MAX_QUOTA;\\n        }\\n        uint spent = _spentQuota(q);\\n        return quota > spent ? quota - spent : 0;\\n    }\\n\\n    function _hasEnoughQuota(\\n        Quota   memory q,\\n        uint    requiredAmount\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _availableQuota(q) >= requiredAmount;\\n    }\\n\\n    function _addToSpent(\\n        Wallet storage wallet,\\n        Quota   memory q,\\n        uint    amount\\n        )\\n        private\\n    {\\n        Quota storage s = wallet.quota;\\n        s.spentAmount = _spentQuota(q).add(amount).toUint128();\\n        s.spentTimestamp = uint64(block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/ApprovalLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../lib/EIP712.sol\\\";\\nimport \\\"../../lib/SignatureUtil.sol\\\";\\nimport \\\"./GuardianLib.sol\\\";\\nimport \\\"./WalletData.sol\\\";\\n\\n\\n/// @title ApprovalLib\\n/// @dev Utility library for better handling of signed wallet requests.\\n///      This library must be deployed and linked to other modules.\\n///\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary ApprovalLib {\\n    using SignatureUtil for bytes32;\\n\\n    function verifyApproval(\\n        Wallet  storage wallet,\\n        bytes32         domainSeparator,\\n        SigRequirement  sigRequirement,\\n        Approval memory approval,\\n        bytes    memory encodedRequest\\n        )\\n        internal\\n        returns (bytes32 approvedHash)\\n    {\\n        require(address(this) == approval.wallet, \\\"INVALID_WALLET\\\");\\n        require(block.timestamp <= approval.validUntil, \\\"EXPIRED_SIGNED_REQUEST\\\");\\n\\n        approvedHash = EIP712.hashPacked(domainSeparator, keccak256(encodedRequest));\\n\\n        // Save hash to prevent replay attacks\\n        require(!wallet.hashes[approvedHash], \\\"HASH_EXIST\\\");\\n        wallet.hashes[approvedHash] = true;\\n\\n        require(\\n            approvedHash.verifySignatures(approval.signers, approval.signatures),\\n            \\\"INVALID_SIGNATURES\\\"\\n        );\\n\\n        require(\\n            GuardianLib.requireMajority(\\n                wallet,\\n                approval.signers,\\n                sigRequirement\\n            ),\\n            \\\"PERMISSION_DENIED\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Token from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/90ed1af972299070f51bf4665a85da56ac4d355e/contracts/utils/Address.sol\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        //require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/base/libwallet/WalletData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nenum SigRequirement\\n{\\n    MAJORITY_OWNER_NOT_ALLOWED,\\n    MAJORITY_OWNER_ALLOWED,\\n    MAJORITY_OWNER_REQUIRED,\\n    OWNER_OR_ANY_GUARDIAN,\\n    ANY_GUARDIAN\\n}\\n\\nstruct Approval\\n{\\n    address[] signers;\\n    bytes[]   signatures;\\n    uint      validUntil;\\n    address   wallet;\\n}\\n\\n// Optimized to fit into 64 bytes (2 slots)\\nstruct Quota\\n{\\n    uint128 currentQuota;\\n    uint128 pendingQuota;\\n    uint128 spentAmount;\\n    uint64  spentTimestamp;\\n    uint64  pendingUntil;\\n}\\n\\nenum GuardianStatus\\n{\\n    REMOVE,    // Being removed or removed after validUntil timestamp\\n    ADD        // Being added or added after validSince timestamp.\\n}\\n\\n// Optimized to fit into 32 bytes (1 slot)\\nstruct Guardian\\n{\\n    address addr;\\n    uint8   status;\\n    uint64  timestamp; // validSince if status = ADD; validUntil if adding = REMOVE;\\n}\\n\\nstruct Wallet\\n{\\n    address owner;\\n    uint64  creationTimestamp;\\n\\n    // relayer => nonce\\n    uint nonce;\\n    // hash => consumed\\n    mapping (bytes32 => bool) hashes;\\n\\n    bool    locked;\\n\\n    Guardian[] guardians;\\n    mapping (address => uint)  guardianIdx;\\n\\n    address    inheritor;\\n    uint32     inheritWaitingPeriod;\\n    uint64     lastActive; // the latest timestamp the owner is considered to be active\\n\\n    Quota quota;\\n\\n    // whitelisted address => effective timestamp\\n    mapping (address => uint) whitelisted;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nlibrary EIP712\\n{\\n    struct Domain {\\n        string  name;\\n        string  version;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n    string constant internal EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    function hash(Domain memory domain)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        uint _chainid;\\n        assembly { _chainid := chainid() }\\n\\n        return keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(domain.name)),\\n                keccak256(bytes(domain.version)),\\n                _chainid,\\n                domain.verifyingContract\\n            )\\n        );\\n    }\\n\\n    function hashPacked(\\n        bytes32 domainSeparator,\\n        bytes32 dataHash\\n        )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                domainSeparator,\\n                dataHash\\n            )\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SignatureUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../thirdparty/BytesUtil.sol\\\";\\nimport \\\"./AddressUtil.sol\\\";\\nimport \\\"./ERC1271.sol\\\";\\nimport \\\"./MathUint.sol\\\";\\n\\n\\n/// @title SignatureUtil\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @dev This method supports multihash standard. Each signature's last byte indicates\\n///      the signature's type.\\nlibrary SignatureUtil\\n{\\n    using BytesUtil     for bytes;\\n    using MathUint      for uint;\\n    using AddressUtil   for address;\\n\\n    enum SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP_712,\\n        ETH_SIGN,\\n        WALLET   // deprecated\\n    }\\n\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function verifySignatures(\\n        bytes32          signHash,\\n        address[] memory signers,\\n        bytes[]   memory signatures\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(signers.length == signatures.length, \\\"BAD_SIGNATURE_DATA\\\");\\n        address lastSigner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function verifySignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        return signer.isContract()?\\n            verifyERC1271Signature(signHash, signer, signature):\\n            verifyEOASignature(signHash, signer, signature);\\n    }\\n\\n    function recoverECDSASigner(\\n        bytes32      signHash,\\n        bytes memory signature\\n        )\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        if (signature.length != 65) {\\n            return address(0);\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8   v;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := and(mload(add(signature, 0x41)), 0xff)\\n        }\\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n        if (v == 27 || v == 28) {\\n            return ecrecover(signHash, v, r, s);\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function verifyEOASignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        uint signatureTypeOffset = signature.length.sub(1);\\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\\n\\n        // Strip off the last byte of the signature by updating the length\\n        assembly {\\n            mstore(signature, signatureTypeOffset)\\n        }\\n\\n        if (signatureType == SignatureType.EIP_712) {\\n            success = (signer == recoverECDSASigner(signHash, signature));\\n        } else if (signatureType == SignatureType.ETH_SIGN) {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", signHash)\\n            );\\n            success = (signer == recoverECDSASigner(hash, signature));\\n        } else {\\n            success = false;\\n        }\\n\\n        // Restore the signature length\\n        assembly {\\n            mstore(signature, add(signatureTypeOffset, 1))\\n        }\\n\\n        return success;\\n    }\\n\\n    function verifyERC1271Signature(\\n        bytes32 signHash,\\n        address signer,\\n        bytes   memory signature\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes memory callData = abi.encodeWithSelector(\\n            ERC1271.isValidSignature.selector,\\n            signHash,\\n            signature\\n        );\\n        (bool success, bytes memory result) = signer.staticcall(callData);\\n        return (\\n            success &&\\n            result.length == 32 &&\\n            result.toBytes4(0) == ERC1271_MAGICVALUE\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/GuardianLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./WalletData.sol\\\";\\nimport \\\"./ApprovalLib.sol\\\";\\nimport \\\"../../lib/SignatureUtil.sol\\\";\\nimport \\\"../../thirdparty/SafeCast.sol\\\";\\n\\n\\n/// @title GuardianModule\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary GuardianLib\\n{\\n    using AddressUtil   for address;\\n    using SafeCast      for uint;\\n    using SignatureUtil for bytes32;\\n    using ApprovalLib   for Wallet;\\n\\n    uint public constant MAX_GUARDIANS           = 10;\\n    uint public constant GUARDIAN_PENDING_PERIOD = 3 days;\\n\\n    bytes32 public constant ADD_GUARDIAN_TYPEHASH = keccak256(\\n        \\\"addGuardian(address wallet,uint256 validUntil,address guardian)\\\"\\n    );\\n    bytes32 public constant REMOVE_GUARDIAN_TYPEHASH = keccak256(\\n        \\\"removeGuardian(address wallet,uint256 validUntil,address guardian)\\\"\\n    );\\n    bytes32 public constant RESET_GUARDIANS_TYPEHASH = keccak256(\\n        \\\"resetGuardians(address wallet,uint256 validUntil,address[] guardians)\\\"\\n    );\\n\\n    event GuardianAdded   (address guardian, uint effectiveTime);\\n    event GuardianRemoved (address guardian, uint effectiveTime);\\n\\n    function addGuardiansImmediately(\\n        Wallet    storage wallet,\\n        address[] memory  _guardians\\n        )\\n        external\\n    {\\n        address guardian = address(0);\\n        for (uint i = 0; i < _guardians.length; i++) {\\n            require(_guardians[i] > guardian, \\\"INVALID_ORDERING\\\");\\n            guardian = _guardians[i];\\n            _addGuardian(wallet, guardian, 0, true);\\n        }\\n    }\\n\\n    function addGuardian(\\n        Wallet storage wallet,\\n        address guardian\\n        )\\n        external\\n    {\\n        _addGuardian(wallet, guardian, GUARDIAN_PENDING_PERIOD, false);\\n    }\\n\\n    function addGuardianWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address  guardian\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                ADD_GUARDIAN_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                guardian\\n            )\\n        );\\n\\n        _addGuardian(wallet, guardian, 0, true);\\n    }\\n\\n    function removeGuardian(\\n        Wallet storage wallet,\\n        address guardian\\n        )\\n        external\\n    {\\n        _removeGuardian(wallet, guardian, GUARDIAN_PENDING_PERIOD, false);\\n    }\\n\\n    function removeGuardianWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address  guardian\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                REMOVE_GUARDIAN_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                guardian\\n            )\\n        );\\n\\n        _removeGuardian(wallet, guardian, 0, true);\\n    }\\n\\n    function resetGuardians(\\n        Wallet    storage  wallet,\\n        address[] calldata newGuardians\\n        )\\n        external\\n    {\\n        Guardian[] memory allGuardians = guardians(wallet, true);\\n        for (uint i = 0; i < allGuardians.length; i++) {\\n            _removeGuardian(wallet, allGuardians[i].addr, GUARDIAN_PENDING_PERIOD, false);\\n        }\\n\\n        for (uint j = 0; j < newGuardians.length; j++) {\\n            _addGuardian(wallet, newGuardians[j], GUARDIAN_PENDING_PERIOD, false);\\n        }\\n    }\\n\\n    function resetGuardiansWA(\\n        Wallet    storage  wallet,\\n        bytes32            domainSeparator,\\n        Approval  calldata approval,\\n        address[] calldata newGuardians\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                RESET_GUARDIANS_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                keccak256(abi.encodePacked(newGuardians))\\n            )\\n        );\\n\\n        removeAllGuardians(wallet);\\n        for (uint i = 0; i < newGuardians.length; i++) {\\n            _addGuardian(wallet, newGuardians[i], 0, true);\\n        }\\n    }\\n\\n    function requireMajority(\\n        Wallet         storage wallet,\\n        address[]      memory  signers,\\n        SigRequirement         requirement\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // We always need at least one signer\\n        if (signers.length == 0) {\\n            return false;\\n        }\\n\\n        // Calculate total group sizes\\n        Guardian[] memory allGuardians = guardians(wallet, false);\\n        require(allGuardians.length > 0, \\\"NO_GUARDIANS\\\");\\n\\n        address lastSigner;\\n        bool walletOwnerSigned = false;\\n        address owner = wallet.owner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            // Check for duplicates\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n\\n            if (signers[i] == owner) {\\n                walletOwnerSigned = true;\\n            } else {\\n                bool _isGuardian = false;\\n                for (uint j = 0; j < allGuardians.length; j++) {\\n                    if (allGuardians[j].addr == signers[i]) {\\n                        _isGuardian = true;\\n                        break;\\n                    }\\n                }\\n                require(_isGuardian, \\\"SIGNER_NOT_GUARDIAN\\\");\\n            }\\n        }\\n\\n        if (requirement == SigRequirement.OWNER_OR_ANY_GUARDIAN) {\\n            return signers.length == 1;\\n        } else if (requirement == SigRequirement.ANY_GUARDIAN) {\\n            require(!walletOwnerSigned, \\\"WALLET_OWNER_SIGNATURE_NOT_ALLOWED\\\");\\n            return signers.length == 1;\\n        }\\n\\n        // Check owner requirements\\n        if (requirement == SigRequirement.MAJORITY_OWNER_REQUIRED) {\\n            require(walletOwnerSigned, \\\"WALLET_OWNER_SIGNATURE_REQUIRED\\\");\\n        } else if (requirement == SigRequirement.MAJORITY_OWNER_NOT_ALLOWED) {\\n            require(!walletOwnerSigned, \\\"WALLET_OWNER_SIGNATURE_NOT_ALLOWED\\\");\\n        }\\n\\n        uint numExtendedSigners = allGuardians.length;\\n        if (walletOwnerSigned) {\\n            numExtendedSigners += 1;\\n            require(signers.length > 1, \\\"NO_GUARDIAN_SIGNED_BESIDES_OWNER\\\");\\n        }\\n\\n        return signers.length >= (numExtendedSigners >> 1) + 1;\\n    }\\n\\n    function isGuardian(\\n        Wallet storage wallet,\\n        address addr,\\n        bool    includePendingAddition\\n        )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        Guardian memory g = _getGuardian(wallet, addr);\\n        return _isActiveOrPendingAddition(g, includePendingAddition);\\n    }\\n\\n    function guardians(\\n        Wallet storage wallet,\\n        bool    includePendingAddition\\n        )\\n        public\\n        view\\n        returns (Guardian[] memory _guardians)\\n    {\\n        _guardians = new Guardian[](wallet.guardians.length);\\n        uint index = 0;\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            Guardian memory g = wallet.guardians[i];\\n            if (_isActiveOrPendingAddition(g, includePendingAddition)) {\\n                _guardians[index] = g;\\n                index++;\\n            }\\n        }\\n        assembly { mstore(_guardians, index) }\\n    }\\n\\n    function numGuardians(\\n        Wallet storage wallet,\\n        bool    includePendingAddition\\n        )\\n        public\\n        view\\n        returns (uint count)\\n    {\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            Guardian memory g = wallet.guardians[i];\\n            if (_isActiveOrPendingAddition(g, includePendingAddition)) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n     function removeAllGuardians(\\n        Wallet storage wallet\\n        )\\n        internal\\n    {\\n        uint size = wallet.guardians.length;\\n        if (size == 0) return;\\n\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            delete wallet.guardianIdx[wallet.guardians[i].addr];\\n        }\\n        delete wallet.guardians;\\n    }\\n\\n    function cancelPendingGuardians(Wallet storage wallet)\\n        internal\\n    {\\n        bool cancelled = false;\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            Guardian memory g = wallet.guardians[i];\\n            if (_isPendingAddition(g)) {\\n                wallet.guardians[i].status = uint8(GuardianStatus.REMOVE);\\n                wallet.guardians[i].timestamp = 0;\\n                cancelled = true;\\n            }\\n            if (_isPendingRemoval(g)) {\\n                wallet.guardians[i].status = uint8(GuardianStatus.ADD);\\n                wallet.guardians[i].timestamp = 0;\\n                cancelled = true;\\n            }\\n        }\\n        _cleanRemovedGuardians(wallet, true);\\n    }\\n\\n    function storeGuardian(\\n        Wallet storage wallet,\\n        address addr,\\n        uint    validSince,\\n        bool    alwaysOverride\\n        )\\n        internal\\n        returns (uint)\\n    {\\n        require(validSince >= block.timestamp, \\\"INVALID_VALID_SINCE\\\");\\n        require(addr != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(addr != address(this), \\\"INVALID_ADDRESS\\\");\\n\\n        uint pos = wallet.guardianIdx[addr];\\n\\n        if (pos == 0) {\\n            // Add the new guardian\\n            Guardian memory _g = Guardian(\\n                addr,\\n                uint8(GuardianStatus.ADD),\\n                validSince.toUint64()\\n            );\\n            wallet.guardians.push(_g);\\n            wallet.guardianIdx[addr] = wallet.guardians.length;\\n\\n            _cleanRemovedGuardians(wallet, false);\\n            return validSince;\\n        }\\n\\n        Guardian memory g = wallet.guardians[pos - 1];\\n\\n        if (_isRemoved(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.ADD);\\n            wallet.guardians[pos - 1].timestamp = validSince.toUint64();\\n            return validSince;\\n        }\\n\\n        if (_isPendingRemoval(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.ADD);\\n            wallet.guardians[pos - 1].timestamp = 0;\\n            return 0;\\n        }\\n\\n        if (_isPendingAddition(g)) {\\n            if (!alwaysOverride) return g.timestamp;\\n\\n            wallet.guardians[pos - 1].timestamp = validSince.toUint64();\\n            return validSince;\\n        }\\n\\n        require(_isAdded(g), \\\"UNEXPECTED_RESULT\\\");\\n        return 0;\\n    }\\n\\n    function deleteGuardian(\\n        Wallet storage wallet,\\n        address addr,\\n        uint    validUntil,\\n        bool    alwaysOverride\\n        )\\n        internal\\n        returns (uint)\\n    {\\n        require(validUntil >= block.timestamp, \\\"INVALID_VALID_UNTIL\\\");\\n        require(addr != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        uint pos = wallet.guardianIdx[addr];\\n        require(pos > 0, \\\"GUARDIAN_NOT_EXISTS\\\");\\n\\n        Guardian memory g = wallet.guardians[pos - 1];\\n\\n        if (_isAdded(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.REMOVE);\\n            wallet.guardians[pos - 1].timestamp = validUntil.toUint64();\\n            return validUntil;\\n        }\\n\\n        if (_isPendingAddition(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.REMOVE);\\n            wallet.guardians[pos - 1].timestamp = 0;\\n            return 0;\\n        }\\n\\n        if (_isPendingRemoval(g)) {\\n            if (!alwaysOverride) return g.timestamp;\\n\\n            wallet.guardians[pos - 1].timestamp = validUntil.toUint64();\\n            return validUntil;\\n        }\\n\\n        require(_isRemoved(g), \\\"UNEXPECTED_RESULT\\\");\\n        return 0;\\n    }\\n\\n    // --- Internal functions ---\\n\\n    function _addGuardian(\\n        Wallet storage wallet,\\n        address guardian,\\n        uint    pendingPeriod,\\n        bool    alwaysOverride\\n        )\\n        internal\\n    {\\n        uint _numGuardians = numGuardians(wallet, true);\\n        require(_numGuardians < MAX_GUARDIANS, \\\"TOO_MANY_GUARDIANS\\\");\\n        require(guardian != wallet.owner, \\\"GUARDIAN_CAN_NOT_BE_OWNER\\\");\\n\\n        uint validSince = block.timestamp;\\n        if (_numGuardians >= 2) {\\n            validSince = block.timestamp + pendingPeriod;\\n        }\\n        validSince = storeGuardian(wallet, guardian, validSince, alwaysOverride);\\n        emit GuardianAdded(guardian, validSince);\\n    }\\n\\n    function _removeGuardian(\\n        Wallet storage wallet,\\n        address guardian,\\n        uint    pendingPeriod,\\n        bool    alwaysOverride\\n        )\\n        private\\n    {\\n        uint validUntil = block.timestamp + pendingPeriod;\\n        validUntil = deleteGuardian(wallet, guardian, validUntil, alwaysOverride);\\n        emit GuardianRemoved(guardian, validUntil);\\n    }\\n\\n    function _getGuardian(\\n        Wallet storage wallet,\\n        address addr\\n        )\\n        private\\n        view\\n        returns (Guardian memory guardian)\\n    {\\n        uint pos = wallet.guardianIdx[addr];\\n        if (pos > 0) {\\n            guardian = wallet.guardians[pos - 1];\\n        }\\n    }\\n\\n    function _isAdded(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return guardian.status == uint8(GuardianStatus.ADD) &&\\n            guardian.timestamp <= block.timestamp;\\n    }\\n\\n    function _isPendingAddition(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return guardian.status == uint8(GuardianStatus.ADD) &&\\n            guardian.timestamp > block.timestamp;\\n    }\\n\\n    function _isRemoved(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return guardian.status == uint8(GuardianStatus.REMOVE) &&\\n            guardian.timestamp <= block.timestamp;\\n    }\\n\\n    function _isPendingRemoval(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n         return guardian.status == uint8(GuardianStatus.REMOVE) &&\\n            guardian.timestamp > block.timestamp;\\n    }\\n\\n    function _isActive(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _isAdded(guardian) || _isPendingRemoval(guardian);\\n    }\\n\\n    function _isActiveOrPendingAddition(\\n        Guardian memory guardian,\\n        bool includePendingAddition\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _isActive(guardian) || includePendingAddition && _isPendingAddition(guardian);\\n    }\\n\\n    function _cleanRemovedGuardians(\\n        Wallet storage wallet,\\n        bool    force\\n        )\\n        private\\n    {\\n        uint count = wallet.guardians.length;\\n        if (!force && count < 10) return;\\n\\n        for (int i = int(count) - 1; i >= 0; i--) {\\n            Guardian memory g = wallet.guardians[uint(i)];\\n            if (_isRemoved(g)) {\\n                Guardian memory lastGuardian = wallet.guardians[wallet.guardians.length - 1];\\n\\n                if (g.addr != lastGuardian.addr) {\\n                    wallet.guardians[uint(i)] = lastGuardian;\\n                    wallet.guardianIdx[lastGuardian.addr] = uint(i) + 1;\\n                }\\n                wallet.guardians.pop();\\n                delete wallet.guardianIdx[g.addr];\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/BytesUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\npragma solidity ^0.7.0;\\n\\nlibrary BytesUtil {\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\\n        require(_bytes.length >= (_start + 3));\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8));\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12));\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16));\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\\n        require(_bytes.length >= (_start + 4));\\n        bytes4 tempBytes4;\\n\\n        assembly {\\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes4;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function fastSHA256(\\n        bytes memory data\\n        )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32[] memory result = new bytes32[](1);\\n        bool success;\\n        assembly {\\n             let ptr := add(data, 32)\\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\\n        }\\n        require(success, \\\"SHA256_FAILED\\\");\\n        return result[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function isValidSignature(\\n        bytes32      _hash,\\n        bytes memory _signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value < 2**96, \\\"SafeCast: value doesn\\\\'t fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value < 2**40, \\\"SafeCast: value doesn\\\\'t fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ContractCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"logdata\",\"type\":\"bytes\"}],\"name\":\"Transfered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APPROVE_THEN_CALL_CONTRACT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"APPROVE_TOKEN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CALL_CONTRACT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_TOKEN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ERC20Lib","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}