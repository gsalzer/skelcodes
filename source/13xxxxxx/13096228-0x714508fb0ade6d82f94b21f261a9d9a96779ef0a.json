{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ncontract ShitYouDoWhenBored {\r\n    address internal constant TOKEN_WETH  = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address internal constant TOKEN_LIDO  = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\r\n    address internal constant TOKEN_DAI   = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address internal constant TOKEN_USDC  = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address internal constant PROXY_DYDX  = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    \r\n    \r\n    function callFunction(\r\n        address sender,\r\n        Types.AccountInfo memory,\r\n        bytes calldata\r\n    ) external {\r\n        require(sender == address(this));\r\n        uint256 amountToMint = IERC20Token(TOKEN_WETH).balanceOf(address(this));\r\n        WETH9(TOKEN_WETH).withdraw(amountToMint);\r\n        IERC20Token(TOKEN_LIDO).submit{value: amountToMint}(0x90102a92e8E40561f88be66611E5437FEb339e79);\r\n        require(IERC20Token(TOKEN_LIDO).totalSupply() >= 1000000 * 10 ** 18);\r\n        uint256 amountToSell = IERC20Token(TOKEN_LIDO).balanceOf(address(this));\r\n        IERC20Token(TOKEN_LIDO).approve(\r\n            0xDC24316b9AE028F1497c275EB9192a3Ea0f67022,\r\n            amountToSell\r\n        );\r\n        Curve(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022).exchange(\r\n            1,\r\n            0,\r\n            amountToSell,\r\n            1\r\n        );\r\n        WETH9(TOKEN_WETH).deposit{value: address(this).balance}();\r\n    }\r\n    \r\n    function wrapWithDyDx(uint256 requiredAmount) public payable {\r\n        require(msg.sender == 0x90102a92e8E40561f88be66611E5437FEb339e79);\r\n        require(IERC20Token(TOKEN_LIDO).totalSupply() < 1000000 * 10 ** 18);\r\n        Types.ActionArgs[] memory operations = new Types.ActionArgs[](3);\r\n        operations[0] = Types.ActionArgs({\r\n            actionType: Types.ActionType.Withdraw,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: requiredAmount\r\n            }),\r\n            primaryMarketId: marketIdFromTokenAddress(TOKEN_WETH),\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n        operations[1] = Types.ActionArgs({\r\n            actionType: Types.ActionType.Call,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: 0\r\n            }),\r\n            primaryMarketId: 0,\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n        operations[2] = Types.ActionArgs({\r\n            actionType: Types.ActionType.Deposit,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: true,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: requiredAmount + 1\r\n            }),\r\n            primaryMarketId: marketIdFromTokenAddress(TOKEN_WETH),\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n\r\n        Types.AccountInfo[] memory accountInfos = new Types.AccountInfo[](1);\r\n        accountInfos[0] = Types.AccountInfo({\r\n            owner: address(this),\r\n            number: 1\r\n        });\r\n        IERC20Token(TOKEN_WETH).approve(\r\n            PROXY_DYDX,\r\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n        );\r\n        ISoloMargin(PROXY_DYDX).operate(accountInfos, operations);\r\n    }\r\n    function marketIdFromTokenAddress(address tokenAddress) internal pure returns (uint256 resultId) {\r\n        assembly {\r\n            switch tokenAddress\r\n            case 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 {\r\n                resultId := 0\r\n            }\r\n            case 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 {\r\n                resultId := 2\r\n            }\r\n            case 0x6B175474E89094C44Da98b954EedeAC495271d0F {\r\n                resultId := 3\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n    \r\n    function withdraw(address token, uint256 amount) public {\r\n        assert(msg.sender == 0x90102a92e8E40561f88be66611E5437FEb339e79);\r\n        if (token != address(0x0)) {\r\n            uint256 tokenBalance =  IERC20Token(token).balanceOf(address(this));\r\n            if (amount < tokenBalance) {\r\n                IERC20Token(token).transfer(msg.sender, amount);\r\n            } else {\r\n                IERC20Token(token).transfer(msg.sender, tokenBalance);\r\n            }\r\n        } else {\r\n            if (amount < address(this).balance) {\r\n                payable(msg.sender).transfer(amount);\r\n            } else {\r\n                payable(msg.sender).transfer(address(this).balance);\r\n            }\r\n        }\r\n    }\r\n    function withdrawNFT(address tokenAddr, uint256 tokenId, bool approval) public {\r\n        assert(msg.sender == 0x90102a92e8E40561f88be66611E5437FEb339e79);\r\n        if (approval) {\r\n            IERC721(tokenAddr).setApprovalForAll(\r\n                msg.sender,\r\n                true\r\n            );\r\n        }\r\n        IERC721(tokenAddr).transferFrom(\r\n            address(this),\r\n            msg.sender,\r\n            tokenId\r\n        );\r\n    }\r\n    fallback() external payable {}\r\n}\r\n\r\ninterface ISoloMargin {\r\n    function operate(Types.AccountInfo[] memory accounts, Types.ActionArgs[] memory actions) external;\r\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\r\n}\r\n\r\ninterface Curve {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\r\n}\r\n\r\ninterface IERC721 {\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n}\r\n\r\nlibrary Types {\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct AccountInfo {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n}\r\n\r\ninterface WETH9 {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n\r\ninterface IERC20Token {\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    \r\n    function submit(address _referral) external payable returns (uint256);\r\n}","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.AccountInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"}],\"name\":\"withdrawNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredAmount\",\"type\":\"uint256\"}],\"name\":\"wrapWithDyDx\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ShitYouDoWhenBored","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d2a765522926cb1e5c3e0639ecd174e7b4d143f97044005f7852315cbcca5bad"}]}