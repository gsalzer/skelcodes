{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/erc20-proxy/MirrorERC20Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {MirrorProxy} from \\\"../../producers/mirror/MirrorProxy.sol\\\";\\nimport {IMirrorERC20Factory, IMirrorERC20FactoryEvents} from \\\"./interface/IMirrorERC20Factory.sol\\\";\\nimport {IMirrorERC20ProxyStorageEvents} from \\\"./interface/IMirrorERC20ProxyStorage.sol\\\";\\n\\ninterface IERC20ProxyStorage {\\n    /// @notice Register new proxy and initialize metadata\\n    function initialize(\\n        address operator_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimals_\\n    ) external;\\n}\\n\\n/**\\n * @title MirrorERC20Factory\\n * @author MirrorXYZ\\n */\\ncontract MirrorERC20Factory is\\n    IMirrorERC20Factory,\\n    IMirrorERC20FactoryEvents,\\n    IMirrorERC20ProxyStorageEvents\\n{\\n    /// @notice Address that holds the relay logic for proxies\\n    address public immutable relayer;\\n\\n    //======== Constructor =========\\n\\n    constructor(address relayer_) {\\n        relayer = relayer_;\\n    }\\n\\n    //======== Deploy function =========\\n\\n    function create(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimals_\\n    ) external override returns (address erc20Proxy) {\\n        address operator = payable(msg.sender);\\n\\n        bytes memory initializationData = abi.encodeWithSelector(\\n            IERC20ProxyStorage.initialize.selector,\\n            operator,\\n            name_,\\n            symbol_,\\n            totalSupply_,\\n            decimals_\\n        );\\n\\n        erc20Proxy = address(\\n            new MirrorProxy{\\n                salt: keccak256(abi.encode(operator, name_, symbol_))\\n            }(relayer, initializationData)\\n        );\\n\\n        emit ERC20ProxyDeployed(erc20Proxy, name_, symbol_, operator);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/mirror/MirrorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title MirrorProxy\\n * @author MirrorXYZ\\n * The MirrorProxy contract is used to deploy minimal contracts for multiple\\n * economic producers on the Mirror ecosystem (e.g. crowdfunds, editions). The\\n * proxies are used with the proxy-relayer pattern. The proxy delegates calls\\n * to a relayer contract that calls into the storage contract. The proxy uses the\\n * EIP-1967 standard to store the \\\"implementation\\\" logic, which in our case is\\n * the relayer contract. The relayer logic is directly stored into the standard\\n * slot using `sstore` in the constructor, and read using `sload` in the fallback\\n * function.\\n */\\ncontract MirrorProxy {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice Initializes a proxy by delegating logic to the relayer,\\n     * and reverts if the call is not successful. Stores relayer logic.\\n     * @param relayer - the relayer holds the logic for all proxies\\n     * @param initializationData - initialization call\\n     */\\n    constructor(address relayer, bytes memory initializationData) {\\n        // Delegatecall into the relayer, supplying initialization calldata.\\n        (bool ok, ) = relayer.delegatecall(initializationData);\\n\\n        // Revert and include revert data if delegatecall to implementation reverts.\\n        if (!ok) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, relayer)\\n        }\\n    }\\n\\n    /**\\n     * @notice When any function is called on this contract, we delegate to\\n     * the logic contract stored in the implementation storage slot.\\n     */\\n    fallback() external payable {\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                sload(_IMPLEMENTATION_SLOT),\\n                ptr,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/erc20-proxy/interface/IMirrorERC20Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorERC20FactoryEvents {\\n    event ERC20ProxyDeployed(\\n        address proxy,\\n        string name,\\n        string symbol,\\n        address operator\\n    );\\n}\\n\\ninterface IMirrorERC20Factory {\\n    /// @notice Deploy a new proxy\\n    function create(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimals_\\n    ) external returns (address erc20Proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/erc20-proxy/interface/IMirrorERC20ProxyStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorERC20ProxyStorageEvents {\\n    /// @notice Emitted when a new proxy is initialized\\n    event NewProxy(address indexed proxy, address indexed operator);\\n}\\n\\ninterface IMirrorERC20ProxyStorage {\\n    function operator() external view returns (address);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice Register new proxy and initialize metadata\\n    function initialize(\\n        address operator_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        uint8 decimals_\\n    ) external returns (address);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(\\n        address sender,\\n        address spender,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transfer(\\n        address sender,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function mint(\\n        address sender,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function setOperator(address sender, address newOperator) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC20ProxyDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"NewProxy\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"erc20Proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MirrorERC20Factory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000062294f4b4d6e3f1a189ac1a6518f8c861a830ff7","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}