{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/crowdfunds/crowdfund/CrowdfundFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundProxy} from \\\"./CrowdfundProxy.sol\\\";\\nimport {CrowdfundLogic} from \\\"./CrowdfundLogic.sol\\\";\\nimport {ICrowdfund} from \\\"./interface/ICrowdfund.sol\\\";\\nimport {ITributaryRegistry} from \\\"../../../interface/ITributaryRegistry.sol\\\";\\nimport {Governable} from \\\"../../../lib/Governable.sol\\\";\\n\\n/**\\n * @title CrowdfundFactory\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundFactory is Governable {\\n    //======== Structs ========\\n\\n    struct Parameters {\\n        address payable fundingRecipient;\\n        uint256 fundingCap;\\n        uint256 operatorPercent;\\n        uint256 feePercentage;\\n    }\\n\\n    //======== Events ========\\n\\n    event CrowdfundDeployed(\\n        address crowdfundProxy,\\n        string name,\\n        string symbol,\\n        address operator\\n    );\\n\\n    event Upgraded(address indexed implementation);\\n\\n    //======== Configuration storage =========\\n\\n    /*\\n        Updatable via governance\\n    */\\n\\n    address public logic;\\n    address public tributaryRegistry;\\n    address public treasuryConfig;\\n    uint256 public minFeePercentage = 250;\\n\\n    //======== Runtime mutable storage =========\\n\\n    // Gets set within the block, and then deleted.\\n    Parameters public parameters;\\n\\n    //======== Constructor =========\\n\\n    constructor(\\n        address owner_,\\n        address logic_,\\n        address tributaryRegistry_,\\n        address treasuryConfig_\\n    ) Governable(owner_) {\\n        logic = logic_;\\n        tributaryRegistry = tributaryRegistry_;\\n        treasuryConfig = treasuryConfig_;\\n    }\\n\\n    //======== Configuration =========\\n\\n    function setMinimumFeePercentage(uint256 newMinFeePercentage)\\n        public\\n        onlyGovernance\\n    {\\n        minFeePercentage = newMinFeePercentage;\\n    }\\n\\n    function setLogic(address newLogic) public onlyGovernance {\\n        logic = newLogic;\\n    }\\n\\n    function setTreasuryConfig(address newTreasuryConfig)\\n        public\\n        onlyGovernance\\n    {\\n        treasuryConfig = newTreasuryConfig;\\n    }\\n\\n    function setTributaryRegistry(address newTributaryRegistry)\\n        public\\n        onlyGovernance\\n    {\\n        tributaryRegistry = newTributaryRegistry;\\n    }\\n\\n    //======== Deploy function =========\\n    struct TributaryConfig {\\n        address tributary;\\n        uint256 feePercentage;\\n    }\\n\\n    function createCrowdfund(\\n        TributaryConfig calldata tributaryConfig,\\n        string calldata name_,\\n        string calldata symbol_,\\n        address payable operator_,\\n        address payable fundingRecipient_,\\n        uint256 fundingCap_,\\n        uint256 operatorPercent_\\n    ) external returns (address crowdfundProxy) {\\n        require(\\n            tributaryConfig.feePercentage >= minFeePercentage,\\n            \\\"fee is too low\\\"\\n        );\\n\\n        parameters = Parameters({\\n            fundingRecipient: fundingRecipient_,\\n            fundingCap: fundingCap_,\\n            operatorPercent: operatorPercent_,\\n            feePercentage: tributaryConfig.feePercentage\\n        });\\n\\n        crowdfundProxy = address(\\n            new CrowdfundProxy{salt: keccak256(abi.encode(symbol_, operator_))}(\\n                treasuryConfig,\\n                operator_,\\n                name_,\\n                symbol_\\n            )\\n        );\\n\\n        delete parameters;\\n\\n        emit CrowdfundDeployed(crowdfundProxy, name_, symbol_, operator_);\\n\\n        ITributaryRegistry(tributaryRegistry).registerTributary(\\n            crowdfundProxy,\\n            tributaryConfig.tributary\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund/CrowdfundProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundStorage} from \\\"./CrowdfundStorage.sol\\\";\\nimport {ERC20Storage} from \\\"../../../external/ERC20Storage.sol\\\";\\nimport {IERC20Events} from \\\"../../../external/interface/IERC20.sol\\\";\\n\\ninterface ICrowdfundFactory {\\n    function mediaAddress() external returns (address);\\n\\n    function logic() external returns (address);\\n\\n    // ERC20 data.\\n    function parameters()\\n        external\\n        returns (\\n            address payable fundingRecipient,\\n            uint256 fundingCap,\\n            uint256 operatorPercent,\\n            uint256 feePercentage\\n        );\\n}\\n\\n/**\\n * @title CrowdfundProxy\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundProxy is CrowdfundStorage, ERC20Storage, IERC20Events {\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    constructor(\\n        address treasuryConfig_,\\n        address payable operator_,\\n        string memory name_,\\n        string memory symbol_\\n    ) ERC20Storage(name_, symbol_) {\\n        address logic = ICrowdfundFactory(msg.sender).logic();\\n\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, logic)\\n        }\\n\\n        emit Upgraded(logic);\\n\\n        // Crowdfund-specific data.\\n        (\\n            fundingRecipient,\\n            fundingCap,\\n            operatorPercent,\\n            feePercentage\\n        ) = ICrowdfundFactory(msg.sender).parameters();\\n\\n        operator = operator_;\\n        treasuryConfig = treasuryConfig_;\\n        // Initialize mutable storage.\\n        status = Status.FUNDING;\\n    }\\n\\n    /// @notice Get current logic\\n    function logic() external view returns (address logic_) {\\n        assembly {\\n            logic_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    fallback() external payable {\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                sload(_IMPLEMENTATION_SLOT),\\n                ptr,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund/CrowdfundLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundStorage} from \\\"./CrowdfundStorage.sol\\\";\\nimport {ERC20} from \\\"../../../external/ERC20.sol\\\";\\nimport {ICrowdfund} from \\\"./interface/ICrowdfund.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../../interface/ITreasuryConfig.sol\\\";\\n\\n/**\\n * @title CrowdfundLogic\\n * @author MirrorXYZ\\n *\\n * Crowdfund issuing ERC20 tokens that can be redeemed for\\n * the Ether in the contract once funding closes.\\n */\\ncontract CrowdfundLogic is CrowdfundStorage, ERC20 {\\n    // ============ Events ============\\n\\n    event Contribution(address contributor, uint256 amount);\\n\\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\\n    event BidAccepted(uint256 amount);\\n    event Redeemed(address contributor, uint256 amount);\\n    event Withdrawal(uint256 amount, uint256 fee);\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @dev Modifier to check whether the `msg.sender` is the operator.\\n     * If it is, it will run the function. Otherwise, it will revert.\\n     */\\n    modifier onlyOperator() {\\n        require(msg.sender == operator);\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancy_status != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancy_status = REENTRANCY_ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        reentrancy_status = REENTRANCY_NOT_ENTERED;\\n    }\\n\\n    // ============ Crowdfunding Methods ============\\n\\n    /**\\n     * @notice Mints tokens for the sender propotional to the\\n     *  amount of ETH sent in the transaction.\\n     * @dev Emits the Contribution event.\\n     */\\n    function contribute(address payable backer, uint256 amount)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        _contribute(backer, amount);\\n    }\\n\\n    /**\\n     * @notice Burns the sender's tokens and redeems underlying ETH.\\n     * @dev Emits the Redeemed event.\\n     */\\n    function redeem(uint256 tokenAmount) external nonReentrant {\\n        // Prevent backers from accidently redeeming when balance is 0.\\n        require(\\n            address(this).balance > 0,\\n            \\\"Crowdfund: No ETH available to redeem\\\"\\n        );\\n        // Check\\n        require(\\n            balanceOf[msg.sender] >= tokenAmount,\\n            \\\"Crowdfund: Insufficient balance\\\"\\n        );\\n        require(status == Status.TRADING, \\\"Crowdfund: Funding must be trading\\\");\\n        // Effect\\n        uint256 redeemable = redeemableFromTokens(tokenAmount);\\n        _burn(msg.sender, tokenAmount);\\n        // Safe version of transfer.\\n        sendValue(payable(msg.sender), redeemable);\\n        emit Redeemed(msg.sender, redeemable);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of ETH that is redeemable for tokenAmount.\\n     */\\n    function redeemableFromTokens(uint256 tokenAmount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return (tokenAmount * address(this).balance) / totalSupply;\\n    }\\n\\n    function valueToTokens(uint256 value) public pure returns (uint256 tokens) {\\n        tokens = value * TOKEN_SCALE;\\n    }\\n\\n    function tokensToValue(uint256 tokenAmount)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = tokenAmount / TOKEN_SCALE;\\n    }\\n\\n    // ============ Operator Methods ============\\n\\n    /**\\n     * @notice Transfers all funds to operator, and mints tokens for the operator.\\n     *  Updates status to TRADING.\\n     * @dev Emits the FundingClosed event.\\n     */\\n    function closeFunding() external onlyOperator nonReentrant {\\n        require(status == Status.FUNDING, \\\"Crowdfund: Funding must be open\\\");\\n        // Close funding status, move to tradable.\\n        status = Status.TRADING;\\n        // Mint the operator a percent of the total supply.\\n        uint256 operatorTokens = (operatorPercent * totalSupply) /\\n            (100 - operatorPercent);\\n        _mint(operator, operatorTokens);\\n        // Announce that funding has been closed.\\n        emit FundingClosed(address(this).balance, operatorTokens);\\n\\n        _withdraw();\\n    }\\n\\n    /**\\n     * @notice Operator can change the funding recipient.\\n     */\\n    function changeFundingRecipient(address payable newFundingRecipient)\\n        public\\n        onlyOperator\\n    {\\n        fundingRecipient = newFundingRecipient;\\n    }\\n\\n    function withdraw() public {\\n        _withdraw();\\n    }\\n\\n    function computeFee(uint256 amount, uint256 feePercentage_)\\n        public\\n        pure\\n        returns (uint256 fee)\\n    {\\n        fee = (feePercentage_ * amount) / (100 * 100);\\n    }\\n\\n    // ============ Utility Methods ============\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    // ============ Internal Methods  ============\\n    function _contribute(address payable backer, uint256 amount) private {\\n        require(status == Status.FUNDING, \\\"Crowdfund: Funding must be open\\\");\\n        require(amount == msg.value, \\\"Crowdfund: Amount is not value sent\\\");\\n        // This first case is the happy path, so we will keep it efficient.\\n        // The balance, which includes the current contribution, is less than or equal to cap.\\n        if (address(this).balance <= fundingCap) {\\n            // Mint equity for the contributor.\\n            _mint(backer, valueToTokens(amount));\\n\\n            emit Contribution(backer, amount);\\n        } else {\\n            // Compute the balance of the crowdfund before the contribution was made.\\n            uint256 startAmount = address(this).balance - amount;\\n            // If that amount was already greater than the funding cap, then we should revert immediately.\\n            require(\\n                startAmount < fundingCap,\\n                \\\"Crowdfund: Funding cap already reached\\\"\\n            );\\n            // Otherwise, the contribution helped us reach the funding cap. We should\\n            // take what we can until the funding cap is reached, and refund the rest.\\n            uint256 eligibleAmount = fundingCap - startAmount;\\n            // Otherwise, we process the contribution as if it were the minimal amount.\\n            _mint(backer, valueToTokens(eligibleAmount));\\n\\n            emit Contribution(backer, eligibleAmount);\\n            // Refund the sender with their contribution (e.g. 2.5 minus the diff - e.g. 1.5 = 1 ETH)\\n            sendValue(backer, amount - eligibleAmount);\\n        }\\n    }\\n\\n    function _withdraw() internal {\\n        uint256 fee = feePercentage;\\n\\n        emit Withdrawal(\\n            address(this).balance,\\n            computeFee(address(this).balance, fee)\\n        );\\n\\n        // Transfer the fee to the treasury.\\n        sendValue(\\n            ITreasuryConfig(treasuryConfig).treasury(),\\n            computeFee(address(this).balance, fee)\\n        );\\n        // Transfer available balance to the fundingRecipient.\\n        sendValue(fundingRecipient, address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund/interface/ICrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ICrowdfund {\\n    struct Edition {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        // The account that will receive sales revenue.\\n        address payable fundingRecipient;\\n        // The number of tokens sold so far.\\n        uint256 numSold;\\n        bytes32 contentHash;\\n    }\\n\\n    struct EditionTier {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        bytes32 contentHash;\\n    }\\n\\n    function buyEdition(uint256 editionId, address recipient)\\n        external\\n        payable\\n        returns (uint256 tokenId);\\n\\n    function editionPrice(uint256 editionId) external view returns (uint256);\\n\\n    function createEditions(\\n        EditionTier[] memory tier,\\n        // The account that should receive the revenue.\\n        address payable fundingRecipient,\\n        address minter\\n    ) external;\\n\\n    function contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITributaryRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITributaryRegistry {\\n    function addRegistrar(address registrar) external;\\n\\n    function removeRegistrar(address registrar) external;\\n\\n    function addSingletonProducer(address producer) external;\\n\\n    function removeSingletonProducer(address producer) external;\\n\\n    function registerTributary(address producer, address tributary) external;\\n\\n    function producerToTributary(address producer)\\n        external\\n        returns (address tributary);\\n\\n    function singletonProducer(address producer) external returns (bool);\\n\\n    function changeTributary(address producer, address newTributary) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {IGovernable} from \\\"../lib/interface/IGovernable.sol\\\";\\n\\ncontract Governable is Ownable, IGovernable {\\n    // ============ Mutable Storage ============\\n\\n    // Mirror governance contract.\\n    address public override governor;\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyGovernance() {\\n        require(isOwner() || isGovernor(), \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"caller is not governor\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    // ============ Administration ============\\n\\n    function changeGovernor(address governor_) public override onlyGovernance {\\n        governor = governor_;\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isGovernor() public view override returns (bool) {\\n        return msg.sender == governor;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund/CrowdfundStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title CrowdfundStorage\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundStorage {\\n    /**\\n     * @notice The two states that this contract can exist in.\\n     * \\\"FUNDING\\\" allows contributors to add funds.\\n     */\\n    enum Status {\\n        FUNDING,\\n        TRADING\\n    }\\n\\n    // ============ Constants ============\\n\\n    /// @notice The factor by which ETH contributions will multiply into crowdfund tokens.\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n\\n    // ============ Reentrancy ============\\n\\n    /// @notice Reentrancy constants.\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    /// @notice Current reentrancy status -- used by the modifier.\\n    uint256 internal reentrancy_status;\\n\\n    /// @notice The operator has a special role to change contract status.\\n    address payable public operator;\\n\\n    /// @notice Receives the funds when calling withdraw. Operator can configure.\\n    address payable public fundingRecipient;\\n\\n    /// @notice Treasury configuration.\\n    address public treasuryConfig;\\n\\n    /// @notice We add a hard cap to prevent raising more funds than deemed reasonable.\\n    uint256 public fundingCap;\\n\\n    /// @notice Fee percentage that the crowdfund pays to the treasury.\\n    uint256 public feePercentage;\\n\\n    /// @notice The operator takes some equity in the tokens, represented by this percent.\\n    uint256 public operatorPercent;\\n\\n    // ============ Mutable Storage ============\\n\\n    /// @notice Represents the current state of the campaign.\\n    Status public status;\\n}\\n\"\r\n    },\r\n    \"contracts/external/ERC20Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title ERC20Storage\\n * @author MirrorXYZ\\n */\\ncontract ERC20Storage {\\n    /// @notice EIP-20 token name for this token\\n    string public name;\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public symbol;\\n\\n    /// @notice EIP-20 total number of tokens in circulation\\n    uint256 public totalSupply;\\n\\n    /// @notice Initialize total supply to zero.\\n    constructor(string memory name_, string memory symbol_) {\\n        name = name_;\\n        symbol = symbol_;\\n        totalSupply = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC20 {\\n    /// @notice EIP-20 token name for this token\\n    function name() external returns (string calldata);\\n\\n    /// @notice EIP-20 token symbol for this token\\n    function symbol() external returns (string calldata);\\n\\n    /// @notice EIP-20 token decimals for this token\\n    function decimals() external returns (uint8);\\n\\n    /// @notice EIP-20 total number of tokens in circulation\\n    function totalSupply() external returns (uint256);\\n\\n    /// @notice EIP-20 official record of token balances for each account\\n    function balanceOf(address account) external returns (uint256);\\n\\n    /// @notice EIP-20 allowance amounts on behalf of others\\n    function allowance(address owner, address spender)\\n        external\\n        returns (uint256);\\n\\n    /// @notice EIP-20 approves _spender_ to transfer up to _value_ multiple times\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /// @notice EIP-20 transfer _value_ to _to_ from _msg.sender_\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /// @notice EIP-20 transfer _value_ to _to_ from _from_\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Events {\\n    /// @notice EIP-20 Mint event\\n    event Mint(address indexed to, uint256 amount);\\n\\n    /// @notice EIP-20 approval event\\n    event Approval(\\n        address indexed from,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /// @notice EIP-20 transfer event\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// import {ERC20Storage} from \\\"./ERC20Storage.sol\\\";\\nimport {IERC20, IERC20Events} from \\\"./interface/IERC20.sol\\\";\\n\\n/**\\n * @title ERC20 Implementation.\\n * @author MirrorXYZ\\n */\\ncontract ERC20 is IERC20, IERC20Events {\\n    // ============ ERC20 Attributes ============\\n    /// @notice EIP-20 token name for this token\\n    string public override name;\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public override symbol;\\n\\n    /// @notice EIP-20 token decimals for this token\\n    uint8 public constant override decimals = 18;\\n\\n    // ============ Mutable ERC20 Storage ============\\n    /// @notice EIP-20 total number of tokens in circulation\\n    uint256 public override totalSupply;\\n\\n    /// @notice EIP-20 official record of token balances for each account\\n    mapping(address => uint256) public override balanceOf;\\n\\n    /// @notice EIP-20 allowance amounts on behalf of others\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /**\\n     * @notice Initialize and assign total supply when using\\n     * proxy pattern. Only callable during contract deployment.\\n     * @param totalSupply_ is the initial token supply\\n     * @param to_ is the address that will hold the initial token supply\\n     */\\n    function initialize(uint256 totalSupply_, address to_) external {\\n        // Ensure that this function is only callable during contract construction.\\n        assembly {\\n            if extcodesize(address()) {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        totalSupply = totalSupply_;\\n        balanceOf[to_] = totalSupply_;\\n        emit Transfer(address(0), to_, totalSupply_);\\n    }\\n\\n    // ============ ERC20 Spec ============\\n\\n    /**\\n     * @dev Function to increase allowance of tokens.\\n     * @param spender The address that will receive an allowance increase.\\n     * @param value The amount of tokens to increase allowance.\\n     */\\n    function approve(address spender, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to transfer tokens.\\n     * @param to The address that will receive the tokens.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function transfer(address to, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to transfer an accounts tokens. Sender of txn must be approved.\\n     * @param from The address that will transfer tokens.\\n     * @param to The address that will receive the tokens.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        require(\\n            allowance[from][msg.sender] >= value,\\n            \\\"transfer amount exceeds spender allowance\\\"\\n        );\\n\\n        allowance[from][msg.sender] = allowance[from][msg.sender] - value;\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    // ============ Private Utils ============\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply + value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from] - value;\\n        totalSupply = totalSupply - value;\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(balanceOf[from] >= value, \\\"transfer amount exceeds balance\\\");\\n\\n        balanceOf[from] = balanceOf[from] - value;\\n        balanceOf[to] = balanceOf[to] + value;\\n\\n        emit Transfer(from, to, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Ownable {\\n    address public owner;\\n    address private nextOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IGovernable {\\n    function changeGovernor(address governor_) external;\\n\\n    function isGovernor() external view returns (bool);\\n\\n    function governor() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"logic_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributaryRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"crowdfundProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"CrowdfundDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tributary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct CrowdfundFactory.TributaryConfig\",\"name\":\"tributaryConfig\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingCap_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operatorPercent_\",\"type\":\"uint256\"}],\"name\":\"createCrowdfund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"crowdfundProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operatorPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setMinimumFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasuryConfig\",\"type\":\"address\"}],\"name\":\"setTreasuryConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTributaryRegistry\",\"type\":\"address\"}],\"name\":\"setTributaryRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributaryRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CrowdfundFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b570000000000000000000000008cd3dc90eaa8ec8d6391fca22eb72ba3400b3fba0000000000000000000000001171b858777120a59a6cc8148edda8982f187cd800000000000000000000000021a93be569666527dae0fdbfbe7715299dec1202","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}