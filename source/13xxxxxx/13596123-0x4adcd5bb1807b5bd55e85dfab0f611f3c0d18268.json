{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/presale/AxeCirculatingSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\\\\\npragma solidity 0.7.5;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nimport \\\"../libraries/SafeMath.sol\\\";\\n\\ncontract AxeCirculatingSupply {\\n    using SafeMath for uint;\\n\\n    bool public isInitialized;\\n\\n    address public AXE;\\n    address public owner;\\n    address[] public nonCirculatingAXEAddresses;\\n\\n    constructor( address _owner ) {\\n        owner = _owner;\\n    }\\n\\n    function initialize( address _axe ) external returns ( bool ) {\\n        require( msg.sender == owner, \\\"caller is not owner\\\" );\\n        require( isInitialized == false );\\n\\n        AXE = _axe;\\n\\n        isInitialized = true;\\n\\n        return true;\\n    }\\n\\n    function AXECirculatingSupply() external view returns ( uint ) {\\n        uint _totalSupply = IERC20( AXE ).totalSupply();\\n\\n        uint _circulatingSupply = _totalSupply.sub( getNonCirculatingAXE() );\\n\\n        return _circulatingSupply;\\n    }\\n\\n    function getNonCirculatingAXE() public view returns ( uint ) {\\n        uint _nonCirculatingAXE;\\n\\n        for( uint i=0; i < nonCirculatingAXEAddresses.length; i = i.add( 1 ) ) {\\n            _nonCirculatingAXE = _nonCirculatingAXE.add( IERC20( AXE ).balanceOf( nonCirculatingAXEAddresses[i] ) );\\n        }\\n\\n        return _nonCirculatingAXE;\\n    }\\n\\n    function setNonCirculatingAXEAddresses( address[] calldata _nonCirculatingAddresses ) external returns ( bool ) {\\n        require( msg.sender == owner, \\\"Sender is not owner\\\" );\\n        nonCirculatingAXEAddresses = _nonCirculatingAddresses;\\n\\n        return true;\\n    }\\n\\n    function transferOwnership( address _owner ) external returns ( bool ) {\\n        require( msg.sender == owner, \\\"Sender is not owner\\\" );\\n\\n        owner = _owner;\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\\ninterface IERC20Mintable {\\n  function mint( uint256 amount_ ) external;\\n\\n  function mint( address account_, uint256 ammount_ ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AXE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AXECirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNonCirculatingAXE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_axe\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonCirculatingAXEAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nonCirculatingAddresses\",\"type\":\"address[]\"}],\"name\":\"setNonCirculatingAXEAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AxeCirculatingSupply","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ad92618e40356671057d05c1fd0f5862ebe1f39a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}