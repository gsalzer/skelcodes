{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/multiply/MultiplyProxyActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// MultiplyProxyActions.sol\\r\\n\\r\\n// Copyright (C) 2021-2021 Oazo Apps Limited\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../utils/SafeMath.sol\\\";\\r\\nimport \\\"../interfaces/IWETH.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IJoin.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IManager.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IVat.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IJug.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IDaiJoin.sol\\\";\\r\\nimport \\\"../interfaces/exchange/IExchange.sol\\\";\\r\\nimport \\\"./ExchangeData.sol\\\";\\r\\n\\r\\nimport \\\"./../flashMint/interface/IERC3156FlashBorrower.sol\\\";\\r\\nimport \\\"./../flashMint/interface/IERC3156FlashLender.sol\\\";\\r\\n\\r\\npragma solidity >=0.7.6;\\r\\npragma abicoder v2;\\r\\n\\r\\nstruct CdpData {\\r\\n  address gemJoin;\\r\\n  address payable fundsReceiver;\\r\\n  uint256 cdpId;\\r\\n  bytes32 ilk;\\r\\n  uint256 requiredDebt;\\r\\n  uint256 borrowCollateral;\\r\\n  uint256 withdrawCollateral;\\r\\n  uint256 withdrawDai;\\r\\n  uint256 depositDai;\\r\\n  uint256 depositCollateral;\\r\\n  bool skipFL;\\r\\n  string methodName;\\r\\n}\\r\\n\\r\\nstruct AddressRegistry {\\r\\n  address jug;\\r\\n  address manager;\\r\\n  address multiplyProxyActions;\\r\\n  address lender;\\r\\n  address exchange;\\r\\n}\\r\\n\\r\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\r\\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\\r\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\r\\n\\r\\ncontract MultiplyProxyActions is IERC3156FlashBorrower {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  uint256 constant RAY = 10**27;\\r\\n\\r\\n  address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n  address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\r\\n  address public constant DAIJOIN = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\r\\n\\r\\n  modifier logMethodName(\\r\\n    string memory name,\\r\\n    CdpData memory data,\\r\\n    address destination\\r\\n  ) {\\r\\n    if (bytes(data.methodName).length == 0) {\\r\\n      data.methodName = name;\\r\\n    }\\r\\n    _;\\r\\n    data.methodName = \\\"\\\";\\r\\n  }\\r\\n\\r\\n  function takeAFlashLoan(\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    CdpData memory cdpData,\\r\\n    bytes memory paramsData\\r\\n  ) internal {\\r\\n    IManager(addressRegistry.manager).cdpAllow(\\r\\n      cdpData.cdpId,\\r\\n      addressRegistry.multiplyProxyActions,\\r\\n      1\\r\\n    );\\r\\n\\r\\n    IERC3156FlashLender(addressRegistry.lender).flashLoan(\\r\\n      IERC3156FlashBorrower(addressRegistry.multiplyProxyActions),\\r\\n      DAI,\\r\\n      cdpData.requiredDebt,\\r\\n      paramsData\\r\\n    );\\r\\n\\r\\n    IManager(addressRegistry.manager).cdpAllow(\\r\\n      cdpData.cdpId,\\r\\n      addressRegistry.multiplyProxyActions,\\r\\n      0\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function toInt256(uint256 x) internal pure returns (int256 y) {\\r\\n    y = int256(x);\\r\\n    require(y >= 0, \\\"int256-overflow\\\");\\r\\n  }\\r\\n\\r\\n  function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\\r\\n    // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\\r\\n    // Adapters will automatically handle the difference of precision\\r\\n    wad = amt.mul(10**(18 - IJoin(gemJoin).dec()));\\r\\n  }\\r\\n\\r\\n  function _getDrawDart(\\r\\n    address vat,\\r\\n    address jug,\\r\\n    address urn,\\r\\n    bytes32 ilk,\\r\\n    uint256 wad\\r\\n  ) internal returns (int256 dart) {\\r\\n    // Updates stability fee rate\\r\\n    uint256 rate = IJug(jug).drip(ilk);\\r\\n\\r\\n    // Gets DAI balance of the urn in the vat\\r\\n    uint256 dai = IVat(vat).dai(urn);\\r\\n\\r\\n    // If there was already enough DAI in the vat balance, just exits it without adding more debt\\r\\n    if (dai < wad.mul(RAY)) {\\r\\n      // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\\r\\n      dart = toInt256(wad.mul(RAY).sub(dai) / rate);\\r\\n      // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\\r\\n      dart = uint256(dart).mul(rate) < wad.mul(RAY) ? dart + 1 : dart;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function openMultiplyVault(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    payable\\r\\n    logMethodName(\\\"openMultiplyVault\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n    cdpData.cdpId = IManager(addressRegistry.manager).open(cdpData.ilk, address(this));\\r\\n    increaseMultipleDepositCollateral(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function increaseMultipleDepositCollateral(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    payable\\r\\n    logMethodName(\\r\\n      \\\"increaseMultipleDepositCollateral\\\",\\r\\n      cdpData,\\r\\n      addressRegistry.multiplyProxyActions\\r\\n    )\\r\\n  {\\r\\n    IGem gem = IJoin(cdpData.gemJoin).gem();\\r\\n\\r\\n    if (address(gem) == WETH) {\\r\\n      gem.deposit{value: msg.value}();\\r\\n      if (cdpData.skipFL == false) {\\r\\n        gem.transfer(addressRegistry.multiplyProxyActions, msg.value);\\r\\n      }\\r\\n    } else {\\r\\n      if (cdpData.skipFL == false) {\\r\\n        gem.transferFrom(\\r\\n          msg.sender,\\r\\n          addressRegistry.multiplyProxyActions,\\r\\n          cdpData.depositCollateral\\r\\n        );\\r\\n      } else {\\r\\n        gem.transferFrom(msg.sender, address(this), cdpData.depositCollateral);\\r\\n      }\\r\\n    }\\r\\n    increaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function toRad(uint256 wad) internal pure returns (uint256 rad) {\\r\\n    rad = wad.mul(10**27);\\r\\n  }\\r\\n\\r\\n  function drawDaiDebt(\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry,\\r\\n    uint256 amount\\r\\n  ) internal {\\r\\n    address urn = IManager(addressRegistry.manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(addressRegistry.manager).vat();\\r\\n    IManager(addressRegistry.manager).frob(\\r\\n      cdpData.cdpId,\\r\\n      0,\\r\\n      _getDrawDart(vat, addressRegistry.jug, urn, cdpData.ilk, amount)\\r\\n    );\\r\\n    IManager(addressRegistry.manager).move(cdpData.cdpId, address(this), toRad(amount));\\r\\n    if (IVat(vat).can(address(this), address(DAIJOIN)) == 0) {\\r\\n      IVat(vat).hope(DAIJOIN);\\r\\n    }\\r\\n\\r\\n    IJoin(DAIJOIN).exit(address(this), amount);\\r\\n  }\\r\\n\\r\\n  function increaseMultipleDepositDai(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\\"increaseMultipleDepositDai\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    if (cdpData.skipFL) {\\r\\n      IERC20(DAI).transferFrom(msg.sender, address(this), cdpData.depositDai);\\r\\n    } else {\\r\\n      IERC20(DAI).transferFrom(\\r\\n        msg.sender,\\r\\n        addressRegistry.multiplyProxyActions,\\r\\n        cdpData.depositDai\\r\\n      );\\r\\n    }\\r\\n    increaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function increaseMultiple(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) public logMethodName(\\\"increaseMultiple\\\", cdpData, addressRegistry.multiplyProxyActions) {\\r\\n    increaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function increaseMultipleInternal(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) internal {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n\\r\\n    bytes memory paramsData = abi.encode(1, exchangeData, cdpData, addressRegistry);\\r\\n\\r\\n    if (cdpData.skipFL) {\\r\\n      //we want to draw our own DAI and use them in the exchange to buy collateral\\r\\n      IGem gem = IJoin(cdpData.gemJoin).gem();\\r\\n      uint256 collBalance = IERC20(address(gem)).balanceOf(address(this));\\r\\n      if (collBalance > 0) {\\r\\n        //if someone provided some collateral during increase\\r\\n        //add it to vault and draw DAI\\r\\n        joinDrawDebt(cdpData, cdpData.requiredDebt, addressRegistry.manager, addressRegistry.jug);\\r\\n      } else {\\r\\n        //just draw DAI\\r\\n        drawDaiDebt(cdpData, addressRegistry, cdpData.requiredDebt);\\r\\n      }\\r\\n      _increaseMP(exchangeData, cdpData, addressRegistry, 0);\\r\\n    } else {\\r\\n      takeAFlashLoan(addressRegistry, cdpData, paramsData);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function decreaseMultiple(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) public logMethodName(\\\"decreaseMultiple\\\", cdpData, addressRegistry.multiplyProxyActions) {\\r\\n    decreaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function decreaseMultipleInternal(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) internal {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n\\r\\n    bytes memory paramsData = abi.encode(0, exchangeData, cdpData, addressRegistry);\\r\\n\\r\\n    if (cdpData.skipFL) {\\r\\n      _decreaseMP(exchangeData, cdpData, addressRegistry, 0);\\r\\n    } else {\\r\\n      takeAFlashLoan(addressRegistry, cdpData, paramsData);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function decreaseMultipleWithdrawCollateral(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\r\\n      \\\"decreaseMultipleWithdrawCollateral\\\",\\r\\n      cdpData,\\r\\n      addressRegistry.multiplyProxyActions\\r\\n    )\\r\\n  {\\r\\n    decreaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function decreaseMultipleWithdrawDai(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\\"decreaseMultipleWithdrawDai\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    decreaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function closeVaultExitGeneric(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry,\\r\\n    uint8 mode\\r\\n  ) private {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n\\r\\n    address urn = IManager(addressRegistry.manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(addressRegistry.manager).vat();\\r\\n\\r\\n    uint256 wadD = _getWipeAllWad(vat, urn, urn, cdpData.ilk);\\r\\n    cdpData.requiredDebt = wadD;\\r\\n\\r\\n    bytes memory paramsData = abi.encode(mode, exchangeData, cdpData, addressRegistry);\\r\\n\\r\\n    if (cdpData.skipFL == false) {\\r\\n      takeAFlashLoan(addressRegistry, cdpData, paramsData);\\r\\n    } else {\\r\\n      if (mode == 2) {\\r\\n        _closeWithdrawCollateralSkipFL(\\r\\n          exchangeData,\\r\\n          cdpData,\\r\\n          addressRegistry,\\r\\n          cdpData.borrowCollateral\\r\\n        );\\r\\n      } else {\\r\\n        require(false, \\\"this code should be unreachable\\\");\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function closeVaultExitCollateral(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\\"closeVaultExitCollateral\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    closeVaultExitGeneric(exchangeData, cdpData, addressRegistry, 2);\\r\\n  }\\r\\n\\r\\n  function closeVaultExitDai(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) public logMethodName(\\\"closeVaultExitDai\\\", cdpData, addressRegistry.multiplyProxyActions) {\\r\\n    require(cdpData.skipFL == false, \\\"cannot close to DAI if FL not used\\\");\\r\\n    closeVaultExitGeneric(exchangeData, cdpData, addressRegistry, 3);\\r\\n  }\\r\\n\\r\\n  function joinDrawDebt(\\r\\n    CdpData memory cdpData,\\r\\n    uint256 borrowedDai,\\r\\n    address manager,\\r\\n    address jug\\r\\n  ) private {\\r\\n    IGem gem = IJoin(cdpData.gemJoin).gem();\\r\\n\\r\\n    uint256 balance = IERC20(address(gem)).balanceOf(address(this));\\r\\n    gem.approve(address(cdpData.gemJoin), balance);\\r\\n\\r\\n    address urn = IManager(manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(manager).vat();\\r\\n\\r\\n    IJoin(cdpData.gemJoin).join(urn, balance);\\r\\n\\r\\n    IManager(manager).frob(\\r\\n      cdpData.cdpId,\\r\\n      toInt256(convertTo18(cdpData.gemJoin, balance)),\\r\\n      _getDrawDart(vat, jug, urn, cdpData.ilk, borrowedDai)\\r\\n    );\\r\\n    IManager(manager).move(cdpData.cdpId, address(this), borrowedDai.mul(RAY));\\r\\n\\r\\n    IVat(vat).hope(DAIJOIN);\\r\\n\\r\\n    IJoin(DAIJOIN).exit(address(this), borrowedDai);\\r\\n  }\\r\\n\\r\\n  function getInk(address manager, CdpData memory cdpData) internal view returns (uint256) {\\r\\n    address urn = IManager(manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(manager).vat();\\r\\n\\r\\n    (uint256 ink, ) = IVat(vat).urns(cdpData.ilk, urn);\\r\\n    return ink;\\r\\n  }\\r\\n\\r\\n  function _getWipeDart(\\r\\n    address vat,\\r\\n    uint256 dai,\\r\\n    address urn,\\r\\n    bytes32 ilk\\r\\n  ) internal view returns (int256 dart) {\\r\\n    // Gets actual rate from the vat\\r\\n    (, uint256 rate, , , ) = IVat(vat).ilks(ilk);\\r\\n    // Gets actual art value of the urn\\r\\n    (, uint256 art) = IVat(vat).urns(ilk, urn);\\r\\n\\r\\n    // Uses the whole dai balance in the vat to reduce the debt\\r\\n    dart = toInt256(dai / rate);\\r\\n    // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\\r\\n    dart = uint256(dart) <= art ? -dart : -toInt256(art);\\r\\n  }\\r\\n\\r\\n  function _getWipeAllWad(\\r\\n    address vat,\\r\\n    address usr,\\r\\n    address urn,\\r\\n    bytes32 ilk\\r\\n  ) internal view returns (uint256 wad) {\\r\\n    // Gets actual rate from the vat\\r\\n    (, uint256 rate, , , ) = IVat(vat).ilks(ilk);\\r\\n    // Gets actual art value of the urn\\r\\n    (, uint256 art) = IVat(vat).urns(ilk, urn);\\r\\n    // Gets actual dai amount in the urn\\r\\n    uint256 dai = IVat(vat).dai(usr);\\r\\n\\r\\n    uint256 rad = art.mul(rate).sub(dai);\\r\\n    wad = rad / RAY;\\r\\n\\r\\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\\r\\n    wad = wad.mul(RAY) < rad ? wad + 1 : wad;\\r\\n  }\\r\\n\\r\\n  function wipeAndFreeGem(\\r\\n    address manager,\\r\\n    address gemJoin,\\r\\n    uint256 cdp,\\r\\n    uint256 borrowedDai,\\r\\n    uint256 collateralDraw\\r\\n  ) internal {\\r\\n    address vat = IManager(manager).vat();\\r\\n    address urn = IManager(manager).urns(cdp);\\r\\n    bytes32 ilk = IManager(manager).ilks(cdp);\\r\\n\\r\\n    IERC20(DAI).approve(DAIJOIN, borrowedDai);\\r\\n    IDaiJoin(DAIJOIN).join(urn, borrowedDai);\\r\\n\\r\\n    uint256 wadC = convertTo18(gemJoin, collateralDraw);\\r\\n\\r\\n    IManager(manager).frob(cdp, -toInt256(wadC), _getWipeDart(vat, IVat(vat).dai(urn), urn, ilk));\\r\\n\\r\\n    IManager(manager).flux(cdp, address(this), wadC);\\r\\n    IJoin(gemJoin).exit(address(this), collateralDraw);\\r\\n  }\\r\\n\\r\\n  function _withdrawGem(\\r\\n    address gemJoin,\\r\\n    address payable destination,\\r\\n    uint256 amount\\r\\n  ) private {\\r\\n    IGem gem = IJoin(gemJoin).gem();\\r\\n\\r\\n    if (address(gem) == WETH) {\\r\\n      gem.withdraw(amount);\\r\\n      destination.transfer(amount);\\r\\n    } else {\\r\\n      IERC20(address(gem)).transfer(destination, amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _increaseMP(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 premium\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    uint256 borrowedDai = cdpData.requiredDebt.add(premium);\\r\\n    if (cdpData.skipFL) {\\r\\n      borrowedDai = 0; //this DAI are not borrowed and shal not stay after this method execution\\r\\n    }\\r\\n    require(\\r\\n      IERC20(DAI).approve(address(exchange), exchangeData.fromTokenAmount.add(cdpData.depositDai)),\\r\\n      \\\"MPA / Could not approve Exchange for DAI\\\"\\r\\n    );\\r\\n    exchange.swapDaiForToken(\\r\\n      exchangeData.toTokenAddress,\\r\\n      exchangeData.fromTokenAmount.add(cdpData.depositDai),\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n    //here we add collateral we got from exchange, if skipFL then borrowedDai = 0\\r\\n    joinDrawDebt(cdpData, borrowedDai, addressRegistry.manager, addressRegistry.jug);\\r\\n    //if some DAI are left after exchange return them to the user\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDai);\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      0,\\r\\n      daiLeft\\r\\n    );\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _decreaseMP(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 premium\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n\\r\\n    uint256 debtToBeWiped = cdpData.skipFL ? 0 : cdpData.requiredDebt.sub(cdpData.withdrawDai);\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      debtToBeWiped,\\r\\n      cdpData.borrowCollateral.add(cdpData.withdrawCollateral)\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(\\r\\n        address(exchange),\\r\\n        exchangeData.fromTokenAmount\\r\\n      ),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      exchangeData.fromTokenAmount,\\r\\n      cdpData.requiredDebt.add(premium),\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 collateralLeft = IERC20(exchangeData.fromTokenAddress).balanceOf(address(this));\\r\\n\\r\\n    uint256 daiLeft = 0;\\r\\n    if (cdpData.skipFL) {\\r\\n      wipeAndFreeGem(\\r\\n        addressRegistry.manager,\\r\\n        cdpData.gemJoin,\\r\\n        cdpData.cdpId,\\r\\n        IERC20(DAI).balanceOf(address(this)).sub(cdpData.withdrawDai),\\r\\n        0\\r\\n      );\\r\\n      daiLeft = cdpData.withdrawDai;\\r\\n    } else {\\r\\n      daiLeft = IERC20(DAI).balanceOf(address(this)).sub(cdpData.requiredDebt.add(premium));\\r\\n    }\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _closeWithdrawCollateralSkipFL(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 ink\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    address gemAddress = address(IJoin(cdpData.gemJoin).gem());\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      0,\\r\\n      exchangeData.fromTokenAmount\\r\\n    );\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(address(exchange), ink),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      exchangeData.fromTokenAmount,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this));\\r\\n\\r\\n    require(cdpData.requiredDebt <= daiLeft, \\\"cannot repay all debt\\\");\\r\\n    \\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      cdpData.requiredDebt,\\r\\n      cdpData.withdrawCollateral\\r\\n    );\\r\\n    daiLeft = IERC20(DAI).balanceOf(address(this));\\r\\n\\r\\n    uint256 collateralLeft = IERC20(gemAddress).balanceOf(address(this));\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function _closeWithdrawCollateral(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 borrowedDaiAmount,\\r\\n    uint256 ink\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    address gemAddress = address(IJoin(cdpData.gemJoin).gem());\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      cdpData.requiredDebt,\\r\\n      ink\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(address(exchange), ink),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      exchangeData.fromTokenAmount,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDaiAmount);\\r\\n    uint256 collateralLeft = IERC20(gemAddress).balanceOf(address(this));\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function _closeWithdrawDai(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 borrowedDaiAmount,\\r\\n    uint256 ink\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    address gemAddress = address(IJoin(cdpData.gemJoin).gem());\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      cdpData.requiredDebt,\\r\\n      ink\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(\\r\\n        address(exchange),\\r\\n        IERC20(gemAddress).balanceOf(address(this))\\r\\n      ),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      ink,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDaiAmount);\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    uint256 collateralLeft = IERC20(gemAddress).balanceOf(address(this));\\r\\n    /*\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }*/\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function onFlashLoan(\\r\\n    address initiator,\\r\\n    address token,\\r\\n    uint256 amount,\\r\\n    uint256 fee,\\r\\n    bytes calldata params\\r\\n  ) public override returns (bytes32) {\\r\\n    (\\r\\n      uint8 mode,\\r\\n      ExchangeData memory exchangeData,\\r\\n      CdpData memory cdpData,\\r\\n      AddressRegistry memory addressRegistry\\r\\n    ) = abi.decode(params, (uint8, ExchangeData, CdpData, AddressRegistry));\\r\\n\\r\\n    require(msg.sender == address(addressRegistry.lender), \\\"mpa-untrusted-lender\\\");\\r\\n\\r\\n    uint256 borrowedDaiAmount = amount.add(fee);\\r\\n    emit FLData(IERC20(DAI).balanceOf(address(this)).sub(cdpData.depositDai), borrowedDaiAmount);\\r\\n\\r\\n    require(\\r\\n      cdpData.requiredDebt.add(cdpData.depositDai) <= IERC20(DAI).balanceOf(address(this)),\\r\\n      \\\"mpa-receive-requested-amount-mismatch\\\"\\r\\n    );\\r\\n\\r\\n    if (mode == 0) {\\r\\n      _decreaseMP(exchangeData, cdpData, addressRegistry, fee);\\r\\n    }\\r\\n    if (mode == 1) {\\r\\n      _increaseMP(exchangeData, cdpData, addressRegistry, fee);\\r\\n    }\\r\\n    if (mode == 2) {\\r\\n      _closeWithdrawCollateral(\\r\\n        exchangeData,\\r\\n        cdpData,\\r\\n        addressRegistry,\\r\\n        borrowedDaiAmount,\\r\\n        cdpData.borrowCollateral\\r\\n      );\\r\\n    }\\r\\n    if (mode == 3) {\\r\\n      _closeWithdrawDai(\\r\\n        exchangeData,\\r\\n        cdpData,\\r\\n        addressRegistry,\\r\\n        borrowedDaiAmount,\\r\\n        cdpData.borrowCollateral\\r\\n      );\\r\\n    }\\r\\n\\r\\n    IERC20(token).approve(addressRegistry.lender, borrowedDaiAmount);\\r\\n\\r\\n    return keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\r\\n  }\\r\\n\\r\\n  event FLData(uint256 borrowed, uint256 due);\\r\\n  event MultipleActionCalled(\\r\\n    string methodName,\\r\\n    uint256 indexed cdpId,\\r\\n    uint256 swapMinAmount,\\r\\n    uint256 swapOptimistAmount,\\r\\n    uint256 collateralLeft,\\r\\n    uint256 daiLeft\\r\\n  );\\r\\n\\r\\n  fallback() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n  function totalSupply() external view returns (uint256 supply);\\r\\n\\r\\n  function balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n  function transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _value\\r\\n  ) external returns (bool success);\\r\\n\\r\\n  function approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n\\r\\n  function decimals() external view returns (uint256 digits);\\r\\n\\r\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.6;\\r\\n\\r\\nlibrary SafeMath {\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, 'SafeMath: addition overflow');\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\r\\n  }\\r\\n\\r\\n  function sub(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b <= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, 'SafeMath: division by zero');\\r\\n  }\\r\\n\\r\\n  function div(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b > 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, 'SafeMath: modulo by zero');\\r\\n  }\\r\\n\\r\\n  function mod(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './IERC20.sol';\\r\\n\\r\\nabstract contract IWETH {\\r\\n  function allowance(address, address) public virtual returns (uint256);\\r\\n\\r\\n  function balanceOf(address) public virtual returns (uint256);\\r\\n\\r\\n  function approve(address, uint256) public virtual;\\r\\n\\r\\n  function transfer(address, uint256) public virtual returns (bool);\\r\\n\\r\\n  function transferFrom(\\r\\n    address,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual returns (bool);\\r\\n\\r\\n  function deposit() public payable virtual;\\r\\n\\r\\n  function withdraw(uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './IGem.sol';\\r\\n\\r\\nabstract contract IJoin {\\r\\n  bytes32 public ilk;\\r\\n\\r\\n  function dec() public view virtual returns (uint256);\\r\\n\\r\\n  function gem() public view virtual returns (IGem);\\r\\n\\r\\n  function join(address, uint256) public payable virtual;\\r\\n\\r\\n  function exit(address, uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IManager {\\r\\n  function last(address) public virtual returns (uint256);\\r\\n\\r\\n  function cdpCan(\\r\\n    address,\\r\\n    uint256,\\r\\n    address\\r\\n  ) public view virtual returns (uint256);\\r\\n\\r\\n  function ilks(uint256) public view virtual returns (bytes32);\\r\\n\\r\\n  function owns(uint256) public view virtual returns (address);\\r\\n\\r\\n  function urns(uint256) public view virtual returns (address);\\r\\n\\r\\n  function vat() public view virtual returns (address);\\r\\n\\r\\n  function open(bytes32, address) public virtual returns (uint256);\\r\\n\\r\\n  function give(uint256, address) public virtual;\\r\\n\\r\\n  function cdpAllow(\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function urnAllow(address, uint256) public virtual;\\r\\n\\r\\n  function frob(\\r\\n    uint256,\\r\\n    int256,\\r\\n    int256\\r\\n  ) public virtual;\\r\\n\\r\\n  function flux(\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function move(\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function exit(\\r\\n    address,\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function quit(uint256, address) public virtual;\\r\\n\\r\\n  function enter(address, uint256) public virtual;\\r\\n\\r\\n  function shift(uint256, uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IVat {\\r\\n  struct Urn {\\r\\n    uint256 ink; // Locked Collateral  [wad]\\r\\n    uint256 art; // Normalised Debt    [wad]\\r\\n  }\\r\\n\\r\\n  struct Ilk {\\r\\n    uint256 Art; // Total Normalised Debt     [wad]\\r\\n    uint256 rate; // Accumulated Rates         [ray]\\r\\n    uint256 spot; // Price with Safety Margin  [ray]\\r\\n    uint256 line; // Debt Ceiling              [rad]\\r\\n    uint256 dust; // Urn Debt Floor            [rad]\\r\\n  }\\r\\n\\r\\n  mapping(bytes32 => mapping(address => Urn)) public urns;\\r\\n  mapping(bytes32 => Ilk) public ilks;\\r\\n  mapping(bytes32 => mapping(address => uint256)) public gem; // [wad]\\r\\n\\r\\n  function can(address, address) public view virtual returns (uint256);\\r\\n\\r\\n  function dai(address) public view virtual returns (uint256);\\r\\n\\r\\n  function frob(\\r\\n    bytes32,\\r\\n    address,\\r\\n    address,\\r\\n    address,\\r\\n    int256,\\r\\n    int256\\r\\n  ) public virtual;\\r\\n\\r\\n  function hope(address) public virtual;\\r\\n\\r\\n  function move(\\r\\n    address,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function fork(\\r\\n    bytes32,\\r\\n    address,\\r\\n    address,\\r\\n    int256,\\r\\n    int256\\r\\n  ) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IJug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IJug {\\r\\n  struct Ilk {\\r\\n    uint256 duty;\\r\\n    uint256 rho;\\r\\n  }\\r\\n\\r\\n  mapping(bytes32 => Ilk) public ilks;\\r\\n\\r\\n  function drip(bytes32) public virtual returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IDaiJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './IVat.sol';\\r\\nimport './IGem.sol';\\r\\n\\r\\nabstract contract IDaiJoin {\\r\\n  function vat() public virtual returns (IVat);\\r\\n\\r\\n  function dai() public virtual returns (IGem);\\r\\n\\r\\n  function join(address, uint256) public payable virtual;\\r\\n\\r\\n  function exit(address, uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/exchange/IExchange.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.0;\\r\\n\\r\\nabstract contract IExchange {\\r\\n  function swapDaiForToken(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 receiveAtLeast,\\r\\n    address callee,\\r\\n    bytes calldata withData\\r\\n  ) external virtual;\\r\\n\\r\\n  function swapTokenForDai(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 receiveAtLeast,\\r\\n    address callee,\\r\\n    bytes calldata withData\\r\\n  ) external virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/multiply/ExchangeData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity >=0.7.6;\\n\\nstruct ExchangeData {\\n  address fromTokenAddress;\\n  address toTokenAddress;\\n  uint256 fromTokenAmount;\\n  uint256 toTokenAmount;\\n  uint256 minToTokenAmount;\\n  address exchangeAddress;\\n  bytes _exchangeCalldata;\\n}\\n\"\r\n    },\r\n    \"contracts/flashMint/interface/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n// Copyright (C) 2021 Dai Foundation\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity >=0.6.12;\\r\\n\\r\\ninterface IERC3156FlashBorrower {\\r\\n\\r\\n    /**\\r\\n     * @dev Receive a flash loan.\\r\\n     * @param initiator The initiator of the loan.\\r\\n     * @param token The loan currency.\\r\\n     * @param amount The amount of tokens lent.\\r\\n     * @param fee The additional amount of tokens to repay.\\r\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\r\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\r\\n     */\\r\\n    function onFlashLoan(\\r\\n        address initiator,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        uint256 fee,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/flashMint/interface/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n// Copyright (C) 2021 Dai Foundation\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity >=0.6.12;\\r\\n\\r\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\r\\n\\r\\ninterface IERC3156FlashLender {\\r\\n\\r\\n    /**\\r\\n     * @dev The amount of currency available to be lent.\\r\\n     * @param token The loan currency.\\r\\n     * @return The amount of `token` that can be borrowed.\\r\\n     */\\r\\n    function maxFlashLoan(\\r\\n        address token\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev The fee to be charged for a given loan.\\r\\n     * @param token The loan currency.\\r\\n     * @param amount The amount of tokens lent.\\r\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\r\\n     */\\r\\n    function flashFee(\\r\\n        address token,\\r\\n        uint256 amount\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Initiate a flash loan.\\r\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\r\\n     * @param token The loan currency.\\r\\n     * @param amount The amount of tokens lent.\\r\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\r\\n     */\\r\\n    function flashLoan(\\r\\n        IERC3156FlashBorrower receiver,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IGem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IGem {\\r\\n  function dec() public virtual returns (uint256);\\r\\n\\r\\n  function gem() public virtual returns (IGem);\\r\\n\\r\\n  function join(address, uint256) public payable virtual;\\r\\n\\r\\n  function exit(address, uint256) public virtual;\\r\\n\\r\\n  function approve(address, uint256) public virtual;\\r\\n\\r\\n  function transfer(address, uint256) public virtual returns (bool);\\r\\n\\r\\n  function transferFrom(\\r\\n    address,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual returns (bool);\\r\\n\\r\\n  function deposit() public payable virtual;\\r\\n\\r\\n  function withdraw(uint256) public virtual;\\r\\n\\r\\n  function allowance(address, address) public virtual returns (uint256);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"due\",\"type\":\"uint256\"}],\"name\":\"FLData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapMinAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapOptimistAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiLeft\",\"type\":\"uint256\"}],\"name\":\"MultipleActionCalled\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAIJOIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"closeVaultExitCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"closeVaultExitDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"decreaseMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"decreaseMultipleWithdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"decreaseMultipleWithdrawDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultipleDepositCollateral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultipleDepositDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"openMultiplyVault\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"MultiplyProxyActions","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}