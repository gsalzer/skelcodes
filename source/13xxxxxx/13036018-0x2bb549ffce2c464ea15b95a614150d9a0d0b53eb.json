{"status":"1","message":"OK","result":[{"SourceCode":"// File: node_modules\\@openzeppelin\\contracts\\utils\\introspection\\IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC1155\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\model\\IERC1155Views.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title IERC1155Views - An optional utility interface to improve the ERC-1155 Standard.\r\n * @dev This interface introduces some additional capabilities for ERC-1155 Tokens.\r\n */\r\ninterface IERC1155Views {\r\n\r\n    /**\r\n     * @dev Returns the total supply of the given token id\r\n     * @param itemId the id of the token whose availability you want to know \r\n     */\r\n    function totalSupply(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the name of the given token id\r\n     * @param itemId the id of the token whose name you want to know \r\n     */\r\n    function name(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the given token id\r\n     * @param itemId the id of the token whose symbol you want to know \r\n     */\r\n    function symbol(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals of the given token id\r\n     * @param itemId the id of the token whose decimals you want to know \r\n     */\r\n    function decimals(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the uri of the given token id\r\n     * @param itemId the id of the token whose uri you want to know \r\n     */\r\n    function uri(uint256 itemId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\model\\Item.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\npragma abicoder v2;\r\n\r\n\r\n\r\nstruct Header {\r\n    address host;\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n}\r\n\r\nstruct CreateItem {\r\n    Header header;\r\n    bytes32 collectionId;\r\n    uint256 id;\r\n    address[] accounts;\r\n    uint256[] amounts;\r\n}\r\n\r\ninterface Item is IERC1155, IERC1155Views {\r\n\r\n    event CollectionItem(bytes32 indexed fromCollectionId, bytes32 indexed toCollectionId, uint256 indexed itemId);\r\n\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts) external;\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes calldata data) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) external;\r\n\r\n    function mintItems(CreateItem[] calldata items) external returns(uint256[] memory itemIds);\r\n    function setItemsCollection(uint256[] calldata itemIds, bytes32[] calldata collectionIds) external returns(bytes32[] memory oldCollectionIds);\r\n    function setItemsMetadata(uint256[] calldata itemIds, Header[] calldata amounts) external returns(Header[] memory oldValues);\r\n\r\n    function interoperableOf(uint256 itemId) external view returns(address);\r\n}\r\n\r\n// File: node_modules\\@ethereansos\\swissknife\\contracts\\generic\\model\\ILazyInitCapableElement.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface ILazyInitCapableElement is IERC165 {\r\n\r\n    function lazyInit(bytes calldata lazyInitData) external returns(bytes memory initResponse);\r\n    function initializer() external view returns(address);\r\n\r\n    event Host(address indexed from, address indexed to);\r\n\r\n    function host() external view returns(address);\r\n    function setHost(address newValue) external returns(address oldValue);\r\n\r\n    function subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata payload, uint256 value) external view returns(bool);\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\dynamicMetadata\\model\\IDynamicMetadataCapableElement.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface IDynamicMetadataCapableElement is ILazyInitCapableElement {\r\n\r\n    function uri() external view returns(string memory);\r\n    function plainUri() external view returns(string memory);\r\n\r\n    function setUri(string calldata newValue) external returns (string memory oldValue);\r\n\r\n    function dynamicUriResolver() external view returns(address);\r\n    function setDynamicUriResolver(address newValue) external returns(address oldValue);\r\n}\r\n\r\n// File: contracts\\model\\IItemMainInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\nstruct ItemData {\r\n    bytes32 collectionId;\r\n    Header header;\r\n    bytes32 domainSeparator;\r\n    uint256 totalSupply;\r\n    mapping(address => uint256) balanceOf;\r\n    mapping(address => mapping(address => uint256)) allowance;\r\n    mapping(address => uint256) nonces;\r\n}\r\n\r\ninterface IItemMainInterface is Item, IDynamicMetadataCapableElement {\r\n\r\n    event Collection(address indexed from, address indexed to, bytes32 indexed collectionId);\r\n\r\n    function interoperableInterfaceModel() external view returns(address);\r\n\r\n    function collection(bytes32 collectionId) external view returns(address host, string memory name, string memory symbol, string memory uri);\r\n    function collectionUri(bytes32 collectionId) external view returns(string memory);\r\n    function createCollection(Header calldata _collection, CreateItem[] calldata items) external returns(bytes32 collectionId, uint256[] memory itemIds);\r\n    function setCollectionsMetadata(bytes32[] calldata collectionIds, Header[] calldata values) external returns(Header[] memory oldValues);\r\n\r\n    function item(uint256 itemId) external view returns(bytes32 collectionId, Header memory header, bytes32 domainSeparator, uint256 totalSupply);\r\n\r\n    function mintTransferOrBurn(bool isMulti, bytes calldata data) external;\r\n\r\n    function allowance(address account, address spender, uint256 itemId) external view returns(uint256);\r\n    function approve(address account, address spender, uint256 amount, uint256 itemId) external;\r\n    function TYPEHASH_PERMIT() external view returns (bytes32);\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external view returns(string memory domainSeparatorName, string memory domainSeparatorVersion);\r\n    function permit(uint256 itemId, address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address owner, uint256 itemId) external view returns(uint256);\r\n}\r\n\r\n// File: contracts\\impl\\ItemMainInterfaceSupportsInterfaceImplementer.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\ncontract ItemMainInterfaceSupportsInterfaceImplementer is IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external override pure returns(bool) {\r\n        return \r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == IItemMainInterface(address(0)).balanceOf.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).balanceOfBatch.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setApprovalForAll.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).isApprovedForAll.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).safeTransferFrom.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).safeBatchTransferFrom.selector ||\r\n            interfaceId == 0xd9b67a26 ||//OpenSea Standard\r\n            interfaceId == type(IERC1155Views).interfaceId ||\r\n            interfaceId == IItemMainInterface(address(0)).totalSupply.selector ||\r\n            interfaceId == 0x00ad800c ||//name(uint256)\r\n            interfaceId == 0x4e41a1fb ||//symbol(uint256)\r\n            interfaceId == IItemMainInterface(address(0)).decimals.selector ||\r\n            interfaceId == 0x0e89341c ||//uri(uint256)\r\n            interfaceId == type(Item).interfaceId ||\r\n            interfaceId == 0x06fdde03 ||//name()\r\n            interfaceId == 0x95d89b41 ||//symbol()\r\n            interfaceId == 0xf5298aca ||//burn(address,uint256,uint256)\r\n            interfaceId == 0x6b20c454 ||//burnBatch(address,uint256[],uint256[])\r\n            interfaceId == 0x8a94b05f ||//burn(address,uint256,uint256,bytes)\r\n            interfaceId == 0x5473422e ||//burnBatch(address,uint256[],uint256[],bytes)\r\n            interfaceId == IItemMainInterface(address(0)).mintItems.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setItemsCollection.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setItemsMetadata.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).interoperableOf.selector ||\r\n            interfaceId == type(IItemMainInterface).interfaceId ||\r\n            interfaceId == IItemMainInterface(address(0)).interoperableInterfaceModel.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).collection.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).collectionUri.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).createCollection.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setCollectionsMetadata.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).item.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).mintTransferOrBurn.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).allowance.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).approve.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).TYPEHASH_PERMIT.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).permit.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).nonces.selector;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ItemMainInterfaceSupportsInterfaceImplementer","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5c04bb4a7ac07357c0fc49d8df902bd0b5b83a9a60ad150907db5db937dfc6b8"}]}