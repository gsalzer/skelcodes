{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n// Copyright 2021 David Huber (@cxkoda)\r\n// All Rights Reserved\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @notice A point on the sphere with unit radius.\r\n * @dev Since we will be interested in 3D points in the end, it makes more\r\n * sense to just store trigonimetric values (and don't spend the effort\r\n * to invert to the actual angles).\r\n */\r\nstruct SphericalPoint {\r\n    int256 sinAzimuth;\r\n    int256 cosAzimuth;\r\n    int256 sinAltitude;\r\n    int256 cosAltitude;\r\n}\r\n\r\n/**\r\n * @notice Some special math functions used for `Strange Attractors`.\r\n * @dev The functions use fixed-point number with the same precision (96) as\r\n * the numerical solvers (see also `IAttractorSolver`).\r\n * @author David Huber (@cxkoda)\r\n */\r\nlibrary MathHelpers {\r\n    uint8 public constant PRECISION = 96;\r\n\r\n    /**\r\n     * @dev Some handy constants.\r\n     */\r\n    int256 private constant ONE = 2**96;\r\n    int256 public constant PI = 248902613312231085230521944622;\r\n    int256 public constant PI_2 = 497805226624462170461043889244;\r\n    int256 public constant MINUS_PI_2 = -497805226624462170461043889244;\r\n    int256 public constant PI_0_5 = 124451306656115542615260972311;\r\n\r\n    /**\r\n     * @notice Taylor series coefficients for sin around 0.\r\n     */\r\n    int256 private constant COEFFICIENTS_SIN_1 = 2**96;\r\n    int256 private constant COEFFICIENTS_SIN_3 = -(2**96 + 2) / 6;\r\n    int256 private constant COEFFICIENTS_SIN_5 = (2**96 - 16) / 120;\r\n    int256 private constant COEFFICIENTS_SIN_7 = -(2**96 + 944) / 5040;\r\n    int256 private constant COEFFICIENTS_SIN_9 = (2**96 - 205696) / 362880;\r\n    int256 private constant COEFFICIENTS_SIN_11 =\r\n        -(2**96 + 34993664) / 39916800;\r\n\r\n    /**\r\n     * @notice A pure solidity approximation of the sine function.\r\n     * @dev The implementation uses a broken Taylor series approximation to\r\n     * compute values. The absolute error is <1e-3.\r\n     */\r\n    function sin(int256 x) public pure returns (int256 result) {\r\n        assembly {\r\n            // We remap the x to the range [-pi, pi] first, since the Taylor\r\n            // series is most accurate there.\r\n\r\n            // Attention: smod(-10, 2) = -10 but smod(-10, -2) = 0\r\n            // We therefore shift the numbers to the positive side first\r\n            x := add(smod(x, MINUS_PI_2), PI_2)\r\n\r\n            // Restrict to the range [-pi, pi]\r\n            x := sub(addmod(x, PI, PI_2), PI)\r\n\r\n            let x2 := sar(PRECISION, mul(x, x))\r\n            result := sar(\r\n                PRECISION,\r\n                mul(\r\n                    x,\r\n                    add(\r\n                        COEFFICIENTS_SIN_1,\r\n                        sar(\r\n                            PRECISION,\r\n                            mul(\r\n                                x2,\r\n                                add(\r\n                                    COEFFICIENTS_SIN_3,\r\n                                    sar(\r\n                                        PRECISION,\r\n                                        mul(\r\n                                            x2,\r\n                                            add(\r\n                                                COEFFICIENTS_SIN_5,\r\n                                                sar(\r\n                                                    PRECISION,\r\n                                                    mul(\r\n                                                        x2,\r\n                                                        add(\r\n                                                            COEFFICIENTS_SIN_7,\r\n                                                            sar(\r\n                                                                PRECISION,\r\n                                                                mul(\r\n                                                                    x2,\r\n                                                                    add(\r\n                                                                        COEFFICIENTS_SIN_9,\r\n                                                                        sar(\r\n                                                                            PRECISION,\r\n                                                                            mul(\r\n                                                                                x2,\r\n                                                                                COEFFICIENTS_SIN_11\r\n                                                                            )\r\n                                                                        )\r\n                                                                    )\r\n                                                                )\r\n                                                            )\r\n                                                        )\r\n                                                    )\r\n                                                )\r\n                                            )\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Taylor series coefficients for cos around 0.\r\n     */\r\n    int256 private constant COEFFICIENTS_COS_2 = -(2**96 / 2);\r\n    int256 private constant COEFFICIENTS_COS_4 = (2**96 - 16) / 24;\r\n    int256 private constant COEFFICIENTS_COS_6 = -(2**96 + 224) / 720;\r\n    int256 private constant COEFFICIENTS_COS_8 = (2**96 - 4096) / 40320;\r\n    int256 private constant COEFFICIENTS_COS_10 = -(2**96 + 2334464) / 3628800;\r\n    int256 private constant COEFFICIENTS_COS_12 =\r\n        (2**96 - 204507136) / 479001600;\r\n\r\n    /**\r\n     * @notice A pure solidity approximation of the cosine function.\r\n     * @dev The implementation uses a broken Taylor series approximation to\r\n     * compute values. The absolute error is <1e-3.\r\n     */\r\n    function cos(int256 x) public pure returns (int256 result) {\r\n        assembly {\r\n            // We remap the x to the range [-pi, pi] first, since the Taylor\r\n            // series is most accurate there.\r\n\r\n            // Attention: smod(-10, 2) = -10 but smod(-10, -2) = 0\r\n            // We therefore shift the numbers to the positive side first\r\n            x := add(smod(x, MINUS_PI_2), PI_2)\r\n\r\n            // Restrict to the range [-pi, pi]\r\n            x := sub(addmod(x, PI, PI_2), PI)\r\n\r\n            let x2 := sar(PRECISION, mul(x, x))\r\n\r\n            result := add(\r\n                ONE,\r\n                sar(\r\n                    PRECISION,\r\n                    mul(\r\n                        x2,\r\n                        add(\r\n                            COEFFICIENTS_COS_2,\r\n                            sar(\r\n                                PRECISION,\r\n                                mul(\r\n                                    x2,\r\n                                    add(\r\n                                        COEFFICIENTS_COS_4,\r\n                                        sar(\r\n                                            PRECISION,\r\n                                            mul(\r\n                                                x2,\r\n                                                add(\r\n                                                    COEFFICIENTS_COS_6,\r\n                                                    sar(\r\n                                                        PRECISION,\r\n                                                        mul(\r\n                                                            x2,\r\n                                                            add(\r\n                                                                COEFFICIENTS_COS_8,\r\n                                                                sar(\r\n                                                                    PRECISION,\r\n                                                                    mul(\r\n                                                                        x2,\r\n                                                                        add(\r\n                                                                            COEFFICIENTS_COS_10,\r\n                                                                            sar(\r\n                                                                                PRECISION,\r\n                                                                                mul(\r\n                                                                                    x2,\r\n                                                                                    COEFFICIENTS_COS_12\r\n                                                                                )\r\n                                                                            )\r\n                                                                        )\r\n                                                                    )\r\n                                                                )\r\n                                                            )\r\n                                                        )\r\n                                                    )\r\n                                                )\r\n                                            )\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice A pure solidity approximation of the square root function.\r\n     * @dev The implementation uses the Babylonian method with a fixed amount of\r\n     *  steps (for a predictable gas). The approximation is optimised for values\r\n     * in the range of[0,1]. The absolute error is <1e-3.\r\n     */\r\n    function sqrt(int256 x) public pure returns (int256 result) {\r\n        require(x >= 0, \"Sqrt is only defined for positive numbers\");\r\n        assembly {\r\n            result := x\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\r\n        }\r\n    }\r\n\r\n    int256 private constant GOLDEN_RATIO = 128193859814280023944822833248;\r\n\r\n    /**\r\n     * @notice Computes quasi-equidistant points on a unit-sphere.\r\n     * @dev The function employs Fibonacci lattices remapped to the unit-sphere\r\n     * to compute `numPoints` different points in spherical coordinates. It\r\n     * should be noted that we use the angle convention `altitude`(=theta) in\r\n     * [-pi/2, pi/2].\r\n     */\r\n    function getFibonacciLatticeOnSphere(uint256 idx, uint256 numPoints)\r\n        internal\r\n        pure\r\n        returns (SphericalPoint memory sphericalPoint)\r\n    {\r\n        require(idx >= 0 && idx < numPoints, \"Index out of range\");\r\n        sphericalPoint.sinAltitude =\r\n            (2 * ONE * int256(idx)) /\r\n            int256(numPoints) -\r\n            ONE;\r\n\r\n        {\r\n            int256 sinAltitude2 = sphericalPoint.sinAltitude;\r\n            assembly {\r\n                sinAltitude2 := sar(PRECISION, mul(sinAltitude2, sinAltitude2))\r\n            }\r\n            sphericalPoint.cosAltitude = sqrt(ONE - sinAltitude2);\r\n        }\r\n\r\n        {\r\n            int256 azimuth;\r\n            assembly {\r\n                azimuth := smod(\r\n                    div(shl(PRECISION, mul(PI_2, idx)), GOLDEN_RATIO),\r\n                    PI_2\r\n                )\r\n            }\r\n            sphericalPoint.cosAzimuth = cos(azimuth);\r\n            sphericalPoint.sinAzimuth = sin(azimuth);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Computes projection axes for different directions.\r\n     * @dev Uses the directions provided by `getFibonacciLatticeOnSphere` to\r\n     * compute two normalised, orthogonal axes. The are computed by rotating the\r\n     * x-z projection plane first by `altitude` around -x and then by `azimuth`\r\n     * around +z.\r\n     */\r\n    function getFibonacciSphericalAxes(uint256 idx, uint256 numPoints)\r\n        external\r\n        pure\r\n        returns (int256[3] memory axis1, int256[3] memory axis2)\r\n    {\r\n        SphericalPoint memory sphericalPoint = getFibonacciLatticeOnSphere(\r\n            idx,\r\n            numPoints\r\n        );\r\n\r\n        axis1 = [sphericalPoint.cosAzimuth, sphericalPoint.sinAzimuth, 0];\r\n        axis2 = [\r\n            -sphericalPoint.sinAzimuth * sphericalPoint.sinAltitude,\r\n            sphericalPoint.cosAzimuth * sphericalPoint.sinAltitude,\r\n            sphericalPoint.cosAltitude\r\n        ];\r\n\r\n        assembly {\r\n            let pos := axis2\r\n            mstore(pos, sar(PRECISION, mload(pos)))\r\n            pos := add(pos, 0x20)\r\n            mstore(pos, sar(PRECISION, mload(pos)))\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"MINUS_PI_2\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PI\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PI_0_5\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PI_2\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"cos\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numPoints\",\"type\":\"uint256\"}],\"name\":\"getFibonacciSphericalAxes\",\"outputs\":[{\"internalType\":\"int256[3]\",\"name\":\"axis1\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"axis2\",\"type\":\"int256[3]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"sin\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"sqrt\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MathHelpers","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ee02599d36e65a755aac8509edf88039f5099374ad6590358e7216d2df5ef6a0"}]}