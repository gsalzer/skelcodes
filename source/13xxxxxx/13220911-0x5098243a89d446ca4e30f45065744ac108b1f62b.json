{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/builders/WPodCallBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../WPodCall.sol\\\";\\nimport \\\"../../interfaces/IPodOption.sol\\\";\\nimport \\\"../../interfaces/IOptionBuilder.sol\\\";\\n\\n/**\\n * @title WPodCallBuilder\\n * @author Pods Finance\\n * @notice Builds WPodCall options\\n */\\ncontract WPodCallBuilder is IOptionBuilder {\\n    /**\\n     * @notice creates a new WPodCall Contract\\n     * @param name The option token name. Eg. \\\"Pods Call WETH-USDC 5000 2020-02-23\\\"\\n     * @param symbol The option token symbol. Eg. \\\"podWETH:20AA\\\"\\n     * @param exerciseType The option exercise type. Eg. \\\"0 for European, 1 for American\\\"\\n     * @param underlyingAsset The underlying asset. For this type of option its not going to be used. Eg. \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\"\\n     * @param strikeAsset The strike asset. Eg. \\\"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\\\"\\n     * @param strikePrice The option strike price including decimals. e.g. 5000000000\\n     * @param expiration The Expiration Option date in seconds. e.g. 1600178324\\n     * @param exerciseWindowSize The Expiration Window Size duration in seconds. E.g 24*60*60 (24h)\\n     */\\n    function buildOption(\\n        string memory name,\\n        string memory symbol,\\n        IPodOption.ExerciseType exerciseType,\\n        address underlyingAsset, // solhint-disable-line\\n        address strikeAsset,\\n        uint256 strikePrice,\\n        uint256 expiration,\\n        uint256 exerciseWindowSize,\\n        IConfigurationManager configurationManager\\n    ) external override returns (IPodOption) {\\n        WPodCall option = new WPodCall(\\n            name,\\n            symbol,\\n            exerciseType,\\n            strikeAsset,\\n            strikePrice,\\n            expiration,\\n            exerciseWindowSize,\\n            configurationManager\\n        );\\n\\n        return option;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/options/WPodCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./PodCall.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../lib/Conversion.sol\\\";\\n\\n/**\\n * @title WPodCall\\n * @author Pods Finance\\n *\\n * @notice Represents a tokenized Call option series for some long/short token pair.\\n *\\n * @dev Call options represents the right, not the obligation to buy the underlying asset\\n * for strike price units of the strike asset.\\n *\\n * There are four main actions that can be done with an option:\\n *\\n * Sellers can mint fungible call option tokens by locking 1:1 units\\n * of underlying asset until expiration. Buyers can exercise their call, meaning\\n * buying the locked underlying asset for strike price units of strike asset.\\n * At the end, seller can retrieve back its collateral, that could be the underlying asset\\n * AND/OR strike based on the contract's current ratio of underlying and strike assets.\\n *\\n * There are many option's style, but the most usual are: American and European.\\n * The difference between them are the moments that the buyer is allowed to exercise and\\n * the moment that seller can retrieve its locked collateral.\\n *\\n *  Exercise:\\n *  American -> any moment until expiration\\n *  European -> only after expiration and until the end of the exercise window\\n *\\n *  Withdraw:\\n *  American -> after expiration\\n *  European -> after end of exercise window\\n *\\n * Let's take an example: there is such an European call option series where buyers\\n * may buy 1 ETH for 300 USDC until Dec 31, 2021.\\n *\\n * In this case:\\n *\\n * - Expiration date: Dec 31, 2021\\n * - Underlying asset: ETH\\n * - Strike asset: USDC\\n * - Strike price: 300 USDC\\n *\\n * ETH holders may call mint() until the expiration date, which in turn:\\n *\\n * - Will lock their WETH into this contract\\n * - Will issue option tokens corresponding to this WETH amount\\n * - This contract is agnostic about where options could be bought or sold and how much the\\n * the option premium should be.\\n *\\n * WETH holders who also hold the option tokens may call unmint() until the\\n * expiration date, which in turn:\\n *\\n * - Will unlock their WETH from this contract\\n * - Will burn the corresponding amount of options tokens\\n *\\n * Option token holders may call exercise() after the expiration date and\\n * end of before exercise window, to exercise their option, which in turn:\\n *\\n * - Will buy 1 ETH for 300 USDC (the strike price) each.\\n * - Will burn the corresponding amount of option tokens.\\n *\\n * WETH holders that minted options initially can call withdraw() after the\\n * end of exercise window, which in turn:\\n *\\n * - Will give back its amount of collateral locked. That could be o mix of\\n * underlying asset and strike asset based if and how the pool was exercised.\\n *\\n * IMPORTANT: Note that after expiration, option tokens are worthless since they can not\\n * be exercised and its price should be worth 0 in a healthy market.\\n *\\n */\\ncontract WPodCall is PodCall, Conversion {\\n    event Received(address indexed sender, uint256 value);\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        IPodOption.ExerciseType exerciseType,\\n        address strikeAsset,\\n        uint256 strikePrice,\\n        uint256 expiration,\\n        uint256 exerciseWindowSize,\\n        IConfigurationManager configurationManager\\n    )\\n        public\\n        PodCall(\\n            name,\\n            symbol,\\n            exerciseType,\\n            _parseAddressFromUint(configurationManager.getParameter(\\\"WRAPPED_NETWORK_TOKEN\\\")),\\n            strikeAsset,\\n            strikePrice,\\n            expiration,\\n            exerciseWindowSize,\\n            configurationManager\\n        )\\n    {} // solhint-disable-line no-empty-blocks\\n\\n    /**\\n     * @notice Locks underlying asset (ETH) and write option tokens.\\n     *\\n     * @dev The issued amount ratio is 1:1, i.e., 1 option token for 1 underlying token.\\n     *\\n     * This function is meant to be called by underlying token (ETH) holders wanting\\n     * to write option tokens. Calling it will lock `amountOfOptions` units of\\n     * `underlyingToken` into this contract\\n     *\\n     * Options can only be minted while the series is NOT expired.\\n     *\\n     * It is also important to notice that options will be sent back\\n     * to `msg.sender` and not the `owner`. This behavior is designed to allow\\n     * proxy contracts to mint on others behalf. The `owner` will be able to remove\\n     * the deposited collateral after series expiration or by calling unmint(), even\\n     * if a third-party minted options on its behalf.\\n     *\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function mintEth(address owner) external payable tradeWindow {\\n        uint256 amountOfOptions = msg.value;\\n        require(amountOfOptions > 0, \\\"WPodCall: you can not mint zero options\\\");\\n        _mintOptions(amountOfOptions, amountOfOptions, owner);\\n\\n        IWETH(underlyingAsset()).deposit{ value: amountOfOptions }();\\n\\n        emit Mint(owner, amountOfOptions);\\n    }\\n\\n    /**\\n     * @notice Unlocks collateral by burning option tokens.\\n     *\\n     * Options can only be burned while the series is NOT expired.\\n     *\\n     * @param amountOfOptions The amount option tokens to be burned\\n     */\\n    function unmint(uint256 amountOfOptions) external virtual override unmintWindow {\\n        (uint256 strikeToSend, uint256 underlyingToSend) = _unmintOptions(amountOfOptions, msg.sender);\\n\\n        // Sends underlying asset\\n        IWETH(underlyingAsset()).withdraw(underlyingToSend);\\n        Address.sendValue(msg.sender, underlyingToSend);\\n\\n        emit Unmint(msg.sender, amountOfOptions, strikeToSend, underlyingToSend);\\n    }\\n\\n    /**\\n     * @notice Allow Call token holders to use them to buy some amount of ETH\\n     * for the amountOfOptions * strike price units of the strike token.\\n     *\\n     * @dev It presumes the caller has already called IERC20.approve() on the\\n     * strike token contract to move caller funds.\\n     *\\n     * During the process:\\n     *\\n     * - The amountOfOptions units of underlying tokens are transferred to the caller\\n     * - The amountOfOptions option tokens are burned.\\n     * - The amountOfOptions * strikePrice units of strike tokens are transferred into\\n     * this contract as a payment for the underlying tokens.\\n     *\\n     * On American options, this function can only called anytime before expiration.\\n     * For European options, this function can only be called during the exerciseWindow.\\n     * Meaning, after expiration and before the end of exercise window.\\n     *\\n     * @param amountOfOptions The amount option tokens to be exercised\\n     */\\n    function exercise(uint256 amountOfOptions) external override exerciseWindow {\\n        require(amountOfOptions > 0, \\\"WPodCall: you can not exercise zero options\\\");\\n        // Calculate the strike amount equivalent to pay for the underlying requested\\n        uint256 amountStrikeToReceive = _strikeToTransfer(amountOfOptions);\\n\\n        // Burn the exercised options\\n        _burn(msg.sender, amountOfOptions);\\n\\n        // Retrieve the strike asset from caller\\n        IERC20(strikeAsset()).safeTransferFrom(msg.sender, address(this), amountStrikeToReceive);\\n\\n        // Sends underlying asset\\n        IWETH(underlyingAsset()).withdraw(amountOfOptions);\\n        Address.sendValue(msg.sender, amountOfOptions);\\n\\n        emit Exercise(msg.sender, amountOfOptions);\\n    }\\n\\n    /**\\n     * @notice After series expiration in case of American or after exercise window for European,\\n     * allow minters who have locked their underlying asset tokens to withdraw them proportionally\\n     * to their minted options.\\n     *\\n     * @dev If assets had been exercised during the option series the minter may withdraw\\n     * the exercised assets or a combination of exercised and underlying asset tokens.\\n     */\\n    function withdraw() external virtual override withdrawWindow {\\n        (uint256 strikeToSend, uint256 underlyingToSend) = _withdraw();\\n\\n        if (strikeToSend > 0) {\\n            IERC20(strikeAsset()).safeTransfer(msg.sender, strikeToSend);\\n        }\\n\\n        // Sends underlying asset\\n        IWETH(underlyingAsset()).withdraw(underlyingToSend);\\n        Address.sendValue(msg.sender, underlyingToSend);\\n\\n        emit Withdraw(msg.sender, strikeToSend, underlyingToSend);\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == this.underlyingAsset(), \\\"WPodCall: Only deposits from WETH are allowed\\\");\\n        emit Received(msg.sender, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPodOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPodOption is IERC20 {\\n    /** Enums */\\n    // @dev 0 for Put, 1 for Call\\n    enum OptionType { PUT, CALL }\\n    // @dev 0 for European, 1 for American\\n    enum ExerciseType { EUROPEAN, AMERICAN }\\n\\n    /** Events */\\n    event Mint(address indexed minter, uint256 amount);\\n    event Unmint(address indexed minter, uint256 optionAmount, uint256 strikeAmount, uint256 underlyingAmount);\\n    event Exercise(address indexed exerciser, uint256 amount);\\n    event Withdraw(address indexed minter, uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    /** Functions */\\n\\n    /**\\n     * @notice Locks collateral and write option tokens.\\n     *\\n     * @dev The issued amount ratio is 1:1, i.e., 1 option token for 1 underlying token.\\n     *\\n     * The collateral could be the strike or the underlying asset depending on the option type: Put or Call,\\n     * respectively\\n     *\\n     * It presumes the caller has already called IERC20.approve() on the\\n     * strike/underlying token contract to move caller funds.\\n     *\\n     * Options can only be minted while the series is NOT expired.\\n     *\\n     * It is also important to notice that options will be sent back\\n     * to `msg.sender` and not the `owner`. This behavior is designed to allow\\n     * proxy contracts to mint on others behalf. The `owner` will be able to remove\\n     * the deposited collateral after series expiration or by calling unmint(), even\\n     * if a third-party minted options on its behalf.\\n     *\\n     * @param amountOfOptions The amount option tokens to be issued\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function mint(uint256 amountOfOptions, address owner) external;\\n\\n    /**\\n     * @notice Allow option token holders to use them to exercise the amount of units\\n     * of the locked tokens for the equivalent amount of the exercisable assets.\\n     *\\n     * @dev It presumes the caller has already called IERC20.approve() exercisable asset\\n     * to move caller funds.\\n     *\\n     * On American options, this function can only called anytime before expiration.\\n     * For European options, this function can only be called during the exerciseWindow.\\n     * Meaning, after expiration and before the end of exercise window.\\n     *\\n     * @param amountOfOptions The amount option tokens to be exercised\\n     */\\n    function exercise(uint256 amountOfOptions) external;\\n\\n    /**\\n     * @notice After series expiration in case of American or after exercise window for European,\\n     * allow minters who have locked their collateral to withdraw them proportionally\\n     * to their minted options.\\n     *\\n     * @dev If assets had been exercised during the option series the minter may withdraw\\n     * the exercised assets or a combination of exercised and collateral.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Unlocks collateral by burning option tokens.\\n     *\\n     * Options can only be burned while the series is NOT expired.\\n     *\\n     * @param amountOfOptions The amount option tokens to be burned\\n     */\\n    function unmint(uint256 amountOfOptions) external;\\n\\n    function optionType() external view returns (OptionType);\\n\\n    function exerciseType() external view returns (ExerciseType);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function underlyingAssetDecimals() external view returns (uint8);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function strikeAssetDecimals() external view returns (uint8);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function strikePriceDecimals() external view returns (uint8);\\n\\n    function expiration() external view returns (uint256);\\n\\n    function startOfExerciseWindow() external view returns (uint256);\\n\\n    function hasExpired() external view returns (bool);\\n\\n    function isTradeWindow() external view returns (bool);\\n\\n    function isExerciseWindow() external view returns (bool);\\n\\n    function isWithdrawWindow() external view returns (bool);\\n\\n    function strikeToTransfer(uint256 amountOfOptions) external view returns (uint256);\\n\\n    function getSellerWithdrawAmounts(address owner)\\n        external\\n        view\\n        returns (uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    function underlyingReserves() external view returns (uint256);\\n\\n    function strikeReserves() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IPodOption.sol\\\";\\nimport \\\"./IConfigurationManager.sol\\\";\\n\\ninterface IOptionBuilder {\\n    function buildOption(\\n        string memory _name,\\n        string memory _symbol,\\n        IPodOption.ExerciseType _exerciseType,\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiration,\\n        uint256 _exerciseWindowSize,\\n        IConfigurationManager _configurationManager\\n    ) external returns (IPodOption);\\n}\\n\"\r\n    },\r\n    \"contracts/options/PodCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./PodOption.sol\\\";\\n\\n/**\\n * @title PodCall\\n * @author Pods Finance\\n *\\n * @notice Represents a tokenized Call option series for some long/short token pair.\\n *\\n * @dev Call options represents the right, not the obligation to buy the underlying asset\\n * for strike price units of the strike asset.\\n *\\n * There are four main actions that can be done with an option:\\n *\\n *\\n * Sellers can mint fungible call option tokens by locking 1:1 units\\n * of underlying asset until expiration. Buyers can exercise their call, meaning\\n * buying the locked underlying asset for strike price units of strike asset.\\n * At the end, seller can retrieve back its collateral, that could be the underlying asset\\n * AND/OR strike based on the contract's current ratio of underlying and strike assets.\\n *\\n * There are many option's style, but the most usual are: American and European.\\n * The difference between them are the moments that the buyer is allowed to exercise and\\n * the moment that seller can retrieve its locked collateral.\\n *\\n *  Exercise:\\n *  American -> any moment until expiration\\n *  European -> only after expiration and until the end of the exercise window\\n *\\n *  Withdraw:\\n *  American -> after expiration\\n *  European -> after end of exercise window\\n *\\n * Let's take an example: there is such an European call option series where buyers\\n * may buy 1 WETH for 300 USDC until Dec 31, 2021.\\n *\\n * In this case:\\n *\\n * - Expiration date: Dec 31, 2021\\n * - Underlying asset: WETH\\n * - Strike asset: USDC\\n * - Strike price: 300 USDC\\n *\\n * ETH holders may call mint() until the expiration date, which in turn:\\n *\\n * - Will lock their WETH into this contract\\n * - Will issue option tokens corresponding to this WETH amount\\n * - This contract is agnostic about where options could be bought or sold and how much the\\n * the option premium should be.\\n *\\n * WETH holders who also hold the option tokens may call unmint() until the\\n * expiration date, which in turn:\\n *\\n * - Will unlock their WETH from this contract\\n * - Will burn the corresponding amount of options tokens\\n *\\n * Option token holders may call exercise() after the expiration date and\\n * end of before exercise window, to exercise their option, which in turn:\\n *\\n * - Will buy 1 ETH for 300 USDC (the strike price) each.\\n * - Will burn the corresponding amount of option tokens.\\n *\\n * WETH holders that minted options initially can call withdraw() after the\\n * end of exercise window, which in turn:\\n *\\n * - Will give back its amount of collateral locked. That could be o mix of\\n * underlying asset and strike asset based if and how the pool was exercised.\\n *\\n * IMPORTANT: Note that after expiration, option tokens are worthless since they can not\\n * be exercised and it price should worth 0 in a healthy market.\\n *\\n */\\ncontract PodCall is PodOption {\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        IPodOption.ExerciseType exerciseType,\\n        address underlyingAsset,\\n        address strikeAsset,\\n        uint256 strikePrice,\\n        uint256 expiration,\\n        uint256 exerciseWindowSize,\\n        IConfigurationManager configurationManager\\n    )\\n        public\\n        PodOption(\\n            name,\\n            symbol,\\n            IPodOption.OptionType.CALL,\\n            exerciseType,\\n            underlyingAsset,\\n            strikeAsset,\\n            strikePrice,\\n            expiration,\\n            exerciseWindowSize,\\n            configurationManager\\n        )\\n    {} // solhint-disable-line no-empty-blocks\\n\\n    /**\\n     * @notice Locks underlying asset and write option tokens.\\n     *\\n     * @dev The issued amount ratio is 1:1, i.e., 1 option token for 1 underlying token.\\n     *\\n     * It presumes the caller has already called IERC20.approve() on the\\n     * underlying token contract to move caller funds.\\n     *\\n     * This function is meant to be called by underlying token holders wanting\\n     * to write option tokens. Calling it will lock `amountOfOptions` units of\\n     * `underlyingToken` into this contract\\n     *\\n     * Options can only be minted while the series is NOT expired.\\n     *\\n     * It is also important to notice that options will be sent back\\n     * to `msg.sender` and not the `owner`. This behavior is designed to allow\\n     * proxy contracts to mint on others behalf. The `owner` will be able to remove\\n     * the deposited collateral after series expiration or by calling unmint(), even\\n     * if a third-party minted options on its behalf.\\n     *\\n     * @param amountOfOptions The amount option tokens to be issued\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function mint(uint256 amountOfOptions, address owner) external override tradeWindow {\\n        require(amountOfOptions > 0, \\\"PodCall: you can not mint zero options\\\");\\n        _mintOptions(amountOfOptions, amountOfOptions, owner);\\n\\n        IERC20(underlyingAsset()).safeTransferFrom(msg.sender, address(this), amountOfOptions);\\n\\n        emit Mint(owner, amountOfOptions);\\n    }\\n\\n    /**\\n     * @notice Unlocks collateral by burning option tokens.\\n     *\\n     * Options can only be burned while the series is NOT expired.\\n     *\\n     * @param amountOfOptions The amount option tokens to be burned\\n     */\\n    function unmint(uint256 amountOfOptions) external virtual override unmintWindow {\\n        (uint256 strikeToSend, uint256 underlyingToSend) = _unmintOptions(amountOfOptions, msg.sender);\\n\\n        // Sends underlying asset\\n        IERC20(underlyingAsset()).safeTransfer(msg.sender, underlyingToSend);\\n\\n        emit Unmint(msg.sender, amountOfOptions, strikeToSend, underlyingToSend);\\n    }\\n\\n    /**\\n     * @notice Allow Call token holders to use them to buy some amount of units\\n     * of underlying token for the amountOfOptions * strike price units of the\\n     * strike token.\\n     *\\n     * @dev It presumes the caller has already called IERC20.approve() on the\\n     * strike token contract to move caller funds.\\n     *\\n     * During the process:\\n     *\\n     * - The amountOfOptions units of underlying tokens are transferred to the caller\\n     * - The amountOfOptions option tokens are burned.\\n     * - The amountOfOptions * strikePrice units of strike tokens are transferred into\\n     * this contract as a payment for the underlying tokens.\\n     *\\n     * On American options, this function can only called anytime before expiration.\\n     * For European options, this function can only be called during the exerciseWindow.\\n     * Meaning, after expiration and before the end of exercise window.\\n     *\\n     * @param amountOfOptions The amount option tokens to be exercised\\n     */\\n    function exercise(uint256 amountOfOptions) external virtual override exerciseWindow {\\n        require(amountOfOptions > 0, \\\"PodCall: you can not exercise zero options\\\");\\n        // Calculate the strike amount equivalent to pay for the underlying requested\\n        uint256 amountStrikeToReceive = _strikeToTransfer(amountOfOptions);\\n\\n        // Burn the exercised options\\n        _burn(msg.sender, amountOfOptions);\\n\\n        // Retrieve the strike asset from caller\\n        IERC20(strikeAsset()).safeTransferFrom(msg.sender, address(this), amountStrikeToReceive);\\n\\n        // Releases the underlying asset to caller, completing the exchange\\n        IERC20(underlyingAsset()).safeTransfer(msg.sender, amountOfOptions);\\n\\n        emit Exercise(msg.sender, amountOfOptions);\\n    }\\n\\n    /**\\n     * @notice After series expiration in case of American or after exercise window for European,\\n     * allow minters who have locked their underlying asset tokens to withdraw them proportionally\\n     * to their minted options.\\n     *\\n     * @dev If assets had been exercised during the option series the minter may withdraw\\n     * the exercised assets or a combination of exercised and underlying asset tokens.\\n     */\\n    function withdraw() external virtual override withdrawWindow {\\n        (uint256 strikeToSend, uint256 underlyingToSend) = _withdraw();\\n\\n        IERC20(underlyingAsset()).safeTransfer(msg.sender, underlyingToSend);\\n\\n        if (strikeToSend > 0) {\\n            IERC20(strikeAsset()).safeTransfer(msg.sender, strikeToSend);\\n        }\\n\\n        emit Withdraw(msg.sender, strikeToSend, underlyingToSend);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    event Deposit(address indexed depositor, uint256 amount);\\n    event Withdrawal(address indexed recipient, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Conversion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ncontract Conversion {\\n    /**\\n     * @notice Parses the address represented by an uint\\n     */\\n    function _parseAddressFromUint(uint256 x) internal pure returns (address) {\\n        bytes memory data = new bytes(32);\\n        assembly {\\n            mstore(add(data, 32), x)\\n        }\\n        return abi.decode(data, (address));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/options/PodOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../interfaces/IPodOption.sol\\\";\\nimport \\\"../lib/CappedOption.sol\\\";\\nimport \\\"../lib/RequiredDecimals.sol\\\";\\nimport \\\"../interfaces/IConfigurationManager.sol\\\";\\n\\n/**\\n * @title PodOption\\n * @author Pods Finance\\n *\\n * @notice This contract represents the basic structure of the financial instrument\\n * known as Option, sharing logic between both a PUT or a CALL types.\\n *\\n * @dev There are four main actions that can be called in an Option:\\n *\\n * A) mint => A minter can lock collateral and create new options before expiration.\\n * B) unmint => The minter who previously minted can choose for leaving its position any given time\\n * until expiration.\\n * C) exercise => The option bearer the can exchange its option for the collateral at the strike price.\\n * D) withdraw => The minter can retrieve collateral at the end of the series.\\n *\\n * Depending on the type (PUT / CALL) or the exercise (AMERICAN / EUROPEAN), those functions have\\n * different behave and should be override accordingly.\\n */\\nabstract contract PodOption is IPodOption, ERC20, RequiredDecimals, CappedOption {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @dev Minimum allowed exercise window: 24 hours\\n     */\\n    uint256 public constant MIN_EXERCISE_WINDOW_SIZE = 86400;\\n\\n    OptionType private immutable _optionType;\\n    ExerciseType private immutable _exerciseType;\\n    IConfigurationManager public immutable configurationManager;\\n\\n    address private immutable _underlyingAsset;\\n    uint8 private immutable _underlyingAssetDecimals;\\n    address private immutable _strikeAsset;\\n    uint8 private immutable _strikeAssetDecimals;\\n    uint256 private immutable _strikePrice;\\n    uint256 private immutable _expiration;\\n    uint256 private _startOfExerciseWindow;\\n\\n    /**\\n     * @notice Reserve share balance\\n     * @dev Tracks the shares of the total asset reserve by address\\n     */\\n    mapping(address => uint256) public shares;\\n\\n    /**\\n     * @notice Minted option balance\\n     * @dev Tracks amount of minted options by address\\n     */\\n    mapping(address => uint256) public mintedOptions;\\n\\n    /**\\n     * @notice Total reserve shares\\n     */\\n    uint256 public totalShares = 0;\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        OptionType optionType,\\n        ExerciseType exerciseType,\\n        address underlyingAsset,\\n        address strikeAsset,\\n        uint256 strikePrice,\\n        uint256 expiration,\\n        uint256 exerciseWindowSize,\\n        IConfigurationManager _configurationManager\\n    ) public ERC20(name, symbol) CappedOption(_configurationManager) {\\n        require(Address.isContract(underlyingAsset), \\\"PodOption: underlying asset is not a contract\\\");\\n        require(Address.isContract(strikeAsset), \\\"PodOption: strike asset is not a contract\\\");\\n        require(underlyingAsset != strikeAsset, \\\"PodOption: underlying asset and strike asset must differ\\\");\\n        require(expiration > block.timestamp, \\\"PodOption: expiration should be in the future\\\");\\n        require(strikePrice > 0, \\\"PodOption: strike price must be greater than zero\\\");\\n\\n        if (exerciseType == ExerciseType.EUROPEAN) {\\n            require(\\n                exerciseWindowSize >= MIN_EXERCISE_WINDOW_SIZE,\\n                \\\"PodOption: exercise window must be greater than or equal 86400\\\"\\n            );\\n            _startOfExerciseWindow = expiration.sub(exerciseWindowSize);\\n        } else {\\n            require(exerciseWindowSize == 0, \\\"PodOption: exercise window size must be equal to zero\\\");\\n            _startOfExerciseWindow = block.timestamp;\\n        }\\n\\n        configurationManager = _configurationManager;\\n\\n        _optionType = optionType;\\n        _exerciseType = exerciseType;\\n        _expiration = expiration;\\n\\n        _underlyingAsset = underlyingAsset;\\n        _strikeAsset = strikeAsset;\\n\\n        uint8 underlyingDecimals = tryDecimals(IERC20(underlyingAsset));\\n        _underlyingAssetDecimals = underlyingDecimals;\\n        _strikeAssetDecimals = tryDecimals(IERC20(strikeAsset));\\n\\n        _strikePrice = strikePrice;\\n        _setupDecimals(underlyingDecimals);\\n    }\\n\\n    /**\\n     * @notice Checks if the options series has already expired.\\n     */\\n    function hasExpired() external override view returns (bool) {\\n        return _hasExpired();\\n    }\\n\\n    /**\\n     * @notice External function to calculate the amount of strike asset\\n     * needed given the option amount\\n     */\\n    function strikeToTransfer(uint256 amountOfOptions) external override view returns (uint256) {\\n        return _strikeToTransfer(amountOfOptions);\\n    }\\n\\n    /**\\n     * @notice Checks if the options trade window has opened.\\n     */\\n    function isTradeWindow() external override view returns (bool) {\\n        return _isTradeWindow();\\n    }\\n\\n    /**\\n     * @notice Checks if the options exercise window has opened.\\n     */\\n    function isExerciseWindow() external override view returns (bool) {\\n        return _isExerciseWindow();\\n    }\\n\\n    /**\\n     * @notice Checks if the options withdraw window has opened.\\n     */\\n    function isWithdrawWindow() external override view returns (bool) {\\n        return _isWithdrawWindow();\\n    }\\n\\n    /**\\n     * @notice The option type. eg: CALL, PUT\\n     */\\n    function optionType() external override view returns (OptionType) {\\n        return _optionType;\\n    }\\n\\n    /**\\n     * @notice Exercise type. eg: AMERICAN, EUROPEAN\\n     */\\n    function exerciseType() external override view returns (ExerciseType) {\\n        return _exerciseType;\\n    }\\n\\n    /**\\n     * @notice The sell price of each unit of underlyingAsset; given in units\\n     * of strikeAsset, e.g. 0.99 USDC\\n     */\\n    function strikePrice() external override view returns (uint256) {\\n        return _strikePrice;\\n    }\\n\\n    /**\\n     * @notice The number of decimals of strikePrice\\n     */\\n    function strikePriceDecimals() external override view returns (uint8) {\\n        return _strikeAssetDecimals;\\n    }\\n\\n    /**\\n     * @notice The timestamp in seconds that represents the series expiration\\n     */\\n    function expiration() external override view returns (uint256) {\\n        return _expiration;\\n    }\\n\\n    /**\\n     * @notice How many decimals does the strike token have? E.g.: 18\\n     */\\n    function strikeAssetDecimals() public override view returns (uint8) {\\n        return _strikeAssetDecimals;\\n    }\\n\\n    /**\\n     * @notice The asset used as the strike asset, e.g. USDC, DAI\\n     */\\n    function strikeAsset() public override view returns (address) {\\n        return _strikeAsset;\\n    }\\n\\n    /**\\n     * @notice How many decimals does the underlying token have? E.g.: 18\\n     */\\n    function underlyingAssetDecimals() public override view returns (uint8) {\\n        return _underlyingAssetDecimals;\\n    }\\n\\n    /**\\n     * @notice The asset used as the underlying token, e.g. WETH, WBTC, UNI\\n     */\\n    function underlyingAsset() public override view returns (address) {\\n        return _underlyingAsset;\\n    }\\n\\n    /**\\n     * @notice getSellerWithdrawAmounts returns the seller position based on his amount of shares\\n     * and the current option position\\n     *\\n     * @param owner address of the user to check the withdraw amounts\\n     *\\n     * @return strikeAmount current amount of strike the user will receive. It may change until maturity\\n     * @return underlyingAmount current amount of underlying the user will receive. It may change until maturity\\n     */\\n    function getSellerWithdrawAmounts(address owner)\\n        public\\n        override\\n        view\\n        returns (uint256 strikeAmount, uint256 underlyingAmount)\\n    {\\n        uint256 ownerShares = shares[owner];\\n\\n        strikeAmount = ownerShares.mul(strikeReserves()).div(totalShares);\\n        underlyingAmount = ownerShares.mul(underlyingReserves()).div(totalShares);\\n\\n        return (strikeAmount, underlyingAmount);\\n    }\\n\\n    /**\\n     * @notice The timestamp in seconds that represents the start of exercise window\\n     */\\n    function startOfExerciseWindow() public override view returns (uint256) {\\n        return _startOfExerciseWindow;\\n    }\\n\\n    /**\\n     * @notice Utility function to check the amount of the underlying tokens\\n     * locked inside this contract\\n     */\\n    function underlyingReserves() public override view returns (uint256) {\\n        return IERC20(_underlyingAsset).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @notice Utility function to check the amount of the strike tokens locked\\n     * inside this contract\\n     */\\n    function strikeReserves() public override view returns (uint256) {\\n        return IERC20(_strikeAsset).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Modifier with the conditions to be able to mint\\n     * based on option exerciseType.\\n     */\\n    modifier tradeWindow() {\\n        require(_isTradeWindow(), \\\"PodOption: trade window has closed\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier with the conditions to be able to unmint\\n     * based on option exerciseType.\\n     */\\n    modifier unmintWindow() {\\n        require(_isTradeWindow() || _isExerciseWindow(), \\\"PodOption: not in unmint window\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier with the conditions to be able to exercise\\n     * based on option exerciseType.\\n     */\\n    modifier exerciseWindow() {\\n        require(_isExerciseWindow(), \\\"PodOption: not in exercise window\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier with the conditions to be able to withdraw\\n     * based on exerciseType.\\n     */\\n    modifier withdrawWindow() {\\n        require(_isWithdrawWindow(), \\\"PodOption: option has not expired yet\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Internal function to check expiration\\n     */\\n    function _hasExpired() internal view returns (bool) {\\n        return block.timestamp >= _expiration;\\n    }\\n\\n    /**\\n     * @dev Internal function to check trade window\\n     */\\n    function _isTradeWindow() internal view returns (bool) {\\n        if (_hasExpired()) {\\n            return false;\\n        } else if (_exerciseType == ExerciseType.EUROPEAN) {\\n            return !_isExerciseWindow();\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to check window exercise started\\n     */\\n    function _isExerciseWindow() internal view returns (bool) {\\n        return !_hasExpired() && block.timestamp >= _startOfExerciseWindow;\\n    }\\n\\n    /**\\n     * @dev Internal function to check withdraw started\\n     */\\n    function _isWithdrawWindow() internal view returns (bool) {\\n        return _hasExpired();\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate the amount of strike asset needed given the option amount\\n     * @param amountOfOptions Intended amount to options to mint\\n     */\\n    function _strikeToTransfer(uint256 amountOfOptions) internal view returns (uint256) {\\n        uint256 strikeAmount = amountOfOptions.mul(_strikePrice).div(10**uint256(underlyingAssetDecimals()));\\n        require(strikeAmount > 0, \\\"PodOption: amount of options is too low\\\");\\n        return strikeAmount;\\n    }\\n\\n    /**\\n     * @dev Calculate number of reserve shares based on the amount of collateral locked by the minter\\n     */\\n    function _calculatedShares(uint256 amountOfCollateral) internal view returns (uint256 ownerShares) {\\n        uint256 currentStrikeReserves = strikeReserves();\\n        uint256 currentUnderlyingReserves = underlyingReserves();\\n\\n        uint256 numerator = amountOfCollateral.mul(totalShares);\\n        uint256 denominator;\\n\\n        if (_optionType == OptionType.PUT) {\\n            denominator = currentStrikeReserves.add(\\n                currentUnderlyingReserves.mul(_strikePrice).div(uint256(10)**underlyingAssetDecimals())\\n            );\\n        } else {\\n            denominator = currentUnderlyingReserves.add(\\n                currentStrikeReserves.mul(uint256(10)**underlyingAssetDecimals()).div(_strikePrice)\\n            );\\n        }\\n        ownerShares = numerator.div(denominator);\\n        return ownerShares;\\n    }\\n\\n    /**\\n     * @dev Mint options, creating the shares accordingly to the amount of collateral provided\\n     * @param amountOfOptions The amount option tokens to be issued\\n     * @param amountOfCollateral The amount of collateral provided to mint options\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function _mintOptions(\\n        uint256 amountOfOptions,\\n        uint256 amountOfCollateral,\\n        address owner\\n    ) internal capped(amountOfOptions) {\\n        require(owner != address(0), \\\"PodOption: zero address cannot be the owner\\\");\\n\\n        if (totalShares > 0) {\\n            uint256 ownerShares = _calculatedShares(amountOfCollateral);\\n\\n            shares[owner] = shares[owner].add(ownerShares);\\n            totalShares = totalShares.add(ownerShares);\\n        } else {\\n            shares[owner] = amountOfCollateral;\\n            totalShares = amountOfCollateral;\\n        }\\n\\n        mintedOptions[owner] = mintedOptions[owner].add(amountOfOptions);\\n\\n        _mint(msg.sender, amountOfOptions);\\n    }\\n\\n    /**\\n     * @dev Unmints options, burning the option tokens removing shares accordingly and releasing a certain\\n     * amount of collateral.\\n     * @param amountOfOptions The amount option tokens to be burned\\n     * @param owner Which address options will be burned from\\n     */\\n    function _unmintOptions(uint256 amountOfOptions, address owner)\\n        internal\\n        returns (uint256 strikeToSend, uint256 underlyingToSend)\\n    {\\n        require(shares[owner] > 0, \\\"PodOption: you do not have minted options\\\");\\n        require(amountOfOptions <= mintedOptions[owner], \\\"PodOption: not enough minted options\\\");\\n\\n        uint256 burnedShares = shares[owner].mul(amountOfOptions).div(mintedOptions[owner]);\\n\\n        if (_optionType == IPodOption.OptionType.PUT) {\\n            uint256 strikeAssetDeposited = totalSupply().mul(_strikePrice).div(10**uint256(decimals()));\\n            uint256 totalInterest = 0;\\n\\n            if (strikeReserves() > strikeAssetDeposited) {\\n                totalInterest = strikeReserves().sub(strikeAssetDeposited);\\n            }\\n\\n            strikeToSend = amountOfOptions.mul(_strikePrice).div(10**uint256(decimals())).add(\\n                totalInterest.mul(burnedShares).div(totalShares)\\n            );\\n\\n            // In the case we lost some funds due to precision, the last user to unmint will still be able to perform.\\n            if (strikeToSend > strikeReserves()) {\\n                strikeToSend = strikeReserves();\\n            }\\n        } else {\\n            uint256 underlyingAssetDeposited = totalSupply();\\n            uint256 currentUnderlyingAmount = underlyingReserves().add(strikeReserves().div(_strikePrice));\\n            uint256 totalInterest = 0;\\n\\n            if (currentUnderlyingAmount > underlyingAssetDeposited) {\\n                totalInterest = currentUnderlyingAmount.sub(underlyingAssetDeposited);\\n            }\\n\\n            underlyingToSend = amountOfOptions.add(totalInterest.mul(burnedShares).div(totalShares));\\n        }\\n\\n        shares[owner] = shares[owner].sub(burnedShares);\\n        mintedOptions[owner] = mintedOptions[owner].sub(amountOfOptions);\\n        totalShares = totalShares.sub(burnedShares);\\n\\n        _burn(owner, amountOfOptions);\\n    }\\n\\n    /**\\n     * @dev Removes all shares, returning the amounts that would be withdrawable\\n     */\\n    function _withdraw() internal returns (uint256 strikeToSend, uint256 underlyingToSend) {\\n        uint256 ownerShares = shares[msg.sender];\\n        require(ownerShares > 0, \\\"PodOption: you do not have balance to withdraw\\\");\\n\\n        (strikeToSend, underlyingToSend) = getSellerWithdrawAmounts(msg.sender);\\n\\n        shares[msg.sender] = 0;\\n        mintedOptions[msg.sender] = 0;\\n        totalShares = totalShares.sub(ownerShares);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CappedOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IConfigurationManager.sol\\\";\\nimport \\\"../interfaces/ICapProvider.sol\\\";\\n\\n/**\\n * @title CappedOption\\n * @author Pods Finance\\n *\\n * @notice Controls a maximum cap for a guarded release\\n */\\nabstract contract CappedOption is IERC20 {\\n    using SafeMath for uint256;\\n\\n    IConfigurationManager private immutable _configurationManager;\\n\\n    constructor(IConfigurationManager configurationManager) public {\\n        _configurationManager = configurationManager;\\n    }\\n\\n    /**\\n     * @dev Modifier to stop transactions that exceed the cap\\n     */\\n    modifier capped(uint256 amountOfOptions) {\\n        uint256 cap = capSize();\\n        if (cap > 0) {\\n            require(this.totalSupply().add(amountOfOptions) <= cap, \\\"CappedOption: amount exceed cap\\\");\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Get the cap size\\n     */\\n    function capSize() public view returns (uint256) {\\n        ICapProvider capProvider = ICapProvider(_configurationManager.getCapProvider());\\n        return capProvider.getCap(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RequiredDecimals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract RequiredDecimals {\\n    uint256 private constant _MAX_TOKEN_DECIMALS = 38;\\n\\n    /**\\n     * Tries to fetch the decimals of a token, if not existent, fails with a require statement\\n     *\\n     * @param token An instance of IERC20\\n     * @return The decimals of a token\\n     */\\n    function tryDecimals(IERC20 token) internal view returns (uint8) {\\n        // solhint-disable-line private-vars-leading-underscore\\n        bytes memory payload = abi.encodeWithSignature(\\\"decimals()\\\");\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory returnData) = address(token).staticcall(payload);\\n\\n        require(success, \\\"RequiredDecimals: required decimals\\\");\\n        uint8 decimals = abi.decode(returnData, (uint8));\\n        require(decimals < _MAX_TOKEN_DECIMALS, \\\"RequiredDecimals: token decimals should be lower than 38\\\");\\n\\n        return decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfigurationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity >=0.6.12;\\n\\ninterface IConfigurationManager {\\n    function setParameter(bytes32 name, uint256 value) external;\\n\\n    function setEmergencyStop(address emergencyStop) external;\\n\\n    function setPricingMethod(address pricingMethod) external;\\n\\n    function setIVGuesser(address ivGuesser) external;\\n\\n    function setIVProvider(address ivProvider) external;\\n\\n    function setPriceProvider(address priceProvider) external;\\n\\n    function setCapProvider(address capProvider) external;\\n\\n    function setAMMFactory(address ammFactory) external;\\n\\n    function setOptionFactory(address optionFactory) external;\\n\\n    function setOptionHelper(address optionHelper) external;\\n\\n    function setOptionPoolRegistry(address optionPoolRegistry) external;\\n\\n    function getParameter(bytes32 name) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function getEmergencyStop() external view returns (address);\\n\\n    function getPricingMethod() external view returns (address);\\n\\n    function getIVGuesser() external view returns (address);\\n\\n    function getIVProvider() external view returns (address);\\n\\n    function getPriceProvider() external view returns (address);\\n\\n    function getCapProvider() external view returns (address);\\n\\n    function getAMMFactory() external view returns (address);\\n\\n    function getOptionFactory() external view returns (address);\\n\\n    function getOptionHelper() external view returns (address);\\n\\n    function getOptionPoolRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICapProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface ICapProvider {\\n    function setCap(address target, uint256 value) external;\\n\\n    function getCap(address target) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"enum IPodOption.ExerciseType\",\"name\":\"exerciseType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exerciseWindowSize\",\"type\":\"uint256\"},{\"internalType\":\"contract IConfigurationManager\",\"name\":\"configurationManager\",\"type\":\"address\"}],\"name\":\"buildOption\",\"outputs\":[{\"internalType\":\"contract IPodOption\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WPodCallBuilder","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}