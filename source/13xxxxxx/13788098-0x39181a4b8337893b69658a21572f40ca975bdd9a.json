{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/libraries/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Utils {\\n  using Utils for Unlock;\\n  using Utils for Vest;\\n\\n  struct Vest {\\n    uint256 shortAmnt;\\n    uint256 longAmnt;\\n    uint256 lastUpdate;\\n  }\\n\\n  struct Unlock {\\n    uint256 unlockAmnt;\\n    uint256 unlockTime;\\n  }\\n\\n  // note: we should be able to unlock all tokens (including vested tokens)\\n  function unlock(\\n    Unlock storage self,\\n    uint256 amount,\\n    uint256 lockTime\\n  ) internal {\\n    self.unlockAmnt = amount;\\n    self.unlockTime = block.timestamp + lockTime;\\n  }\\n\\n  function useUnlocked(Unlock storage self, uint256 amount) internal {\\n    require(self.unlockTime <= block.timestamp, \\\"sRelU: tokens are not unlocked yet\\\");\\n    require(self.unlockAmnt >= amount, \\\"sRelU: tokens should be unlocked before transfer\\\");\\n\\n    self.unlockAmnt -= amount; // update locked amount;\\n  }\\n\\n  function resetLock(Unlock storage self) internal {\\n    self.unlockAmnt = 0;\\n    self.unlockTime = 0;\\n  }\\n\\n  function transferUnvestedTokens(Vest storage self, Vest storage vestTo) internal {\\n    require(self.shortAmnt | self.longAmnt != 0, \\\"sRelU: nothing to transfer\\\");\\n\\n    require(\\n      vestTo.shortAmnt | vestTo.longAmnt == 0,\\n      \\\"sRelU: cannot transfer to account with unvested tokens\\\"\\n    );\\n\\n    vestTo.shortAmnt = self.shortAmnt;\\n    vestTo.longAmnt = self.longAmnt;\\n    vestTo.lastUpdate = self.lastUpdate;\\n\\n    // reset initial vest\\n    self.shortAmnt = 0;\\n    self.longAmnt = 0;\\n    self.lastUpdate = 0;\\n  }\\n\\n  function setUnvestedAmount(\\n    Vest storage self,\\n    uint256 shortAmnt,\\n    uint256 longAmnt\\n  ) public {\\n    require(self.shortAmnt + self.longAmnt == 0, \\\"sRelU: account has unvested tokens\\\");\\n    if (shortAmnt > 0) self.shortAmnt = shortAmnt;\\n\\n    if (longAmnt > 0) self.longAmnt = longAmnt;\\n\\n    self.lastUpdate = 0;\\n  }\\n\\n  function unvested(Vest storage self) internal view returns (uint256) {\\n    return self.shortAmnt + self.longAmnt;\\n  }\\n\\n  // this method updates long and short unvested amounts and returns vested amount\\n  function updateUnvestedAmount(\\n    Vest storage self,\\n    uint256 vestShort,\\n    uint256 vestLong,\\n    uint256 vestBegin\\n  ) public returns (uint256 amount) {\\n    if (block.timestamp <= vestBegin) return 0;\\n    uint256 shortAmnt = self.shortAmnt;\\n    uint256 longAmnt = self.longAmnt;\\n    uint256 last = self.lastUpdate < vestBegin ? vestBegin : self.lastUpdate;\\n\\n    if (shortAmnt > 0 && last < vestShort) {\\n      uint256 sAmnt = block.timestamp < vestShort\\n        ? (shortAmnt * (block.timestamp - last)) / (vestShort - last)\\n        : shortAmnt;\\n      self.shortAmnt = shortAmnt - sAmnt;\\n      amount += sAmnt;\\n    }\\n\\n    if (longAmnt > 0 && last < vestLong) {\\n      uint256 lAmnt = block.timestamp < vestLong\\n        ? (longAmnt * (block.timestamp - last)) / (vestLong - last)\\n        : longAmnt;\\n      self.longAmnt = longAmnt - lAmnt;\\n      amount += lAmnt;\\n    }\\n\\n    self.lastUpdate = block.timestamp;\\n    return amount;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[]","ContractName":"Utils","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}