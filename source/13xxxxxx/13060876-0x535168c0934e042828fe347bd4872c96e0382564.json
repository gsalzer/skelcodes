{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IFarm {\r\n    function deposit(uint amount) external;\r\n    function withdrawAll() external;\r\n    function withdraw(address toAddr, uint amount) external;\r\n}\r\n\r\ninterface OrbitBridgeReceiver {\r\n    function onTokenBridgeReceived(address _token, uint256 _value, bytes calldata _data) external returns(uint);\r\n\tfunction onNFTBridgeReceived(address _token, uint256 _tokenId, bytes calldata _data) external returns(uint);\r\n}\r\n\r\nlibrary LibCallBridgeReceiver {\r\n    function callReceiver(bool isFungible, uint gasLimitForBridgeReceiver, address tokenAddress, uint256 _int, bytes memory data, address toAddr) internal returns (bool){\r\n        bool result;\r\n        bytes memory callbytes;\r\n        bytes memory returnbytes;\r\n        if (isFungible) {\r\n            callbytes = abi.encodeWithSignature(\"onTokenBridgeReceived(address,uint256,bytes)\", tokenAddress, _int, data);\r\n        } else {\r\n            callbytes = abi.encodeWithSignature(\"onNFTBridgeReceived(address,uint256,bytes)\", tokenAddress, _int, data);\r\n        }\r\n        if (gasLimitForBridgeReceiver > 0) {\r\n            (result, returnbytes) = toAddr.call.gas(gasLimitForBridgeReceiver)(callbytes);\r\n        } else {\r\n            (result, returnbytes) = toAddr.call(callbytes);\r\n        }\r\n\r\n        if(!result){\r\n            return false;\r\n        } else {\r\n            (uint flag) = abi.decode(returnbytes, (uint));\r\n            return flag > 0;\r\n        }\r\n    }\r\n}\r\n\r\ncontract EthVaultStorage {\r\n    /////////////////////////////////////////////////////////////////////////\r\n    // MultiSigWallet.sol\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////\r\n\r\n    /////////////////////////////////////////////////////////////////////////\r\n    // EthVault.sol\r\n    string public constant chain = \"ETH\";\r\n    bool public isActivated = true;\r\n    address payable public implementation;\r\n    address public tetherAddress;\r\n    uint public depositCount = 0;\r\n    mapping(bytes32 => bool) public isUsedWithdrawal;\r\n    mapping(bytes32 => address) public tokenAddr;\r\n    mapping(address => bytes32) public tokenSummaries;\r\n    mapping(bytes32 => bool) public isValidChain;\r\n    /////////////////////////////////////////////////////////////////////////\r\n\r\n    /////////////////////////////////////////////////////////////////////////\r\n    // EthVault.impl.sol\r\n    uint public bridgingFee = 0;\r\n    address payable public feeGovernance;\r\n    mapping(address => bool) public silentTokenList;\r\n    mapping(address => address payable) public farms;\r\n    uint public taxRate; // 0.01% interval\r\n    address public taxReceiver;\r\n    uint public gasLimitForBridgeReceiver;\r\n\r\n    address public policyAdmin;\r\n    mapping(bytes32 => uint256) public chainFee;\r\n    mapping(bytes32 => uint256) public chainFeeWithData;\r\n\r\n    mapping(bytes32 => uint256) public chainUintsLength;\r\n    mapping(bytes32 => uint256) public chainAddressLength;\r\n    /////////////////////////////////////////////////////////////////////////\r\n}\r\n\r\ncontract EthVaultImpl is EthVaultStorage {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n\r\n    event Deposit(string toChain, address fromAddr, bytes toAddr, address token, uint8 decimal, uint amount, uint depositId, bytes data);\r\n    event DepositNFT(string toChain, address fromAddr, bytes toAddr, address token, uint tokenId, uint amount, uint depositId, bytes data);\r\n\r\n    event Withdraw(string fromChain, bytes fromAddr, bytes toAddr, bytes token, bytes32[] bytes32s, uint[] uints, bytes data);\r\n    event WithdrawNFT(string fromChain, bytes fromAddr, bytes toAddr, bytes token, bytes32[] bytes32s, uint[] uints, bytes data);\r\n\r\n    event BridgeReceiverResult(bool success, bytes fromAddress, address tokenAddress, bytes data);\r\n\r\n    modifier onlyActivated {\r\n        require(isActivated);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWallet {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier onlyPolicyAdmin {\r\n        require(msg.sender == policyAdmin);\r\n        _;\r\n    }\r\n\r\n    constructor() public payable { }\r\n\r\n    function getVersion() public pure returns(string memory){\r\n        return \"EthVault20210817A\";\r\n    }\r\n\r\n    function getChainId(string memory _chain) public view returns(bytes32){\r\n        return sha256(abi.encodePacked(address(this), _chain));\r\n    }\r\n\r\n    function setValidChain(string memory _chain, bool valid, uint fromAddrLen, uint uintsLen) public onlyWallet {\r\n        bytes32 chainId = getChainId(_chain);\r\n        require(chainId != getChainId(chain));\r\n        isValidChain[chainId] = valid;\r\n        if(valid){\r\n            chainAddressLength[chainId] = fromAddrLen;\r\n            chainUintsLength[chainId] = uintsLen;\r\n        }\r\n        else{\r\n            chainAddressLength[chainId] = 0;\r\n            chainUintsLength[chainId] = 0;\r\n        }\r\n    }\r\n\r\n    function setTaxParams(uint _taxRate, address _taxReceiver) public onlyWallet {\r\n        require(_taxRate < 10000);\r\n        require(_taxReceiver != address(0));\r\n        taxRate = _taxRate;\r\n        taxReceiver = _taxReceiver;\r\n    }\r\n\r\n    function setPolicyAdmin(address _policyAdmin) public onlyWallet {\r\n        require(_policyAdmin != address(0));\r\n\r\n        policyAdmin = _policyAdmin;\r\n    }\r\n\r\n    function changeActivate(bool activate) public onlyPolicyAdmin {\r\n        isActivated = activate;\r\n    }\r\n\r\n    function setSilentToken(address token, bool v) public onlyPolicyAdmin {\r\n        require(token != address(0));\r\n\r\n        silentTokenList[token] = v;\r\n    }\r\n\r\n    function setFeeGovernance(address payable _feeGovernance) public onlyWallet {\r\n        require(_feeGovernance != address(0));\r\n\r\n        feeGovernance = _feeGovernance;\r\n    }\r\n\r\n    function setChainFee(string memory chainSymbol, uint256 _fee, uint256 _feeWithData) public onlyPolicyAdmin {\r\n        bytes32 chainId = getChainId(chainSymbol);\r\n        require(isValidChain[chainId]);\r\n\r\n        chainFee[chainId] = _fee;\r\n        chainFeeWithData[chainId] = _feeWithData;\r\n    }\r\n\r\n    function setGasLimitForBridgeReceiver(uint256 _gasLimitForBridgeReceiver) public onlyPolicyAdmin {\r\n        gasLimitForBridgeReceiver = _gasLimitForBridgeReceiver;\r\n    }\r\n\r\n    function addFarm(address token, address payable proxy) public onlyWallet {\r\n        require(farms[token] == address(0));\r\n\r\n        uint amount;\r\n        if(token == address(0)){\r\n            amount = address(this).balance;\r\n        }\r\n        else{\r\n            amount = IERC20(token).balanceOf(address(this));\r\n        }\r\n\r\n        _transferToken(token, proxy, amount);\r\n        IFarm(proxy).deposit(amount);\r\n\r\n        farms[token] = proxy;\r\n    }\r\n\r\n    function removeFarm(address token, address payable newProxy) public onlyWallet {\r\n        require(farms[token] != address(0));\r\n\r\n        IFarm(farms[token]).withdrawAll();\r\n\r\n        if(newProxy != address(0)){\r\n            uint amount;\r\n            if(token == address(0)){\r\n                amount = address(this).balance;\r\n            }\r\n            else{\r\n                amount = IERC20(token).balanceOf(address(this));\r\n            }\r\n\r\n            _transferToken(token, newProxy, amount);\r\n            IFarm(newProxy).deposit(amount);\r\n        }\r\n\r\n        farms[token] = newProxy;\r\n    }\r\n\r\n    function deposit(string memory toChain, bytes memory toAddr) payable public {\r\n        uint256 fee = chainFee[getChainId(toChain)];\r\n        if(fee != 0){\r\n            require(msg.value > fee);\r\n            _transferToken(address(0), feeGovernance, fee);\r\n        }\r\n\r\n        _depositToken(address(0), toChain, toAddr, (msg.value).sub(fee), \"\");\r\n    }\r\n\r\n    function deposit(string memory toChain, bytes memory toAddr, bytes memory data) payable public {\r\n        require(data.length != 0);\r\n\r\n        uint256 fee = chainFeeWithData[getChainId(toChain)];\r\n        if(fee != 0){\r\n            require(msg.value > fee);\r\n            _transferToken(address(0), feeGovernance, fee);\r\n        }\r\n\r\n        _depositToken(address(0), toChain, toAddr, (msg.value).sub(fee), data);\r\n    }\r\n\r\n    function depositToken(address token, string memory toChain, bytes memory toAddr, uint amount) public payable {\r\n        require(token != address(0));\r\n\r\n        uint256 fee = chainFee[getChainId(toChain)];\r\n        if(fee != 0){\r\n            require(msg.value >= fee);\r\n            _transferToken(address(0), feeGovernance, msg.value);\r\n        }\r\n\r\n        _depositToken(token, toChain, toAddr, amount, \"\");\r\n    }\r\n\r\n    function depositToken(address token, string memory toChain, bytes memory toAddr, uint amount, bytes memory data) public payable {\r\n        require(token != address(0));\r\n        require(data.length != 0);\r\n\r\n        uint256 fee = chainFeeWithData[getChainId(toChain)];\r\n        if(fee != 0){\r\n            require(msg.value >= fee);\r\n            _transferToken(address(0), feeGovernance, msg.value);\r\n        }\r\n\r\n        _depositToken(token, toChain, toAddr, amount, data);\r\n    }\r\n\r\n    function _depositToken(address token, string memory toChain, bytes memory toAddr, uint amount, bytes memory data) private onlyActivated {\r\n        require(isValidChain[getChainId(toChain)]);\r\n        require(amount != 0);\r\n        require(!silentTokenList[token]);\r\n\r\n        uint8 decimal;\r\n        if(token == address(0)){\r\n            decimal = 18;\r\n        }\r\n        else{\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n            decimal = IERC20(token).decimals();\r\n        }\r\n        require(decimal > 0);\r\n\r\n        address payable farm = farms[token];\r\n        if(farm != address(0)){\r\n            _transferToken(token, farm, amount);\r\n            IFarm(farm).deposit(amount);\r\n        }\r\n\r\n        if(taxRate > 0 && taxReceiver != address(0)){\r\n            uint tax = _payTax(token, amount, decimal);\r\n            amount = amount.sub(tax);\r\n        }\r\n\r\n        depositCount = depositCount + 1;\r\n        emit Deposit(toChain, msg.sender, toAddr, token, decimal, amount, depositCount, data);\r\n    }\r\n\r\n    function depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId) public payable {\r\n        uint256 fee = chainFee[getChainId(toChain)];\r\n        if(fee != 0){\r\n            require(msg.value >= fee);\r\n            _transferToken(address(0), feeGovernance, msg.value);\r\n        }\r\n\r\n        _depositNFT(token, toChain, toAddr, tokenId, \"\");\r\n    }\r\n\r\n    function depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId, bytes memory data) public payable {\r\n        require(data.length != 0);\r\n\r\n        uint256 fee = chainFeeWithData[getChainId(toChain)];\r\n        if(fee != 0){\r\n            require(msg.value >= fee);\r\n            _transferToken(address(0), feeGovernance, msg.value);\r\n        }\r\n\r\n        _depositNFT(token, toChain, toAddr, tokenId, data);\r\n    }\r\n\r\n    function _depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId, bytes memory data) private onlyActivated {\r\n        require(isValidChain[getChainId(toChain)]);\r\n        require(token != address(0));\r\n        require(IERC721(token).ownerOf(tokenId) == msg.sender);\r\n        require(!silentTokenList[token]);\r\n\r\n        IERC721(token).transferFrom(msg.sender, address(this), tokenId);\r\n        require(IERC721(token).ownerOf(tokenId) == address(this));\r\n\r\n        depositCount = depositCount + 1;\r\n        emit DepositNFT(toChain, msg.sender, toAddr, token, tokenId, 1, depositCount, data);\r\n    }\r\n\r\n    // Fix Data Info\r\n    ///@param bytes32s [0]:govId, [1]:txHash\r\n    ///@param uints [0]:amount, [1]:decimal\r\n    function withdraw(\r\n        address hubContract,\r\n        string memory fromChain,\r\n        bytes memory fromAddr,\r\n        address payable toAddr,\r\n        address token,\r\n        bytes32[] memory bytes32s,\r\n        uint[] memory uints,\r\n        bytes memory data,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s\r\n    ) public onlyActivated {\r\n        require(bytes32s.length == 2);\r\n        require(uints.length == chainUintsLength[getChainId(fromChain)]);\r\n        require(uints[1] <= 100);\r\n        require(fromAddr.length == chainAddressLength[getChainId(fromChain)]);\r\n\r\n        require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\r\n        require(isValidChain[getChainId(fromChain)]);\r\n\r\n        {\r\n        bytes32 whash = sha256(abi.encodePacked(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\r\n\r\n        require(!isUsedWithdrawal[whash]);\r\n        isUsedWithdrawal[whash] = true;\r\n\r\n        uint validatorCount = _validate(whash, v, r, s);\r\n        require(validatorCount >= required);\r\n        }\r\n\r\n\r\n        if(farms[token] != address(0)){\r\n            IFarm(farms[token]).withdraw(toAddr, uints[0]);\r\n        }\r\n        else{\r\n            _transferToken(token, toAddr, uints[0]);\r\n        }\r\n\r\n        if(isContract(toAddr) && data.length != 0){\r\n            bool result = LibCallBridgeReceiver.callReceiver(true, gasLimitForBridgeReceiver, token, uints[0], data, toAddr);\r\n            emit BridgeReceiverResult(result, fromAddr, token, data);\r\n        }\r\n\r\n        emit Withdraw(fromChain, fromAddr, abi.encodePacked(toAddr), abi.encodePacked(token), bytes32s, uints, data);\r\n    }\r\n\r\n    // Fix Data Info\r\n    ///@param bytes32s [0]:govId, [1]:txHash\r\n    ///@param uints [0]:amount, [1]:tokenId\r\n    function withdrawNFT(\r\n        address hubContract,\r\n        string memory fromChain,\r\n        bytes memory fromAddr,\r\n        address payable toAddr,\r\n        address token,\r\n        bytes32[] memory bytes32s,\r\n        uint[] memory uints,\r\n        bytes memory data,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s\r\n    ) public onlyActivated {\r\n        require(bytes32s.length == 2);\r\n        require(uints.length == chainUintsLength[getChainId(fromChain)]);\r\n        require(fromAddr.length == chainAddressLength[getChainId(fromChain)]);\r\n\r\n        require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\r\n        require(isValidChain[getChainId(fromChain)]);\r\n\r\n        {\r\n        bytes32 whash = sha256(abi.encodePacked(\"NFT\", hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\r\n\r\n        require(!isUsedWithdrawal[whash]);\r\n        isUsedWithdrawal[whash] = true;\r\n\r\n        uint validatorCount = _validate(whash, v, r, s);\r\n        require(validatorCount >= required);\r\n        }\r\n\r\n        require(IERC721(token).ownerOf(uints[1]) == address(this));\r\n        IERC721(token).transferFrom(address(this), toAddr, uints[1]);\r\n        require(IERC721(token).ownerOf(uints[1]) == toAddr);\r\n\r\n        if(isContract(toAddr) && data.length != 0){\r\n            bool result = LibCallBridgeReceiver.callReceiver(false, gasLimitForBridgeReceiver, token, uints[1], data, toAddr);\r\n            emit BridgeReceiverResult(result, fromAddr, token, data);\r\n        }\r\n\r\n        emit WithdrawNFT(fromChain, fromAddr, abi.encodePacked(toAddr), abi.encodePacked(token), bytes32s, uints, data);\r\n    }\r\n\r\n    function _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\r\n        uint validatorCount = 0;\r\n        address[] memory vaList = new address[](owners.length);\r\n\r\n        uint i=0;\r\n        uint j=0;\r\n\r\n        for(i; i<v.length; i++){\r\n            address va = ecrecover(whash,v[i],r[i],s[i]);\r\n            if(isOwner[va]){\r\n                for(j=0; j<validatorCount; j++){\r\n                    require(vaList[j] != va);\r\n                }\r\n\r\n                vaList[validatorCount] = va;\r\n                validatorCount += 1;\r\n            }\r\n        }\r\n\r\n        return validatorCount;\r\n    }\r\n\r\n    function _payTax(address token, uint amount, uint8 decimal) private returns (uint tax) {\r\n        tax = amount.mul(taxRate).div(10000);\r\n        if(tax > 0){\r\n            depositCount = depositCount + 1;\r\n            emit Deposit(\"ORBIT\", msg.sender, abi.encodePacked(taxReceiver), token, decimal, tax, depositCount, \"\");\r\n        }\r\n    }\r\n\r\n    function _transferToken(address token, address payable destination, uint amount) private {\r\n        if(token == address(0)){\r\n            (bool transfered,) = destination.call.value(amount)(\"\");\r\n            require(transfered);\r\n        }\r\n        else{\r\n            IERC20(token).safeTransfer(destination, amount);\r\n        }\r\n    }\r\n\r\n    function isContract(address _addr) private view returns (bool){\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) public pure returns (address payable addr) {\r\n        assembly {\r\n            addr := mload(add(bys,20))\r\n        }\r\n    }\r\n\r\n    function () payable external{\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"chainAddressLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"chainFeeWithData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hubContract\",\"type\":\"address\"},{\"name\":\"fromChain\",\"type\":\"string\"},{\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"name\":\"uints\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"bool\"}],\"name\":\"setSilentToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_chain\",\"type\":\"string\"}],\"name\":\"getChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"depositNFT\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"activate\",\"type\":\"bool\"}],\"name\":\"changeActivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tetherAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"farms\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bys\",\"type\":\"bytes\"}],\"name\":\"bytesToAddress\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"addFarm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"silentTokenList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"policyAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLimitForBridgeReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"depositNFT\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"newProxy\",\"type\":\"address\"}],\"name\":\"removeFarm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgingFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hubContract\",\"type\":\"address\"},{\"name\":\"fromChain\",\"type\":\"string\"},{\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"name\":\"uints\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isUsedWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_chain\",\"type\":\"string\"},{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"fromAddrLen\",\"type\":\"uint256\"},{\"name\":\"uintsLen\",\"type\":\"uint256\"}],\"name\":\"setValidChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_policyAdmin\",\"type\":\"address\"}],\"name\":\"setPolicyAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeGovernance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taxRate\",\"type\":\"uint256\"},{\"name\":\"_taxReceiver\",\"type\":\"address\"}],\"name\":\"setTaxParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"chainFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chain\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasLimitForBridgeReceiver\",\"type\":\"uint256\"}],\"name\":\"setGasLimitForBridgeReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeGovernance\",\"type\":\"address\"}],\"name\":\"setFeeGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenSummaries\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isValidChain\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chainSymbol\",\"type\":\"string\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_feeWithData\",\"type\":\"uint256\"}],\"name\":\"setChainFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"chainUintsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"decimal\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DepositNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"uints\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"uints\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"WithdrawNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"fromAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeReceiverResult\",\"type\":\"event\"}]","ContractName":"EthVaultImpl","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8378daf4fa8ac02b19f33a03b82af8f67678848589062fd25d6b06703760bc0b"}]}