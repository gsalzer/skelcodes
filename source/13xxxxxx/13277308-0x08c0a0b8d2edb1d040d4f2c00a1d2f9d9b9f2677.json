{"status":"1","message":"OK","result":[{"SourceCode":"{\"CellarPoolShareLimitUSDCETH.sol\":{\"content\":\"//SPDX-License-Identifier: Apache-2.0\\n// VolumeFi Software, Inc.\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract CellarPoolShareLimitUSDCETH is ICellarPoolShare, BlockLock {\\n    using SafeERC20 for IERC20;\\n\\n    address constant NONFUNGIBLEPOSITIONMANAGER =\\n        0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\\n\\n    address constant UNISWAPV3FACTORY =\\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\\n\\n    address constant SWAPROUTER =\\n        0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    uint256 constant FEEDOMINATOR = 10000;\\n\\n    uint256 constant YEAR = 31556952;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n    mapping(address =\\u003e bool) public validator;\\n    uint256 private _totalSupply;\\n    address private _owner;\\n    bool private _isEntered;\\n    string private _name;\\n    string private _symbol;\\n\\n    address public immutable token0;\\n    address public immutable token1;\\n    uint24 public immutable feeLevel;\\n    CellarTickInfo[] public cellarTickInfo;\\n    uint256 lastManageTimestamp;\\n    uint256 public performanceFee = 2000;\\n    uint256 public managementFee = 200;\\n    AggregatorV3Interface public constant priceFeed = AggregatorV3Interface(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4);\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _token0,\\n        address _token1,\\n        uint24 _feeLevel,\\n        CellarTickInfo[] memory _cellarTickInfo\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        require(_token0 \\u003c _token1, \\\"R9\\\");//\\\"Tokens are not sorted\\\"\\n        token0 = _token0;\\n        token1 = _token1;\\n        feeLevel = _feeLevel;\\n        for (uint256 i = 0; i \\u003c _cellarTickInfo.length; i++) {\\n            require(_cellarTickInfo[i].weight \\u003e 0, \\\"R10\\\");//\\\"Weight cannot be zero\\\"\\n            require(_cellarTickInfo[i].tokenId == 0, \\\"R11\\\");//\\\"tokenId is not empty\\\"\\n            require(_cellarTickInfo[i].tickUpper \\u003e _cellarTickInfo[i].tickLower, \\\"R12\\\");//\\\"Wrong tick tier\\\"\\n            if (i \\u003e 0) {\\n                require(_cellarTickInfo[i].tickUpper \\u003c= _cellarTickInfo[i - 1].tickLower, \\\"R12\\\");//\\\"Wrong tick tier\\\"\\n            }\\n            cellarTickInfo.push(\\n                CellarTickInfo({\\n                    tokenId: 0,\\n                    tickUpper: _cellarTickInfo[i].tickUpper,\\n                    tickLower: _cellarTickInfo[i].tickLower,\\n                    weight: _cellarTickInfo[i].weight\\n                })\\n            );\\n        }\\n        _owner = msg.sender;\\n    }\\n\\n    modifier onlyValidator() {\\n        require(validator[msg.sender], \\\"R13\\\");//\\\"Not validator\\\"\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(!_isEntered, \\\"R14\\\");//\\\"reentrant call\\\"\\n        _isEntered = true;\\n        _;\\n        _isEntered = false;\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount, \\\"R15\\\");//\\\"transfer exceeds allowance\\\"\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n    function totalPrice(uint256 amount0, uint256 amount1) internal view returns (uint256 total) {\\n        // USDC + WETH\\n        uint256 price = uint256(priceFeed.latestAnswer());\\n        total = amount1 * 10 ** 6 / price + amount0;\\n    }\\n\\n    function addLiquidityForUniV3(CellarAddParams calldata cellarParams)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        notLocked(msg.sender)\\n    {\\n        require(block.timestamp \\u003c= cellarParams.deadline);\\n        if (token0 == WETH) {\\n            if (msg.value \\u003e= cellarParams.amount0Desired) {\\n                if (msg.value \\u003e cellarParams.amount0Desired) {\\n                    payable(msg.sender).transfer(\\n                        msg.value - cellarParams.amount0Desired\\n                    );\\n                }\\n                IWETH(WETH).deposit{value: cellarParams.amount0Desired}();\\n            } else {\\n                IERC20(WETH).safeTransferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    cellarParams.amount0Desired\\n                );\\n                if (msg.value \\u003e 0) {\\n                    payable(msg.sender).transfer(msg.value);\\n                }\\n            }\\n            IERC20(token1).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                cellarParams.amount1Desired\\n            );\\n        } else if (token1 == WETH) {\\n            if (msg.value \\u003e= cellarParams.amount1Desired) {\\n                if (msg.value \\u003e cellarParams.amount1Desired) {\\n                    payable(msg.sender).transfer(\\n                        msg.value - cellarParams.amount1Desired\\n                    );\\n                }\\n                IWETH(WETH).deposit{value: cellarParams.amount1Desired}();\\n            } else {\\n                IERC20(WETH).safeTransferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    cellarParams.amount1Desired\\n                );\\n                if (msg.value \\u003e 0) {\\n                    payable(msg.sender).transfer(msg.value);\\n                }\\n            }\\n            IERC20(token0).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                cellarParams.amount0Desired\\n            );\\n        } else {\\n            IERC20(token0).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                cellarParams.amount0Desired\\n            );\\n            IERC20(token1).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                cellarParams.amount1Desired\\n            );\\n        }\\n\\n        (\\n            uint256 inAmount0,\\n            uint256 inAmount1,\\n            uint128 liquidityBefore,\\n            uint128 liquiditySum\\n        ) = _addLiquidity(cellarParams);\\n\\n        uint256 prevTotalSupply = _totalSupply;\\n\\n        if (liquidityBefore == 0) {\\n            _mint(msg.sender, liquiditySum);\\n        } else {\\n            _mint(\\n                msg.sender,\\n                FullMath.mulDiv(liquiditySum, _totalSupply, liquidityBefore)\\n            );\\n        }\\n\\n        require(inAmount0 \\u003e= cellarParams.amount0Min, \\\"R16\\\");\\n        require(inAmount1 \\u003e= cellarParams.amount1Min, \\\"R17\\\");\\n        // check limitation\\n        uint256 increasedSupply = _totalSupply - prevTotalSupply;\\n        if (increasedSupply \\u003e 0) {\\n            uint256 inPrice = totalPrice(inAmount0, inAmount1);\\n            uint256 userPrice = FullMath.mulDiv(inPrice, _balances[msg.sender], increasedSupply);\\n            require(userPrice \\u003c= 10000 * 10 ** 6, \\\"R31\\\"); // \\\"More than 10000 USD\\\"\\n            uint256 total = FullMath.mulDiv(inPrice, _totalSupply, increasedSupply);\\n            require(total \\u003c= 500000 * 10 ** 6, \\\"R32\\\"); // \\\"More than 500000 USD\\\"\\n        }\\n        //\\n        uint256 retAmount0 = cellarParams.amount0Desired - inAmount0;\\n        uint256 retAmount1 = cellarParams.amount1Desired - inAmount1;\\n\\n        if (retAmount0 \\u003e 0) {\\n            if (token0 == WETH) {\\n                IWETH(WETH).withdraw(retAmount0);\\n                msg.sender.transfer(retAmount0);\\n            } else {\\n                IERC20(token0).safeTransfer(msg.sender, retAmount0);\\n            }\\n        }\\n        if (retAmount1 \\u003e 0) {\\n            if (token1 == WETH) {\\n                IWETH(WETH).withdraw(retAmount1);\\n                msg.sender.transfer(retAmount1);\\n            } else {\\n                IERC20(token1).safeTransfer(msg.sender, retAmount1);\\n            }\\n        }\\n        emit AddedLiquidity(token0, token1, liquiditySum, inAmount0, inAmount1);\\n    }\\n\\n    function removeLiquidityFromUniV3(\\n        CellarRemoveParams calldata cellarParams\\n    ) external override nonReentrant notLocked(msg.sender) {\\n        require(block.timestamp \\u003c= cellarParams.deadline);\\n        (uint256 outAmount0, uint256 outAmount1, uint128 liquiditySum, ) =\\n            _removeLiquidity(cellarParams, false);\\n        _burn(msg.sender, cellarParams.tokenAmount);\\n\\n        require(outAmount0 \\u003e= cellarParams.amount0Min, \\\"R16\\\");\\n        require(outAmount1 \\u003e= cellarParams.amount1Min, \\\"R17\\\");\\n\\n        if (token0 == WETH) {\\n            IWETH(WETH).withdraw(outAmount0);\\n            msg.sender.transfer(outAmount0);\\n            IERC20(token1).safeTransfer(msg.sender, outAmount1);\\n        } else {\\n            require(token1 == WETH, \\\"R19\\\");\\n            IWETH(WETH).withdraw(outAmount1);\\n            msg.sender.transfer(outAmount1);\\n            IERC20(token0).safeTransfer(msg.sender, outAmount0);\\n        }\\n        emit RemovedLiquidity(\\n            token0,\\n            token1,\\n            liquiditySum,\\n            outAmount0,\\n            outAmount1\\n        );\\n    }\\n\\n    function invest(uint160 sqrtPriceX96)\\n        private\\n        returns (\\n            uint256 totalInAmount0,\\n            uint256 totalInAmount1\\n        )\\n    {\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n\\n        (uint256 inAmount0, uint256 inAmount1, , ) =\\n            _addLiquidity(\\n                CellarAddParams({\\n                    amount0Desired: balance0,\\n                    amount1Desired: balance1,\\n                    amount0Min: 0,\\n                    amount1Min: 0,\\n                    recipient: address(this),\\n                    deadline: type(uint256).max\\n                })\\n            );\\n        balance0 -= inAmount0;\\n        balance1 -= inAmount1;\\n\\n        totalInAmount0 += inAmount0;\\n        totalInAmount1 += inAmount1;\\n\\n\\n        if (balance0 * inAmount1 \\u003e balance1 * inAmount0 || (inAmount0 == 0 \\u0026\\u0026 inAmount1 == 0 \\u0026\\u0026 balance0 \\u003e balance1)) {\\n            uint256 swapAmount = (balance0 * inAmount1 - balance1 * inAmount0)\\n                /\\n                (FullMath.mulDiv(\\n                    FullMath.mulDiv(\\n                        inAmount0,\\n                        sqrtPriceX96,\\n                        FixedPoint96.Q96),\\n                    sqrtPriceX96,\\n                    FixedPoint96.Q96)\\n                + inAmount1);\\n            if (inAmount0 == 0 \\u0026\\u0026 inAmount1 == 0) {\\n                swapAmount = balance0 / 2;\\n            }\\n            IERC20(token0).safeApprove(SWAPROUTER, swapAmount);\\n            try ISwapRouter(SWAPROUTER).exactInputSingle(\\n                ISwapRouter.ExactInputSingleParams({\\n                    tokenIn: token0,\\n                    tokenOut: token1,\\n                    fee: feeLevel,\\n                    recipient: address(this),\\n                    deadline: type(uint256).max,\\n                    amountIn: swapAmount,\\n                    amountOutMinimum: 0,\\n                    sqrtPriceLimitX96: 0\\n                })\\n            ) {} catch {}\\n            IERC20(token0).safeApprove(SWAPROUTER, 0);\\n        }\\n        if (balance0 * inAmount1 \\u003c balance1 * inAmount0 || (inAmount0 == 0 \\u0026\\u0026 inAmount1 == 0 \\u0026\\u0026 balance0 \\u003c balance1)) {\\n            uint256 swapAmount = (balance1 * inAmount0 - balance0 * inAmount1)\\n                /\\n                (FullMath.mulDiv(\\n                    FullMath.mulDiv(\\n                        inAmount1,\\n                        FixedPoint96.Q96,\\n                        sqrtPriceX96),\\n                    FixedPoint96.Q96,\\n                    sqrtPriceX96)\\n                + inAmount0);\\n            if (inAmount0 == 0 \\u0026\\u0026 inAmount1 == 0) {\\n                swapAmount = balance1 / 2;\\n            }\\n            IERC20(token1).safeApprove(SWAPROUTER, swapAmount);\\n            try ISwapRouter(SWAPROUTER).exactInputSingle(\\n                ISwapRouter.ExactInputSingleParams({\\n                    tokenIn: token1,\\n                    tokenOut: token0,\\n                    fee: feeLevel,\\n                    recipient: address(this),\\n                    deadline: type(uint256).max,\\n                    amountIn: swapAmount,\\n                    amountOutMinimum: 0,\\n                    sqrtPriceLimitX96: 0\\n                })\\n            ) {} catch {}\\n            IERC20(token1).safeApprove(SWAPROUTER, 0);\\n        }\\n\\n        balance0 = IERC20(token0).balanceOf(address(this));\\n        balance1 = IERC20(token1).balanceOf(address(this));\\n        (inAmount0, inAmount1, , ) =\\n            _addLiquidity(\\n                CellarAddParams({\\n                    amount0Desired: balance0,\\n                    amount1Desired: balance1,\\n                    amount0Min: 0,\\n                    amount1Min: 0,\\n                    recipient: address(this),\\n                    deadline: type(uint256).max\\n                })\\n            );\\n\\n        totalInAmount0 += inAmount0;\\n        totalInAmount1 += inAmount1;\\n    }\\n\\n    function getManagementFee(uint256 tokenId, uint160 sqrtPriceX96, uint256 duration)\\n        internal\\n        view\\n        returns (uint256 feeAmount0, uint256 feeAmount1)\\n    {\\n        (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) =\\n            INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\\n                .positions(tokenId);\\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\\n        (uint256 amount0, uint256 amount1) =\\n            LiquidityAmounts.getAmountsForLiquidity(sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, liquidity);\\n        feeAmount0 = amount0 * managementFee * duration / YEAR / FEEDOMINATOR;\\n        feeAmount1 = amount1 * managementFee * duration / YEAR / FEEDOMINATOR;\\n    }\\n\\n    function reinvest() external override onlyValidator notLocked(msg.sender) {\\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\\n        uint256 weightSum;\\n        uint256 balance0;\\n        uint256 balance1;\\n        uint256 fee0;\\n        uint256 fee1;\\n        uint256 duration = block.timestamp - lastManageTimestamp;\\n        (uint160 sqrtPriceX96, , , , , , ) =\\n            IUniswapV3Pool(\\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\\n                    token0,\\n                    token1,\\n                    feeLevel\\n                )\\n            )\\n                .slot0();\\n        for (uint256 index = 0; index \\u003c _cellarTickInfo.length; index++) {\\n            require(_cellarTickInfo[index].tokenId != 0, \\\"R20\\\");//\\\"NFLP doesnot exist\\\"\\n            weightSum += _cellarTickInfo[index].weight;\\n            (uint256 amount0, uint256 amount1) =\\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).collect(\\n                    INonfungiblePositionManager.CollectParams({\\n                        tokenId: _cellarTickInfo[index].tokenId,\\n                        recipient: address(this),\\n                        amount0Max: type(uint128).max,\\n                        amount1Max: type(uint128).max\\n                    })\\n                );\\n            balance0 += amount0;\\n            balance1 += amount1;\\n            (uint256 mFee0, uint256 mFee1) = getManagementFee(_cellarTickInfo[index].tokenId, sqrtPriceX96, duration);\\n            fee0 += mFee0;\\n            fee1 += mFee1;\\n        }\\n        uint256 mgmtFee0 = fee0;\\n        uint256 mgmtFee1 = fee1;\\n        uint256 perfFee0 = (balance0 * performanceFee) / FEEDOMINATOR;\\n        uint256 perfFee1 = (balance1 * performanceFee) / FEEDOMINATOR;\\n        fee0 += perfFee0;\\n        fee1 += perfFee1;\\n        if (fee0 \\u003e balance0) {\\n            fee0 = balance0;\\n            if (mgmtFee0 \\u003c balance0) {\\n                perfFee0 = balance0 - mgmtFee0;\\n            } else {\\n                mgmtFee0 = balance0;\\n                perfFee0 = 0;\\n            }\\n        }\\n        if (fee1 \\u003e balance1) {\\n            fee1 = balance1;\\n            if (mgmtFee1 \\u003c balance1) {\\n                perfFee1 = balance1 - mgmtFee1;\\n            } else {\\n                mgmtFee1 = balance1;\\n                perfFee1 = 0;\\n            }\\n        }\\n        lastManageTimestamp = block.timestamp;\\n        if (fee0 \\u003e 0) {\\n            IERC20(token0).safeTransfer(_owner, fee0);\\n        }\\n        if (fee1 \\u003e 0) {\\n            IERC20(token1).safeTransfer(_owner, fee1);\\n        }\\n        (uint256 investedAmount0, uint256 investedAmount1) = invest(sqrtPriceX96);\\n\\n        emit Reinvest(\\n            balance0,\\n            balance1,\\n            mgmtFee0,\\n            mgmtFee1,\\n            perfFee0,\\n            perfFee1,\\n            investedAmount0,\\n            investedAmount1\\n        );\\n    }\\n\\n    function rebalance(CellarTickInfo[] memory _cellarTickInfo) external notLocked(msg.sender) {\\n        require(msg.sender == _owner, \\\"R21\\\");//\\\"Not owner\\\"\\n        (uint160 sqrtPriceX96, , , , , , ) =\\n            IUniswapV3Pool(\\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\\n                    token0,\\n                    token1,\\n                    feeLevel\\n                )\\n            )\\n                .slot0();\\n        CellarRemoveParams memory removeParams =\\n            CellarRemoveParams({\\n                tokenAmount: _totalSupply,\\n                amount0Min: 0,\\n                amount1Min: 0,\\n                recipient: address(this),\\n                deadline: type(uint256).max\\n            });\\n\\n        (uint256 outAmount0, uint256 outAmount1, uint128 liquiditySum, CellarFees memory cellarFees) =\\n            _removeLiquidity(removeParams, true);\\n        lastManageTimestamp = block.timestamp;\\n\\n        uint256 fee0 = cellarFees.management0 + cellarFees.performance0;\\n        uint256 fee1 = cellarFees.management1 + cellarFees.performance1;\\n        if (fee0 \\u003e cellarFees.collect0) {\\n            fee0 = cellarFees.collect0;\\n            if (cellarFees.management0 \\u003c cellarFees.collect0) {\\n                cellarFees.performance0 = cellarFees.collect0 - cellarFees.management0;\\n            } else {\\n                cellarFees.management0 = cellarFees.collect0;\\n                cellarFees.performance0 = 0;\\n            }\\n        }\\n        if (fee1 \\u003e cellarFees.collect1) {\\n            fee1 = cellarFees.collect1;\\n            if (cellarFees.management1 \\u003c cellarFees.collect1) {\\n                cellarFees.performance1 = cellarFees.collect1 - cellarFees.management1;\\n            } else {\\n                cellarFees.management1 = cellarFees.collect1;\\n                cellarFees.performance1 = 0;\\n            }\\n        }\\n\\n        if (fee0 \\u003e 0) {\\n            IERC20(token0).safeTransfer(_owner, fee0);\\n        }\\n        if (fee1 \\u003e 0) {\\n            IERC20(token1).safeTransfer(_owner, fee1);\\n        }\\n        CellarTickInfo[] memory _oldCellarTickInfo = cellarTickInfo;\\n        for (uint256 i = 0; i \\u003c _oldCellarTickInfo.length; i++) {\\n            INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).burn(\\n                _oldCellarTickInfo[i].tokenId\\n            );\\n        }\\n        delete cellarTickInfo;\\n        for (uint256 i = 0; i \\u003c _cellarTickInfo.length; i++) {\\n            require(_cellarTickInfo[i].tickUpper \\u003e _cellarTickInfo[i].tickLower, \\\"R12\\\");\\n            if (i \\u003e 0) {\\n                require(_cellarTickInfo[i].tickUpper \\u003c= _cellarTickInfo[i - 1].tickLower, \\\"R12\\\");\\n            }\\n            require(_cellarTickInfo[i].weight \\u003e 0, \\\"R10\\\");\\n            require(_cellarTickInfo[i].tokenId == 0, \\\"R11\\\");\\n            cellarTickInfo.push(_cellarTickInfo[i]);\\n        }\\n\\n        (uint256 investedAmount0, uint256 investedAmount1) = invest(sqrtPriceX96);\\n\\n        emit Rebalance(\\n            cellarFees.collect0,\\n            cellarFees.collect1,\\n            cellarFees.management0,\\n            cellarFees.management1,\\n            cellarFees.performance0,\\n            cellarFees.performance1,\\n            investedAmount0,\\n            investedAmount1\\n        );\\n    }\\n\\n    function setValidator(address _validator, bool value) external override {\\n        require(msg.sender == _owner, \\\"R21\\\");\\n        validator[_validator] = value;\\n    }\\n\\n    function transferOwnership(address newOwner) external override {\\n        require(msg.sender == _owner, \\\"R21\\\");\\n        _owner = newOwner;\\n    }\\n\\n    function setManagementFee(uint256 newFee) external override {\\n        require(msg.sender == _owner, \\\"R21\\\");\\n        managementFee = newFee;\\n    }\\n\\n    function setPerformanceFee(uint256 newFee) external override {\\n        require(msg.sender == _owner, \\\"R21\\\");\\n        performanceFee = newFee;\\n    }\\n\\n    function owner() external view override returns (address) {\\n        return _owner;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner_, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner_][spender];\\n    }\\n\\n    function getCellarTickInfo()\\n        external\\n        view\\n        override\\n        returns (CellarTickInfo[] memory)\\n    {\\n        return cellarTickInfo;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"R22\\\");//\\\"transfer from zero address\\\"\\n        require(recipient != address(0), \\\"R23\\\");//\\\"transfer to zero address\\\"\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"R24\\\");//\\\"transfer exceeds balance\\\"\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"R25\\\");//\\\"mint to zero address\\\"\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"R26\\\");//\\\"burn from zero address\\\"\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance \\u003e= amount, \\\"R27\\\");//\\\"burn exceeds balance\\\"\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner_,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner_ != address(0), \\\"R28\\\");//\\\"approve from zero address\\\"\\n        require(spender != address(0), \\\"R29\\\");//\\\"approve to zero address\\\"\\n\\n        _allowances[owner_][spender] = amount;\\n        emit Approval(owner_, spender, amount);\\n    }\\n\\n    function _getWeightInfo(CellarTickInfo[] memory _cellarTickInfo)\\n        internal\\n        view\\n        returns (\\n            uint256 weightSum0,\\n            uint256 weightSum1,\\n            uint128 liquidityBefore,\\n            uint256[] memory weight0,\\n            uint256[] memory weight1\\n        )\\n    {\\n        weight0 = new uint256[](_cellarTickInfo.length);\\n        weight1 = new uint256[](_cellarTickInfo.length);\\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) =\\n            IUniswapV3Pool(\\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\\n                    token0,\\n                    token1,\\n                    feeLevel\\n                )\\n            )\\n                .slot0();\\n        UintPair memory sqrtPrice0;\\n\\n        uint256 weight00;\\n        uint256 weight10;\\n\\n        sqrtPrice0.a = TickMath.getSqrtRatioAtTick(\\n            _cellarTickInfo[0].tickLower\\n        );\\n        sqrtPrice0.b = TickMath.getSqrtRatioAtTick(\\n            _cellarTickInfo[0].tickUpper\\n        );\\n\\n        weight00 = _cellarTickInfo[0].weight;\\n\\n        weight10 = _cellarTickInfo[_cellarTickInfo.length - 1].weight;\\n        for (uint256 i = 0; i \\u003c _cellarTickInfo.length; i++) {\\n            if (_cellarTickInfo[i].tokenId \\u003e 0) {\\n                (, , , , , , , uint128 liquidity, , , , ) =\\n                    INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\\n                        .positions(_cellarTickInfo[i].tokenId);\\n                liquidityBefore += liquidity;\\n            }\\n\\n            UintPair memory sqrtCurrentTickPriceX96;\\n            sqrtCurrentTickPriceX96.a = TickMath.getSqrtRatioAtTick(\\n                _cellarTickInfo[i].tickLower\\n            );\\n            sqrtCurrentTickPriceX96.b = TickMath.getSqrtRatioAtTick(\\n                _cellarTickInfo[i].tickUpper\\n            );\\n\\n            if (currentTick \\u003c= _cellarTickInfo[i].tickLower) {\\n                weight0[i] =\\n                    (FullMath.mulDiv(\\n                        FullMath.mulDiv(\\n                            FullMath.mulDiv(\\n                                sqrtPrice0.a,\\n                                sqrtPrice0.b,\\n                                sqrtPrice0.b - sqrtPrice0.a\\n                            ),\\n                            sqrtCurrentTickPriceX96.b -\\n                                sqrtCurrentTickPriceX96.a,\\n                            sqrtCurrentTickPriceX96.b\\n                        ),\\n                        FixedPoint96.Q96,\\n                        sqrtCurrentTickPriceX96.a\\n                    ) * _cellarTickInfo[i].weight) /\\n                    weight00;\\n                weightSum0 += weight0[i];\\n            } else if (currentTick \\u003e= _cellarTickInfo[i].tickUpper) {\\n                weight1[i] =\\n                    (FullMath.mulDiv(\\n                        sqrtCurrentTickPriceX96.b - sqrtCurrentTickPriceX96.a,\\n                        FixedPoint96.Q96,\\n                        sqrtPrice0.b - sqrtPrice0.a\\n                    ) * _cellarTickInfo[i].weight) /\\n                    weight10;\\n                weightSum1 += weight1[i];\\n            } else {\\n                weight0[i] =\\n                    (FullMath.mulDiv(\\n                        FullMath.mulDiv(\\n                            FullMath.mulDiv(\\n                                sqrtPrice0.a,\\n                                sqrtPrice0.b,\\n                                sqrtPrice0.b - sqrtPrice0.a\\n                            ),\\n                            sqrtCurrentTickPriceX96.b - sqrtPriceX96,\\n                            sqrtCurrentTickPriceX96.b\\n                        ),\\n                        FixedPoint96.Q96,\\n                        sqrtPriceX96\\n                    ) * _cellarTickInfo[i].weight) /\\n                    weight00;\\n\\n                weight1[i] =\\n                    (FullMath.mulDiv(\\n                        sqrtPriceX96 - sqrtCurrentTickPriceX96.a,\\n                        FixedPoint96.Q96,\\n                        sqrtPrice0.b - sqrtPrice0.a\\n                    ) * _cellarTickInfo[i].weight) /\\n                    weight10;\\n                weightSum0 += weight0[i];\\n                weightSum1 += weight1[i];\\n            }\\n        }\\n    }\\n\\n    function _modifyWeightInfo(\\n        CellarTickInfo[] memory _cellarTickInfo,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired,\\n        uint256 weightSum0,\\n        uint256 weightSum1,\\n        uint256[] memory weight0,\\n        uint256[] memory weight1\\n    ) internal view returns (uint256 newWeightSum0, uint256 newWeightSum1) {\\n        if (_cellarTickInfo.length == 1) {\\n            return (weightSum0, weightSum1);\\n        }\\n\\n        UintPair memory liquidity;\\n        (uint160 sqrtPriceX96, , , , , , ) =\\n            IUniswapV3Pool(\\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\\n                    token0,\\n                    token1,\\n                    feeLevel\\n                )\\n            )\\n                .slot0();\\n        liquidity.a = LiquidityAmounts.getLiquidityForAmounts(\\n            sqrtPriceX96,\\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[0].tickLower),\\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[0].tickUpper),\\n            FullMath.mulDiv(amount0Desired, weight0[0], weightSum0),\\n            FullMath.mulDiv(amount1Desired, weight1[0], weightSum1)\\n        );\\n        uint256 tickLength = _cellarTickInfo.length - 1;\\n        liquidity.b = LiquidityAmounts.getLiquidityForAmounts(\\n            sqrtPriceX96,\\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[tickLength].tickLower),\\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[tickLength].tickUpper),\\n            FullMath.mulDiv(amount0Desired, weight0[tickLength], weightSum0),\\n            FullMath.mulDiv(amount1Desired, weight1[tickLength], weightSum1)\\n        );\\n\\n        if (\\n            liquidity.a * _cellarTickInfo[tickLength].weight \\u003e\\n            liquidity.b * _cellarTickInfo[0].weight\\n        ) {\\n            if (liquidity.b * _cellarTickInfo[0].weight \\u003e 0) {\\n                newWeightSum0 = FullMath.mulDiv(\\n                    weightSum0,\\n                    liquidity.a * _cellarTickInfo[tickLength].weight,\\n                    liquidity.b * _cellarTickInfo[0].weight\\n                );\\n            }\\n            else {\\n                newWeightSum0 = 0;\\n            }\\n            newWeightSum1 = weightSum1;\\n        } else {\\n            newWeightSum0 = weightSum0;\\n            if (liquidity.a * _cellarTickInfo[tickLength].weight \\u003e 0) {\\n                newWeightSum1 = FullMath.mulDiv(\\n                    weightSum1,\\n                    liquidity.b * _cellarTickInfo[0].weight,\\n                    liquidity.a * _cellarTickInfo[tickLength].weight\\n                );\\n            }\\n            else {\\n                newWeightSum1 = 0;\\n            }\\n        }\\n    }\\n\\n    function _addLiquidity(CellarAddParams memory cellarParams)\\n        internal\\n        returns (\\n            uint256 inAmount0,\\n            uint256 inAmount1,\\n            uint128 liquidityBefore,\\n            uint128 liquiditySum\\n        )\\n    {\\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\\n        IERC20(token0).safeApprove(\\n            NONFUNGIBLEPOSITIONMANAGER,\\n            cellarParams.amount0Desired\\n        );\\n        IERC20(token1).safeApprove(\\n            NONFUNGIBLEPOSITIONMANAGER,\\n            cellarParams.amount1Desired\\n        );\\n\\n        uint256 weightSum0;\\n        uint256 weightSum1;\\n        uint256[] memory weight0 = new uint256[](_cellarTickInfo.length);\\n        uint256[] memory weight1 = new uint256[](_cellarTickInfo.length);\\n\\n        (\\n            weightSum0,\\n            weightSum1,\\n            liquidityBefore,\\n            weight0,\\n            weight1\\n        ) = _getWeightInfo(_cellarTickInfo);\\n        if (weightSum0 \\u003e 0 \\u0026\\u0026 weightSum1 \\u003e 0) {\\n            (weightSum0, weightSum1) = _modifyWeightInfo(\\n                _cellarTickInfo,\\n                cellarParams.amount0Desired,\\n                cellarParams.amount1Desired,\\n                weightSum0,\\n                weightSum1,\\n                weight0,\\n                weight1\\n            );\\n        }\\n\\n        for (uint256 i = 0; i \\u003c _cellarTickInfo.length; i++) {\\n            INonfungiblePositionManager.MintParams memory mintParams =\\n                INonfungiblePositionManager.MintParams({\\n                    token0: token0,\\n                    token1: token1,\\n                    fee: feeLevel,\\n                    tickLower: _cellarTickInfo[i].tickLower,\\n                    tickUpper: _cellarTickInfo[i].tickUpper,\\n                    amount0Desired: 0,\\n                    amount1Desired: 0,\\n                    amount0Min: 0,\\n                    amount1Min: 0,\\n                    recipient: address(this),\\n                    deadline: cellarParams.deadline\\n                });\\n\\n                INonfungiblePositionManager.IncreaseLiquidityParams\\n                    memory increaseLiquidityParams\\n             =\\n                INonfungiblePositionManager.IncreaseLiquidityParams({\\n                    tokenId: _cellarTickInfo[i].tokenId,\\n                    amount0Desired: 0,\\n                    amount1Desired: 0,\\n                    amount0Min: 0,\\n                    amount1Min: 0,\\n                    deadline: cellarParams.deadline\\n                });\\n            if (weightSum0 \\u003e 0) {\\n                mintParams.amount0Desired = FullMath.mulDiv(\\n                    cellarParams.amount0Desired,\\n                    weight0[i],\\n                    weightSum0\\n                );\\n                increaseLiquidityParams.amount0Desired = mintParams\\n                    .amount0Desired;\\n                mintParams.amount0Min = FullMath.mulDiv(\\n                    cellarParams.amount0Min,\\n                    weight0[i],\\n                    weightSum0\\n                );\\n                increaseLiquidityParams.amount0Min = mintParams.amount0Min;\\n            }\\n            if (weightSum1 \\u003e 0) {\\n                mintParams.amount1Desired = FullMath.mulDiv(\\n                    cellarParams.amount1Desired,\\n                    weight1[i],\\n                    weightSum1\\n                );\\n                increaseLiquidityParams.amount1Desired = mintParams\\n                    .amount1Desired;\\n                mintParams.amount1Min = FullMath.mulDiv(\\n                    cellarParams.amount1Min,\\n                    weight1[i],\\n                    weightSum1\\n                );\\n                increaseLiquidityParams.amount1Min = mintParams.amount1Min;\\n            }\\n            if (\\n                mintParams.amount0Desired \\u003e 0 || mintParams.amount1Desired \\u003e 0\\n            ) {\\n                MintResult memory mintResult;\\n                if (_cellarTickInfo[i].tokenId == 0) {\\n\\n                    try INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\\n                        .mint(mintParams) returns (uint256 r1, uint128 r2, uint256 r3, uint256 r4) {\\n                        mintResult.tokenId = r1;\\n                        mintResult.liquidity = r2;\\n                        mintResult.amount0 = r3;\\n                        mintResult.amount1 = r4;\\n                    } catch {}\\n\\n                    cellarTickInfo[i].tokenId = uint184(mintResult.tokenId);\\n\\n                    inAmount0 += mintResult.amount0;\\n                    inAmount1 += mintResult.amount1;\\n                    liquiditySum += mintResult.liquidity;\\n                } else {\\n                    try INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\\n                        .increaseLiquidity(increaseLiquidityParams) returns (uint128 r1, uint256 r2, uint256 r3) {\\n                        mintResult.liquidity = r1;\\n                        mintResult.amount0 = r2;\\n                        mintResult.amount1 = r3;\\n                    } catch {}\\n                    inAmount0 += mintResult.amount0;\\n                    inAmount1 += mintResult.amount1;\\n                    liquiditySum += mintResult.liquidity;\\n                }\\n            }\\n        }\\n        IERC20(token0).safeApprove(NONFUNGIBLEPOSITIONMANAGER, 0);\\n        IERC20(token1).safeApprove(NONFUNGIBLEPOSITIONMANAGER, 0);\\n    }\\n\\n    function _removeLiquidity(CellarRemoveParams memory cellarParams, bool getFee)\\n        internal\\n        returns (\\n            uint256 outAmount0,\\n            uint256 outAmount1,\\n            uint128 liquiditySum,\\n            CellarFees memory cellarFees\\n        )\\n    {\\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\\n        uint256 duration = block.timestamp - lastManageTimestamp;\\n        (uint160 sqrtPriceX96, , , , , , ) =\\n            IUniswapV3Pool(\\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\\n                    token0,\\n                    token1,\\n                    feeLevel\\n                )\\n            )\\n                .slot0();\\n        for (uint256 i = 0; i \\u003c _cellarTickInfo.length; i++) {\\n            (, , , , , , , uint128 liquidity, , , , ) =\\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\\n                    .positions(_cellarTickInfo[i].tokenId);\\n            uint128 outLiquidity =\\n                uint128(\\n                    FullMath.mulDiv(\\n                        liquidity,\\n                        cellarParams.tokenAmount,\\n                        _totalSupply\\n                    )\\n                );\\n\\n                INonfungiblePositionManager.DecreaseLiquidityParams\\n                    memory decreaseLiquidityParams\\n             =\\n                INonfungiblePositionManager.DecreaseLiquidityParams({\\n                    tokenId: _cellarTickInfo[i].tokenId,\\n                    liquidity: outLiquidity,\\n                    amount0Min: 0,\\n                    amount1Min: 0,\\n                    deadline: cellarParams.deadline\\n                });\\n            UintPair memory amount;\\n            (amount.a, amount.b) =\\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\\n                    .decreaseLiquidity(decreaseLiquidityParams);\\n            UintPair memory collectAmount;\\n            (collectAmount.a, collectAmount.b) =\\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).collect(\\n                    INonfungiblePositionManager.CollectParams({\\n                        tokenId: _cellarTickInfo[i].tokenId,\\n                        recipient: address(this),\\n                        amount0Max: type(uint128).max,\\n                        amount1Max: type(uint128).max\\n                    })\\n                );\\n            outAmount0 += amount.a;\\n            outAmount1 += amount.b;\\n            liquiditySum += outLiquidity;\\n            if (getFee) {\\n                cellarFees.collect0 += collectAmount.a - amount.a;\\n                cellarFees.collect1 += collectAmount.b - amount.b;\\n                (amount.a, amount.b) = getManagementFee(_cellarTickInfo[i].tokenId, sqrtPriceX96, duration);\\n                cellarFees.management0 += amount.a;\\n                cellarFees.management1 += amount.b;\\n            }\\n        }\\n        if (getFee) {\\n            cellarFees.performance0 = (cellarFees.collect0 * performanceFee) / FEEDOMINATOR;\\n            cellarFees.performance1 = (cellarFees.collect1 * performanceFee) / FEEDOMINATOR;\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    receive() external payable {}\\n}\\n\"},\"interfaces.sol\":{\"content\":\"//SPDX-License-Identifier: Apache-2.0\\n// VolumeFi Software, Inc.\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface INonfungiblePositionManager {\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    struct IncreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    struct DecreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint128 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    struct CollectParams {\\n        uint256 tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function mint(MintParams calldata params)\\n        external\\n        payable\\n        returns (\\n            uint256 tokenId,\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n\\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function collect(CollectParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function burn(uint256 tokenId) external payable;\\n\\n    function positions(uint256 tokenId)\\n        external\\n        view\\n        returns (\\n            uint96 nonce,\\n            address operator,\\n            address token0,\\n            address token1,\\n            uint24 fee,\\n            int24 tickLower,\\n            int24 tickUpper,\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n}\\n\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function exactInputSingle(ExactInputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n}\\n\\ninterface IUniswapV3Factory {\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n}\\n\\ninterface IUniswapV3Pool {\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n}\\n\\nlibrary Address {\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"R2\\\");//\\\"Address: low-level call failed\\\"\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"R3\\\"//\\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance \\u003e= value,\\n            \\\"R4\\\"//\\\"insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"R5\\\");//\\\"Address: call to non-contract\\\"\\n\\n        (bool success, bytes memory returndata) =\\n            target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"R6\\\"//\\\"approve non-zero to non-zero\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata =\\n            address(token).functionCall(\\n                data,\\n                \\\"R7\\\"//\\\"SafeERC20: low-level call failed\\\"\\n            );\\n        if (returndata.length \\u003e 0) {\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"R8\\\"//\\\"ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\\nlibrary FullMath {\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 == 0) {\\n            require(denominator \\u003e 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        require(denominator \\u003e prod1);\\n\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        uint256 twos = -denominator \\u0026 denominator;\\n\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        uint256 inv = (3 * denominator) ^ 2;\\n\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        result = prod0 * inv;\\n        return result;\\n    }\\n}\\n\\nlibrary TickMath {\\n    int24 internal constant MIN_TICK = -887272;\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    function getSqrtRatioAtTick(int24 tick)\\n        internal\\n        pure\\n        returns (uint160 sqrtPriceX96)\\n    {\\n        uint256 absTick =\\n            tick \\u003c 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick \\u003c= uint256(MAX_TICK), \\\"T\\\");\\n\\n        uint256 ratio =\\n            absTick \\u0026 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n        if (absTick \\u0026 0x2 != 0)\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x4 != 0)\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x8 != 0)\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x10 != 0)\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x20 != 0)\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x40 != 0)\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x80 != 0)\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x100 != 0)\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x200 != 0)\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x400 != 0)\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x800 != 0)\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x1000 != 0)\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x2000 != 0)\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x4000 != 0)\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x8000 != 0)\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x10000 != 0)\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x20000 != 0)\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x40000 != 0)\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) \\u003e\\u003e 128;\\n        if (absTick \\u0026 0x80000 != 0)\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) \\u003e\\u003e 128;\\n\\n        if (tick \\u003e 0) ratio = type(uint256).max / ratio;\\n\\n        sqrtPriceX96 = uint160(\\n            (ratio \\u003e\\u003e 32) + (ratio % (1 \\u003c\\u003c 32) == 0 ? 0 : 1)\\n        );\\n    }\\n}\\n\\nlibrary LiquidityAmounts {\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\n        require((y = uint128(x)) == x);\\n    }\\n\\n    function getLiquidityForAmount0(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 \\u003e sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        uint256 intermediate =\\n            FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\\n        return\\n            toUint128(\\n                FullMath.mulDiv(\\n                    amount0,\\n                    intermediate,\\n                    sqrtRatioBX96 - sqrtRatioAX96\\n                )\\n            );\\n    }\\n\\n    function getLiquidityForAmount1(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 \\u003e sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        return\\n            toUint128(\\n                FullMath.mulDiv(\\n                    amount1,\\n                    FixedPoint96.Q96,\\n                    sqrtRatioBX96 - sqrtRatioAX96\\n                )\\n            );\\n    }\\n\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 \\u003e sqrtRatioBX96)\\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 \\u003c= sqrtRatioAX96) {\\n            liquidity = getLiquidityForAmount0(\\n                sqrtRatioAX96,\\n                sqrtRatioBX96,\\n                amount0\\n            );\\n        } else if (sqrtRatioX96 \\u003c sqrtRatioBX96) {\\n            uint128 liquidity0 =\\n                getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n            uint128 liquidity1 =\\n                getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n\\n            liquidity = liquidity0 \\u003c liquidity1 ? liquidity0 : liquidity1;\\n        } else {\\n            liquidity = getLiquidityForAmount1(\\n                sqrtRatioAX96,\\n                sqrtRatioBX96,\\n                amount1\\n            );\\n        }\\n    }\\n\\n    function getAmount0ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 \\u003e sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                uint256(liquidity) \\u003c\\u003c FixedPoint96.RESOLUTION,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                sqrtRatioBX96\\n            ) / sqrtRatioAX96;\\n    }\\n\\n    function getAmount1ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 \\u003e sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\n        if (sqrtRatioAX96 \\u003e sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 \\u003c= sqrtRatioAX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        } else if (sqrtRatioX96 \\u003c sqrtRatioBX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n        } else {\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        }\\n    }\\n}\\n\\ninterface ICellarPoolShare is IERC20 {\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    struct MintResult {\\n        uint256 tokenId;\\n        uint128 liquidity;\\n        uint256 amount0;\\n        uint256 amount1;\\n    }\\n\\n    struct CellarAddParams {\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    struct CellarRemoveParams {\\n        uint256 tokenAmount;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        address recipient;\\n        uint256 deadline;\\n    }\\n\\n    struct CellarTickInfo {\\n        uint184 tokenId;\\n        int24 tickUpper;\\n        int24 tickLower;\\n        uint24 weight;\\n    }\\n\\n    struct UintPair {\\n        uint256 a;\\n        uint256 b;\\n    }\\n\\n    struct CellarFees {\\n        uint256 collect0;\\n        uint256 collect1;\\n        uint256 management0;\\n        uint256 management1;\\n        uint256 performance0;\\n        uint256 performance1;\\n    }\\n\\n    event AddedLiquidity(\\n        address indexed token0,\\n        address indexed token1,\\n        uint128 liquidity,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event RemovedLiquidity(\\n        address indexed token0,\\n        address indexed token1,\\n        uint128 liquidity,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Reinvest (\\n        uint256 fees0,\\n        uint256 fees1,\\n        uint256 managementFee0,\\n        uint256 managementFee1,\\n        uint256 performanceFee0,\\n        uint256 performanceFee1,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Rebalance (\\n        uint256 fees0,\\n        uint256 fees1,\\n        uint256 managementFee0,\\n        uint256 managementFee1,\\n        uint256 performanceFee0,\\n        uint256 performanceFee1,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    function addLiquidityForUniV3(CellarAddParams calldata cellarParams)\\n        external\\n        payable;\\n\\n    function removeLiquidityFromUniV3(CellarRemoveParams calldata cellarParams)\\n        external;\\n\\n    function reinvest() external;\\n\\n    function setValidator(address _validator, bool value) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function setManagementFee(uint256 newFee) external;\\n\\n    function setPerformanceFee(uint256 newFee) external;\\n\\n    function owner() external view returns (address);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function getCellarTickInfo() external view returns (CellarTickInfo[] memory);\\n\\n    function decimals() external pure returns (uint8);\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\\ncontract BlockLock {\\n    // how many blocks are the functions locked for\\n    uint256 private constant BLOCK_LOCK_COUNT = 1;\\n    // last block for which this address is timelocked\\n    mapping(address =\\u003e uint256) public lastLockedBlock;\\n\\n    modifier notLocked(address lockedAddress) {\\n        require(lastLockedBlock[lockedAddress] \\u003c= block.number, \\\"R30\\\");//\\\"Locked\\\"\\n        lastLockedBlock[lockedAddress] = block.number + BLOCK_LOCK_COUNT;\\n        _;\\n    }\\n}\\n\\ninterface AggregatorV3Interface {\\n    function latestAnswer() external view returns(int256);\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_feeLevel\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"internalType\":\"struct ICellarPoolShare.CellarTickInfo[]\",\"name\":\"_cellarTickInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"AddedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managementFee0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managementFee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"performanceFee0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"performanceFee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managementFee0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"managementFee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"performanceFee0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"performanceFee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"RemovedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ICellarPoolShare.CellarAddParams\",\"name\":\"cellarParams\",\"type\":\"tuple\"}],\"name\":\"addLiquidityForUniV3\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cellarTickInfo\",\"outputs\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLevel\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCellarTickInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"internalType\":\"struct ICellarPoolShare.CellarTickInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastLockedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"internalType\":\"struct ICellarPoolShare.CellarTickInfo[]\",\"name\":\"_cellarTickInfo\",\"type\":\"tuple[]\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ICellarPoolShare.CellarRemoveParams\",\"name\":\"cellarParams\",\"type\":\"tuple\"}],\"name\":\"removeLiquidityFromUniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setManagementFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CellarPoolShareLimitUSDCETH","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000002c43656c6c617220506f6f6c205368617265204c696d69746564205465737420555344432d4554482d33303030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034350530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000033450000000000000000000000000000000000000000000000000000000000002bf200000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://358fbdd82eddaa84d9571498cbc60a60b7b34a7f360d4594616d39334e726b66"}]}