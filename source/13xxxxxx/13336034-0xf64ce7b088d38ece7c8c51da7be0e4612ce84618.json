{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation with open minting.\r\ncontract OpenNFT {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    string public name;\r\n    string public symbol;\r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(uint256 => address) public ownerOf;\r\n    mapping(uint256 => string) public tokenURI;\r\n    mapping(uint256 => address) public getApproved;\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n    \r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_ALL_TYPEHASH = \r\n        keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\r\n    \r\n    uint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;\r\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\r\n\r\n    mapping(uint256 => uint256) public nonces;\r\n    mapping(address => uint256) public noncesForAll;\r\n    \r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        \r\n        DOMAIN_SEPARATOR_CHAIN_ID = block.chainid;\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator();\r\n    }\r\n    \r\n    function _calculateDomainSeparator() internal view returns (bytes32 domainSeperator) {\r\n        domainSeperator = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n    \r\n    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {\r\n        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator();\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\r\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\r\n    }\r\n    \r\n    function approve(address spender, uint256 tokenId) external {\r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_APPROVED\");\r\n        \r\n        getApproved[tokenId] = spender;\r\n        \r\n        emit Approval(owner, spender, tokenId); \r\n    }\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        \r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n    \r\n    function transfer(address to, uint256 tokenId) external {\r\n        require(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\r\n        \r\n        // This is safe because ownership is checked\r\n        // against decrement, and sum of all user\r\n        // balances can't exceed type(uint256).max!\r\n        unchecked {\r\n            balanceOf[msg.sender]--; \r\n        \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        emit Transfer(msg.sender, to, tokenId); \r\n    }\r\n\r\n    function transferFrom(address, address to, uint256 tokenId) public {\r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(\r\n            msg.sender == owner \r\n            || msg.sender == getApproved[tokenId]\r\n            || isApprovedForAll[owner][msg.sender], \r\n            \"NOT_APPROVED\"\r\n        );\r\n        \r\n        // This is safe because ownership is checked\r\n        // against decrement, and sum of all user\r\n        // balances can't exceed type(uint256).max!\r\n        unchecked { \r\n            balanceOf[owner]--; \r\n        \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        emit Transfer(owner, to, tokenId); \r\n    }\r\n    \r\n    function safeTransferFrom(address, address to, uint256 tokenId) external {\r\n        safeTransferFrom(address(0), to, tokenId, \"\");\r\n    }\r\n    \r\n    function safeTransferFrom(address, address to, uint256 tokenId, bytes memory data) public {\r\n        transferFrom(address(0), to, tokenId); \r\n        \r\n        if (to.code.length != 0) {\r\n            // selector = `onERC721Received(address,address,uint,bytes)`\r\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\r\n                msg.sender, address(0), tokenId, data));\r\n                \r\n            bytes4 selector = abi.decode(returned, (bytes4));\r\n            \r\n            require(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\r\n        }\r\n    }\r\n    \r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n        \r\n        address owner = ownerOf[tokenId];\r\n        // This is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits!\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress != address(0) \r\n                    && recoveredAddress == owner\r\n                    || isApprovedForAll[owner][recoveredAddress], \r\n                    \"INVALID_PERMIT_SIGNATURE\"\r\n            );\r\n        }\r\n        \r\n        getApproved[tokenId] = spender;\r\n\r\n        emit Approval(owner, spender, tokenId);\r\n    }\r\n    \r\n    function permitAll(\r\n        address owner,\r\n        address operator,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n        \r\n        // This is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits!\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress != address(0) \r\n                    && recoveredAddress == owner\r\n                    || isApprovedForAll[owner][recoveredAddress], \r\n                    \"INVALID_PERMIT_SIGNATURE\"\r\n            );\r\n        }\r\n        \r\n        isApprovedForAll[owner][operator] = true;\r\n\r\n        emit ApprovalForAll(owner, operator, true);\r\n    }\r\n    \r\n    function mint(address to, uint256 tokenId, string memory _tokenURI) external { \r\n        require(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\r\n  \r\n        // This is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits,\r\n        // and because the sum of all user balances can't exceed type(uint256).max!\r\n        unchecked {\r\n            totalSupply++;\r\n            \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        tokenURI[tokenId] = _tokenURI;\r\n        \r\n        emit Transfer(address(0), to, tokenId); \r\n    }\r\n    \r\n    function burn(uint256 tokenId) external { \r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(ownerOf[tokenId] != address(0), \"NOT_MINTED\");\r\n        \r\n        // This is safe because a user won't ever\r\n        // have a balance larger than totalSupply!\r\n        unchecked {\r\n            totalSupply--;\r\n        \r\n            balanceOf[owner]--;\r\n        }\r\n        \r\n        delete ownerOf[tokenId];\r\n        \r\n        delete tokenURI[tokenId];\r\n        \r\n        emit Transfer(owner, address(0), tokenId); \r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainSeperator\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_ALL_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noncesForAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permitAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OpenNFT","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000074f70656e4e46540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044f4e465400000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2ad4ba6e536232251106ce42153a2b4e3182dda6ea68210c923d3b882c99e77e"}]}