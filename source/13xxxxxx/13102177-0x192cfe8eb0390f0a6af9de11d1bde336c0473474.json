{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Users/zheli/Desktop/work/SmartContracts/CrossChainSwap/contracts/SwapContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./libraries/ECDSAOffsetRecovery.sol\\\";\\nimport \\\"./libraries/FullMath.sol\\\";\\n\\n/// @title Swap contract for multisignature bridge\\ncontract SwapContract is AccessControl, Pausable, ECDSAOffsetRecovery {\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n    bytes32 public constant RELAYER_ROLE = keccak256(\\\"RELAYER_ROLE\\\");\\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\\\"VALIDATOR_ROLE\\\");\\n\\n    uint128 public immutable numOfThisBlockchain;\\n    IUniswapV2Router02 public blockchainRouter;\\n    address public blockchainPool;\\n    address public blockchainFeeAddress;\\n    mapping(uint256 => address) public RubicAddresses;\\n    mapping(uint256 => bool) public existingOtherBlockchain;\\n    mapping(uint256 => uint256) public feeAmountOfBlockchain;\\n    mapping(uint256 => uint256) public blockchainCryptoFee;\\n\\n    uint256 public constant SIGNATURE_LENGTH = 65;\\n\\n    struct processedTx {\\n        uint256 statusCode;\\n        bytes32 hashedParams;\\n    }\\n\\n    mapping(bytes32 => processedTx) public processedTransactions;\\n    uint256 public minConfirmationSignatures = 3;\\n\\n    uint256 public minTokenAmount;\\n    uint256 public maxTokenAmount;\\n    uint256 public maxGasPrice;\\n    uint256 public minConfirmationBlocks;\\n    uint256 public refundSlippage;\\n\\n    // emitted every time when user gets crypto or tokens after success crossChainSwap\\n    event TransferFromOtherBlockchain(\\n        address user,\\n        uint256 amount,\\n        uint256 amountWithoutFee,\\n        bytes32 originalTxHash\\n    );\\n    // emitted every time when user get a refund\\n    event userRefunded(\\n        address user,\\n        uint256 amount,\\n        uint256 amountWithoutFee,\\n        bytes32 originalTxHash\\n    );\\n    // emitted if the recipient should receive crypto in the target blockchain\\n    event TransferCryptoToOtherBlockchainUser(\\n        uint256 blockchain,\\n        address sender,\\n        uint256 RBCAmountIn,\\n        uint256 amountSpent,\\n        string newAddress,\\n        uint256 cryptoOutMin,\\n        address[] path\\n    );\\n    // emitted if the recipient should receive tokens in the target blockchain\\n    event TransferTokensToOtherBlockchainUser(\\n        uint256 blockchain,\\n        address sender,\\n        uint256 RBCAmountIn,\\n        uint256 amountSpent,\\n        string newAddress,\\n        uint256 tokenOutMin,\\n        address[] path\\n    );\\n\\n    /**\\n     * @param blockchain Number of blockchain\\n     * @param tokenInAmount Maximum amount of a token being sold\\n     * @param firstPath Path used for swapping tokens to *RBC (tokenIn address,.., *RBC addres)\\n     * @param secondPath Path used for swapping *RBC to tokenOut (*RBC address,.., tokenOut address)\\n     * @param exactRBCtokenOut Exact amount of RBC to get after first swap\\n     * @param tokenOutMin Minimal amount of tokens (or crypto) to get after second swap\\n     * @param newAddress Address in the blockchain to which the user wants to transfer\\n     * @param swapToCrypto This must be _true_ if swapping tokens to desired blockchain's crypto\\n     */\\n    struct swapToParams {\\n        uint256 blockchain;\\n        uint256 tokenInAmount;\\n        address[] firstPath;\\n        address[] secondPath;\\n        uint256 exactRBCtokenOut;\\n        uint256 tokenOutMin;\\n        string newAddress;\\n        bool swapToCrypto;\\n    }\\n\\n    /**\\n     * @param user User address // \\\"newAddress\\\" from event\\n     * @param amountWithFee Amount of tokens with included fees to transfer from the pool // \\\"RBCAmountIn\\\" from event\\n     * @param amountOutMin Minimal amount of tokens to get after second swap // \\\"tokenOutMin\\\" from event\\n     * @param path Path used for a second swap // \\\"secondPath\\\" from event\\n     * @param originalTxHash Hash of transaction from other network, on which swap was called\\n     * @param concatSignatures Concatenated string of signature bytes for verification of transaction\\n     */\\n    struct swapFromParams {\\n        address user;\\n        uint256 amountWithFee;\\n        uint256 amountOutMin;\\n        address[] path;\\n        bytes32 originalTxHash;\\n        bytes concatSignatures;\\n    }\\n\\n    /**\\n     * @dev throws if transaction sender is not in owner role\\n     */\\n    modifier onlyOwner() {\\n        require(\\n            hasRole(OWNER_ROLE, _msgSender()),\\n            \\\"Caller is not in owner role\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev throws if transaction sender is not in owner or manager role\\n     */\\n    modifier onlyOwnerAndManager() {\\n        require(\\n            hasRole(OWNER_ROLE, _msgSender()) ||\\n                hasRole(MANAGER_ROLE, _msgSender()),\\n            \\\"Caller is not in owner or manager role\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev throws if transaction sender is not in relayer role\\n     */\\n    modifier onlyRelayer() {\\n        require(\\n            hasRole(RELAYER_ROLE, _msgSender()),\\n            \\\"swapContract: Caller is not in relayer role\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Performs check before swap*ToOtherBlockchain-functions and emits events\\n     * @param params The swapToParams structure\\n     * @param value The msg.value\\n     */\\n    modifier TransferTo(swapToParams memory params, uint256 value) {\\n        require(\\n            bytes(params.newAddress).length > 0,\\n            \\\"swapContract: No destination address provided\\\"\\n        );\\n        require(\\n            existingOtherBlockchain[params.blockchain] &&\\n                params.blockchain != numOfThisBlockchain,\\n            \\\"swapContract: Wrong choose of blockchain\\\"\\n        );\\n        require(\\n            params.firstPath.length > 0,\\n            \\\"swapContract: firsPath length must be greater than 1\\\"\\n        );\\n        require(\\n            params.secondPath.length > 0,\\n            \\\"swapContract: secondPath length must be greater than 1\\\"\\n        );\\n        require(\\n            params.firstPath[params.firstPath.length - 1] ==\\n                RubicAddresses[numOfThisBlockchain],\\n            \\\"swapContract: the last address in the firstPath must be Rubic\\\"\\n        );\\n        require(\\n            params.secondPath[0] == RubicAddresses[params.blockchain],\\n            \\\"swapContract: the first address in the secondPath must be Rubic\\\"\\n        );\\n        require(\\n            params.exactRBCtokenOut >= minTokenAmount,\\n            \\\"swapContract: Not enough amount of tokens\\\"\\n        );\\n        require(\\n            params.exactRBCtokenOut < maxTokenAmount,\\n            \\\"swapContract: Too many RBC requested\\\"\\n        );\\n        require(\\n            value >= blockchainCryptoFee[params.blockchain],\\n            \\\"swapContract: Not enough crypto provided\\\"\\n        );\\n        _;\\n        if (params.swapToCrypto) {\\n            emit TransferCryptoToOtherBlockchainUser(\\n                params.blockchain,\\n                _msgSender(),\\n                params.exactRBCtokenOut,\\n                params.tokenInAmount,\\n                params.newAddress,\\n                params.tokenOutMin,\\n                params.secondPath\\n            );\\n        } else {\\n            emit TransferTokensToOtherBlockchainUser(\\n                params.blockchain,\\n                _msgSender(),\\n                params.exactRBCtokenOut,\\n                params.tokenInAmount,\\n                params.newAddress,\\n                params.tokenOutMin,\\n                params.secondPath\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs check before swap*ToUser-functions\\n     * @param params The swapFromParams structure\\n     */\\n    modifier TransferFrom(swapFromParams memory params) {\\n        require(\\n            params.amountWithFee >= minTokenAmount,\\n            \\\"swapContract: Not enough amount of tokens\\\"\\n        );\\n        require(\\n            params.amountWithFee < maxTokenAmount,\\n            \\\"swapContract: Too many RBC requested\\\"\\n        );\\n        require(\\n            params.path.length > 0,\\n            \\\"swapContract: path length must be greater than 1\\\"\\n        );\\n        require(\\n            params.path[0] == RubicAddresses[numOfThisBlockchain],\\n            \\\"swapContract: the first address in the path must be Rubic\\\"\\n        );\\n        require(\\n            params.user != address(0),\\n            \\\"swapContract: Address cannot be zero address\\\"\\n        );\\n        require(\\n            params.concatSignatures.length % SIGNATURE_LENGTH == 0,\\n            \\\"swapContract: Signatures lengths must be divisible by 65\\\"\\n        );\\n        require(\\n            params.concatSignatures.length / SIGNATURE_LENGTH >=\\n                minConfirmationSignatures,\\n            \\\"swapContract: Not enough signatures passed\\\"\\n        );\\n\\n        _processTransaction(\\n            params.user,\\n            params.amountWithFee,\\n            params.originalTxHash,\\n            params.concatSignatures\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructor of contract\\n     * @param _numOfThisBlockchain Number of blockchain where contract is deployed\\n     * @param _numsOfOtherBlockchains List of blockchain number that is supported by bridge\\n     * @param tokenLimits A list where 0 element is minTokenAmount and 1 is maxTokenAmount\\n     * @param _maxGasPrice Maximum gas price on which relayer nodes will operate\\n     * @param _minConfirmationBlocks Minimal amount of blocks for confirmation on validator nodes\\n     * @param _refundSlippage Slippage represented as hundredths of a bip, i.e. 1e-6 that will be used on refund\\n     * @param _RubicAddresses Addresses of Rubic in different blockchains\\n     */\\n    constructor(\\n        uint128 _numOfThisBlockchain,\\n        uint128[] memory _numsOfOtherBlockchains,\\n        uint256[] memory tokenLimits,\\n        uint256 _maxGasPrice,\\n        uint256 _minConfirmationBlocks,\\n        uint256 _refundSlippage,\\n        IUniswapV2Router02 _blockchainRouter,\\n        address[] memory _RubicAddresses\\n    ) {\\n//        for (uint256 i = 0; i < _numsOfOtherBlockchains.length; i++) {\\n//            require(\\n//                _numsOfOtherBlockchains[i] != _numOfThisBlockchain,\\n//                \\\"swapContract: Number of this blockchain is in array of other blockchains\\\"\\n//            );\\n//            existingOtherBlockchain[_numsOfOtherBlockchains[i]] = true;\\n//        }\\n//\\n//        for (uint256 i = 0; i < _RubicAddresses.length; i++) {\\n//            RubicAddresses[i + 1] = _RubicAddresses[i];\\n//        }\\n\\n        require(_maxGasPrice > 0, \\\"swapContract: Gas price cannot be zero\\\");\\n\\n        numOfThisBlockchain = _numOfThisBlockchain;\\n        minTokenAmount = tokenLimits[0];\\n        maxTokenAmount = tokenLimits[1];\\n        maxGasPrice = _maxGasPrice;\\n        refundSlippage = _refundSlippage;\\n        minConfirmationBlocks = _minConfirmationBlocks;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OWNER_ROLE, _msgSender());\\n        blockchainRouter = _blockchainRouter;\\n\\n//        require(\\n//            IERC20(RubicAddresses[_numOfThisBlockchain]).approve(\\n//                address(blockchainRouter),\\n//                type(uint256).max\\n//            ),\\n//            \\\"swapContract: approve to Swap failed\\\"\\n//        );\\n    }\\n\\n    /**\\n     * @dev Returns true if blockchain of passed id is registered to swap\\n     * @param blockchain number of blockchain\\n     */\\n    function getOtherBlockchainAvailableByNum(uint256 blockchain)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return existingOtherBlockchain[blockchain];\\n    }\\n\\n    function _processTransaction(\\n        address user,\\n        uint256 amountWithFee,\\n        bytes32 originalTxHash,\\n        bytes memory concatSignatures\\n    ) private {\\n        bytes32 hashedParams = getHashPacked(\\n            user,\\n            amountWithFee,\\n            originalTxHash\\n        );\\n        uint256 statusCode = processedTransactions[originalTxHash].statusCode;\\n        bytes32 savedHash = processedTransactions[originalTxHash].hashedParams;\\n        require(\\n            statusCode == 0 && savedHash != hashedParams,\\n            \\\"swapContract: Transaction already processed\\\"\\n        );\\n\\n        uint256 signaturesCount = concatSignatures.length /\\n            uint256(SIGNATURE_LENGTH);\\n        address[] memory validatorAddresses = new address[](signaturesCount);\\n        for (uint256 i = 0; i < signaturesCount; i++) {\\n            address validatorAddress = ecOffsetRecover(\\n                hashedParams,\\n                concatSignatures,\\n                i * SIGNATURE_LENGTH\\n            );\\n            require(\\n                isValidator(validatorAddress),\\n                \\\"swapContract: Validator address not in whitelist\\\"\\n            );\\n            for (uint256 j = 0; j < i; j++) {\\n                require(\\n                    validatorAddress != validatorAddresses[j],\\n                    \\\"swapContract: Validator address is duplicated\\\"\\n                );\\n            }\\n            validatorAddresses[i] = validatorAddress;\\n        }\\n        processedTransactions[originalTxHash].hashedParams = hashedParams;\\n        processedTransactions[originalTxHash].statusCode = 1;\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from sender to the contract.\\n     * User calls this function when he wants to transfer tokens to another blockchain.\\n     * @notice User must have approved tokenInAmount of tokenIn\\n     */\\n    function swapTokensToOtherBlockchain(swapToParams memory params)\\n        external\\n        payable\\n        whenNotPaused\\n        TransferTo(params, msg.value)\\n    {\\n        IERC20 tokenIn = IERC20(params.firstPath[0]);\\n        if (params.firstPath.length > 1) {\\n            require(\\n                tokenIn.transferFrom(\\n                    msg.sender,\\n                    address(this),\\n                    params.tokenInAmount\\n                ),\\n                \\\"swapContract: Transfer tokens from sender failed\\\"\\n            );\\n            require(\\n                tokenIn.approve(\\n                    address(blockchainRouter),\\n                    params.tokenInAmount\\n                ),\\n                \\\"swapContract: tokeinIn approve failed.\\\"\\n            );\\n            uint256[] memory amounts = blockchainRouter\\n                .swapTokensForExactTokens(\\n                    params.exactRBCtokenOut,\\n                    params.tokenInAmount,\\n                    params.firstPath,\\n                    blockchainPool,\\n                    block.timestamp\\n                );\\n            tokenIn.transfer(_msgSender(), params.tokenInAmount - amounts[0]);\\n            params.tokenInAmount = amounts[0];\\n        } else {\\n            require(\\n                tokenIn.transferFrom(\\n                    msg.sender,\\n                    blockchainPool,\\n                    params.exactRBCtokenOut\\n                ),\\n                \\\"swapContract: Transfer tokens from sender failed\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from sender to the contract.\\n     * User calls this function when he wants to transfer tokens to another blockchain.\\n     * @notice User must have approved tokenInAmount of tokenIn\\n     */\\n    function swapCryptoToOtherBlockchain(swapToParams memory params)\\n        external\\n        payable\\n        whenNotPaused\\n        TransferTo(params, msg.value)\\n    {\\n        uint256 cryptoWithoutFee = msg.value -\\n            blockchainCryptoFee[params.blockchain];\\n        uint256[] memory amounts = blockchainRouter.swapETHForExactTokens{\\n            value: cryptoWithoutFee\\n        }(\\n            params.exactRBCtokenOut,\\n            params.firstPath,\\n            blockchainPool,\\n            block.timestamp\\n        );\\n        params.tokenInAmount = amounts[0];\\n        bool success = payable(_msgSender()).send(\\n            cryptoWithoutFee - amounts[0]\\n        );\\n        require(success, \\\"swapContract: crypto transfer back to caller failed\\\");\\n    }\\n\\n    /**\\n     * @dev Transfers tokens to end user in current blockchain\\n     */\\n    function swapTokensToUserWithFee(swapFromParams memory params)\\n        external\\n        onlyRelayer\\n        whenNotPaused\\n        TransferFrom(params)\\n    {\\n        uint256 amountWithoutFee = FullMath.mulDiv(\\n            params.amountWithFee,\\n            1e6 - feeAmountOfBlockchain[numOfThisBlockchain],\\n            1e6\\n        );\\n\\n        IERC20 RBCToken = IERC20(params.path[0]);\\n\\n        if (params.path.length == 1) {\\n            require(\\n                RBCToken.transferFrom(\\n                    blockchainPool,\\n                    params.user,\\n                    amountWithoutFee\\n                ),\\n                \\\"swapContract: transfer from pool failed\\\"\\n            );\\n            require(\\n                RBCToken.transferFrom(\\n                    blockchainPool,\\n                    blockchainFeeAddress,\\n                    params.amountWithFee - amountWithoutFee\\n                ),\\n                \\\"swapContract: fee transfer failed\\\"\\n            );\\n        } else {\\n            require(\\n                RBCToken.transferFrom(\\n                    blockchainPool,\\n                    address(this),\\n                    amountWithoutFee\\n                ),\\n                \\\"swapContract: transfer from pool failed\\\"\\n            );\\n            require(\\n                RBCToken.transferFrom(\\n                    blockchainPool,\\n                    blockchainFeeAddress,\\n                    params.amountWithFee - amountWithoutFee\\n                ),\\n                \\\"swapContract: fee transfer failed\\\"\\n            );\\n            blockchainRouter.swapExactTokensForTokens(\\n                amountWithoutFee,\\n                params.amountOutMin,\\n                params.path,\\n                params.user,\\n                block.timestamp\\n            );\\n        }\\n        emit TransferFromOtherBlockchain(\\n            params.user,\\n            params.amountWithFee,\\n            amountWithoutFee,\\n            params.originalTxHash\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers tokens to end user in current blockchain\\n     */\\n    function swapCryptoToUserWithFee(swapFromParams memory params)\\n        external\\n        onlyRelayer\\n        whenNotPaused\\n        TransferFrom(params)\\n    {\\n        uint256 amountWithoutFee = FullMath.mulDiv(\\n            params.amountWithFee,\\n            1e6 - feeAmountOfBlockchain[numOfThisBlockchain],\\n            1e6\\n        );\\n\\n        IERC20 RBCToken = IERC20(params.path[0]);\\n        require(\\n            RBCToken.transferFrom(\\n                blockchainPool,\\n                address(this),\\n                amountWithoutFee\\n            ),\\n            \\\"swapContract: transfer from pool failed\\\"\\n        );\\n        require(\\n            RBCToken.transferFrom(\\n                blockchainPool,\\n                blockchainFeeAddress,\\n                params.amountWithFee - amountWithoutFee\\n            ),\\n            \\\"swapContract: fee transfer failed\\\"\\n        );\\n        blockchainRouter.swapExactTokensForETH(\\n            amountWithoutFee,\\n            params.amountOutMin,\\n            params.path,\\n            params.user,\\n            block.timestamp\\n        );\\n        emit TransferFromOtherBlockchain(\\n            params.user,\\n            params.amountWithFee,\\n            amountWithoutFee,\\n            params.originalTxHash\\n        );\\n    }\\n\\n    /**\\n     * @dev Swaps RBC from pool to initially spent by user tokens and transfers him\\n     * @notice There is used the same structure as in other similar functions but amountOutMin should be\\n     * equal to the amount of tokens initially spent by user (we are refunding them), AmountWithFee should\\n     * be equal to the amount of RBC tokens that the pool got after the first swap (RBCAmountIn in the event)\\n     * hashedParams of this originalTxHash\\n     */\\n    function refundTokensToUser(swapFromParams memory params)\\n        external\\n        onlyRelayer\\n        whenNotPaused\\n        TransferFrom(params)\\n    {\\n        IERC20 RBCToken = IERC20(params.path[0]);\\n\\n        if (params.path.length == 1) {\\n            require(\\n                RBCToken.transferFrom(\\n                    blockchainPool,\\n                    params.user,\\n                    params.amountOutMin\\n                ),\\n                \\\"swapContract: transfer from pool failed\\\"\\n            );\\n            emit userRefunded(\\n                params.user,\\n                params.amountOutMin,\\n                params.amountOutMin,\\n                params.originalTxHash\\n            );\\n        } else {\\n            uint256 amountIn = FullMath.mulDiv(\\n                params.amountWithFee,\\n                1e6 + refundSlippage,\\n                1e6\\n            );\\n\\n            require(\\n                RBCToken.transferFrom(blockchainPool, address(this), amountIn),\\n                \\\"swapContract: transfer from pool failed\\\"\\n            );\\n\\n            uint256 RBCSpent = blockchainRouter.swapTokensForExactTokens(\\n                params.amountOutMin,\\n                amountIn,\\n                params.path,\\n                params.user,\\n                block.timestamp\\n            )[0];\\n\\n            require(\\n                RBCToken.transfer(blockchainPool, amountIn - RBCSpent),\\n                \\\"swapContract: remaining RBC transfer to pool failed\\\"\\n            );\\n            emit userRefunded(\\n                params.user,\\n                RBCSpent,\\n                RBCSpent,\\n                params.originalTxHash\\n            );\\n        }\\n    }\\n\\n    function refundCryptoToUser(swapFromParams memory params)\\n        external\\n        onlyRelayer\\n        whenNotPaused\\n        TransferFrom(params)\\n    {\\n        IERC20 RBCToken = IERC20(params.path[0]);\\n\\n        uint256 amountIn = FullMath.mulDiv(\\n            params.amountWithFee,\\n            1e6 + refundSlippage,\\n            1e6\\n        );\\n\\n        require(\\n            RBCToken.transferFrom(blockchainPool, address(this), amountIn),\\n            \\\"swapContract: transfer from pool failed\\\"\\n        );\\n\\n        uint256 RBCSpent = blockchainRouter.swapTokensForExactETH(\\n            params.amountOutMin,\\n            amountIn,\\n            params.path,\\n            params.user,\\n            block.timestamp\\n        )[0];\\n\\n        require(\\n            RBCToken.transfer(blockchainPool, amountIn - RBCSpent),\\n            \\\"swapContract: remaining RBC transfer to pool failed\\\"\\n        );\\n        emit userRefunded(\\n            params.user,\\n            RBCSpent,\\n            RBCSpent,\\n            params.originalTxHash\\n        );\\n    }\\n\\n    // OTHER BLOCKCHAIN MANAGEMENT\\n    /**\\n     * @dev Registers another blockchain for availability to swap\\n     * @param numOfOtherBlockchain number of blockchain\\n     */\\n    function addOtherBlockchain(uint128 numOfOtherBlockchain)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            numOfOtherBlockchain != numOfThisBlockchain,\\n            \\\"swapContract: Cannot add this blockchain to array of other blockchains\\\"\\n        );\\n        require(\\n            !existingOtherBlockchain[numOfOtherBlockchain],\\n            \\\"swapContract: This blockchain is already added\\\"\\n        );\\n        existingOtherBlockchain[numOfOtherBlockchain] = true;\\n    }\\n\\n    /**\\n     * @dev Unregisters another blockchain for availability to swap\\n     * @param numOfOtherBlockchain number of blockchain\\n     */\\n    function removeOtherBlockchain(uint128 numOfOtherBlockchain)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            existingOtherBlockchain[numOfOtherBlockchain],\\n            \\\"swapContract: This blockchain was not added\\\"\\n        );\\n        existingOtherBlockchain[numOfOtherBlockchain] = false;\\n    }\\n\\n    /**\\n     * @dev Change existing blockchain id\\n     * @param oldNumOfOtherBlockchain number of existing blockchain\\n     * @param newNumOfOtherBlockchain number of new blockchain\\n     */\\n    function changeOtherBlockchain(\\n        uint128 oldNumOfOtherBlockchain,\\n        uint128 newNumOfOtherBlockchain\\n    ) external onlyOwner {\\n        require(\\n            oldNumOfOtherBlockchain != newNumOfOtherBlockchain,\\n            \\\"swapContract: Cannot change blockchains with same number\\\"\\n        );\\n        require(\\n            newNumOfOtherBlockchain != numOfThisBlockchain,\\n            \\\"swapContract: Cannot add this blockchain to array of other blockchains\\\"\\n        );\\n        require(\\n            existingOtherBlockchain[oldNumOfOtherBlockchain],\\n            \\\"swapContract: This blockchain was not added\\\"\\n        );\\n        require(\\n            !existingOtherBlockchain[newNumOfOtherBlockchain],\\n            \\\"swapContract: This blockchain is already added\\\"\\n        );\\n\\n        existingOtherBlockchain[oldNumOfOtherBlockchain] = false;\\n        existingOtherBlockchain[newNumOfOtherBlockchain] = true;\\n    }\\n\\n    /**\\n     * @dev Changes/Set Router address\\n     * @param _router the new Router address\\n     */\\n\\n    function setRouter(IUniswapV2Router02 _router)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        blockchainRouter = _router;\\n    }\\n\\n    /**\\n     * @dev Changes/Set Pool address\\n     * @param _poolAddress the new Pool address\\n     */\\n\\n    function setPoolAddress(address _poolAddress) external onlyOwnerAndManager {\\n        blockchainPool = _poolAddress;\\n    }\\n\\n    // FEE MANAGEMENT\\n\\n    /**\\n     * @dev Sends collected crypto fee to the owner\\n     */\\n\\n    function collectCryptoFee() external onlyOwner {\\n        bool success = payable(msg.sender).send(address(this).balance);\\n        require(success, \\\"swapContract: fail collecting fee\\\");\\n    }\\n\\n    /**\\n     * @dev Changes address which receives fees from transfers\\n     * @param newFeeAddress New address for fees\\n     */\\n    function setFeeAddress(address newFeeAddress) external onlyOwnerAndManager {\\n        blockchainFeeAddress = newFeeAddress;\\n    }\\n\\n    /**\\n     * @dev Changes fee values for blockchains in feeAmountOfBlockchain variables\\n     * @notice fee is represented as hundredths of a bip, i.e. 1e-6\\n     * @param _blockchainNum Existing number of blockchain\\n     * @param feeAmount Fee amount to substruct from transfer amount\\n     */\\n    function setFeeAmountOfBlockchain(uint128 _blockchainNum, uint256 feeAmount)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        feeAmountOfBlockchain[_blockchainNum] = feeAmount;\\n    }\\n\\n    /**\\n     * @dev Changes crypto fee values for blockchains in blockchainCryptoFee variables\\n     * @param _blockchainNum Existing number of blockchain\\n     * @param feeAmount Fee amount that must be sent calling transferToOtherBlockchain\\n     */\\n    function setCryptoFeeOfBlockchain(uint128 _blockchainNum, uint256 feeAmount)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        blockchainCryptoFee[_blockchainNum] = feeAmount;\\n    }\\n\\n    /**\\n     * @dev Changes the address of Rubic in the certain blockchain\\n     * @param _blockchainNum Existing number of blockchain\\n     * @param _RubicAddress The Rubic address\\n     */\\n    function setRubicAddressOfBlockchain(\\n        uint128 _blockchainNum,\\n        address _RubicAddress\\n    ) external onlyOwnerAndManager {\\n        RubicAddresses[_blockchainNum] = _RubicAddress;\\n        if (_blockchainNum == numOfThisBlockchain){\\n            require(\\n                IERC20(_RubicAddress).approve(\\n                    address(blockchainRouter),\\n                    type(uint256).max\\n                ),\\n                \\\"swapContract: approve to Swap failed\\\"\\n            );\\n        }\\n    }\\n\\n    // VALIDATOR CONFIRMATIONS MANAGEMENT\\n\\n    /**\\n     * @dev Changes requirement for minimal amount of signatures to validate on transfer\\n     * @param _minConfirmationSignatures Number of signatures to verify\\n     */\\n    function setMinConfirmationSignatures(uint256 _minConfirmationSignatures)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _minConfirmationSignatures > 0,\\n            \\\"swapContract: At least 1 confirmation can be set\\\"\\n        );\\n        minConfirmationSignatures = _minConfirmationSignatures;\\n    }\\n\\n    /**\\n     * @dev Changes requirement for minimal token amount on transfers\\n     * @param _minTokenAmount Amount of tokens\\n     */\\n    function setMinTokenAmount(uint256 _minTokenAmount)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        minTokenAmount = _minTokenAmount;\\n    }\\n\\n    /**\\n     * @dev Changes requirement for maximum token amount on transfers\\n     * @param _maxTokenAmount Amount of tokens\\n     */\\n    function setMaxTokenAmount(uint256 _maxTokenAmount)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        maxTokenAmount = _maxTokenAmount;\\n    }\\n\\n    /**\\n     * @dev Changes parameter of maximum gas price on which relayer nodes will operate\\n     * @param _maxGasPrice Price of gas in wei\\n     */\\n    function setMaxGasPrice(uint256 _maxGasPrice) external onlyOwnerAndManager {\\n        require(_maxGasPrice > 0, \\\"swapContract: Gas price cannot be zero\\\");\\n        maxGasPrice = _maxGasPrice;\\n    }\\n\\n    /**\\n     * @dev Changes requirement for minimal amount of block to consider tx confirmed on validator\\n     * @param _minConfirmationBlocks Amount of blocks\\n     */\\n\\n    function setMinConfirmationBlocks(uint256 _minConfirmationBlocks)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        minConfirmationBlocks = _minConfirmationBlocks;\\n    }\\n\\n    function setRefundSlippage(uint256 _refundSlippage)\\n        external\\n        onlyOwnerAndManager\\n    {\\n        refundSlippage = _refundSlippage;\\n    }\\n\\n    /**\\n     * @dev Transfers permissions of contract ownership.\\n     * Will setup new owner and one manager on contract.\\n     * Main purpose of this function is to transfer ownership from deployer account ot real owner\\n     * @param newOwner Address of new owner\\n     * @param newManager Address of new manager\\n     */\\n    function transferOwnerAndSetManager(address newOwner, address newManager)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            newOwner != _msgSender(),\\n            \\\"swapContract: New owner must be different than current\\\"\\n        );\\n        require(\\n            newOwner != address(0x0),\\n            \\\"swapContract: Owner cannot be zero address\\\"\\n        );\\n        require(\\n            newManager != address(0x0),\\n            \\\"swapContract: Owner cannot be zero address\\\"\\n        );\\n        _setupRole(DEFAULT_ADMIN_ROLE, newOwner);\\n        _setupRole(OWNER_ROLE, newOwner);\\n        _setupRole(MANAGER_ROLE, newManager);\\n        renounceRole(OWNER_ROLE, _msgSender());\\n        renounceRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Pauses transfers of tokens on contract\\n     */\\n    function pauseExecution() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Resumes transfers of tokens on contract\\n     */\\n    function continueExecution() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @dev Function to check if address is belongs to owner role\\n     * @param account Address to check\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return hasRole(OWNER_ROLE, account);\\n    }\\n\\n    /**\\n     * @dev Function to check if address is belongs to manager role\\n     * @param account Address to check\\n     */\\n    function isManager(address account) public view returns (bool) {\\n        return hasRole(MANAGER_ROLE, account);\\n    }\\n\\n    /**\\n     * @dev Function to check if address is belongs to relayer role\\n     * @param account Address to check\\n     */\\n    function isRelayer(address account) public view returns (bool) {\\n        return hasRole(RELAYER_ROLE, account);\\n    }\\n\\n    /**\\n     * @dev Function to check if address is belongs to validator role\\n     * @param account Address to check\\n     *\\n     */\\n    function isValidator(address account) public view returns (bool) {\\n        return hasRole(VALIDATOR_ROLE, account);\\n    }\\n\\n    /**\\n     * @dev Function changes values associated with certain originalTxHash\\n     * @param originalTxHash Transaction hash to change\\n     * @param statusCode Associated status: 0-Not processed, 1-Processed, 2-Reverted\\n     * @param hashedParams Hashed params with which the initial transaction was executed\\n     */\\n    function changeTxStatus(\\n        bytes32 originalTxHash,\\n        uint256 statusCode,\\n        bytes32 hashedParams\\n    ) external onlyRelayer {\\n        require(\\n            statusCode != 0,\\n            \\\"swapContract: you cannot set the statusCode to 0\\\"\\n        );\\n        require(\\n            processedTransactions[originalTxHash].statusCode != 1,\\n            \\\"swapContract: transaction with this originalTxHash has already been set as succeed\\\"\\n        );\\n        processedTransactions[originalTxHash].statusCode = statusCode;\\n        processedTransactions[originalTxHash].hashedParams = hashedParams;\\n    }\\n\\n    /**\\n     * @dev Plain fallback function to receive crypto\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"/C/Users/zheli/Desktop/work/SmartContracts/CrossChainSwap/contracts/libraries/ECDSAOffsetRecovery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ncontract ECDSAOffsetRecovery {\\n    function getHashPacked(\\n        address user,\\n        uint256 amountWithFee,\\n        bytes32 originalTxHash\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(user, amountWithFee, originalTxHash));\\n    }\\n\\n    function toEthSignedMessageHash(bytes32 hash)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n\\n    function ecOffsetRecover(\\n        bytes32 hash,\\n        bytes memory signature,\\n        uint256 offset\\n    ) public pure returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Divide the signature in r, s and v variables with inline assembly.\\n        assembly {\\n            r := mload(add(signature, add(offset, 0x20)))\\n            s := mload(add(signature, add(offset, 0x40)))\\n            v := byte(0, mload(add(signature, add(offset, 0x60))))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        // If the version is correct return the signer address\\n        if (v != 27 && v != 28) {\\n            return (address(0));\\n        }\\n\\n        // bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        // hash = keccak256(abi.encodePacked(prefix, hash));\\n        // solium-disable-next-line arg-overflow\\n        return ecrecover(toEthSignedMessageHash(hash), v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"/C/Users/zheli/Desktop/work/SmartContracts/CrossChainSwap/contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 440\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_numOfThisBlockchain\",\"type\":\"uint128\"},{\"internalType\":\"uint128[]\",\"name\":\"_numsOfOtherBlockchains\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenLimits\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minConfirmationBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refundSlippage\",\"type\":\"uint256\"},{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_blockchainRouter\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_RubicAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockchain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"RBCAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cryptoOutMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"TransferCryptoToOtherBlockchainUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithoutFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"}],\"name\":\"TransferFromOtherBlockchain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockchain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"RBCAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenOutMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"TransferTokensToOtherBlockchainUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithoutFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"}],\"name\":\"userRefunded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RubicAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNATURE_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"numOfOtherBlockchain\",\"type\":\"uint128\"}],\"name\":\"addOtherBlockchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockchainCryptoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockchainFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockchainPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockchainRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"oldNumOfOtherBlockchain\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"newNumOfOtherBlockchain\",\"type\":\"uint128\"}],\"name\":\"changeOtherBlockchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"statusCode\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hashedParams\",\"type\":\"bytes32\"}],\"name\":\"changeTxStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectCryptoFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"continueExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ecOffsetRecover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingOtherBlockchain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeAmountOfBlockchain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWithFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"}],\"name\":\"getHashPacked\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockchain\",\"type\":\"uint256\"}],\"name\":\"getOtherBlockchainAvailableByNum\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isRelayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minConfirmationBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minConfirmationSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfThisBlockchain\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"statusCode\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hashedParams\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWithFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"concatSignatures\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapContract.swapFromParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"refundCryptoToUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWithFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"concatSignatures\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapContract.swapFromParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"refundTokensToUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"numOfOtherBlockchain\",\"type\":\"uint128\"}],\"name\":\"removeOtherBlockchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_blockchainNum\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"setCryptoFeeOfBlockchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_blockchainNum\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"setFeeAmountOfBlockchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxGasPrice\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTokenAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minConfirmationBlocks\",\"type\":\"uint256\"}],\"name\":\"setMinConfirmationBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minConfirmationSignatures\",\"type\":\"uint256\"}],\"name\":\"setMinConfirmationSignatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokenAmount\",\"type\":\"uint256\"}],\"name\":\"setMinTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"setPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refundSlippage\",\"type\":\"uint256\"}],\"name\":\"setRefundSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_blockchainNum\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_RubicAddress\",\"type\":\"address\"}],\"name\":\"setRubicAddressOfBlockchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blockchain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"firstPath\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"secondPath\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"exactRBCtokenOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutMin\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newAddress\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swapToCrypto\",\"type\":\"bool\"}],\"internalType\":\"struct SwapContract.swapToParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapCryptoToOtherBlockchain\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWithFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"concatSignatures\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapContract.swapFromParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapCryptoToUserWithFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blockchain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"firstPath\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"secondPath\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"exactRBCtokenOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutMin\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newAddress\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"swapToCrypto\",\"type\":\"bool\"}],\"internalType\":\"struct SwapContract.swapToParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapTokensToOtherBlockchain\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWithFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"originalTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"concatSignatures\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapContract.swapFromParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapTokensToUserWithFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"toEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferOwnerAndSetManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SwapContract","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"440","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000022ecb25c00000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000027100000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}