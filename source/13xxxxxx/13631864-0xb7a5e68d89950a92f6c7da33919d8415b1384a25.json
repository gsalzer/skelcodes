{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PalPool.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./utils/SafeERC20.sol\\\";\\nimport \\\"./utils/Clones.sol\\\";\\nimport \\\"./IPalPool.sol\\\";\\nimport \\\"./PalPoolStorage.sol\\\";\\nimport \\\"./IPalLoan.sol\\\";\\n//import \\\"./PalLoan.sol\\\";\\nimport \\\"./IPalToken.sol\\\";\\nimport \\\"./IPaladinController.sol\\\";\\nimport \\\"./IPalLoanToken.sol\\\";\\nimport \\\"./interests/InterestInterface.sol\\\";\\nimport \\\"./utils/IERC20.sol\\\";\\nimport \\\"./utils/Admin.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport {Errors} from  \\\"./utils/Errors.sol\\\";\\n\\n\\n\\n/** @title PalPool contract  */\\n/// @author Paladin\\ncontract PalPool is IPalPool, PalPoolStorage, Admin, ReentrancyGuard {\\n    using SafeMath for uint;\\n    using SafeERC20 for IERC20;\\n\\n\\n    modifier controllerOnly() {\\n        //allows only the Controller and the admin to call the function\\n        require(msg.sender == admin || msg.sender == address(controller), Errors.CALLER_NOT_CONTROLLER);\\n        _;\\n    }\\n\\n\\n\\n    //Functions\\n\\n    constructor(\\n        address _palToken,\\n        address _controller, \\n        address _underlying,\\n        address _interestModule,\\n        address _delegator,\\n        address _palLoanToken\\n    ){\\n        //Set admin\\n        admin = msg.sender;\\n\\n        //Set inital values & modules\\n        palToken = IPalToken(_palToken);\\n        controller = IPaladinController(_controller);\\n        underlying = IERC20(_underlying);\\n        accrualBlockNumber = block.number;\\n        interestModule = InterestInterface(_interestModule);\\n        borrowIndex = 1e18;\\n        delegator = _delegator;\\n        palLoanToken = IPalLoanToken(_palLoanToken);\\n    }\\n\\n    /**\\n    * @notice Get the underlying balance for this Pool\\n    * @dev Get the underlying balance of this Pool\\n    * @return uint : balance of this pool in the underlying token\\n    */\\n    function underlyingBalance() public view returns(uint){\\n        //Return the balance of this contract for the underlying asset\\n        return underlying.balanceOf(address(this));\\n    }\\n\\n    /**\\n    * @notice Deposit underlying in the Pool\\n    * @dev Deposit underlying, and mints palToken for the user\\n    * @param _amount Amount of underlying to deposit\\n    * @return bool : amount of minted palTokens\\n    */\\n    function deposit(uint _amount) public virtual override nonReentrant returns(uint){\\n        require(_updateInterest());\\n\\n        //Retrieve the current exchange rate palToken:underlying\\n        uint _exchRate = _exchangeRate();\\n\\n\\n        //Find the amount to mint depending on the amount to transfer\\n        uint _num = _amount.mul(mantissaScale);\\n        uint _toMint = _num.div(_exchRate);\\n\\n        //Transfer the underlying to this contract\\n        //The amount of underlying needs to be approved before\\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        //Mint the palToken\\n        require(palToken.mint(msg.sender, _toMint), Errors.FAIL_MINT);\\n\\n        //Emit the Deposit event\\n        emit Deposit(msg.sender, _amount, address(this));\\n\\n        //Use the controller to check if the minting was successfull\\n        require(controller.depositVerify(address(this), msg.sender, _toMint), Errors.FAIL_DEPOSIT);\\n\\n        return _toMint;\\n    }\\n\\n    /**\\n    * @notice Withdraw underliyng token from the Pool\\n    * @dev Transfer underlying token to the user, and burn the corresponding palToken amount\\n    * @param _amount Amount of palToken to return\\n    * @return uint : amount of underlying returned\\n    */\\n    function withdraw(uint _amount) public virtual override nonReentrant returns(uint){\\n        require(_updateInterest());\\n        require(balanceOf(msg.sender) >= _amount, Errors.INSUFFICIENT_BALANCE);\\n\\n        //Retrieve the current exchange rate palToken:underlying\\n        uint _exchRate = _exchangeRate();\\n\\n        //Find the amount to return depending on the amount of palToken to burn\\n        uint _num = _amount.mul(_exchRate);\\n        uint _toReturn = _num.div(mantissaScale);\\n\\n        //Check if the pool has enough underlying to return\\n        require(_toReturn <= underlyingBalance(), Errors.INSUFFICIENT_CASH);\\n\\n        //Burn the corresponding palToken amount\\n        require(palToken.burn(msg.sender, _amount), Errors.FAIL_BURN);\\n\\n        //Make the underlying transfer\\n        underlying.safeTransfer(msg.sender, _toReturn);\\n\\n        //Use the controller to check if the burning was successfull\\n        require(controller.withdrawVerify(address(this), msg.sender, _toReturn), Errors.FAIL_WITHDRAW);\\n\\n        //Emit the Withdraw event\\n        emit Withdraw(msg.sender, _amount, address(this));\\n\\n        return _toReturn;\\n    }\\n\\n    /**\\n    * @dev Create a Borrow, deploy a Loan Pool and delegate voting power\\n    * @param _delegatee Address to delegate the voting power to\\n    * @param _amount Amount of underlying to borrow\\n    * @param _feeAmount Amount of fee to pay to start the loan\\n    * @return uint : new PalLoanToken Id\\n    */\\n    function borrow(address _delegatee, uint _amount, uint _feeAmount) public virtual override nonReentrant returns(uint){\\n        //Need the pool to have enough liquidity, and the interests to be up to date\\n        require(_amount < underlyingBalance(), Errors.INSUFFICIENT_CASH);\\n        require(_delegatee != address(0), Errors.ZERO_ADDRESS);\\n        require(_amount > 0, Errors.ZERO_BORROW);\\n        require(_feeAmount >= minBorrowFees(_amount), Errors.BORROW_INSUFFICIENT_FEES);\\n        require(_updateInterest());\\n\\n        address _borrower = msg.sender;\\n\\n        //Update Total Borrowed & number active Loans\\n        numberActiveLoans = numberActiveLoans.add(1);\\n        totalBorrowed = totalBorrowed.add(_amount);\\n\\n        IPalLoan _newLoan = IPalLoan(Clones.clone(delegator));\\n\\n        //Send the borrowed amount of underlying tokens to the Loan\\n        underlying.safeTransfer(address(_newLoan), _amount);\\n\\n        //And transfer the fees from the Borrower to the Loan\\n        underlying.safeTransferFrom(_borrower, address(_newLoan), _feeAmount);\\n\\n        //Start the Loan (and delegate voting power)\\n        require(_newLoan.initiate(\\n            address(this),\\n            _borrower,\\n            address(underlying),\\n            _delegatee,\\n            _amount,\\n            _feeAmount\\n        ), Errors.FAIL_LOAN_INITIATE);\\n\\n        //Add the new Loan to mappings\\n        loans.push(address(_newLoan));\\n\\n        //Mint the palLoanToken linked to this new Loan\\n        uint256 _newTokenId = palLoanToken.mint(_borrower, address(this), address(_newLoan));\\n\\n        //New Borrow struct for this Loan\\n        loanToBorrow[address(_newLoan)] = Borrow(\\n            _newTokenId,\\n            _delegatee,\\n            address(_newLoan),\\n            _amount,\\n            address(underlying),\\n            _feeAmount,\\n            0,\\n            borrowIndex,\\n            block.number,\\n            0,\\n            false,\\n            false\\n        );\\n\\n        //Check the borrow succeeded\\n        require(\\n            controller.borrowVerify(address(this), _borrower, _delegatee, _amount, _feeAmount, address(_newLoan)), \\n            Errors.FAIL_BORROW\\n        );\\n\\n        //Emit the NewLoan Event\\n        emit NewLoan(\\n            _borrower,\\n            _delegatee,\\n            address(underlying),\\n            _amount,\\n            address(this),\\n            address(_newLoan),\\n            _newTokenId,\\n            block.number\\n        );\\n\\n        //Return the PalLoanToken Id\\n        return _newTokenId;\\n    }\\n\\n    /**\\n    * @notice Transfer the new fees to the Loan, and expand the Loan\\n    * @param _loan Address of the Loan\\n    * @param _feeAmount New amount of fees to pay\\n    * @return bool : Amount of fees paid\\n    */\\n    function expandBorrow(address _loan, uint _feeAmount) public virtual override nonReentrant returns(uint){\\n        //Fetch the corresponding Borrow\\n        //And check that the caller is the Borrower, and the Loan is still active\\n        Borrow storage _borrow = loanToBorrow[_loan];\\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\\n        require(isLoanOwner(_loan, msg.sender), Errors.NOT_LOAN_OWNER);\\n        require(_feeAmount > 0);\\n        require(_updateInterest());\\n        \\n        //Load the Loan Pool contract & get Loan owner\\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\\n\\n        address _loanOwner = palLoanToken.ownerOf(_borrow.tokenId);\\n\\n        _borrow.feesAmount = _borrow.feesAmount.add(_feeAmount);\\n\\n        //Transfer the new fees to the Loan\\n        //If success, call the expand function of the Loan\\n        underlying.safeTransferFrom(_loanOwner, _borrow.loan, _feeAmount);\\n\\n        require(_palLoan.expand(_feeAmount), Errors.FAIL_LOAN_EXPAND);\\n\\n        emit ExpandLoan(\\n            _loanOwner,\\n            _borrow.delegatee,\\n            address(underlying),\\n            address(this),\\n            _borrow.feesAmount,\\n            _borrow.loan,\\n            _borrow.tokenId\\n        );\\n\\n        return _feeAmount;\\n    }\\n\\n    /**\\n    * @notice Close a Loan, and return the non-used fees to the Borrower.\\n    * If closed before the minimum required length, penalty fees are taken to the non-used fees\\n    * @dev Close a Loan, and return the non-used fees to the Borrower\\n    * @param _loan Address of the Loan\\n    */\\n    function closeBorrow(address _loan) public virtual override nonReentrant {\\n        //Fetch the corresponding Borrow\\n        //And check that the caller is the Borrower, and the Loan is still active\\n        Borrow storage _borrow = loanToBorrow[_loan];\\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\\n        require(isLoanOwner(_loan, msg.sender), Errors.NOT_LOAN_OWNER);\\n        require(_updateInterest());\\n\\n        //Get Loan owner from the ERC721 contract\\n        address _loanOwner = palLoanToken.ownerOf(_borrow.tokenId);\\n\\n        //Load the Loan contract\\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\\n\\n        //Calculates the amount of fees used\\n        uint _feesUsed = (_borrow.amount.mul(borrowIndex).div(_borrow.borrowIndex)).sub(_borrow.amount);\\n        uint _penaltyFees = 0;\\n        uint _totalFees = _feesUsed;\\n\\n        //If the Borrow is closed before the minimum length, calculates the penalty fees to pay\\n        // -> Number of block remaining to complete the minimum length * current Borrow Rate\\n        if(block.number < (_borrow.startBlock.add(minBorrowLength))){\\n            uint _currentBorrowRate = interestModule.getBorrowRate(address(this), underlyingBalance(), totalBorrowed, totalReserve);\\n            uint _missingBlocks = (_borrow.startBlock.add(minBorrowLength)).sub(block.number);\\n            _penaltyFees = _missingBlocks.mul(_borrow.amount.mul(_currentBorrowRate)).div(mantissaScale);\\n            _totalFees = _totalFees.add(_penaltyFees);\\n        }\\n    \\n        //Security so the Borrow can be closed if there are no more fees\\n        //(if the Borrow wasn't Killed yet, or the loan is closed before minimum time, and already paid fees aren't enough)\\n        if(_totalFees > _borrow.feesAmount){\\n            _totalFees = _borrow.feesAmount;\\n        }\\n\\n        //Set the Borrow as closed\\n        _borrow.closed = true;\\n        _borrow.feesUsed = _totalFees;\\n        _borrow.closeBlock = block.number;\\n\\n        //Remove the borrowed tokens + fees from the TotalBorrowed\\n        //Add to the Reserve the reserveFactor of Penalty Fees (if there is Penalty Fees)\\n        //And add the fees counted as potential Killer Fees to the Accrued Fees, since no killing was necessary\\n\\n        numberActiveLoans = numberActiveLoans.sub(1);\\n\\n        totalBorrowed = numberActiveLoans == 0 ? 0 : totalBorrowed.sub((_borrow.amount).add(_feesUsed)); //If not current active Loan, we can just reset the totalBorrowed to 0\\n\\n        uint _realPenaltyFees = _totalFees.sub(_feesUsed);\\n        uint _killerFees = _feesUsed.mul(killerRatio).div(mantissaScale);\\n        totalReserve = totalReserve.add(reserveFactor.mul(_realPenaltyFees).div(mantissaScale));\\n        accruedFees = accruedFees.add(_killerFees).add(reserveFactor.mul(_realPenaltyFees).div(mantissaScale));\\n        \\n        //Close and destroy the loan\\n        _palLoan.closeLoan(_totalFees);\\n\\n        //Burn the palLoanToken for this Loan\\n        require(palLoanToken.burn(_borrow.tokenId), Errors.FAIL_LOAN_TOKEN_BURN);\\n\\n        require(controller.closeBorrowVerify(address(this), _loanOwner, _borrow.loan), Errors.FAIL_CLOSE_BORROW);\\n\\n        //Emit the CloseLoan Event\\n        emit CloseLoan(\\n            _loanOwner,\\n            _borrow.delegatee,\\n            address(underlying),\\n            _borrow.amount,\\n            address(this),\\n            _totalFees,\\n            _loan,\\n            _borrow.tokenId,\\n            false\\n        );\\n    }\\n\\n    /**\\n    * @notice Kill a non-healthy Loan to collect rewards\\n    * @dev Kill a non-healthy Loan to collect rewards\\n    * @param _loan Address of the Loan\\n    */\\n    function killBorrow(address _loan) public virtual override nonReentrant {\\n        address killer = msg.sender;\\n        //Fetch the corresponding Borrow\\n        //And check that the killer is not the Borrower, and the Loan is still active\\n        Borrow storage _borrow = loanToBorrow[_loan];\\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\\n        require(!isLoanOwner(_loan, killer), Errors.LOAN_OWNER);\\n        require(_updateInterest());\\n\\n        //Get the owner of the Loan through the ERC721 contract\\n        address _loanOwner = palLoanToken.ownerOf(_borrow.tokenId);\\n\\n        //Calculate the amount of fee used, and check if the Loan is killable\\n        uint _feesUsed = (_borrow.amount.mul(borrowIndex).div(_borrow.borrowIndex)).sub(_borrow.amount);\\n        uint _loanHealthFactor = _feesUsed.mul(uint(1e18)).div(_borrow.feesAmount);\\n        require(_loanHealthFactor >= killFactor, Errors.NOT_KILLABLE);\\n\\n        //Load the Loan\\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\\n\\n        //Close the Loan, and update storage variables\\n        _borrow.closed = true;\\n        _borrow.killed = true;\\n        _borrow.feesUsed = _borrow.feesAmount;\\n        _borrow.closeBlock = block.number;\\n\\n        //Remove the borrowed tokens + fees from the TotalBorrowed\\n        //Remove the amount paid as killer fees from the Reserve, and any over accrued interest in the Reserve & AccruedFees\\n        uint _overAccruedInterest = _loanHealthFactor <= mantissaScale ? 0 : _feesUsed.sub(_borrow.feesAmount);\\n        uint _killerFees = (_borrow.feesAmount).mul(killerRatio).div(mantissaScale);\\n\\n        numberActiveLoans = numberActiveLoans.sub(1);\\n\\n        totalBorrowed = numberActiveLoans == 0 ? 0 : totalBorrowed.sub((_borrow.amount).add(_feesUsed)); //If not current active Loan, we can just reset the totalBorrowed to 0\\n\\n        totalReserve = totalReserve.sub(_killerFees).sub(_overAccruedInterest.mul(reserveFactor).div(mantissaScale));\\n        accruedFees = accruedFees.sub(_overAccruedInterest.mul(reserveFactor.sub(killerRatio)).div(mantissaScale));\\n\\n        //Kill the Loan\\n        _palLoan.killLoan(killer, killerRatio);\\n\\n        //Burn the palLoanToken for this Loan\\n        require(palLoanToken.burn(_borrow.tokenId), Errors.FAIL_LOAN_TOKEN_BURN);\\n\\n        require(controller.killBorrowVerify(address(this), killer, _borrow.loan), Errors.FAIL_KILL_BORROW);\\n\\n        //Emit the CloseLoan Event\\n        emit CloseLoan(\\n            _loanOwner,\\n            _borrow.delegatee,\\n            address(underlying),\\n            _borrow.amount,\\n            address(this),\\n            _borrow.feesAmount,\\n            _loan,\\n            _borrow.tokenId,\\n            true\\n        );\\n    }\\n\\n\\n\\n    /**\\n    * @notice Change the delegatee of a Loan, and delegate him the voting power\\n    * @dev Change the delegatee in the Borrow struct and in the palLoan, then change the voting power delegation recipient\\n    * @param _loan Address of the Loan\\n    * @param _newDelegatee Address of the new voting power recipient\\n    */\\n    function changeBorrowDelegatee(address _loan, address _newDelegatee) public virtual override nonReentrant {\\n        //Fetch the corresponding Borrow\\n        //And check that the caller is the Borrower, and the Loan is still active\\n        Borrow storage _borrow = loanToBorrow[_loan];\\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\\n        require(_newDelegatee != address(0), Errors.ZERO_ADDRESS);\\n        require(isLoanOwner(_loan, msg.sender), Errors.NOT_LOAN_OWNER);\\n        require(_updateInterest());\\n\\n        //Load the Loan Pool contract\\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\\n\\n        //Update storage data\\n        _borrow.delegatee = _newDelegatee;\\n\\n        //Call the delegation logic in the palLoan to change the votong power recipient\\n        require(_palLoan.changeDelegatee(_newDelegatee), Errors.FAIL_LOAN_DELEGATEE_CHANGE);\\n\\n        //Emit the Event\\n        emit ChangeLoanDelegatee(\\n            palLoanToken.ownerOf(_borrow.tokenId),\\n            _newDelegatee,\\n            address(underlying),\\n            address(this),\\n            _borrow.loan,\\n            _borrow.tokenId\\n        );\\n\\n    }\\n\\n\\n    /**\\n    * @notice Return the user's palToken balance\\n    * @dev Links the PalToken balanceOf() method\\n    * @param _account User address\\n    * @return uint256 : user palToken balance (in wei)\\n    */\\n    function balanceOf(address _account) public view override returns(uint){\\n        return palToken.balanceOf(_account);\\n    }\\n\\n\\n    /**\\n    * @notice Return the corresponding balance of the pool underlying token depending on the user's palToken balance\\n    * @param _account User address\\n    * @return uint256 : corresponding balance in the underlying token (in wei)\\n    */\\n    function underlyingBalanceOf(address _account) external view override returns(uint){\\n        uint _balance = palToken.balanceOf(_account);\\n        if(_balance == 0){\\n            return 0;\\n        }\\n        uint _exchRate = _exchangeRate();\\n        uint _num = _balance.mul(_exchRate);\\n        return _num.div(mantissaScale);\\n    }\\n\\n\\n    /**\\n    * @notice Return true is the given address is the owner of the palLoanToken for the given palLoan\\n    * @param _loanAddress Address of the Loan\\n    * @param _user User address\\n    * @return bool : true if owner\\n    */\\n    function isLoanOwner(address _loanAddress, address _user) public view override returns(bool){\\n        return palLoanToken.allOwnerOf(idOfLoan(_loanAddress)) == _user;\\n    }\\n\\n\\n    /**\\n    * @notice Return the token Id of the palLoanToken linked to this palLoan\\n    * @param _loanAddress Address of the Loan\\n    * @return uint256 : palLoanToken token Id\\n    */\\n    function idOfLoan(address _loanAddress) public view override returns(uint256){\\n        return loanToBorrow[_loanAddress].tokenId;\\n    }\\n\\n\\n\\n    /**\\n    * @notice Return the list of all Loans for this Pool (closed and active)\\n    * @return address[] : list of Loans\\n    */\\n    function getLoansPools() external view override returns(address [] memory){\\n        //Return the addresses of all loans (old ones and active ones)\\n        return loans;\\n    }\\n    \\n    /**\\n    * @notice Return all the Loans for a given address\\n    * @param _borrower Address of the user\\n    * @return address : list of Loans\\n    */\\n    function getLoansByBorrower(address _borrower) external view override returns(address [] memory){\\n        return palLoanToken.allLoansOfForPool(_borrower, address(this));\\n    }\\n\\n    \\n    /**\\n    * @notice Return the stored Borrow data for a given Loan\\n    * @dev Return the Borrow data for a given Loan\\n    * @param _loanAddress Address of the palLoan\\n    * Composants of a Borrow struct\\n    */\\n    function getBorrowData(address _loanAddress) external view override returns(\\n        address _borrower,\\n        address _delegatee,\\n        address _loan,\\n        uint256 _palLoanTokenId,\\n        uint _amount,\\n        address _underlying,\\n        uint _feesAmount,\\n        uint _feesUsed,\\n        uint _startBlock,\\n        uint _closeBlock,\\n        bool _closed,\\n        bool _killed\\n    ){\\n        //Return the data inside a Borrow struct\\n        Borrow memory _borrow = loanToBorrow[_loanAddress];\\n        return (\\n            //Get the Loan owner through the ERC721 contract\\n            palLoanToken.allOwnerOf(_borrow.tokenId),\\n            _borrow.delegatee,\\n            _borrow.loan,\\n            _borrow.tokenId,\\n            _borrow.amount,\\n            _borrow.underlying,\\n            _borrow.feesAmount,\\n            //Calculate amount of fees used\\n            _borrow.closed ? _borrow.feesUsed : (_borrow.amount.mul(borrowIndex).div(_borrow.borrowIndex)).sub(_borrow.amount),\\n            _borrow.startBlock,\\n            _borrow.closeBlock,\\n            _borrow.closed,\\n            _borrow.killed\\n        );\\n\\n    }\\n    \\n    /**\\n    * @notice Get the Borrow Rate for this Pool\\n    * @dev Get the Borrow Rate from the Interest Module\\n    * @return uint : Borrow Rate (scale 1e18)\\n    */\\n    function borrowRatePerBlock() external view override returns (uint){\\n        return interestModule.getBorrowRate(address(this), underlyingBalance(), totalBorrowed, totalReserve);\\n    }\\n    \\n    /**\\n    * @notice Get the Supply Rate for this Pool\\n    * @dev Get the Supply Rate from the Interest Module\\n    * @return uint : Supply Rate (scale 1e18)\\n    */\\n    function supplyRatePerBlock() external view override returns (uint){\\n        return interestModule.getSupplyRate(address(this), underlyingBalance(), totalBorrowed, totalReserve, reserveFactor);\\n    }\\n\\n    \\n    /**\\n    * @dev Calculates the current exchange rate\\n    * @return uint : current exchange rate (scale 1e18)\\n    */\\n    function _exchangeRate() internal view returns (uint){\\n        uint _totalSupply = palToken.totalSupply();\\n        //If no palTokens where minted, use the initial exchange rate\\n        if(_totalSupply == 0){\\n            return initialExchangeRate;\\n        }\\n        else{\\n            // Exchange Rate = (Cash + Borrows - Reserve) / Supply\\n            uint _cash = underlyingBalance();\\n            uint _availableCash = _cash.add(totalBorrowed).sub(totalReserve);\\n            return _availableCash.mul(1e18).div(_totalSupply);\\n        }\\n    }\\n\\n    /**\\n    * @notice Get the current exchange rate for the palToken\\n    * @dev Updates interest & Calls internal function _exchangeRate\\n    * @return uint : current exchange rate (scale 1e18)\\n    */\\n    function exchangeRateCurrent() external override returns (uint){\\n        _updateInterest();\\n        return _exchangeRate();\\n    }\\n    \\n    /**\\n    * @notice Get the stored exchange rate for the palToken\\n    * @dev Calls internal function _exchangeRate\\n    * @return uint : current exchange rate (scale 1e18)\\n    */\\n    function exchangeRateStored() external view override returns (uint){\\n        return _exchangeRate();\\n    }\\n\\n    /**\\n    * @notice Return the minimum of fees to pay to borrow\\n    * @dev Fees to pay for a Borrow (for the minimum borrow length)\\n    * @return uint : minimum amount (in wei)\\n    */\\n    function minBorrowFees(uint _amount) public view override returns (uint){\\n        require(_amount < underlyingBalance(), Errors.INSUFFICIENT_CASH);\\n        //Future Borrow Rate with the amount to borrow counted as already borrowed\\n        uint _borrowRate = interestModule.getBorrowRate(address(this), underlyingBalance().sub(_amount), totalBorrowed.add(_amount), totalReserve);\\n        uint _minFees = minBorrowLength.mul(_amount.mul(_borrowRate)).div(mantissaScale);\\n        return _minFees > 0 ? _minFees : 1;\\n    }\\n\\n    function isKillable(address _loan) external view override returns(bool){\\n        Borrow memory __borrow = loanToBorrow[_loan];\\n        if(__borrow.closed){\\n            return false;\\n        }\\n\\n        //Calculate the amount of fee used, and check if the Loan is killable\\n        uint _feesUsed = (__borrow.amount.mul(borrowIndex).div(__borrow.borrowIndex)).sub(__borrow.amount);\\n        uint _loanHealthFactor = _feesUsed.mul(uint(1e18)).div(__borrow.feesAmount);\\n        return _loanHealthFactor >= killFactor;\\n    }\\n\\n    /**\\n    * @dev Updates Inetrest and variables for this Pool\\n    * @return bool : Update success\\n    */\\n    function _updateInterest() public returns (bool){\\n        //Get the current block\\n        //Check if the Pool has already been updated this block\\n        uint _currentBlock = block.number;\\n        if(_currentBlock == accrualBlockNumber){\\n            return true;\\n        }\\n\\n        //Get Pool variables from Storage\\n        uint _cash = underlyingBalance();\\n        uint _borrows = totalBorrowed;\\n        uint _reserves = totalReserve;\\n        uint _accruedFees = accruedFees;\\n        uint _oldBorrowIndex = borrowIndex;\\n\\n        //Get the Borrow Rate from the Interest Module\\n        uint _borrowRate = interestModule.getBorrowRate(address(this), _cash, _borrows, _reserves);\\n\\n        //Delta of blocks since the last update\\n        uint _ellapsedBlocks = _currentBlock.sub(accrualBlockNumber);\\n\\n        /*\\n        Interest Factor = Borrow Rate * Ellapsed Blocks\\n        Accumulated Interests = Interest Factor * Borrows\\n        Total Borrows = Borrows + Accumulated Interests\\n        Total Reserve = Reserve + Accumulated Interests * Reserve Factor\\n        Accrued Fees = Accrued Fees + Accumulated Interests * (Reserve Factor - Killer Ratio) -> (available fees should not count potential fees to send to killers)\\n        Borrow Index = old Borrow Index + old Borrow Index * Interest Factor \\n        */\\n        uint _interestFactor = _borrowRate.mul(_ellapsedBlocks);\\n        uint _accumulatedInterest = _interestFactor.mul(_borrows).div(mantissaScale);\\n        uint _newBorrows = _borrows.add(_accumulatedInterest);\\n        uint _newReserve = _reserves.add(reserveFactor.mul(_accumulatedInterest).div(mantissaScale));\\n        uint _newAccruedFees = _accruedFees.add((reserveFactor.sub(killerRatio)).mul(_accumulatedInterest).div(mantissaScale));\\n        uint _newBorrowIndex = _oldBorrowIndex.add(_interestFactor.mul(_oldBorrowIndex).div(1e18));\\n\\n        //Update storage\\n        totalBorrowed = _newBorrows;\\n        totalReserve = _newReserve;\\n        accruedFees = _newAccruedFees;\\n        borrowIndex = _newBorrowIndex;\\n        accrualBlockNumber = _currentBlock;\\n\\n        return true;\\n    }\\n\\n    \\n\\n\\n    // Admin Functions\\n\\n    /**\\n    * @notice Set a new Controller\\n    * @dev Loads the new Controller for the Pool\\n    * @param  _newController address of the new Controller\\n    */\\n    function setNewController(address _newController) external override controllerOnly {\\n        controller = IPaladinController(_newController);\\n    }\\n\\n    /**\\n    * @notice Set a new Interest Module\\n    * @dev Load a new Interest Module\\n    * @param _interestModule address of the new Interest Module\\n    */\\n    function setNewInterestModule(address _interestModule) external override adminOnly {\\n        interestModule = InterestInterface(_interestModule);\\n    }\\n\\n    /**\\n    * @notice Set a new Delegator\\n    * @dev Change Delegator address\\n    * @param _delegator address of the new Delegator\\n    */\\n    function setNewDelegator(address _delegator) external override adminOnly {\\n        delegator = _delegator;\\n    }\\n\\n\\n    /**\\n    * @notice Set a new Minimum Borrow Length\\n    * @dev Change Minimum Borrow Length value\\n    * @param _length new Minimum Borrow Length\\n    */\\n    function updateMinBorrowLength(uint _length) external override adminOnly {\\n        require(_length > 0, Errors.INVALID_PARAMETERS);\\n        minBorrowLength = _length;\\n    }\\n\\n\\n    /**\\n    * @notice Update the Pool Reserve Factor & Killer Ratio\\n    * @dev Change Reserve Factor value & Killer Ratio value\\n    * @param _reserveFactor new % of fees to set as Reserve\\n    * @param _killerRatio new Ratio of Fees to pay the killer\\n    */\\n    function updatePoolFactors(uint _reserveFactor, uint _killerRatio) external override adminOnly {\\n        require(_reserveFactor > 0 && _killerRatio > 0 && _reserveFactor >= _killerRatio, \\n            Errors.INVALID_PARAMETERS\\n        );\\n        reserveFactor = _reserveFactor;\\n        killerRatio = _killerRatio;\\n    }\\n\\n\\n    /**\\n    * @notice Add underlying in the Pool Reserve\\n    * @dev Transfer underlying token from the admin to the Pool\\n    * @param _amount Amount of underlying to transfer\\n    */\\n    function addReserve(uint _amount) external override adminOnly {\\n        require(_updateInterest());\\n\\n        totalReserve = totalReserve.add(_amount);\\n\\n        //Transfer from the admin to the Pool\\n        underlying.safeTransferFrom(admin, address(this), _amount);\\n\\n        emit AddReserve(_amount);\\n    }\\n\\n    /**\\n    * @notice Remove underlying from the Pool Reserve\\n    * @dev Transfer underlying token from the Pool to the admin\\n    * @param _amount Amount of underlying to transfer\\n    */\\n    function removeReserve(uint _amount) external override adminOnly {\\n        //Check if there is enough in the reserve\\n        require(_updateInterest());\\n        require(_amount <= underlyingBalance() && _amount <= totalReserve, Errors.RESERVE_FUNDS_INSUFFICIENT);\\n\\n        totalReserve = totalReserve.sub(_amount);\\n\\n        //Transfer underlying to the admin\\n        underlying.safeTransfer(admin, _amount);\\n\\n        emit RemoveReserve(_amount);\\n    }\\n\\n    /**\\n    * @notice Method to allow the Controller (or admin) to withdraw protocol fees\\n    * @dev Transfer underlying token from the Pool to the controller (or admin)\\n    * @param _amount Amount of underlying to transfer\\n    * @param _recipient Address to receive the token\\n    */\\n    function withdrawFees(uint _amount, address _recipient) external override controllerOnly {\\n        //Check if there is enough in the reserve\\n        require(_updateInterest());\\n        require(_amount<= accruedFees && _amount <= totalReserve, Errors.FEES_ACCRUED_INSUFFICIENT);\\n\\n        //Substract from accruedFees (to track how much fees the Controller can withdraw since last time)\\n        //And also from the REserve, since the fees are part of the Reserve\\n        accruedFees = accruedFees.sub(_amount);\\n        totalReserve = totalReserve.sub(_amount);\\n\\n        //Transfer fees to the recipient\\n        underlying.safeTransfer(_recipient, _amount);\\n\\n        emit WithdrawFees(_amount);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address master) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, master))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, master))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, master))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\\n        return predictDeterministicAddress(master, salt, address(this));\\n    }\\n}\"\r\n    },\r\n    \"contracts/IPalPool.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\n/** @title palPool Interface  */\\n/// @author Paladin\\ninterface IPalPool {\\n\\n    //Events\\n    /** @notice Event when an user deposit tokens in the pool */\\n    event Deposit(address user, uint amount, address palPool);\\n    /** @notice Event when an user withdraw tokens from the pool */\\n    event Withdraw(address user, uint amount, address palPool);\\n    /** @notice Event when a loan is started */\\n    event NewLoan(\\n        address borrower,\\n        address delegatee,\\n        address underlying,\\n        uint amount,\\n        address palPool,\\n        address loanAddress,\\n        uint256 palLoanTokenId,\\n        uint startBlock);\\n    /** @notice Event when the fee amount in the loan is updated */\\n    event ExpandLoan(\\n        address borrower,\\n        address delegatee,\\n        address underlying,\\n        address palPool,\\n        uint newFeesAmount,\\n        address loanAddress,\\n        uint256 palLoanTokenId\\n    );\\n    /** @notice Event when the delegatee of the loan is updated */\\n    event ChangeLoanDelegatee(\\n        address borrower,\\n        address newDelegatee,\\n        address underlying,\\n        address palPool,\\n        address loanAddress,\\n        uint256 palLoanTokenId\\n    );\\n    /** @notice Event when a loan is ended */\\n    event CloseLoan(\\n        address borrower,\\n        address delegatee,\\n        address underlying,\\n        uint amount,\\n        address palPool,\\n        uint usedFees,\\n        address loanAddress,\\n        uint256 palLoanTokenId,\\n        bool wasKilled\\n    );\\n\\n    /** @notice Reserve Events */\\n    event AddReserve(uint amount);\\n    event RemoveReserve(uint amount);\\n    event WithdrawFees(uint amount);\\n\\n\\n    //Functions\\n    function deposit(uint _amount) external returns(uint);\\n    function withdraw(uint _amount) external returns(uint);\\n    \\n    function borrow(address _delegatee, uint _amount, uint _feeAmount) external returns(uint);\\n    function expandBorrow(address _loanPool, uint _feeAmount) external returns(uint);\\n    function closeBorrow(address _loanPool) external;\\n    function killBorrow(address _loanPool) external;\\n    function changeBorrowDelegatee(address _loanPool, address _newDelegatee) external;\\n\\n    function balanceOf(address _account) external view returns(uint);\\n    function underlyingBalanceOf(address _account) external view returns(uint);\\n\\n    function isLoanOwner(address _loanAddress, address _user) external view returns(bool);\\n    function idOfLoan(address _loanAddress) external view returns(uint256);\\n\\n    function getLoansPools() external view returns(address [] memory);\\n    function getLoansByBorrower(address _borrower) external view returns(address [] memory);\\n    function getBorrowData(address _loanAddress) external view returns(\\n        address _borrower,\\n        address _delegatee,\\n        address _loanPool,\\n        uint256 _palLoanTokenId,\\n        uint _amount,\\n        address _underlying,\\n        uint _feesAmount,\\n        uint _feesUsed,\\n        uint _startBlock,\\n        uint _closeBlock,\\n        bool _closed,\\n        bool _killed\\n    );\\n\\n    function borrowRatePerBlock() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n\\n    function exchangeRateCurrent() external returns (uint);\\n    function exchangeRateStored() external view returns (uint);\\n\\n    function minBorrowFees(uint _amount) external view returns (uint);\\n\\n    function isKillable(address _loan) external view returns(bool);\\n\\n    //Admin functions : \\n    function setNewController(address _newController) external;\\n    function setNewInterestModule(address _interestModule) external;\\n    function setNewDelegator(address _delegator) external;\\n\\n    function updateMinBorrowLength(uint _length) external;\\n    function updatePoolFactors(uint _reserveFactor, uint _killerRatio) external;\\n\\n    function addReserve(uint _amount) external;\\n    function removeReserve(uint _amount) external;\\n    function withdrawFees(uint _amount, address _recipient) external;\\n\\n}\"\r\n    },\r\n    \"contracts/PalPoolStorage.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./IPaladinController.sol\\\";\\nimport \\\"./IPalLoanToken.sol\\\";\\nimport \\\"./interests/InterestInterface.sol\\\";\\nimport \\\"./IPalPool.sol\\\";\\nimport \\\"./IPalToken.sol\\\";\\nimport \\\"./utils/IERC20.sol\\\";\\n\\n/** @title palPool Storage contract  */\\n/// @author Paladin\\ncontract PalPoolStorage {\\n\\n    /** @notice Struct of a Borrow */\\n    struct Borrow {\\n        //id of the palLoanToken\\n        uint256 tokenId;\\n        //address of the delegatee\\n        address delegatee;\\n        //address of the Loan Pool contract holding the loan\\n        address loan;\\n        //amount of the loan\\n        uint amount;\\n        //address of the underlying for this loan\\n        address underlying;\\n        //amount of fees (in the underlying token) paid by the borrower\\n        uint feesAmount;\\n        //amount of fees (in the underlying token) already used\\n        uint feesUsed;\\n        //borrow index at the loan creation\\n        uint borrowIndex;\\n        //start block for the Borrow\\n        uint startBlock;\\n        //block where the Borrow was closed\\n        uint closeBlock;\\n        //false if the loan is active, true if loan was closed or killed\\n        bool closed;\\n        //false when the loan is active, true if the loan was killed\\n        bool killed;\\n    }\\n\\n    //palPool variables & Mappings\\n\\n    /** @notice ERC721 palLoanToken */\\n    IPalLoanToken public palLoanToken;\\n\\n    /** @notice Underlying ERC20 token of this Pool */\\n    IERC20 public underlying;\\n\\n    /** @notice ERC20 palToken for this Pool */\\n    IPalToken public palToken;\\n\\n    /** @dev Boolean to prevent reentry in some functions */\\n    bool internal entered = false;\\n\\n    /** @notice Total of the current Reserve */\\n    uint public totalReserve;\\n    /** @notice Total of underlying tokens \\\"borrowed\\\" (in Loan Pool contracts) */\\n    uint public totalBorrowed;\\n    /** @notice Total fees accrued since last withdraw */\\n    /** (this amount id part of the Reserve : we should always have totalReserve >= accruedFees) */\\n    uint public accruedFees;\\n\\n    /** @notice Minimum duration of a Borrow (in blocks) */\\n    uint public minBorrowLength = 45290;\\n    \\n\\n    /** @dev Health Factor to kill a loan */\\n    uint public constant killFactor = 0.95e18;\\n    /** @dev Ratio of the borrow fees to pay the killer of a loan */\\n    uint public killerRatio = 0.1e18;\\n\\n    /** @dev Base value to mint palTokens */\\n    uint internal constant initialExchangeRate = 1e18;\\n    /** @notice Part of the borrows interest to set as Reserves */\\n    uint public reserveFactor = 0.2e18;\\n    /** @notice Last block where the interest where updated for this pool */\\n    uint public accrualBlockNumber;\\n    /** @notice Borrow Index : increase at each interest update to represent borrows interests increasing */\\n    uint public borrowIndex;\\n\\n    /** @dev Scale used to represent decimal values */\\n    uint constant internal mantissaScale = 1e18;\\n\\n    /** @dev Mapping of Loan Pool contract address to Borrow struct */\\n    mapping (address => Borrow) internal loanToBorrow;\\n    /** @dev List of all Loans (active & closed) */\\n    address[] internal loans;\\n    /** @dev Current number of active Loans */\\n    uint public numberActiveLoans;\\n\\n    //Modules\\n\\n    /** @notice Paladin Controller contract */\\n    IPaladinController public controller;\\n    /** @dev Current Inetrest Module */\\n    InterestInterface internal interestModule;\\n\\n    /** @dev Delegator for the underlying governance token */\\n    address internal delegator;\\n    \\n}\"\r\n    },\r\n    \"contracts/IPalLoan.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n/** @title Interface for PalLoan contract  */\\n/// @author Paladin\\ninterface IPalLoan {\\n\\n    // Variables\\n    function underlying() external view returns(address);\\n    function amount() external view returns(uint);\\n    function borrower() external view returns(address);\\n    function delegatee() external view returns(address);\\n    function motherPool() external view returns(address);\\n    function feesAmount() external view returns(uint);\\n\\n    // Functions\\n    function initiate(\\n        address _motherPool,\\n        address _borrower,\\n        address _underlying,\\n        address _delegatee,\\n        uint _amount,\\n        uint _feesAmount\\n    ) external returns(bool);\\n    function expand(uint _newFeesAmount) external returns(bool);\\n    function closeLoan(uint _usedAmount) external;\\n    function killLoan(address _killer, uint _killerRatio) external;\\n    function changeDelegatee(address _delegatee) external returns(bool);\\n}\"\r\n    },\r\n    \"contracts/IPalToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n\\n/** @title simple PalToken Interface to be used inside the PalPool contract  */\\n/// @author Paladin\\ninterface IPalToken {\\n\\n    function mint(address _user, uint _toMint) external returns(bool);\\n\\n    function burn(address _user, uint _toBurn) external returns(bool);\\n\\n    function balanceOf(address owner) external view returns(uint);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/IPaladinController.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n/** @title Paladin Controller Interface  */\\n/// @author Paladin\\ninterface IPaladinController {\\n    \\n    //Events\\n\\n    /** @notice Event emitted when a new token & pool are added to the list */\\n    event NewPalPool(address palPool, address palToken);\\n    /** @notice Event emitted when a token & pool are removed from the list */\\n    event RemovePalPool(address palPool, address palToken);\\n\\n\\n    //Functions\\n    function isPalPool(address pool) external view returns(bool);\\n    function getPalTokens() external view returns(address[] memory);\\n    function getPalPools() external view returns(address[] memory);\\n    function setInitialPools(address[] memory palTokens, address[] memory palPools) external returns(bool);\\n    function addNewPool(address palToken, address palPool) external returns(bool);\\n    function removePool(address _palPool) external returns(bool);\\n\\n    function withdrawPossible(address palPool, uint amount) external view returns(bool);\\n    function borrowPossible(address palPool, uint amount) external view returns(bool);\\n\\n    function depositVerify(address palPool, address dest, uint amount) external view returns(bool);\\n    function withdrawVerify(address palPool, address dest, uint amount) external view returns(bool);\\n    function borrowVerify(address palPool, address borrower, address delegatee, uint amount, uint feesAmount, address loanAddress) external view returns(bool);\\n    function expandBorrowVerify(address palPool, address loanAddress, uint newFeesAmount) external view returns(bool);\\n    function closeBorrowVerify(address palPool, address borrower, address loanAddress) external view returns(bool);\\n    function killBorrowVerify(address palPool, address killer, address loanAddress) external view returns(bool);\\n\\n    //Admin functions\\n    function setPoolsNewController(address _newController) external returns(bool);\\n    function withdrawFromPool(address _pool, uint _amount, address _recipient) external returns(bool);\\n\\n}\"\r\n    },\r\n    \"contracts/IPalLoanToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./utils/IERC721.sol\\\";\\n\\n/** @title palLoanToken Interface  */\\n/// @author Paladin\\ninterface IPalLoanToken is IERC721 {\\n\\n    //Events\\n\\n    /** @notice Event when a new Loan Token is minted */\\n    event NewLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\\n    /** @notice Event when a Loan Token is burned */\\n    event BurnLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\\n\\n\\n    //Functions\\n    function mint(address to, address palPool, address palLoan) external returns(uint256);\\n    function burn(uint256 tokenId) external returns(bool);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function tokenOfByIndex(address owner, uint256 tokenIdex) external view returns (uint256);\\n    function loanOf(uint256 tokenId) external view returns(address);\\n    function poolOf(uint256 tokenId) external view returns(address);\\n    function loansOf(address owner) external view returns(address[] memory);\\n    function tokensOf(address owner) external view returns(uint256[] memory);\\n    function loansOfForPool(address owner, address palPool) external view returns(address[] memory);\\n    function allTokensOf(address owner) external view returns(uint256[] memory);\\n    function allLoansOf(address owner) external view returns(address[] memory);\\n    function allLoansOfForPool(address owner, address palPool) external view returns(address[] memory);\\n    function allOwnerOf(uint256 tokenId) external view returns(address);\\n\\n    function isBurned(uint256 tokenId) external view returns(bool);\\n\\n    //Admin functions\\n    function setNewController(address _newController) external;\\n    function setNewBaseURI(string memory _newBaseURI) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interests/InterestInterface.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n/** @title Interest Module Interface  */\\n/// @author Paladin\\ninterface InterestInterface {\\n\\n    function getSupplyRate(address palPool, uint cash, uint borrows, uint reserves, uint reserveFactor) external view returns(uint);\\n    function getBorrowRate(address palPool, uint cash, uint borrows, uint reserves) external view returns(uint);\\n}\"\r\n    },\r\n    \"contracts/utils/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/utils/Admin.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n\\n/** @title Admin contract  */\\n/// @author Paladin\\ncontract Admin {\\n\\n    /** @notice (Admin) Event when the contract admin is updated */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /** @dev Admin address for this contract */\\n    address payable internal admin;\\n    \\n    modifier adminOnly() {\\n        //allows only the admin of this contract to call the function\\n        require(msg.sender == admin, '1');\\n        _;\\n    }\\n\\n        /**\\n    * @notice Set a new Admin\\n    * @dev Changes the address for the admin parameter\\n    * @param _newAdmin address of the new Controller Admin\\n    */\\n    function setNewAdmin(address payable _newAdmin) external adminOnly {\\n        address _oldAdmin = admin;\\n        admin = _newAdmin;\\n\\n        emit NewAdmin(_oldAdmin, _newAdmin);\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Errors.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\nlibrary Errors {\\n    // Admin error\\n    string public constant CALLER_NOT_ADMIN = '1'; // 'The caller must be the admin'\\n    string public constant CALLER_NOT_CONTROLLER = '29'; // 'The caller must be the admin or the controller'\\n    string public constant CALLER_NOT_ALLOWED_POOL = '30';  // 'The caller must be a palPool listed in the controller'\\n    string public constant CALLER_NOT_MINTER = '31';\\n\\n    // ERC20 type errors\\n    string public constant FAIL_TRANSFER = '2';\\n    string public constant FAIL_TRANSFER_FROM = '3';\\n    string public constant BALANCE_TOO_LOW = '4';\\n    string public constant ALLOWANCE_TOO_LOW = '5';\\n    string public constant SELF_TRANSFER = '6';\\n\\n    // PalPool errors\\n    string public constant INSUFFICIENT_CASH = '9';\\n    string public constant INSUFFICIENT_BALANCE = '10';\\n    string public constant FAIL_DEPOSIT = '11';\\n    string public constant FAIL_LOAN_INITIATE = '12';\\n    string public constant FAIL_BORROW = '13';\\n    string public constant ZERO_BORROW = '27';\\n    string public constant BORROW_INSUFFICIENT_FEES = '23';\\n    string public constant LOAN_CLOSED = '14';\\n    string public constant NOT_LOAN_OWNER = '15';\\n    string public constant LOAN_OWNER = '16';\\n    string public constant FAIL_LOAN_EXPAND = '17';\\n    string public constant NOT_KILLABLE = '18';\\n    string public constant RESERVE_FUNDS_INSUFFICIENT = '19';\\n    string public constant FAIL_MINT = '20';\\n    string public constant FAIL_BURN = '21';\\n    string public constant FAIL_WITHDRAW = '24';\\n    string public constant FAIL_CLOSE_BORROW = '25';\\n    string public constant FAIL_KILL_BORROW = '26';\\n    string public constant ZERO_ADDRESS = '22';\\n    string public constant INVALID_PARAMETERS = '28'; \\n    string public constant FAIL_LOAN_DELEGATEE_CHANGE = '32';\\n    string public constant FAIL_LOAN_TOKEN_BURN = '33';\\n    string public constant FEES_ACCRUED_INSUFFICIENT = '34';\\n\\n}\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/utils/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_palToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_interestModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_palLoanToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDelegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loanAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"palLoanTokenId\",\"type\":\"uint256\"}],\"name\":\"ChangeLoanDelegatee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usedFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loanAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"palLoanTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasKilled\",\"type\":\"bool\"}],\"name\":\"CloseLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeesAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loanAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"palLoanTokenId\",\"type\":\"uint256\"}],\"name\":\"ExpandLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loanAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"palLoanTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"NewLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RemoveReserve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFees\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_updateInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newDelegatee\",\"type\":\"address\"}],\"name\":\"changeBorrowDelegatee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"}],\"name\":\"closeBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IPaladinController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"name\":\"expandBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanAddress\",\"type\":\"address\"}],\"name\":\"getBorrowData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_palLoanTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feesUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closeBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_closed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_killed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getLoansByBorrower\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLoansPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanAddress\",\"type\":\"address\"}],\"name\":\"idOfLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"}],\"name\":\"isKillable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isLoanOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"}],\"name\":\"killBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killerRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"minBorrowFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBorrowLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberActiveLoans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"palLoanToken\",\"outputs\":[{\"internalType\":\"contract IPalLoanToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"palToken\",\"outputs\":[{\"internalType\":\"contract IPalToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setNewAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"setNewController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegator\",\"type\":\"address\"}],\"name\":\"setNewDelegator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interestModule\",\"type\":\"address\"}],\"name\":\"setNewInterestModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"underlyingBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"updateMinBorrowLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_killerRatio\",\"type\":\"uint256\"}],\"name\":\"updatePoolFactors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PalPool","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"25000","ConstructorArguments":"0000000000000000000000003f482847d97937c2c13626fe98dd44c68e29eb29000000000000000000000000bbfa3b05b2dae65fb4c05ec7f1598793a4bc0623000000000000000000000000875773784af8135ea0ef43b5a374aad105c5d39e000000000000000000000000076d4cf37e48b9265e05d57f280eff562b17747600000000000000000000000012cb3f4e80b795bc77090a7c412b1f804ee085a800000000000000000000000055da1cbd77b1c3b2d8bfe0f5fdf63d684b49f8a5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}