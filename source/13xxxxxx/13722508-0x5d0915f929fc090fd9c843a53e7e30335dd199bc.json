{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Traits.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ITraits.sol\\\";\\nimport \\\"./IDogewood.sol\\\";\\n\\ncontract Traits is Ownable, ITraits {\\n\\n  using Strings for uint256;\\n\\n  string[] traitTypes = ['head', 'breed', 'color', 'class', 'armor', 'offhand', 'mainhand', 'level'];\\n\\n  // storage of each traits name\\n  // trait1 => [name1, name2, ...]\\n  mapping(uint8 => mapping(uint8 => string)) public traitNames;\\n\\n  // trait1 => id1 => trait2 => id2 => address\\n  // ex:\\n  //   breed => 0 => head => 0 => breedHeas\\n  //   class => {armor | offhand | mainhand} => value => address\\n  mapping(uint8 => mapping(uint8 => mapping(uint8 => mapping(uint8 => address)))) public traitSvgs;\\n\\n  IDogewood public dogewood;\\n\\n  constructor() {\\n    // head\\n    string[9] memory heads = [\\\"Determined\\\", \\\"High\\\", \\\"Happy\\\", \\\"Determined Tongue\\\", \\\"High Tongue\\\", \\\"Happy Tongue\\\", \\\"Determined Open\\\", \\\"High Open\\\", \\\"Happy Open\\\"];\\n    for (uint8 i = 0; i < heads.length; i++) {\\n      traitNames[0][i] = heads[i];  \\n    }\\n    // bread\\n    string[8] memory breads = [\\\"Shiba\\\", \\\"Pug\\\", \\\"Corgi\\\", \\\"Labrador\\\", \\\"Dachshund\\\", \\\"Poodle\\\", \\\"Pitbull\\\", \\\"Bulldog\\\"];\\n    for (uint8 i = 0; i < breads.length; i++) {\\n      traitNames[1][i] = breads[i];  \\n    }\\n    // color\\n    string[6] memory colors = [\\\"Palette 1\\\", \\\"Palette 2\\\", \\\"Palette 3\\\", \\\"Palette 4\\\", \\\"Palette 5\\\", \\\"Palette 6\\\"];\\n    for (uint8 i = 0; i < colors.length; i++) {\\n      traitNames[2][i] = colors[i];  \\n    }\\n    // class\\n    string[8] memory classes = [\\\"Warrior\\\", \\\"Rogue\\\", \\\"Mage\\\", \\\"Hunter\\\", \\\"Cleric\\\", \\\"Bard\\\", \\\"Merchant\\\", \\\"Forager\\\"];\\n    for (uint8 i = 0; i < classes.length; i++) {\\n      traitNames[3][i] = classes[i];  \\n    }\\n  }\\n\\n  /** ADMIN */\\n\\n  function setDogewood(address _dogewood) external onlyOwner {\\n    dogewood = IDogewood(_dogewood);\\n  }\\n\\n  /**\\n   * administrative to upload the names associated with each trait\\n   */\\n  function uploadTraitNames(uint8 trait, uint8[] calldata traitIds, string[] calldata names) external onlyOwner {\\n    require(traitIds.length == names.length, \\\"Mismatched inputs\\\");\\n    for (uint256 index = 0; index < traitIds.length; index++) {\\n      traitNames[trait][traitIds[index]] = names[index];\\n    }\\n  }\\n\\n  function uploadTraitSvgs(uint8 trait1, uint8 id1, uint8 trait2, uint8[] calldata trait2Ids, address source) external onlyOwner {\\n    for (uint256 index = 0; index < trait2Ids.length; index++) {\\n        traitSvgs[trait1][id1][trait2][trait2Ids[index]] = source; \\n    }\\n  }\\n\\n  /*///////////////////////////////////////////////////////////////\\n                  INTERNAL FUNCTIONS\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function call(address source, bytes memory sig) internal view returns (string memory svg) {\\n      (bool succ, bytes memory ret)  = source.staticcall(sig);\\n      require(succ, \\\"failed to get data\\\");\\n      svg = abi.decode(ret, (string));\\n  }\\n\\n  function getSvg(uint8 trait1, uint8 id1, uint8 trait2, uint8 id2) internal view returns (string memory data_) {\\n      address source = traitSvgs[trait1][id1][trait2][id2];\\n      data_ = call(source, getData(trait1, id1, trait2, id2));\\n  }\\n\\n  function getData(uint8 trait1, uint8 id1, uint8 trait2, uint8 id2) internal view returns (bytes memory data) {\\n    string memory s = string(abi.encodePacked(\\n          traitTypes[trait1],toString(id1),\\n          traitTypes[trait2],toString(id2),\\n          \\\"()\\\"\\n      ));\\n    return abi.encodeWithSignature(s, \\\"\\\");\\n  }\\n\\n  /**\\n   * generates an entire SVG by composing multiple <image> elements of PNGs\\n   * @param tokenId the ID of the token to generate an SVG for\\n   * @return a valid SVG of the Sheep / Wolf\\n   */\\n  function drawSVG(uint256 tokenId) public view returns (string memory) {\\n    IDogewood.Doge memory s = dogewood.getTokenTraits(tokenId);\\n\\n    return string(abi.encodePacked(\\n      string(abi.encodePacked(\\n        '<svg id=\\\"doge\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" viewBox=\\\"0 0 64 64\\\" shape-rendering=\\\"geometricPrecision\\\" text-rendering=\\\"geometricPrecision\\\"><style>',\\n        getSvg(1, s.breed, 2, s.color) // breed -> color\\n      )),\\n      '.to {fill: #E2B0D0;};<![CDATA[#llu_to {animation: llu_to__to 1970ms linear infinite normal forwards}@keyframes llu_to__to {0% {transform: translate(38.445px, 50.11px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(38.445px, 49.11px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(38.445px, 50.08px)}}#llu_tr {animation: llu_tr__tr 1970ms linear infinite normal forwards}@keyframes llu_tr__tr {0% {transform: rotate(0deg);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: rotate(9.852042deg);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: rotate(0.295561deg)}}#lll_tr {animation: lll_tr__tr 1970ms linear infinite normal forwards}@keyframes lll_tr__tr {0% {transform: translate(40.570847px, 59.34803px) rotate(0deg);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(40.570847px, 59.34803px) rotate(-6.706667deg);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(40.570847px, 59.34803px) rotate(0deg)}}#lau_to {animation: lau_to__to 1970ms linear infinite normal forwards}@keyframes lau_to__to {0% {transform: translate(40.09px, 36.61px)}10.152284% {transform: translate(40.09px, 36.61px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(40.09px, 35.724449px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(40.09px, 36.583433px)}}#lal_to {animation: lal_to__to 1970ms linear infinite normal forwards}@keyframes lal_to__to {0% {transform: translate(44.64px, 42.14px)}10.152284% {transform: translate(44.64px, 42.14px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(44.64px, 41.30px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(44.64px, 42.12px)}}#lhg_to {animation: lhg_to__to 1970ms linear infinite normal forwards}@keyframes lhg_to__to {0% {transform: translate(51.932867px, 41.61px)}10.152284% {transform: translate(51.932867px, 41.61px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(51.932867px, 40.61px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(51.932867px, 41.58px)}}#rlu_to {animation: rlu_to__to 1970ms linear infinite normal forwards}@keyframes rlu_to__to {0% {transform: translate(29.8px, 49px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(29.727549px, 47.98px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(29.797826px, 48.97px)}}#rll_tr {animation: rll_tr__tr 1970ms linear infinite normal forwards}@keyframes rll_tr__tr {0% {transform: translate(21.539296px, 59.4px) rotate(7.41deg);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(21.539296px, 59.397946px) rotate(0.899323deg);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(21.539296px, 59.397946px) rotate(7.824398deg)}}#b_to {animation: b_to__to 1970ms linear infinite normal forwards}@keyframes b_to__to {0% {transform: translate(32.42684px, 42.24346px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(32.42684px, 41.24346px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(32.42684px, 42.21346px)}}#h_to {animation: h_to__to 1970ms linear infinite normal forwards}@keyframes h_to__to {0% {transform: translate(34.27015px, 25.573563px)}5.076142% {transform: translate(34.27015px, 25.573563px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(34.27015px, 24.573563px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(34.27015px, 25.543563px)}}#rau_to {animation: rau_to__to 1970ms linear infinite normal forwards}@keyframes rau_to__to {0% {transform: translate(25.071545px, 35.88px)}10.152284% {transform: translate(25.071545px, 35.88px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(25.071545px, 34.88px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(25.071545px, 35.85px)}}#ral_to {animation: ral_to__to 1970ms linear infinite normal forwards}@keyframes ral_to__to {0% {transform: translate(21.75px, 39.476864px)}10.152284% {transform: translate(21.75px, 39.476864px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}50.761421% {transform: translate(21.75px, 38.476864px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(21.75px, 39.446864px)}}#rhg_to {animation: rhg_to__to 1970ms linear infinite normal forwards}@keyframes rhg_to__to {0% {transform: translate(16.48px, 26.210001px)}20.304569% {transform: translate(16.48px, 26.210001px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}60.913706% {transform: translate(16.48px, 25.210001px);animation-timing-function: cubic-bezier(0.42, 0, 0.58, 1)}100% {transform: translate(16.48px, 26.172501px)}}]]></style><g id=\\\"llu_to\\\" transform=\\\"translate(38.445,50.11)\\\"><g id=\\\"llu_tr\\\" transform=\\\"rotate(0)\\\"><path id=\\\"llu\\\" class=\\\"p st\\\" d=\\\"M39,54.08C48.21,59.71,47.38,49.2,38.85,47.08C35.57,46.22,32.87,50.33,39,54.08Z\\\" transform=\\\"translate(-38.444998,-50.11)\\\"/></g></g><g id=\\\"lll_tr\\\" transform=\\\"translate(40.570847,59.34803) rotate(0)\\\"><path id=\\\"lll\\\" d=\\\"M40.67,54.6C40.67,54.6,38.22,55.6,38.76,56.02C39.019118,56.1171,39.293294,56.167874,39.57,56.17C39.846706,56.172126,37.48,57.85,39.5,57.85C38.5,59.75,39.33,60.29,40.5,60.14C42.88,59.85,47.35,54.94,45.34,53.35\\\" transform=\\\"translate(-40.570846,-59.34803)\\\" class= \\\"p st\\\" /></g><g id=\\\"lau_to\\\" transform=\\\"translate(40.09,36.61)\\\"><path id=\\\"lau\\\" d=\\\"M39.58,34.55C41,32.99,43.94,34.55,44.05,37.89C54,50.78,31.36,41.73,39.58,34.55Z\\\" transform=\\\"translate(-40.089999,-36.692566)\\\" class=\\\"p st\\\" /></g><g id=\\\"lal_to\\\" transform=\\\"translate(44.64,42.141064)\\\"><path id=\\\"lal\\\" d=\\\"M44.45,40.41C48.84,37.86,55.52,44.57,45.22,44.5C45.22,44.5,45.03,45.5,44.49,44.74C44.22,44.98,43.29,46.3,43.49,43.81\\\" transform=\\\"translate(-44.64,-42.141054)\\\" class= \\\"p st\\\" /></g><g id=\\\"lhg_to\\\" transform=\\\"translate(51.932867,41.613806)\\\"><g id=\\\"lhg\\\" transform=\\\"translate(-51.932867,-41.613805)\\\"><g id=\\\"lh\\\"><path class=\\\"p st\\\" d=\\\"M53.72,40.94C53.72,40.94,54.19,42.8,53.06,42.82C53.74,44.82,48.95,43.66,50.46,42.27C50.310545,41.770875,50.383427,41.231554,50.66,40.79C48.89,38.05,55,38.77,53.72,40.94Z\\\" fill=\\\"rgb(250,146,35)\\\"/><path class=\\\"p st\\\" d=\\\"M50.38,43.33C50.38,43.33,50.15,43.56,49.03,43.1M50.18,41.72C50.5,41.62,50.42,40.56,50.42,40.56C52.19,42.44,51.55,38.78,50.42,39.07C49.957689,39.069969,49.514599,39.254979,49.18958,39.583756C48.864561,39.912532,48.684655,40.35772,48.69,40.82\\\" fill=\\\"rgb(250,146,35)\\\" /></g><g id=\\\"oh\\\">',\\n      string(abi.encodePacked(\\n        getSvg(3, s.class, 5, s.offhand), // class -> offhand\\n        string(abi.encodePacked(\\n          '</g></g></g><g id=\\\"rlu_to\\\" transform=\\\"translate(29.8,49)\\\"><path id=\\\"rlu\\\" d=\\\"M26.16,47.51C17.88,57,27,58.28,32.3,51.18\\\" transform=\\\"rotate(-16.630564) translate(-29.8,-49.07425)\\\" class= \\\"p st\\\" /></g><g id=\\\"rll_tr\\\" transform=\\\"translate(21.539296,59.397946) rotate(7.415168)\\\"><path id=\\\"rll\\\" d=\\\"M23,53.26C23,53.26,20,54,21.35,55C20.07,55.79,20.19,56.46,21.24,56.32C18.09,63.32,24.24,59.17,26.69,56.56C28.03,55.13,28.07,54.78,28.07,54.78\\\" transform=\\\"translate(-21.059999,-59.397931)\\\" class= \\\"p st\\\" /></g><g id=\\\"b_to\\\" transform=\\\"translate(32.42684,42.24346)\\\"><g id=\\\"b\\\" transform=\\\"translate(-32.42684,-42.243459)\\\"><path id=\\\"t\\\" d=\\\"M23.47,36.09C22.57,40.9,25.15,39.94,26.03,47.91C26.63,53.36,41,56.43,40.5,43C40.36,39.33,42.2,35.12,39.8,33.36C36.57,31,24.94,28.27,23.47,36.09Z\\\" class= \\\"p st\\\" /></g></g> <g id=\\\"rau_to\\\" transform=\\\"translate(25.071545,35.88)\\\"><path id=\\\"rau\\\" d=\\\"M26,33.76C26,33.76,21.84,31.92,20.7,36.82C20.7,36.82,17.2,41.48,21.7,41.49C26.05,41.49,26.03,40.15,27.32,40.25\\\" transform=\\\"translate(-25.07154,-35.756237)\\\" class= \\\"p st\\\" /></g><g id=\\\"b_to\\\" transform=\\\"translate(32.42684,42.24346)\\\"><g id=\\\"b\\\" transform=\\\"translate(-32.42684,-42.243459)\\\">',\\n          getSvg(3, s.class, 4, s.armor))), // class -> armor\\n        string(abi.encodePacked(\\n          '</g></g><g id=\\\"h_to\\\" transform=\\\"translate(34.27015,25.573563)\\\"><g id=\\\"h\\\" transform=\\\"translate(-34.27015,-25.573563)\\\">',\\n          getSvg(1, s.breed, 0, s.head), // breed -> head\\n          '</g></g><g id=\\\"ral_to\\\" transform=\\\"translate(21.75,39.476864)\\\"><path id=\\\"ral\\\" d=\\\"M22.54,37.73C21.91,36.65,19.54,35.95,17.48,38.42C13.89,42.8,23,43,23.3,40.67\\\" transform=\\\"translate(-21.749999,-39.476864)\\\" class= \\\"p st\\\" /></g><g id=\\\"rhg_to\\\" transform=\\\"translate(16.48,26.210001)\\\"><g id=\\\"rhg\\\" transform=\\\"translate(-16.48,-26.210001)\\\"><g id=\\\"mh\\\">')),\\n        string(abi.encodePacked(\\n          getSvg(3, s.class, 6, s.mainhand), // class -> mainhand\\n          '</g><g id=\\\"rh\\\"><path id=\\\"25\\\" d=\\\"M18.08,37.23C22.13,35.44,21.08,41.16,19.59,41.16C18.1,41.16,17.51,37.49,18.08,37.23Z\\\" class= \\\"p st\\\" /><path id=\\\"13\\\" d=\\\"M18.67,38.69C20.56,39.14,19.04,40.86,19.04,40.86C21.63,43.17,13.04,44.51,14.3,41.67C12.24,41.67,13.08,38.92,13.08,38.92C11.52,35.33,21.48,36,18.67,38.69ZM15.67,41.35C16.55443,41.435012,17.446858,41.370784,18.31,41.16M17.62,38.74C16.866986,38.594273,16.093014,38.594273,15.34,38.74\\\" class= \\\"p st\\\" /></g></g></g><path id=\\\"rf\\\" d=\\\"M22.920306,59.141614Q24.375075,57.999107,24.899612,59.141614Q26.13429,57.617253,26.488256,60.345399Q23.097414,60.768964,21.257409,60.174476\\\" transform=\\\"matrix(1 0 0 1 -0.10429 -0.116147)\\\" class= \\\"p st\\\" /><path id=\\\"lf\\\" d=\\\"M23.380676,59.141614Q25.065606,57.999107,25.590143,59.141614Q26.824821,57.617253,26.488256,60.345399Q23.097414,60.768964,21.257409,60.174476\\\" transform=\\\"matrix(1 0 0 1 18.164491 -0.116147)\\\" class= \\\"p st\\\" /></svg>'\\n        ))\\n      ))\\n    ));\\n  }\\n\\n  /**\\n   * generates an attribute for the attributes array in the ERC721 metadata standard\\n   * @param traitType the trait type to reference as the metadata key\\n   * @param value the token's trait associated with the key\\n   * @return a JSON dictionary for the single attribute\\n   */\\n  function attributeForTypeAndValue(string memory traitType, string memory value) internal pure returns (string memory) {\\n    return string(abi.encodePacked(\\n      '{\\\"trait_type\\\":\\\"',\\n      traitType,\\n      '\\\",\\\"value\\\":\\\"',\\n      value,\\n      '\\\"}'\\n    ));\\n  }\\n\\n  function toString(uint256 value) internal pure returns (string memory) {\\n      // Inspired by OraclizeAPI's implementation - MIT licence\\n      // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n      if (value == 0) {\\n          return \\\"0\\\";\\n      }\\n      uint256 temp = value;\\n      uint256 digits;\\n      while (temp != 0) {\\n          digits++;\\n          temp /= 10;\\n      }\\n      bytes memory buffer = new bytes(digits);\\n      while (value != 0) {\\n          digits -= 1;\\n          buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n          value /= 10;\\n      }\\n      return string(buffer);\\n  }\\n\\n  /**\\n   * generates an array composed of all the individual traits and values\\n   * @param tokenId the ID of the token to compose the metadata for\\n   * @return a JSON array of all of the attributes for given token ID\\n   */\\n  function compileAttributes(uint256 tokenId) public view returns (string memory) {\\n    IDogewood.Doge memory s = dogewood.getTokenTraits(tokenId);\\n\\n    string memory traits1 = string(abi.encodePacked(\\n      attributeForTypeAndValue(traitTypes[0], traitNames[0][s.head]),',',\\n      attributeForTypeAndValue(traitTypes[1], traitNames[1][s.breed]),',',\\n      attributeForTypeAndValue(traitTypes[2], traitNames[2][s.color]),',',\\n      attributeForTypeAndValue(traitTypes[3], traitNames[3][s.class]),','\\n    ));\\n    string memory traits2 = string(abi.encodePacked(\\n      attributeForTypeAndValue(traitTypes[4], toString(s.armor)),',',\\n      attributeForTypeAndValue(traitTypes[5], toString(s.offhand)),',',\\n      attributeForTypeAndValue(traitTypes[6], toString(s.mainhand)),',',\\n      attributeForTypeAndValue(traitTypes[7], toString(s.level)),','\\n    ));\\n    return string(abi.encodePacked(\\n      '[',\\n      traits1, traits2,\\n      '{\\\"trait_type\\\":\\\"Generation\\\",\\\"value\\\":',\\n      tokenId <= dogewood.getGenesisSupply() ? '\\\"Gen 0\\\"' : '\\\"Gen 1\\\"',\\n      '}]'\\n    ));\\n  }\\n\\n  /**\\n   * generates a base64 encoded metadata response without referencing off-chain content\\n   * @param tokenId the ID of the token to generate the metadata for\\n   * @return a base64 encoded JSON dictionary of the token's metadata and SVG\\n   */\\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n    string memory metadata = string(abi.encodePacked(\\n      '{\\\"name\\\": \\\"Dogewood #',\\n      tokenId.toString(),\\n      '\\\", \\\"description\\\": \\\"100% on-chain\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n      base64(bytes(drawSVG(tokenId))),\\n      '\\\", \\\"attributes\\\":',\\n      compileAttributes(tokenId),\\n      \\\"}\\\"\\n    ));\\n\\n    return string(abi.encodePacked(\\n      \\\"data:application/json;base64,\\\",\\n      base64(bytes(metadata))\\n    ));\\n  }\\n\\n  /** BASE 64 - Written by Brech Devos */\\n  \\n  string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n  function base64(bytes memory data) internal pure returns (string memory) {\\n    if (data.length == 0) return '';\\n    \\n    // load the table into memory\\n    string memory table = TABLE;\\n\\n    // multiply by 4/3 rounded up\\n    uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n    // add some extra buffer at the end required for the writing\\n    string memory result = new string(encodedLen + 32);\\n\\n    assembly {\\n      // set the actual output length\\n      mstore(result, encodedLen)\\n      \\n      // prepare the lookup table\\n      let tablePtr := add(table, 1)\\n      \\n      // input ptr\\n      let dataPtr := data\\n      let endPtr := add(dataPtr, mload(data))\\n      \\n      // result ptr, jump over length\\n      let resultPtr := add(result, 32)\\n      \\n      // run over the input, 3 bytes at a time\\n      for {} lt(dataPtr, endPtr) {}\\n      {\\n          dataPtr := add(dataPtr, 3)\\n          \\n          // read 3 bytes\\n          let input := mload(dataPtr)\\n          \\n          // write 4 characters\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n          resultPtr := add(resultPtr, 1)\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n          resultPtr := add(resultPtr, 1)\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n          resultPtr := add(resultPtr, 1)\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n          resultPtr := add(resultPtr, 1)\\n      }\\n      \\n      // padding with '='\\n      switch mod(mload(data), 3)\\n      case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n      case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n    }\\n    \\n    return result;\\n  }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Strings.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ITraits.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\ninterface ITraits {\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/IDogewood.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\ninterface IDogewood {\\n\\n  // struct to store each token's traits\\n  \\n  struct Doge {\\n      uint8 head;\\n      uint8 breed;\\n      uint8 color;\\n      uint8 class;\\n      uint8 armor;\\n      uint8 offhand;\\n      uint8 mainhand;\\n      uint16 level;\\n  }\\n\\n  function getTokenTraits(uint256 tokenId) external view returns (Doge memory);\\n  function getGenesisSupply() external view returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"compileAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dogewood\",\"outputs\":[{\"internalType\":\"contract IDogewood\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"drawSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dogewood\",\"type\":\"address\"}],\"name\":\"setDogewood\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitSvgs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"trait\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"traitIds\",\"type\":\"uint8[]\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"uploadTraitNames\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"trait1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"id1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"trait2\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"trait2Ids\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"uploadTraitSvgs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Traits","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}