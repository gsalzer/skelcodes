{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\nlibrary SafeMathLib {\r\n  function times(uint a, uint b) public pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) public pure returns (uint) {\r\n    require(b <= a, 'Underflow detected');\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) public pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// This contract is inspired by the harberger tax idea, it rewards people with FVT for burning their liquidity provider\r\n// tokens.\r\ncontract LiquidityFactory {\r\n    using SafeMathLib for uint;\r\n\r\n    // this represents a single recipient of token rewards on a fixed schedule that does not depend on deposit or burn rate\r\n    // it specifies an id (key to a map below) an marker for the last time it was updated, a deposit (of LP tokens) and a\r\n    // burn rate of those LP tokens per block, and finally, the owner of the slot, who will receive the rewards\r\n    struct Slot {\r\n        uint id;\r\n        uint lastUpdatedBlock;\r\n        uint vacatedBlock;\r\n        uint depositWei;\r\n        uint burnRateWei;\r\n        address owner;\r\n    }\r\n\r\n    // rewardToken: the token that the rewards are made in\r\n    // liquidityToken: the liquidity provider (LP) token\r\n    // taxAddress: address to which taxes are sent\r\n    struct Pool {\r\n        uint id;\r\n        address liquidityToken;\r\n        address taxAddress;\r\n        address poolOwner;\r\n        uint maxStakers;\r\n        uint minimumDepositWei;\r\n        uint maximumDepositWei;\r\n        uint minimumBurnRateWeiPerBlock;\r\n        uint maximumBurnRateWeiPerBlock;\r\n        mapping (uint => Slot) slots;\r\n    }\r\n\r\n    struct Metadata {\r\n        bytes32 name;\r\n        bytes32 ipfsHash;\r\n    }\r\n\r\n    struct Pulse {\r\n        address rewardToken1;\r\n        address rewardToken2;\r\n        uint pulseStartBlock;\r\n        uint pulseWavelengthBlocks;\r\n        uint pulseAmplitudeWei;\r\n        uint pulseIntegral;\r\n        uint pulseConstant;\r\n        uint reward2WeiPerBlock;\r\n    }\r\n\r\n    struct PoolStats {\r\n        uint totalStakedWei;\r\n        uint totalRewardsWei;\r\n        uint totalBurnedWei;\r\n        uint depositDecayWeiPerBlock; // decay only applies to vacated slots\r\n        uint burnRateDecayWeiPerBlock; // decay only applies to vacated slots\r\n        bool paused;\r\n        uint pausedBlock;\r\n        uint unpausedBlock;\r\n        uint pausedStakers;\r\n        uint numSynced; // only used while paused\r\n        uint numStakers;\r\n        mapping (address => uint) totalStakedWeiFor;\r\n        mapping (address => uint) totalRewardsWeiFor;\r\n        mapping (address => uint) totalBurnedWeiFor;\r\n        mapping (uint => uint) rewards1WeiForSession;\r\n    }\r\n\r\n    uint public numPools;\r\n    mapping (uint => Pool) public pools;\r\n    mapping (uint => Metadata) public metadatas;\r\n    mapping (uint => PoolStats) public poolStats;\r\n    mapping (uint => Pulse) public pulses;\r\n\r\n    // privileged key that can change key parameters, will change to dao later\r\n    address public management;\r\n\r\n    event SlotChangedHands(uint indexed poolId, address indexed newOwner, address indexed previousOwner, uint slotId, uint depositWei, uint burnRateWei, uint rewards1WeiForSession);\r\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    modifier poolOwnerOnly(uint poolId) {\r\n        Pool storage pool = pools[poolId];\r\n        require (msg.sender == pool.poolOwner, 'Only pool owner may call this');\r\n        _;\r\n    }\r\n\r\n    modifier initializedPoolOnly(uint poolId) {\r\n        Pool storage pool = pools[poolId];\r\n        require(pool.id == poolId && poolId > 0, 'Uninitialized pool');\r\n        _;\r\n    }\r\n\r\n    modifier pausedAndSynced(uint poolId) {\r\n        PoolStats storage stats = poolStats[poolId];\r\n        require (stats.paused, 'Must be paused');\r\n        require (stats.numSynced == stats.pausedStakers, 'Must sync all users');\r\n        _;\r\n    }\r\n\r\n    constructor(address mgmt) {\r\n        management = mgmt;\r\n    }\r\n\r\n    function addPool(\r\n        address rewardToken1Addr,\r\n        address rewardToken2Addr,\r\n        address liquidityTokenAddr,\r\n        address taxAddr,\r\n        address poolOwner,\r\n        uint rewardPerBlock2Wei,\r\n        uint pulseStartDelayBlocks,\r\n        bytes32 ipfsHash,\r\n        bytes32 name) managementOnly external {\r\n        numPools = numPools.plus(1);\r\n        {\r\n            Pool storage pool = pools[numPools];\r\n            pool.id = numPools;\r\n            pool.liquidityToken = liquidityTokenAddr;\r\n            pool.taxAddress = taxAddr;\r\n            pool.poolOwner = poolOwner;\r\n        }\r\n        {\r\n            Metadata storage metadata = metadatas[numPools];\r\n            metadata.ipfsHash = ipfsHash;\r\n            metadata.name = name;\r\n        }\r\n        {\r\n            Pulse storage pulse = pulses[numPools];\r\n            pulse.rewardToken1 = rewardToken1Addr;\r\n            pulse.rewardToken2 = rewardToken2Addr;\r\n            pulse.pulseStartBlock = block.number + pulseStartDelayBlocks;\r\n            pulse.reward2WeiPerBlock = rewardPerBlock2Wei;\r\n        }\r\n        {\r\n            PoolStats storage stats = poolStats[numPools];\r\n            stats.paused = true;\r\n            stats.pausedBlock = block.number;\r\n//            stats.pausedStakers = 0;\r\n//            stats.unpausedBlock = 0;\r\n        }\r\n\r\n        emit PoolAdded(numPools, name, liquidityTokenAddr);\r\n    }\r\n\r\n    function getRewards(uint poolId, uint slotId) public view returns (uint, uint) {\r\n        Slot storage slot = pools[poolId].slots[slotId];\r\n\r\n        // unoccupied slots have no rewards\r\n        if (slot.owner == address(0)) {\r\n            return (0, 0);\r\n        }\r\n\r\n        return (getRewards1(poolId, slotId), getRewards2(poolId, slotId));\r\n    }\r\n\r\n    function getRewards2(uint poolId, uint slotId) internal view returns (uint) {\r\n        Pulse storage pulse = pulses[poolId];\r\n\r\n        (uint referenceBlock1, uint referenceBlock2) = getReferenceBlocks(poolId, slotId);\r\n        // rewards2 is linear with time, probably very small amount as advertising\r\n        uint rewards2 = referenceBlock2.minus(referenceBlock1).times(pulse.reward2WeiPerBlock);\r\n        return rewards2;\r\n    }\r\n\r\n    // compute the undistributed rewards for a slot\r\n    function getRewards1(uint poolId, uint slotId) internal view initializedPoolOnly(poolId) returns (uint) {\r\n\r\n        (uint referenceBlock1, uint referenceBlock2) = getReferenceBlocks(poolId, slotId);\r\n\r\n        // three parts, incomplete beginning, incomplete end and complete middle\r\n        Pulse storage pulse = pulses[poolId];\r\n        uint rewards1;\r\n\r\n        // complete middle\r\n        // trim off overhang on both ends\r\n        uint startPhase = referenceBlock1.minus(pulse.pulseStartBlock) % pulse.pulseWavelengthBlocks;\r\n        uint startOverhang = pulse.pulseWavelengthBlocks.minus(startPhase);\r\n\r\n        uint blocksDiffTotal = referenceBlock2.minus(referenceBlock1);\r\n\r\n        uint endPhase = referenceBlock2.minus(pulse.pulseStartBlock) % pulse.pulseWavelengthBlocks;\r\n        uint endingBlocks = pulse.pulseWavelengthBlocks.minus(endPhase);\r\n        uint leftoverSum = pulseSum(pulse.pulseConstant, endingBlocks);\r\n        // if we haven't made it to phase 0 yet\r\n        if (blocksDiffTotal < startOverhang) {\r\n            uint startSum = pulseSum(pulse.pulseConstant, startOverhang);\r\n            rewards1 = startSum.minus(leftoverSum);\r\n        } else {\r\n            uint blocksDiff = blocksDiffTotal.minus(endPhase).minus(startOverhang);\r\n            uint wavelengths = blocksDiff / pulse.pulseWavelengthBlocks;\r\n            rewards1 = wavelengths.times(pulse.pulseIntegral);\r\n\r\n            // incomplete beginning of reward cycle, end of pulse\r\n            if (startPhase > 0) {\r\n                rewards1 = rewards1.plus(pulseSum(pulse.pulseConstant, startOverhang));\r\n            }\r\n\r\n            // incomplete ending of reward cycle, beginning of pulse\r\n            if (endPhase > 0) {\r\n                rewards1 = rewards1.plus(pulse.pulseIntegral.minus(leftoverSum));\r\n            }\r\n        }\r\n\r\n        return rewards1;\r\n    }\r\n\r\n    // compute the unapplied burn to the deposit\r\n    function getBurn(uint poolId, uint slotId) public view initializedPoolOnly(poolId) returns (uint) {\r\n        Slot storage slot = pools[poolId].slots[slotId];\r\n        (uint referenceBlock1, uint referenceBlock2) = getReferenceBlocks(poolId, slotId);\r\n        uint burn = slot.burnRateWei.times(referenceBlock2.minus(referenceBlock1));\r\n        if (burn > slot.depositWei) {\r\n            burn = slot.depositWei;\r\n        }\r\n        return burn;\r\n    }\r\n\r\n    // this must be idempotent, it syncs both the rewards and the deposit burn atomically, and updates lastUpdatedBlock\r\n    function updateSlot(uint poolId, uint slotId) public initializedPoolOnly(poolId) {\r\n        Pool storage pool = pools[poolId];\r\n        PoolStats storage stats = poolStats[poolId];\r\n        Slot storage slot = pool.slots[slotId];\r\n        require(slot.owner != address(0), 'Unoccupied slot');\r\n\r\n        // prevent multiple updates on same slot while paused\r\n        if (stats.paused) {\r\n            // these two requires prevent weird double updates that might make numSynced too high\r\n            // it also means that if someone updates you while paused you cannot withdraw...\r\n            require(block.number > stats.pausedBlock, 'Do not call this in the same block that you paused');\r\n            require(slot.lastUpdatedBlock <= stats.pausedBlock, 'If pool is paused, can only update slot once');\r\n            require(msg.sender == pool.poolOwner || msg.sender == slot.owner, 'If pool is paused, only pool owner or slot owner may call this');\r\n            stats.numSynced = stats.numSynced.plus(1);\r\n        }\r\n\r\n        Pulse storage pulse = pulses[poolId];\r\n        (uint rewards1, uint rewards2) = getRewards(poolId, slotId);\r\n\r\n        // burn and rewards always have to update together, since they both depend on lastUpdatedBlock\r\n        uint burn = getBurn(poolId, slotId);\r\n\r\n        // update this first to make burn and reward zero in the case of re-entrance\r\n        // this must happen after getting rewards and burn since they depend on this var\r\n        slot.lastUpdatedBlock = block.number;\r\n\r\n        if (rewards1 > 0) {\r\n            // bookkeeping\r\n            stats.totalRewardsWei = stats.totalRewardsWei.plus(rewards1);\r\n            stats.totalRewardsWeiFor[slot.owner] = stats.totalRewardsWeiFor[slot.owner].plus(rewards1);\r\n            stats.rewards1WeiForSession[slotId] = stats.rewards1WeiForSession[slotId].plus(rewards1);\r\n\r\n            // transfer the rewards\r\n            require(IERC20(pulse.rewardToken1).transfer(slot.owner, rewards1), 'Token transfer failed');\r\n        }\r\n\r\n        if (rewards2 > 0) {\r\n            require(IERC20(pulse.rewardToken2).transfer(slot.owner, rewards2), 'Token transfer failed');\r\n        }\r\n\r\n        if (burn > 0) {\r\n            // adjust deposit first\r\n            slot.depositWei = slot.depositWei.minus(burn);\r\n\r\n            // bookkeeping\r\n            stats.totalBurnedWei = stats.totalBurnedWei.plus(burn);\r\n            stats.totalBurnedWeiFor[slot.owner] = stats.totalBurnedWeiFor[slot.owner].plus(burn);\r\n\r\n            // pay the tax!\r\n            require(IERC20(pool.liquidityToken).transfer(pool.taxAddress, burn), 'Token transfer failed');\r\n        }\r\n    }\r\n\r\n    // most important function for users, allows them to start receiving rewards\r\n    function claimSlot(uint poolId, uint slotId, uint newBurnRate, uint newDeposit) external {\r\n        Pool storage pool = pools[poolId];\r\n        PoolStats storage stats = poolStats[poolId];\r\n        require(slotId > 0, 'Slot id must be positive');\r\n        require(slotId <= pool.maxStakers, 'Slot id out of range');\r\n        require(newBurnRate >= pool.minimumBurnRateWeiPerBlock, 'Burn rate must meet or exceed minimum');\r\n        require(newBurnRate <= pool.maximumBurnRateWeiPerBlock, 'Burn rate must not exceed maximum');\r\n        require(newDeposit >= pool.minimumDepositWei, 'Deposit must meet or exceed minimum');\r\n        require(newDeposit <= pool.maximumDepositWei, 'Deposit must not exceed maximum');\r\n        require(stats.paused == false, 'Must be unpaused');\r\n        require(pool.id == poolId && poolId > 0, 'Uninitialized pool');\r\n        {\r\n            Pulse storage pulse = pulses[poolId];\r\n            require(pulse.pulseStartBlock <= block.number, 'Pool has not started yet');\r\n        }\r\n        Slot storage slot = pool.slots[slotId];\r\n\r\n        // count the stakers\r\n        if (slot.owner == address(0)) {\r\n            // assign id since this may be the first time\r\n            slot.id = slotId;\r\n\r\n            // set last updated block, this happens in updateSlot but that's the other branch\r\n            slot.lastUpdatedBlock = block.number;\r\n\r\n            // check that we meet-or-exceed the linearly-decayed deposit and burn rates\r\n            (uint depositMin, uint burnRateMin) = getClaimMinimums(poolId, slotId);\r\n            bool betterDeal = newBurnRate >= burnRateMin && newDeposit >= depositMin;\r\n            require(betterDeal, 'You must meet or exceed the current burn rate and deposit');\r\n\r\n            // increment counter\r\n            stats.numStakers = stats.numStakers.plus(1);\r\n\r\n        } else {\r\n            updateSlot(poolId, slotId);\r\n\r\n            //  this must go after updateSlot to sync the deposit variable\r\n            bool betterDeal = newBurnRate > slot.burnRateWei && (newDeposit > slot.depositWei || newDeposit == pool.maximumDepositWei);\r\n            require(betterDeal || slot.depositWei == 0, 'You must outbid the current owner');\r\n\r\n            // bookkeeping\r\n            stats.totalStakedWei = stats.totalStakedWei.minus(slot.depositWei);\r\n            stats.totalStakedWeiFor[slot.owner] = stats.totalStakedWeiFor[slot.owner].minus(slot.depositWei);\r\n\r\n            // this is probably not necessary, but we do it to be tidy\r\n            slot.vacatedBlock = 0;\r\n\r\n            // if there's any deposit left,\r\n            if (slot.depositWei > 0) {\r\n                require(IERC20(pool.liquidityToken).transfer(slot.owner, slot.depositWei), 'Token transfer failed');\r\n            }\r\n        }\r\n\r\n        emit SlotChangedHands(poolId, msg.sender, slot.owner, slotId, newDeposit, newBurnRate, stats.rewards1WeiForSession[slotId]);\r\n        stats.rewards1WeiForSession[slotId] = 0;\r\n\r\n        // set new owner, burn rate and deposit\r\n        slot.owner = msg.sender;\r\n        slot.burnRateWei = newBurnRate;\r\n        slot.depositWei = newDeposit;\r\n\r\n        // bookkeeping\r\n        stats.totalStakedWei = stats.totalStakedWei.plus(newDeposit);\r\n        stats.totalStakedWeiFor[msg.sender] = stats.totalStakedWeiFor[msg.sender].plus(newDeposit);\r\n\r\n        // transfer the tokens!\r\n        if (newDeposit > 0) {\r\n            require(IERC20(pool.liquidityToken).transferFrom(msg.sender, address(this), newDeposit), 'Token transfer failed');\r\n        }\r\n    }\r\n\r\n    // separates user from slot, if either voluntary or delinquent\r\n    function withdrawFromSlot(uint poolId, uint slotId) external initializedPoolOnly(poolId) {\r\n        Pool storage pool = pools[poolId];\r\n\r\n        PoolStats storage stats = poolStats[poolId];\r\n        Slot storage slot = pool.slots[slotId];\r\n\r\n        // prevent double-withdrawals\r\n        require(slot.owner != address(0), 'Slot unoccupied');\r\n\r\n        // sync deposit variable (this increments numSynced)\r\n        updateSlot(poolId, slotId);\r\n\r\n        // anyone can withdraw delinquents, but non-delinquents can only be withdrawn by themselves\r\n        bool withdrawable = slot.owner == msg.sender || slot.depositWei == 0;\r\n        require(withdrawable, 'Only owner can call this unless user is delinquent');\r\n\r\n        // must do this before rewards1WeiForSession gets zeroed out\r\n        emit SlotChangedHands(poolId, address(0), slot.owner, slotId, 0, 0, stats.rewards1WeiForSession[slotId]);\r\n        stats.rewards1WeiForSession[slotId] = 0;\r\n\r\n        // decrement the number of stakers\r\n        stats.numStakers = stats.numStakers.minus(1);\r\n\r\n        // record what block we vacated in to compute linear decay\r\n        slot.vacatedBlock = block.number;\r\n\r\n        // zero out owner, closing re-entrance gate\r\n        address owner = slot.owner;\r\n        slot.owner = address(0);\r\n\r\n        // don't set deposit or burn rate to 0 so we can compute linear decay\r\n\r\n        // if there's any deposit left,\r\n        if (slot.depositWei > 0) {\r\n            require(IERC20(pool.liquidityToken).transfer(owner, slot.depositWei), 'Token transfer failed');\r\n        }\r\n    }\r\n\r\n    // ======================== PAUSE =============================\r\n\r\n    function pausePool(uint poolId) external poolOwnerOnly(poolId) initializedPoolOnly(poolId) {\r\n        PoolStats storage stats = poolStats[poolId];\r\n        require(stats.paused == false, 'Already paused');\r\n        stats.paused = true;\r\n        stats.pausedBlock = block.number;\r\n        stats.pausedStakers = stats.numStakers;\r\n        stats.unpausedBlock = 0;\r\n    }\r\n\r\n    function unpausePool(uint poolId) external poolOwnerOnly(poolId) pausedAndSynced(poolId) {\r\n        PoolStats storage stats = poolStats[poolId];\r\n        stats.paused = false;\r\n        stats.pausedBlock = 0;\r\n        stats.numSynced = 0;\r\n        stats.pausedStakers = 0;\r\n        stats.unpausedBlock = block.number;\r\n    }\r\n\r\n    // ======================== GETTERS =============================\r\n\r\n    function getClaimMinimums(uint poolId, uint slotId) public view returns (uint, uint) {\r\n        Slot memory slot = pools[poolId].slots[slotId];\r\n        if (slot.owner != address(0)) {\r\n            return (slot.depositWei, slot.burnRateWei);\r\n        } else {\r\n            PoolStats storage stats = poolStats[poolId];\r\n            uint blocksDiff = block.number.minus(slot.vacatedBlock);\r\n            uint depositDecay = blocksDiff.times(stats.depositDecayWeiPerBlock);\r\n            if (depositDecay > slot.depositWei) {\r\n                depositDecay = slot.depositWei;\r\n            }\r\n\r\n            uint burnRateDecay = blocksDiff.times(stats.burnRateDecayWeiPerBlock);\r\n            if (burnRateDecay > slot.burnRateWei) {\r\n                burnRateDecay = slot.burnRateWei;\r\n            }\r\n\r\n            return (slot.depositWei.minus(depositDecay), slot.burnRateWei.minus(burnRateDecay));\r\n        }\r\n    }\r\n\r\n    function getSlot(uint poolId, uint slotId) external view returns (uint, uint, uint, uint, uint, address) {\r\n        Slot memory slot = pools[poolId].slots[slotId];\r\n        PoolStats storage stats = poolStats[poolId];\r\n        return (slot.lastUpdatedBlock, slot.depositWei, slot.burnRateWei, stats.rewards1WeiForSession[slotId], slot.vacatedBlock, slot.owner);\r\n    }\r\n\r\n    function getUserStats(uint poolId, address user) external view returns (uint, uint, uint) {\r\n        PoolStats storage stats = poolStats[poolId];\r\n        return (stats.totalStakedWeiFor[user], stats.totalRewardsWeiFor[user], stats.totalBurnedWeiFor[user]);\r\n    }\r\n\r\n    function getReferenceBlocks(uint poolId, uint slotId) internal view returns (uint, uint) {\r\n        Pool storage pool = pools[poolId];\r\n        PoolStats storage stats = poolStats[poolId];\r\n        Slot memory slot = pool.slots[slotId];\r\n\r\n        uint referenceBlock1 = slot.lastUpdatedBlock;\r\n        uint referenceBlock2 = block.number;\r\n        if (stats.paused) {\r\n            referenceBlock2 = stats.pausedBlock;\r\n        } else if (slot.lastUpdatedBlock < stats.unpausedBlock) {\r\n            referenceBlock1 = stats.unpausedBlock;\r\n        }\r\n\r\n        return (referenceBlock1, referenceBlock2);\r\n    }\r\n\r\n    // compute the sum of the rewards per pulse\r\n    function pulseSum(uint coeff, uint wavelength) public pure returns (uint) {\r\n        // sum of squares formula\r\n        return coeff.times(wavelength.times(wavelength.plus(1))).times(wavelength.times(2).plus(1)) / 6;\r\n    }\r\n\r\n    // ======================== SETTERS =============================\r\n\r\n    function setConfig(\r\n        uint poolId,\r\n        uint newMaxStakers,\r\n        uint newMinDeposit,\r\n        uint newMaxDeposit,\r\n        uint newMinBurnRate,\r\n        uint newMaxBurnRate,\r\n        uint newWavelength,\r\n        uint newAmplitude) external poolOwnerOnly(poolId) pausedAndSynced(poolId) {\r\n        Pool storage pool = pools[poolId];\r\n        pool.maxStakers = newMaxStakers;\r\n        pool.minimumDepositWei = newMinDeposit;\r\n        pool.maximumDepositWei = newMaxDeposit;\r\n        pool.minimumBurnRateWeiPerBlock = newMinBurnRate;\r\n        pool.maximumBurnRateWeiPerBlock = newMaxBurnRate;\r\n\r\n        Pulse storage pulse = pulses[poolId];\r\n        pulse.pulseWavelengthBlocks = newWavelength;\r\n        pulse.pulseAmplitudeWei = newAmplitude;\r\n        pulse.pulseConstant = pulse.pulseAmplitudeWei / pulse.pulseWavelengthBlocks.times(pulse.pulseWavelengthBlocks);\r\n        pulse.pulseIntegral = pulseSum(pulse.pulseConstant, newWavelength);\r\n    }\r\n\r\n    // only management can reset management key\r\n    function setManagement(address newMgmt) managementOnly external {\r\n        management = newMgmt;\r\n    }\r\n\r\n    // only management can change tax address\r\n    function setTaxAddress(uint poolId, address newTaxAddress) managementOnly external {\r\n        Pool storage pool = pools[poolId];\r\n        pool.taxAddress = newTaxAddress;\r\n    }\r\n\r\n    function setReward2PerBlock(uint poolId, uint newReward) managementOnly external {\r\n        Pulse storage pulse = pulses[poolId];\r\n        pulse.reward2WeiPerBlock = newReward;\r\n    }\r\n\r\n    // only management can change pool owner key\r\n    function setPoolOwner(uint poolId, address newOwner) managementOnly external {\r\n        Pool storage pool = pools[poolId];\r\n        pool.poolOwner = newOwner;\r\n    }\r\n\r\n    function setDecays(uint poolId, uint burnRateDecayWeiPerBlock, uint depositDecayWeiPerBlock) external poolOwnerOnly(poolId) initializedPoolOnly(poolId)  {\r\n        PoolStats storage stats = poolStats[poolId];\r\n        stats.burnRateDecayWeiPerBlock = burnRateDecayWeiPerBlock;\r\n        stats.depositDecayWeiPerBlock = depositDecayWeiPerBlock;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnRateWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards1WeiForSession\",\"type\":\"uint256\"}],\"name\":\"SlotChangedHands\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken1Addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken2Addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock2Wei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseStartDelayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBurnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"claimSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getClaimMinimums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadatas\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"pausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBurnedWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDecayWeiPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnRateDecayWeiPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pausedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unpausedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numSynced\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numStakers\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidityToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBurnRateWeiPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumBurnRateWeiPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wavelength\",\"type\":\"uint256\"}],\"name\":\"pulseSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pulses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pulseStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseWavelengthBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseAmplitudeWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseIntegral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseConstant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward2WeiPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinBurnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxBurnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newWavelength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAmplitude\",\"type\":\"uint256\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnRateDecayWeiPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDecayWeiPerBlock\",\"type\":\"uint256\"}],\"name\":\"setDecays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setPoolOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"setReward2PerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newTaxAddress\",\"type\":\"address\"}],\"name\":\"setTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"unpausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"withdrawFromSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityFactory","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b","EVMVersion":"Default","Library":"SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://30ec8d94d1fe64fbf13bfbfff56400f42ce7aacd44996f14a7d8aab8213aca6e"}]}