{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/market-wrapper/NounsMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ External Imports ============\\nimport {INounsAuctionHouse} from \\\"../external/interfaces/INounsAuctionHouse.sol\\\";\\n\\n// ============ Internal Imports ============\\nimport {IMarketWrapper} from \\\"./IMarketWrapper.sol\\\";\\n\\n/**\\n * @title NounsMarketWrapper\\n * @author Anna Carroll + Nounders\\n * @notice MarketWrapper contract implementing IMarketWrapper interface\\n * according to the logic of Nouns' Auction Houses\\n */\\ncontract NounsMarketWrapper is IMarketWrapper {\\n    // ============ Public Immutables ============\\n\\n    INounsAuctionHouse public immutable market;\\n\\n    // ======== Constructor =========\\n\\n    constructor(address _nounsAuctionHouse) {\\n        market = INounsAuctionHouse(_nounsAuctionHouse);\\n    }\\n\\n    // ======== External Functions =========\\n\\n    /**\\n     * @notice Determine whether there is an existing, active auction\\n     * for this token. In the Nouns auction house, the current auction\\n     * id is the token id, which increments sequentially, forever. The\\n     * auction is considered active while the current block timestamp\\n     * is less than the auction's end time.\\n     * @return TRUE if the auction exists\\n     */\\n    function auctionExists(uint256 auctionId)\\n      public\\n      view\\n      override\\n      returns (bool)\\n    {\\n        (uint256 currentAuctionId, , , uint256 endTime, , ) = market.auction();\\n        return auctionId == currentAuctionId && block.timestamp < endTime;\\n    }\\n\\n    /**\\n     * @notice Determine whether the given auctionId and tokenId is active.\\n     * We ignore nftContract since it is static for all nouns auctions.\\n     * @return TRUE if the auctionId and tokenId matches the active auction\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address /* nftContract */,\\n        uint256 tokenId\\n    ) public view override returns (bool) {\\n        return auctionId == tokenId && auctionExists(auctionId);\\n    }\\n\\n    /**\\n     * @notice Calculate the minimum next bid for the active auction\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId)\\n      external\\n      view\\n      override\\n      returns (uint256)\\n    {\\n        require(\\n            auctionExists(auctionId),\\n            \\\"NounsMarketWrapper::getMinimumBid: Auction not active\\\"\\n        );\\n\\n        (, uint256 amount, , , address payable bidder, ) = market.auction();\\n        if (bidder == address(0)) {\\n            // if there are NO bids, the minimum bid is the reserve price\\n            return market.reservePrice();\\n        }\\n        // if there ARE bids, the minimum bid is the current bid plus the increment buffer\\n        uint8 minBidIncrementPercentage = market.minBidIncrementPercentage();\\n        return amount + ((amount * minBidIncrementPercentage) / 100);\\n    }\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId)\\n      external\\n      view\\n      override\\n      returns (address)\\n    {\\n        require(\\n            auctionExists(auctionId),\\n            \\\"NounsMarketWrapper::getCurrentHighestBidder: Auction not active\\\"\\n        );\\n\\n        (, , , , address payable bidder, ) = market.auction();\\n        return bidder;\\n    }\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external override {\\n        // line 104 of Nouns Auction House, createBid() function\\n        (bool success, bytes memory returnData) =\\n        address(market).call{value: bidAmount}(\\n            abi.encodeWithSignature(\\n                \\\"createBid(uint256)\\\",\\n                auctionId\\n            )\\n        );\\n        require(success, string(returnData));\\n    }\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId)\\n      external\\n      view\\n      override\\n      returns (bool)\\n    {\\n        (uint256 currentAuctionId, , , , , bool settled) = market.auction();\\n        bool settledNormally = auctionId != currentAuctionId;\\n        bool settledWhenPaused = auctionId == currentAuctionId && settled;\\n        return settledNormally || settledWhenPaused;\\n    }\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     */\\n    function finalize(uint256 /* auctionId */) external override {\\n        if (market.paused()) {\\n            market.settleAuction();\\n        } else {\\n            market.settleCurrentAndCreateNewAuction();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/INounsAuctionHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for Noun Auction Houses\\n\\n/*********************************\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n * ░░░░░░█████████░░█████████░░░ *\\n * ░░░░░░██░░░████░░██░░░████░░░ *\\n * ░░██████░░░████████░░░████░░░ *\\n * ░░██░░██░░░████░░██░░░████░░░ *\\n * ░░██░░██░░░████░░██░░░████░░░ *\\n * ░░░░░░█████████░░█████████░░░ *\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n *********************************/\\n\\npragma solidity ^0.8.5;\\n\\ninterface INounsAuctionHouse {\\n    struct Auction {\\n        // ID for the Noun (ERC721 token ID)\\n        uint256 nounId;\\n        // The current highest bid amount\\n        uint256 amount;\\n        // The time that the auction started\\n        uint256 startTime;\\n        // The time that the auction is scheduled to end\\n        uint256 endTime;\\n        // The address of the current highest bid\\n        address payable bidder;\\n        // Whether or not the auction has been settled\\n        bool settled;\\n    }\\n\\n    event AuctionCreated(uint256 indexed nounId, uint256 startTime, uint256 endTime);\\n\\n    event AuctionBid(uint256 indexed nounId, address sender, uint256 value, bool extended);\\n\\n    event AuctionExtended(uint256 indexed nounId, uint256 endTime);\\n\\n    event AuctionSettled(uint256 indexed nounId, address winner, uint256 amount);\\n\\n    event AuctionTimeBufferUpdated(uint256 timeBuffer);\\n\\n    event AuctionReservePriceUpdated(uint256 reservePrice);\\n\\n    event AuctionMinBidIncrementPercentageUpdated(uint256 minBidIncrementPercentage);\\n\\n    function reservePrice() external view returns (uint256);\\n\\n    function minBidIncrementPercentage() external view returns (uint8);\\n\\n    function auction() external view returns (uint256, uint256, uint256, uint256, address payable, bool);\\n\\n    function settleAuction() external;\\n\\n    function settleCurrentAndCreateNewAuction() external;\\n\\n    function createBid(uint256 nounId) external payable;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function paused() external view returns (bool);\\n\\n    function setTimeBuffer(uint256 timeBuffer) external;\\n\\n    function setReservePrice(uint256 reservePrice) external;\\n\\n    function setMinBidIncrementPercentage(uint8 minBidIncrementPercentage) external;\\n}\\n\"\r\n    },\r\n    \"contracts/market-wrapper/IMarketWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title IMarketWrapper\\n * @author Anna Carroll\\n * @notice IMarketWrapper provides a common interface for\\n * interacting with NFT auction markets.\\n * Contracts can abstract their interactions with\\n * different NFT markets using IMarketWrapper.\\n * NFT markets can become compatible with any contract\\n * using IMarketWrapper by deploying a MarketWrapper contract\\n * that implements this interface using the logic of their Market.\\n *\\n * WARNING: MarketWrapper contracts should NEVER write to storage!\\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\\n */\\ninterface IMarketWrapper {\\n    /**\\n     * @notice Determine whether there is an existing auction\\n     * for this token on the underlying market\\n     * @return TRUE if the auction exists\\n     */\\n    function auctionExists(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Determine whether the given auctionId is\\n     * an auction for the tokenId + nftContract\\n     * @return TRUE if the auctionId matches the tokenId + nftContract\\n     */\\n    function auctionIdMatchesToken(\\n        uint256 auctionId,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Calculate the minimum next bid for this auction\\n     * @return minimum bid amount\\n     */\\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\\n\\n    /**\\n     * @notice Query the current highest bidder for this auction\\n     * @return highest bidder\\n     */\\n    function getCurrentHighestBidder(uint256 auctionId)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @notice Submit bid to Market contract\\n     */\\n    function bid(uint256 auctionId, uint256 bidAmount) external;\\n\\n    /**\\n     * @notice Determine whether the auction has been finalized\\n     * @return TRUE if the auction has been finalized\\n     */\\n    function isFinalized(uint256 auctionId) external view returns (bool);\\n\\n    /**\\n     * @notice Finalize the results of the auction\\n     */\\n    function finalize(uint256 auctionId) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nounsAuctionHouse\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"auctionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"auctionIdMatchesToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getCurrentHighestBidder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getMinimumBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"contract INounsAuctionHouse\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NounsMarketWrapper","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000830bd73e4184cef73443c15111a1df14e495c706","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}