{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlockDirectCall.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/*\\n  This contract provides means to block direct call of an external function.\\n  A derived contract (e.g. MainDispatcherBase) should decorate sensitive functions with the\\n  notCalledDirectly modifier, thereby preventing it from being called directly, and allowing only calling\\n  using delegate_call.\\n\\n  This Guard contract uses pseudo-random slot, So each deployed contract would have its own guard.\\n*/\\nabstract contract BlockDirectCall {\\n    bytes32 immutable UNIQUE_SAFEGUARD_SLOT; // NOLINT naming-convention.\\n\\n    constructor() internal {\\n        // The slot is pseudo-random to allow hierarchy of contracts with guarded functions.\\n        bytes32 slot = keccak256(abi.encode(this, block.timestamp, gasleft()));\\n        UNIQUE_SAFEGUARD_SLOT = slot;\\n        assembly {\\n            sstore(slot, 42)\\n        }\\n    }\\n\\n    modifier notCalledDirectly() {\\n        {\\n            // Prevent too many local variables in stack.\\n            uint256 safeGuardValue;\\n            bytes32 slot = UNIQUE_SAFEGUARD_SLOT;\\n            assembly {\\n                safeGuardValue := sload(slot)\\n            }\\n            require(safeGuardValue == 0, \\\"DIRECT_CALL_DISALLOWED\\\");\\n        }\\n        _;\\n    }\\n}\\n\"},\"ContractInitializer.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/**\\n  Interface for contract initialization.\\n  The functions it exposes are the app specific parts of the contract initialization,\\n  and are called by the ProxySupport contract that implement the generic part of behind-proxy\\n  initialization.\\n*/\\nabstract contract ContractInitializer {\\n    function isInitialized() internal view virtual returns (bool);\\n\\n    function validateInitData(bytes calldata data) internal pure virtual;\\n\\n    function initializeContractState(bytes calldata data) internal virtual;\\n}\\n\"},\"Governance.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MGovernance.sol\\\";\\n\\n/*\\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\\n  Notes:\\n   The use of the same function names by both the Proxy and a delegated implementation\\n   is not possible since calling the implementation functions is done via the default function\\n   of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\\n   exposes mainIsGovernor, which calls the internal isGovernor method.\\n*/\\nabstract contract Governance is MGovernance {\\n    event LogNominatedGovernor(address nominatedGovernor);\\n    event LogNewGovernorAccepted(address acceptedGovernor);\\n    event LogRemovedGovernor(address removedGovernor);\\n    event LogNominationCancelled();\\n\\n    function getGovernanceInfo() internal view virtual returns (GovernanceInfoStruct storage);\\n\\n    /*\\n      Current code intentionally prevents governance re-initialization.\\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\\n      performs an initialization (for real) and within that calls initGovernance().\\n\\n      Possible workarounds:\\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\\n         This will remove existing main governance information.\\n      2. Modify the require part in this function, so that it will exit quietly\\n         when trying to re-initialize (uncomment the lines below).\\n    */\\n    function initGovernance() internal {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(!gub.initialized, \\\"ALREADY_INITIALIZED\\\");\\n        gub.initialized = true; // to ensure addGovernor() won\\u0027t fail.\\n        // Add the initial governer.\\n        addGovernor(msg.sender);\\n    }\\n\\n    function isGovernor(address testGovernor) internal view override returns (bool) {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        return gub.effectiveGovernors[testGovernor];\\n    }\\n\\n    /*\\n      Cancels the nomination of a governor candidate.\\n    */\\n    function cancelNomination() internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        gub.candidateGovernor = address(0x0);\\n        emit LogNominationCancelled();\\n    }\\n\\n    function nominateNewGovernor(address newGovernor) internal onlyGovernance {\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(!isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        gub.candidateGovernor = newGovernor;\\n        emit LogNominatedGovernor(newGovernor);\\n    }\\n\\n    /*\\n      The addGovernor is called in two cases:\\n      1. by acceptGovernance when a new governor accepts its role.\\n      2. by initGovernance to add the initial governor.\\n      The difference is that the init path skips the nominate step\\n      that would fail because of the onlyGovernance modifier.\\n    */\\n    function addGovernor(address newGovernor) private {\\n        require(!isGovernor(newGovernor), \\\"ALREADY_GOVERNOR\\\");\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        gub.effectiveGovernors[newGovernor] = true;\\n    }\\n\\n    function acceptGovernance() internal {\\n        // The new governor was proposed as a candidate by the current governor.\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(msg.sender == gub.candidateGovernor, \\\"ONLY_CANDIDATE_GOVERNOR\\\");\\n\\n        // Update state.\\n        addGovernor(gub.candidateGovernor);\\n        gub.candidateGovernor = address(0x0);\\n\\n        // Send a notification about the change of governor.\\n        emit LogNewGovernorAccepted(msg.sender);\\n    }\\n\\n    /*\\n      Remove a governor from office.\\n    */\\n    function removeGovernor(address governorForRemoval) internal onlyGovernance {\\n        require(msg.sender != governorForRemoval, \\\"GOVERNOR_SELF_REMOVE\\\");\\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\\n        require(isGovernor(governorForRemoval), \\\"NOT_GOVERNOR\\\");\\n        gub.effectiveGovernors[governorForRemoval] = false;\\n        emit LogRemovedGovernor(governorForRemoval);\\n    }\\n}\\n\"},\"IFactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/*\\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\\n  business logic of the contract flow.\\n\\n  A fact registry holds a hash table of verified \\\"facts\\\" which are represented by a hash of claims\\n  that the registry hash check and found valid. This table may be queried by accessing the\\n  isValid() function of the registry with a given hash.\\n\\n  In addition, each fact registry exposes a registry specific function for submitting new claims\\n  together with their proofs. The information submitted varies from one registry to the other\\n  depending of the type of fact requiring verification.\\n\\n  For further reading on the Fact Registry design pattern see this\\n  `StarkWare blog post \\u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\\u003e`_.\\n*/\\ninterface IFactRegistry {\\n    /*\\n      Returns true if the given fact was previously registered in the contract.\\n    */\\n    function isValid(bytes32 fact) external view returns (bool);\\n}\\n\"},\"IIdentity.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\ninterface IIdentity {\\n    /*\\n      Allows a caller to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify() external pure returns (string memory);\\n}\\n\"},\"IStarknetMessaging.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.6.12;\\n\\ninterface IStarknetMessaging {\\n    // This event needs to be compatible with the one defined in Output.sol.\\n    event LogMessageToL1(\\n        uint256 indexed from_address,\\n        address indexed to_address,\\n        uint256[] payload\\n    );\\n\\n    // An event that is raised when a message is sent from L1 to L2.\\n    event LogMessageToL2(\\n        address indexed from_address,\\n        uint256 indexed to_address,\\n        uint256 indexed selector,\\n        uint256[] payload\\n    );\\n\\n    // An event that is raised when a message from L2 to L1 is consumed.\\n    event ConsumedMessageToL1(\\n        uint256 indexed from_address,\\n        address indexed to_address,\\n        uint256[] payload\\n    );\\n\\n    // An event that is raised when a message from L1 to L2 is consumed.\\n    event ConsumedMessageToL2(\\n        address indexed from_address,\\n        uint256 indexed to_address,\\n        uint256 indexed selector,\\n        uint256[] payload\\n    );\\n\\n    /**\\n      Sends a message to an L2 contract.\\n\\n      Returns the hash of the message.\\n    */\\n    function sendMessageToL2(\\n        uint256 to_address,\\n        uint256 selector,\\n        uint256[] calldata payload\\n    ) external returns (bytes32);\\n\\n    /**\\n      Consumes a message that was sent from an L2 contract.\\n\\n      Returns the hash of the message.\\n    */\\n    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\\n        external\\n        returns (bytes32);\\n}\\n\"},\"MGovernance.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nstruct GovernanceInfoStruct {\\n    mapping(address =\\u003e bool) effectiveGovernors;\\n    address candidateGovernor;\\n    bool initialized;\\n}\\n\\nabstract contract MGovernance {\\n    function isGovernor(address testGovernor) internal view virtual returns (bool);\\n\\n    /*\\n      Allows calling the function only by a Governor.\\n    */\\n    modifier onlyGovernance() {\\n        require(isGovernor(msg.sender), \\\"ONLY_GOVERNANCE\\\");\\n        _;\\n    }\\n}\\n\"},\"MOperator.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MGovernance.sol\\\";\\n\\nabstract contract MOperator {\\n    event LogOperatorAdded(address operator);\\n    event LogOperatorRemoved(address operator);\\n\\n    function isOperator(address testedOperator) public view virtual returns (bool);\\n\\n    modifier onlyOperator() {\\n        require(isOperator(msg.sender), \\\"ONLY_OPERATOR\\\");\\n        _;\\n    }\\n\\n    function registerOperator(address newOperator) external virtual;\\n\\n    function unregisterOperator(address removedOperator) external virtual;\\n\\n    function getOperators() internal view virtual returns (mapping(address =\\u003e bool) storage);\\n}\\n\"},\"NamedStorage.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\n/*\\n  Library to provide basic storage, in storage location out of the low linear address space.\\n\\n  New types of storage variables should be added here upon need.\\n*/\\nlibrary NamedStorage {\\n    function bytes32ToUint256Mapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 =\\u003e uint256) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable_slot := location\\n        }\\n    }\\n\\n    function bytes32ToAddressMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(bytes32 =\\u003e address) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable_slot := location\\n        }\\n    }\\n\\n    function addressToBoolMapping(string memory tag_)\\n        internal\\n        pure\\n        returns (mapping(address =\\u003e bool) storage randomVariable)\\n    {\\n        bytes32 location = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            randomVariable_slot := location\\n        }\\n    }\\n\\n    function getUintValue(string memory tag_) internal view returns (uint256 retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setUintValue(string memory tag_, uint256 value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function setUintValueOnce(string memory tag_, uint256 value) internal {\\n        require(getUintValue(tag_) == 0, \\\"ALREADY_SET\\\");\\n        setUintValue(tag_, value);\\n    }\\n\\n    function getAddressValue(string memory tag_) internal view returns (address retVal) {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            retVal := sload(slot)\\n        }\\n    }\\n\\n    function setAddressValue(string memory tag_, address value) internal {\\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function setAddressValueOnce(string memory tag_, address value) internal {\\n        require(getAddressValue(tag_) == address(0x0), \\\"ALREADY_SET\\\");\\n        setAddressValue(tag_, value);\\n    }\\n}\\n\"},\"OnchainDataFactTreeEncoder.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nlibrary OnchainDataFactTreeEncoder {\\n    struct DataAvailabilityFact {\\n        uint256 onchainDataHash;\\n        uint256 onchainDataSize;\\n    }\\n\\n    // The number of additional words appended to the public input when using the\\n    // OnchainDataFactTreeEncoder format.\\n    uint256 internal constant ONCHAIN_DATA_FACT_ADDITIONAL_WORDS = 2;\\n\\n    /*\\n      Encodes a GPS fact Merkle tree where the root has two children.\\n      The left child contains the data we care about and the right child contains\\n      on-chain data for the fact.\\n    */\\n    function encodeFactWithOnchainData(\\n        uint256[] calldata programOutput,\\n        DataAvailabilityFact memory factData\\n    ) internal pure returns (bytes32) {\\n        // The state transition fact is computed as a Merkle tree, as defined in\\n        // GpsOutputParser.\\n        //\\n        // In our case the fact tree looks as follows:\\n        //   The root has two children.\\n        //   The left child is a leaf that includes the main part - the information regarding\\n        //   the state transition required by this contract.\\n        //   The right child contains the onchain-data which shouldn\\u0027t be accessed by this\\n        //   contract, so we are only given its hash and length\\n        //   (it may be a leaf or an inner node, this has no effect on this contract).\\n\\n        // Compute the hash without the two additional fields.\\n        uint256 mainPublicInputLen = programOutput.length;\\n        bytes32 mainPublicInputHash = keccak256(abi.encodePacked(programOutput));\\n\\n        // Compute the hash of the fact Merkle tree.\\n        bytes32 hashResult = keccak256(\\n            abi.encodePacked(\\n                mainPublicInputHash,\\n                mainPublicInputLen,\\n                factData.onchainDataHash,\\n                mainPublicInputLen + factData.onchainDataSize\\n            )\\n        );\\n        // Add one to the hash to indicate it represents an inner node, rather than a leaf.\\n        return bytes32(uint256(hashResult) + 1);\\n    }\\n}\\n\"},\"Operator.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"MOperator.sol\\\";\\nimport \\\"MGovernance.sol\\\";\\n\\n/**\\n  The Operator of the contract is the entity entitled to submit state update requests\\n  by calling :sol:func:`updateState`.\\n\\n  An Operator may be instantly appointed or removed by the contract Governor\\n  (see :sol:mod:`Governance`). Typically, the Operator is the hot wallet of the service\\n  submitting proofs for state updates.\\n*/\\nabstract contract Operator is MGovernance, MOperator {\\n    function registerOperator(address newOperator) external override onlyGovernance {\\n        getOperators()[newOperator] = true;\\n        emit LogOperatorAdded(newOperator);\\n    }\\n\\n    function unregisterOperator(address removedOperator) external override onlyGovernance {\\n        getOperators()[removedOperator] = false;\\n        emit LogOperatorRemoved(removedOperator);\\n    }\\n\\n    function isOperator(address testedOperator) public view override returns (bool) {\\n        return getOperators()[testedOperator];\\n    }\\n}\\n\"},\"Output.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nlibrary CommitmentTreeUpdateOutput {\\n    /**\\n      Returns the previous commitment tree root.\\n    */\\n    function getPrevRoot(uint256[] calldata commitment_tree_update_data)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return commitment_tree_update_data[0];\\n    }\\n\\n    /**\\n      Returns the new commitment tree root.\\n    */\\n    function getNewRoot(uint256[] calldata commitment_tree_update_data)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return commitment_tree_update_data[1];\\n    }\\n}\\n\\nlibrary StarknetOutput {\\n    uint256 internal constant MERKLE_UPDATE_OFFSET = 0;\\n    uint256 internal constant HEADER_SIZE = 2;\\n\\n    uint256 constant MESSAGE_FROM_ADDRESS_OFFSET = 0;\\n    uint256 constant MESSAGE_TO_ADDRESS_OFFSET = 1;\\n    uint256 constant MESSAGE_PAYLOAD_SIZE_OFFSET = 2;\\n    uint256 constant MESSAGE_PREFIX_SIZE = 3;\\n    uint256 constant SELECTOR_SIZE = 1;\\n\\n    // An event that is raised when a message is sent from L2 to L1.\\n    event LogMessageToL1(\\n        uint256 indexed from_address,\\n        address indexed to_address,\\n        uint256[] payload\\n    );\\n\\n    // An event that is raised when a message from L1 to L2 is consumed.\\n    event ConsumedMessageToL2(\\n        address indexed from_address,\\n        uint256 indexed to_address,\\n        uint256 indexed selector,\\n        uint256[] payload\\n    );\\n\\n    /**\\n      Does a sanity check of the output_data length.\\n    */\\n    function validate(uint256[] calldata output_data) internal pure {\\n        require(output_data.length \\u003e HEADER_SIZE, \\\"STARKNET_OUTPUT_TOO_SHORT\\\");\\n    }\\n\\n    /**\\n      Returns a slice of the \\u0027output_data\\u0027 with the commitment tree update information.\\n    */\\n    function getMerkleUpdate(uint256[] calldata output_data)\\n        internal\\n        pure\\n        returns (uint256[] calldata)\\n    {\\n        return output_data[MERKLE_UPDATE_OFFSET:MERKLE_UPDATE_OFFSET + 2];\\n    }\\n\\n    /**\\n      Processes a message segment from the program output.\\n      The format of a message segment is the length of the messages in words followed\\n      by the concatenation of all the messages.\\n\\n      The \\u0027messages\\u0027 mapping is updated according to the messages and the direction (\\u0027isL2ToL1\\u0027).\\n    */\\n    function processMessages(\\n        bool isL2ToL1,\\n        uint256[] calldata programOutputSlice,\\n        mapping(bytes32 =\\u003e uint256) storage messages\\n    ) internal returns (uint256) {\\n        uint256 message_segment_size = programOutputSlice[0];\\n        require(message_segment_size \\u003c 2**30, \\\"INVALID_MESSAGE_SEGMENT_SIZE\\\");\\n\\n        uint256 offset = 1;\\n        uint256 message_segment_end = offset + message_segment_size;\\n        while (offset \\u003c message_segment_end) {\\n            uint256 payloadLengthOffset = offset + MESSAGE_PAYLOAD_SIZE_OFFSET;\\n            require(payloadLengthOffset \\u003c programOutputSlice.length, \\\"MESSAGE_TOO_SHORT\\\");\\n\\n            uint256 payloadLength = programOutputSlice[payloadLengthOffset];\\n            require(payloadLength \\u003c 2**30, \\\"INVALID_PAYLOAD_LENGTH\\\");\\n\\n            uint256 endOffset = offset + MESSAGE_PREFIX_SIZE + payloadLength;\\n            require(endOffset \\u003c= programOutputSlice.length, \\\"TRUNCATED_MESSAGE_PAYLOAD\\\");\\n\\n            bytes32 messageHash = keccak256(abi.encodePacked(programOutputSlice[offset:endOffset]));\\n            if (isL2ToL1) {\\n                emit LogMessageToL1(\\n                    // from=\\n                    programOutputSlice[offset + MESSAGE_FROM_ADDRESS_OFFSET],\\n                    // to=\\n                    address(programOutputSlice[offset + MESSAGE_TO_ADDRESS_OFFSET]),\\n                    // payload=\\n                    (uint256[])(programOutputSlice[offset + MESSAGE_PREFIX_SIZE:endOffset])\\n                );\\n                messages[messageHash] += 1;\\n            } else {\\n                require(messages[messageHash] \\u003e 0, \\\"INVALID_MESSAGE_TO_CONSUME\\\");\\n\\n                // Note that in the case of a message from L1 to L2, the selector (a single integer)\\n                // is prepended to the payload.\\n                emit ConsumedMessageToL2(\\n                    // from=\\n                    address(programOutputSlice[offset + MESSAGE_FROM_ADDRESS_OFFSET]),\\n                    // to=\\n                    programOutputSlice[offset + MESSAGE_TO_ADDRESS_OFFSET],\\n                    // selector=\\n                    programOutputSlice[offset + MESSAGE_PREFIX_SIZE],\\n                    // payload=\\n                    (uint256[])(programOutputSlice[offset + MESSAGE_PREFIX_SIZE + 1:endOffset])\\n                );\\n                messages[messageHash] -= 1;\\n            }\\n\\n            offset = endOffset;\\n        }\\n        require(offset == message_segment_end, \\\"INVALID_MESSAGE_SEGMENT_SIZE\\\");\\n\\n        return offset;\\n    }\\n}\\n\"},\"ProxySupport.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"ContractInitializer.sol\\\";\\nimport \\\"Governance.sol\\\";\\nimport \\\"BlockDirectCall.sol\\\";\\n\\n/**\\n  This contract contains the code commonly needed for a contract to be deployed behind\\n  an upgradability proxy.\\n  It perform the required semantics of the proxy pattern,\\n  but in a generic manner.\\n  Instantiation of the Governance and of the ContractInitializer, that are the app specific\\n  part of initialization, has to be done by the using contract.\\n*/\\nabstract contract ProxySupport is Governance, BlockDirectCall, ContractInitializer {\\n    // The two function below (isFrozen \\u0026 initialize) needed to bind to the Proxy.\\n    function isFrozen() external pure returns (bool) {\\n        return false;\\n    }\\n\\n    /*\\n      The initialize() function serves as an alternative constructor for a proxied deployment.\\n\\n      Flow and notes:\\n      1. This function cannot be called directly on the deployed contract, but only via degegate call.\\n      2. If the contract is already initialized, calling this function is allowed only with an empty data\\n    */\\n    function initialize(bytes calldata data) external notCalledDirectly {\\n        // Already initialized. Only empty init vector allowed (for upgrade).\\n        if (isInitialized()) {\\n            require(data.length == 0, \\\"ALREADY_INITIALIZED\\\");\\n            return;\\n        }\\n\\n        // Contract was not initialized yet.\\n        validateInitData(data);\\n        initializeContractState(data);\\n        initGovernance();\\n    }\\n}\\n\"},\"Starknet.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"IFactRegistry.sol\\\";\\nimport \\\"IIdentity.sol\\\";\\nimport \\\"Output.sol\\\";\\nimport \\\"StarknetGovernance.sol\\\";\\nimport \\\"StarknetMessaging.sol\\\";\\nimport \\\"StarknetOperator.sol\\\";\\nimport \\\"StarknetState.sol\\\";\\nimport \\\"NamedStorage.sol\\\";\\nimport \\\"ContractInitializer.sol\\\";\\nimport \\\"ProxySupport.sol\\\";\\nimport \\\"OnchainDataFactTreeEncoder.sol\\\";\\n\\ncontract Starknet is\\n    IIdentity,\\n    StarknetMessaging,\\n    StarknetGovernance,\\n    StarknetOperator,\\n    ContractInitializer,\\n    ProxySupport\\n{\\n    using StarknetState for StarknetState.State;\\n\\n    // Logs the new state following a state update.\\n    event LogStateUpdate(uint256 globalRoot, int256 sequenceNumber);\\n\\n    // Logs a stateTransitionFact that was used to update the state.\\n    event LogStateTransitionFact(bytes32 stateTransitionFact);\\n\\n    // Random storage slot tags.\\n    string internal constant PROGRAM_HASH_TAG = \\\"STARKNET_1.0_INIT_PROGRAM_HASH_UINT\\\";\\n    string internal constant VERIFIER_ADDRESS_TAG = \\\"STARKNET_1.0_INIT_VERIFIER_ADDRESS\\\";\\n    string internal constant STATE_STRUCT_TAG = \\\"STARKNET_1.0_INIT_STARKNET_STATE_STRUCT\\\";\\n\\n    // State variable \\\"programHash\\\" access functions.\\n    function programHash() internal view returns (uint256) {\\n        return NamedStorage.getUintValue(PROGRAM_HASH_TAG);\\n    }\\n\\n    function setProgramHash(uint256 value) internal {\\n        NamedStorage.setUintValueOnce(PROGRAM_HASH_TAG, value);\\n    }\\n\\n    // State variable \\\"verifier\\\" access functions.\\n    function verifier() internal view returns (address) {\\n        return NamedStorage.getAddressValue(VERIFIER_ADDRESS_TAG);\\n    }\\n\\n    function setVerifierAddress(address value) internal {\\n        NamedStorage.setAddressValueOnce(VERIFIER_ADDRESS_TAG, value);\\n    }\\n\\n    // State variable \\\"state\\\" access functions.\\n    function state() internal pure returns (StarknetState.State storage stateStruct) {\\n        bytes32 location = keccak256(abi.encodePacked(STATE_STRUCT_TAG));\\n        assembly {\\n            stateStruct_slot := location\\n        }\\n    }\\n\\n    function isInitialized() internal view override returns (bool) {\\n        return programHash() != 0;\\n    }\\n\\n    function validateInitData(bytes calldata data) internal pure override {\\n        require(data.length == 4 * 32, \\\"ILLEGAL_INIT_DATA_SIZE\\\");\\n        uint256 programHash_ = abi.decode(data[:32], (uint256));\\n        require(programHash_ != 0, \\\"BAD_INITIALIZATION\\\");\\n    }\\n\\n    function initializeContractState(bytes calldata data) internal override {\\n        (uint256 programHash_, address verifier_, StarknetState.State memory initialState) = abi\\n            .decode(data, (uint256, address, StarknetState.State));\\n\\n        setProgramHash(programHash_);\\n        setVerifierAddress(verifier_);\\n        state().copy(initialState);\\n    }\\n\\n    /**\\n      Returns a string that identifies the contract.\\n    */\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_Starknet_2021_1\\\";\\n    }\\n\\n    /**\\n      Returns the current state root.\\n    */\\n    function stateRoot() external view returns (uint256) {\\n        return state().globalRoot;\\n    }\\n\\n    /**\\n      Returns the current sequence number.\\n    */\\n    function stateSequenceNumber() external view returns (int256) {\\n        return state().sequenceNumber;\\n    }\\n\\n    /**\\n      Updates the state of the StarkNet, based on a proof of the \\n      StarkNet OS that the state transition is valid.\\n\\n      Arguments:\\n        sequenceNumber - The expected sequence number of the new block.\\n        programOutput - The main part of the StarkNet OS program output.\\n        data_availability_fact - An encoding of the on-chain data associated\\n        with the \\u0027programOutput\\u0027.\\n    */\\n    function updateState(\\n        int256 sequenceNumber,\\n        uint256[] calldata programOutput,\\n        OnchainDataFactTreeEncoder.DataAvailabilityFact calldata data_availability_fact\\n    ) external onlyOperator {\\n        // Validate program output.\\n        StarknetOutput.validate(programOutput);\\n\\n        bytes32 stateTransitionFact = OnchainDataFactTreeEncoder.encodeFactWithOnchainData(\\n            programOutput,\\n            data_availability_fact\\n        );\\n        bytes32 sharpFact = keccak256(abi.encode(programHash(), stateTransitionFact));\\n        require(IFactRegistry(verifier()).isValid(sharpFact), \\\"NO_STATE_TRANSITION_PROOF\\\");\\n        emit LogStateTransitionFact(stateTransitionFact);\\n\\n        // Process L2 -\\u003e L1 messages.\\n        uint256 outputOffset = StarknetOutput.HEADER_SIZE;\\n        outputOffset += StarknetOutput.processMessages(\\n            // isL2ToL1=\\n            true,\\n            programOutput[outputOffset:],\\n            l2ToL1Messages()\\n        );\\n\\n        // Process L1 -\\u003e L2 messages.\\n        outputOffset += StarknetOutput.processMessages(\\n            // isL2ToL1=\\n            false,\\n            programOutput[outputOffset:],\\n            l1ToL2Messages()\\n        );\\n\\n        require(outputOffset == programOutput.length, \\\"STARKNET_OUTPUT_TOO_LONG\\\");\\n\\n        // Perform state update.\\n        state().update(sequenceNumber, programOutput);\\n        StarknetState.State memory state_ = state();\\n        emit LogStateUpdate(state_.globalRoot, state_.sequenceNumber);\\n    }\\n}\\n\"},\"StarknetGovernance.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Governance.sol\\\";\\n\\ncontract StarknetGovernance is Governance {\\n    string constant STARKNET_GOVERNANCE_INFO_TAG = \\\"STARKNET_1.0_GOVERNANCE_INFO\\\";\\n\\n    /*\\n      Returns the GovernanceInfoStruct associated with the governance tag.\\n    */\\n    function getGovernanceInfo() internal view override returns (GovernanceInfoStruct storage gub) {\\n        bytes32 location = keccak256(abi.encodePacked(STARKNET_GOVERNANCE_INFO_TAG));\\n        assembly {\\n            gub_slot := location\\n        }\\n    }\\n\\n    function starknetIsGovernor(address testGovernor) external view returns (bool) {\\n        return isGovernor(testGovernor);\\n    }\\n\\n    function starknetNominateNewGovernor(address newGovernor) external {\\n        nominateNewGovernor(newGovernor);\\n    }\\n\\n    function starknetRemoveGovernor(address governorForRemoval) external {\\n        removeGovernor(governorForRemoval);\\n    }\\n\\n    function starknetAcceptGovernance() external {\\n        acceptGovernance();\\n    }\\n\\n    function starknetCancelNomination() external {\\n        cancelNomination();\\n    }\\n}\\n\"},\"StarknetMessaging.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\npragma solidity ^0.6.12;\\n\\nimport \\\"IStarknetMessaging.sol\\\";\\nimport \\\"NamedStorage.sol\\\";\\n\\n/**\\n  Implements sending messages to L2 by adding them to a pipe and consuming messages from L2 by\\n  removing them from a different pipe. A deriving contract can handle the former pipe and add items\\n  to the latter pipe while interacting with L2.\\n*/\\ncontract StarknetMessaging is IStarknetMessaging {\\n    /**\\n      Random slot storage elements and accessors.\\n    */\\n    string constant L1L2_MESSAGE_MAP_TAG = \\\"STARKNET_1.0_MSGING_L1TOL2_MAPPPING\\\";\\n    string constant L2L1_MESSAGE_MAP_TAG = \\\"STARKNET_1.0_MSGING_L2TOL1_MAPPPING\\\";\\n\\n    function l1ToL2Messages(bytes32 msgHash) external view returns (uint256) {\\n        return l1ToL2Messages()[msgHash];\\n    }\\n\\n    function l2ToL1Messages(bytes32 msgHash) external view returns (uint256) {\\n        return l2ToL1Messages()[msgHash];\\n    }\\n\\n    function l1ToL2Messages() internal pure returns (mapping(bytes32 =\\u003e uint256) storage) {\\n        return NamedStorage.bytes32ToUint256Mapping(L1L2_MESSAGE_MAP_TAG);\\n    }\\n\\n    function l2ToL1Messages() internal pure returns (mapping(bytes32 =\\u003e uint256) storage) {\\n        return NamedStorage.bytes32ToUint256Mapping(L2L1_MESSAGE_MAP_TAG);\\n    }\\n\\n    /**\\n      Sends a message to an L2 contract.\\n    */\\n    function sendMessageToL2(\\n        uint256 to_address,\\n        uint256 selector,\\n        uint256[] calldata payload\\n    ) external override returns (bytes32) {\\n        emit LogMessageToL2(msg.sender, to_address, selector, payload);\\n        // Note that the selector (a single integer) is prepended to the payload.\\n        bytes32 msgHash = keccak256(\\n            abi.encodePacked(uint256(msg.sender), to_address, 1 + payload.length, selector, payload)\\n        );\\n        l1ToL2Messages()[msgHash] += 1;\\n        return msgHash;\\n    }\\n\\n    /**\\n      Consumes a message that was sent from an L2 contract.\\n\\n      Returns the hash of the message.\\n    */\\n    function consumeMessageFromL2(uint256 from_address, uint256[] calldata payload)\\n        external\\n        override\\n        returns (bytes32)\\n    {\\n        bytes32 msgHash = keccak256(\\n            abi.encodePacked(from_address, uint256(msg.sender), payload.length, payload)\\n        );\\n\\n        require(l2ToL1Messages()[msgHash] \\u003e 0, \\\"INVALID_MESSAGE_TO_CONSUME\\\");\\n        emit ConsumedMessageToL1(from_address, msg.sender, payload);\\n        l2ToL1Messages()[msgHash] -= 1;\\n        return msgHash;\\n    }\\n}\\n\"},\"StarknetOperator.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"NamedStorage.sol\\\";\\nimport \\\"Operator.sol\\\";\\n\\nabstract contract StarknetOperator is Operator {\\n    string constant OPERATORS_MAPPING_TAG = \\\"STARKNET_1.0_ROLES_OPERATORS_MAPPING_TAG\\\";\\n\\n    function getOperators() internal view override returns (mapping(address =\\u003e bool) storage) {\\n        return NamedStorage.addressToBoolMapping(OPERATORS_MAPPING_TAG);\\n    }\\n}\\n\"},\"StarknetState.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.12;\\n\\nimport \\\"Output.sol\\\";\\n\\nlibrary StarknetState {\\n    struct State {\\n        uint256 globalRoot;\\n        int256 sequenceNumber;\\n    }\\n\\n    function copy(State storage state, State memory stateFrom) internal {\\n        state.globalRoot = stateFrom.globalRoot;\\n        state.sequenceNumber = stateFrom.sequenceNumber;\\n    }\\n\\n    /**\\n      Validates that the \\u0027sequenceNumber\\u0027 and the previous root are consistent with the\\n      current state and updates the state.\\n    */\\n    function update(\\n        State storage state,\\n        int256 sequenceNumber,\\n        uint256[] calldata starknetOutput\\n    ) internal {\\n        // Check the sequenceNumber first as the error is less ambiguous then INVALID_PREVIOUS_ROOT.\\n        state.sequenceNumber += 1;\\n        require(state.sequenceNumber == sequenceNumber, \\\"INVALID_SEQUENCE_NUMBER\\\");\\n\\n        uint256[] calldata commitment_tree_update = StarknetOutput.getMerkleUpdate(starknetOutput);\\n        require(\\n            state.globalRoot == CommitmentTreeUpdateOutput.getPrevRoot(commitment_tree_update),\\n            \\\"INVALID_PREVIOUS_ROOT\\\"\\n        );\\n        state.globalRoot = CommitmentTreeUpdateOutput.getNewRoot(commitment_tree_update);\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"from_address\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"payload\",\"type\":\"uint256[]\"}],\"name\":\"ConsumedMessageToL1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"to_address\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"selector\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"payload\",\"type\":\"uint256[]\"}],\"name\":\"ConsumedMessageToL2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"from_address\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"payload\",\"type\":\"uint256[]\"}],\"name\":\"LogMessageToL1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"to_address\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"selector\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"payload\",\"type\":\"uint256[]\"}],\"name\":\"LogMessageToL2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"acceptedGovernor\",\"type\":\"address\"}],\"name\":\"LogNewGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominatedGovernor\",\"type\":\"address\"}],\"name\":\"LogNominatedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogNominationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"LogOperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"LogOperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGovernor\",\"type\":\"address\"}],\"name\":\"LogRemovedGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"stateTransitionFact\",\"type\":\"bytes32\"}],\"name\":\"LogStateTransitionFact\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"globalRoot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"sequenceNumber\",\"type\":\"int256\"}],\"name\":\"LogStateUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from_address\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"payload\",\"type\":\"uint256[]\"}],\"name\":\"consumeMessageFromL2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testedOperator\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"l1ToL2Messages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"l2ToL1Messages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"registerOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"to_address\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selector\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"payload\",\"type\":\"uint256[]\"}],\"name\":\"sendMessageToL2\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starknetAcceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starknetCancelNomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"testGovernor\",\"type\":\"address\"}],\"name\":\"starknetIsGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"starknetNominateNewGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governorForRemoval\",\"type\":\"address\"}],\"name\":\"starknetRemoveGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stateRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stateSequenceNumber\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"removedOperator\",\"type\":\"address\"}],\"name\":\"unregisterOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"sequenceNumber\",\"type\":\"int256\"},{\"internalType\":\"uint256[]\",\"name\":\"programOutput\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"onchainDataHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"onchainDataSize\",\"type\":\"uint256\"}],\"internalType\":\"struct OnchainDataFactTreeEncoder.DataAvailabilityFact\",\"name\":\"data_availability_fact\",\"type\":\"tuple\"}],\"name\":\"updateState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Starknet","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b414f49d7a7fdce0670d7a798822fd471cda60098d14b9d6fb68ede5573fbd44"}]}