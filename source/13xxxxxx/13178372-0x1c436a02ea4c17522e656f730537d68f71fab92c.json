{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SushiswapSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IUniswapV2Pair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function token1() external view returns (address);\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n}\\n\\ninterface Sushiswap {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\\ncontract SushiswapSwap {\\n    address public weth;\\n    address public sushiswap;\\n    IERC20 public outputToken;\\n    address public swapOutputDestinationAddress;\\n    address public swapController;\\n    address public pairAddress;\\n    uint256 public maxSlippagePercentageBasisPoints;\\n\\n    event SwapForMinimum(uint256 wethAmount, uint256 minOutputTokenAmount);\\n\\n    constructor(\\n        address _outputTokenAddress,\\n        address _swapOutputDestinationAddress,\\n        address _swapController,\\n        address _pairAddress,\\n        address _wethAddress,\\n        address _sushiswapAddress,\\n        uint256 _maxSlippagePercentageBasisPoints\\n    ) {\\n        outputToken = IERC20(_outputTokenAddress);\\n        swapOutputDestinationAddress = _swapOutputDestinationAddress;\\n        swapController = _swapController;\\n        pairAddress = _pairAddress;\\n        weth = _wethAddress;\\n        sushiswap = _sushiswapAddress;\\n        IERC20(weth).approve(_sushiswapAddress, type(uint256).max);\\n        maxSlippagePercentageBasisPoints = _maxSlippagePercentageBasisPoints;\\n    }\\n\\n    modifier onlySwapController() {\\n        require(msg.sender == swapController, \\\"Only swapController may call this function.\\\");\\n        _;\\n    }\\n\\n    function swap() public {\\n        uint256 minimumAcceptableBuyAmount = getMinAcceptableBuyAmount();\\n\\n        IWETH(weth).deposit{value: address(this).balance}();\\n        uint256 amountIn = IERC20(weth).balanceOf(address(this));\\n\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = address(outputToken);\\n\\n        emit SwapForMinimum(amountIn, minimumAcceptableBuyAmount);\\n\\n        Sushiswap(sushiswap).swapExactTokensForTokens(\\n            amountIn,\\n            minimumAcceptableBuyAmount,\\n            path,\\n            swapOutputDestinationAddress,\\n            block.timestamp\\n        );\\n    }\\n\\n    function getMinAcceptableBuyAmount() public view returns(uint256) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n        (uint Res0, uint Res1,) = pair.getReserves();\\n        uint res0 = Res0*(10**18);\\n        uint256 price = address(this).balance / (res0/Res1);\\n        uint256 minimumAcceptableBuy = ((price * (10000 - maxSlippagePercentageBasisPoints))*(10**18)) / 10000;\\n        return minimumAcceptableBuy;\\n    }\\n\\n    function setMaxSlippagePercentageBasisPoints(uint256 _maxSlippagePercentageBasisPoints) public onlySwapController {\\n        require(_maxSlippagePercentageBasisPoints > 0, \\\"_maxSlippagePercentageBasisPoints must be more than zero\\\");\\n        maxSlippagePercentageBasisPoints = _maxSlippagePercentageBasisPoints;\\n    }\\n\\n    receive() external payable {}\\n\\n    // Failure case fallback functions below\\n\\n    function fallbackSwap(uint256 _amountOutMin) public onlySwapController {\\n        IWETH(weth).deposit{value: address(this).balance}();\\n        uint256 amountIn = IERC20(weth).balanceOf(address(this));\\n\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = address(outputToken);\\n\\n        emit SwapForMinimum(amountIn, _amountOutMin);\\n\\n        Sushiswap(sushiswap).swapExactTokensForTokens(\\n            amountIn,\\n            _amountOutMin,\\n            path,\\n            swapOutputDestinationAddress,\\n            block.timestamp\\n        );\\n    }\\n\\n    function emergencyExit() public onlySwapController {\\n        (bool success, ) = swapController.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Emergency exit failed.\\\");\\n    }\\n\\n    function emergencyExitToEndpoint(address endpoint) public onlySwapController {\\n        (bool success, ) = endpoint.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Emergency exit to endpoint failed.\\\");\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_outputTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapOutputDestinationAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pairAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiswapAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSlippagePercentageBasisPoints\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minOutputTokenAmount\",\"type\":\"uint256\"}],\"name\":\"SwapForMinimum\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"endpoint\",\"type\":\"address\"}],\"name\":\"emergencyExitToEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"fallbackSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinAcceptableBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippagePercentageBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outputToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippagePercentageBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippagePercentageBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapOutputDestinationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SushiswapSwap","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ca3fe04c7ee111f0bbb02c328c699226acf9fd3300000000000000000000000038747baf050d3c22315a761585868dba16abfd890000000000000000000000004a25e18076ddcfd646ed14abc07286c2a4c1256a000000000000000000000000c5fa164247d2f8d68804139457146efbde8370f6000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f00000000000000000000000000000000000000000000000000000000000000fa","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}