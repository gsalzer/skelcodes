{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NYM/NymLibUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"../lib/encode/Base58.sol\\\";\\r\\nimport \\\"./INymLib.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title NymLibUpgradeable\\r\\n * @dev This contract is needed to avoid code size exceeds 24576 bytes\\r\\n */\\r\\ncontract NymLibUpgradeable is INymLib {\\r\\n\\r\\n    function toBase58(bytes memory source) external pure override returns (string memory) {\\r\\n        return Base58.toBase58(source);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\\r\\n     */\\r\\n    function validateName(string memory str) external pure override returns (bool) {\\r\\n        bytes memory b = bytes(str);\\r\\n        if (b.length < 1) return false;\\r\\n        if (b.length > 25) return false; // Cannot be longer than 25 characters\\r\\n        if (b[0] == 0x20) return false; // Leading space\\r\\n        if (b[b.length - 1] == 0x20) return false; // Trailing space\\r\\n\\r\\n        bytes1 lastChar = b[0];\\r\\n\\r\\n        for(uint i=0; i<b.length; i++){\\r\\n            bytes1 char = b[i];\\r\\n\\r\\n            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\\r\\n\\r\\n            if(\\r\\n                !(char >= 0x30 && char <= 0x39) && //9-0\\r\\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\\r\\n                !(char >= 0x61 && char <= 0x7A) && //a-z\\r\\n                !(char == 0x20) //space\\r\\n            )\\r\\n                return false;\\r\\n\\r\\n            lastChar = char;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts the string to lowercase\\r\\n     */\\r\\n    function toLower(string memory str) external pure override returns (string memory) {\\r\\n        bytes memory bStr = bytes(str);\\r\\n        bytes memory bLower = new bytes(bStr.length);\\r\\n        for (uint i = 0; i < bStr.length; i++) {\\r\\n            // Uppercase character\\r\\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\\r\\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\\r\\n            } else {\\r\\n                bLower[i] = bStr[i];\\r\\n            }\\r\\n        }\\r\\n        return string(bLower);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/encode/Base58.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nlibrary Base58 {\\r\\n    // Internal variables\\r\\n    bytes internal constant _ALPHABET = \\\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\\";\\r\\n\\r\\n    // Source: verifyIPFS (https://github.com/MrChico/verifyIPFS/blob/master/contracts/verifyIPFS.sol)\\r\\n    // @author Martin Lundfall (martin.lundfall@consensys.net)\\r\\n    // @dev Converts hex string to base 58\\r\\n    function toBase58(bytes memory source) internal pure returns (string memory)\\r\\n    {\\r\\n        if (source.length == 0) return new string(0);\\r\\n        uint8[] memory digits = new uint8[](46);\\r\\n        digits[0] = 0;\\r\\n        uint8 digitlength = 1;\\r\\n        for (uint256 i = 0; i < source.length; ++i) {\\r\\n            uint256 carry = uint8(source[i]);\\r\\n            for (uint256 j = 0; j < digitlength; ++j) {\\r\\n                carry += uint256(digits[j]) * 256;\\r\\n                digits[j] = uint8(carry % 58);\\r\\n                carry = carry / 58;\\r\\n            }\\r\\n\\r\\n            while (carry > 0) {\\r\\n                digits[digitlength] = uint8(carry % 58);\\r\\n                digitlength++;\\r\\n                carry = carry / 58;\\r\\n            }\\r\\n        }\\r\\n        return string(_toAlphabet(_reverse(_truncate(digits, digitlength))));\\r\\n    }\\r\\n\\r\\n    function _truncate(uint8[] memory array, uint8 length) internal pure returns (uint8[] memory)\\r\\n    {\\r\\n        uint8[] memory output = new uint8[](length);\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            output[i] = array[i];\\r\\n        }\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    function _reverse(uint8[] memory input) internal pure returns (uint8[] memory)\\r\\n    {\\r\\n        uint8[] memory output = new uint8[](input.length);\\r\\n        for (uint256 i = 0; i < input.length; i++) {\\r\\n            output[i] = input[input.length - 1 - i];\\r\\n        }\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    function _toAlphabet(uint8[] memory indices) internal pure returns (bytes memory)\\r\\n    {\\r\\n        bytes memory output = new bytes(indices.length);\\r\\n        for (uint256 i = 0; i < indices.length; i++) {\\r\\n            output[i] = _ALPHABET[indices[i]];\\r\\n        }\\r\\n        return output;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/NYM/INymLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier:MIT\\npragma solidity 0.7.6;\\n\\ninterface INymLib {\\n    function toBase58(bytes memory source) external pure returns (string memory);\\n    function validateName(string memory str) external pure returns (bool);\\n    function toLower(string memory str) external pure returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"source\",\"type\":\"bytes\"}],\"name\":\"toBase58\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"toLower\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"validateName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"NymLibUpgradeable","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}