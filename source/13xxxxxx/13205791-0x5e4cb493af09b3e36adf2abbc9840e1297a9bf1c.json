{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PRBProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\nimport \\\"./IPRBProxyFactory.sol\\\";\\nimport \\\"./IPRBProxyRegistry.sol\\\";\\n\\n/// @notice Emitted when a proxy already exists for the given owner.\\nerror PRBProxyRegistry__ProxyAlreadyExists(address owner);\\n\\n/// @title PRBProxyRegistry\\n/// @author Paul Razvan Berg\\ncontract PRBProxyRegistry is IPRBProxyRegistry {\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    IPRBProxyFactory public override factory;\\n\\n    /// INTERNAL STORAGE ///\\n\\n    /// @notice Internal mapping of owners to current proxies.\\n    mapping(address => IPRBProxy) internal currentProxies;\\n\\n    /// CONSTRUCTOR ///\\n\\n    constructor(IPRBProxyFactory factory_) {\\n        factory = factory_;\\n    }\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function getCurrentProxy(address owner) public view override returns (IPRBProxy proxy) {\\n        proxy = currentProxies[owner];\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deploy() external override returns (address payable proxy) {\\n        proxy = deployFor(msg.sender);\\n    }\\n\\n    /// @inheritdoc IPRBProxyRegistry\\n    function deployFor(address owner) public override returns (address payable proxy) {\\n        IPRBProxy currentProxy = getCurrentProxy(owner);\\n\\n        // Do not deploy if the proxy already exists and the owner is the same.\\n        if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {\\n            revert PRBProxyRegistry__ProxyAlreadyExists(owner);\\n        }\\n\\n        // Deploy the proxy via the factory.\\n        proxy = factory.deployFor(owner);\\n\\n        // Set or override the current proxy for the owner.\\n        currentProxies[owner] = IPRBProxy(proxy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./access/IOwnable.sol\\\";\\n\\n/// @title IPRBProxy\\n/// @author Paul Razvan Berg\\n/// @notice Proxy contract to compose transactions on owner's behalf.\\ninterface IPRBProxy is IOwnable {\\n    /// EVENTS ///\\n\\n    event Execute(address indexed target, bytes data, bytes response);\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice How much gas should remain for executing the remainder of the assembly code.\\n    function minGasReserve() external view returns (uint256);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Delegate calls to the target contract by forwarding the call data. This function returns\\n    /// the data it gets back, including when the contract call reverts with a reason or custom error.\\n    ///\\n    /// @dev Requirements:\\n    /// - The caller must be the owner.\\n    /// - `target` must be a contract.\\n    ///\\n    /// @param target The address of the target contract.\\n    /// @param data Function selector plus ABI encoded data.\\n    /// @return response The response received from the target contract.\\n    function execute(address target, bytes memory data) external payable returns (bytes memory response);\\n\\n    /// @notice Initializes the contract by setting the address of the owner of the proxy.\\n    ///\\n    /// @dev Supposed to be called by an EIP-1167 clone.\\n    ///\\n    /// Requirements:\\n    /// - Can only be called once.\\n    ///\\n    /// @param owner_ The address of the owner of the proxy.\\n    function initialize(address owner_) external;\\n\\n    /// @notice Sets a new value for the `minGasReserve` storage variable.\\n    /// @dev Requirements:\\n    /// - The caller must be the owner.\\n    function setMinGasReserve(uint256 newMinGasReserve) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\n\\n/// @title IPRBProxyFactory\\n/// @author Paul Razvan Berg\\n/// @notice Deploys new proxy instances with CREATE2.\\ninterface IPRBProxyFactory {\\n    /// EVENTS ///\\n\\n    event DeployProxy(\\n        address indexed origin,\\n        address indexed deployer,\\n        address indexed owner,\\n        bytes32 salt,\\n        bytes32 finalSalt,\\n        address proxy\\n    );\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice Gets the next salt that will be used to deploy the proxy.\\n    /// @param eoa The externally owned account which deployed proxies.\\n    function getNextSalt(address eoa) external view returns (bytes32 result);\\n\\n    /// @notice The address of the implementation of PRBProxy.\\n    function implementation() external view returns (IPRBProxy proxy);\\n\\n    /// @notice Mapping to track all deployed proxies.\\n    /// @param proxy The address of the proxy to make the check for.\\n    function isProxy(address proxy) external view returns (bool result);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Deploys a new proxy as an EIP-1167 clone deployed via CREATE2.\\n    /// @dev Sets \\\"msg.sender\\\" as the owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deploy() external returns (address payable proxy);\\n\\n    /// @notice Deploys a new proxy as an EIP-1167 clone deployed via CREATE2, for a specific owner.\\n    ///\\n    /// @dev Requirements:\\n    /// - The CREATE2 must not have been used.\\n    ///\\n    /// @param owner The owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deployFor(address owner) external returns (address payable proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\nimport \\\"./IPRBProxyFactory.sol\\\";\\n\\n/// @title IPRBProxyRegistry\\n/// @author Paul Razvan Berg\\n/// @notice Deploys new proxy instances via the proxy factory and keeps a registry of owners to proxies. Owners can only\\n/// have one proxy at a time.\\ninterface IPRBProxyRegistry {\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice Proxy factory contract.\\n    function factory() external view returns (IPRBProxyFactory proxyFactory);\\n\\n    /// @notice Gets the current proxy that belongs to the given owner.\\n    /// @param owner The address of the owner of the current proxy.\\n    function getCurrentProxy(address owner) external view returns (IPRBProxy proxy);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Deploys a new proxy instance via the proxy factory.\\n    /// @dev Sets \\\"msg.sender\\\" as the owner of the proxy.\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"deployFor\\\".\\n    ///\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deploy() external returns (address payable proxy);\\n\\n    /// @notice Deploys a new proxy instance via the proxy factory, for the given owner.\\n    ///\\n    /// @dev Requirements:\\n    /// - The proxy must either not exist or its ownership must have been transferred by the owner.\\n    ///\\n    /// @param owner The owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deployFor(address owner) external returns (address payable proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/access/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\n/// @title IOwnable\\n/// @author Paul Razvan Berg\\n/// @notice Contract module that provides a basic access control mechanism, where there is an\\n/// account (an owner) that can be granted exclusive access to specific functions.\\n///\\n/// By default, the owner account will be the one that deploys the contract. This can later be\\n/// changed with {transfer}.\\n///\\n/// This module is used through inheritance. It will make available the modifier `onlyOwner`,\\n/// which can be applied to your functions to restrict their use to the owner.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/access/Ownable.sol\\ninterface IOwnable {\\n    /// EVENTS ///\\n\\n    /// @notice Emitted when ownership is transferred.\\n    /// @param oldOwner The address of the old owner.\\n    /// @param newOwner The address of the new owner.\\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\\n\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Leaves the contract without owner, so it will not be possible to call `onlyOwner`\\n    /// functions anymore.\\n    ///\\n    /// WARNING: Doing this will leave the contract without an owner, thereby removing any\\n    /// functionality that is only available to the owner.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - The caller must be the owner.\\n    function renounceOwnership() external;\\n\\n    /// @notice Transfers the owner of the contract to a new account (`newOwner`). Can only be\\n    /// called by the current owner.\\n    /// @param newOwner The acount of the new owner.\\n    function transferOwnership(address newOwner) external;\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice The address of the owner account or contract.\\n    /// @return The address of the owner.\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IPRBProxyFactory\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PRBProxyRegistry__ProxyAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"deployFor\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IPRBProxyFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getCurrentProxy\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PRBProxyRegistry","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000479f1cd619a9efced0338a72c8cfc42cd17b96f8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}