{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AutoGammaResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {IAutoGamma} from \\\"./interfaces/IAutoGamma.sol\\\";\\nimport {IGammaOperator} from \\\"./interfaces/IGammaOperator.sol\\\";\\nimport {IResolver} from \\\"./interfaces/IResolver.sol\\\";\\nimport {MarginVault} from \\\"./external/OpynVault.sol\\\";\\nimport {IUniswapRouter} from \\\"./interfaces/IUniswapRouter.sol\\\";\\n\\n/// @author Willy Shen\\n/// @title AutoGamma Resolver\\n/// @notice AutoGamma resolver for Gelato PokeMe checks\\ncontract AutoGammaResolver is IResolver {\\n    address public redeemer;\\n    address public uniRouter;\\n\\n    uint256 public maxSlippage = 50; // 0.5%\\n    address public owner;\\n\\n    constructor(address _redeemer, address _uniRouter) {\\n        redeemer = _redeemer;\\n        uniRouter = _uniRouter;\\n        owner = msg.sender;\\n    }\\n\\n    function setMaxSlippage(uint256 _maxSlippage) public {\\n        require(msg.sender == owner && _maxSlippage <= 500); // sanity check max slippage under 5%\\n        maxSlippage = _maxSlippage;\\n    }\\n\\n    /**\\n     * @notice return if a specific order can be processed\\n     * @param _orderId id of order\\n     * @return true if order can be proceseed without a revert\\n     */\\n    function canProcessOrder(uint256 _orderId) public view returns (bool) {\\n        IAutoGamma.Order memory order = IAutoGamma(redeemer).getOrder(_orderId);\\n\\n        if (order.isSeller) {\\n            if (\\n                !IGammaOperator(redeemer).isValidVaultId(\\n                    order.owner,\\n                    order.vaultId\\n                ) || !IGammaOperator(redeemer).isOperatorOf(order.owner)\\n            ) return false;\\n\\n            (\\n                MarginVault.Vault memory vault,\\n                uint256 typeVault,\\n\\n            ) = IGammaOperator(redeemer).getVaultWithDetails(\\n                order.owner,\\n                order.vaultId\\n            );\\n\\n            try IGammaOperator(redeemer).getVaultOtokenByVault(vault) returns (\\n                address otoken\\n            ) {\\n                if (\\n                    !IGammaOperator(redeemer).hasExpiredAndSettlementAllowed(\\n                        otoken\\n                    )\\n                ) return false;\\n\\n                (uint256 payout, bool isValidVault) = IGammaOperator(redeemer)\\n                    .getExcessCollateral(vault, typeVault);\\n                if (!isValidVault || payout == 0) return false;\\n\\n                if (order.toToken != address(0)) {\\n                    address collateral = IGammaOperator(redeemer)\\n                        .getOtokenCollateral(otoken);\\n                    if (\\n                        !IAutoGamma(redeemer).isPairAllowed(\\n                            collateral,\\n                            order.toToken\\n                        )\\n                    ) return false;\\n                }\\n            } catch {\\n                return false;\\n            }\\n        } else {\\n            if (\\n                !IGammaOperator(redeemer).hasExpiredAndSettlementAllowed(\\n                    order.otoken\\n                )\\n            ) return false;\\n\\n            if (order.toToken != address(0)) {\\n                address collateral = IGammaOperator(redeemer)\\n                    .getOtokenCollateral(order.otoken);\\n                if (\\n                    !IAutoGamma(redeemer).isPairAllowed(\\n                        collateral,\\n                        order.toToken\\n                    )\\n                ) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice return payout of an order\\n     * @param _orderId id of order\\n     * @return payoutToken token address of payout\\n     * @return payoutAmount amount of payout\\n     */\\n    function getOrderPayout(uint256 _orderId)\\n        public\\n        view\\n        returns (address payoutToken, uint256 payoutAmount)\\n    {\\n        IAutoGamma.Order memory order = IAutoGamma(redeemer).getOrder(_orderId);\\n\\n        if (order.isSeller) {\\n            (\\n                MarginVault.Vault memory vault,\\n                uint256 typeVault,\\n\\n            ) = IGammaOperator(redeemer).getVaultWithDetails(\\n                order.owner,\\n                order.vaultId\\n            );\\n\\n            address otoken = IGammaOperator(redeemer).getVaultOtokenByVault(\\n                vault\\n            );\\n            payoutToken = IGammaOperator(redeemer).getOtokenCollateral(otoken);\\n\\n            (payoutAmount, ) = IGammaOperator(redeemer).getExcessCollateral(\\n                vault,\\n                typeVault\\n            );\\n        } else {\\n            payoutToken = IGammaOperator(redeemer).getOtokenCollateral(\\n                order.otoken\\n            );\\n\\n            uint256 actualAmount = IGammaOperator(redeemer).getRedeemableAmount(\\n                order.owner,\\n                order.otoken,\\n                order.amount\\n            );\\n            payoutAmount = IGammaOperator(redeemer).getRedeemPayout(\\n                order.otoken,\\n                actualAmount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice return list of processable orderIds\\n     * @return canExec if gelato should execute\\n     * @return execPayload the function and data to be executed by gelato\\n     * @dev order is processable if:\\n     * 1. it is profitable to process (shouldProcessOrder)\\n     * 2. it can be processed without reverting (canProcessOrder)\\n     * 3. it is not included yet (for same type of orders, process it one at a time)\\n     */\\n    function getProcessableOrders()\\n        public\\n        view\\n        override\\n        returns (bool canExec, bytes memory execPayload)\\n    {\\n        IAutoGamma.Order[] memory orders = IAutoGamma(redeemer).getOrders();\\n\\n        // Only proceess duplicate orders one at a time\\n        bytes32[] memory preCheckHashes = new bytes32[](orders.length);\\n        bytes32[] memory postCheckHashes = new bytes32[](orders.length);\\n\\n        uint256 orderIdsLength;\\n        for (uint256 i = 0; i < orders.length; i++) {\\n            if (\\n                IAutoGamma(redeemer).shouldProcessOrder(i) &&\\n                canProcessOrder(i) &&\\n                !containDuplicateOrderType(orders[i], preCheckHashes)\\n            ) {\\n                preCheckHashes[i] = getOrderHash(orders[i]);\\n                orderIdsLength++;\\n            }\\n        }\\n\\n        if (orderIdsLength > 0) {\\n            canExec = true;\\n        }\\n\\n        uint256 counter;\\n        uint256[] memory orderIds = new uint256[](orderIdsLength);\\n\\n\\n            IAutoGamma.ProcessOrderArgs[] memory orderArgs\\n         = new IAutoGamma.ProcessOrderArgs[](orderIdsLength);\\n        for (uint256 i = 0; i < orders.length; i++) {\\n            if (\\n                IAutoGamma(redeemer).shouldProcessOrder(i) &&\\n                canProcessOrder(i) &&\\n                !containDuplicateOrderType(orders[i], postCheckHashes)\\n            ) {\\n                postCheckHashes[i] = getOrderHash(orders[i]);\\n                orderIds[counter] = i;\\n\\n                if (orders[i].toToken != address(0)) {\\n                    // determine amountOutMin for swap\\n                    (\\n                        address payoutToken,\\n                        uint256 payoutAmount\\n                    ) = getOrderPayout(i);\\n\\n                    payoutAmount =\\n                        payoutAmount -\\n                        ((orders[i].fee * payoutAmount) / 10_000);\\n\\n                    address[] memory path = new address[](2);\\n                    path[0] = payoutToken;\\n                    path[1] = orders[i].toToken;\\n\\n                    uint256[] memory amounts = IUniswapRouter(uniRouter)\\n                        .getAmountsOut(payoutAmount, path);\\n                    uint256 amountOutMin = amounts[1] -\\n                        ((amounts[1] * maxSlippage) / 10_000);\\n\\n                    orderArgs[counter].swapAmountOutMin = amountOutMin;\\n                    orderArgs[counter].swapPath = path;\\n                }\\n\\n                counter++;\\n            }\\n        }\\n\\n        execPayload = abi.encodeWithSelector(\\n            IAutoGamma.processOrders.selector,\\n            orderIds,\\n            orderArgs\\n        );\\n    }\\n\\n    /**\\n     * @notice return if order is already included\\n     * @param order struct to check\\n     * @param hashes list of hashed orders\\n     * @return containDuplicate if hashes already contain a same order type.\\n     */\\n    function containDuplicateOrderType(\\n        IAutoGamma.Order memory order,\\n        bytes32[] memory hashes\\n    ) public pure returns (bool containDuplicate) {\\n        bytes32 orderHash = getOrderHash(order);\\n\\n        for (uint256 j = 0; j < hashes.length; j++) {\\n            if (hashes[j] == orderHash) {\\n                containDuplicate = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice return hash of the order\\n     * @param order struct to hash\\n     * @return orderHash hash depending on the order's type\\n     */\\n    function getOrderHash(IAutoGamma.Order memory order)\\n        public\\n        pure\\n        returns (bytes32 orderHash)\\n    {\\n        if (order.isSeller) {\\n            orderHash = keccak256(abi.encode(order.owner, order.vaultId));\\n        } else {\\n            orderHash = keccak256(abi.encode(order.owner, order.otoken));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAutoGamma.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IAutoGamma {\\n    struct Order {\\n        // address of user\\n        address owner;\\n        // address of otoken to redeem\\n        address otoken;\\n        // amount of otoken to redeem\\n        uint256 amount;\\n        // vaultId of vault to settle\\n        uint256 vaultId;\\n        // true if settle vault order, else redeem otoken\\n        bool isSeller;\\n        // convert proceed to token if not address(0)\\n        address toToken;\\n        // fee in 1/10.000\\n        uint256 fee;\\n        // true if order is already processed\\n        bool finished;\\n    }\\n\\n    struct ProcessOrderArgs {\\n        // minimal swap output amount to prevent manipulation\\n        uint256 swapAmountOutMin;\\n        // swap path\\n        address[] swapPath;\\n    }\\n\\n    event OrderCreated(\\n        uint256 indexed orderId,\\n        address indexed owner,\\n        address indexed otoken\\n    );\\n    event OrderFinished(uint256 indexed orderId, bool indexed cancelled);\\n\\n    function createOrder(\\n        address _otoken,\\n        uint256 _amount,\\n        uint256 _vaultId,\\n        address _toToken\\n    ) external;\\n\\n    function cancelOrder(uint256 _orderId) external;\\n\\n    function shouldProcessOrder(uint256 _orderId) external view returns (bool);\\n\\n    function processOrder(uint256 _orderId, ProcessOrderArgs calldata _orderArg)\\n        external;\\n\\n    function processOrders(\\n        uint256[] calldata _orderIds,\\n        ProcessOrderArgs[] calldata _orderArgs\\n    ) external;\\n\\n    function getOrdersLength() external view returns (uint256);\\n\\n    function getOrders() external view returns (Order[] memory);\\n\\n    function getOrder(uint256 _orderId) external view returns (Order memory);\\n\\n    function isPairAllowed(address _token0, address _token1)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGammaOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {MarginVault} from \\\"../external/OpynVault.sol\\\";\\n\\ninterface IGammaOperator {\\n    function isValidVaultId(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getExcessCollateral(\\n        MarginVault.Vault memory _vault,\\n        uint256 _typeVault\\n    ) external view returns (uint256, bool);\\n\\n    function getVaultOtokenByVault(MarginVault.Vault memory _vault)\\n        external\\n        pure\\n        returns (address);\\n\\n    function getVaultOtoken(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (address);\\n\\n    function getVaultWithDetails(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (\\n            MarginVault.Vault memory,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getOtokenCollateral(address _otoken)\\n        external\\n        pure\\n        returns (address);\\n\\n    function getRedeemPayout(address _otoken, uint256 _amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRedeemableAmount(\\n        address _owner,\\n        address _otoken,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function isSettlementAllowed(address _otoken) external view returns (bool);\\n\\n    function isOperatorOf(address _owner) external view returns (bool);\\n\\n    function hasExpiredAndSettlementAllowed(address _otoken)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IResolver {\\n    function getProcessableOrders()\\n        external\\n        returns (bool canExec, bytes memory execPayload);\\n}\\n\"\r\n    },\r\n    \"contracts/external/OpynVault.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: UNLICENSED\\n */\\npragma solidity 0.8.0;\\n\\n/**\\n * @title MarginVault\\n * @author Opyn Team\\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\\n */\\nlibrary MarginVault {\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IUniswapRouter {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_redeemer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"canProcessOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"internalType\":\"struct IAutoGamma.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"containDuplicateOrderType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"containDuplicate\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"internalType\":\"struct IAutoGamma.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"getOrderPayout\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payoutAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProcessableOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSlippage\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AutoGammaResolver","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003519cfc47c3dbc2f6d916557bd5a4ae96c33b95c0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}