{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n\r\n    struct AddressSet {\r\n        // Storage of set values\r\n        address[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (address => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        if (!contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            address lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n/*  we use proxy, so owner will be set in initialize() function\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n*/\r\n    function initialize() external {\r\n        require(_owner == address(0), \"Already initialized\");\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function mint(address to, uint256 amount) external;\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\ncontract TokenVault {\r\n    \r\n    address public owner;\r\n    address public reimbursementToken;\r\n    address public factory;\r\n    \r\n    \r\n    constructor(address _owner,address _token) {\r\n        owner = _owner;\r\n        reimbursementToken = _token;\r\n        factory = msg.sender;\r\n    }\r\n    \r\n    function transferToken(address to, uint256 amount) external {\r\n        require(msg.sender == factory,\"caller should be factory\");\r\n        safeTransfer(reimbursementToken, to, amount);\r\n    }\r\n\r\n    // vault owner can withdraw unreserved tokens\r\n    function withdrawTokens(uint256 amount) external {\r\n        require(msg.sender == owner, \"caller should be owner\");\r\n        uint256 available = Reimbursement(factory).getAvailableTokens(address(this));\r\n        require(available >= amount, \"not enough available tokens\");\r\n        safeTransfer(reimbursementToken, msg.sender, amount);\r\n    }\r\n\r\n    // allow owner to withdraw third-party tokens from contract address\r\n    function rescueTokens(address someToken) external {\r\n        require(msg.sender == owner, \"caller should be owner\");\r\n        require(someToken != reimbursementToken, \"Only third-party token\");\r\n        uint256 available = IBEP20(someToken).balanceOf(address(this));\r\n        safeTransfer(someToken, msg.sender, available);\r\n    }\r\n    \r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n}\r\n\r\ncontract Reimbursement is Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    struct Stake {\r\n        uint256 startTime;  // stake start at timestamp\r\n        uint256 amount;     // staked tokens amount\r\n    }\r\n\r\n    struct Setting {\r\n        address token;  // reimbursement token\r\n        bool isMintable; // token can be minted by this contract\r\n        address owner;  // owner of reimbursement vault\r\n        uint64 period;  // staking period in seconds (365 days)\r\n        uint32 reimbursementRatio;     // the ratio of deposited amount to reimbursement amount (with 2 decimals)\r\n        IUniswapV2Pair swapPair;   // uniswap compatible pair for token and native coin (ETH, BNB)\r\n        bool isReversOrder; // if `true` then `token1 = token` otherwise `token0 = token`\r\n    }\r\n\r\n    mapping(address => Setting) public settings; // vault address (licensee address) => setting\r\n    mapping(address => uint256) public totalReserved;    // vault address (licensee address) => total amount used for reimbursement\r\n    mapping(address => mapping(address => uint256)) public balances;    // vault address => user address => eligible reimbursement balance\r\n    mapping(address => mapping(address => Stake)) public staking;    // vault address => user address => Stake\r\n    mapping(address => EnumerableSet.AddressSet) vaults;   // user address => licensee address list that user mat get reimbursement\r\n    mapping(address => mapping(address => uint256)) licenseeFees;    // vault => contract => fee (with 2 decimals). I.e. 30 means 0.3%\r\n    mapping(address => EnumerableSet.AddressSet) licenseeVaults;    // licensee address => list of vaults\r\n\r\n    event StakeToken(address indexed vault, address indexed user, uint256 date, uint256 amount);\r\n    event UnstakeToken(address indexed vault, address indexed user, uint256 date, uint256 amount);\r\n    event SetLicenseeFee(address indexed vault, address indexed projectContract, uint256 fee);\r\n    event VaultCreated(address indexed vault, address indexed owner, address indexed token);\r\n    event SetVaultOwner(address indexed vault, address indexed oldOwner, address indexed newOwner);\r\n\r\n    // set percentage of fee (with 2 decimals) by licensee for selected `projectContract`\r\n    function setLicenseeFee(address vault, address projectContract, uint256 fee) external {\r\n        require(settings[vault].owner == msg.sender, \"Only vault owner\");\r\n        licenseeFees[vault][projectContract] = fee;\r\n        emit SetLicenseeFee(vault, projectContract, fee);\r\n    }\r\n\r\n    // get percentage of fee (with 2 decimals) set by licensee for selected `projectContract`\r\n    function getLicenseeFee(address vault, address projectContract) external view returns(uint256 fee) {\r\n        return licenseeFees[vault][projectContract];\r\n    }\r\n\r\n    // get list of licensee vaults addresses belong to licensee\r\n    function getLicenseeVaults(address licensee) external view returns(address[] memory vault) {\r\n        return licenseeVaults[licensee]._values;\r\n    }\r\n\r\n    // get list of vault addresses where user has tokens.\r\n    function getVaults(address user) external view returns(address[] memory vault) {\r\n        return vaults[user]._values;\r\n    }\r\n\r\n    // get numbers of vault where user has tokens.\r\n    function getVaultsLength(address user) external view returns(uint256) {\r\n        return vaults[user].length();\r\n    }\r\n\r\n    // get vault address by index\r\n    function getVault(address user, uint256 index) external view returns(address) {\r\n        return vaults[user].at(index);\r\n    }\r\n\r\n    // Get vault owner\r\n    function getVaultOwner(address vault) external view returns(address) {\r\n        return settings[vault].owner;\r\n    }\r\n\r\n    // change vault owner. Only current owner can call it.\r\n    function setVaultOwner(address vault, address newOwner) external {\r\n        require(msg.sender == settings[vault].owner, \"caller should be owner\");\r\n        require(newOwner != address(0), \"Wrong new owner address\");\r\n        emit SetVaultOwner(vault, settings[vault].owner, newOwner);\r\n        settings[vault].owner = newOwner;\r\n    }\r\n\r\n    // get list of vault and balance where user can get reimbursement \r\n    function getVaultsBalance(address user) external view returns(address[] memory vault, uint256[] memory balance) {\r\n        vault = vaults[user]._values;\r\n        balance = new uint256[](vault.length);\r\n        for (uint i = 0; i < vault.length; i++) {\r\n            balance[i] = balances[vault[i]][user];\r\n        }\r\n    }\r\n\r\n    // get available (not reserved) tokens amount in vault\r\n    function getAvailableTokens(address vault) public view returns(uint256 available) {\r\n        available = IBEP20(settings[vault].token).balanceOf(vault) - totalReserved[vault];\r\n    }\r\n\r\n    // vault owner can withdraw unreserved tokens\r\n    function withdrawTokens(address vault, uint256 amount) external {\r\n        require(msg.sender == settings[vault].owner, \"caller should be owner\");\r\n        uint256 available = getAvailableTokens(vault);\r\n        require(available >= amount, \"not enough available tokens\");\r\n        TokenVault(vault).transferToken(msg.sender, amount);\r\n    }\r\n\r\n    // Stake `amount` of token to `vault` to receive reimbursement\r\n    function stake(address vault, uint256 amount) external {\r\n        uint256 balance = balances[vault][msg.sender];\r\n        require(balance != 0, \"No tokens for reimbursement\");\r\n        Stake storage s = staking[vault][msg.sender];\r\n        uint256 currentStake = s.amount;\r\n        safeTransferFrom(settings[vault].token, msg.sender, vault, amount);\r\n        totalReserved[vault] += amount;\r\n        if (currentStake != 0) {\r\n            // recalculate time due new amount: old interval * old amount = new interval * new amount\r\n            uint256 interval = block.timestamp - s.startTime;\r\n            interval = interval * currentStake / (currentStake + amount);\r\n            s.startTime = block.timestamp - interval;\r\n            s.amount = currentStake + amount;\r\n        } else {\r\n            s.startTime = block.timestamp;\r\n            s.amount = amount;\r\n        }\r\n        emit StakeToken(vault, msg.sender, block.timestamp, amount);\r\n    }\r\n\r\n    // Withdraw staked tokens + reward from vault.\r\n    function unstake(address vault) external {\r\n        Stake memory s = staking[vault][msg.sender];\r\n        Setting memory set = settings[vault];\r\n        uint256 amount;\r\n        uint256 balance = balances[vault][msg.sender];\r\n        if (set.period == 0) {\r\n            require(balance != 0, \"No reimbursement\");\r\n            amount = balance;\r\n        } else {\r\n            require(s.amount != 0, \"No stake\");\r\n            uint256 interval = block.timestamp - s.startTime;\r\n            amount = s.amount * 100 * interval / (set.period * set.reimbursementRatio);\r\n        }\r\n        delete staking[vault][msg.sender];   // remove staking record.\r\n        if (amount > balance) amount = balance;\r\n        balance -= amount;\r\n        balances[vault][msg.sender] = balance;\r\n        if (balance == 0) {\r\n            vaults[msg.sender].remove(vault); // remove vault from vaults list where user has reimbursement tokens\r\n        }\r\n        if (set.isMintable) {\r\n            totalReserved[vault] -= s.amount;\r\n            TokenVault(vault).transferToken(msg.sender, s.amount); // withdraw staked amount\r\n            IBEP20(set.token).mint(msg.sender, amount); // mint reimbursement token\r\n            amount += s.amount; // total amount: rewards + staking\r\n        } else {\r\n            amount += s.amount; // total amount: rewards + staking\r\n            totalReserved[vault] -= amount;\r\n            TokenVault(vault).transferToken(msg.sender, amount); // withdraw staked amount + rewards\r\n        }\r\n        emit UnstakeToken(vault, msg.sender, block.timestamp, amount);\r\n    }\r\n\r\n    // get information about user's fee\r\n    // address user - address of user whp paid the fee\r\n    // uint256 feeAmount - amount of fee in native coin (ETH, BNB)\r\n    // address vault - licensee vault address that licensee get after registration. Use it as Licensee ID.\r\n    // returns address of fee receiver or address(0) if licensee can't receive the fee (should be returns to user)\r\n    function requestReimbursement(address user, uint256 feeAmount, address vault) external returns(address licenseeAddress){\r\n        uint256 licenseeFee = licenseeFees[vault][msg.sender];\r\n        if (licenseeFee == 0) return address(0); // project contract not added to reimbursement\r\n        Setting memory set = settings[vault];\r\n        (uint256 reserve0, uint256 reserve1,) = set.swapPair.getReserves();\r\n        if (set.isReversOrder) (reserve0, reserve1) = (reserve1, reserve0);\r\n        uint256 amount = reserve0 * feeAmount / reserve1;\r\n\r\n        if (!set.isMintable) {\r\n            uint256 reserve = totalReserved[vault];\r\n            uint256 available = IBEP20(set.token).balanceOf(vault) - reserve;\r\n            if (available < amount) return address(0);  // not enough reimbursement tokens\r\n            totalReserved[vault] = reserve + amount;\r\n        }\r\n\r\n        uint256 balance = balances[vault][user];\r\n        if (balance == 0) vaults[user].add(vault);\r\n        balances[vault][user] = balance + amount;\r\n        return set.owner;\r\n    }\r\n\r\n    // create new vault (register Licensee)\r\n    function newVault(\r\n        address token,              // reimbursement token\r\n        bool isMintable,            // token can be minted by this contract\r\n        uint64 period,              // staking period in seconds (365 days)\r\n        uint32 reimbursementRatio,   // the ratio of deposited amount to reimbursement amount (with 2 decimals). \r\n        address swapPair,           // uniswap compatible pair for token and native coin (ETH, BNB)\r\n        uint32[] memory licenseeFee,         // percentage of Licensee fee (with 2 decimals). I.e. 30 means 0.3%\r\n        address[] memory projectContract     // contract that has right to request reimbursement\r\n    ) \r\n        external \r\n        returns(address vault) // vault - is the vault contract address where project has to transfer tokens. A licensee has to use it as Licensee ID.\r\n    {\r\n        if (isMintable) {\r\n            require(msg.sender == owner(), \"Only owner may add mintable token\");\r\n        }\r\n        bool isReversOrder;\r\n        if (IUniswapV2Pair(swapPair).token1() == token) {\r\n            isReversOrder == true;\r\n        } else {\r\n            require(IUniswapV2Pair(swapPair).token0() == token, \"Wrong swap pair\");\r\n        }\r\n        vault = address(new TokenVault(msg.sender, token));\r\n        licenseeVaults[msg.sender].add(vault);\r\n        settings[vault] = Setting(token, isMintable, msg.sender, period, reimbursementRatio, IUniswapV2Pair(swapPair), isReversOrder);\r\n        require(licenseeFee.length == projectContract.length, \"Wrong length\");\r\n        for (uint i = 0; i < projectContract.length; i++) {\r\n            require(licenseeFee[i] <= 10000, \"Wrong fee\");\r\n            licenseeFees[vault][projectContract[i]] = licenseeFee[i];\r\n            emit SetLicenseeFee(vault, projectContract[i], licenseeFee[i]);\r\n        }\r\n        emit VaultCreated(vault, msg.sender, token);\r\n    }\r\n\r\n    // This contract should not received any tokens, but due issue in ERC20 standard we can't disallow someone to do it.\r\n    // If someone accidentally transfer tokens to this contract, the owner will be able to rescue it and refund sender.\r\n    function rescueTokens(address someToken) external onlyOwner {\r\n        uint256 available = IBEP20(someToken).balanceOf(address(this));\r\n        safeTransfer(someToken, msg.sender, available);\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"projectContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetLicenseeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetVaultOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"VaultCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getAvailableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"projectContract\",\"type\":\"address\"}],\"name\":\"getLicenseeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"licensee\",\"type\":\"address\"}],\"name\":\"getLicenseeVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"vault\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getVaultOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"vault\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getVaultsBalance\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"vault\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balance\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getVaultsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isMintable\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"reimbursementRatio\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"swapPair\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"licenseeFee\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"projectContract\",\"type\":\"address[]\"}],\"name\":\"newVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"requestReimbursement\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"licenseeAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"someToken\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"projectContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setLicenseeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setVaultOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isMintable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"reimbursementRatio\",\"type\":\"uint32\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"swapPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isReversOrder\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReserved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Reimbursement","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://62d52a99dfa0e2ce803b8ac3baa803299f988b6a2a9d3263b83910e0e2c6e6c9"}]}