{"status":"1","message":"OK","result":[{"SourceCode":"{\"DNTfixedPointMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8.4;\\r\\n\\r\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\r\\nerror _ExpInputTooBig(int256 x);\\r\\n\\r\\n/// @notice Emitted when the input is greater than 192.\\r\\nerror _Exp2InputTooBig(int256 x);\\r\\n\\r\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\r\\nerror _DivInputTooSmall();\\r\\n\\r\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\r\\nerror _DivOverflow(uint256 rAbs);\\r\\n\\r\\n/// @notice Emitted when the result overflows uint256.\\r\\nerror _MulDivOverflow(uint256 prod1, uint256 denominator);\\r\\n\\r\\n/// @notice Emitted when the input is less than or equal to zero.\\r\\nerror _LogInputTooSmall(uint256 x);\\r\\n\\r\\n// Lib for fixed-point math in the Dynamic Network Token.\\r\\n// Thanks to PRBMath.\\r\\n\\r\\nlibrary DNTfixedPointMath{\\r\\n\\r\\n// int256s for fixed-point math.\\r\\n\\r\\nint256 internal constant MAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\\r\\nint256 internal constant MIN_SD59x18 = - 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\r\\nint256 internal constant LOG2_E = 1442695040888963407;\\r\\nint256 internal constant SCALE = 1e18;\\r\\nint256 internal constant HALF_SCALE = 5e17;\\r\\n\\r\\n// uint256s for fixed-point math.\\r\\n\\r\\nuint256 internal constant uSCALE = 1e18;\\r\\nuint256 internal constant uLOG2_E = 1442695040888963407;\\r\\nuint256 internal constant uHALF_SCALE = 5e17;\\r\\n\\r\\nfunction ln(uint256 x) internal pure returns (uint256 result) {\\r\\n\\r\\n// Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\r\\n// can return is 195205294292027477728.\\r\\n    unchecked {\\r\\n        result = (log2(x) * uSCALE) / uLOG2_E;\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction log2(uint256 x) internal pure returns (uint256 result) {\\r\\n\\r\\n    if (x \\u003c= 0) {\\r\\n        revert _LogInputTooSmall(x);\\r\\n    }\\r\\n        unchecked {\\r\\n        // This works because log2(x) = -log2(1/x).\\r\\n        uint256 sign;\\r\\n        if (x \\u003e= uSCALE) {\\r\\n            sign = 1;\\r\\n        }\\r\\n        else {\\r\\n\\r\\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\r\\n        assembly {\\r\\n            x := div(1000000000000000000000000000000000000, x)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\r\\n    uint256 n = mostSignificantBit(uint256(x / uSCALE));\\r\\n\\r\\n    // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can\\u0027t overflow\\r\\n    // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\\r\\n    result = uint256(n) * uSCALE;\\r\\n\\r\\n    // This is y = x * 2^(-n).\\r\\n    uint256 y = x \\u003e\\u003e n;\\r\\n\\r\\n    // If y = 1, the fractional part is zero.\\r\\n    if (y == uSCALE) {\\r\\n        return result * sign;\\r\\n    }\\r\\n\\r\\n    // Calculate the fractional part via the iterative approximation.\\r\\n    // The \\\"delta \\u003e\\u003e= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\r\\n    for (uint256 delta = uint256(HALF_SCALE); delta \\u003e 0; delta \\u003e\\u003e= 1) {\\r\\n        y = (y * y) / uSCALE;\\r\\n\\r\\n    // Is y^2 \\u003e 2 and so in the range [2,4)?\\r\\n        if (y \\u003e= 2 * uSCALE) {\\r\\n    // Add the 2^(-m) factor to the logarithm.\\r\\n            result += delta;\\r\\n\\r\\n    // Corresponds to z/2 on Wikipedia.\\r\\n            y \\u003e\\u003e= 1;\\r\\n        }\\r\\n    }\\r\\n        result *= sign;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\\r\\n/// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\r\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\r\\n/// @return msb The index of the most significant bit as an uint256.\\r\\nfunction mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\r\\n\\r\\n    if (x \\u003e= 2 ** 128) {\\r\\n        x \\u003e\\u003e= 128;\\r\\n        msb += 128;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 64) {\\r\\n        x \\u003e\\u003e= 64;\\r\\n        msb += 64;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 32) {\\r\\n        x \\u003e\\u003e= 32;\\r\\n        msb += 32;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 16) {\\r\\n        x \\u003e\\u003e= 16;\\r\\n        msb += 16;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 8) {\\r\\n        x \\u003e\\u003e= 8;\\r\\n        msb += 8;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 4) {\\r\\n        x \\u003e\\u003e= 4;\\r\\n        msb += 4;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 2) {\\r\\n        x \\u003e\\u003e= 2;\\r\\n        msb += 2;\\r\\n    }\\r\\n    if (x \\u003e= 2 ** 1) {\\r\\n    // No need to shift x any more.\\r\\n        msb += 1;\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @param x The exponent as a signed 59.18-decimal fixed-point number.\\r\\n/// @return result The result as a signed 59.18-decimal fixed-point number.\\r\\n\\r\\nfunction exp(int256 x) internal pure returns (int256 result) {\\r\\n\\r\\n    // Without this check, the value passed to \\\"exp2\\\" would be less than -59.794705707972522261.\\r\\n    if (x \\u003c - 41446531673892822322) {\\r\\n         return 0;\\r\\n    }\\r\\n\\r\\n    // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\r\\n    if (x \\u003e= 133084258667509499441) {\\r\\n        revert _ExpInputTooBig(x);\\r\\n    }\\r\\n\\r\\n    // Do the fixed-point multiplication inline to save gas.\\r\\n    unchecked {\\r\\n        int256 doubleScaleProduct = x * LOG2_E;\\r\\n        result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @param x The exponent as a signed 59.18-decimal fixed-point number.\\r\\n/// @return result The result as a signed 59.18-decimal fixed-point number.\\r\\n\\r\\nfunction exp2(int256 x) internal pure returns (int256 result) {\\r\\n    // This works because 2^(-x) = 1/2^x.\\r\\n    if (x \\u003c 0) {\\r\\n    // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\\r\\n        if (x \\u003c - 59794705707972522261) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n    // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\r\\n        unchecked {\\r\\n            result = 1e36 / exp2(- x);\\r\\n        }\\r\\n    }\\r\\n    else {\\r\\n    // 2^192 doesn\\u0027t fit within the 192.64-bit format used internally in this function.\\r\\n    if (x \\u003e= 192e18) {\\r\\n        revert _Exp2InputTooBig(x);\\r\\n    }\\r\\n\\r\\n        unchecked {\\r\\n            // Convert x to the 192.64-bit fixed-point format.\\r\\n            uint256 x192x64 = (uint256(x) \\u003c\\u003c 64) / uint256(SCALE);\\r\\n            // Safe to convert the result to int256 directly because the maximum input allowed is 192.\\r\\n            result = int256(uExp2(x192x64));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\r\\n/// @dev Has to use 192.64-bit fixed-point numbers.\\r\\n/// See https://ethereum.stackexchange.com/a/96594/24693.\\r\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\r\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\r\\nfunction uExp2(uint256 x) internal pure returns (uint256 result) {\\r\\n\\r\\n    unchecked {\\r\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\r\\n        result = 0x800000000000000000000000000000000000000000000000;\\r\\n\\r\\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\r\\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\\r\\n        if (x \\u0026 0x8000000000000000 \\u003e 0) {\\r\\n            result = (result * 0x16A09E667F3BCC909) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x4000000000000000 \\u003e 0) {\\r\\n            result = (result * 0x1306FE0A31B7152DF) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x2000000000000000 \\u003e 0) {\\r\\n            result = (result * 0x1172B83C7D517ADCE) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x1000000000000000 \\u003e 0) {\\r\\n            result = (result * 0x10B5586CF9890F62A) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x800000000000000 \\u003e 0) {\\r\\n            result = (result * 0x1059B0D31585743AE) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x400000000000000 \\u003e 0) {\\r\\n            result = (result * 0x102C9A3E778060EE7) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x200000000000000 \\u003e 0) {\\r\\n            result = (result * 0x10163DA9FB33356D8) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x100000000000000 \\u003e 0) {\\r\\n            result = (result * 0x100B1AFA5ABCBED61) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x80000000000000 \\u003e 0) {\\r\\n            result = (result * 0x10058C86DA1C09EA2) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x40000000000000 \\u003e 0) {\\r\\n            result = (result * 0x1002C605E2E8CEC50) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x20000000000000 \\u003e 0) {\\r\\n            result = (result * 0x100162F3904051FA1) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x10000000000000 \\u003e 0) {\\r\\n            result = (result * 0x1000B175EFFDC76BA) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x8000000000000 \\u003e 0) {\\r\\n            result = (result * 0x100058BA01FB9F96D) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x4000000000000 \\u003e 0) {\\r\\n            result = (result * 0x10002C5CC37DA9492) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x2000000000000 \\u003e 0) {\\r\\n            result = (result * 0x1000162E525EE0547) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x1000000000000 \\u003e 0) {\\r\\n            result = (result * 0x10000B17255775C04) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x800000000000 \\u003e 0) {\\r\\n            result = (result * 0x1000058B91B5BC9AE) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x400000000000 \\u003e 0) {\\r\\n            result = (result * 0x100002C5C89D5EC6D) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x200000000000 \\u003e 0) {\\r\\n            result = (result * 0x10000162E43F4F831) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x100000000000 \\u003e 0) {\\r\\n            result = (result * 0x100000B1721BCFC9A) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x80000000000 \\u003e 0) {\\r\\n            result = (result * 0x10000058B90CF1E6E) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x40000000000 \\u003e 0) {\\r\\n            result = (result * 0x1000002C5C863B73F) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x20000000000 \\u003e 0) {\\r\\n            result = (result * 0x100000162E430E5A2) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x10000000000 \\u003e 0) {\\r\\n            result = (result * 0x1000000B172183551) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x8000000000 \\u003e 0) {\\r\\n            result = (result * 0x100000058B90C0B49) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x4000000000 \\u003e 0) {\\r\\n            result = (result * 0x10000002C5C8601CC) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x2000000000 \\u003e 0) {\\r\\n            result = (result * 0x1000000162E42FFF0) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x1000000000 \\u003e 0) {\\r\\n            result = (result * 0x10000000B17217FBB) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x800000000 \\u003e 0) {\\r\\n            result = (result * 0x1000000058B90BFCE) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x400000000 \\u003e 0) {\\r\\n            result = (result * 0x100000002C5C85FE3) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x200000000 \\u003e 0) {\\r\\n            result = (result * 0x10000000162E42FF1) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x100000000 \\u003e 0) {\\r\\n            result = (result * 0x100000000B17217F8) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x80000000 \\u003e 0) {\\r\\n            result = (result * 0x10000000058B90BFC) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x40000000 \\u003e 0) {\\r\\n            result = (result * 0x1000000002C5C85FE) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x20000000 \\u003e 0) {\\r\\n            result = (result * 0x100000000162E42FF) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x10000000 \\u003e 0) {\\r\\n            result = (result * 0x1000000000B17217F) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x8000000 \\u003e 0) {\\r\\n            result = (result * 0x100000000058B90C0) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x4000000 \\u003e 0) {\\r\\n            result = (result * 0x10000000002C5C860) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x2000000 \\u003e 0) {\\r\\n            result = (result * 0x1000000000162E430) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x1000000 \\u003e 0) {\\r\\n            result = (result * 0x10000000000B17218) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x800000 \\u003e 0) {\\r\\n            result = (result * 0x1000000000058B90C) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x400000 \\u003e 0) {\\r\\n            result = (result * 0x100000000002C5C86) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x200000 \\u003e 0) {\\r\\n            result = (result * 0x10000000000162E43) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x100000 \\u003e 0) {\\r\\n            result = (result * 0x100000000000B1721) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x80000 \\u003e 0) {\\r\\n            result = (result * 0x10000000000058B91) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x40000 \\u003e 0) {\\r\\n            result = (result * 0x1000000000002C5C8) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x20000 \\u003e 0) {\\r\\n            result = (result * 0x100000000000162E4) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x10000 \\u003e 0) {\\r\\n            result = (result * 0x1000000000000B172) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x8000 \\u003e 0) {\\r\\n            result = (result * 0x100000000000058B9) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x4000 \\u003e 0) {\\r\\n            result = (result * 0x10000000000002C5D) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x2000 \\u003e 0) {\\r\\n            result = (result * 0x1000000000000162E) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x1000 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000B17) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x800 \\u003e 0) {\\r\\n            result = (result * 0x1000000000000058C) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x400 \\u003e 0) {\\r\\n            result = (result * 0x100000000000002C6) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x200 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000163) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x100 \\u003e 0) {\\r\\n            result = (result * 0x100000000000000B1) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x80 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000059) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x40 \\u003e 0) {\\r\\n            result = (result * 0x1000000000000002C) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x20 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000016) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x10 \\u003e 0) {\\r\\n            result = (result * 0x1000000000000000B) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x8 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000006) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x4 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000003) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x2 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000001) \\u003e\\u003e 64;\\r\\n        }\\r\\n        if (x \\u0026 0x1 \\u003e 0) {\\r\\n            result = (result * 0x10000000000000001) \\u003e\\u003e 64;\\r\\n        }\\r\\n\\r\\n// We\\u0027re doing two things at the same time:\\r\\n//\\r\\n//   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\r\\n//      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\r\\n//      rather than 192.\\r\\n//   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\r\\n//\\r\\n// This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\r\\n            result *= uSCALE;\\r\\n            result \\u003e\\u003e= (191 - (x \\u003e\\u003e 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\nfunction div(int256 x, int256 y) internal pure returns (int256 result) {\\r\\n\\r\\n    if (x == MIN_SD59x18 || y == MIN_SD59x18) {\\r\\n        revert _DivInputTooSmall();\\r\\n    }\\r\\n\\r\\n    // Get hold of the absolute values of x and y.\\r\\n    uint256 ax;\\r\\n    uint256 ay;\\r\\n\\r\\n    unchecked {\\r\\n        ax = x \\u003c 0 ? uint256(- x) : uint256(x);\\r\\n        ay = y \\u003c 0 ? uint256(- y) : uint256(y);\\r\\n    }\\r\\n\\r\\n    // Compute the absolute value of (x*SCALE)ÃƒÂ·y. The result must fit within int256.\\r\\n    uint256 rAbs = mulDiv(ax, uint256(SCALE), ay);\\r\\n    if (rAbs \\u003e uint256(MAX_SD59x18)) {\\r\\n        revert _DivOverflow(rAbs);\\r\\n    }\\r\\n\\r\\n    // Get the signs of x and y.\\r\\n    uint256 sx;\\r\\n    uint256 sy;\\r\\n\\r\\n    assembly {\\r\\n        sx := sgt(x, sub(0, 1))\\r\\n        sy := sgt(y, sub(0, 1))\\r\\n    }\\r\\n\\r\\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\\r\\n        // should be positive. Otherwise, it should be negative.\\r\\n        result = sx ^ sy == 1 ? - int256(rAbs) : int256(rAbs);\\r\\n    }\\r\\n\\r\\n\\r\\n/// @param x The multiplicand as an uint256.\\r\\n/// @param y The multiplier as an uint256.\\r\\n/// @param denominator The divisor as an uint256.\\r\\n/// @return result The result as an uint256.\\r\\n\\r\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n\\r\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n    // variables such that product = prod1 * 2^256 + prod0.\\r\\n    uint256 prod0; // Least significant 256 bits of the product\\r\\n    uint256 prod1; // Most significant 256 bits of the product\\r\\n    assembly {\\r\\n        let mm := mulmod(x, y, not(0))\\r\\n        prod0 := mul(x, y)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    // Handle non-overflow cases, 256 by 256 division.\\r\\n    if (prod1 == 0) {\\r\\n        unchecked {\\r\\n        result = prod0 / denominator;\\r\\n    }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n    if (prod1 \\u003e= denominator) {\\r\\n        revert _MulDivOverflow(prod1, denominator);\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    // 512 by 256 division.\\r\\n    ///////////////////////////////////////////////\\r\\n\\r\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n    uint256 remainder;\\r\\n\\r\\n    assembly {\\r\\n        // Compute remainder using mulmod.\\r\\n        remainder := mulmod(x, y, denominator)\\r\\n\\r\\n        // Subtract 256 bit number from 512 bit number.\\r\\n        prod1 := sub(prod1, gt(remainder, prod0))\\r\\n        prod0 := sub(prod0, remainder)\\r\\n    }\\r\\n\\r\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always \\u003e= 1.\\r\\n    // See https://cs.stackexchange.com/q/138556/92363.\\r\\n    unchecked {\\r\\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n        uint256 lpotdod = denominator \\u0026 (~denominator + 1);\\r\\n\\r\\n    assembly {\\r\\n            // Divide denominator by lpotdod.\\r\\n            denominator := div(denominator, lpotdod)\\r\\n\\r\\n            // Divide [prod1 prod0] by lpotdod.\\r\\n            prod0 := div(prod0, lpotdod)\\r\\n\\r\\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\r\\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * lpotdod;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel\\u0027s lifting lemma, this also works\\r\\n            // in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don\\u0027t need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"},\"DynamicNetworkToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.4;\\r\\n\\r\\nimport \\\"./DNTfixedPointMath.sol\\\";\\r\\n\\r\\n\\r\\n// Interface for IERC20.\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n// Interface for IERC20Metadata.\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\n// Interface for IAccessControl.\\r\\ninterface IAccessControl {\\r\\n\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\\r\\n\\r\\n// Interface for IERC165\\r\\ninterface IERC165 {\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n// Contract for Context.\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n// Contract for ERC165\\r\\nabstract contract ERC165 is IERC165 {\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\\r\\n// Contract for ERC20.\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        unchecked {\\r\\n    _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n    }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n    _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n    }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n    _balances[sender] = senderBalance - amount;\\r\\n    }\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n\\r\\n        _afterTokenTransfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance \\u003e= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n    _balances[account] = accountBalance - amount;\\r\\n    }\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\n// Contract for AccessControl.\\r\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\r\\n    struct RoleData {\\r\\n        mapping(address =\\u003e bool) members;\\r\\n        bytes32 adminRole;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 =\\u003e RoleData) private _roles;\\r\\n\\r\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n    modifier onlyRole(bytes32 role) {\\r\\n        _checkRole(role, _msgSender());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\r\\n        return _roles[role].members[account];\\r\\n    }\\r\\n\\r\\n    function _checkRole(bytes32 role, address account) internal view {\\r\\n        if (!hasRole(role, account)) {\\r\\n            revert(\\r\\n                string(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"AccessControl: account \\\",\\r\\n                        Strings.toHexString(uint160(account), 20),\\r\\n                        \\\" is missing role \\\",\\r\\n                        Strings.toHexString(uint256(role), 32)\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\r\\n        return _roles[role].adminRole;\\r\\n    }\\r\\n\\r\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    function renounceRole(bytes32 role, address account) public virtual override {\\r\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    function _setupRole(bytes32 role, address account) internal virtual {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\r\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\r\\n        _roles[role].adminRole = adminRole;\\r\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\r\\n    }\\r\\n\\r\\n    function _grantRole(bytes32 role, address account) private {\\r\\n        if (!hasRole(role, account)) {\\r\\n            _roles[role].members[account] = true;\\r\\n            emit RoleGranted(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revokeRole(bytes32 role, address account) private {\\r\\n        if (hasRole(role, account)) {\\r\\n            _roles[role].members[account] = false;\\r\\n            emit RoleRevoked(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// Library for SafeCast.\\r\\nlibrary SafeCast {\\r\\n\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        require(value \\u003c= type(uint224).max, \\\"SafeCast: value doesn\\u0027t fit in 224 bits\\\");\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        require(value \\u003c= type(uint128).max, \\\"SafeCast: value doesn\\u0027t fit in 128 bits\\\");\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        require(value \\u003c= type(uint96).max, \\\"SafeCast: value doesn\\u0027t fit in 96 bits\\\");\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        require(value \\u003c= type(uint64).max, \\\"SafeCast: value doesn\\u0027t fit in 64 bits\\\");\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        require(value \\u003c= type(uint32).max, \\\"SafeCast: value doesn\\u0027t fit in 32 bits\\\");\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        require(value \\u003c= type(uint16).max, \\\"SafeCast: value doesn\\u0027t fit in 16 bits\\\");\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        require(value \\u003c= type(uint8).max, \\\"SafeCast: value doesn\\u0027t fit in 8 bits\\\");\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        require(value \\u003e= 0, \\\"SafeCast: value must be positive\\\");\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    function toInt128(int256 value) internal pure returns (int128) {\\r\\n        require(value \\u003e= type(int128).min \\u0026\\u0026 value \\u003c= type(int128).max, \\\"SafeCast: value doesn\\u0027t fit in 128 bits\\\");\\r\\n        return int128(value);\\r\\n    }\\r\\n\\r\\n    function toInt64(int256 value) internal pure returns (int64) {\\r\\n        require(value \\u003e= type(int64).min \\u0026\\u0026 value \\u003c= type(int64).max, \\\"SafeCast: value doesn\\u0027t fit in 64 bits\\\");\\r\\n        return int64(value);\\r\\n    }\\r\\n\\r\\n    function toInt32(int256 value) internal pure returns (int32) {\\r\\n        require(value \\u003e= type(int32).min \\u0026\\u0026 value \\u003c= type(int32).max, \\\"SafeCast: value doesn\\u0027t fit in 32 bits\\\");\\r\\n        return int32(value);\\r\\n    }\\r\\n\\r\\n    function toInt16(int256 value) internal pure returns (int16) {\\r\\n        require(value \\u003e= type(int16).min \\u0026\\u0026 value \\u003c= type(int16).max, \\\"SafeCast: value doesn\\u0027t fit in 16 bits\\\");\\r\\n        return int16(value);\\r\\n    }\\r\\n\\r\\n    function toInt8(int256 value) internal pure returns (int8) {\\r\\n        require(value \\u003e= type(int8).min \\u0026\\u0026 value \\u003c= type(int8).max, \\\"SafeCast: value doesn\\u0027t fit in 8 bits\\\");\\r\\n        return int8(value);\\r\\n    }\\r\\n\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        require(value \\u003c= uint256(type(int256).max), \\\"SafeCast: value doesn\\u0027t fit in an int256\\\");\\r\\n        return int256(value);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// Library for SafeMath\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n// Library for Strings.\\r\\nlibrary Strings {\\r\\n\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp \\u003e\\u003e= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\r\\n            value \\u003e\\u003e= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\\r\\n// Smart contract for the Dynamic Network Token.\\r\\ncontract DynamicNetworkToken is ERC20, AccessControl\\r\\n{\\r\\n    // Declaration of roles in the network.\\r\\n    bytes32 public constant ADMIN = keccak256(\\\"ADMIN\\\");\\r\\n    bytes32 public constant LIQ_PROVIDER = keccak256(\\\"LIQ_PROVIDER\\\");\\r\\n\\r\\n    // Govern the amount of tokens with a min and a max.\\r\\n    uint256 private minimumSupply = 21000000 ether;\\r\\n    uint256 private maximumSupply = 52500000 ether;\\r\\n\\r\\n    // Keep track of total amount of burned and minted tokens.\\r\\n    uint256 private totalBurned = 0;\\r\\n    uint256 private totalMinted = 0;\\r\\n\\r\\n    // Keep track of previous burn and mint transaction.\\r\\n    uint256 private prevAmountMint = 0;\\r\\n    uint256 private prevAmountBurn = 0;\\r\\n\\r\\n    // Keep track of wallets in the network with balance \\u003e 0.\\r\\n    uint256 private  totalWallets = 0;\\r\\n\\r\\n    // Network Based Burn.\\r\\n    uint256 private networkBasedBurn = 1000000 ether;\\r\\n    uint256 private nextBurn = 100;\\r\\n\\r\\n    // The reserve address.\\r\\n    address private reserveAddress;\\r\\n\\r\\n    // The minimum balance for the reserveAddress.\\r\\n    uint256 private minimumReserve = 4200000 ether;\\r\\n\\r\\n    // The initial supply of the token.\\r\\n    uint256 private _initialSupply  = 42000000 ether;\\r\\n\\r\\n    // The current supply of the token.\\r\\n    uint256 private currentSupply  = _initialSupply;\\r\\n\\r\\n    // Number of decimals for DNT.\\r\\n    uint256 private _decimals = 18;\\r\\n\\r\\n    // Booleans for exp burning and minting.\\r\\n    bool private isExpBurn = false;\\r\\n    bool private isExpMint = false;\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor() ERC20(\\\"Dynamic Network Token\\\", \\\"DNT\\\"){\\r\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\r\\n        _setupRole(LIQ_PROVIDER, _msgSender());\\r\\n        _setupRole(ADMIN, _msgSender());\\r\\n        _mint(_msgSender(),  _initialSupply);\\r\\n        reserveAddress = _msgSender();\\r\\n    }\\r\\n\\r\\n    // Getter for nextBurn.\\r\\n    function getNextBurn() public view returns(uint256){\\r\\n        return(nextBurn);\\r\\n    }\\r\\n\\r\\n    // Getter for networkBasedBurn.\\r\\n    function getNetworkBasedBurn() public view returns(uint256){\\r\\n        return(networkBasedBurn/(10**18));\\r\\n    }\\r\\n\\r\\n    // Getter for currentSupply. Returns currentSupply with two decimals.\\r\\n    function getCurrentSupply() public view returns(uint256){\\r\\n        return(currentSupply/(10**16));\\r\\n    }\\r\\n\\r\\n    // Getter for totalBurned.\\r\\n    function getTotalBurned() public view returns(uint256){\\r\\n        return(totalBurned/(10**18));\\r\\n    }\\r\\n\\r\\n    // Getter for totalMinted.\\r\\n    function getTotalMinted() public view returns(uint256){\\r\\n        return(totalMinted/(10**18));\\r\\n    }\\r\\n\\r\\n    // Getter for totalWallets.\\r\\n    function getTotalWallets() public view returns(uint256){\\r\\n        return(totalWallets);\\r\\n    }\\r\\n\\r\\n    // Function for calculating mint.\\r\\n    function calculateMint(uint256 amount) public returns(uint256){\\r\\n        uint256 toBeMinted = SafeMath.add(prevAmountMint,amount);\\r\\n        prevAmountMint = amount;\\r\\n        uint256 uLog = DNTfixedPointMath.ln(toBeMinted);\\r\\n\\r\\n        // Check if log \\u003c 1, if so calculate exp for minting.\\r\\n        if(uLog\\u003c1)\\r\\n        {\\r\\n            isExpMint = true;\\r\\n            int256 iExp = DNTfixedPointMath.exp(SafeCast.toInt256(toBeMinted));\\r\\n            iExp = iExp * 8;\\r\\n            iExp =  DNTfixedPointMath.div(SafeCast.toInt256(toBeMinted),iExp);\\r\\n            uint256 uExp = SafeCast.toUint256(iExp);\\r\\n            uExp = uExp * 10**4;\\r\\n            return  uExp;\\r\\n        }\\r\\n        uint256 log = SafeMath.mul(uLog,8);\\r\\n        uint256 logMint = SafeMath.div(toBeMinted,log);\\r\\n        logMint = logMint * 10 ** _decimals;\\r\\n        return logMint;\\r\\n    }\\r\\n\\r\\n    // Function for calculating burn.\\r\\n    function calculateBurn(uint256 amount) public returns(uint256){\\r\\n        uint256 toBeBurned = SafeMath.add(prevAmountBurn,amount);\\r\\n        prevAmountBurn = amount;\\r\\n        uint256 uLog = DNTfixedPointMath.ln(toBeBurned);\\r\\n\\r\\n        // Check if log \\u003c 1, if so calculate exp for burning.\\r\\n        if(uLog\\u003c1)\\r\\n        {\\r\\n            isExpBurn = true;\\r\\n            int256 iExp = DNTfixedPointMath.exp(SafeCast.toInt256(toBeBurned));\\r\\n            iExp = iExp * 4;\\r\\n            iExp =  DNTfixedPointMath.div(SafeCast.toInt256(toBeBurned),iExp);\\r\\n            uint256 uExp = SafeCast.toUint256(iExp);\\r\\n            uExp = uExp * 10**4;\\r\\n            return  uExp;\\r\\n        }\\r\\n        uint256 log = SafeMath.mul(uLog,4);\\r\\n        uint256 logBurn = SafeMath.div(toBeBurned,log);\\r\\n        logBurn = logBurn * 10 ** _decimals;\\r\\n        return logBurn;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        // Calculate burn and mint.\\r\\n        uint256 toBeBurned = calculateBurn(amount);\\r\\n        uint256 toBeMinted = calculateMint(amount);\\r\\n        uint256 currentSupplyAfterBurn = SafeMath.sub(currentSupply,toBeBurned);\\r\\n        uint256 currentSupplyAfterMint = SafeMath.add(currentSupply,toBeMinted);\\r\\n        // Add to totalWalelts if balance is 0.\\r\\n        if(balanceOf(recipient)==0)\\r\\n        {\\r\\n            totalWallets += 1;\\r\\n        }\\r\\n        // Check if Network Based Burn.\\r\\n        if(totalWallets\\u003e=nextBurn \\u0026\\u0026 SafeMath.sub(currentSupply,amount)\\u003e=minimumSupply \\u0026\\u0026 SafeMath.sub(balanceOf(reserveAddress),networkBasedBurn)\\u003e=minimumReserve)\\r\\n        {\\r\\n            _burn(reserveAddress,networkBasedBurn);\\r\\n            currentSupply = SafeMath.sub(currentSupply,networkBasedBurn);\\r\\n            totalBurned = SafeMath.add(totalBurned,networkBasedBurn);\\r\\n            nextBurn = nextBurn*2;\\r\\n            networkBasedBurn = networkBasedBurn/2;\\r\\n        }\\r\\n        if(hasRole(LIQ_PROVIDER, _msgSender()))\\r\\n        {\\r\\n            if(currentSupplyAfterMint\\u003c=maximumSupply \\u0026\\u0026 isExpMint)\\r\\n            {\\r\\n                _mint(reserveAddress,SafeMath.div(toBeMinted,10**4));\\r\\n                isExpMint = false;\\r\\n                currentSupply = SafeMath.add(currentSupply,SafeMath.div(toBeMinted,10**4));\\r\\n                totalMinted = SafeMath.add(totalMinted,SafeMath.div(toBeMinted,10**4));\\r\\n            }\\r\\n            else if(currentSupplyAfterMint\\u003c=maximumSupply \\u0026\\u0026 toBeMinted \\u003e 0)\\r\\n            {\\r\\n                _mint(reserveAddress,toBeMinted);\\r\\n                currentSupply = SafeMath.add(currentSupply,toBeMinted);\\r\\n                totalMinted = SafeMath.add(totalMinted,toBeMinted);\\r\\n            }\\r\\n        }\\r\\n        if(hasRole(LIQ_PROVIDER, recipient))\\r\\n        {\\r\\n            if(isExpBurn \\u0026\\u0026 currentSupplyAfterBurn\\u003e=minimumSupply)\\r\\n            {\\r\\n                if(SafeMath.sub(balanceOf(reserveAddress),SafeMath.div(toBeBurned,10**4))\\u003e= minimumReserve)\\r\\n                {\\r\\n                    _burn(reserveAddress,SafeMath.div(toBeBurned,10**4));\\r\\n                    isExpBurn= false;\\r\\n                    currentSupply = SafeMath.sub(currentSupply,SafeMath.div(toBeBurned,10**4));\\r\\n                    totalBurned = SafeMath.add(totalBurned,SafeMath.div(toBeBurned,10**4));\\r\\n                }\\r\\n            }\\r\\n            else if(currentSupplyAfterBurn\\u003e=minimumSupply \\u0026\\u0026 toBeBurned \\u003e 0)\\r\\n            {\\r\\n                if(SafeMath.sub(balanceOf(reserveAddress),toBeBurned)\\u003e= minimumReserve)\\r\\n                {\\r\\n                    _burn(reserveAddress,toBeBurned);\\r\\n                    currentSupply = SafeMath.sub(currentSupply,toBeBurned);\\r\\n                    totalBurned = SafeMath.add(totalBurned,toBeBurned);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender,address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        uint256 toBeBurned = calculateBurn(amount);\\r\\n        uint256 currentSupplyAfterBurn = SafeMath.sub(currentSupply,toBeBurned);\\r\\n        if(hasRole(LIQ_PROVIDER, recipient))\\r\\n        {\\r\\n            if(isExpBurn \\u0026\\u0026 currentSupplyAfterBurn\\u003e=minimumSupply)\\r\\n            {\\r\\n                if(SafeMath.sub(balanceOf(reserveAddress),SafeMath.div(toBeBurned,10**4))\\u003e= minimumReserve)\\r\\n                {\\r\\n                    _burn(reserveAddress,SafeMath.div(toBeBurned,10**4));\\r\\n                    isExpBurn= false;\\r\\n                    currentSupply = SafeMath.sub(currentSupply,SafeMath.div(toBeBurned,10**4));\\r\\n                    totalBurned = SafeMath.add(totalBurned,SafeMath.div(toBeBurned,10**4));\\r\\n                }\\r\\n            }\\r\\n            else if(currentSupplyAfterBurn\\u003e=minimumSupply \\u0026\\u0026 toBeBurned \\u003e 0)\\r\\n            {\\r\\n                if(SafeMath.sub(balanceOf(reserveAddress), amount) \\u003e= minimumReserve)\\r\\n                {\\r\\n                    _burn(reserveAddress,toBeBurned);\\r\\n                    currentSupply = SafeMath.sub(currentSupply,toBeBurned);\\r\\n                    totalBurned = SafeMath.add(totalBurned,toBeBurned);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        _transfer(sender, recipient, amount);\\r\\n        uint256 currentAllowance = allowance(sender,_msgSender());\\r\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        unchecked {\\r\\n    _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n    }\\r\\n        return true;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_DivInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAbs\",\"type\":\"uint256\"}],\"name\":\"_DivOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"_Exp2InputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"_ExpInputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"_LogInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"_MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQ_PROVIDER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetworkBasedBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DynamicNetworkToken","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://208cb6b7bb6d89ff07cc39cfaa20f455331bbfa5660cf2d50abb8d36f3bca119"}]}