{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/PLBTStaking/IPLBTStaking.sol\\\";\\nimport \\\"./interfaces/DAO/IDAO.sol\\\";\\nimport \\\"./sushiswap/IUniswapV2Router02.sol\\\";\\nimport \\\"./gysr/ERC20FriendlyRewardModule.sol\\\";\\nimport \\\"./gysr/PoolFactory.sol\\\";\\nimport \\\"./gysr/interfaces/IPool.sol\\\";\\n\\n///@title DAO contract\\ncontract DAO is IDAO, AccessControl {\\n    using SafeERC20 for IERC20;\\n\\n    /// status of vote\\n    enum Decision {\\n        none,\\n        votedFor,\\n        votedAgainst\\n    }\\n\\n    /// type of proposal types\\n    enum ChangesType {\\n        none,\\n        strategy,\\n        allocation,\\n        quorum,\\n        majority,\\n        treasury,\\n        cancel\\n    }\\n\\n    /// state of proposal\\n    enum Status {\\n        none,\\n        proposal,\\n        finished,\\n        voting\\n    }\\n\\n    /// struct represents a vote\\n    struct Vote {\\n        // amount of tokens in vote\\n        uint256 amount;\\n        // voting decision\\n        Decision decision;\\n    }\\n\\n    /// struct for storing proposal\\n    struct Voting {\\n        // voting id\\n        uint256 id;\\n        // in support of votes\\n        uint256 votesFor;\\n        // against votes\\n        uint256 votesAgainst;\\n        // when started\\n        uint256 startTime;\\n        // voting may execute only after voting ended\\n        uint256 endTime;\\n        // this time increases if this voting is being cancelled\\n        uint256 finishTime;\\n        // time when changes come in power\\n        uint256 implementationTime;\\n        // creator address\\n        address creator;\\n        // address of proposal creator\\n        ChangesType changesType;\\n        // proposal status\\n        Status status;\\n        // indicator showing if proposal was cancelled\\n        bool wasCancelled;\\n        // bytecode to run on the finishvote\\n        bytes data;\\n    }\\n\\n    /// represents allocation percentage\\n    struct Allocation {\\n        uint8 plbtStakers;\\n        uint8 osomStakers;\\n        uint8 lpStakers;\\n        uint8 buyback;\\n    }\\n\\n    /// represents amount of tokens in percentage put on investing strategies\\n    struct Strategy {\\n        uint8 autopilot;\\n        uint8 uniswap;\\n        uint8 aave;\\n        uint8 anchor;\\n    }\\n\\n    ///@dev emmited when new proposal created\\n    ///@param creator address of proposal creator\\n    ///@param key hash passed to event in order to match with backend, for storing proposal descriptions\\n    ///@param id id of proposal\\n    ///@param startTime time when voting on proposal starts\\n    ///@param endTime time when voting on proposal ends\\n    event ProposalAdded(\\n        address indexed creator,\\n        bytes32 key,\\n        uint256 indexed id,\\n        uint256 startTime,\\n        uint256 endTime\\n    );\\n    ///@dev emmited when proposal transitioned to main voting status\\n    ///@param id id of proposal\\n    ///@param startTime time when main voting starts\\n    ///@param endTime time when main voting ends\\n    event VotingBegan(uint256 indexed id, uint256 startTime, uint256 endTime);\\n\\n    ///@dev emmited when voting is finished\\n    ///@param id id of finished proposal\\n    ///@param executed shows if finish was successfully executed\\n    ///@param votesFor with how many tokens voted for proposal\\n    ///@param votesAgainst with how many tokens voted against proposal\\n    event Finished(\\n        uint256 indexed id,\\n        bool indexed executed,\\n        uint256 votesFor,\\n        uint256 votesAgainst\\n    );\\n\\n    ///@dev emmited when someone voted on proposal\\n    ///@param voter address of voter\\n    ///@param id id of proposal\\n    ///@param decision shows if voted for or against\\n    ///@param amount amount of tokens voted with\\n    event CastedOnProposal(\\n        address indexed voter,\\n        uint256 indexed id,\\n        bool decision,\\n        uint256 amount\\n    );\\n\\n    ///@dev emmited when someone voted in main voting\\n    ///@param voter address of voter\\n    ///@param id id of proposal\\n    ///@param decision shows if voted for or against\\n    ///@param amount amount of tokens voted with\\n    event CastedOnVoting(\\n        address indexed voter,\\n        uint256 indexed id,\\n        bool decision,\\n        uint256 amount\\n    );\\n\\n    ///@dev modifier used for restricted function execution\\n    modifier onlyDAO() {\\n        require(\\n            msg.sender == address(this),\\n            \\\"DAO: only dao can call this function.\\\"\\n        );\\n        _;\\n    }\\n\\n    /// role of treasury holder\\n    bytes32 public TREASURY_ROLE = keccak256(\\\"TREASURY_ROLE\\\");\\n    /// threshold for proposal to pass\\n    uint256 public proposalMajority;\\n    ///threshold for voting to pass\\n    uint256 public votingMajority;\\n    /// threshold for proposal to become valid\\n    uint256 public proposalQuorum;\\n    /// threshold for voting to become valid\\n    uint256 public votingQuorum;\\n    /// debating period duration\\n    uint256 public votingPeriod;\\n    /// voting count\\n    uint256 public votingsCount;\\n    /// regular timelock\\n    uint256 public regularTimelock;\\n    /// cancel timelock\\n    uint256 public cancelTimelock;\\n    /// Allocation\\n    Allocation public allocation;\\n    /// Strategy\\n    Strategy public strategy;\\n    /// Treasury owner\\n    address treasury;\\n    /// for percent calculations\\n    uint256 private precision = 1e6;\\n    /// staking contracts\\n    IPLBTStaking private staking;\\n    /// tokens\\n    IERC20 private plbt;\\n    IERC20 private weth;\\n    IERC20 private wbtc;\\n    /// Router\\n    IUniswapV2Router02 router;\\n    ///pool address\\n    address public pool;\\n    ///GYSR Pool\\n    address public gysr;\\n\\n    ///OSOM address\\n    address OSOM;\\n    ///array of function selectors\\n    bytes4[6] selectors = [\\n        this.changeStrategy.selector,\\n        this.changeAllocation.selector,\\n        this.changeQuorum.selector,\\n        this.changeMajority.selector,\\n        this.changeTreasury.selector,\\n        this.cancelVoting.selector\\n    ];\\n    /// active proposals\\n    uint256[10] public proposals;\\n    /// initialized\\n    bool private initialized;\\n\\n    mapping(uint256 => Voting) public votings;\\n    /// storing votes from a certain address for voting\\n    mapping(uint256 => mapping(address => Vote)) public votingDecisions;\\n    /// current voting\\n    uint256 public activeVoting;\\n    /// current cancel\\n    uint256 public activeCancellation;\\n\\n    ///@param _proposalMajority initial percent of proposal majority of votes to become valid\\n    ///@param _votingMajority initial percent of main voting majority of votes to become valid\\n    ///@param _proposalQuorum initial percent of proposal quorum\\n    ///@param _votingQuorum initial percent of main voting quorum\\n    ///@param _votingPeriod initial voting period time\\n    ///@param _regularTimelock initial timelock period\\n    ///@param _cancelTimelock initial cancel timelock period\\n    ///@param _allocation initial allocation config\\n    ///@param _strategy initial strategy config\\n    constructor(\\n        uint256 _proposalMajority,\\n        uint256 _votingMajority,\\n        uint256 _proposalQuorum,\\n        uint256 _votingQuorum,\\n        uint256 _votingPeriod,\\n        uint256 _regularTimelock,\\n        uint256 _cancelTimelock,\\n        Allocation memory _allocation,\\n        Strategy memory _strategy\\n    ) {\\n        proposalMajority = _proposalMajority;\\n        votingMajority = _votingMajority;\\n        proposalQuorum = _proposalQuorum;\\n        votingQuorum = _votingQuorum;\\n        votingPeriod = _votingPeriod;\\n        regularTimelock = _regularTimelock;\\n        cancelTimelock = _cancelTimelock;\\n        allocation = _allocation;\\n        strategy = _strategy;\\n        _setupRole(DEFAULT_ADMIN_ROLE, address(this));\\n        _setRoleAdmin(TREASURY_ROLE, DEFAULT_ADMIN_ROLE);\\n    }\\n\\n    ///@dev initializing DAO with settings\\n    ///@param _router SushiSwap router address\\n    ///@param _treasury address of the treasury holder\\n    ///@param _stakingAddr address of staking\\n    ///@param _plbt Polybius token address\\n    ///@param _weth address of wEth\\n    ///@param _wbtc address of wBTC\\n    ///@param _poolFactory address of GYSR pool factory\\n    ///@param _stakingFactory address of GYSR staking module Factory\\n    ///@param _rewardFactory address of GYSR reward module factory\\n    ///@param _slpAddress address of PLBT-wETH LP token address\\n    ///@param _OSOM address of OSOM\\n    function initialize(\\n        address _router,\\n        address _treasury,\\n        address _stakingAddr,\\n        address _plbt,\\n        address _weth,\\n        address _wbtc,\\n        address _poolFactory,\\n        address _stakingFactory,\\n        address _rewardFactory,\\n        address _slpAddress,\\n        address _OSOM\\n    ) external {\\n        require(!initialized, \\\"DAO: Already initialized.\\\");\\n        treasury = _treasury;\\n        _setupRole(TREASURY_ROLE, treasury);\\n        staking = IPLBTStaking(_stakingAddr);\\n        plbt = IERC20(_plbt);\\n        weth = IERC20(_weth);\\n        wbtc = IERC20(_wbtc);\\n        PoolFactory factory = PoolFactory(_poolFactory);\\n        bytes memory stakingdata = (abi.encode(_slpAddress));\\n        bytes memory rewarddata = (abi.encode(_plbt, 10**18, 2592000));\\n        pool = factory.create(\\n            _stakingFactory,\\n            _rewardFactory,\\n            stakingdata,\\n            rewarddata\\n        );\\n        gysr = IPool(pool).rewardModule();\\n        OSOM = _OSOM;\\n        router = IUniswapV2Router02(_router);\\n        _setupRole(TREASURY_ROLE, treasury);\\n        initialized = true;\\n    }\\n\\n    ///@dev distributing fund to parties and staking contracts, and buying back PLBT from Sushiswap pool\\n    ///@param toStakersWETH amount of wETH to distribute to PLBTStakers\\n    ///@param toStakersWBTC amount of wBTC to distribute to PLBTStakers\\n    ///@param toLPStakers amount of PLBT to distribute to LPStakers on GYSR\\n    ///@param toOSOMWETH amount of wETH to distribute to PLBTStakers on OSOM\\n    ///@param toOSOMWBTC amount of wBTC to distribute to PLBTStakers on OSOM\\n    ///@param toBuyback amount of wETH to swap for PLBT\\n    function distribute(\\n        uint256 toStakersWETH,\\n        uint256 toStakersWBTC,\\n        uint256 toLPStakers,\\n        uint256 toOSOMWETH,\\n        uint256 toOSOMWBTC,\\n        uint256 toBuyback\\n    ) external onlyRole(TREASURY_ROLE) {\\n        if (toStakersWETH != 0 && toStakersWBTC != 0) {\\n            weth.safeTransferFrom(treasury, address(staking), toStakersWETH);\\n            wbtc.safeTransferFrom(treasury, address(staking), toStakersWBTC);\\n            staking.setReward(toStakersWETH, toStakersWBTC);\\n        }\\n        if (toLPStakers != 0) {\\n            plbt.safeTransferFrom(treasury, address(this), toLPStakers);\\n            plbt.approve(gysr, toLPStakers);\\n            ERC20FriendlyRewardModule(gysr).fund(toLPStakers, 2592000);\\n        }\\n\\n        if (toOSOMWETH != 0 && toOSOMWBTC != 0) {\\n            weth.safeTransferFrom(treasury, OSOM, toOSOMWETH);\\n            wbtc.safeTransferFrom(treasury, OSOM, toOSOMWBTC);\\n        }\\n        if (toBuyback != 0) {\\n            uint256 total = plbt.balanceOf(address(this));\\n            weth.safeTransferFrom(treasury, address(this), toBuyback);\\n            address[] memory path = new address[](2);\\n            path[0] = address(weth);\\n            path[1] = address(plbt);\\n            uint256[] memory amounts = router.getAmountsOut(toBuyback, path);\\n            weth.approve(address(router), amounts[0]);\\n            router.swapTokensForExactTokens(\\n                amounts[1],\\n                amounts[0],\\n                path,\\n                address(this),\\n                block.timestamp + 600\\n            );\\n            uint256 current = plbt.balanceOf(address(this));\\n            uint256 burn = current - total;\\n            plbt.safeTransfer(address(0), burn);\\n        }\\n    }\\n\\n    function changeOSOM(address _address) external onlyRole(TREASURY_ROLE) {\\n        require(_address != address(0), \\\"DAO: can't set zero-address\\\");\\n        OSOM = _address;\\n    }\\n\\n    ///@dev function which matches function selector with bytecode\\n    ///@param _changesType shows which function selector is expected\\n    ///@param _data bytecode to match\\n    modifier matchChangesTypes(ChangesType _changesType, bytes memory _data) {\\n        require(\\n            _changesType != ChangesType.none,\\n            \\\"DAO: addProposal bad arguments.\\\"\\n        );\\n        bytes4 outBytes4;\\n        assembly {\\n            outBytes4 := mload(add(_data, 0x20))\\n        }\\n\\n        require(\\n            outBytes4 == selectors[uint256(_changesType) - 1],\\n            \\\"DAO: bytecode is wrong\\\"\\n        );\\n        _;\\n    }\\n\\n    ///@dev function which will be called on Finish; changes proposal or main voting quorums\\n    ///@param or shows what quorum to change\\n    ///@param _quorum new quorum percent value\\n    function changeQuorum(bool or, uint256 _quorum) public onlyDAO {\\n        or ? votingQuorum = _quorum : proposalQuorum = _quorum;\\n    }\\n\\n    ///@dev function which will be called on Finish; changes proposal or main voting Majority\\n    ///@param or shows what Majority to change\\n    ///@param _majority new Majority percent value\\n    function changeMajority(bool or, uint256 _majority) public onlyDAO {\\n        or ? votingMajority = _majority : proposalMajority = _majority;\\n    }\\n\\n    ///@dev function which will be called on Finish of cancellation voting\\n    ///@param id id of main voting\\n    function cancelVoting(uint256 id) public onlyDAO {\\n        votings[id].status = Status.finished;\\n    }\\n\\n    ///@dev function which will be called on Finish; changes allocation parameters\\n    ///@param _allocation new allocation config\\n    function changeAllocation(Allocation memory _allocation) public onlyDAO {\\n        allocation = _allocation;\\n    }\\n\\n    ///@dev function which will be called on Finish; changes strategy parameters\\n    ///@param _strategy new strategy config\\n    function changeStrategy(Strategy memory _strategy) public onlyDAO {\\n        strategy = _strategy;\\n    }\\n\\n    ///@dev function which will be called on Finish; changes treasury holder address\\n    ///@param _treasury new treasury holder address\\n    function changeTreasury(address _treasury) public onlyDAO {\\n        revokeRole(TREASURY_ROLE, treasury);\\n        treasury = _treasury;\\n        grantRole(TREASURY_ROLE, treasury);\\n        staking.changeTreasury(_treasury);\\n    }\\n\\n    ///@dev check if proposal passed quorum and majority thresholds\\n    ///@param proposal proposal sent to validate\\n    function validate(Voting memory proposal) private view returns (bool) {\\n        uint256 total = proposal.votesFor + proposal.votesAgainst;\\n        if (total == 0) {\\n            return false;\\n        }\\n        bool quorum;\\n        uint256 supply = plbt.totalSupply() - plbt.balanceOf(address(0));\\n        bool majority;\\n        if (proposal.status == Status.voting) {\\n            quorum = ((total * precision) / supply) > votingQuorum;\\n            majority = (proposal.votesFor * precision) / total > votingMajority;\\n        } else {\\n            quorum = ((total * precision) / supply) > proposalQuorum;\\n            majority =\\n                (proposal.votesFor * precision) / total > proposalMajority;\\n        }\\n        return majority && quorum;\\n    }\\n\\n    ///@dev picks next proposal out of proposal pool\\n    function pickProposal() private view returns (uint256 id, bool check) {\\n        if (votings[activeVoting].status == Status.voting) {\\n            return (0, false);\\n        }\\n        uint256 temp = 0;\\n        Voting memory proposal;\\n        for (uint256 i = 0; i < proposals.length; i++) {\\n            proposal = votings[proposals[i]];\\n            if (proposal.status == Status.proposal && validate(proposal)) {\\n                (temp == 0 || proposal.startTime < votings[temp].startTime)\\n                    ? temp = proposal.id\\n                    : 0;\\n            }\\n        }\\n        if (temp != 0 && validate(votings[temp])) {\\n            return (temp, true);\\n        }\\n        return (0, false);\\n    }\\n\\n    ///@dev send proposal to main voting round\\n    ///@param id id of proposal\\n    function sendProposalToVoting(uint256 id) private {\\n        Voting storage proposal = votings[id];\\n        proposal.status = Status.voting;\\n        proposal.startTime = block.timestamp;\\n        proposal.endTime = block.timestamp + votingPeriod;\\n        proposal.finishTime = proposal.endTime + regularTimelock;\\n        activeVoting = id;\\n        emit VotingBegan(proposal.id, proposal.startTime, proposal.endTime);\\n    }\\n\\n    ///@dev adds proposal to proposal pool\\n    ///@param _changesType type of proposal\\n    ///@param _data executable bytecode to execute on Finish\\n    ///@param id key for matching frontend request with this contract logs\\n    function addProposal(\\n        ChangesType _changesType,\\n        bytes memory _data,\\n        bytes32 id\\n    ) public matchChangesTypes(_changesType, _data) {\\n        bool cancel = _changesType == ChangesType.cancel;\\n        require(\\n            !(cancel && votings[activeCancellation].status == Status.voting),\\n            \\\"Cancel Voting already exists\\\"\\n        );\\n        if (cancel) {\\n            Voting storage voting = votings[activeVoting];\\n            require(\\n                voting.wasCancelled == false && voting.status == Status.voting,\\n                \\\"DAO: Can't cancel twice.\\\"\\n            );\\n            require(\\n                voting.endTime < block.timestamp &&\\n                    voting.finishTime > block.timestamp,\\n                \\\"DAO: can only cancel during timelock\\\"\\n            );\\n            voting.finishTime = block.timestamp + cancelTimelock;\\n            voting.wasCancelled = true;\\n        }\\n        votingsCount++;\\n        Voting memory proposal = Voting({\\n            id: votingsCount,\\n            votesFor: 0,\\n            votesAgainst: 0,\\n            startTime: block.timestamp,\\n            endTime: block.timestamp + votingPeriod,\\n            finishTime: 0,\\n            implementationTime: 0,\\n            creator: msg.sender,\\n            changesType: _changesType,\\n            status: Status.proposal,\\n            wasCancelled: false,\\n            data: _data\\n        });\\n        votings[votingsCount] = proposal;\\n        if (cancel) {\\n            activeCancellation = votingsCount;\\n            votings[activeCancellation].status = Status.voting;\\n            votings[activeCancellation].finishTime = votings[activeCancellation]\\n                .endTime;\\n\\n            emit ProposalAdded(\\n                msg.sender,\\n                id,\\n                votingsCount,\\n                proposal.startTime,\\n                proposal.endTime\\n            );\\n            return;\\n        }\\n        bool proposalAdded = false;\\n        bool check;\\n        for (uint256 i = 0; i < proposals.length; i++) {\\n            if (\\n                votings[proposals[i]].status != Status.proposal ||\\n                proposals[i] == 0\\n            ) {\\n                check = true;\\n            } else {\\n                if (\\n                    votings[proposals[i]].endTime <= block.timestamp &&\\n                    votings[proposals[i]].status == Status.proposal\\n                ) {\\n                    check = !(validate(votings[proposals[i]]));\\n                }\\n            }\\n            if (check) {\\n                proposals[i] = proposal.id;\\n                proposalAdded = true;\\n                break;\\n            }\\n        }\\n        require(proposalAdded, \\\"DAO: proposals list is full\\\");\\n\\n        emit ProposalAdded(\\n            msg.sender,\\n            id,\\n            votingsCount,\\n            proposal.startTime,\\n            proposal.endTime\\n        );\\n    }\\n\\n    ///@dev participate in main voting round\\n    ///@param id id of proposal\\n    ///@param amount amount of tokens to vote with\\n    ///@param decision shows if voted for or against\\n    function participateInVoting(\\n        uint256 id,\\n        uint256 amount,\\n        bool decision\\n    ) external {\\n        // check if proposal is active\\n        bool check = votings[id].status == Status.voting &&\\n            votings[id].endTime >= block.timestamp;\\n        require(check, \\\"DAO: voting ended\\\");\\n        // check if voted\\n        Vote storage vote = votingDecisions[id][msg.sender];\\n        require(\\n            vote.decision == Decision.none && vote.amount == 0,\\n            \\\"DAO: you have already voted\\\"\\n        );\\n        // check if msg.sender has available tokens\\n        uint256 possible = getAvailableTokens(msg.sender);\\n        require(amount > 0 && amount <= possible, \\\"DAO: incorrect amount\\\");\\n        Voting storage voting = votings[id];\\n        vote.amount += amount;\\n        if (decision) {\\n            voting.votesFor += amount;\\n            vote.decision = Decision.votedFor;\\n        } else {\\n            voting.votesAgainst += amount;\\n            vote.decision = Decision.votedAgainst;\\n        }\\n        emit CastedOnVoting(msg.sender, id, decision, amount);\\n    }\\n\\n    ///@dev participate in proposal\\n    ///@param id id of proposal\\n    ///@param amount amount of tokens to vote with\\n    ///@param decision shows if voted for or against\\n    function participateInProposal(\\n        uint256 id,\\n        uint256 amount,\\n        bool decision\\n    ) external {\\n        // check if proposal is active\\n        bool check = votings[id].status == Status.proposal &&\\n            votings[id].endTime >= block.timestamp;\\n        require(check, \\\"DAO: proposal ended\\\");\\n        // check if voted\\n        Voting storage proposal = votings[id];\\n        Vote storage vote = votingDecisions[proposal.id][msg.sender];\\n        require(\\n            vote.decision == Decision.none && vote.amount == 0,\\n            \\\"DAO: you have already voted\\\"\\n        );\\n        // check if msg.sender has available tokens\\n        uint256 possible = getAvailableTokens(msg.sender);\\n        require(amount > 0 && amount <= possible, \\\"DAO: incorrect amount\\\");\\n        vote.amount += amount;\\n        if (decision) {\\n            proposal.votesFor += amount;\\n            vote.decision = Decision.votedFor;\\n        } else {\\n            proposal.votesAgainst += amount;\\n            vote.decision = Decision.votedAgainst;\\n        }\\n        votings[proposal.id] = proposal;\\n        (uint256 picked, bool found) = pickProposal();\\n        if (found) {\\n            sendProposalToVoting(picked);\\n        }\\n        emit CastedOnProposal(msg.sender, id, decision, amount);\\n    }\\n\\n    ///@dev to finish main voting round and run changes on success\\n    ///@param id id of proposal to finish\\n    function finishVoting(uint256 id) public {\\n        Voting storage voting = votings[id];\\n        require(\\n            (voting.status == Status.voting),\\n            \\\"DAO: the result of the vote has already been completed,\\\"\\n        );\\n        require(\\n            block.timestamp > (voting.finishTime),\\n            \\\"DAO: Voting can't be finished yet.\\\"\\n        );\\n        bool result = validate(voting);\\n        if (result && voting.changesType != ChangesType.cancel) {\\n            (bool success, ) = address(this).call{value: 0}(voting.data);\\n            voting.implementationTime = block.timestamp;\\n        }\\n        if (voting.changesType == ChangesType.cancel) {\\n            if (result) {\\n                address(this).call{value: 0}(voting.data);\\n            } else {\\n                bytes memory data = voting.data;\\n                uint256 id_;\\n                assembly {\\n                    let sig := mload(add(data, add(4, 0)))\\n                    id_ := mload(add(data, 36))\\n                }\\n                votings[id_].finishTime = votings[id_].endTime;\\n                finishVoting(id_);\\n            }\\n        }\\n        voting.status = Status.finished;\\n        (uint256 picked, bool found) = pickProposal();\\n        if (found) {\\n            sendProposalToVoting(picked);\\n        }\\n        emit Finished(id, result, voting.votesFor, voting.votesAgainst);\\n    }\\n\\n    ///@dev used for situations, when previously passed proposal wasn't finished and proposal pool is full\\n    ///@param finishId id of proposal to finish\\n    ///@param _changesType type of proposal\\n    ///@param _data executable bytecode to execute on Finish\\n    ///@param id key for matching frontend request with this contract logs\\n    function finishAndAddProposal(\\n        uint256 finishId,\\n        ChangesType _changesType,\\n        bytes calldata _data,\\n        bytes32 id\\n    ) external {\\n        finishVoting(finishId);\\n        addProposal(_changesType, _data, id);\\n    }\\n\\n    ///@dev get all locked tokens for address `staker`, so user cannot unstake or vote with tokens used in proposals\\n    ///@param staker address of staker\\n    function getLockedTokens(address staker)\\n        public\\n        view\\n        override\\n        returns (uint256 locked)\\n    {\\n        for (uint256 i = 0; i < proposals.length; i++) {\\n            if (\\n                (votings[proposals[i]].endTime > block.timestamp ||\\n                    validate(votings[proposals[i]])) &&\\n                votings[proposals[i]].status == Status.proposal\\n            ) locked += votingDecisions[proposals[i]][staker].amount;\\n        }\\n        if (\\n            votings[activeVoting].status == Status.voting &&\\n            votings[activeVoting].finishTime > block.timestamp\\n        ) {\\n            locked += votingDecisions[activeVoting][staker].amount;\\n        }\\n        if (\\n            votings[activeCancellation].status == Status.voting &&\\n            votings[activeCancellation].finishTime > block.timestamp\\n        ) {\\n            locked += votingDecisions[activeCancellation][staker].amount;\\n        }\\n        return locked;\\n    }\\n\\n    ///@dev get available tokens for address `staker`, so user cannot unstake or vote with tokens used in proposals\\n    ///@param staker address of staker\\n    function getAvailableTokens(address staker)\\n        public\\n        view\\n        override\\n        returns (uint256 available)\\n    {\\n        uint256 locked = getLockedTokens(staker);\\n        uint256 staked = staking.getStakedTokens(staker);\\n        available = staked - locked;\\n        return available;\\n    }\\n\\n    ///@dev returns all proposals from pool\\n    function getAllProposals() external view returns (Voting[] memory) {\\n        Voting[] memory proposalsList = new Voting[](10); // allocate array memory\\n        for (uint256 i = 0; i < proposals.length; i++) {\\n            {\\n                proposalsList[i] = votings[proposals[i]];\\n            }\\n        }\\n        return proposalsList;\\n    }\\n\\n    ///@dev returns all votings\\n    ///@return array of proposals from pool\\n    function getAllVotings() external view returns (Voting[] memory) {\\n        Voting[] memory votingsList = new Voting[](votingsCount); // allocate array memory\\n        for (uint256 i = 0; i < votingsCount; i++) {\\n            {\\n                votingsList[i] = votings[i + 1];\\n            }\\n        }\\n        return votingsList;\\n    }\\n\\n    ///@dev returns proposal info with additional information for frontend\\n    ///@return proposal struct\\n    ///@return creatorAmountStaked amount of staked tokens by proposal creator\\n    ///@return quorum\\n    ///@return majority\\n    function getActiveVoting()\\n        external\\n        view\\n        returns (\\n            Voting memory,\\n            uint256 creatorAmountStaked,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        creatorAmountStaked = staking.getStakedTokens(\\n            votings[activeVoting].creator\\n        );\\n        return (\\n            votings[activeVoting],\\n            creatorAmountStaked,\\n            votingQuorum,\\n            votingMajority\\n        );\\n    }\\n\\n    ///@dev returns proposal info with additional information for frontend\\n    ///@return proposal struct\\n    ///@return creatorAmountStaked amount of staked tokens by proposal creator\\n    ///@return quorum\\n    ///@return majority\\n    function getActiveCancellation()\\n        external\\n        view\\n        returns (\\n            Voting memory,\\n            uint256 creatorAmountStaked,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        creatorAmountStaked = staking.getStakedTokens(\\n            votings[activeCancellation].creator\\n        );\\n        return (\\n            votings[activeCancellation],\\n            creatorAmountStaked,\\n            votingQuorum,\\n            votingMajority\\n        );\\n    }\\n\\n    ///@dev returns proposal info with additional information for frontend\\n    ///@param user address of the user\\n    ///@return proposal struct\\n    ///@return vote struct\\n    ///@return available amount of available for voting tokens by `user`\\n    ///@return creatorAmountStaked amount of staked tokens by proposal creator\\n    ///@return quorum\\n    ///@return majority\\n    function getActiveVoting(address user)\\n        external\\n        view\\n        returns (\\n            Voting memory,\\n            Vote memory,\\n            uint256 available,\\n            uint256 creatorAmountStaked,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        available = getAvailableTokens(user);\\n        creatorAmountStaked = staking.getStakedTokens(\\n            votings[activeVoting].creator\\n        );\\n        return (\\n            votings[activeVoting],\\n            votingDecisions[activeVoting][user],\\n            creatorAmountStaked,\\n            available,\\n            votingQuorum,\\n            votingMajority\\n        );\\n    }\\n\\n    ///@dev returns proposal info with additional information for frontend\\n    ///@param user address of the user\\n    ///@return proposal struct\\n    ///@return vote struct\\n    ///@return available amount of available for voting tokens by `user`\\n    ///@return creatorAmountStaked amount of staked tokens by proposal creator\\n    ///@return quorum\\n    ///@return majority\\n    function getActiveCancellation(address user)\\n        external\\n        view\\n        returns (\\n            Voting memory,\\n            Vote memory,\\n            uint256 available,\\n            uint256 creatorAmountStaked,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        available = getAvailableTokens(user);\\n        creatorAmountStaked = staking.getStakedTokens(\\n            votings[activeCancellation].creator\\n        );\\n        return (\\n            votings[activeCancellation],\\n            votingDecisions[activeCancellation][user],\\n            creatorAmountStaked,\\n            available,\\n            votingQuorum,\\n            votingMajority\\n        );\\n    }\\n\\n    ///@dev returns proposal info with additional information for frontend\\n    ///@param id id of proposal\\n    ///@return proposal struct\\n    ///@return creatorAmountStaked amount of staked tokens by proposal creator\\n    ///@return quorum\\n    ///@return majority\\n    function getProposalInfo(uint256 id)\\n        external\\n        view\\n        returns (\\n            Voting memory,\\n            uint256 creatorAmountStaked,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        creatorAmountStaked = staking.getStakedTokens(votings[id].creator);\\n        return (\\n            votings[id],\\n            creatorAmountStaked,\\n            votings[id].status == Status.proposal\\n                ? proposalQuorum\\n                : votingQuorum,\\n            votings[id].status == Status.proposal\\n                ? proposalMajority\\n                : votingMajority\\n        );\\n    }\\n\\n    ///@dev returns proposal info with additional information for frontend\\n    ///@param id id of proposal\\n    ///@param user address of the user\\n    ///@return proposal struct\\n    ///@return vote struct\\n    ///@return available amount of available for voting tokens by `user`\\n    ///@return creatorAmountStaked amount of staked tokens by proposal creator\\n    ///@return quorum\\n    ///@return majority\\n    function getProposalInfo(uint256 id, address user)\\n        external\\n        view\\n        returns (\\n            Voting memory,\\n            Vote memory,\\n            uint256 available,\\n            uint256 creatorAmountStaked,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        available = getAvailableTokens(user);\\n        creatorAmountStaked = staking.getStakedTokens(votings[id].creator);\\n        return (\\n            votings[id],\\n            votingDecisions[id][user],\\n            creatorAmountStaked,\\n            available,\\n            votings[id].status == Status.proposal\\n                ? proposalQuorum\\n                : votingQuorum,\\n            votings[id].status == Status.proposal\\n                ? proposalMajority\\n                : votingMajority\\n        );\\n    }\\n\\n    ///@dev returns DAO configuration parameters\\n    ///@return allocation config\\n    ///@return strategy config\\n    ///@return proposal majority\\n    ///@return main voting round majority\\n    ///@return proposal quorum\\n    ///@return main voting round quorum\\n    function InfoDAO()\\n        external\\n        view\\n        returns (\\n            Allocation memory,\\n            Strategy memory,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            allocation,\\n            strategy,\\n            proposalMajority,\\n            votingMajority,\\n            proposalQuorum,\\n            votingQuorum\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PLBTStaking/IPLBTStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n\\n///@title Interface for PLBTSTaking contract for DAO interactions\\ninterface IPLBTStaking {\\n\\n    ///@dev returns amount of staked tokens by user `_address`\\n    ///@param _address address of the user\\n    ///@return amount of tokens\\n    function getStakedTokens(address _address) external view returns (uint256);\\n\\n    ///@dev sets reward for next distribution time\\n    ///@param _amountWETH amount of wETH tokens\\n    ///@param _amountWBTC amount of wBTC tokens\\n    function setReward(uint256 _amountWETH, uint256 _amountWBTC) external;\\n\\n    ///@dev changes treasury address\\n    ///@param _treasury address of the treasury\\n    function changeTreasury(address _treasury) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/DAO/IDAO.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.4;\\n\\ninterface IDAO {\\n \\n    function getLockedTokens(address staker) external view returns(uint256 locked);\\n    \\n    function getAvailableTokens(address staker) external view returns(uint256 locked);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/sushiswap/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/gysr/ERC20FriendlyRewardModule.sol\": {\r\n      \"content\": \"/*\\nERC20FriendlyRewardModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./interfaces/IRewardModule.sol\\\";\\nimport \\\"./interfaces/IEvents.sol\\\";\\nimport \\\"./ERC20BaseRewardModule.sol\\\";\\nimport \\\"./GysrUtils.sol\\\";\\n\\n/**\\n * @title ERC20 friendly reward module\\n *\\n * @notice this reward module distributes a single ERC20 token as the staking reward.\\n * It is designed to offer simple and predictable reward mechanics.\\n *\\n * @dev rewards are immutable once earned, and can be claimed by the user at\\n * any time. The module can be configured with a linear vesting schedule to\\n * incentivize longer term staking. The user can spend GYSR at the time of\\n * staking to receive a multiplier on their earning rate.\\n */\\ncontract ERC20FriendlyRewardModule is ERC20BaseRewardModule {\\n    using GysrUtils for uint256;\\n\\n    // constants\\n    uint256 public constant FULL_VESTING = 10**DECIMALS;\\n\\n    // single stake by user\\n    struct Stake {\\n        uint256 shares;\\n        uint256 gysr;\\n        uint256 bonus;\\n        uint256 rewardTally;\\n        uint256 timestamp;\\n    }\\n\\n    // mapping of user to all of their stakes\\n    mapping(address => Stake[]) public stakes;\\n\\n    // total shares without GYSR multiplier applied\\n    uint256 public totalRawStakingShares;\\n    // total shares with GYSR multiplier applied\\n    uint256 public totalStakingShares;\\n    // counter representing the current rate of rewards per share\\n    uint256 public rewardsPerStakedShare;\\n    // value to keep track of earnings to be put back into the pool\\n    uint256 public rewardDust;\\n    // timestamp of last update\\n    uint256 public lastUpdated;\\n\\n    // minimum ratio of earned rewards measured against FULL_VESTING (i.e. 2.5 * 10^17 would be 25%)\\n    uint256 public immutable vestingStart;\\n    // length of time in seconds until the user receives a FULL_VESTING (1x) multiplier on rewards\\n    uint256 public immutable vestingPeriod;\\n\\n    IERC20 private immutable _token;\\n    address private immutable _factory;\\n\\n    /**\\n     * @param token_ the token that will be rewarded\\n     * @param vestingStart_ minimum ratio earned\\n     * @param vestingPeriod_ period (in seconds) over which investors vest to 100%\\n     * @param factory_ address of module factory\\n     */\\n    constructor(\\n        address token_,\\n        uint256 vestingStart_,\\n        uint256 vestingPeriod_,\\n        address factory_\\n    ) {\\n        require(vestingStart_ <= FULL_VESTING, \\\"frm1\\\");\\n\\n        _token = IERC20(token_);\\n        _factory = factory_;\\n\\n        vestingStart = vestingStart_;\\n        vestingPeriod = vestingPeriod_;\\n\\n        lastUpdated = block.timestamp;\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function tokens()\\n        external\\n        view\\n        override\\n        returns (address[] memory tokens_)\\n    {\\n        tokens_ = new address[](1);\\n        tokens_[0] = address(_token);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function factory() external view override returns (address) {\\n        return _factory;\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function balances()\\n        external\\n        view\\n        override\\n        returns (uint256[] memory balances_)\\n    {\\n        balances_ = new uint256[](1);\\n        balances_[0] = totalLocked();\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function usage() external view override returns (uint256) {\\n        return _usage();\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function stake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external override onlyOwner returns (uint256, uint256) {\\n        _update();\\n        return _stake(account, user, shares, data);\\n    }\\n\\n    /**\\n     * @notice internal implementation of stake method\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of new shares minted\\n     * @param data addtional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function _stake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) internal returns (uint256, uint256) {\\n        require(data.length == 0 || data.length == 32, \\\"frm2\\\");\\n\\n        uint256 gysr;\\n        if (data.length == 32) {\\n            assembly {\\n                gysr := calldataload(164)\\n            }\\n        }\\n\\n        uint256 bonus =\\n            gysr.gysrBonus(shares, totalRawStakingShares + shares, _usage());\\n\\n        if (gysr > 0) {\\n            emit GysrSpent(user, gysr);\\n        }\\n\\n        // update user staking info\\n        stakes[account].push(\\n            Stake(shares, gysr, bonus, rewardsPerStakedShare, block.timestamp)\\n        );\\n\\n        // add new shares to global totals\\n        totalRawStakingShares += shares;\\n        totalStakingShares += (shares * bonus) / 10**DECIMALS;\\n\\n        return (gysr, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function unstake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata\\n    ) external override onlyOwner returns (uint256, uint256) {\\n        _update();\\n        return _unstake(account, user, shares);\\n    }\\n\\n    /**\\n     * @notice internal implementation of unstake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of shares burned\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function _unstake(\\n        address account,\\n        address user,\\n        uint256 shares\\n    ) internal returns (uint256, uint256) {\\n        // redeem first-in-last-out\\n        uint256 sharesLeftToBurn = shares;\\n        Stake[] storage userStakes = stakes[account];\\n        uint256 rewardAmount;\\n        uint256 gysrVested;\\n        uint256 preVestingRewards;\\n        uint256 timeVestingCoeff;\\n        while (sharesLeftToBurn > 0) {\\n            Stake storage lastStake = userStakes[userStakes.length - 1];\\n\\n            if (lastStake.shares <= sharesLeftToBurn) {\\n                // fully redeem a past stake\\n\\n                preVestingRewards = _rewardForStakedShares(\\n                    lastStake.shares,\\n                    lastStake.bonus,\\n                    lastStake.rewardTally\\n                );\\n\\n                timeVestingCoeff = timeVestingCoefficient(lastStake.timestamp);\\n                rewardAmount +=\\n                    (preVestingRewards * timeVestingCoeff) /\\n                    10**DECIMALS;\\n\\n                rewardDust +=\\n                    (preVestingRewards * (FULL_VESTING - timeVestingCoeff)) /\\n                    10**DECIMALS;\\n\\n                totalStakingShares -=\\n                    (lastStake.shares * lastStake.bonus) /\\n                    10**DECIMALS;\\n                sharesLeftToBurn -= lastStake.shares;\\n                gysrVested += lastStake.gysr;\\n                userStakes.pop();\\n            } else {\\n                // partially redeem a past stake\\n\\n                preVestingRewards = _rewardForStakedShares(\\n                    sharesLeftToBurn,\\n                    lastStake.bonus,\\n                    lastStake.rewardTally\\n                );\\n\\n                timeVestingCoeff = timeVestingCoefficient(lastStake.timestamp);\\n                rewardAmount +=\\n                    (preVestingRewards * timeVestingCoeff) /\\n                    10**DECIMALS;\\n\\n                rewardDust +=\\n                    (preVestingRewards * (FULL_VESTING - timeVestingCoeff)) /\\n                    10**DECIMALS;\\n\\n                totalStakingShares -=\\n                    (sharesLeftToBurn * lastStake.bonus) /\\n                    10**DECIMALS;\\n\\n                uint256 partialVested =\\n                    (sharesLeftToBurn * lastStake.gysr) / lastStake.shares;\\n                gysrVested += partialVested;\\n                lastStake.shares -= sharesLeftToBurn;\\n                lastStake.gysr -= partialVested;\\n                sharesLeftToBurn = 0;\\n            }\\n        }\\n\\n        // update global totals\\n        totalRawStakingShares -= shares;\\n\\n        if (rewardAmount > 0) {\\n            _distribute(user, address(_token), rewardAmount);\\n        }\\n\\n        if (gysrVested > 0) {\\n            emit GysrVested(user, gysrVested);\\n        }\\n\\n        return (0, gysrVested);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function claim(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external override onlyOwner returns (uint256 spent, uint256 vested) {\\n        _update();\\n        (, vested) = _unstake(account, user, shares);\\n        (spent, ) = _stake(account, user, shares, data);\\n    }\\n\\n    /**\\n     * @dev compute rewards owed for a specific stake\\n     * @param shares number of shares to calculate rewards for\\n     * @param bonus associated bonus for this stake\\n     * @param rewardTally associated rewardTally for this stake\\n     * @return reward for these staked shares\\n     */\\n    function _rewardForStakedShares(\\n        uint256 shares,\\n        uint256 bonus,\\n        uint256 rewardTally\\n    ) internal view returns (uint256) {\\n        return\\n            ((((rewardsPerStakedShare - rewardTally) * shares) / 10**DECIMALS) * // counteract rewardsPerStakedShare coefficient\\n                bonus) / 10**DECIMALS; // counteract bonus coefficient\\n    }\\n\\n    /**\\n     * @notice compute vesting multiplier as function of staking time\\n     * @param time epoch time at which the tokens were staked\\n     * @return vesting multiplier rewards\\n     */\\n    function timeVestingCoefficient(uint256 time)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (vestingPeriod == 0) return FULL_VESTING;\\n        uint256 stakeTime = block.timestamp - time;\\n        if (stakeTime > vestingPeriod) return FULL_VESTING;\\n        return\\n            vestingStart +\\n            (stakeTime * (FULL_VESTING - vestingStart)) /\\n            vestingPeriod;\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function update(address) external override {\\n        requireOwner();\\n        _update();\\n    }\\n\\n    /**\\n     * @notice method called ad hoc to clean up and perform additional accounting\\n     * @dev will only be called manually, and should not contain any essential logic\\n     */\\n    function clean() external override {\\n        requireOwner();\\n        _update();\\n        _clean(address(_token));\\n    }\\n\\n    /**\\n     * @notice fund Geyser by locking up reward tokens for distribution\\n     * @param amount number of reward tokens to lock up as funding\\n     * @param duration period (seconds) over which funding will be unlocked\\n     */\\n    function fund(uint256 amount, uint256 duration) external {\\n        _update();\\n        _fund(address(_token), amount, duration, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice fund Geyser by locking up reward tokens for distribution\\n     * @param amount number of reward tokens to lock up as funding\\n     * @param duration period (seconds) over which funding will be unlocked\\n     * @param start time (seconds) at which funding begins to unlock\\n     */\\n    function fund(\\n        uint256 amount,\\n        uint256 duration,\\n        uint256 start\\n    ) external {\\n        _update();\\n        _fund(address(_token), amount, duration, start);\\n    }\\n\\n    /**\\n     * @dev updates the internal accounting for rewards per staked share\\n     * retrieves unlocked tokens and adds on any unvested rewards from the last unstake operation\\n     */\\n    function _update() private {\\n        lastUpdated = block.timestamp;\\n\\n        if (totalStakingShares == 0) {\\n            rewardsPerStakedShare = 0;\\n            return;\\n        }\\n\\n        uint256 rewardsToUnlock = _unlockTokens(address(_token)) + rewardDust;\\n        rewardDust = 0;\\n\\n        // global accounting\\n        rewardsPerStakedShare +=\\n            (rewardsToUnlock * 10**DECIMALS) /\\n            totalStakingShares;\\n    }\\n\\n    /**\\n     * @return total number of locked reward tokens\\n     */\\n    function totalLocked() public view returns (uint256) {\\n        if (lockedShares(address(_token)) == 0) {\\n            return 0;\\n        }\\n        return\\n            (_token.balanceOf(address(this)) * lockedShares(address(_token))) /\\n            totalShares(address(_token));\\n    }\\n\\n    /**\\n     * @return total number of unlocked reward tokens\\n     */\\n    function totalUnlocked() public view returns (uint256) {\\n        uint256 unlockedShares =\\n            totalShares(address(_token)) - lockedShares(address(_token));\\n\\n        if (unlockedShares == 0) {\\n            return 0;\\n        }\\n        return\\n            (_token.balanceOf(address(this)) * unlockedShares) /\\n            totalShares(address(_token));\\n    }\\n\\n    /**\\n     * @dev internal helper to get current usage ratio\\n     * @return GYSR usage ratio\\n     */\\n    function _usage() private view returns (uint256) {\\n        if (totalStakingShares == 0) {\\n            return 0;\\n        }\\n        return\\n            ((totalStakingShares - totalRawStakingShares) * 10**DECIMALS) /\\n            totalStakingShares;\\n    }\\n\\n    /**\\n     * @param addr address of interest\\n     * @return number of active stakes for user\\n     */\\n    function stakeCount(address addr) public view returns (uint256) {\\n        return stakes[addr].length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/PoolFactory.sol\": {\r\n      \"content\": \"/*\\nPoolFactory\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./interfaces/IPoolFactory.sol\\\";\\nimport \\\"./interfaces/IModuleFactory.sol\\\";\\nimport \\\"./interfaces/IStakingModule.sol\\\";\\nimport \\\"./interfaces/IRewardModule.sol\\\";\\nimport \\\"./OwnerController.sol\\\";\\nimport \\\"./Pool.sol\\\";\\n\\n/**\\n * @title Pool factory\\n *\\n * @notice this implements the Pool factory contract which allows any user to\\n * easily configure and deploy their own Pool\\n *\\n * @dev it relies on a system of sub-factories which are responsible for the\\n * creation of underlying staking and reward modules. This primary factory\\n * calls each module factory and assembles the overall Pool contract.\\n *\\n * this contract also manages various privileged platform settings including\\n * treasury address, fee amount, and module factory whitelist.\\n */\\ncontract PoolFactory is IPoolFactory, OwnerController {\\n    // events\\n    event PoolCreated(address indexed user, address pool);\\n    event FeeUpdated(uint256 previous, uint256 updated);\\n    event TreasuryUpdated(address previous, address updated);\\n    event WhitelistUpdated(\\n        address indexed factory,\\n        uint256 previous,\\n        uint256 updated\\n    );\\n\\n    // types\\n    enum ModuleFactoryType {Unknown, Staking, Reward}\\n\\n    // constants\\n    uint256 public constant MAX_FEE = 20 * 10**16; // 20%\\n\\n    // fields\\n    mapping(address => bool) public map;\\n    address[] public list;\\n    address private _gysr;\\n    address private _treasury;\\n    uint256 private _fee;\\n    mapping(address => ModuleFactoryType) public whitelist;\\n\\n    /**\\n     * @param gysr_ address of GYSR token\\n     */\\n    constructor(address gysr_, address treasury_) {\\n        _gysr = gysr_;\\n        _treasury = treasury_;\\n        _fee = MAX_FEE;\\n    }\\n\\n    /**\\n     * @notice create a new Pool\\n     * @param staking address of factory that will be used to create staking module\\n     * @param reward address of factory that will be used to create reward module\\n     * @param stakingdata construction data for staking module factory\\n     * @param rewarddata construction data for reward module factory\\n     * @return address of newly created Pool\\n     */\\n    function create(\\n        address staking,\\n        address reward,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external returns (address) {\\n        // validate\\n        require(whitelist[staking] == ModuleFactoryType.Staking, \\\"f1\\\");\\n        require(whitelist[reward] == ModuleFactoryType.Reward, \\\"f2\\\");\\n\\n        // create modules\\n        address stakingModule =\\n            IModuleFactory(staking).createModule(stakingdata);\\n        address rewardModule = IModuleFactory(reward).createModule(rewarddata);\\n\\n        // create pool\\n        Pool pool = new Pool(stakingModule, rewardModule, _gysr, address(this));\\n\\n        // set access\\n        IStakingModule(stakingModule).transferOwnership(address(pool));\\n        IRewardModule(rewardModule).transferOwnership(address(pool));\\n        pool.transferControl(msg.sender); // this also sets controller for modules\\n        pool.transferOwnership(msg.sender);\\n\\n        // bookkeeping\\n        map[address(pool)] = true;\\n        list.push(address(pool));\\n\\n        // output\\n        emit PoolCreated(msg.sender, address(pool));\\n        return address(pool);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function treasury() external view override returns (address) {\\n        return _treasury;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolFactory\\n     */\\n    function fee() external view override returns (uint256) {\\n        return _fee;\\n    }\\n\\n    /**\\n     * @notice update the GYSR treasury address\\n     * @param treasury_ new value for treasury address\\n     */\\n    function setTreasury(address treasury_) external {\\n        requireController();\\n        emit TreasuryUpdated(_treasury, treasury_);\\n        _treasury = treasury_;\\n    }\\n\\n    /**\\n     * @notice update the global GYSR spending fee\\n     * @param fee_ new value for GYSR spending fee\\n     */\\n    function setFee(uint256 fee_) external {\\n        requireController();\\n        require(fee_ <= MAX_FEE, \\\"f3\\\");\\n        emit FeeUpdated(_fee, fee_);\\n        _fee = fee_;\\n    }\\n\\n    /**\\n     * @notice set the whitelist status of a module factory\\n     * @param factory_ address of module factory\\n     * @param type_ updated whitelist status for module\\n     */\\n    function setWhitelist(address factory_, uint256 type_) external {\\n        requireController();\\n        require(type_ <= uint256(ModuleFactoryType.Reward), \\\"f4\\\");\\n        require(factory_ != address(0), \\\"f5\\\");\\n        emit WhitelistUpdated(factory_, uint256(whitelist[factory_]), type_);\\n        whitelist[factory_] = ModuleFactoryType(type_);\\n    }\\n\\n    /**\\n     * @return total number of Pools created by the factory\\n     */\\n    function count() public view returns (uint256) {\\n        return list.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/interfaces/IPool.sol\": {\r\n      \"content\": \"/*\\nIPool\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Pool interface\\n *\\n * @notice this defines the core Pool contract interface\\n */\\ninterface IPool {\\n    /**\\n     * @return staking tokens for Pool\\n     */\\n    function stakingTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @return reward tokens for Pool\\n     */\\n    function rewardTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @return staking balances for user\\n     */\\n    function stakingBalances(address user)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @return total staking balances for Pool\\n     */\\n    function stakingTotals() external view returns (uint256[] memory);\\n\\n    /**\\n     * @return reward balances for Pool\\n     */\\n    function rewardBalances() external view returns (uint256[] memory);\\n\\n    /**\\n     * @return GYSR usage ratio for Pool\\n     */\\n    function usage() external view returns (uint256);\\n\\n    /**\\n     * @return address of staking module\\n     */\\n    function stakingModule() external view returns (address);\\n\\n    /**\\n     * @return address of reward module\\n     */\\n    function rewardModule() external view returns (address);\\n\\n    /**\\n     * @notice stake asset and begin earning rewards\\n     * @param amount number of tokens to unstake\\n     * @param stakingdata data passed to staking module\\n     * @param rewarddata data passed to reward module\\n     */\\n    function stake(\\n        uint256 amount,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external;\\n\\n    /**\\n     * @notice unstake asset and claim rewards\\n     * @param amount number of tokens to unstake\\n     * @param stakingdata data passed to staking module\\n     * @param rewarddata data passed to reward module\\n     */\\n    function unstake(\\n        uint256 amount,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external;\\n\\n    /**\\n     * @notice claim rewards without unstaking\\n     * @param amount number of tokens to claim against\\n     * @param stakingdata data passed to staking module\\n     * @param rewarddata data passed to reward module\\n     */\\n    function claim(\\n        uint256 amount,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external;\\n\\n    /**\\n     * @notice method called ad hoc to update user accounting\\n     */\\n    function update() external;\\n\\n    /**\\n     * @notice method called ad hoc to clean up and perform additional accounting\\n     */\\n    function clean() external;\\n\\n    /**\\n     * @return gysr balance available for withdrawal\\n     */\\n    function gysrBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice withdraw GYSR tokens applied during unstaking\\n     * @param amount number of GYSR to withdraw\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/sushiswap/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/gysr/interfaces/IRewardModule.sol\": {\r\n      \"content\": \"/*\\nIRewardModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IEvents.sol\\\";\\n\\nimport \\\"../OwnerController.sol\\\";\\n\\n/**\\n * @title Reward module interface\\n *\\n * @notice this contract defines the common interface that any reward module\\n * must implement to be compatible with the modular Pool architecture.\\n */\\nabstract contract IRewardModule is OwnerController, IEvents {\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n\\n    /**\\n     * @return array of reward tokens\\n     */\\n    function tokens() external view virtual returns (address[] memory);\\n\\n    /**\\n     * @return array of reward token balances\\n     */\\n    function balances() external view virtual returns (uint256[] memory);\\n\\n    /**\\n     * @return GYSR usage ratio for reward module\\n     */\\n    function usage() external view virtual returns (uint256);\\n\\n    /**\\n     * @return address of module factory\\n     */\\n    function factory() external view virtual returns (address);\\n\\n    /**\\n     * @notice perform any necessary accounting for new stake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of new shares minted\\n     * @param data addtional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function stake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external virtual returns (uint256, uint256);\\n\\n    /**\\n     * @notice reward user and perform any necessary accounting for unstake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of shares burned\\n     * @param data additional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function unstake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external virtual returns (uint256, uint256);\\n\\n    /**\\n     * @notice reward user and perform and necessary accounting for existing stake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of shares being claimed against\\n     * @param data addtional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function claim(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external virtual returns (uint256, uint256);\\n\\n    /**\\n     * @notice method called by anyone to update accounting\\n     * @param user address of user for update\\n     * @dev will only be called ad hoc and should not contain essential logic\\n     */\\n    function update(address user) external virtual;\\n\\n    /**\\n     * @notice method called by owner to clean up and perform additional accounting\\n     * @dev will only be called ad hoc and should not contain any essential logic\\n     */\\n    function clean() external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/interfaces/IEvents.sol\": {\r\n      \"content\": \"/*\\nIEvents\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n */\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title GYSR event system\\n *\\n * @notice common interface to define GYSR event system\\n */\\ninterface IEvents {\\n    // staking\\n    event Staked(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event Unstaked(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event Claimed(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n\\n    // rewards\\n    event RewardsDistributed(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event RewardsFunded(\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n    event RewardsUnlocked(address indexed token, uint256 shares);\\n    event RewardsExpired(\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    // gysr\\n    event GysrSpent(address indexed user, uint256 amount);\\n    event GysrVested(address indexed user, uint256 amount);\\n    event GysrWithdrawn(uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/ERC20BaseRewardModule.sol\": {\r\n      \"content\": \"/*\\nERC20BaseRewardModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./interfaces/IRewardModule.sol\\\";\\n\\n/**\\n * @title ERC20 base reward module\\n *\\n * @notice this abstract class implements common ERC20 funding and unlocking\\n * logic, which is inherited by other reward modules.\\n */\\nabstract contract ERC20BaseRewardModule is IRewardModule {\\n    using SafeERC20 for IERC20;\\n\\n    // single funding/reward schedule\\n    struct Funding {\\n        uint256 amount;\\n        uint256 shares;\\n        uint256 locked;\\n        uint256 updated;\\n        uint256 start;\\n        uint256 duration;\\n    }\\n\\n    // constants\\n    uint256 public constant INITIAL_SHARES_PER_TOKEN = 10**6;\\n    uint256 public constant MAX_ACTIVE_FUNDINGS = 16;\\n\\n    // funding/reward state fields\\n    mapping(address => Funding[]) private _fundings;\\n    mapping(address => uint256) private _shares;\\n    mapping(address => uint256) private _locked;\\n\\n    /**\\n     * @notice getter for total token shares\\n     */\\n    function totalShares(address token) public view returns (uint256) {\\n        return _shares[token];\\n    }\\n\\n    /**\\n     * @notice getter for total locked token shares\\n     */\\n    function lockedShares(address token) public view returns (uint256) {\\n        return _locked[token];\\n    }\\n\\n    /**\\n     * @notice getter for funding schedule struct\\n     */\\n    function fundings(address token, uint256 index)\\n        public\\n        view\\n        returns (\\n            uint256 amount,\\n            uint256 shares,\\n            uint256 locked,\\n            uint256 updated,\\n            uint256 start,\\n            uint256 duration\\n        )\\n    {\\n        Funding storage f = _fundings[token][index];\\n        return (f.amount, f.shares, f.locked, f.updated, f.start, f.duration);\\n    }\\n\\n    /**\\n     * @param token contract address of reward token\\n     * @return number of active funding schedules\\n     */\\n    function fundingCount(address token) public view returns (uint256) {\\n        return _fundings[token].length;\\n    }\\n\\n    /**\\n     * @notice compute number of unlockable shares for a specific funding schedule\\n     * @param token contract address of reward token\\n     * @param idx index of the funding\\n     * @return the number of unlockable shares\\n     */\\n    function unlockable(address token, uint256 idx)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        Funding storage funding = _fundings[token][idx];\\n\\n        // funding schedule is in future\\n        if (block.timestamp < funding.start) {\\n            return 0;\\n        }\\n        // empty\\n        if (funding.locked == 0) {\\n            return 0;\\n        }\\n        // handle zero-duration period or leftover dust from integer division\\n        if (block.timestamp >= funding.start + funding.duration) {\\n            return funding.locked;\\n        }\\n\\n        return\\n            ((block.timestamp - funding.updated) * funding.shares) /\\n            funding.duration;\\n    }\\n\\n    /**\\n     * @notice fund pool by locking up reward tokens for future distribution\\n     * @param token contract address of reward token\\n     * @param amount number of reward tokens to lock up as funding\\n     * @param duration period (seconds) over which funding will be unlocked\\n     * @param start time (seconds) at which funding begins to unlock\\n     */\\n    function _fund(\\n        address token,\\n        uint256 amount,\\n        uint256 duration,\\n        uint256 start\\n    ) internal {\\n        requireController();\\n        // validate\\n        require(amount > 0, \\\"rm1\\\");\\n        require(start >= block.timestamp, \\\"rm2\\\");\\n        require(_fundings[token].length < MAX_ACTIVE_FUNDINGS, \\\"rm3\\\");\\n\\n        IERC20 rewardToken = IERC20(token);\\n\\n        // do transfer of funding\\n        uint256 total = rewardToken.balanceOf(address(this));\\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\\n        uint256 actual = rewardToken.balanceOf(address(this)) - total;\\n\\n        // mint shares at current rate\\n        uint256 minted =\\n            (total > 0)\\n                ? (_shares[token] * actual) / total\\n                : actual * INITIAL_SHARES_PER_TOKEN;\\n\\n        _locked[token] += minted;\\n        _shares[token] += minted;\\n\\n        // create new funding\\n        _fundings[token].push(\\n            Funding({\\n                amount: amount,\\n                shares: minted,\\n                locked: minted,\\n                updated: start,\\n                start: start,\\n                duration: duration\\n            })\\n        );\\n\\n        emit RewardsFunded(token, amount, minted, start);\\n    }\\n\\n    /**\\n     * @dev internal function to clean up stale funding schedules\\n     * @param token contract address of reward token to clean up\\n     */\\n    function _clean(address token) internal {\\n        // check for stale funding schedules to expire\\n        uint256 removed = 0;\\n        uint256 originalSize = _fundings[token].length;\\n        for (uint256 i = 0; i < originalSize; i++) {\\n            Funding storage funding = _fundings[token][i - removed];\\n            uint256 idx = i - removed;\\n\\n            if (\\n                unlockable(token, idx) == 0 &&\\n                block.timestamp >= funding.start + funding.duration\\n            ) {\\n                emit RewardsExpired(\\n                    token,\\n                    funding.amount,\\n                    funding.shares,\\n                    funding.start\\n                );\\n\\n                // remove at idx by copying last element here, then popping off last\\n                // (we don't care about order)\\n                _fundings[token][idx] = _fundings[token][\\n                    _fundings[token].length - 1\\n                ];\\n                _fundings[token].pop();\\n                removed++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev unlocks reward tokens based on funding schedules\\n     * @param token contract addres of reward token\\n     * @return shares number of shares unlocked\\n     */\\n    function _unlockTokens(address token) internal returns (uint256 shares) {\\n        // get unlockable shares for each funding schedule\\n        for (uint256 i = 0; i < _fundings[token].length; i++) {\\n            uint256 s = unlockable(token, i);\\n            Funding storage funding = _fundings[token][i];\\n            if (s > 0) {\\n                funding.locked -= s;\\n                funding.updated = block.timestamp;\\n                shares += s;\\n            }\\n        }\\n\\n        // do unlocking\\n        if (shares > 0) {\\n            _locked[token] -= shares;\\n            emit RewardsUnlocked(token, shares);\\n        }\\n    }\\n\\n    /**\\n     * @dev distribute reward tokens to user\\n     * @param user address of user receiving rweard\\n     * @param token contract address of reward token\\n     * @param shares number of shares to be distributed\\n     * @return amount number of reward tokens distributed\\n     */\\n    function _distribute(\\n        address user,\\n        address token,\\n        uint256 shares\\n    ) internal returns (uint256 amount) {\\n        // compute reward amount in tokens\\n        IERC20 rewardToken = IERC20(token);\\n        amount =\\n            (rewardToken.balanceOf(address(this)) * shares) /\\n            _shares[token];\\n\\n        // update overall reward shares\\n        _shares[token] -= shares;\\n\\n        // do reward\\n        rewardToken.safeTransfer(user, amount);\\n        emit RewardsDistributed(user, token, amount, shares);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/GysrUtils.sol\": {\r\n      \"content\": \"/*\\nGYSRUtils\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./MathUtils.sol\\\";\\n\\n/**\\n * @title GYSR utilities\\n *\\n * @notice this library implements utility methods for the GYSR multiplier\\n * and spending mechanics\\n */\\nlibrary GysrUtils {\\n    using MathUtils for int128;\\n\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n    uint256 public constant GYSR_PROPORTION = 10**(DECIMALS - 2); // 1%\\n\\n    /**\\n     * @notice compute GYSR bonus as a function of usage ratio, stake amount,\\n     * and GYSR spent\\n     * @param gysr number of GYSR token applied to bonus\\n     * @param amount number of tokens or shares to unstake\\n     * @param total number of tokens or shares in overall pool\\n     * @param ratio usage ratio from 0 to 1\\n     * @return multiplier value\\n     */\\n    function gysrBonus(\\n        uint256 gysr,\\n        uint256 amount,\\n        uint256 total,\\n        uint256 ratio\\n    ) internal pure returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (total == 0) {\\n            return 0;\\n        }\\n        if (gysr == 0) {\\n            return 10**DECIMALS;\\n        }\\n\\n        // scale GYSR amount with respect to proportion\\n        uint256 portion = (GYSR_PROPORTION * total) / 10**DECIMALS;\\n        if (amount > portion) {\\n            gysr = (gysr * portion) / amount;\\n        }\\n\\n        // 1 + gysr / (0.01 + ratio)\\n        uint256 x = 2**64 + (2**64 * gysr) / (10**(DECIMALS - 2) + ratio);\\n\\n        return\\n            10**DECIMALS +\\n            (uint256(int256(int128(uint128(x)).logbase10())) * 10**DECIMALS) /\\n            2**64;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/OwnerController.sol\": {\r\n      \"content\": \"/*\\nOwnerController\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Owner controller\\n *\\n * @notice this base contract implements an owner-controller access model.\\n *\\n * @dev the contract is an adapted version of the OpenZeppelin Ownable contract.\\n * It allows the owner to designate an additional account as the controller to\\n * perform restricted operations.\\n *\\n * Other changes include supporting role verification with a require method\\n * in addition to the modifier option, and removing some unneeded functionality.\\n *\\n * Original contract here:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\ncontract OwnerController {\\n    address private _owner;\\n    address private _controller;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    event ControlTransferred(\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        _controller = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n        emit ControlTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current controller.\\n     */\\n    function controller() public view returns (address) {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @dev Modifier that throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"oc1\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that throws if called by any account other than the controller.\\n     */\\n    modifier onlyController() {\\n        require(_controller == msg.sender, \\\"oc2\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    function requireOwner() internal view {\\n        require(_owner == msg.sender, \\\"oc1\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the controller.\\n     */\\n    function requireController() internal view {\\n        require(_controller == msg.sender, \\\"oc2\\\");\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`). This can\\n     * include renouncing ownership by transferring to the zero address.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual {\\n        requireOwner();\\n        require(newOwner != address(0), \\\"oc3\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a new account (`newController`).\\n     * Can only be called by the owner.\\n     */\\n    function transferControl(address newController) public virtual {\\n        requireOwner();\\n        require(newController != address(0), \\\"oc4\\\");\\n        emit ControlTransferred(_controller, newController);\\n        _controller = newController;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/MathUtils.sol\": {\r\n      \"content\": \"/*\\nMathUtils\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: BSD-4-Clause\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Math utilities\\n *\\n * @notice this library implements various logarithmic math utilies which support\\n * other contracts and specifically the GYSR multiplier calculation\\n *\\n * @dev h/t https://github.com/abdk-consulting/abdk-libraries-solidity\\n */\\nlibrary MathUtils {\\n    /**\\n     * @notice calculate binary logarithm of x\\n     *\\n     * @param x signed 64.64-bit fixed point number, require x > 0\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function logbase2(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x > 0);\\n\\n            int256 msb = 0;\\n            int256 xc = x;\\n            if (xc >= 0x10000000000000000) {\\n                xc >>= 64;\\n                msb += 64;\\n            }\\n            if (xc >= 0x100000000) {\\n                xc >>= 32;\\n                msb += 32;\\n            }\\n            if (xc >= 0x10000) {\\n                xc >>= 16;\\n                msb += 16;\\n            }\\n            if (xc >= 0x100) {\\n                xc >>= 8;\\n                msb += 8;\\n            }\\n            if (xc >= 0x10) {\\n                xc >>= 4;\\n                msb += 4;\\n            }\\n            if (xc >= 0x4) {\\n                xc >>= 2;\\n                msb += 2;\\n            }\\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\n\\n            int256 result = (msb - 64) << 64;\\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n                ux *= ux;\\n                uint256 b = ux >> 255;\\n                ux >>= 127 + b;\\n                result += bit * int256(b);\\n            }\\n\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate natural logarithm of x\\n     * @dev magic constant comes from ln(2) * 2^128 -> hex\\n     * @param x signed 64.64-bit fixed point number, require x > 0\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function ln(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x > 0);\\n\\n            return\\n                int128(\\n                    int256(\\n                        (uint256(int256(logbase2(x))) *\\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate logarithm base 10 of x\\n     * @dev magic constant comes from log10(2) * 2^128 -> hex\\n     * @param x signed 64.64-bit fixed point number, require x > 0\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function logbase10(int128 x) internal pure returns (int128) {\\n        require(x > 0);\\n\\n        return\\n            int128(\\n                int256(\\n                    (uint256(int256(logbase2(x))) *\\n                        0x4d104d427de7fce20a6e420e02236748) >> 128\\n                )\\n            );\\n    }\\n\\n    // wrapper functions to allow testing\\n    function testlogbase2(int128 x) public pure returns (int128) {\\n        return logbase2(x);\\n    }\\n\\n    function testlogbase10(int128 x) public pure returns (int128) {\\n        return logbase10(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/interfaces/IPoolFactory.sol\": {\r\n      \"content\": \"/*\\nIPoolFactory\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Pool factory interface\\n *\\n * @notice this defines the Pool factory interface, primarily intended for\\n * the Pool contract to interact with\\n */\\ninterface IPoolFactory {\\n    /**\\n     * @return GYSR treasury address\\n     */\\n    function treasury() external view returns (address);\\n\\n    /**\\n     * @return GYSR spending fee\\n     */\\n    function fee() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/interfaces/IModuleFactory.sol\": {\r\n      \"content\": \"/*\\nIModuleFactory\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Module factory interface\\n *\\n * @notice this defines the common module factory interface used by the\\n * main factory to create the staking and reward modules for a new Pool.\\n */\\ninterface IModuleFactory {\\n    // events\\n    event ModuleCreated(address indexed user, address module);\\n\\n    /**\\n     * @notice create a new Pool module\\n     * @param data binary encoded construction parameters\\n     * @return address of newly created module\\n     */\\n    function createModule(bytes calldata data) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/interfaces/IStakingModule.sol\": {\r\n      \"content\": \"/*\\nIStakingModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IEvents.sol\\\";\\n\\nimport \\\"../OwnerController.sol\\\";\\n\\n/**\\n * @title Staking module interface\\n *\\n * @notice this contract defines the common interface that any staking module\\n * must implement to be compatible with the modular Pool architecture.\\n */\\nabstract contract IStakingModule is OwnerController, IEvents {\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n\\n    /**\\n     * @return array of staking tokens\\n     */\\n    function tokens() external view virtual returns (address[] memory);\\n\\n    /**\\n     * @notice get balance of user\\n     * @param user address of user\\n     * @return balances of each staking token\\n     */\\n    function balances(address user)\\n        external\\n        view\\n        virtual\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @return address of module factory\\n     */\\n    function factory() external view virtual returns (address);\\n\\n    /**\\n     * @notice get total staked amount\\n     * @return totals for each staking token\\n     */\\n    function totals() external view virtual returns (uint256[] memory);\\n\\n    /**\\n     * @notice stake an amount of tokens for user\\n     * @param user address of user\\n     * @param amount number of tokens to stake\\n     * @param data additional data\\n     * @return address of staking account\\n     * @return number of shares minted for stake\\n     */\\n    function stake(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual returns (address, uint256);\\n\\n    /**\\n     * @notice unstake an amount of tokens for user\\n     * @param user address of user\\n     * @param amount number of tokens to unstake\\n     * @param data additional data\\n     * @return address of staking account\\n     * @return number of shares burned for unstake\\n     */\\n    function unstake(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual returns (address, uint256);\\n\\n    /**\\n     * @notice quote the share value for an amount of tokens without unstaking\\n     * @param user address of user\\n     * @param amount number of tokens to claim with\\n     * @param data additional data\\n     * @return address of staking account\\n     * @return number of shares that the claim amount is worth\\n     */\\n    function claim(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual returns (address, uint256);\\n\\n    /**\\n     * @notice method called by anyone to update accounting\\n     * @param user address of user for update\\n     * @dev will only be called ad hoc and should not contain essential logic\\n     */\\n    function update(address user) external virtual;\\n\\n    /**\\n     * @notice method called by owner to clean up and perform additional accounting\\n     * @dev will only be called ad hoc and should not contain any essential logic\\n     */\\n    function clean() external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/gysr/Pool.sol\": {\r\n      \"content\": \"/*\\nPool\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/IPool.sol\\\";\\nimport \\\"./interfaces/IPoolFactory.sol\\\";\\nimport \\\"./interfaces/IStakingModule.sol\\\";\\nimport \\\"./interfaces/IRewardModule.sol\\\";\\nimport \\\"./interfaces/IEvents.sol\\\";\\nimport \\\"./OwnerController.sol\\\";\\n\\n/**\\n * @title Pool\\n *\\n * @notice this implements the GYSR core Pool contract. It supports generalized\\n * incentive mechanisms through a modular architecture, where\\n * staking and reward logic is contained in child contracts.\\n */\\ncontract Pool is IPool, IEvents, ReentrancyGuard, OwnerController {\\n    using SafeERC20 for IERC20;\\n\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n\\n    // modules\\n    IStakingModule private immutable _staking;\\n    IRewardModule private immutable _reward;\\n\\n    // gysr fields\\n    IERC20 private immutable _gysr;\\n    IPoolFactory private immutable _factory;\\n    uint256 private _gysrVested;\\n\\n    /**\\n     * @param staking_ the staking module address\\n     * @param reward_ the reward module address\\n     * @param gysr_ address for GYSR token\\n     * @param factory_ address for parent factory\\n     */\\n    constructor(\\n        address staking_,\\n        address reward_,\\n        address gysr_,\\n        address factory_\\n    ) {\\n        _staking = IStakingModule(staking_);\\n        _reward = IRewardModule(reward_);\\n        _gysr = IERC20(gysr_);\\n        _factory = IPoolFactory(factory_);\\n    }\\n\\n    // -- IPool --------------------------------------------------------------\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function stakingTokens() external view override returns (address[] memory) {\\n        return _staking.tokens();\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rewardTokens() external view override returns (address[] memory) {\\n        return _reward.tokens();\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function stakingBalances(address user)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        return _staking.balances(user);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function stakingTotals() external view override returns (uint256[] memory) {\\n        return _staking.totals();\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rewardBalances()\\n        external\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        return _reward.balances();\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function usage() external view override returns (uint256) {\\n        return _reward.usage();\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function stakingModule() external view override returns (address) {\\n        return address(_staking);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rewardModule() external view override returns (address) {\\n        return address(_reward);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function stake(\\n        uint256 amount,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external override nonReentrant {\\n        (address account, uint256 shares) =\\n            _staking.stake(msg.sender, amount, stakingdata);\\n        (uint256 spent, uint256 vested) =\\n            _reward.stake(account, msg.sender, shares, rewarddata);\\n        _processGysr(spent, vested);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function unstake(\\n        uint256 amount,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external override nonReentrant {\\n        (address account, uint256 shares) =\\n            _staking.unstake(msg.sender, amount, stakingdata);\\n        (uint256 spent, uint256 vested) =\\n            _reward.unstake(account, msg.sender, shares, rewarddata);\\n        _processGysr(spent, vested);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function claim(\\n        uint256 amount,\\n        bytes calldata stakingdata,\\n        bytes calldata rewarddata\\n    ) external override nonReentrant {\\n        (address account, uint256 shares) =\\n            _staking.claim(msg.sender, amount, stakingdata);\\n        (uint256 spent, uint256 vested) =\\n            _reward.claim(account, msg.sender, shares, rewarddata);\\n        _processGysr(spent, vested);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function update() external override nonReentrant {\\n        _staking.update(msg.sender);\\n        _reward.update(msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function clean() external override nonReentrant {\\n        requireController();\\n        _staking.clean();\\n        _reward.clean();\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function gysrBalance() external view override returns (uint256) {\\n        return _gysrVested;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function withdraw(uint256 amount) external override {\\n        requireController();\\n        require(amount > 0, \\\"p1\\\");\\n        require(amount <= _gysrVested, \\\"p2\\\");\\n\\n        // do transfer\\n        _gysr.safeTransfer(msg.sender, amount);\\n\\n        _gysrVested = _gysrVested - amount;\\n\\n        emit GysrWithdrawn(amount);\\n    }\\n\\n    /**\\n     * @notice transfer control of the Pool and modules to another account\\n     * @param newController address of new controller\\n     */\\n    function transferControl(address newController) public override {\\n        super.transferControl(newController);\\n        _staking.transferControl(newController);\\n        _reward.transferControl(newController);\\n    }\\n\\n    // -- Pool internal -----------------------------------------------------\\n\\n    /**\\n     * @dev private method to process GYSR spending and vesting\\n     * @param spent number of tokens to unstake\\n     * @param vested data passed to staking module\\n     */\\n    function _processGysr(uint256 spent, uint256 vested) private {\\n        // spending\\n        if (spent > 0) {\\n            _gysr.safeTransferFrom(msg.sender, address(this), spent);\\n        }\\n\\n        // vesting\\n        if (vested > 0) {\\n            uint256 fee = (vested * _factory.fee()) / 10**DECIMALS;\\n            if (fee > 0) {\\n                _gysr.safeTransfer(_factory.treasury(), fee);\\n            }\\n            _gysrVested = _gysrVested + vested - fee;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalMajority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingMajority\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_regularTimelock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cancelTimelock\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"plbtStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"osomStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lpStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyback\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Allocation\",\"name\":\"_allocation\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"autopilot\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"uniswap\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"aave\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"anchor\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Strategy\",\"name\":\"_strategy\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"decision\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CastedOnProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"decision\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CastedOnVoting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"}],\"name\":\"Finished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"VotingBegan\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InfoDAO\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"plbtStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"osomStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lpStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyback\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Allocation\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"autopilot\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"uniswap\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"aave\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"anchor\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Strategy\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREASURY_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeCancellation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeVoting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"_changesType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"addProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocation\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"plbtStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"osomStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lpStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyback\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"plbtStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"osomStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lpStakers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyback\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Allocation\",\"name\":\"_allocation\",\"type\":\"tuple\"}],\"name\":\"changeAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"or\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_majority\",\"type\":\"uint256\"}],\"name\":\"changeMajority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeOSOM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"or\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_quorum\",\"type\":\"uint256\"}],\"name\":\"changeQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"autopilot\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"uniswap\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"aave\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"anchor\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Strategy\",\"name\":\"_strategy\",\"type\":\"tuple\"}],\"name\":\"changeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"changeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toStakersWETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toStakersWBTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toLPStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toOSOMWETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toOSOMWBTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBuyback\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"finishId\",\"type\":\"uint256\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"_changesType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"finishAndAddProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"finishVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveCancellation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"creatorAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getActiveCancellation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum DAO.Decision\",\"name\":\"decision\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Vote\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getActiveVoting\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum DAO.Decision\",\"name\":\"decision\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Vote\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveVoting\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"creatorAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllProposals\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVotings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAvailableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getProposalInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"creatorAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getProposalInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct DAO.Voting\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum DAO.Decision\",\"name\":\"decision\",\"type\":\"uint8\"}],\"internalType\":\"struct DAO.Vote\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gysr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_plbt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbtc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_slpAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_OSOM\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"decision\",\"type\":\"bool\"}],\"name\":\"participateInProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"decision\",\"type\":\"bool\"}],\"name\":\"participateInVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalMajority\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regularTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"autopilot\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"uniswap\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"aave\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"anchor\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votingDecisions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum DAO.Decision\",\"name\":\"decision\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingMajority\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"implementationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum DAO.ChangesType\",\"name\":\"changesType\",\"type\":\"uint8\"},{\"internalType\":\"enum DAO.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"wasCancelled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DAO","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"400","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000007a12000000000000000000000000000000000000000000000000000000000000075300000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000003f4800000000000000000000000000000000000000000000000000000000000127500000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}