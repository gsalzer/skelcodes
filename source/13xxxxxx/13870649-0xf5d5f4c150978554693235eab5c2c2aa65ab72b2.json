{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAtopia.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBucks.sol\\\";\\n\\ninterface IAtopia {\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction bucks() external view returns (IBucks);\\n\\n\\tfunction getAge(uint256 tokenId) external view returns (uint256);\\n\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address);\\n\\n\\tfunction update(uint256 tokenId) external;\\n\\n\\tfunction exitCenter(\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 grown,\\n\\t\\tuint256 enjoyFee\\n\\t) external returns (uint256);\\n\\n\\tfunction addReward(uint256 tokenId, uint256 reward) external;\\n\\n\\tfunction claimGrowth(\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 grown,\\n\\t\\tuint256 enjoyFee\\n\\t) external returns (uint256);\\n\\n\\tfunction claimBucks(address user, uint256 amount) external;\\n\\n\\tfunction buyAndUseItem(\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 itemInfo\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBucks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBucks {\\n\\tfunction mint(address account, uint256 amount) external;\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICenter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICenter {\\n\\tfunction setId(uint256 _id) external;\\n\\n\\tfunction addFeeAmount(uint256 feeAmount) external;\\n\\n\\tfunction enter(uint256 tokenId) external returns (uint256);\\n\\n\\tfunction exit(uint256 tokenId) external returns (uint256);\\n\\n\\tfunction work(\\n\\t\\tuint256 tokenId,\\n\\t\\tuint16 task,\\n\\t\\tuint256 working\\n\\t) external returns (uint256 info, uint256 reward);\\n\\n\\tfunction enjoyFee() external view returns (uint16);\\n\\n\\tfunction grown(uint256 tokenId) external view returns (uint256);\\n\\n\\tfunction rewards(uint256 tokenId) external view returns (uint256);\\n\\n\\tfunction metadata() external view returns (string memory);\\n\\n\\tfunction grow(uint256 tokenId) external returns (uint256 _growing);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\\n/// including the MetaData, and partially, Enumerable extensions.\\ncontract ERC721 {\\n\\t/*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\taddress implementation_;\\n\\taddress public admin;\\n\\n\\tstring public name;\\n\\tstring public symbol;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             ERC-721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\tmapping(address => uint256) public balanceOf;\\n\\n\\tmapping(uint256 => address) public ownerOf;\\n\\n\\tmapping(uint256 => address) public getApproved;\\n\\n\\tmapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             VIEW FUNCTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == admin);\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction owner() external view returns (address) {\\n\\t\\treturn admin;\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                              ERC-20-LIKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\tfunction transfer(address to, uint256 tokenId) external {\\n\\t\\trequire(msg.sender == ownerOf[tokenId], \\\"NOT_OWNER\\\");\\n\\n\\t\\t_transfer(msg.sender, to, tokenId);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                              ERC-721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\tfunction supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\\n\\t\\tsupported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\\n\\t}\\n\\n\\tfunction approve(address spender, uint256 tokenId) external {\\n\\t\\taddress owner_ = ownerOf[tokenId];\\n\\n\\t\\trequire(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \\\"NOT_APPROVED\\\");\\n\\n\\t\\tgetApproved[tokenId] = spender;\\n\\n\\t\\temit Approval(owner_, spender, tokenId);\\n\\t}\\n\\n\\tfunction setApprovalForAll(address operator, bool approved) external {\\n\\t\\tisApprovedForAll[msg.sender][operator] = approved;\\n\\n\\t\\temit ApprovalForAll(msg.sender, operator, approved);\\n\\t}\\n\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) public {\\n\\t\\trequire(\\n\\t\\t\\tmsg.sender == from || msg.sender == getApproved[tokenId] || isApprovedForAll[from][msg.sender],\\n\\t\\t\\t\\\"NOT_APPROVED\\\"\\n\\t\\t);\\n\\n\\t\\t_transfer(from, to, tokenId);\\n\\t}\\n\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) external {\\n\\t\\tsafeTransferFrom(from, to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId,\\n\\t\\tbytes memory data\\n\\t) public {\\n\\t\\ttransferFrom(from, to, tokenId);\\n\\n\\t\\tif (to.code.length != 0) {\\n\\t\\t\\t// selector = `onERC721Received(address,address,uint,bytes)`\\n\\t\\t\\t(, bytes memory returned) = to.staticcall(\\n\\t\\t\\t\\tabi.encodeWithSelector(0x150b7a02, msg.sender, from, tokenId, data)\\n\\t\\t\\t);\\n\\n\\t\\t\\tbytes4 selector = abi.decode(returned, (bytes4));\\n\\n\\t\\t\\trequire(selector == 0x150b7a02, \\\"NOT_ERC721_RECEIVER\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\tfunction _transfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) internal {\\n\\t\\trequire(ownerOf[tokenId] == from);\\n\\t\\t_beforeTokenTransfer(from, to, tokenId);\\n\\n\\t\\tbalanceOf[from]--;\\n\\t\\tbalanceOf[to]++;\\n\\n\\t\\tdelete getApproved[tokenId];\\n\\n\\t\\townerOf[tokenId] = to;\\n\\t\\temit Transfer(msg.sender, to, tokenId);\\n\\t}\\n\\n\\tfunction _mint(address to, uint256 tokenId) internal {\\n\\t\\trequire(ownerOf[tokenId] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n\\t\\t// This is safe because the sum of all user\\n\\t\\t// balances can't exceed type(uint256).max!\\n\\t\\tunchecked {\\n\\t\\t\\tbalanceOf[to]++;\\n\\t\\t}\\n\\n\\t\\townerOf[tokenId] = to;\\n\\n\\t\\temit Transfer(address(0), to, tokenId);\\n\\t}\\n\\n\\tfunction _burn(uint256 tokenId) internal {\\n\\t\\taddress owner_ = ownerOf[tokenId];\\n\\n\\t\\trequire(owner_ != address(0), \\\"NOT_MINTED\\\");\\n\\t\\t_beforeTokenTransfer(owner_, address(0), tokenId);\\n\\n\\t\\tbalanceOf[owner_]--;\\n\\n\\t\\tdelete ownerOf[tokenId];\\n\\n\\t\\temit Transfer(owner_, address(0), tokenId);\\n\\t}\\n\\n\\tfunction _beforeTokenTransfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenId\\n\\t) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Space.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"../interfaces/IAtopia.sol\\\";\\nimport \\\"../interfaces/ICenter.sol\\\";\\n\\ncontract AtopiaSpace is ERC721 {\\n\\tbool public initialized;\\n\\tusing Counters for Counters.Counter;\\n\\tCounters.Counter private _tokenIds;\\n\\n\\tstruct Task {\\n\\t\\tuint256 id;\\n\\t\\tuint256 info;\\n\\t\\tuint256 rewards;\\n\\t}\\n\\n\\tIAtopia public atopia;\\n\\tICenter[] public centers;\\n\\tmapping(uint256 => uint256) public lives;\\n\\n\\tTask[] public tasks;\\n\\n\\tevent TaskUpdated(Task task);\\n\\tevent LifeUpdated(uint256 tokenId, uint256 life);\\n\\n\\tfunction initialize(address _atopia) public {\\n\\t\\trequire(!initialized);\\n\\t\\tinitialized = true;\\n\\t\\tname = \\\"Atopia Space\\\";\\n\\t\\tsymbol = \\\"ATPSPACE\\\";\\n\\t\\tatopia = IAtopia(_atopia);\\n\\t}\\n\\n\\tmodifier onlyAtopia() {\\n\\t\\trequire(msg.sender == atopia.owner());\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction onlyTokenOwner(uint256 tokenId) public view {\\n\\t\\trequire(atopia.ownerOf(tokenId) == msg.sender);\\n\\t}\\n\\n\\tfunction totalTasks() external view returns (uint256) {\\n\\t\\treturn tasks.length;\\n\\t}\\n\\n\\tfunction totalCenters() external view returns (uint256) {\\n\\t\\treturn centers.length;\\n\\t}\\n\\n\\tfunction getLife(uint256 tokenId)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256 job,\\n\\t\\t\\tuint256 task,\\n\\t\\t\\tuint256 data\\n\\t\\t)\\n\\t{\\n\\t\\tuint256 life = lives[tokenId];\\n\\t\\tdata = life & ((1 << 129) - 1);\\n\\t\\tlife = life >> 128;\\n\\t\\ttask = life & 0xFFFF;\\n\\t\\tjob = life >> 64;\\n\\t}\\n\\n\\tfunction addTask(\\n\\t\\tuint128 duration,\\n\\t\\tuint128 minAge,\\n\\t\\tuint256 rewards\\n\\t) external onlyAtopia {\\n\\t\\tTask memory newTask = Task(tasks.length + 1, (uint256(duration) << 128) | minAge, rewards);\\n\\t\\ttasks.push(newTask);\\n\\t\\temit TaskUpdated(newTask);\\n\\t}\\n\\n\\tfunction updateTask(\\n\\t\\tuint256 id,\\n\\t\\tuint128 duration,\\n\\t\\tuint128 minAge,\\n\\t\\tuint256 rewards\\n\\t) external onlyAtopia {\\n\\t\\tuint256 index = id - 1;\\n\\t\\ttasks[index].info = (uint256(duration) << 128) | minAge;\\n\\t\\ttasks[index].rewards = rewards;\\n\\t\\temit TaskUpdated(tasks[index]);\\n\\t}\\n\\n\\tfunction addCenter(address center) external onlyAtopia {\\n\\t\\tICenter newCenter = ICenter(center);\\n\\t\\tcenters.push(newCenter);\\n\\t\\tuint256 id = centers.length;\\n\\t\\t_mint(msg.sender, id);\\n\\t\\tnewCenter.setId(id);\\n\\t}\\n\\n\\tfunction addFeeAmount(uint256 centerId, uint256 amount) external {\\n\\t\\trequire(msg.sender == address(atopia));\\n\\t\\tcenters[centerId - 1].addFeeAmount(amount);\\n\\t}\\n\\n\\tfunction enterInternal(uint256 tokenId, uint256 centerId) internal {\\n\\t\\t(uint256 job, uint256 task, ) = getLife(tokenId);\\n\\t\\tif (job != 0) {\\n\\t\\t\\t// already in a center for enjoying or working\\n\\t\\t\\tif (task != 0) {\\n\\t\\t\\t\\t// if working quit work\\n\\t\\t\\t\\tworkInternal(tokenId, centerId, 0);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trequire(job != centerId);\\n\\t\\t\\t\\texit(tokenId);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//require(lives[tokenId] == 0);\\n\\t\\t//atopia.update(tokenId);\\n\\t\\tlives[tokenId] = centers[centerId - 1].enter(tokenId);\\n\\t\\temit LifeUpdated(tokenId, lives[tokenId]);\\n\\t}\\n\\n\\tfunction enter(uint256 tokenId, uint256 centerId) external {\\n\\t\\tonlyTokenOwner(tokenId);\\n\\t\\tenterInternal(tokenId, centerId);\\n\\t}\\n\\n\\tstruct EnterInfo {\\n\\t\\tuint256 centerId;\\n\\t\\tuint256[] tokenIds;\\n\\t}\\n\\n\\tfunction batchEnter(EnterInfo[] memory enterInfos) external {\\n\\t\\tfor (uint256 i = 0; i < enterInfos.length; i++) {\\n\\t\\t\\tEnterInfo memory enterInfo = enterInfos[i];\\n\\t\\t\\tfor (uint256 j = 0; j < enterInfo.tokenIds.length; j++) {\\n\\t\\t\\t\\tuint256 tokenId = enterInfo.tokenIds[j];\\n\\t\\t\\t\\tonlyTokenOwner(tokenId);\\n\\t\\t\\t\\tenterInternal(tokenId, enterInfo.centerId);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction grow(uint256 centerId, uint256 tokenId) external {\\n\\t\\trequire(msg.sender == address(atopia));\\n\\t\\tcenters[centerId - 1].grow(tokenId);\\n\\t}\\n\\n\\tfunction getGrowthAndFee(\\n\\t\\tuint256 centerId,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 growingReward\\n\\t) external view returns (uint256 grown, uint256 fee) {\\n\\t\\tICenter center = centers[centerId - 1];\\n\\t\\tfee = (growingReward * center.enjoyFee()) / 10000;\\n\\t\\tgrown = center.grown(tokenId);\\n\\t}\\n\\n\\tfunction exit(uint256 tokenId) public {\\n\\t\\tonlyTokenOwner(tokenId);\\n\\t\\t(uint256 job, uint256 task, ) = getLife(tokenId);\\n\\t\\trequire(job > 0 && task == 0);\\n\\t\\tuint256 centerIndex = job - 1;\\n\\t\\tuint256 feeAmount = atopia.claimGrowth(\\n\\t\\t\\ttokenId,\\n\\t\\t\\tcenters[centerIndex].exit(tokenId),\\n\\t\\t\\tcenters[centerIndex].enjoyFee()\\n\\t\\t);\\n\\t\\tlives[tokenId] = 0;\\n\\t\\tif (feeAmount > 0) centers[centerIndex].addFeeAmount(feeAmount);\\n\\t\\temit LifeUpdated(tokenId, 0);\\n\\t}\\n\\n\\tfunction batchExit(uint256[] memory tokenIds, uint256 centerId) external {\\n\\t\\tuint256 centerIndex = centerId - 1;\\n\\t\\tICenter center = centers[centerIndex];\\n\\t\\tuint256 feeAmount;\\n\\t\\tfor (uint256 i = 0; i < tokenIds.length; i++) {\\n\\t\\t\\tuint256 tokenId = tokenIds[i];\\n\\t\\t\\t(uint256 job, uint256 task, ) = getLife(tokenId);\\n\\t\\t\\trequire(job == centerId && task == 0 && atopia.ownerOf(tokenId) == msg.sender);\\n\\t\\t\\tfeeAmount += atopia.claimGrowth(tokenId, center.exit(tokenId), center.enjoyFee());\\n\\t\\t\\tlives[tokenId] = 0;\\n\\t\\t\\temit LifeUpdated(tokenId, 0);\\n\\t\\t}\\n\\t\\tif (feeAmount > 0) center.addFeeAmount(feeAmount);\\n\\t}\\n\\n\\tfunction claimGrowth(uint256[] memory tokenIds, uint256 centerId) public {\\n\\t\\tuint256 centerIndex = centerId - 1;\\n\\t\\tICenter center = centers[centerIndex];\\n\\t\\tuint256 feeAmount;\\n\\t\\tfor (uint256 i = 0; i < tokenIds.length; i++) {\\n\\t\\t\\tuint256 tokenId = tokenIds[i];\\n\\t\\t\\t(uint256 job, uint256 task, ) = getLife(tokenId);\\n\\t\\t\\trequire(job == centerId && task == 0);\\n\\t\\t\\tfeeAmount += atopia.claimGrowth(tokenId, center.grow(tokenId), center.enjoyFee());\\n\\t\\t}\\n\\t\\tif (feeAmount > 0) center.addFeeAmount(feeAmount);\\n\\t}\\n\\n\\tfunction workInternal(\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 centerId,\\n\\t\\tuint16 task\\n\\t) internal {\\n\\t\\tuint256 life = lives[tokenId];\\n\\t\\tuint256 job = life >> 128;\\n\\t\\tuint256 currentTask = uint16(job);\\n\\t\\tuint256 reward;\\n\\t\\tjob = job >> 64;\\n\\t\\tif (task > 0) {\\n\\t\\t\\t//require(job == 0 || job == centerId);\\n\\t\\t\\tif (job != 0) {\\n\\t\\t\\t\\t// if enjoying or already working\\n\\t\\t\\t\\tif (currentTask == 0) {\\n\\t\\t\\t\\t\\t// if enjoying\\n\\t\\t\\t\\t\\texit(tokenId);\\n\\t\\t\\t\\t\\tlife = 0;\\n\\t\\t\\t\\t} else if (job != centerId) {\\n\\t\\t\\t\\t\\t// if working\\n\\t\\t\\t\\t\\t(, reward) = centers[job - 1].work(tokenId, 0, life);\\n\\t\\t\\t\\t\\tlife = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t(life, reward) = centers[centerId - 1].work(tokenId, task, life);\\n\\t\\t} else {\\n\\t\\t\\t// quit work\\n\\t\\t\\trequire(job == centerId && currentTask > 0);\\n\\t\\t\\t(, reward) = centers[centerId - 1].work(tokenId, task, life);\\n\\t\\t\\tlife = 0;\\n\\t\\t}\\n\\t\\tlives[tokenId] = life;\\n\\t\\tif (reward > 0) atopia.addReward(tokenId, reward);\\n\\t\\temit LifeUpdated(tokenId, life);\\n\\t}\\n\\n\\tfunction work(\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 centerId,\\n\\t\\tuint16 task\\n\\t) external {\\n\\t\\tonlyTokenOwner(tokenId);\\n\\t\\tworkInternal(tokenId, centerId, task);\\n\\t}\\n\\n\\tfunction tokenURI(uint256 tokenId) public view returns (string memory) {\\n\\t\\treturn centers[tokenId - 1].metadata();\\n\\t}\\n\\n\\tfunction claimBucks(uint256 centerId, uint256 amount) external {\\n\\t\\trequire(msg.sender == address(centers[centerId - 1]));\\n\\t\\tatopia.claimBucks(ownerOf[centerId], amount);\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"life\",\"type\":\"uint256\"}],\"name\":\"LifeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct AtopiaSpace.Task\",\"name\":\"task\",\"type\":\"tuple\"}],\"name\":\"TaskUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"center\",\"type\":\"address\"}],\"name\":\"addCenter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"duration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minAge\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"addTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"atopia\",\"outputs\":[{\"internalType\":\"contract IAtopia\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct AtopiaSpace.EnterInfo[]\",\"name\":\"enterInfos\",\"type\":\"tuple[]\"}],\"name\":\"batchEnter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"}],\"name\":\"batchExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"centers\",\"outputs\":[{\"internalType\":\"contract ICenter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimBucks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"}],\"name\":\"claimGrowth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"growingReward\",\"type\":\"uint256\"}],\"name\":\"getGrowthAndFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"grown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLife\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"job\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"task\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"grow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_atopia\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lives\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"onlyTokenOwner\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCenters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTasks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"duration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minAge\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"updateTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"centerId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"task\",\"type\":\"uint16\"}],\"name\":\"work\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AtopiaSpace","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}