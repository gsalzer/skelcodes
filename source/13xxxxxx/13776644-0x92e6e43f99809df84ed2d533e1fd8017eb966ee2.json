{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/AddressRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Votium Address Registry\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract AddressRegistry is Ownable {\\n  struct Registry {\\n    uint256 start;      // when first registering, there is a delay until the next vlCVX voting epoch starts\\n    address to;         // forward rewards to alternate address OR 0x0 address for OPT OUT of rewards\\n    uint256 expiration; // when ending an active registration, expiration is set to the next vlCVX voting epoch\\n                        // an active registration cannot be changed until after it is expired (one vote round delay when changing active registration)\\n  }\\n  mapping(address => Registry) public registry;\\n\\n  mapping(address => bool) public inOptOutHistory;\\n  mapping(address => bool) public inForwardHistory;\\n  address[] public optOutHistory;\\n  address[] public forwardHistory;\\n\\n  // address changes do not take effect until the next vote starts\\n  uint256 public constant eDuration = 86400 * 14;\\n\\n\\n  // Set forwarding address or OPT OUT of rewards by setting to 0x0 address\\n  // Registration is active until setToExpire() is called, and then remains active until the next reward period\\n  function setRegistry(address _to) public {\\n    uint256 current = currentEpoch();\\n    require(registry[msg.sender].start == 0 || registry[msg.sender].expiration <= current,\\\"Registration is still active\\\");\\n    registry[msg.sender].start = current+eDuration;\\n    registry[msg.sender].to = _to;\\n    registry[msg.sender].expiration = 0xfffffffff;\\n    if(_to == address(0)) {\\n      // prevent duplicate entry in optOutHistory array\\n      if(!inOptOutHistory[msg.sender]) {\\n        optOutHistory.push(msg.sender);\\n        inOptOutHistory[msg.sender] = true;\\n      }\\n    } else if(!inForwardHistory[msg.sender]) {\\n        forwardHistory.push(msg.sender);\\n        inForwardHistory[msg.sender] = true;\\n    }\\n    emit setReg(msg.sender, _to, registry[msg.sender].start);\\n  }\\n\\n  // Sets a registration to expire on the following epoch (cannot change registration during an epoch)\\n  function setToExpire() public {\\n    uint256 next = nextEpoch();\\n    require(registry[msg.sender].start > 0 && registry[msg.sender].expiration > next,\\\"Not registered or expiration already pending\\\");\\n    // if not started yet, nullify instead of setting expiration\\n    if(next == registry[msg.sender].start) {\\n      registry[msg.sender].start = 0;\\n      registry[msg.sender].to = address(0);\\n    } else {\\n      registry[msg.sender].expiration = next;\\n    }\\n    emit expReg(msg.sender, next);\\n  }\\n\\n  // supply an array of addresses, returns their destination (same address for no change, 0x0 for opt-out, different address for forwarding)\\n  function batchAddressCheck(address[] memory accounts) external view returns (address[] memory) {\\n    uint256 current = currentEpoch();\\n    for(uint256 i=0; i<accounts.length; i++) {\\n      // if registration active return \\\"to\\\", otherwise return checked address (no forwarding)\\n      if(registry[accounts[i]].start <= current && registry[accounts[i]].start != 0 && registry[accounts[i]].expiration > current) {\\n        accounts[i] = registry[accounts[i]].to;\\n      }\\n    }\\n    return accounts;\\n  }\\n\\n  // length of optOutHistory - needed for retrieving paginated results from optOutPage()\\n  function optOutLength() public view returns (uint256) {\\n    return optOutHistory.length;\\n  }\\n\\n  // returns list of actively opted-out addresses using pagination\\n  function optOutPage(uint256 size, uint256 page) public view returns (address[] memory) {\\n    page = size*page;\\n    uint256 current = currentEpoch();\\n    uint256 n = 0;\\n    for(uint256 i=page; i<optOutHistory.length; i++) {\\n      if(registry[optOutHistory[i]].start <= current && registry[optOutHistory[i]].expiration > current && registry[optOutHistory[i]].to == address(0)) {\\n        n++;\\n        if(n == size) { break; }\\n      }\\n    }\\n    address[] memory optOuts = new address[](n);\\n    n = 0;\\n    for(uint256 i=page; i<optOutHistory.length; i++) {\\n      if(registry[optOutHistory[i]].start <= current && registry[optOutHistory[i]].expiration > current && registry[optOutHistory[i]].to == address(0)) {\\n        optOuts[n] = optOutHistory[i];\\n        n++;\\n        if(n == size) { break; }\\n      }\\n    }\\n    return optOuts;\\n  }\\n\\n  // length of forwardHistory - needed for retrieving paginated results from forwardPage()\\n  function forwardLength() public view returns (uint256) {\\n    return forwardHistory.length;\\n  }\\n\\n  // returns list of actively opted-out addresses using pagination\\n  function forwardPage(uint256 size, uint256 page) public view returns (address[] memory) {\\n    page = size*page;\\n    uint256 current = currentEpoch();\\n    uint256 n = 0;\\n    for(uint256 i=page; i<forwardHistory.length; i++) {\\n      if(registry[forwardHistory[i]].start <= current && registry[forwardHistory[i]].expiration > current && registry[forwardHistory[i]].to != address(0)) {\\n        n++;\\n        if(n == size) { break; }\\n      }\\n    }\\n    address[] memory forwards = new address[](n*2);\\n    n = 0;\\n    for(uint256 i=page; i<forwardHistory.length; i++) {\\n      if(registry[forwardHistory[i]].start <= current && registry[forwardHistory[i]].expiration > current && registry[forwardHistory[i]].to != address(0)) {\\n        forwards[n] = forwardHistory[i];\\n        forwards[n+1] = registry[forwardHistory[i]].to;\\n        n+=2;\\n        if(n == size*2) { break; }\\n      }\\n    }\\n    return forwards;\\n  }\\n\\n  // returns start of current Epoch\\n  function currentEpoch() public view returns (uint256) {\\n    return block.timestamp/eDuration*eDuration;\\n  }\\n\\n  // returns start of next Epoch\\n  function nextEpoch() public view returns (uint256) {\\n    return block.timestamp/eDuration*eDuration+eDuration;\\n  }\\n\\n  // only used for rescuing mistakenly sent funds or other unexpected needs\\n  function execute(address _to, uint256 _value, bytes calldata _data) external onlyOwner returns (bool, bytes memory) {\\n    (bool success, bytes memory result) = _to.call{value:_value}(_data);\\n    return (success, result);\\n  }\\n\\n  // multi-sig functions for edge cases\\n  function forceRegistry(address _from, address _to) public onlyOwner {\\n    uint256 current = currentEpoch();\\n    require(registry[_from].start == 0 || registry[_from].expiration < current,\\\"Registration is still active\\\");\\n    registry[_from].start = current+eDuration;\\n    registry[_from].to = _to;\\n    registry[_from].expiration = 0xfffffffff;\\n    if(_to == address(0)) {\\n      // prevent duplicate entry in optOutHistory array\\n      if(!inOptOutHistory[_from]) {\\n        optOutHistory.push(_from);\\n        inOptOutHistory[_from] = true;\\n      }\\n    } else if(!inForwardHistory[_from]) {\\n        forwardHistory.push(_from);\\n        inForwardHistory[_from] = true;\\n    }\\n    emit setReg(_from, _to, registry[_from].start);\\n  }\\n\\n  function forceToExpire(address _from) public onlyOwner {\\n    uint256 next = nextEpoch();\\n    require(registry[_from].start > 0 && registry[_from].expiration > next,\\\"Not registered or expiration already pending\\\");\\n    // if not started yet, nullify instead of setting expiration\\n    if(next == registry[_from].start) {\\n      registry[_from].start = 0;\\n      registry[_from].to = address(0);\\n    } else {\\n      registry[_from].expiration = next;\\n    }\\n    emit expReg(_from, next);\\n  }\\n\\n  event setReg(address indexed _from, address indexed _to, uint256 indexed _start);\\n  event expReg(address indexed _from, uint256 indexed _end);\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n\\n\\t  address private _owner = 0xe39b8617D571CEe5e75e1EC6B2bb40DdC8CF6Fa3; // Votium multi-sig address\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"expReg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"setReg\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"batchAddressCheck\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"forceRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"forceToExpire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"forwardHistory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"forwardPage\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inForwardHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inOptOutHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"optOutHistory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optOutLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"optOutPage\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setToExpire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AddressRegistry","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}