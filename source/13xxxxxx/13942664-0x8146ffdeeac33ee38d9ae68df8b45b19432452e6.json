{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/devin/gysr/core-private/contracts/ERC721StakingModule.sol\": {\r\n      \"content\": \"/*\\nERC721StakingModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./interfaces/IStakingModule.sol\\\";\\n\\n/**\\n * @title ERC721 staking module\\n *\\n * @notice this staking module allows users to deposit one or more ERC721\\n * tokens in exchange for shares credited to their address. When the user\\n * unstakes, these shares will be burned and a reward will be distributed.\\n */\\ncontract ERC721StakingModule is IStakingModule {\\n    // constant\\n    uint256 public constant SHARES_PER_TOKEN = 10**18;\\n\\n    // members\\n    IERC721 private immutable _token;\\n    address private immutable _factory;\\n\\n    mapping(address => uint256) public counts;\\n    mapping(uint256 => address) public owners;\\n    mapping(address => mapping(uint256 => uint256)) public tokenByOwner;\\n    mapping(uint256 => uint256) public tokenIndex;\\n\\n    /**\\n     * @param token_ the token that will be rewarded\\n     */\\n    constructor(address token_, address factory_) {\\n        require(IERC165(token_).supportsInterface(0x80ac58cd), \\\"smn1\\\");\\n        _token = IERC721(token_);\\n        _factory = factory_;\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function tokens()\\n        external\\n        view\\n        override\\n        returns (address[] memory tokens_)\\n    {\\n        tokens_ = new address[](1);\\n        tokens_[0] = address(_token);\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function balances(address user)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory balances_)\\n    {\\n        balances_ = new uint256[](1);\\n        balances_[0] = counts[user];\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function factory() external view override returns (address) {\\n        return _factory;\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function totals()\\n        external\\n        view\\n        override\\n        returns (uint256[] memory totals_)\\n    {\\n        totals_ = new uint256[](1);\\n        totals_[0] = _token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function stake(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external override onlyOwner returns (address, uint256) {\\n        // validate\\n        require(amount > 0, \\\"smn2\\\");\\n        require(amount <= _token.balanceOf(user), \\\"smn3\\\");\\n        require(data.length == 32 * amount, \\\"smn4\\\");\\n\\n        uint256 count = counts[user];\\n\\n        // stake\\n        for (uint256 i = 0; i < amount; i++) {\\n            // get token id\\n            uint256 id;\\n            uint256 pos = 132 + 32 * i;\\n            assembly {\\n                id := calldataload(pos)\\n            }\\n\\n            // ownership mappings\\n            owners[id] = user;\\n            uint256 len = count + i;\\n            tokenByOwner[user][len] = id;\\n            tokenIndex[id] = len;\\n\\n            // transfer to module\\n            _token.transferFrom(user, address(this), id);\\n        }\\n\\n        // update position\\n        counts[user] = count + amount;\\n\\n        // emit\\n        uint256 shares = amount * SHARES_PER_TOKEN;\\n        emit Staked(user, address(_token), amount, shares);\\n\\n        return (user, shares);\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function unstake(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external override onlyOwner returns (address, uint256) {\\n        // validate\\n        require(amount > 0, \\\"smn5\\\");\\n        uint256 count = counts[user];\\n        require(amount <= count, \\\"smn6\\\");\\n        require(data.length == 32 * amount, \\\"smn7\\\");\\n\\n        // unstake\\n        for (uint256 i = 0; i < amount; i++) {\\n            // get token id\\n            uint256 id;\\n            uint256 pos = 132 + 32 * i;\\n            assembly {\\n                id := calldataload(pos)\\n            }\\n\\n            // ownership\\n            require(owners[id] == user, \\\"smn8\\\");\\n            delete owners[id];\\n\\n            // clean up ownership mappings\\n            uint256 lastIndex = count - 1 - i;\\n            if (amount != count) {\\n                // reindex on partial unstake\\n                uint256 index = tokenIndex[id];\\n                if (index != lastIndex) {\\n                    uint256 lastId = tokenByOwner[user][lastIndex];\\n                    tokenByOwner[user][index] = lastId;\\n                    tokenIndex[lastId] = index;\\n                }\\n            }\\n            delete tokenByOwner[user][lastIndex];\\n            delete tokenIndex[id];\\n\\n            // transfer to user\\n            _token.safeTransferFrom(address(this), user, id);\\n        }\\n\\n        // update position\\n        counts[user] = count - amount;\\n\\n        // emit\\n        uint256 shares = amount * SHARES_PER_TOKEN;\\n        emit Unstaked(user, address(_token), amount, shares);\\n\\n        return (user, shares);\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function claim(\\n        address user,\\n        uint256 amount,\\n        bytes calldata\\n    ) external override onlyOwner returns (address, uint256) {\\n        // validate\\n        require(amount > 0, \\\"smn9\\\");\\n        require(amount <= counts[user], \\\"smn10\\\");\\n\\n        uint256 shares = amount * SHARES_PER_TOKEN;\\n        emit Claimed(user, address(_token), amount, shares);\\n        return (user, shares);\\n    }\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function update(address) external override {}\\n\\n    /**\\n     * @inheritdoc IStakingModule\\n     */\\n    function clean() external override {}\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/OwnerController.sol\": {\r\n      \"content\": \"/*\\nOwnerController\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Owner controller\\n *\\n * @notice this base contract implements an owner-controller access model.\\n *\\n * @dev the contract is an adapted version of the OpenZeppelin Ownable contract.\\n * It allows the owner to designate an additional account as the controller to\\n * perform restricted operations.\\n *\\n * Other changes include supporting role verification with a require method\\n * in addition to the modifier option, and removing some unneeded functionality.\\n *\\n * Original contract here:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\ncontract OwnerController {\\n    address private _owner;\\n    address private _controller;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    event ControlTransferred(\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        _controller = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n        emit ControlTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current controller.\\n     */\\n    function controller() public view returns (address) {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @dev Modifier that throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"oc1\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that throws if called by any account other than the controller.\\n     */\\n    modifier onlyController() {\\n        require(_controller == msg.sender, \\\"oc2\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    function requireOwner() internal view {\\n        require(_owner == msg.sender, \\\"oc1\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the controller.\\n     */\\n    function requireController() internal view {\\n        require(_controller == msg.sender, \\\"oc2\\\");\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`). This can\\n     * include renouncing ownership by transferring to the zero address.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual {\\n        requireOwner();\\n        require(newOwner != address(0), \\\"oc3\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a new account (`newController`).\\n     * Can only be called by the owner.\\n     */\\n    function transferControl(address newController) public virtual {\\n        requireOwner();\\n        require(newController != address(0), \\\"oc4\\\");\\n        emit ControlTransferred(_controller, newController);\\n        _controller = newController;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/info/ERC721StakingModuleInfo.sol\": {\r\n      \"content\": \"/*\\nERC721StakingModuleInfo\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\nimport \\\"../interfaces/IStakingModule.sol\\\";\\nimport \\\"../ERC721StakingModule.sol\\\";\\n\\n/**\\n * @title ERC721 staking module info library\\n *\\n * @notice this library provides read-only convenience functions to query\\n * additional information about the ERC721StakingModule contract.\\n */\\nlibrary ERC721StakingModuleInfo {\\n    /**\\n     * @notice convenience function to get token metadata in a single call\\n     * @param module address of staking module\\n     * @return address\\n     * @return name\\n     * @return symbol\\n     * @return decimals\\n     */\\n    function token(address module)\\n        public\\n        view\\n        returns (\\n            address,\\n            string memory,\\n            string memory,\\n            uint8\\n        )\\n    {\\n        IStakingModule m = IStakingModule(module);\\n        IERC721Metadata tkn = IERC721Metadata(m.tokens()[0]);\\n        if (!tkn.supportsInterface(0x5b5e139f)) {\\n            return (address(tkn), \\\"\\\", \\\"\\\", 0);\\n        }\\n        return (address(tkn), tkn.name(), tkn.symbol(), 0);\\n    }\\n\\n    /**\\n     * @notice quote the share value for an amount of tokens\\n     * @param module address of staking module\\n     * @param addr account address of interest\\n     * @param amount number of tokens. if zero, return entire share balance\\n     * @return number of shares\\n     */\\n    function shares(\\n        address module,\\n        address addr,\\n        uint256 amount\\n    ) public view returns (uint256) {\\n        ERC721StakingModule m = ERC721StakingModule(module);\\n\\n        // return all user shares\\n        if (amount == 0) {\\n            return m.counts(addr) * m.SHARES_PER_TOKEN();\\n        }\\n\\n        require(amount <= m.counts(addr), \\\"smni1\\\");\\n        return amount * m.SHARES_PER_TOKEN();\\n    }\\n\\n    /**\\n     * @notice get shares per token\\n     * @param module address of staking module\\n     * @return current shares per token\\n     */\\n    function sharesPerToken(address module) public view returns (uint256) {\\n        ERC721StakingModule m = ERC721StakingModule(module);\\n        return m.SHARES_PER_TOKEN() * 1e18;\\n    }\\n\\n    /**\\n     * @notice get staked token ids for user\\n     * @param module address of staking module\\n     * @param addr account address of interest\\n     * @param amount number of tokens to enumerate\\n     * @param start token index to start at\\n     * @return ids array of token ids\\n     */\\n    function tokenIds(\\n        address module,\\n        address addr,\\n        uint256 amount,\\n        uint256 start\\n    ) public view returns (uint256[] memory ids) {\\n        ERC721StakingModule m = ERC721StakingModule(module);\\n        uint256 sz = m.counts(addr);\\n        require(start + amount <= sz, \\\"smni2\\\");\\n\\n        if (amount == 0) {\\n            amount = sz - start;\\n        }\\n\\n        ids = new uint256[](amount);\\n\\n        for (uint256 i = 0; i < amount; i++) {\\n            ids[i] = m.tokenByOwner(addr, i + start);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/interfaces/IEvents.sol\": {\r\n      \"content\": \"/*\\nIEvents\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n */\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title GYSR event system\\n *\\n * @notice common interface to define GYSR event system\\n */\\ninterface IEvents {\\n    // staking\\n    event Staked(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event Unstaked(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event Claimed(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n\\n    // rewards\\n    event RewardsDistributed(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event RewardsFunded(\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n    event RewardsUnlocked(address indexed token, uint256 shares);\\n    event RewardsExpired(\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    // gysr\\n    event GysrSpent(address indexed user, uint256 amount);\\n    event GysrVested(address indexed user, uint256 amount);\\n    event GysrWithdrawn(uint256 amount);\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/interfaces/IStakingModule.sol\": {\r\n      \"content\": \"/*\\nIStakingModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IEvents.sol\\\";\\n\\nimport \\\"../OwnerController.sol\\\";\\n\\n/**\\n * @title Staking module interface\\n *\\n * @notice this contract defines the common interface that any staking module\\n * must implement to be compatible with the modular Pool architecture.\\n */\\nabstract contract IStakingModule is OwnerController, IEvents {\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n\\n    /**\\n     * @return array of staking tokens\\n     */\\n    function tokens() external view virtual returns (address[] memory);\\n\\n    /**\\n     * @notice get balance of user\\n     * @param user address of user\\n     * @return balances of each staking token\\n     */\\n    function balances(address user)\\n        external\\n        view\\n        virtual\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @return address of module factory\\n     */\\n    function factory() external view virtual returns (address);\\n\\n    /**\\n     * @notice get total staked amount\\n     * @return totals for each staking token\\n     */\\n    function totals() external view virtual returns (uint256[] memory);\\n\\n    /**\\n     * @notice stake an amount of tokens for user\\n     * @param user address of user\\n     * @param amount number of tokens to stake\\n     * @param data additional data\\n     * @return address of staking account\\n     * @return number of shares minted for stake\\n     */\\n    function stake(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual returns (address, uint256);\\n\\n    /**\\n     * @notice unstake an amount of tokens for user\\n     * @param user address of user\\n     * @param amount number of tokens to unstake\\n     * @param data additional data\\n     * @return address of staking account\\n     * @return number of shares burned for unstake\\n     */\\n    function unstake(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual returns (address, uint256);\\n\\n    /**\\n     * @notice quote the share value for an amount of tokens without unstaking\\n     * @param user address of user\\n     * @param amount number of tokens to claim with\\n     * @param data additional data\\n     * @return address of staking account\\n     * @return number of shares that the claim amount is worth\\n     */\\n    function claim(\\n        address user,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external virtual returns (address, uint256);\\n\\n    /**\\n     * @notice method called by anyone to update accounting\\n     * @param user address of user for update\\n     * @dev will only be called ad hoc and should not contain essential logic\\n     */\\n    function update(address user) external virtual;\\n\\n    /**\\n     * @notice method called by owner to clean up and perform additional accounting\\n     * @dev will only be called ad hoc and should not contain any essential logic\\n     */\\n    function clean() external virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"sharesPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ERC721StakingModuleInfo","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}