{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Governance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./TellorVars.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\nimport \\\"./interfaces/IController.sol\\\";\\nimport \\\"./interfaces/ITreasury.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Governance\\n @dev This is the Governance contract which defines the functionality for\\n * proposing and executing votes, handling vote mechanism for voters,\\n * and distributing funds for initiators and disputed reporters depending\\n * on result.\\n*/\\ncontract Governance is TellorVars {\\n    // Storage\\n    uint256 public voteCount; // total number of votes initiated\\n    uint256 public disputeFee; // dispute fee for a vote\\n    mapping(address => Delegation[]) private delegateInfo; // mapping of delegate addresses to an array of their delegations\\n    mapping(bytes4 => bool) private functionApproved; // mapping of function hashes to bools of whether the functions are approved\\n    mapping(bytes32 => uint256[]) private voteRounds; // mapping of vote identifier hashes to an array of dispute IDs\\n    mapping(uint256 => Vote) private voteInfo; // mapping of vote IDs to the details of the vote\\n    mapping(uint256 => Dispute) private disputeInfo; // mapping of dispute IDs to the details of the dispute\\n    mapping(bytes32 => uint256) private openDisputesOnId; // mapping of a query ID to the number of disputes on that query ID\\n    enum VoteResult {\\n        FAILED,\\n        PASSED,\\n        INVALID\\n    } // status of a potential vote\\n\\n    // Structs\\n    struct Delegation {\\n        address delegate; // address of holder delegating their tokens\\n        uint256 fromBlock; // block number when address started delegating\\n    }\\n\\n    struct Dispute {\\n        bytes32 queryId; // query ID of disputed value\\n        uint256 timestamp; // timestamp of disputed value\\n        bytes value; // disputed value\\n        address disputedReporter; // reporter who submitted the disputed value\\n    }\\n\\n    struct Vote {\\n        bytes32 identifierHash; // identifier hash of the vote\\n        uint256 voteRound; // the round of voting on a given dispute or proposal\\n        uint256 startDate; // timestamp of when vote was initiated\\n        uint256 blockNumber; // block number of when vote was initiated\\n        uint256 fee; // fee associated with the vote\\n        uint256 tallyDate; // timestamp of when the votes were tallied\\n        uint256 doesSupport; // number of votes in favor\\n        uint256 against; // number of votes against\\n        bool executed; // boolean of is the dispute settled\\n        VoteResult result; // VoteResult of did the vote pass?\\n        bool isDispute; // boolean of is the vote a dispute as opposed to a proposal\\n        uint256 invalidQuery; // number of votes for invalid\\n        bytes data; // arguments used to execute a proposal\\n        bytes4 voteFunction; // hash of the function associated with a proposal vote\\n        address voteAddress; // address of contract to execute function on\\n        address initiator; // address which initiated dispute/proposal\\n        mapping(address => bool) voted; // mapping of address to whether or not they voted\\n    }\\n\\n    // Events\\n    event DelegateSet(address _delegate, address _delegator); // Emitted when voting delegate is set\\n    event NewDispute(\\n        uint256 _disputeId,\\n        bytes32 _queryId,\\n        uint256 _timestamp,\\n        address _reporter\\n    ); // Emitted when a new dispute is opened\\n    event NewVote(\\n        address _contract,\\n        bytes4 _function,\\n        bytes _data,\\n        uint256 _disputeId\\n    ); // Emitted when a new proposal vote is initiated\\n    event Voted(\\n        uint256 _disputeId,\\n        bool _supports,\\n        address _voter,\\n        uint256 _voteWeight,\\n        bool _invalidQuery\\n    ); // Emitted when an address casts their vote\\n    event VoteExecuted(uint256 _disputeId, VoteResult _result); // Emitted when a vote is executed\\n    event VoteTallied(\\n        uint256 _disputeId,\\n        VoteResult _result,\\n        address _initiator,\\n        address _reporter\\n    ); // Emitted when all casting for a vote is tallied\\n\\n    // Functions\\n    /**\\n     * @dev Initializes approved function hashes and updates the minimum dispute fees\\n     */\\n    constructor() {\\n        bytes4[10] memory _funcs = [\\n            bytes4(0x3c46a185), // changeControllerContract(address)\\n            0xe8ce51d7, // changeGovernanceContract(address)\\n            0x1cbd3151, // changeOracleContract(address)\\n            0xbd87e0c9, // changeTreasuryContract(address)\\n            0x740358e6, // changeUint(bytes32,uint256)\\n            0x40c10f19, // mint(address,uint256)\\n            0xe48d4b3b, // setApprovedFunction(bytes4,bool)\\n            0x5d183cfa, // changeReportingLock(uint256)\\n            0x6d53585f, // changeTimeBasedReward(uint256)\\n            0x6274885f // issueTreasury(uint256,uint256,uint256)\\n        ];\\n        // Approve function hashes and update dispute fee\\n        for (uint256 _i = 0; _i < _funcs.length; _i++) {\\n            functionApproved[_funcs[_i]] = true;\\n        }\\n        updateMinDisputeFee();\\n    }\\n\\n    /**\\n     * @dev Helps initialize a dispute by assigning it a disputeId\\n     * @param _queryId being disputed\\n     * @param _timestamp being disputed\\n     */\\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external {\\n        // Ensure mined block is not 0\\n        address _oracle = IController(TELLOR_ADDRESS).addresses(\\n            _ORACLE_CONTRACT\\n        );\\n        require(\\n            IOracle(_oracle).getBlockNumberByTimestamp(_queryId, _timestamp) !=\\n                0,\\n            \\\"Mined block is 0\\\"\\n        );\\n        address _reporter = IOracle(_oracle).getReporterByTimestamp(\\n            _queryId,\\n            _timestamp\\n        );\\n        bytes32 _hash = keccak256(abi.encodePacked(_queryId, _timestamp));\\n        // Increment vote count and push new vote round\\n        voteCount++;\\n        uint256 _disputeId = voteCount;\\n        voteRounds[_hash].push(_disputeId);\\n        // Check if dispute is started within correct time frame\\n        if (voteRounds[_hash].length > 1) {\\n            uint256 _prevId = voteRounds[_hash][voteRounds[_hash].length - 2];\\n            require(\\n                block.timestamp - voteInfo[_prevId].tallyDate < 1 days,\\n                \\\"New dispute round must be started within a day\\\"\\n            ); // Within a day for new round\\n        } else {\\n            require(\\n                block.timestamp - _timestamp < IOracle(_oracle).reportingLock(),\\n                \\\"Dispute must be started within 12 hours...same variable as reporting lock\\\"\\n            ); // New dispute within reporting lock\\n            openDisputesOnId[_queryId]++;\\n        }\\n        // Create new vote and dispute\\n        Vote storage _thisVote = voteInfo[_disputeId];\\n        Dispute storage _thisDispute = disputeInfo[_disputeId];\\n        // Initialize dispute information - query ID, timestamp, value, etc.\\n        _thisDispute.queryId = _queryId;\\n        _thisDispute.timestamp = _timestamp;\\n        _thisDispute.value = IOracle(_oracle).getValueByTimestamp(\\n            _queryId,\\n            _timestamp\\n        );\\n        _thisDispute.disputedReporter = _reporter;\\n        // Initialize vote information - hash, initiator, block number, etc.\\n        _thisVote.identifierHash = _hash;\\n        _thisVote.initiator = msg.sender;\\n        _thisVote.blockNumber = block.number;\\n        _thisVote.startDate = block.timestamp;\\n        _thisVote.voteRound = voteRounds[_hash].length;\\n        _thisVote.isDispute = true;\\n        // Calculate dispute fee based on number of current vote rounds\\n        uint256 _fee;\\n        if (voteRounds[_hash].length == 1) {\\n            _fee = disputeFee * 2**(openDisputesOnId[_queryId] - 1);\\n            IOracle(_oracle).removeValue(_queryId, _timestamp);\\n        } else {\\n            _fee = disputeFee * 2**(voteRounds[_hash].length - 1);\\n        }\\n        _thisVote.fee = (_fee * 9) / 10;\\n        require(\\n            IController(TELLOR_ADDRESS).approveAndTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _fee\\n            ),\\n            \\\"Fee must be paid\\\"\\n        ); // This is the fork fee. Returned if dispute passes\\n        // Add an initial tip and change the current staking status of reporter\\n        IOracle(_oracle).tipQuery(_queryId, _fee - _thisVote.fee, bytes(\\\"\\\"));\\n        (uint256 _status, ) = IController(TELLOR_ADDRESS).getStakerInfo(\\n            _thisDispute.disputedReporter\\n        );\\n        if (_status == 1) {\\n            uint256 _stakeCount = IController(TELLOR_ADDRESS).getUintVar(\\n                _STAKE_COUNT\\n            );\\n            IController(TELLOR_ADDRESS).changeUint(\\n                _STAKE_COUNT,\\n                _stakeCount - 1\\n            );\\n            updateMinDisputeFee();\\n        }\\n        IController(TELLOR_ADDRESS).changeStakingStatus(_reporter, 3);\\n        emit NewDispute(_disputeId, _queryId, _timestamp, _reporter);\\n    }\\n\\n    /**\\n     * @dev Allows a delegate address to vote on behalf of another address\\n     * @param _delegate is the address the sender is delegating to\\n     */\\n    function delegate(address _delegate) external {\\n        Delegation[] storage checkpoints = delegateInfo[msg.sender];\\n        // Check if sender hasn't delegated the specific address, or if the current delegate is from old block number\\n        if (\\n            checkpoints.length == 0 ||\\n            checkpoints[checkpoints.length - 1].fromBlock != block.number\\n        ) {\\n            // Push a new delegate\\n            checkpoints.push(\\n                Delegation({\\n                    delegate: _delegate,\\n                    fromBlock: uint128(block.number)\\n                })\\n            );\\n        } else {\\n            // Else, update old delegate\\n            Delegation storage oldCheckPoint = checkpoints[\\n                checkpoints.length - 1\\n            ];\\n            oldCheckPoint.delegate = _delegate;\\n        }\\n        emit DelegateSet(_delegate, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Queries the delegate of _user at a specific _blockNumber\\n     * @param _user The address delegating voting power\\n     * @param _blockNumber The block number for which the delegate is retrieved\\n     * @return The delegate at _blockNumber specified\\n     */\\n    function delegateOfAt(address _user, uint256 _blockNumber)\\n        public\\n        view\\n        returns (address)\\n    {\\n        Delegation[] storage checkpoints = delegateInfo[_user];\\n        // Checks if delegate doesn't exist or has block number greater than queried\\n        if (\\n            checkpoints.length == 0 || checkpoints[0].fromBlock > _blockNumber\\n        ) {\\n            return address(0);\\n        } else {\\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock)\\n                return checkpoints[checkpoints.length - 1].delegate;\\n            // Binary search of correct delegate address\\n            uint256 _min = 0;\\n            uint256 _max = checkpoints.length - 2;\\n            while (_max > _min) {\\n                uint256 _mid = (_max + _min + 1) / 2;\\n                if (checkpoints[_mid].fromBlock == _blockNumber) {\\n                    return checkpoints[_mid].delegate;\\n                } else if (checkpoints[_mid].fromBlock < _blockNumber) {\\n                    _min = _mid;\\n                } else {\\n                    _max = _mid - 1;\\n                }\\n            }\\n            return checkpoints[_min].delegate;\\n        }\\n    }\\n\\n    /**\\n     * @dev Executes vote by using result and transferring balance to either\\n     * initiator or disputed reporter\\n     * @param _disputeId is the ID of the vote being executed\\n     */\\n    function executeVote(uint256 _disputeId) external {\\n        // Ensure validity of vote ID, vote has been executed, and vote must be tallied\\n        Vote storage _thisVote = voteInfo[_disputeId];\\n        require(_disputeId <= voteCount, \\\"Vote ID must be valid\\\");\\n        require(!_thisVote.executed, \\\"Vote has been executed\\\");\\n        require(_thisVote.tallyDate > 0, \\\"Vote must be tallied\\\");\\n        // Ensure vote must be final vote and that time has to be pass (86400 = 24 * 60 * 60 for seconds in a day)\\n        require(\\n            voteRounds[_thisVote.identifierHash].length == _thisVote.voteRound,\\n            \\\"Must be the final vote\\\"\\n        );\\n        require(\\n            block.timestamp - _thisVote.tallyDate >=\\n                86400 * _thisVote.voteRound,\\n            \\\"Vote needs to be tallied and time must pass\\\"\\n        );\\n        _thisVote.executed = true;\\n        if (!_thisVote.isDispute) {\\n            // If vote is not in dispute and passed, execute proper vote function with vote data\\n            if (_thisVote.result == VoteResult.PASSED) {\\n                address _destination = _thisVote.voteAddress;\\n                bool _succ;\\n                bytes memory _res;\\n                (_succ, _res) = _destination.call(\\n                    abi.encodePacked(_thisVote.voteFunction, _thisVote.data)\\n                ); // Be sure to send enough gas!\\n            }\\n            emit VoteExecuted(_disputeId, _thisVote.result);\\n        } else {\\n            Dispute storage _thisDispute = disputeInfo[_disputeId];\\n            if (\\n                voteRounds[_thisVote.identifierHash].length ==\\n                _thisVote.voteRound\\n            ) {\\n                openDisputesOnId[_thisDispute.queryId]--;\\n            }\\n            IController _controller = IController(TELLOR_ADDRESS);\\n            uint256 _i;\\n            uint256 _voteID;\\n            if (_thisVote.result == VoteResult.PASSED) {\\n                // If vote is in dispute and passed, iterate through each vote round and transfer the dispute to initiator\\n                for (\\n                    _i = voteRounds[_thisVote.identifierHash].length;\\n                    _i > 0;\\n                    _i--\\n                ) {\\n                    _voteID = voteRounds[_thisVote.identifierHash][_i - 1];\\n                    _thisVote = voteInfo[_voteID];\\n                    // If the first vote round, also make sure to slash the reporter and send their balance to the initiator\\n                    if (_i == 1) {\\n                        _controller.slashReporter(\\n                            _thisDispute.disputedReporter,\\n                            _thisVote.initiator\\n                        );\\n                    }\\n                    _controller.transfer(_thisVote.initiator, _thisVote.fee);\\n                }\\n            } else if (_thisVote.result == VoteResult.INVALID) {\\n                // If vote is in dispute and is invalid, iterate through each vote round and transfer the dispute fee to initiator\\n                for (\\n                    _i = voteRounds[_thisVote.identifierHash].length;\\n                    _i > 0;\\n                    _i--\\n                ) {\\n                    _voteID = voteRounds[_thisVote.identifierHash][_i - 1];\\n                    _thisVote = voteInfo[_voteID];\\n                    _controller.transfer(_thisVote.initiator, _thisVote.fee);\\n                }\\n                uint256 _stakeCount = IController(TELLOR_ADDRESS).getUintVar(\\n                    _STAKE_COUNT\\n                );\\n                IController(TELLOR_ADDRESS).changeUint(\\n                    _STAKE_COUNT,\\n                    _stakeCount + 1\\n                );\\n                _controller.changeStakingStatus(\\n                    _thisDispute.disputedReporter,\\n                    1\\n                ); // Change staking status of disputed reporter, but don't slash\\n            } else if (_thisVote.result == VoteResult.FAILED) {\\n                // If vote is in dispute and fails, iterate through each vote round and transfer the dispute fee to disputed reporter\\n                uint256 _reporterReward = 0;\\n                for (\\n                    _i = voteRounds[_thisVote.identifierHash].length;\\n                    _i > 0;\\n                    _i--\\n                ) {\\n                    _voteID = voteRounds[_thisVote.identifierHash][_i - 1];\\n                    _thisVote = voteInfo[_voteID];\\n                    _reporterReward += _thisVote.fee;\\n                }\\n                _controller.transfer(\\n                    _thisDispute.disputedReporter,\\n                    _reporterReward\\n                );\\n                uint256 _stakeCount = IController(TELLOR_ADDRESS).getUintVar(\\n                    _STAKE_COUNT\\n                );\\n                IController(TELLOR_ADDRESS).changeUint(\\n                    _STAKE_COUNT,\\n                    _stakeCount - 1\\n                );\\n                _controller.changeStakingStatus(\\n                    _thisDispute.disputedReporter,\\n                    1\\n                );\\n            }\\n            emit VoteExecuted(_disputeId, voteInfo[_disputeId].result);\\n        }\\n    }\\n\\n    /**\\n     * @dev Proposes a vote for an associated Tellor contract and function, and defines the properties of the vote\\n     * @param _contract is the Tellor contract to propose a vote for -> used to calculate identifier hash\\n     * @param _function is the Tellor function to propose a vote for -> used to calculate identifier hash\\n     * @param _data is the function argument data associated with the vote proposal -> used to calculate identifier hash\\n     * @param _timestamp is the timestamp associated with the vote -> used to calculate identifier hash\\n     */\\n    function proposeVote(\\n        address _contract,\\n        bytes4 _function,\\n        bytes calldata _data,\\n        uint256 _timestamp\\n    ) external {\\n        // Update vote count, vote ID, current vote, and timestamp\\n        voteCount++;\\n        uint256 _disputeId = voteCount;\\n        Vote storage _thisVote = voteInfo[_disputeId];\\n        if (_timestamp == 0) {\\n            _timestamp = block.timestamp;\\n        }\\n        // Calculate vote identifier hash and push to vote rounds\\n        bytes32 _hash = keccak256(\\n            abi.encodePacked(_contract, _function, _data, _timestamp)\\n        );\\n        voteRounds[_hash].push(_disputeId);\\n        // Ensure new dispute round started within a day\\n        if (voteRounds[_hash].length > 1) {\\n            uint256 _prevId = voteRounds[_hash][voteRounds[_hash].length - 2];\\n            require(\\n                block.timestamp - voteInfo[_prevId].tallyDate < 1 days,\\n                \\\"New dispute round must be started within a day\\\"\\n            ); // 1 day for new disputes\\n        }\\n        // Calculate fee to do anything (just 10 tokens flat, no refunds.  Goes up quickly to prevent spamming)\\n        uint256 _fee = 10e18 * 2**(voteRounds[_hash].length - 1);\\n        require(\\n            IController(TELLOR_ADDRESS).approveAndTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _fee\\n            ),\\n            \\\"Fee must be paid\\\"\\n        );\\n        // Update information on vote -- hash, vote round, start date, block number, fee, etc.\\n        _thisVote.identifierHash = _hash;\\n        _thisVote.voteRound = voteRounds[_hash].length;\\n        _thisVote.startDate = block.timestamp;\\n        _thisVote.blockNumber = block.number;\\n        _thisVote.fee = _fee;\\n        _thisVote.data = _data;\\n        _thisVote.voteFunction = _function;\\n        _thisVote.voteAddress = _contract;\\n        _thisVote.initiator = msg.sender;\\n        // Contract must be a Tellor contract, and function must be approved\\n        require(\\n            _contract == TELLOR_ADDRESS ||\\n                _contract ==\\n                IController(TELLOR_ADDRESS).addresses(_GOVERNANCE_CONTRACT) ||\\n                _contract ==\\n                IController(TELLOR_ADDRESS).addresses(_TREASURY_CONTRACT) ||\\n                _contract ==\\n                IController(TELLOR_ADDRESS).addresses(_ORACLE_CONTRACT),\\n            \\\"Must interact with the Tellor system\\\"\\n        );\\n        require(functionApproved[_function], \\\"Function must be approved\\\");\\n        emit NewVote(_contract, _function, _data, _disputeId);\\n    }\\n\\n    /**\\n     * @dev Sets a given function's approved status\\n     * @param _func is the hash of the function to change status\\n     * @param _val is the boolean of the function's status (approved or not)\\n     */\\n    function setApprovedFunction(bytes4 _func, bool _val) public {\\n        require(\\n            msg.sender ==\\n                IController(TELLOR_ADDRESS).addresses(_GOVERNANCE_CONTRACT),\\n            \\\"Only the Governance contract can change a function's status\\\"\\n        );\\n        functionApproved[_func] = _val;\\n    }\\n\\n    /**\\n     * @dev Tallies the votes and begins the 1 day challenge period\\n     * @param _disputeId is the dispute id\\n     */\\n    function tallyVotes(uint256 _disputeId) external {\\n        // Ensure vote has not been executed and that vote has not been tallied\\n        Vote storage _thisVote = voteInfo[_disputeId];\\n        require(!_thisVote.executed, \\\"Dispute has been already executed\\\");\\n        require(_thisVote.tallyDate == 0, \\\"Vote should not already be tallied\\\");\\n        require(_disputeId <= voteCount, \\\"Vote does not exist\\\");\\n        // Determine appropriate vote duration and quorum based on dispute status\\n        uint256 _duration = 2 days;\\n        uint256 _quorum = 0;\\n        if (!_thisVote.isDispute) {\\n            _duration = 7 days;\\n            _quorum = 5;\\n        }\\n        // Ensure voting is not still open\\n        require(\\n            block.timestamp - _thisVote.startDate > _duration,\\n            \\\"Time for voting has not elapsed\\\"\\n        );\\n        // If there are more invalid votes than for and against, result is invalid\\n        if (\\n            _thisVote.invalidQuery >= _thisVote.doesSupport &&\\n            _thisVote.invalidQuery >= _thisVote.against &&\\n            _thisVote.isDispute\\n        ) {\\n            _thisVote.result = VoteResult.INVALID;\\n        } else if (_thisVote.doesSupport > _thisVote.against) {\\n            // If there are more support votes than against votes, and the vote has reached quorum, allow the vote to pass\\n            if (\\n                _thisVote.doesSupport >=\\n                ((IController(TELLOR_ADDRESS).uints(_TOTAL_SUPPLY) * _quorum) /\\n                    100)\\n            ) {\\n                _thisVote.result = VoteResult.PASSED;\\n                Dispute storage _thisDispute = disputeInfo[_disputeId];\\n                // In addition, change staking status of disputed miner as appropriate\\n                (uint256 _status, ) = IController(TELLOR_ADDRESS).getStakerInfo(\\n                    _thisDispute.disputedReporter\\n                );\\n                if (_thisVote.isDispute && _status == 3) {\\n                    IController(TELLOR_ADDRESS).changeStakingStatus(\\n                        _thisDispute.disputedReporter,\\n                        4\\n                    );\\n                }\\n            }\\n        }\\n        // If there are more against votes than support votes, the result failed\\n        else {\\n            _thisVote.result = VoteResult.FAILED;\\n        }\\n        _thisVote.tallyDate = block.timestamp; // Update time vote was tallied\\n        emit VoteTallied(\\n            _disputeId,\\n            _thisVote.result,\\n            _thisVote.initiator,\\n            disputeInfo[_disputeId].disputedReporter\\n        );\\n    }\\n\\n    /**\\n     * @dev This function updates the minimum dispute fee as a function of the amount\\n     * of staked miners\\n     */\\n    function updateMinDisputeFee() public {\\n        uint256 _stakeAmt = IController(TELLOR_ADDRESS).uints(_STAKE_AMOUNT);\\n        uint256 _trgtMiners = IController(TELLOR_ADDRESS).uints(_TARGET_MINERS);\\n        uint256 _stakeCount = IController(TELLOR_ADDRESS).uints(_STAKE_COUNT);\\n        uint256 _minFee = IController(TELLOR_ADDRESS).uints(\\n            _MINIMUM_DISPUTE_FEE\\n        );\\n        uint256 _reducer;\\n        // Calculate total dispute fee using stake count\\n        if (_stakeCount > 0) {\\n            _reducer =\\n                (((_stakeAmt - _minFee) * (_stakeCount * 1000)) / _trgtMiners) /\\n                1000;\\n        }\\n        if (_reducer >= _stakeAmt - _minFee) {\\n            disputeFee = _minFee;\\n        } else {\\n            disputeFee = _stakeAmt - _reducer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Enables the sender address to cast a vote\\n     * @param _disputeId is the ID of the vote\\n     * @param _supports is the address's vote: whether or not they support or are against\\n     * @param _invalidQuery is whether or not the dispute is valid\\n     */\\n    function vote(\\n        uint256 _disputeId,\\n        bool _supports,\\n        bool _invalidQuery\\n    ) external {\\n        require(\\n            delegateOfAt(msg.sender, voteInfo[_disputeId].blockNumber) ==\\n                address(0),\\n            \\\"the vote should not be delegated\\\"\\n        );\\n        _vote(msg.sender, _disputeId, _supports, _invalidQuery);\\n    }\\n\\n    /**\\n     * @dev Enables the sender address to cast a vote for other addresses\\n     * @param _addys is the array of addresses that the sender votes for\\n     * @param _disputeId is the ID of the vote\\n     * @param _supports is the address's vote: whether or not they support or are against\\n     * @param _invalidQuery is whether or not the dispute is valid\\n     */\\n    function voteFor(\\n        address[] calldata _addys,\\n        uint256 _disputeId,\\n        bool _supports,\\n        bool _invalidQuery\\n    ) external {\\n        for (uint256 _i = 0; _i < _addys.length; _i++) {\\n            require(\\n                delegateOfAt(_addys[_i], voteInfo[_disputeId].blockNumber) ==\\n                    msg.sender,\\n                \\\"Sender is not delegated to vote for this address\\\"\\n            );\\n            _vote(_addys[_i], _disputeId, _supports, _invalidQuery);\\n        }\\n    }\\n\\n    // Getters\\n    /**\\n     * @dev Determines if an address voted for a specific vote\\n     * @param _disputeId is the ID of the vote\\n     * @param _voter is the address of the voter to check for\\n     * @return bool of whether or note the address voted for the specific vote\\n     */\\n    function didVote(uint256 _disputeId, address _voter)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return voteInfo[_disputeId].voted[_voter];\\n    }\\n\\n    /**\\n     * @dev Returns info on a delegate for a given holder\\n     * @param _holder is the address of the holder of TRB tokens\\n     * @return address of the delegate at the given holder and block number\\n     * @return uint of the block number of the delegate\\n     */\\n    function getDelegateInfo(address _holder)\\n        external\\n        view\\n        returns (address, uint256)\\n    {\\n        if (delegateInfo[_holder].length > 0) {\\n            return (\\n                delegateOfAt(_holder, block.number),\\n                delegateInfo[_holder][delegateInfo[_holder].length - 1]\\n                    .fromBlock\\n            );\\n        } else {\\n            return (address(0), 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns info on a dispute for a given ID\\n     * @param _disputeId is the ID of a specific dispute\\n     * @return bytes32 of the data ID of the dispute\\n     * @return uint256 of the timestamp of the dispute\\n     * @return bytes memory of the value being disputed\\n     * @return address of the reporter being disputed\\n     */\\n    function getDisputeInfo(uint256 _disputeId)\\n        external\\n        view\\n        returns (\\n            bytes32,\\n            uint256,\\n            bytes memory,\\n            address\\n        )\\n    {\\n        Dispute storage _d = disputeInfo[_disputeId];\\n        return (_d.queryId, _d.timestamp, _d.value, _d.disputedReporter);\\n    }\\n\\n    /**\\n     * @dev Returns the number of open disputes for a specific query ID\\n     * @param _queryId is the ID of a specific data feed\\n     * @return uint256 of the number of open disputes for the query ID\\n     */\\n    function getOpenDisputesOnId(bytes32 _queryId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return openDisputesOnId[_queryId];\\n    }\\n\\n    /**\\n     * @dev Returns the total number of votes\\n     * @return uint256 of the total number of votes\\n     */\\n    function getVoteCount() external view returns (uint256) {\\n        return voteCount;\\n    }\\n\\n    /**\\n     * @dev Returns info on a vote for a given vote ID\\n     * @param _disputeId is the ID of a specific vote\\n     * @return bytes32 identifier hash of the vote\\n     * @return uint256[8] memory of the pertinent round info (vote rounds, start date, fee, etc.)\\n     * @return bool[2] memory of both whether or not the vote was executed and is dispute\\n     * @return VoteResult result of the vote\\n     * @return bytes memory of the argument data of a proposal vote\\n     * @return bytes4 of the function selector proposed to be called\\n     * @return address[2] memory of the Tellor system contract address and vote initiator\\n     */\\n    function getVoteInfo(uint256 _disputeId)\\n        external\\n        view\\n        returns (\\n            bytes32,\\n            uint256[8] memory,\\n            bool[2] memory,\\n            VoteResult,\\n            bytes memory,\\n            bytes4,\\n            address[2] memory\\n        )\\n    {\\n        Vote storage _v = voteInfo[_disputeId];\\n        return (\\n            _v.identifierHash,\\n            [\\n                _v.voteRound,\\n                _v.startDate,\\n                _v.blockNumber,\\n                _v.fee,\\n                _v.tallyDate,\\n                _v.doesSupport,\\n                _v.against,\\n                _v.invalidQuery\\n            ],\\n            [_v.executed, _v.isDispute],\\n            _v.result,\\n            _v.data,\\n            _v.voteFunction,\\n            [_v.voteAddress, _v.initiator]\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns an array of voting rounds for a given vote\\n     * @param _hash is the identifier hash for a vote\\n     * @return uint256[] memory dispute IDs of the vote rounds\\n     */\\n    function getVoteRounds(bytes32 _hash)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return voteRounds[_hash];\\n    }\\n\\n    /**\\n     * @dev Used for future governance contract upgrades. Hardcode old contract address in next upgrade\\n     * @param _contract is the contract address to check\\n     */\\n    function isApprovedGovernanceContract(address _contract)\\n        external\\n        returns (bool)\\n    {\\n        if (\\n            _contract ==\\n            IController(TELLOR_ADDRESS).addresses(_GOVERNANCE_CONTRACT)\\n        ) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether or not a function is approved for proposals\\n     * @param _func is the hash of the function to be checked\\n     * @return bool of whether or not the function is approved\\n     */\\n    function isFunctionApproved(bytes4 _func) external view returns (bool) {\\n        return functionApproved[_func];\\n    }\\n\\n    /**\\n     * @dev Used during the upgrade process to verify valid Tellor Contracts\\n     */\\n    function verify() external pure returns (uint256) {\\n        return 9999;\\n    }\\n\\n    // Internal\\n    /**\\n     * @dev Allows an address to vote by calculating their total vote weight and updating vote count\\n     * for the vote ID\\n     * @param _voter is the address casting their vote\\n     * @param _disputeId is the vote ID the address is casting their vote for\\n     * @param _supports is a boolean of whether the voter supports the dispute\\n     * @param _invalidQuery is a boolean of whether the voter believes the dispute is invalid\\n     */\\n    function _vote(\\n        address _voter,\\n        uint256 _disputeId,\\n        bool _supports,\\n        bool _invalidQuery\\n    ) internal {\\n        // Ensure that dispute has not been executed and that vote does not exist and is not tallied\\n        require(_disputeId <= voteCount, \\\"Vote does not exist\\\");\\n        Vote storage _thisVote = voteInfo[_disputeId];\\n        require(_thisVote.tallyDate == 0, \\\"Vote has already been tallied\\\");\\n        IController _controller = IController(TELLOR_ADDRESS);\\n        uint256 voteWeight = _controller.balanceOfAt(\\n            _voter,\\n            _thisVote.blockNumber\\n        );\\n        IOracle _oracle = IOracle(_controller.addresses(_ORACLE_CONTRACT));\\n        ITreasury _treasury = ITreasury(\\n            _controller.addresses(_TREASURY_CONTRACT)\\n        );\\n        // Add to vote weight of voter based on treasury funds, reports submitted, and total tips\\n        voteWeight += _treasury.getTreasuryFundsByUser(_voter);\\n        voteWeight += _oracle.getReportsSubmittedByAddress(_voter) * 1e18;\\n        voteWeight += _oracle.getTipsByUser(_voter);\\n        // Make sure voter can't already be disputed, has already voted, or if balance is 0\\n        (uint256 _status, ) = _controller.getStakerInfo(_voter);\\n        require(_status != 3, \\\"Cannot vote if being disputed\\\");\\n        require(!_thisVote.voted[_voter], \\\"Sender has already voted\\\");\\n        require(voteWeight > 0, \\\"User balance is 0\\\");\\n        // Update voting status and increment total queries for support, invalid, or against based on vote\\n        _thisVote.voted[_voter] = true;\\n        if (_thisVote.isDispute && _invalidQuery) {\\n            _thisVote.invalidQuery += voteWeight;\\n        } else if (_supports) {\\n            _thisVote.doesSupport += voteWeight;\\n        } else {\\n            _thisVote.against += voteWeight;\\n        }\\n        emit Voted(_disputeId, _supports, _voter, voteWeight, _invalidQuery);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorVars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./tellor3/TellorVariables.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title TellorVariables\\n @dev Helper contract to store hashes of variables.\\n * For each of the bytes32 constants, the values are equal to\\n * keccak256([VARIABLE NAME])\\n*/\\ncontract TellorVars is TellorVariables {\\n    // Storage\\n    address constant TELLOR_ADDRESS =\\n        0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0; // Address of main Tellor Contract\\n    // Hashes for each pertinent contract\\n    bytes32 constant _GOVERNANCE_CONTRACT =\\n        0xefa19baa864049f50491093580c5433e97e8d5e41f8db1a61108b4fa44cacd93;\\n    bytes32 constant _ORACLE_CONTRACT =\\n        0xfa522e460446113e8fd353d7fa015625a68bc0369712213a42e006346440891e;\\n    bytes32 constant _TREASURY_CONTRACT =\\n        0x1436a1a60dca0ebb2be98547e57992a0fa082eb479e7576303cbd384e934f1fa;\\n    bytes32 constant _SWITCH_TIME =\\n        0x6c0e91a96227393eb6e42b88e9a99f7c5ebd588098b549c949baf27ac9509d8f;\\n    bytes32 constant _MINIMUM_DISPUTE_FEE =\\n        0x7335d16d7e7f6cb9f532376441907fe76aa2ea267285c82892601f4755ed15f0;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IOracle{\\r\\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index) external view returns(uint256);\\r\\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(bytes memory);\\r\\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\r\\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(address);\\r\\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\\r\\n    function reportingLock() external view returns(uint256);\\r\\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\\r\\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\\r\\n    function getTipsByUser(address _user) external view returns(uint256);\\r\\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\\r\\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\\r\\n    function burnTips() external;\\r\\n    function verify() external pure returns(uint);\\r\\n    function changeReportingLock(uint256 _newReportingLock) external;\\r\\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\\r\\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\\r\\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\\r\\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\r\\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\\r\\n    function getTimeOfLastNewValue() external view returns(uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IController{\\r\\n    function addresses(bytes32) external returns(address);\\r\\n    function uints(bytes32) external returns(uint256);\\r\\n    function burn(uint256 _amount) external;\\r\\n    function changeDeity(address _newDeity) external;\\r\\n    function changeOwner(address _newOwner) external;\\r\\n    function changeTellorContract(address _tContract) external;\\r\\n    function changeControllerContract(address _newController) external;\\r\\n    function changeGovernanceContract(address _newGovernance) external;\\r\\n    function changeOracleContract(address _newOracle) external;\\r\\n    function changeTreasuryContract(address _newTreasury) external;\\r\\n    function changeUint(bytes32 _target, uint256 _amount) external;\\r\\n    function migrate() external;\\r\\n    function mint(address _reciever, uint256 _amount) external;\\r\\n    function init() external;\\r\\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256);\\r\\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool);\\r\\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\\r\\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256);\\r\\n    function getAddressVars(bytes32 _data) external view returns (address);\\r\\n    function getUintVar(bytes32 _data) external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function allowance(address _user, address _spender) external view  returns (uint256);\\r\\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool);\\r\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\r\\n    function approveAndTransferFrom(address _from, address _to, uint256 _amount) external returns(bool);\\r\\n    function balanceOf(address _user) external view returns (uint256);\\r\\n    function balanceOfAt(address _user, uint256 _blockNumber)external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _amount)external returns (bool success);\\r\\n    function transferFrom(address _from,address _to,uint256 _amount) external returns (bool success) ;\\r\\n    function depositStake() external;\\r\\n    function requestStakingWithdraw() external;\\r\\n    function withdrawStake() external;\\r\\n    function changeStakingStatus(address _reporter, uint _status) external;\\r\\n    function slashReporter(address _reporter, address _disputer) external;\\r\\n    function getStakerInfo(address _staker) external view returns (uint256, uint256);\\r\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256);\\r\\n    function getNewCurrentVariables()external view returns (bytes32 _c,uint256[5] memory _r,uint256 _d,uint256 _t);\\r\\n    //in order to call fallback function\\r\\n    function beginDispute(uint256 _requestId, uint256 _timestamp,uint256 _minerIndex) external;\\r\\n    function unlockDisputeFee(uint256 _disputeId) external;\\r\\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\\r\\n    function tallyVotes(uint256 _disputeId) external;\\r\\n    //test functions\\r\\n    function tipQuery(uint,uint,bytes memory) external;\\r\\n    function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface ITreasury{\\r\\n    function issueTreasury(uint256 _amount, uint256 _rate, uint256 _duration) external;\\r\\n    function payTreasury(address _investor,uint256 _id) external;\\r\\n    function buyTreasury(uint256 _id,uint256 _amount) external;\\r\\n    function getTreasuryDetails(uint256 _id) external view returns(uint256,uint256,uint256,uint256);\\r\\n    function getTreasuryAccount(uint256 _id, address _investor) external view returns(uint256);\\r\\n    function getTreasuryOwners(uint256 _id) external view returns(address[] memory);\\r\\n    function getTreasuryFundsByUser(address _user) external view returns(uint256);\\r\\n    function wasPaid(uint256 _id, address _investor) external view returns(bool);\\r\\n    function verify() external pure returns(uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tellor3/TellorVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.4;\\n\\n/**\\n @author Tellor Inc.\\n @title TellorVariables\\n @dev Helper contract to store hashes of variables\\n*/\\ncontract TellorVariables {\\n    bytes32 constant _BLOCK_NUMBER =\\n        0x4b4cefd5ced7569ef0d091282b4bca9c52a034c56471a6061afd1bf307a2de7c; //keccak256(\\\"_BLOCK_NUMBER\\\");\\n    bytes32 constant _CURRENT_CHALLENGE =\\n        0xd54702836c9d21d0727ffacc3e39f57c92b5ae0f50177e593bfb5ec66e3de280; //keccak256(\\\"_CURRENT_CHALLENGE\\\");\\n    bytes32 constant _CURRENT_REQUESTID =\\n        0xf5126bb0ac211fbeeac2c0e89d4c02ac8cadb2da1cfb27b53c6c1f4587b48020; //keccak256(\\\"_CURRENT_REQUESTID\\\");\\n    bytes32 constant _CURRENT_REWARD =\\n        0xd415862fd27fb74541e0f6f725b0c0d5b5fa1f22367d9b78ec6f61d97d05d5f8; //keccak256(\\\"_CURRENT_REWARD\\\");\\n    bytes32 constant _CURRENT_TOTAL_TIPS =\\n        0x09659d32f99e50ac728058418d38174fe83a137c455ff1847e6fb8e15f78f77a; //keccak256(\\\"_CURRENT_TOTAL_TIPS\\\");\\n    bytes32 constant _DEITY =\\n        0x5fc094d10c65bc33cc842217b2eccca0191ff24148319da094e540a559898961; //keccak256(\\\"_DEITY\\\");\\n    bytes32 constant _DIFFICULTY =\\n        0xf758978fc1647996a3d9992f611883adc442931dc49488312360acc90601759b; //keccak256(\\\"_DIFFICULTY\\\");\\n    bytes32 constant _DISPUTE_COUNT =\\n        0x310199159a20c50879ffb440b45802138b5b162ec9426720e9dd3ee8bbcdb9d7; //keccak256(\\\"_DISPUTE_COUNT\\\");\\n    bytes32 constant _DISPUTE_FEE =\\n        0x675d2171f68d6f5545d54fb9b1fb61a0e6897e6188ca1cd664e7c9530d91ecfc; //keccak256(\\\"_DISPUTE_FEE\\\");\\n    bytes32 constant _DISPUTE_ROUNDS =\\n        0x6ab2b18aafe78fd59c6a4092015bddd9fcacb8170f72b299074f74d76a91a923; //keccak256(\\\"_DISPUTE_ROUNDS\\\");\\n    bytes32 constant _EXTENSION =\\n        0x2b2a1c876f73e67ebc4f1b08d10d54d62d62216382e0f4fd16c29155818207a4; //keccak256(\\\"_EXTENSION\\\");\\n    bytes32 constant _FEE =\\n        0x1da95f11543c9b03927178e07951795dfc95c7501a9d1cf00e13414ca33bc409; //keccak256(\\\"_FEE\\\");\\n    bytes32 constant _FORK_EXECUTED =\\n        0xda571dfc0b95cdc4a3835f5982cfdf36f73258bee7cb8eb797b4af8b17329875; //keccak256(\\\"_FORK_EXECUTED\\\");\\n    bytes32 constant _LOCK =\\n        0xd051321aa26ce60d202f153d0c0e67687e975532ab88ce92d84f18e39895d907;\\n    bytes32 constant _MIGRATOR =\\n        0xc6b005d45c4c789dfe9e2895b51df4336782c5ff6bd59a5c5c9513955aa06307; //keccak256(\\\"_MIGRATOR\\\");\\n    bytes32 constant _MIN_EXECUTION_DATE =\\n        0x46f7d53798d31923f6952572c6a19ad2d1a8238d26649c2f3493a6d69e425d28; //keccak256(\\\"_MIN_EXECUTION_DATE\\\");\\n    bytes32 constant _MINER_SLOT =\\n        0x6de96ee4d33a0617f40a846309c8759048857f51b9d59a12d3c3786d4778883d; //keccak256(\\\"_MINER_SLOT\\\");\\n    bytes32 constant _NUM_OF_VOTES =\\n        0x1da378694063870452ce03b189f48e04c1aa026348e74e6c86e10738514ad2c4; //keccak256(\\\"_NUM_OF_VOTES\\\");\\n    bytes32 constant _OLD_TELLOR =\\n        0x56e0987db9eaec01ed9e0af003a0fd5c062371f9d23722eb4a3ebc74f16ea371; //keccak256(\\\"_OLD_TELLOR\\\");\\n    bytes32 constant _ORIGINAL_ID =\\n        0xed92b4c1e0a9e559a31171d487ecbec963526662038ecfa3a71160bd62fb8733; //keccak256(\\\"_ORIGINAL_ID\\\");\\n    bytes32 constant _OWNER =\\n        0x7a39905194de50bde334d18b76bbb36dddd11641d4d50b470cb837cf3bae5def; //keccak256(\\\"_OWNER\\\");\\n    bytes32 constant _PAID =\\n        0x29169706298d2b6df50a532e958b56426de1465348b93650fca42d456eaec5fc; //keccak256(\\\"_PAID\\\");\\n    bytes32 constant _PENDING_OWNER =\\n        0x7ec081f029b8ac7e2321f6ae8c6a6a517fda8fcbf63cabd63dfffaeaafa56cc0; //keccak256(\\\"_PENDING_OWNER\\\");\\n    bytes32 constant _REQUEST_COUNT =\\n        0x3f8b5616fa9e7f2ce4a868fde15c58b92e77bc1acd6769bf1567629a3dc4c865; //keccak256(\\\"_REQUEST_COUNT\\\");\\n    bytes32 constant _REQUEST_ID =\\n        0x9f47a2659c3d32b749ae717d975e7962959890862423c4318cf86e4ec220291f; //keccak256(\\\"_REQUEST_ID\\\");\\n    bytes32 constant _REQUEST_Q_POSITION =\\n        0xf68d680ab3160f1aa5d9c3a1383c49e3e60bf3c0c031245cbb036f5ce99afaa1; //keccak256(\\\"_REQUEST_Q_POSITION\\\");\\n    bytes32 constant _SLOT_PROGRESS =\\n        0xdfbec46864bc123768f0d134913175d9577a55bb71b9b2595fda21e21f36b082; //keccak256(\\\"_SLOT_PROGRESS\\\");\\n    bytes32 constant _STAKE_AMOUNT =\\n        0x5d9fadfc729fd027e395e5157ef1b53ef9fa4a8f053043c5f159307543e7cc97; //keccak256(\\\"_STAKE_AMOUNT\\\");\\n    bytes32 constant _STAKE_COUNT =\\n        0x10c168823622203e4057b65015ff4d95b4c650b308918e8c92dc32ab5a0a034b; //keccak256(\\\"_STAKE_COUNT\\\");\\n    bytes32 constant _T_BLOCK =\\n        0xf3b93531fa65b3a18680d9ea49df06d96fbd883c4889dc7db866f8b131602dfb; //keccak256(\\\"_T_BLOCK\\\");\\n    bytes32 constant _TALLY_DATE =\\n        0xf9e1ae10923bfc79f52e309baf8c7699edb821f91ef5b5bd07be29545917b3a6; //keccak256(\\\"_TALLY_DATE\\\");\\n    bytes32 constant _TARGET_MINERS =\\n        0x0b8561044b4253c8df1d9ad9f9ce2e0f78e4bd42b2ed8dd2e909e85f750f3bc1; //keccak256(\\\"_TARGET_MINERS\\\");\\n    bytes32 constant _TELLOR_CONTRACT =\\n        0x0f1293c916694ac6af4daa2f866f0448d0c2ce8847074a7896d397c961914a08; //keccak256(\\\"_TELLOR_CONTRACT\\\");\\n    bytes32 constant _TELLOR_GETTERS =\\n        0xabd9bea65759494fe86471c8386762f989e1f2e778949e94efa4a9d1c4b3545a; //keccak256(\\\"_TELLOR_GETTERS\\\");\\n    bytes32 constant _TIME_OF_LAST_NEW_VALUE =\\n        0x2c8b528fbaf48aaf13162a5a0519a7ad5a612da8ff8783465c17e076660a59f1; //keccak256(\\\"_TIME_OF_LAST_NEW_VALUE\\\");\\n    bytes32 constant _TIME_TARGET =\\n        0xd4f87b8d0f3d3b7e665df74631f6100b2695daa0e30e40eeac02172e15a999e1; //keccak256(\\\"_TIME_TARGET\\\");\\n    bytes32 constant _TIMESTAMP =\\n        0x2f9328a9c75282bec25bb04befad06926366736e0030c985108445fa728335e5; //keccak256(\\\"_TIMESTAMP\\\");\\n    bytes32 constant _TOTAL_SUPPLY =\\n        0xe6148e7230ca038d456350e69a91b66968b222bfac9ebfbea6ff0a1fb7380160; //keccak256(\\\"_TOTAL_SUPPLY\\\");\\n    bytes32 constant _TOTAL_TIP =\\n        0x1590276b7f31dd8e2a06f9a92867333eeb3eddbc91e73b9833e3e55d8e34f77d; //keccak256(\\\"_TOTAL_TIP\\\");\\n    bytes32 constant _VALUE =\\n        0x9147231ab14efb72c38117f68521ddef8de64f092c18c69dbfb602ffc4de7f47; //keccak256(\\\"_VALUE\\\");\\n    bytes32 constant _EIP_SLOT =\\n        0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_delegator\",\"type\":\"address\"}],\"name\":\"DelegateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"NewDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"_function\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"NewVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Governance.VoteResult\",\"name\":\"_result\",\"type\":\"uint8\"}],\"name\":\"VoteExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Governance.VoteResult\",\"name\":\"_result\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"VoteTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_supports\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_voteWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_invalidQuery\",\"type\":\"bool\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"beginDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"delegateOfAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"didVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"executeVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getDelegateInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getDisputeInfo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getOpenDisputesOnId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVoteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getVoteInfo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[8]\",\"name\":\"\",\"type\":\"uint256[8]\"},{\"internalType\":\"bool[2]\",\"name\":\"\",\"type\":\"bool[2]\"},{\"internalType\":\"enum Governance.VoteResult\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"},{\"internalType\":\"address[2]\",\"name\":\"\",\"type\":\"address[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getVoteRounds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"isApprovedGovernanceContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_func\",\"type\":\"bytes4\"}],\"name\":\"isFunctionApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_function\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"proposeVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_func\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"_val\",\"type\":\"bool\"}],\"name\":\"setApprovedFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"tallyVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMinDisputeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_supports\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_invalidQuery\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addys\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_supports\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_invalidQuery\",\"type\":\"bool\"}],\"name\":\"voteFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Governance","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}