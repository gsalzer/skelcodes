{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/facets/EscrowDeployerFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/AppStorage.sol\\\";\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../Escrow.sol\\\";\\nimport \\\"../vendor/openzeppelin/SafeMath.sol\\\";\\nimport \\\"../vendor/openzeppelin/ECDSA.sol\\\";\\n\\ncontract EscrowDeployerFacet {\\n    using ECDSA for bytes32;\\n    using SafeMath for uint256;\\n\\n    AppStorage s;\\n\\n    bytes32 constant NAMESPACE = keccak256(\\\"com.escaroo.eth.escrow.deployer\\\");\\n\\n    struct EscrowConfig {\\n        bytes id;\\n        address payable mediator;\\n        address payable affiliate;\\n        address payable buyer;\\n        address payable seller;\\n        uint256 amount;\\n        uint256 fee;\\n        uint256 commission;\\n    }\\n\\n    modifier onlyWithValidEscrowSig(\\n        EscrowConfig memory _cfg,\\n        uint32 _expiry,\\n        bytes memory _signature\\n    ) {\\n        bytes32 deployHash = getEscrowDeployHash(_cfg, _expiry);\\n        require(deployHash.toEthSignedMessageHash().recover(_signature) == LibDiamond.contractOwner(), \\\"Invalid deployment signature.\\\");\\n        _;\\n    }\\n\\n    event EscrowDeployed(bytes32 indexed id, address escrowAddr);\\n\\n    function getEscrowDeployHash(\\n        EscrowConfig memory _cfg,\\n        uint32 _expiry\\n    )\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                _cfg.id,\\n                _cfg.mediator,\\n                _cfg.buyer,\\n                _cfg.seller,\\n                _cfg.amount,\\n                _cfg.fee,\\n                _expiry\\n            )\\n        );\\n    }\\n\\n    function createNewEscrow(\\n        EscrowConfig memory _cfg\\n    )\\n        internal\\n        returns (Escrow)\\n    {\\n        bytes32 escrowID = keccak256(abi.encodePacked(_cfg.id, _cfg.buyer, _cfg.seller, _cfg.amount, _cfg.fee));\\n        require(s.escrows[escrowID] == address(0), \\\"Escrow already exists!\\\");\\n        Escrow escrow = new Escrow(escrowID, address(uint160(LibDiamond.contractOwner())), _cfg.buyer, _cfg.seller, _cfg.mediator, _cfg.affiliate, _cfg.amount, _cfg.fee, _cfg.commission);\\n        s.escrows[escrowID] = address(escrow);\\n        emit EscrowDeployed(escrowID, address(escrow));\\n        return escrow;\\n    }\\n\\n    function deployEscrow(\\n        EscrowConfig memory _cfg,\\n        uint32 _expiry,\\n        bytes memory _signature\\n    )\\n        public\\n        onlyWithValidEscrowSig(_cfg, _expiry, _signature)\\n        returns (Escrow)\\n    {\\n        /* solium-disable-next-line */\\n        require(block.timestamp < _expiry, \\\"Deployment signature expired.\\\");\\n        Escrow escrow = createNewEscrow(_cfg);\\n        return escrow;\\n    }\\n\\n    function deployAndFundEscrow(\\n        EscrowConfig memory _cfg,\\n        uint32 _expiry,\\n        bytes memory _signature\\n    )\\n        public\\n        payable\\n        onlyWithValidEscrowSig(_cfg, _expiry, _signature)\\n        returns (Escrow)\\n    {\\n        /* solium-disable-next-line */\\n        require(block.timestamp < _expiry, \\\"Deployment signature expired.\\\");\\n        require(msg.value == _cfg.amount, \\\"Wrong ether amount.\\\");\\n        Escrow escrow = createNewEscrow(_cfg);\\n        escrow.deposit{value: msg.value}();\\n        return escrow;\\n    }\\n}\"\r\n    },\r\n    \"src/libraries/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nstruct AppStorage {\\n    mapping (bytes32 => address) escrows;\\n}\"\r\n    },\r\n    \"src/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndSelectorPosition {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\n        bytes4[] selectors;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        uint16 selectorCount = uint16(ds.selectors.length);\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\n            ds.selectors.push(selector);\\n            selectorCount++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            // can't replace immutable functions -- functions defined directly in the diamond\\n            require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n            // replace old facet address\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\\n            require(oldFacetAddressAndSelectorPosition.facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n            // can't remove immutable functions -- functions defined directly in the diamond\\n            require(oldFacetAddressAndSelectorPosition.facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function.\\\");\\n            // replace selector with last selector\\n            selectorCount--;\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\n            }\\n            // delete last selector\\n            ds.selectors.pop();\\n            delete ds.facetAddressAndSelectorPosition[selector];\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\"\r\n    },\r\n    \"src/Escrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"./vendor/openzeppelin/SafeMath.sol\\\";\\nimport \\\"./vendor/openzeppelin/ECDSA.sol\\\";\\n\\n/**\\n * @dev Escrow contract for ETH based escrows\\n */\\ncontract Escrow {\\n\\n    using SafeMath for uint256;\\n    using ECDSA for bytes32;\\n\\n    event FundsDeposited(address indexed buyer, uint256 amount);\\n    event FundsRefunded();\\n    event FundsReleased(address indexed seller, uint256 amount);\\n    event DisputeResolved();\\n    event OwnershipTransferred(address indexed oldOwner, address newOwner);\\n    event MediatorChanged(address indexed oldMediator, address newMediator);\\n\\n    enum Status { AWAITING_PAYMENT, PAID, REFUNDED, MEDIATED, COMPLETE }\\n\\n    Status public status;\\n    bytes32 public escrowID;\\n    uint256 public amount;\\n    uint256 public fee;\\n    uint256 public commission;\\n    address payable public owner;\\n    address payable public mediator;\\n    address payable public affiliate;\\n    address payable public buyer;\\n    address payable public seller;\\n    bool public funded = false;\\n    bool public completed = false;\\n    bytes32 public releaseMsgHash;\\n    bytes32 public resolveMsgHash;\\n\\n    modifier onlyExactAmount(uint256 _amount) {\\n        require(_amount == depositAmount(), \\\"Amount needs to be exact.\\\");\\n        _;\\n    }\\n\\n    modifier onlyBuyer() {\\n        require(msg.sender == buyer, \\\"Only the buyer can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier onlyWithBuyerSignature(bytes32 hash, bytes memory signature) {\\n        require(\\n            hash.toEthSignedMessageHash()\\n                .recover(signature) == buyer,\\n            \\\"Must be signed by buyer.\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWithParticipantSignature(bytes32 hash, bytes memory signature) {\\n        address signer = hash.toEthSignedMessageHash()\\n            .recover(signature);\\n        require(\\n            signer == buyer || signer == seller,\\n            \\\"Must be signed by either buyer or seller.\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlySeller() {\\n        require(msg.sender == seller, \\\"Only the seller can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only the owner can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier onlyMediator() {\\n        require(msg.sender == mediator, \\\"Only the mediator can call this function.\\\");\\n        _;\\n    }\\n\\n    modifier onlyUnfunded() {\\n        require(funded == false, \\\"Escrow already funded.\\\");\\n        funded = true;\\n        _;\\n    }\\n\\n    modifier onlyFunded() {\\n        require(funded == true, \\\"Escrow not funded.\\\");\\n        _;\\n    }\\n\\n    modifier onlyIncompleted() {\\n        require(completed == false, \\\"Escrow already completed.\\\");\\n        completed = true;\\n        _;\\n    }\\n\\n    constructor(\\n        bytes32 _escrowID,\\n        address payable _owner,\\n        address payable _buyer,\\n        address payable  _seller,\\n        address payable _mediator,\\n        address payable _affiliate,\\n        uint256 _amount,\\n        uint256 _fee,\\n        uint256 _commission\\n    )\\n    {\\n        status = Status.AWAITING_PAYMENT;\\n        escrowID = _escrowID;\\n        owner = _owner;\\n        buyer = _buyer;\\n        seller = _seller;\\n        mediator = _mediator;\\n        affiliate = _affiliate;\\n        amount = _amount;\\n        fee = _fee;\\n        commission = _commission;\\n        releaseMsgHash = keccak256(\\n            abi.encodePacked(\\\"releaseFunds()\\\", escrowID, address(this))\\n        );\\n        resolveMsgHash = keccak256(\\n            abi.encodePacked(\\\"resolveDispute()\\\", escrowID, address(this))\\n        );\\n        emit OwnershipTransferred(address(0), _owner);\\n        emit MediatorChanged(address(0), _owner);\\n    }\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n\\n    function depositAmount() public view returns (uint256) {\\n        return amount;\\n    }\\n\\n    function deposit()\\n        public\\n        payable\\n        onlyUnfunded\\n        onlyExactAmount(msg.value)\\n    {\\n        status = Status.PAID;\\n        emit FundsDeposited(msg.sender, msg.value);\\n    }\\n\\n    function refund()\\n        public\\n        onlySeller\\n        onlyFunded\\n        onlyIncompleted\\n    {\\n        buyer.transfer(depositAmount());\\n        status = Status.REFUNDED;\\n        emit FundsRefunded();\\n    }\\n\\n    function _releaseFees() private {\\n        (bool success, ) = mediator.call{value: fee}(\\\"\\\");\\n        require(success, \\\"Transfer to mediator failed\\\");\\n        if (affiliate != address(0) && commission > 0) {\\n            (success, ) = affiliate.call{value: commission}(\\\"\\\");\\n            require(success, \\\"Transfer to affiliate failed\\\");\\n        }\\n    }\\n\\n    function releaseFunds(\\n        bytes calldata _signature\\n    )\\n        external\\n        onlyFunded\\n        onlyIncompleted\\n        onlyWithBuyerSignature(releaseMsgHash, _signature)\\n    {\\n        uint256 releaseAmount = depositAmount().sub(fee);\\n        if (affiliate != address(0) && commission > 0) {\\n            releaseAmount = releaseAmount.sub(commission);\\n        }\\n        (bool success, ) = seller.call{value: releaseAmount}(\\\"\\\");\\n        require(success, \\\"Transfer to seller failed\\\");\\n        _releaseFees();\\n        status = Status.COMPLETE;\\n        emit FundsReleased(seller, releaseAmount);\\n    }\\n\\n    function resolveDispute(\\n        bytes calldata _signature,\\n        uint8 _buyerPercent\\n    )\\n        external\\n        onlyFunded\\n        onlyMediator\\n        onlyIncompleted\\n        onlyWithParticipantSignature(resolveMsgHash, _signature)\\n    {\\n        require(_buyerPercent <= 100, \\\"_buyerPercent must be 100 or lower\\\");\\n        uint256 releaseAmount = depositAmount().sub(fee);\\n        if (affiliate != address(0) && commission > 0) {\\n            releaseAmount = releaseAmount.sub(commission);\\n        }\\n\\n        status = Status.MEDIATED;\\n        emit DisputeResolved();\\n\\n        if (_buyerPercent > 0)\\n          buyer.transfer(releaseAmount.mul(uint256(_buyerPercent)).div(100));\\n        if (_buyerPercent < 100)\\n          seller.transfer(releaseAmount.mul(uint256(100).sub(_buyerPercent)).div(100));\\n\\n        _releaseFees();\\n    }\\n\\n    function setOwner(address payable _newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n\\n    function setMediator(address payable _newMediator) external onlyOwner {\\n        emit MediatorChanged(mediator, _newMediator);\\n        mediator = _newMediator;\\n    }\\n}\"\r\n    },\r\n    \"src/vendor/openzeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"src/vendor/openzeppelin/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\"\r\n    },\r\n    \"src/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"escrowAddr\",\"type\":\"address\"}],\"name\":\"EscrowDeployed\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"id\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"mediator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"internalType\":\"struct EscrowDeployerFacet.EscrowConfig\",\"name\":\"_cfg\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"_expiry\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"deployAndFundEscrow\",\"outputs\":[{\"internalType\":\"contract Escrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"id\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"mediator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"internalType\":\"struct EscrowDeployerFacet.EscrowConfig\",\"name\":\"_cfg\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"_expiry\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"deployEscrow\",\"outputs\":[{\"internalType\":\"contract Escrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"id\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"mediator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"internalType\":\"struct EscrowDeployerFacet.EscrowConfig\",\"name\":\"_cfg\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"_expiry\",\"type\":\"uint32\"}],\"name\":\"getEscrowDeployHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"EscrowDeployerFacet","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}