{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//                                                                                                            //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@\"7HMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMF   .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\   -MMMMMMMMMMMMMMMMMMMMF   JMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#    MMMMMMMMMMMMMMMMMMMMM\\   .MMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]   .MMMMMMMMMMMMMMMMMMMMM`    dMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    dMMMH\"\"7!      ?MMMMM#     -MMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMF    ^              .MMMMM#      MMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#\"`         .....g+, .MMMMMMF      dMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM#\"`       ..JMMMMMMMMMMMMMMMMMMM\\      ,MMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMH\"!          (MMMMMMMMMMMMMMMMD`_TMM!       MMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMB^      ..g#   .MMMMMMMMMMMMMMMM#    UM    ;   JMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMM9'      ..MMMM%   .MMMMMMMMMMMMMMMMF     E   .b   .MMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMM\"!      .dMMMMMM#    MMMMMMMMMMMMMMMMM]         .M.   HMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMM@!     ... dMMMMMMM]   .MMMMMMMMMMMMMMMMM:         -M]   -MMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMM#=        .MN.MMMMMMMM    dMMMMMY\"HMMMMMMMMM          dM#    MMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMM@!    ..M,    WMMMMMMMMF   .MMY\"`    dMMMMMMM#   .b     MMM,   dMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMD`    .dMMMMp    TMMMMMMM!   (`              ?MF   .Mc    MMMb   ,MMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMD`    .NMMMMMMMR    ?MMMMMF        ..:           !   (MN.  .MMMN    MMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMF    .dMMMMMMMMMMN.   ,MMMM>     .gMMF   .MMMMh       dMM[  MMMMM|   JMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMM,  .MMMMMMMMMMMMMN,   .MM#        TM]   -MMMMM!      MMMM..MMMMMb   .MMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMN  dMMMMMMMMMMMMMMM,    W%   .,     7    TMM#=      .MMMM..MMMMMM    HMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMM..MMMMMMMMMMMMMMMMMp        MMMa               `   .MMMMMMMMMMMN    -MMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMM`.MMMMMMMMMMMMMMMMMMb      .MMMMNa,     .    .d\\   (MMMMMMMMMMMMN    MMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMM  MMMMMMMMMMMMMMMMMMMN.    dMMMMMMMN,  .MMMaJMMh. .MMMMMMMMMMMMMN    dMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN    JMMMMMMMMM- MMMMMMMMMb.MMMMMMMMMMMMMMMb  .MMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN. JMMMMMMMMMM].MMMMMMMMMMMMMMMMMMMMMMMMMMM| MMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM].MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMF MMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM% MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMgMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM: MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmJMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    //\r\n//                                                                                                            //\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8\r\n    );\r\n\r\n  function description()\r\n    external\r\n    view\r\n    returns (\r\n      string memory\r\n    );\r\n\r\n  function version()\r\n    external\r\n    view\r\n    returns (\r\n      uint256\r\n    );\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/MerkleProof.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/ERC1155.sol\r\n\r\n/* The MIT License (MIT)\r\n * \r\n * Copyright (c) 2016-2020 zOS Global Limited\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/* SUMMARY OF CHANGES\r\n * Line 36-41  Change imports to use @openzeppelin/contracts imports rather than\r\n *             relative imports.\r\n * Line 54     Remove private modifier from `_balances`.\r\n */\r\n\r\n\r\n// OpenZeppelin Contracts v4.3.2 (token/ERC1155/ERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens of token type `id` from `from`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have at least `amount` tokens of token type `id`.\r\n     */\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     */\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/DualERC1155ERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @notice ERC1155 that supports the ERC721 interface for certain tokens\r\ncontract DualERC1155ERC721 is ERC1155 {\r\n\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    /// @dev See {IERC721-Transfer}.\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /// @dev See {IERC721-Approval}.\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    struct ERC721Data {\r\n        bool exists;\r\n        address owner;\r\n        address approved;\r\n    }\r\n\r\n    // Mapping from account to number of erc721 compatible tokens owned\r\n    mapping(address => uint256) private _erc721Balances;\r\n\r\n    // Mapping from token ID to erc721 data\r\n    mapping(uint256 => ERC721Data) private _erc721Data;\r\n\r\n    constructor() ERC1155(\"\") {}\r\n\r\n    /// @dev See {IERC165-supportsInterface}.\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @dev Base URI form {tokenURI}.\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /// @dev See {IERC721Metadata-tokenURI}.\r\n    /// Concatenates the tokenId to the results of {_baseURI}.\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view virtual returns (string memory) {\r\n        require(\r\n            _erc721Data[tokenId].exists,\r\n            \"ERC721Metadata: URI query for nonexistent token\"\r\n        );\r\n\r\n        return bytes(_baseURI()).length > 0 ?\r\n            string(abi.encodePacked(_baseURI(), tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /// @dev See {IERC721Metadata-name}.\r\n    function name() public view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /// @dev See {IERC721Metadata-symbol}.\r\n    function symbol() public view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /// @dev Returns a single element as a single element array\r\n    function _asSingleArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n\r\n    /// @dev See {IERC721-balanceOf}.\r\n    function balanceOf(address owner) public view virtual returns (uint256 balance) {\r\n        return _erc721Balances[owner];\r\n    }\r\n\r\n    /// @dev See {IERC721-ownerOf}.\r\n    function ownerOf(\r\n        uint256 tokenId\r\n    ) public view virtual returns (address owner) {\r\n        return _erc721Data[tokenId].exists ?\r\n            _erc721Data[tokenId].owner :\r\n            address(0);\r\n    }\r\n\r\n    /// @dev See {IERC721-transferFrom}.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual {\r\n        require(\r\n            _erc721Data[tokenId].exists && (\r\n                DualERC1155ERC721.ownerOf(tokenId) == msg.sender || \r\n                _erc721Data[tokenId].approved == msg.sender\r\n            ),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n        _transferERC721(from, to, tokenId);\r\n    }\r\n\r\n    /// @dev See {IERC721-approve}.\r\n    function approve(address to, uint256 tokenId) public virtual {\r\n        address owner = DualERC1155ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n        _approveERC721(to, tokenId);\r\n    }\r\n\r\n    /// @dev See {IERC721-getApproved}.\r\n    function getApproved(\r\n        uint256 tokenId\r\n    ) public view virtual returns (address operator) {\r\n        return _erc721Data[tokenId].approved;\r\n    }\r\n\r\n    /// @dev See {IERC721-safeTransferFrom}.\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            _erc721Data[tokenId].exists && (\r\n                DualERC1155ERC721.ownerOf(tokenId) == msg.sender || \r\n                _erc721Data[tokenId].approved == msg.sender\r\n            ),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n        _transferERC721(from, to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(from, to, tokenId, data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /// @dev See {IERC721-safeTransferFrom}.\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual {\r\n        safeTransferFrom(from, to, tokenId, bytes(\"\"));\r\n    }\r\n\r\n    /// @dev Transfer a token as an ERC721\r\n    function _transferERC721(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(\r\n            _msgSender(),\r\n            from,\r\n            to,\r\n            _asSingleArray(tokenId),\r\n            _asSingleArray(1),\r\n            \"\"\r\n        );\r\n\r\n        _approveERC721(address(0), tokenId);\r\n        _balances[tokenId][from] -= 1;\r\n        _balances[tokenId][to] += 1;\r\n\r\n        // Emit ERC1155 transfer event rather than ERC721\r\n        emit TransferSingle(_msgSender(), from, to, tokenId, 1);\r\n    }\r\n\r\n    /// @dev See {approve}.\r\n    function _approveERC721(address to, uint256 tokenId) internal virtual {\r\n        _erc721Data[tokenId].approved = to;\r\n        emit Approval(DualERC1155ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /// @dev Hooks into transfers of ERC721 marked-tokens\r\n    function _beforeTokenTransfer(\r\n        address,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory\r\n    ) internal override {\r\n        for (uint256 i = 0; i < ids.length; i ++) {\r\n            if (_erc721Data[ids[i]].exists) {\r\n                require(\r\n                    DualERC1155ERC721.ownerOf(ids[i]) == from,\r\n                    \"ERC721: transfer of token that is not own\"\r\n                );\r\n                require(\r\n                    amounts[i] == 1,\r\n                    \"ERC721: multi-transfer of token that is not multi-token\"\r\n                );\r\n                _erc721Data[ids[i]].owner = to;\r\n                emit Transfer(from, to, ids[i]);\r\n                if (from != address(0)) {\r\n                    _erc721Balances[from] -= 1;\r\n                }\r\n                if (to != address(0)) {\r\n                    _erc721Balances[to] += 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Check to see if receiver contract supports IERC721Receiver.\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @dev Mark a token id as ERC721. MUST be called before a token is minted.\r\n    /// Only 1 of this token is allowed to exist at any given time. This token\r\n    /// will be visible from the ERC721 interface of this contract.\r\n    function _registerERC721(uint256 tokenId) internal {\r\n        _erc721Data[tokenId].exists = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/IDUtils.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/// @notice A helper type to enforce stronger type-checking for token IDs\r\ntype ID is uint256;\r\n\r\n/// @title IDUtils\r\n/// @notice Provides utility functions for working with the ID type\r\nlibrary IDUtils {\r\n\r\n    /// @notice Get the ID after a given ID\r\n    /// @param id The ID\r\n    /// @return The next ID\r\n    function next(ID id) internal pure returns (ID) {\r\n        return ID.wrap(ID.unwrap(id) + 1);\r\n    }\r\n\r\n    /// @notice Whether and ID comes after another ID\r\n    /// @param a The first ID\r\n    /// @param b The second ID\r\n    /// @return If the first comes after the second or not\r\n    function gt(ID a, ID b) internal pure returns (bool) {\r\n        return ID.unwrap(a) > ID.unwrap(b);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/MerkleDropUniqueToken.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Merkle Drop Unique Token\r\n/// @notice Supports two classes of tokens: drop tokens and unique tokens. Drop\r\n/// tokens can be distributed using merkle drops and unique tokens are 1 of 1s\r\n/// that can be purchased if enough drop tokens are held.\r\ncontract MerkleDropUniqueToken is DualERC1155ERC721, Ownable, ReentrancyGuard {\r\n\r\n    /// @dev Counter used to create new tokens\r\n    ID public nextId = ID.wrap(0);\r\n\r\n    constructor() DualERC1155ERC721() {}\r\n\r\n    struct DropToken {\r\n        bool exists;\r\n        uint256 supply;\r\n    }\r\n\r\n    /// @notice Describes which IDs correspond to drop tokens and their supply\r\n    mapping(ID => DropToken) public dropTokens;\r\n\r\n    /// @notice List of drop token IDs\r\n    ID[] public dropTokenList;\r\n\r\n    /// @notice Emitted when a new types of drop token are created\r\n    /// @param firstId ID of the first drop token\r\n    /// @param amounts Amounts of the drop tokens\r\n    event DropTokensCreated(ID firstId, uint256[] amounts);\r\n\r\n    function _createDropTokens(uint256[] memory _amounts) internal {\r\n        emit DropTokensCreated(nextId, _amounts);\r\n        for (uint i = 0; i < _amounts.length; i ++) {\r\n            dropTokens[nextId] = DropToken(true, _amounts[i]);\r\n            dropTokenList.push(nextId);\r\n            nextId = IDUtils.next(nextId);\r\n        }\r\n    }\r\n\r\n    /// @notice Create new types of drop token\r\n    /// @param _amounts Amounts of the drop tokens\r\n    function createDropTokens(uint256[] calldata _amounts) external onlyOwner {\r\n        _createDropTokens(_amounts);\r\n    }\r\n\r\n    struct MerkleDrop {\r\n        bool exists;\r\n        bytes32 merkleRoot;\r\n        mapping(ID => uint256) amounts;\r\n        mapping(address => bool) claimed;\r\n    }\r\n\r\n    /// @notice The ID of the next merkle drop\r\n    uint256 public nextMerkleDropId = 0;\r\n\r\n    /// @notice Describes existing merkle drops\r\n    mapping(uint256 => MerkleDrop) public merkleDrops;\r\n\r\n    /// @notice Emitted when a new merkle drop is created\r\n    /// @param merkleDropId The ID of the merkle drop\r\n    /// @param merkleRoot The root of the merkle tree\r\n    /// @param ids The IDs of the drop tokens in this drop\r\n    /// @param amounts The amounts of the drops tokens correspond to `ids`\r\n    event MerkleDropCreated(\r\n        uint256 merkleDropId,\r\n        bytes32 merkleRoot,\r\n        ID[] ids,\r\n        uint256[] amounts\r\n    );\r\n\r\n    /// @notice Create a new merkle drop to drop multiple drop tokens at once\r\n    /// @param _merkleRoot The hex root of the merkle tree. The leaves of the\r\n    /// tree must be the address of the recepient as well as the ids and\r\n    /// amounts of each of the drop tokens they will be eligible to claim. They\r\n    /// should be keccak256 abi packed in address, uint256[], uint256[] format.\r\n    /// The merkle tree should be constructed using keccak256 with sorted\r\n    /// pairs.\r\n    /// @param _ids The IDs of the drop tokens in this drop\r\n    /// @param _amounts The amounts of the drops tokens correspond to `ids`\r\n    /// @return The ID of the new merkle drop\r\n    function createMerkleDrop(\r\n        bytes32 _merkleRoot,\r\n        ID[] calldata _ids,\r\n        uint256[] calldata _amounts\r\n    ) external onlyOwner returns (uint256) {\r\n        require(\r\n            _amounts.length == _ids.length,\r\n            \"Mismatch between IDs and amounts\"\r\n        );\r\n        ID lastId = ID.wrap(0);\r\n        for (uint256 i = 0; i < _ids.length; i ++) {\r\n            require(\r\n                i == 0 || IDUtils.gt(_ids[i], lastId),\r\n                \"Non-ascending IDs\"\r\n            );\r\n            lastId = _ids[i];\r\n            require(dropTokens[_ids[i]].exists, \"Drop token does not exist\");\r\n            require(\r\n                _amounts[i] <= dropTokens[_ids[i]].supply,\r\n                \"Not enough drop token supply\"\r\n            );\r\n        }\r\n        for (uint256 i = 0; i < _ids.length; i ++) {\r\n            dropTokens[_ids[i]].supply -= _amounts[i];\r\n            merkleDrops[nextMerkleDropId].amounts[_ids[i]] = _amounts[i];\r\n        }\r\n        merkleDrops[nextMerkleDropId].merkleRoot = _merkleRoot;\r\n        merkleDrops[nextMerkleDropId].exists = true;\r\n\r\n        emit MerkleDropCreated(nextMerkleDropId, _merkleRoot, _ids, _amounts);\r\n\r\n        return nextMerkleDropId ++;\r\n    }\r\n\r\n    /// @notice Check whether part of a merkle drop is claimed by an account\r\n    /// @param _merkleDropId The ID of the merkle drop\r\n    /// @param _account The account to check\r\n    function isMerkleDropClaimed(\r\n        uint256 _merkleDropId,\r\n        address _account\r\n    ) public view returns (bool) {\r\n        require(merkleDrops[_merkleDropId].exists, \"Drop does not exist\");\r\n        return merkleDrops[_merkleDropId].claimed[_account];\r\n    }\r\n\r\n    /// @notice Emitted when part of a merkle drop is claimed\r\n    /// @param merkleDropId The ID of the merkle drop\r\n    /// @param account The recepient\r\n    /// @param ids The IDs of the drop tokens received\r\n    /// @param amounts The amounts of the drops tokens correspond to `ids`\r\n    event MerkleDropClaimed(\r\n        uint256 merkleDropId,\r\n        address account,\r\n        ID[] ids,\r\n        uint256[] amounts\r\n    );\r\n\r\n    /// @notice Claim part of a merkle drop\r\n    /// @param _merkleDropId The ID of the merkle drop\r\n    /// @param _proof The hex proof of the leaf in the tree. The leaves of the\r\n    /// tree must be the address of the recepient as well as the ids and\r\n    /// amounts of each of the drop tokens they will be eligible to claim. They\r\n    /// should be keccak256 abi packed in address, uint256[], uint256[] format.\r\n    /// The merkle tree should be constructed using keccak256 with sorted\r\n    /// pairs.\r\n    /// @param _ids The IDs of the drop tokens to be received\r\n    /// @param _amounts The amounts of the drops tokens correspond to `ids`\r\n    function claimMerkleDrop(\r\n        uint256 _merkleDropId,\r\n        bytes32[] calldata _proof,\r\n        ID[] calldata _ids,\r\n        uint256[] calldata _amounts\r\n    ) external nonReentrant {\r\n        _claimMerkleDrop(_merkleDropId, _proof, _ids, _amounts, msg.sender);\r\n    }\r\n\r\n    function _claimMerkleDrop(\r\n        uint256 _merkleDropId,\r\n        bytes32[] calldata _proof,\r\n        ID[] calldata _ids,\r\n        uint256[] calldata _amounts,\r\n        address _account\r\n    ) internal {\r\n        require(merkleDrops[_merkleDropId].exists, \"Drop does not exist\");\r\n        require(\r\n            _amounts.length == _ids.length,\r\n            \"Mismatch between IDs and amounts\"\r\n        );\r\n        require(\r\n            !merkleDrops[_merkleDropId].claimed[_account],\r\n            \"Drop already claimed\"\r\n        );\r\n        ID lastId = ID.wrap(0);\r\n        for (uint256 i = 0; i < _ids.length; i ++) {\r\n            require(\r\n                i == 0 || IDUtils.gt(_ids[i], lastId),\r\n                \"Non-ascending IDs\"\r\n            );\r\n            lastId = _ids[i];\r\n            require(dropTokens[_ids[i]].exists, \"Drop token does not exist\");\r\n            require(\r\n                _amounts[i] <= merkleDrops[_merkleDropId].amounts[_ids[i]],\r\n                \"Not enough drop tokens in drop\"\r\n            );\r\n        }\r\n        bytes32 leaf = keccak256(abi.encodePacked(_account, _ids, _amounts));\r\n        require(\r\n            MerkleProof.verify(_proof, merkleDrops[_merkleDropId].merkleRoot, leaf),\r\n            \"Invalid proof\"\r\n        );\r\n        for (uint256 i = 0; i < _ids.length; i ++) {\r\n            merkleDrops[_merkleDropId].amounts[_ids[i]] -= _amounts[i];\r\n            _mint(_account, ID.unwrap(_ids[i]), _amounts[i], \"\");\r\n        }\r\n        merkleDrops[_merkleDropId].claimed[_account] = true;\r\n\r\n        emit MerkleDropClaimed(_merkleDropId, _account, _ids, _amounts);\r\n    }\r\n\r\n    /// @notice Emitted when a merkle drop is cancelled\r\n    /// @param merkleDropId The ID of the merkle drop\r\n    event MerkleDropCancelled(uint256 merkleDropId);\r\n\r\n    /// @notice Cancel an existing merkle drop\r\n    /// @param _merkleDropId The ID of the merkle drop\r\n    function cancelMerkleDrop(uint256 _merkleDropId) external onlyOwner {\r\n        require(merkleDrops[_merkleDropId].exists, \"Drop does not exist\");\r\n        merkleDrops[_merkleDropId].exists = false;\r\n        emit MerkleDropCancelled(_merkleDropId);\r\n    }\r\n\r\n    /// @notice Emitted when drop tokens are manually distributed\r\n    /// @param to The address to which the tokens are minted\r\n    /// @param id The ID of the token being minted\r\n    /// @param amount The amount of the token being minted\r\n    event DropTokensDistributed(address to, ID id, uint256 amount);\r\n\r\n    /// @notice Manually distribute drop tokens to an address\r\n    /// @param _to The address to which the tokens are minted\r\n    /// @param _id The ID of the token being minted\r\n    /// @param _amount The amount of the token being minted\r\n    function distributeDropTokens(\r\n        address _to,\r\n        ID _id,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        require(dropTokens[_id].exists, \"Drop token does not exist\");\r\n        require(dropTokens[_id].supply >= _amount, \"Not enough drop tokens remaining\");\r\n\r\n        dropTokens[_id].supply -= _amount;\r\n        _mint(_to, ID.unwrap(_id), _amount, \"\");\r\n\r\n        emit DropTokensDistributed(_to, _id, _amount);\r\n    }\r\n\r\n    function _dropTokenBalanceOf(address _account) internal view returns (uint256) {\r\n        uint256 balance = 0;\r\n        for (uint256 i = 0; i < dropTokenList.length; i ++) {\r\n            balance += balanceOf(_account, ID.unwrap(dropTokenList[i]));\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    /// @notice Emitted when drop tokens are burned by a holder\r\n    /// @param account The address of the token holder\r\n    /// @param id The ID of the token being burned\r\n    /// @param amount The amount of the token being burned\r\n    event DropTokensBurned(address account, ID id, uint256 amount);\r\n\r\n    /// @notice Emitted when drop tokens are burned by a holder\r\n    /// @param _id The ID of the token to burn\r\n    /// @param _amount The amount of the token to burn\r\n    function burnDropTokens( ID _id, uint256 _amount) external {\r\n        require(dropTokens[_id].exists, \"Drop token does not exist\");\r\n\r\n        _burn(msg.sender, ID.unwrap(_id), _amount);\r\n\r\n        emit DropTokensBurned(msg.sender, _id, _amount);\r\n    }\r\n\r\n    /// @notice Whether unique tokens are availible to be purchased\r\n    bool public uniquesPurchasable = false;\r\n\r\n    struct Unique {\r\n        bool exists;\r\n        bool customPrice;\r\n        bool minted;\r\n        uint256 price;\r\n        bool customDropTokenRequirement;\r\n        uint256 dropTokenRequirement;\r\n    }\r\n\r\n    /// @notice Describes which unique tokens are associated with which IDs \r\n    mapping(ID => Unique) public uniques;\r\n\r\n    /// @notice Emitted when unique tokens are created\r\n    /// @param firstId The id of the first new unique token\r\n    /// @param amount The number of new unique tokens created\r\n    event UniquesCreated(ID firstId, uint256 amount);\r\n\r\n    function _createUniques(uint256 _amount) internal {\r\n        emit UniquesCreated(nextId, _amount);\r\n        for (uint i = 0; i < _amount; i ++) {\r\n            uniques[nextId].exists = true;\r\n            _registerERC721(ID.unwrap(nextId));\r\n            nextId = IDUtils.next(nextId);\r\n        }\r\n    }\r\n\r\n    /// @notice Create a new unique token\r\n    /// @param _amount The number of new unique tokens created\r\n    function createUniques(uint256 _amount) external onlyOwner {\r\n        _createUniques(_amount);\r\n    }\r\n\r\n    /// @notice The default price of all unique tokens without a custom setting\r\n    uint256 public defaultPrice = 10**18;\r\n\r\n    /// @notice The default drop token requirement of all unique tokens without a\r\n    /// custom setting\r\n    uint256 public defaultDropTokenRequirement = 1;\r\n\r\n    /// @notice Emitted when a unique token is purchased\r\n    /// @param account The account who purchased the token\r\n    /// @param id The ID of the token purchased\r\n    /// @param price The price the token sold for\r\n    event UniquePurchased(address account, ID id, uint256 price);\r\n\r\n    /// @notice Purchase a unique token\r\n    /// @param _id The ID of the token to be purchased\r\n    function purchaseUnique(ID _id) external payable nonReentrant {\r\n        require(uniquesPurchasable, \"Uniques not currently purchasable\");\r\n        require(uniques[_id].exists, \"Not a valid unique id\");\r\n        require(!uniques[_id].minted, \"Not enough uniques remaining\");\r\n        _purchaseUnique(_id, msg.sender, msg.value);\r\n    }\r\n\r\n    function _purchaseUnique(\r\n        ID _id,\r\n        address _account,\r\n        uint256 _value\r\n    ) internal {\r\n        require(\r\n            uniques[_id].customDropTokenRequirement ?\r\n                _dropTokenBalanceOf(_account) >=\r\n                    uniques[_id].dropTokenRequirement :\r\n                _dropTokenBalanceOf(_account) >= defaultDropTokenRequirement,\r\n            \"Not enough drop tokens to qualify\"\r\n        );\r\n        uint256 price = uniques[_id].customPrice ?\r\n            uniques[_id].price : defaultPrice;\r\n\r\n        require(_value == price, \"Incorrect payment\");\r\n\r\n        _mint(_account, ID.unwrap(_id), 1, \"\");\r\n        uniques[_id].minted = true;\r\n\r\n        emit UniquePurchased(_account, _id, price);\r\n    }\r\n\r\n    /// @notice Claim part of a merkle drop and purchase a unique token\r\n    /// @param _merkleDropId The ID of the merkle drop\r\n    /// @param _proof The hex proof of the leaf in the tree. The leaves of the\r\n    /// tree must be the address of the recepient as well as the ids and\r\n    /// amounts of each of the drop tokens they will be eligible to claim. They\r\n    /// should be keccak256 abi packed in address, uint256[], uint256[] format.\r\n    /// The merkle tree should be constructed using keccak256 with sorted\r\n    /// pairs.\r\n    /// @param _ids The IDs of the drop tokens to be received\r\n    /// @param _amounts The amounts of the drops tokens correspond to `ids`\r\n    /// @param _uniqueId The ID of the token to be purchased\r\n    function claimMerkleDropAndPurchaseUnique(\r\n        uint256 _merkleDropId,\r\n        bytes32[] calldata _proof,\r\n        ID[] calldata _ids,\r\n        uint256[] calldata _amounts,\r\n        ID _uniqueId\r\n    ) external payable nonReentrant {\r\n        require(uniquesPurchasable, \"Uniques not currently purchasable\");\r\n        require(uniques[_uniqueId].exists, \"Not a valid unique id\");\r\n        require(!uniques[_uniqueId].minted, \"Not enough uniques remaining\");\r\n        _claimMerkleDrop(_merkleDropId, _proof, _ids, _amounts, msg.sender);\r\n        _purchaseUnique(_uniqueId, msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Emitted when funds are withdrawn from the contract\r\n    /// @param to The address to which the funds were sent\r\n    /// @param amount The amount of funds sent in wei\r\n    event FundsWithdrawn(address to, uint256 amount);\r\n\r\n    /// @notice Withdraw funds from the contract\r\n    /// @param _to The address to which the funds were sent\r\n    /// @param _amount The amount of funds sent, in wei\r\n    function withdrawFunds(\r\n        address payable _to,\r\n        uint256 _amount\r\n    ) external onlyOwner nonReentrant {\r\n        require(_amount <= address(this).balance, \"Not enough funds\");\r\n        _to.transfer(_amount);\r\n        emit FundsWithdrawn(_to, _amount);\r\n    }\r\n\r\n    /// @notice Emitted when uniquesPurchasable is updated\r\n    /// @param purchasable Whether unique tokens are now purchasable\r\n    event UniquesPurchasableUpdated(bool purchasable);\r\n\r\n    /// @notice Toggle whether unique tokens are purchasable or not\r\n    function toggleUniquesPurchasable() external onlyOwner {\r\n        uniquesPurchasable = !uniquesPurchasable;\r\n        emit UniquesPurchasableUpdated(uniquesPurchasable);\r\n    }\r\n\r\n    /// @notice Emitted when the default price of unique tokens is updated\r\n    /// @param price The new price, in wei\r\n    event DefaultPriceUpdated(uint256 price);\r\n\r\n    /// @notice Set the default price of unique tokens\r\n    /// @param _price The new price, in wei\r\n    function setDefaultPrice(uint256 _price) external onlyOwner {\r\n        defaultPrice = _price;\r\n        emit DefaultPriceUpdated(_price);\r\n    }\r\n\r\n    /// @notice Emitted when the default drop token requirement to purchase\r\n    /// unique tokens is updated\r\n    /// @param requirement The new drop token requirement\r\n    event DefaultDropTokenRequirementUpdated(uint256 requirement);\r\n\r\n    /// @notice Set the default drop token requirement to purchase unique tokens\r\n    /// @param _dropTokenRequirement The new drop token requirement\r\n    function setDefaultDropTokenRequirement(\r\n        uint256 _dropTokenRequirement\r\n    ) external onlyOwner {\r\n        defaultDropTokenRequirement = _dropTokenRequirement;\r\n        emit DefaultDropTokenRequirementUpdated(_dropTokenRequirement);\r\n    }\r\n\r\n    /// @notice Emitted when the price of a unique token is updated\r\n    /// @param id The id of the unique token\r\n    /// @param price The new price, in wei\r\n    event UniquePriceUpdated(ID id, uint256 price);\r\n\r\n    /// @notice Set the price of a specific unique token\r\n    /// @param _id The id of the unique token\r\n    /// @param _price The new price, in wei\r\n    function setUniquePrice(ID _id, uint256 _price) external onlyOwner {\r\n        require(uniques[_id].exists, \"Not a valid unique id\");\r\n        uniques[_id].customPrice = true;\r\n        uniques[_id].price = _price;\r\n        emit UniquePriceUpdated(_id, _price);\r\n    }\r\n\r\n    /// @notice Emitted when the drop token requirement to purchase a unique\r\n    /// token is updated\r\n    /// @param id The id of the unique token\r\n    /// @param requirement The new drop token requirement\r\n    event UniqueDropTokenRequirementUpdated(ID id, uint256 requirement);\r\n\r\n    /// @notice Set the minimum drop token requirement to purchase a specific\r\n    /// unique token\r\n    /// @param _id The id of the unique token\r\n    /// @param _dropTokenRequirement The new drop token requirement\r\n    function setUniqueDropTokenRequirement(\r\n        ID _id,\r\n        uint256 _dropTokenRequirement\r\n    ) external onlyOwner {\r\n        require(uniques[_id].exists, \"Not a valid unique id\");\r\n        uniques[_id].customDropTokenRequirement = true;\r\n        uniques[_id].dropTokenRequirement = _dropTokenRequirement;\r\n        emit UniqueDropTokenRequirementUpdated(_id, _dropTokenRequirement);\r\n    }\r\n\r\n    /// @notice Emitted when the price of a unique token is set back to default\r\n    /// @param id The ID of the unique token\r\n    event UniquePriceDefault(ID id);\r\n\r\n    /// @notice Set the price of a specific unique token back to default\r\n    /// @param _id The ID of the unique token\r\n    function setUniquePriceDefault(ID _id) external onlyOwner {\r\n        require(uniques[_id].exists, \"Not a valid unique id\");\r\n        uniques[_id].customPrice = false;\r\n        emit UniquePriceDefault(_id);\r\n    }\r\n\r\n    /// @notice Emitted when the drop token requirement of a unique token is set\r\n    /// back to default\r\n    /// @param id The ID of the unique token\r\n    event UniqueDropTokenRequirementDefault(ID id);\r\n\r\n    /// @notice Set the drop token requirement of a specific unique token back to\r\n    /// default\r\n    /// @param _id The ID of the unique token\r\n    function setUniqueDropTokenRequirementDefault(ID _id) external onlyOwner {\r\n        require(uniques[_id].exists, \"Not a valid unique id\");\r\n        uniques[_id].customDropTokenRequirement = false;\r\n        emit UniqueDropTokenRequirementDefault(_id);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IHydra.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\n/// @notice Interface for KomuroDragons contract Hydra bidding\r\ninterface IHydra {\r\n    /// @notice Whether or not an account is eligible to bid on the Hydra\r\n    /// @param _account The address of the account\r\n    /// @return Whether the account is eligible or not\r\n    function canBidOnHydra(address _account) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/KomuroDragons.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Komuro Dragons\r\ncontract KomuroDragons is MerkleDropUniqueToken, IHydra {\r\n\r\n    using Strings for uint256;\r\n\r\n    /// @param _priceFeed Address of a chainlink AggregatorV3 price feed that\r\n    /// controls the Hydra's dynamic URI\r\n    /// @param _positiveHydraUri Hydra URI when price is going up\r\n    /// @param _neutralHydraUri Hydra URI when price is neutral\r\n    /// @param _negativeHydraUri Hydra URI when price is going down\r\n    /// @param _tokenBaseURI The base URI for ERC721 metadata\r\n    /// @param _name The token name for ERC721 metadata\r\n    /// @param _symbol The token symbol for ERC721 metadata\r\n    constructor(\r\n        address _priceFeed,\r\n        string memory _positiveHydraUri,\r\n        string memory _neutralHydraUri,\r\n        string memory _negativeHydraUri,\r\n        string memory _tokenBaseURI,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) MerkleDropUniqueToken() {\r\n        baseURI = _tokenBaseURI;\r\n        tokenSymbol = _symbol;\r\n        tokenName = _name;\r\n        uint256[] memory dropTokenAmounts = new uint256[](15);\r\n        for (uint i = 0; i < 4; i ++) {\r\n            dropTokenAmounts[i] = 2500;\r\n        }\r\n        for (uint i = 4; i < 15; i ++) {\r\n            dropTokenAmounts[i] = 1;\r\n        }\r\n        _createDropTokens(dropTokenAmounts);\r\n        // Hydra\r\n        _initHydra(\r\n            _priceFeed,\r\n            _positiveHydraUri,\r\n            _neutralHydraUri,\r\n            _negativeHydraUri\r\n        );\r\n    }\r\n\r\n    /// @notice Whether or not the hydra has been minted\r\n    bool public isHydraMinted = false;\r\n\r\n    /// @notice The token ID of the Hydra token\r\n    ID public hydraId;\r\n\r\n    /// @dev The three states the Hydra can exist in - depends on price feed\r\n    enum HydraState {\r\n        Positive,\r\n        Neutral,\r\n        Negative\r\n    }\r\n\r\n    /// @dev See {IERC165-supportsInterface}.\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return interfaceId == type(IHydra).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @notice Get the metadata URI for a given token\r\n    /// @param _id The id of the token\r\n    /// @return Metadata URI for the token\r\n    /// @dev See {IERC1155MetadataURI-uri}.\r\n    function uri(\r\n        uint256 _id\r\n    ) public view virtual override returns (string memory) {\r\n        return tokenURI(_id);\r\n    }\r\n\r\n    /// @notice Get the metadata URI for a given token\r\n    /// @param _id The id of the token\r\n    /// @return Metadata URI for the token\r\n    /// @dev See {IERC721Metadata-tokenURI}.\r\n    function tokenURI (\r\n        uint256 _id\r\n    ) public view virtual override returns (string memory) {\r\n        if (isHydraMinted && _id == ID.unwrap(hydraId)) {\r\n            return _hydraUri();\r\n        } else {\r\n            return bytes(_baseURI()).length > 0 ?\r\n                string(abi.encodePacked(_baseURI(), _id.toString())) : \"\";\r\n        }\r\n    }\r\n\r\n    /// @dev Used as the base of {IERC721Metadata-tokenURI}.\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /// @notice The token name\r\n    /// @dev See {IERC721Metadata-name}.\r\n    function name() public view override returns (string memory) {\r\n        return tokenName;\r\n    }\r\n\r\n    /// @notice The token symbol\r\n    /// @dev See {IERC721Metadata-symbol}.\r\n    function symbol() public view override returns (string memory) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    /// @notice The base URI for ERC721 metadata\r\n    string public baseURI;\r\n\r\n    /// @notice Emitted when `baseURI` is updated\r\n    /// @param value The new value of `baseURI`\r\n    event BaseURIUpdated(string value);\r\n\r\n    /// @notice Update the value of `baseURI`\r\n    /// @param _value The new value of `baseURI`\r\n    function setBaseURI(string calldata _value) external onlyOwner {\r\n        baseURI = _value;\r\n        emit BaseURIUpdated(_value);\r\n    }\r\n\r\n    /// @notice The token name for ERC721 metadata\r\n    string public tokenName;\r\n\r\n    /// @notice Emitted when `tokenName` is updated\r\n    /// @param value The new value of `tokenName`\r\n    event TokenNameUpdated(string value);\r\n\r\n    /// @notice Update the value of `tokenName`\r\n    /// @param _value The new value of `tokenName`\r\n    function setTokenName(string calldata _value) external onlyOwner {\r\n        tokenName = _value;\r\n        emit TokenNameUpdated(_value);\r\n    }\r\n\r\n    /// @notice The token symbol for ERC721 metadata\r\n    string public tokenSymbol;\r\n\r\n    /// @notice Emitted when `tokenSymbol` is updated\r\n    /// @param value The new value of `tokenSymbol`\r\n    event TokenSymbolUpdated(string value);\r\n\r\n    /// @notice Update the value of `tokenSymbol`\r\n    /// @param _value The new value of `tokenSymbol`\r\n    function setTokenSymbol(string calldata _value) external onlyOwner {\r\n        tokenSymbol = _value;\r\n        emit TokenSymbolUpdated(_value);\r\n    }\r\n\r\n    /// @notice The Hydra URI when price is going up\r\n    string public hydraUriPositive;\r\n\r\n    /// @notice Emitted when `hydraUriPositive` is updated\r\n    /// @param uri The new uri\r\n    event HydraUriPositiveUpdated(string uri);\r\n\r\n    /// @notice Set `hydraUriPositive`\r\n    /// @param _uri The new uri\r\n    function setHydraUriPositive(string calldata _uri) external onlyOwner {\r\n        hydraUriPositive = _uri;\r\n        emit HydraUriPositiveUpdated(_uri);\r\n    }\r\n\r\n    /// @notice The Hydra URI when price is neutral\r\n    string public hydraUriNeutral;\r\n\r\n    /// @notice Emitted when `hydraUriNeutral` is updated\r\n    /// @param uri The new uri\r\n    event HydraUriNeutralUpdated(string uri);\r\n\r\n    /// @notice Set `hydraUriNeutral`\r\n    /// @param _uri The new uri\r\n    function setHydraUriNeutral(string calldata _uri) external onlyOwner {\r\n        hydraUriNeutral = _uri;\r\n        emit HydraUriNeutralUpdated(_uri);\r\n    }\r\n\r\n    /// @notice The Hydra URI when price is going down\r\n    string public hydraUriNegative;\r\n\r\n    /// @notice Emitted when `hydraUriNegative` is updated\r\n    /// @param uri The new uri\r\n    event HydraUriNegativeUpdated(string uri);\r\n\r\n    /// @notice Set `hydraUriNegative`\r\n    /// @param _uri The new uri\r\n    function setHydraUriNegative(string calldata _uri) external onlyOwner {\r\n        hydraUriNegative = _uri;\r\n        emit HydraUriNegativeUpdated(_uri);\r\n    }\r\n\r\n    /// @notice The number of price feed rounds to go back and get the \"before\"\r\n    /// time in price difference calculations\r\n    uint80 public pricePeriod = 1;\r\n\r\n    /// @notice Emitted when `pricePeriod` is updated\r\n    /// @param value The new value\r\n    event PricePeriodUpdated(uint80 value);\r\n\r\n    /// @notice Set `pricePeriod`\r\n    /// @param _value The new value\r\n    function setPricePeriod(uint80 _value) external onlyOwner {\r\n        pricePeriod = _value;\r\n        emit PricePeriodUpdated(_value);\r\n    }\r\n\r\n    /// @notice The multiplier used in price difference calculations to increase\r\n    /// resolution\r\n    int256 public priceMultiplier = 10000;\r\n\r\n    /// @notice Emitted when `priceMultiplier` is updated\r\n    /// @param value The new value\r\n    event PriceMultiplierUpdated(int256 value);\r\n\r\n    /// @notice Set `priceMultiplier`\r\n    /// @param _value The new value\r\n    function setPriceMultiplier(int256 _value) external onlyOwner {\r\n        priceMultiplier = _value;\r\n        emit PriceMultiplierUpdated(_value);\r\n    }\r\n\r\n    /// @notice The minimum positive price difference after being multiplied by\r\n    /// the `priceMultiplier` to count as a positive change, the negative of\r\n    /// this for negative change\r\n    int256 public minPriceDifference = 30;\r\n\r\n    /// @notice Emitted when `minPriceDifference` is updated\r\n    /// @param value The new value\r\n    event MinPriceDifferenceUpdated(int256 value);\r\n\r\n    /// @notice Set `minPriceDifference`\r\n    /// @param _value The new value\r\n    function setMinPriceDifference(int256 _value) external onlyOwner {\r\n        minPriceDifference = _value;\r\n        emit MinPriceDifferenceUpdated(_value);\r\n    }\r\n\r\n    /// @notice The chainlink AggregatorV3Interface-compatible contract that\r\n    /// provides price feed information for the Hydra's dynamic URI feature\r\n    AggregatorV3Interface public priceFeed;\r\n\r\n    /// @notice Emitted when the price feed is updated\r\n    /// @param priceFeed The address of the price feed contract\r\n    event PriceFeedUpdated(address priceFeed);\r\n\r\n    /// @notice Update the price feed\r\n    /// @param _priceFeed The address of the chainlink\r\n    /// AggregatorV3Interface-compatible price feed contract\r\n    function setPriceFeed(address _priceFeed) external onlyOwner {\r\n        priceFeed = AggregatorV3Interface(_priceFeed);\r\n        emit PriceFeedUpdated(_priceFeed);\r\n    }\r\n\r\n    /// @notice The number of drop tokens needed to take part in the Hydra\r\n    /// auction\r\n    uint256 public hydraDropTokenRequirement = 1;\r\n\r\n    /// @notice Emitted when the number of drop tokens required to bid on the\r\n    /// Hydra is updated\r\n    /// @param requirement The number of drop tokens required\r\n    event HydraDropTokenRequirementUpdated(uint256 requirement);\r\n\r\n    /// @notice Set the number of drop tokens required to bid on the Hydra\r\n    /// @param _dropTokenRequirement The number of drop tokens required\r\n    function setHydraDropTokenRequirement(\r\n        uint256 _dropTokenRequirement\r\n    ) external onlyOwner {\r\n        hydraDropTokenRequirement = _dropTokenRequirement;\r\n        emit HydraDropTokenRequirementUpdated(_dropTokenRequirement);\r\n    }\r\n\r\n    function _initHydra(\r\n        address _priceFeed,\r\n        string memory _positiveUri,\r\n        string memory _neutralUri,\r\n        string memory _negativeUri\r\n    ) internal {\r\n        priceFeed = AggregatorV3Interface(_priceFeed);\r\n        hydraUriPositive = _positiveUri;\r\n        hydraUriNeutral = _neutralUri;\r\n        hydraUriNegative = _negativeUri;\r\n    }\r\n\r\n    function _getHydraState() internal view returns (HydraState) {\r\n        (uint80 roundId, int currentPrice,,,) = priceFeed.latestRoundData();\r\n        (, int previousPrice,,,) = priceFeed.getRoundData(\r\n            roundId - pricePeriod\r\n        );\r\n        int256 priceDifference = previousPrice == int256(0) ? int256(0) :\r\n            ((currentPrice - previousPrice) * priceMultiplier) / previousPrice;\r\n        if (priceDifference >= minPriceDifference) {\r\n            return HydraState.Positive;\r\n        }\r\n        if (priceDifference <= -minPriceDifference) {\r\n            return HydraState.Negative;\r\n        } \r\n        return HydraState.Neutral;\r\n    }\r\n\r\n    function _hydraUri() internal view returns (string memory) {\r\n        HydraState state = _getHydraState();\r\n        if (state == HydraState.Positive) {\r\n            return hydraUriPositive;\r\n        } else if (state == HydraState.Neutral) {\r\n            return hydraUriNeutral;\r\n        } else {\r\n            return hydraUriNegative;\r\n        }\r\n    }\r\n\r\n    /// @notice Whether or not an account is eligible to bid on the Hydra\r\n    /// @param _account The address of the account\r\n    /// @return Whether the account is eligible or not\r\n    function canBidOnHydra(\r\n        address _account\r\n    ) external view override returns (bool) {\r\n        return _dropTokenBalanceOf(_account) >= hydraDropTokenRequirement;\r\n    }\r\n\r\n    /// @notice Transfer the hydra to another owner\r\n    /// @param _to The address of the new owner\r\n    function transferHydra(address _to) external onlyOwner nonReentrant {\r\n        require(!isHydraMinted, \"Not enough hydras remaining\");\r\n\r\n        hydraId = nextId;\r\n        nextId = IDUtils.next(nextId);\r\n        _registerERC721(ID.unwrap(hydraId));\r\n\r\n        _mint(_to, ID.unwrap(hydraId), 1, \"\");\r\n\r\n        isHydraMinted = true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_positiveHydraUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_neutralHydraUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_negativeHydraUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenBaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"BaseURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requirement\",\"type\":\"uint256\"}],\"name\":\"DefaultDropTokenRequirementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"DefaultPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DropTokensBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"firstId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"DropTokensCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DropTokensDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requirement\",\"type\":\"uint256\"}],\"name\":\"HydraDropTokenRequirementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"HydraUriNegativeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"HydraUriNeutralUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"HydraUriPositiveUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleDropId\",\"type\":\"uint256\"}],\"name\":\"MerkleDropCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleDropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"ID[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"MerkleDropClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleDropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"ID[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"MerkleDropCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"MinPriceDifferenceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"}],\"name\":\"PriceFeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"PriceMultiplierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"value\",\"type\":\"uint80\"}],\"name\":\"PricePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"TokenNameUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"TokenSymbolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"UniqueDropTokenRequirementDefault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requirement\",\"type\":\"uint256\"}],\"name\":\"UniqueDropTokenRequirementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"UniquePriceDefault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UniquePriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"UniquePurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"ID\",\"name\":\"firstId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UniquesCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"purchasable\",\"type\":\"bool\"}],\"name\":\"UniquesPurchasableUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnDropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"canBidOnHydra\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_merkleDropId\",\"type\":\"uint256\"}],\"name\":\"cancelMerkleDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_merkleDropId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"ID[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"claimMerkleDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_merkleDropId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"ID[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"ID\",\"name\":\"_uniqueId\",\"type\":\"uint256\"}],\"name\":\"claimMerkleDropAndPurchaseUnique\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"createDropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"ID[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"createMerkleDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createUniques\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultDropTokenRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeDropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dropTokenList\",\"outputs\":[{\"internalType\":\"ID\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dropTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hydraDropTokenRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hydraId\",\"outputs\":[{\"internalType\":\"ID\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hydraUriNegative\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hydraUriNeutral\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hydraUriPositive\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isHydraMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_merkleDropId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isMerkleDropClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleDrops\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPriceDifference\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"internalType\":\"ID\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextMerkleDropId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceMultiplier\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePeriod\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"purchaseUnique\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dropTokenRequirement\",\"type\":\"uint256\"}],\"name\":\"setDefaultDropTokenRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setDefaultPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dropTokenRequirement\",\"type\":\"uint256\"}],\"name\":\"setHydraDropTokenRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setHydraUriNegative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setHydraUriNeutral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setHydraUriPositive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_value\",\"type\":\"int256\"}],\"name\":\"setMinPriceDifference\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_value\",\"type\":\"int256\"}],\"name\":\"setPriceMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_value\",\"type\":\"uint80\"}],\"name\":\"setPricePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setTokenSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dropTokenRequirement\",\"type\":\"uint256\"}],\"name\":\"setUniqueDropTokenRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"setUniqueDropTokenRequirementDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setUniquePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"setUniquePriceDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleUniquesPurchasable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferHydra\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ID\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniques\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"customPrice\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"minted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"customDropTokenRequirement\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"dropTokenRequirement\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniquesPurchasable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KomuroDragons","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b841900000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000002e00000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000005068747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d596a4b7353426545536f693557367132386b3874747a6776473357326a61654231453745693944653174343700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005068747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d596a4b7353426545536f693557367132386b3874747a6776473357326a61654231453745693944653174343700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005068747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d596a4b7353426545536f693557367132386b3874747a6776473357326a61654231453745693944653174343700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005168747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d52515a526b686752446e43755369425067735469676747635154316f4e787a547679313576536d65547861672f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f54414b414849524f204b4f4d55524f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004546b6f4d00000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e1225b47975ea9abaf0d75054e8631e5ec97e6a64b9c00d341a0feb872f7312b"}]}