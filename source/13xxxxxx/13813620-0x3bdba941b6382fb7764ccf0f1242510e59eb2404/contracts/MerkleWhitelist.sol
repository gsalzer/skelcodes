// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

interface IERC721EnumInitMint {
    function mint(address to, uint id) external;
    function totalSupply() external view returns (uint256);
}

contract MerkleWhitelist is Ownable
{
    address public mintingContract;
    bytes32 public merkleRoot;
    mapping(uint256 => uint256) public claimed;
    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor() {
    }

    function numClaimed(uint256 index) public view returns (uint) {
        return claimed[index];
    }

    function setMintingContract(address mintingContract_) public onlyOwner {
        mintingContract = mintingContract_;
    }

    function setMerkleRoot(bytes32 merkleRoot_) public onlyOwner {
        merkleRoot = merkleRoot_;
    }

    function claimWhitelist(uint index, uint claimAmmt, uint claimTotal, bytes32[] calldata merkleProof) external {
        require(claimed[index] + claimAmmt <= claimTotal, "LimitMerkleWhitelist: Already claimed."); 
        claimed[index] += claimAmmt;       
        uint num = 1;
        bytes32 node = keccak256(abi.encode(index, claimTotal, keccak256(abi.encode(msg.sender)), num));
        require(MerkleProof.verify(merkleProof, merkleRoot, node), "Not in allow list.");
        uint mintIdx = IERC721EnumInitMint(mintingContract).totalSupply();
        for(uint i = 0; i < claimAmmt; i++) {
            mintIdx += 1;
            IERC721EnumInitMint(mintingContract).mint(msg.sender, mintIdx);
        }
    }

    function release(address payable _recv, uint _amount) public onlyOwner {
        Address.sendValue(_recv, _amount);
    }
}

