{"status":"1","message":"OK","result":[{"SourceCode":"{\"ArbGateway.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./Outbox.sol\\\";\\r\\nimport \\\"./Inbox.sol\\\";\\r\\nimport \\\"./ArbSys.sol\\\";\\r\\nimport \\\"./Initializable.sol\\\";\\r\\n\\r\\ninterface HungryBunz is IERC721 {\\r\\n    function serializeAtts(uint16 tokenId) external view returns (bytes16);\\r\\n    function serializeStats(uint16 tokenId) external view returns (bytes16);\\r\\n    function writeSerializedAtts(uint16 tokenId, bytes16 newAtts) external;\\r\\n    function writeSerializedStats(uint16 tokenId, bytes16 newStats) external;\\r\\n    function setInactiveOnThisChain(uint16 tokenId) external;\\r\\n    function setActiveOnThisChain(uint16 tokenId, bytes memory metadata, address sender) external;\\r\\n    function applicationOwnerOf(uint256 tokenId) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface INom {\\r\\n    function burn(address account, uint256 amount) external;\\r\\n    function applicationMint(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ninterface IArbPartner {\\r\\n    function synchronizeAndRelease(uint16,address,bytes memory) external;\\r\\n    function receiveNom(address initiatedBy, uint256 quantity) external;\\r\\n}\\r\\n\\r\\ncontract ArbGateway is Ownable, Initializable {\\r\\n    //******************************************************\\r\\n    //CRITICAL CONTRACT PARAMETERS\\r\\n    //******************************************************\\r\\n    //Pausable library is simple enough to integrate into this contract\\r\\n    bool public paused = false;\\r\\n\\r\\n    uint8 _layer;\\r\\n    address _signer;\\r\\n    address _arbPartner;\\r\\n    IArbPartner _arbPartnerInterface;\\r\\n    IInbox _inbox; //Inbox for L1\\r\\n    IOutbox _outbox; //Outbox for L2\\r\\n    HungryBunz _hbContract; //Layer-local main contract\\r\\n    INom _nom; //Layer-local Nom contract\\r\\n    ArbSys _ArbSys = ArbSys(address(100)); //ArbSys address never changes!\\r\\n    \\r\\n    event receivedMessageFromL1(address sentBy, uint16 tokenId);\\r\\n    \\r\\n    //******************************************************\\r\\n    //CONTRACT CONSTRUCTOR\\r\\n    //******************************************************\\r\\n    constructor()\\r\\n    {\\r\\n        ownableInit();\\r\\n    }\\r\\n\\r\\n    function initGateway (\\r\\n        address hbContractAddress,\\r\\n        address nomContract,\\r\\n        uint8 layer\\r\\n    ) external initializer\\r\\n    {\\r\\n        require(owner() == address(0) || owner() == msg.sender,\\r\\n            \\\"No.\\\");\\r\\n        \\r\\n        ownableInit();\\r\\n        _layer = layer; //Set to 1 for L1, 2 for L2\\r\\n        _hbContract = HungryBunz(hbContractAddress);\\r\\n        _nom = INom(nomContract);\\r\\n\\r\\n        _signer = 0xF658480075BA1158f12524409066Ca495b54b0dD;\\r\\n    }\\r\\n    \\r\\n    function updateArbitrumInbox(address gatewayAddress) public onlyOwner {\\r\\n        _inbox = IInbox(gatewayAddress);\\r\\n        _outbox = IOutbox(_inbox.bridge().activeOutbox());\\r\\n    }\\r\\n    \\r\\n    function updateArbitrumPartner(address partnerAddress) public onlyOwner {\\r\\n        if (_layer == 1) {\\r\\n            _arbPartner = partnerAddress;\\r\\n        } else {\\r\\n            address aliasedAddress = address(uint160(partnerAddress) + uint160(0x1111000000000000000000000000000000001111));\\r\\n            _arbPartner = aliasedAddress;\\r\\n        }\\r\\n        _arbPartnerInterface = IArbPartner(_arbPartner);\\r\\n    }\\r\\n\\r\\n    //Cost of owner pausing when already paused is mild annoyance.\\r\\n    //Removed extra requires\\r\\n    function pause() onlyOwner public {\\r\\n        paused = true;\\r\\n    }\\r\\n    \\r\\n    function arbToEth(bytes memory synchronizationData) internal {\\r\\n        _ArbSys.sendTxToL1(\\r\\n            _arbPartner,\\r\\n            synchronizationData\\r\\n            );\\r\\n        _ArbSys.sendTxToL1{value: msg.value}(msg.sender, \\u0027\\u0027);\\r\\n    }\\r\\n    \\r\\n    function ethToArb(bytes memory synchronizationData, uint256 maxBaseFee, uint256 maxGas, uint256 maxPriority) internal {\\r\\n        uint256 nftTransferFees = (maxGas * maxPriority) + maxBaseFee;\\r\\n        require(msg.value \\u003e= nftTransferFees + maxBaseFee, \\\"Insufficient funds\\\");\\r\\n\\r\\n        _inbox.createRetryableTicketNoRefundAliasRewrite{value: nftTransferFees}(\\r\\n            _arbPartner, //Destination address\\r\\n            0, //Call value for remote contract call. Always 0.\\r\\n            maxBaseFee, //Max submission cost\\r\\n            msg.sender, //Refund excess to sender\\r\\n            msg.sender, //Refund excess to sender\\r\\n            maxGas, //Maximum gas units\\r\\n            maxPriority, //Maximum gas price\\r\\n            synchronizationData\\r\\n            );\\r\\n    }\\r\\n    \\r\\n    //Temporarily changed from payable to view for diagnostics.\\r\\n    function teleportAndLock(uint16[] memory tokenIds, uint256 maxBaseFee, uint256 maxGas, uint256 maxPriority) public payable{\\r\\n        require(paused == false, \\\"Gateway paused.\\\");\\r\\n\\r\\n        uint256 nftTransferFees = (maxGas * maxPriority) + maxBaseFee;\\r\\n        require(msg.value \\u003e= (nftTransferFees * tokenIds.length),\\r\\n            \\\"Insufficient funds\\\");\\r\\n\\r\\n        for(uint i = 0; i \\u003c tokenIds.length; i++) {\\r\\n            //Use overriden ownerOf check to implicitly prevent\\r\\n            //exploits involving teleporting a token more than\\r\\n            //once, or teleporting immediately after staking.\\r\\n            require(msg.sender == _hbContract.applicationOwnerOf(uint256(tokenIds[i])),\\r\\n                \\\"Cannot teleport token you don\\u0027t own!\\\");\\r\\n            \\r\\n            //We won\\u0027t synchronize names between layers, since\\r\\n            //arbitrary length strings could be exceedingly\\r\\n            //expensive to synchronize across layers. This can\\r\\n            //create a nuisance for future owners.\\r\\n            bytes memory tokenProperties = abi.encodePacked(\\r\\n                    _hbContract.serializeAtts(tokenIds[i]),\\r\\n                    _hbContract.serializeStats(tokenIds[i])\\r\\n                );\\r\\n                \\r\\n            bytes memory returndata = abi.encodeWithSelector(\\r\\n                IArbPartner.synchronizeAndRelease.selector,\\r\\n                tokenIds[i],\\r\\n                msg.sender,\\r\\n                tokenProperties\\r\\n            );\\r\\n            \\r\\n            _hbContract.setInactiveOnThisChain(tokenIds[i]);\\r\\n            \\r\\n            if(_layer == 1) {\\r\\n                ethToArb(returndata, maxBaseFee, maxGas, maxPriority); \\r\\n            } else {\\r\\n                arbToEth(returndata);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function synchronizeAndRelease(uint16 tokenId, address initiatedBy, bytes memory properties) external {\\r\\n        require(paused == false, \\\"Gateway paused.\\\");\\r\\n        bool authorizedSender;\\r\\n        if (_layer == 2) {\\r\\n            if(msg.sender == _arbPartner) {\\r\\n                authorizedSender = true;\\r\\n            }\\r\\n        } else {\\r\\n            if(_outbox.l2ToL1Sender() == _arbPartner \\u0026\\u0026 msg.sender == address(_outbox)) {\\r\\n                authorizedSender = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(authorizedSender, \\\"Not from authorized sender\\\");\\r\\n        emit receivedMessageFromL1(initiatedBy, tokenId);\\r\\n        _hbContract.setActiveOnThisChain(tokenId, properties, initiatedBy);\\r\\n    }\\r\\n    \\r\\n    //Temporarily changed from payable to view for diagnostics.\\r\\n    function sendNom(uint256 quantity, uint256 maxBaseFee, uint256 maxGas, uint256 maxPriority) public payable{\\r\\n        require(paused == false, \\\"Gateway paused.\\\");\\r\\n\\r\\n        uint256 nftTransferFees = (maxGas * maxPriority) + maxBaseFee;\\r\\n        uint256 ethToDeposit = msg.value - (nftTransferFees);\\r\\n        \\r\\n        _inbox.depositEth{value: ethToDeposit}(maxBaseFee);\\r\\n        _nom.burn(msg.sender, quantity);\\r\\n\\r\\n        bytes memory returndata = abi.encodeWithSelector(\\r\\n            IArbPartner.receiveNom.selector,\\r\\n            msg.sender,\\r\\n            quantity\\r\\n        );\\r\\n        \\r\\n        if(_layer == 1) {\\r\\n            ethToArb(returndata, maxBaseFee, maxGas, maxPriority); \\r\\n        } else {\\r\\n            arbToEth(returndata);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function receiveNom(address initiatedBy, uint256 quantity) external {\\r\\n        require(paused == false, \\\"Gateway paused.\\\");\\r\\n        bool authorizedSender;\\r\\n        if (_layer == 2) {\\r\\n            if(msg.sender == _arbPartner) {\\r\\n                authorizedSender = true;\\r\\n            }\\r\\n        } else {\\r\\n            if(_outbox.l2ToL1Sender() == _arbPartner \\u0026\\u0026 msg.sender == address(_outbox)) {\\r\\n                authorizedSender = true;\\r\\n            }\\r\\n        }\\r\\n        require(authorizedSender, \\\"Not from authorized sender\\\");\\r\\n        _nom.applicationMint(initiatedBy, quantity);\\r\\n    }\\r\\n\\r\\n    //******************************************************\\r\\n    //OWNER ONLY RECOVERY FUNCTIONS FOR EMERGENCIES\\r\\n    //******************************************************\\r\\n    function lastDitchLock(uint16 tokenId) external onlyOwner {\\r\\n        _hbContract.setInactiveOnThisChain(tokenId);\\r\\n    }\\r\\n\\r\\n    function lastDitchRelease(uint16 tokenId, address initiatedBy, bytes memory properties) external onlyOwner {\\r\\n        _hbContract.setActiveOnThisChain(tokenId, properties, initiatedBy);\\r\\n    }\\r\\n}\"},\"ArbSys.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0;\\r\\n\\r\\n/**\\r\\n* @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\r\\n */\\r\\ninterface ArbSys {\\r\\n    /**\\r\\n    * @notice Get internal version number identifying an ArbOS build\\r\\n    * @return version number as int\\r\\n     */\\r\\n    function arbOSVersion() external pure returns (uint);\\r\\n\\r\\n    /**\\r\\n    * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\r\\n    * @return block number as int\\r\\n     */ \\r\\n    function arbBlockNumber() external view returns (uint);\\r\\n\\r\\n    /** \\r\\n    * @notice Send given amount of Eth to dest from sender.\\r\\n    * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\r\\n    * @param destination recipient address on L1\\r\\n    * @return unique identifier for this L2-to-L1 transaction.\\r\\n    */\\r\\n    function withdrawEth(address destination) external payable returns(uint);\\r\\n\\r\\n    /** \\r\\n    * @notice Send a transaction to L1\\r\\n    * @param destination recipient address on L1 \\r\\n    * @param calldataForL1 (optional) calldata for L1 contract call\\r\\n    * @return a unique identifier for this L2-to-L1 transaction.\\r\\n    */\\r\\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns(uint);\\r\\n\\r\\n\\r\\n    /** \\r\\n    * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\r\\n    * @param account target account\\r\\n    * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\r\\n    */\\r\\n    function getTransactionCount(address account) external view returns(uint256);\\r\\n\\r\\n    /**  \\r\\n    * @notice get the value of target L2 storage slot \\r\\n    * This function is only callable from address 0 to prevent contracts from being able to call it\\r\\n    * @param account target account\\r\\n    * @param index target index of storage slot \\r\\n    * @return stotage value for the given account at the given index\\r\\n    */\\r\\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    * @notice check if current call is coming from l1\\r\\n    * @return true if the caller of this was called directly from L1\\r\\n    */\\r\\n    function isTopLevelCall() external view returns (bool);\\r\\n\\r\\n    event EthWithdrawal(address indexed destAddr, uint amount);\\r\\n\\r\\n    event L2ToL1Transaction(address caller, address indexed destination, uint indexed uniqueId,\\r\\n                            uint indexed batchNumber, uint indexInBatch,\\r\\n                            uint arbBlockNum, uint ethBlockNum, uint timestamp,\\r\\n                            uint callvalue, bytes data);\\r\\n}\"},\"IERC721.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n// File: gateway-contracts/IERC721.sol\\r\\n\\r\\n\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\"},\"Inbox.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity \\u003e=0.7.0;\\r\\n\\r\\n\\r\\ninterface IInbox {\\r\\n    \\r\\n    \\r\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\r\\n\\r\\n    function sendUnsignedTransaction(\\r\\n        uint256 maxGas,\\r\\n        uint256 gasPriceBid,\\r\\n        uint256 nonce,\\r\\n        address destAddr,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function sendContractTransaction(\\r\\n        uint256 maxGas,\\r\\n        uint256 gasPriceBid,\\r\\n        address destAddr,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256);\\r\\n\\r\\n   function sendL1FundedUnsignedTransaction(\\r\\n        uint256 maxGas,\\r\\n        uint256 gasPriceBid,\\r\\n        uint256 nonce,\\r\\n        address destAddr,\\r\\n        bytes calldata data\\r\\n    ) external payable returns (uint256);\\r\\n\\r\\n    function sendL1FundedContractTransaction(\\r\\n        uint256 maxGas,\\r\\n        uint256 gasPriceBid,\\r\\n        address destAddr,\\r\\n        bytes calldata data\\r\\n    ) external payable returns (uint256);\\r\\n\\r\\n    function createRetryableTicket(\\r\\n        address destAddr,\\r\\n        uint256 arbTxCallValue,\\r\\n        uint256 maxSubmissionCost,\\r\\n        address submissionRefundAddress,\\r\\n        address valueRefundAddress,\\r\\n        uint256 maxGas,\\r\\n        uint256 gasPriceBid,\\r\\n        bytes calldata data\\r\\n    ) external payable returns (uint256);\\r\\n    \\r\\n    function createRetryableTicketNoRefundAliasRewrite(\\r\\n        address destAddr,\\r\\n        uint256 l2CallValue,\\r\\n        uint256 maxSubmissionCost,\\r\\n        address excessFeeRefundAddress,\\r\\n        address callValueRefundAddress,\\r\\n        uint256 maxGas,\\r\\n        uint256 gasPriceBid,\\r\\n        bytes calldata data\\r\\n    ) external payable returns (uint256);\\r\\n\\r\\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\r\\n\\r\\n    function bridge() external view returns (IBridge);\\r\\n}\\r\\n\\r\\n\\r\\ninterface IBridge {\\r\\n    event MessageDelivered(\\r\\n        uint256 indexed messageIndex,\\r\\n        bytes32 indexed beforeInboxAcc,\\r\\n        address inbox,\\r\\n        uint8 kind,\\r\\n        address sender,\\r\\n        bytes32 messageDataHash\\r\\n    );\\r\\n\\r\\n    function deliverMessageToInbox(\\r\\n        uint8 kind,\\r\\n        address sender,\\r\\n        bytes32 messageDataHash\\r\\n    ) external payable returns (uint256);\\r\\n\\r\\n    function executeCall(\\r\\n        address destAddr,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (bool success, bytes memory returnData);\\r\\n\\r\\n    // These are only callable by the admin\\r\\n    function setInbox(address inbox, bool enabled) external;\\r\\n\\r\\n    function setOutbox(address inbox, bool enabled) external;\\r\\n\\r\\n    // View functions\\r\\n\\r\\n    function activeOutbox() external view returns (address);\\r\\n\\r\\n    function allowedInboxes(address inbox) external view returns (bool);\\r\\n\\r\\n    function allowedOutboxes(address outbox) external view returns (bool);\\r\\n\\r\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\r\\n\\r\\n    function messageCount() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IMessageProvider {\\r\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\r\\n\\r\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\r\\n}\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since a proxied contract can\\u0027t have a constructor, it\\u0027s common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n */\\r\\nabstract contract Initializable {\\r\\n    /**\\r\\n     * @dev Indicates that the contract has been initialized.\\r\\n     */\\r\\n    bool private _initialized;\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract is in the process of being initialized.\\r\\n     */\\r\\n    bool private _initializing;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n            _initialized = true;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"Outbox.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\r\\n\\r\\n/*\\r\\n * Copyright 2021, Offchain Labs, Inc.\\r\\n *\\r\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n * you may not use this file except in compliance with the License.\\r\\n * You may obtain a copy of the License at\\r\\n *\\r\\n *    http://www.apache.org/licenses/LICENSE-2.0\\r\\n *\\r\\n * Unless required by applicable law or agreed to in writing, software\\r\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n * See the License for the specific language governing permissions and\\r\\n * limitations under the License.\\r\\n */\\r\\n\\r\\npragma solidity \\u003e=0.7.0;\\r\\n\\r\\ninterface IOutbox {\\r\\n    event OutboxEntryCreated(\\r\\n        uint256 indexed batchNum,\\r\\n        uint256 outboxIndex,\\r\\n        bytes32 outputRoot,\\r\\n        uint256 numInBatch\\r\\n    );\\r\\n\\r\\n    function l2ToL1Sender() external view returns (address);\\r\\n\\r\\n    function l2ToL1Block() external view returns (uint256);\\r\\n\\r\\n    function l2ToL1EthBlock() external view returns (uint256);\\r\\n\\r\\n    function l2ToL1Timestamp() external view returns (uint256);\\r\\n\\r\\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\\r\\n        external;\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initialization\\r\\n     */\\r\\n    function ownableInit() internal {\\r\\n        _setOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Caller is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sentBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"receivedMessageFromL1\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hbContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nomContract\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"}],\"name\":\"initGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"lastDitchLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initiatedBy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"properties\",\"type\":\"bytes\"}],\"name\":\"lastDitchRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiatedBy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"receiveNom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriority\",\"type\":\"uint256\"}],\"name\":\"sendNom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"initiatedBy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"properties\",\"type\":\"bytes\"}],\"name\":\"synchronizeAndRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256\",\"name\":\"maxBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriority\",\"type\":\"uint256\"}],\"name\":\"teleportAndLock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gatewayAddress\",\"type\":\"address\"}],\"name\":\"updateArbitrumInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"partnerAddress\",\"type\":\"address\"}],\"name\":\"updateArbitrumPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ArbGateway","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6d6ea6563b0d1892cc9e7000886bbda090e78ae8720b0e67e8da5c7bd7415a2f"}]}