{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface KeeperCompatibleInterface {\\n\\n  /**\\n   * @notice checks if the contract requires work to be done.\\n   * @param checkData data passed to the contract when checking for upkeep.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with,\\n   * if upkeep is needed.\\n   */\\n  function checkUpkeep(\\n    bytes calldata checkData\\n  )\\n    external\\n    returns (\\n      bool upkeepNeeded,\\n      bytes memory performData\\n    );\\n\\n  /**\\n   * @notice Performs work on the contract. Executed by the keepers, via the registry.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation.\\n   */\\n  function performUpkeep(\\n    bytes calldata performData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/EthroneContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\\\";\\n\\n/**\\n * @title EthroneContract\\n * @dev Manages the Ethrone game contract\\n *\\n * Rules:\\n * fixed amount to enter (low) goes into prize pool\\n * only one player can take the throne per block\\n * players can only capture the throne `maxAttempts` times per round (default: 3)\\n * time spent accumulates for the user everytimes they takes over the throne\\n * a round lasts `roundDuration` seconds (default: 24h)\\n * at the end of the round - prizepool goes to user who spent the most time on the Throne\\n * if multiple top users with the same time spent -> the first player that has reached the time gets the prize\\n */\\ncontract EthroneContract is KeeperCompatibleInterface {\\n\\n    uint8 public immutable maxAttempts;\\n    uint32 public immutable roundDuration;\\n    address public immutable contractOwner;\\n    uint256 public immutable throneCost;\\n\\n    uint256 public lastRoundStartTime;\\n    uint32 public round;\\n    address public lastWinner;\\n    ThroneOwner public currentThroneOwner;\\n    address[] public participants;\\n    mapping (address => uint32) timeSpentMapping;\\n    mapping (address => uint8) attemptsMapping;\\n\\n    event ThroneTaken(address prevOwner, address newOwner, uint32 prevOwnerTimeSpent, uint32 round);\\n    event WinnerChosen(address winner, uint256 prize, uint32 totalTimeSpent, uint32 round, uint32 totalPlayers);\\n\\n    struct ThroneOwner {\\n        address user;\\n        uint256 timestamp;\\n        bytes32 hash;\\n    }\\n\\n    constructor(uint32 duration, uint8 maxAttemptsPerPlayer, uint256 cost) {\\n        contractOwner = msg.sender;\\n        round = 1;\\n        roundDuration = duration;\\n        lastRoundStartTime = block.timestamp;\\n        maxAttempts = maxAttemptsPerPlayer;\\n        throneCost = cost;\\n    }\\n\\n    // Keeper interface\\n\\n    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {\\n        upkeepNeeded = (block.timestamp - lastRoundStartTime) > roundDuration;\\n    }\\n\\n    function performUpkeep(bytes calldata /* performData */) external override {\\n        awardPrize();\\n    }\\n\\n    // Game public methods   \\n\\n    /**\\n      Main game function\\n     */\\n    function takeThrone() public payable {\\n        require(msg.value == throneCost, \\\"Exactly 0.01 ether is required to take the Ethrone\\\"); // mandatory fixed price\\n        require((block.timestamp - lastRoundStartTime) < roundDuration, \\\"The round is over! Wait for the next one to start\\\");\\n        // contractOwner cannot take the throne\\n        address newOwner = msg.sender;\\n        require(newOwner != currentThroneOwner.user, \\\"You already own the Ethrone!\\\");\\n        require(newOwner != contractOwner, \\\"The contract owner is not allowed to play\\\");\\n\\n        // reject transaction if the current owner already owns this block\\n        bytes32 currentHash = blockhash(block.number - 1);\\n        require(currentThroneOwner.hash != currentHash, \\\"The throne is already taken for this block!\\\");\\n\\n        // reject transaction if player already reached the max attempts this round\\n        require(attemptsMapping[newOwner] < maxAttempts, \\\"You have reached the maximum attempts for this round\\\");\\n\\n        // record new participant if not already recorded\\n        if (attemptsMapping[newOwner] == 0) {\\n          participants.push(newOwner);\\n        }\\n\\n        // increment attempts for player\\n        attemptsMapping[newOwner] = attemptsMapping[newOwner] + 1;        \\n\\n        // record time for last owner\\n        updateLastTimeSpent();\\n\\n        // set the new owner\\n        address previousOwner = currentThroneOwner.user;\\n        currentThroneOwner = ThroneOwner(newOwner, block.timestamp, currentHash);\\n        emit ThroneTaken(previousOwner, newOwner, accumulatedTimeSpent(previousOwner), round);\\n    }\\n\\n    /**\\n     * Find the winner of the round and transfers the prize to it\\n     */\\n    function awardPrize() public {\\n        require((block.timestamp - lastRoundStartTime) > roundDuration, \\\"The round is not over yet!\\\");\\n        \\n        // find winner\\n        uint32 participantSize = uint32(participants.length);\\n        uint32 longestTimeSpent = 0;\\n        address winner;\\n\\n        // no players this round, start the next one\\n        if (participantSize == 0) {\\n            resetGameAndStartNextRound();\\n            return;\\n        }\\n\\n        // update last owner's time spent\\n        updateLastTimeSpent();\\n\\n        // find the winner address\\n        for (uint32 i = 0; i < participantSize; i++) {\\n            address participant = participants[i];\\n            uint32 timeSpent = timeSpentMapping[participant];\\n            if (timeSpent > longestTimeSpent && participant != contractOwner) {\\n                winner = participant;\\n                longestTimeSpent = timeSpent;\\n            }\\n        }\\n\\n        // assert valid winner\\n        require(winner != address(0x0), \\\"Did not find a winner\\\");\\n        require(winner != contractOwner, \\\"Winner cannot be the owner\\\");\\n        // transfer prize\\n        uint256 totalPrize = currentPrizePool();\\n        uint256 winnerPrize = totalPrize * 90 / 100; // 90% for the winner\\n        uint256 maintenanceBudget = totalPrize - winnerPrize; // 10% for maintenance costs\\n        payable(winner).transfer(winnerPrize);\\n        payable(contractOwner).transfer(maintenanceBudget);\\n        lastWinner = winner;\\n        emit WinnerChosen(winner, winnerPrize, accumulatedTimeSpent(winner), round, participantSize);\\n\\n        // cleanup and start next round\\n        resetGameAndStartNextRound();\\n    }\\n\\n    /**\\n     * The total prize pool for this round\\n     */\\n    function currentPrizePool() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /**\\n     * The time spent by the last owner\\n     */\\n    function currentTimeSpent() public view returns (uint32) {\\n        return uint32(block.timestamp - currentThroneOwner.timestamp);\\n    }\\n\\n    /**\\n     * The address of the current owner\\n     */\\n    function currentOwner() public view returns (address) {\\n      return currentThroneOwner.user;\\n    }\\n\\n    /**\\n     * The previous time spent for a given address (excluding current)\\n     */\\n    function accumulatedTimeSpent(address user) public view returns (uint32) {\\n        return timeSpentMapping[user];\\n    }\\n\\n    /**\\n     * The total time spent (including current) for the given address\\n     */\\n    function totalTimeSpent(address user) public view returns (uint32) {\\n        if (user == currentThroneOwner.user) {\\n          return currentTimeSpent() + accumulatedTimeSpent(user);\\n        }\\n        return accumulatedTimeSpent(user);\\n    }\\n\\n    /**\\n     * Total number of participants for this round\\n     */\\n    function totalParticipants() public view returns (uint32) {\\n        return uint32(participants.length);\\n    }\\n\\n    /**\\n     * The amount of time since current round started\\n     */\\n    function currentRoundTime() public view returns (uint32) {\\n        return uint32(block.timestamp - lastRoundStartTime);\\n    }\\n\\n    /**\\n     * The number of attempts for a given player this round\\n     */\\n    function numberOfAttemts(address user) public view returns (uint8) {\\n        return attemptsMapping[user];\\n    }\\n\\n    // PRIVATE\\n\\n    /**\\n     * Records the time spent for the current owner \\n     */\\n    function updateLastTimeSpent() private {\\n        address user = currentThroneOwner.user;\\n        if (user != address(0x0)) {\\n          uint256 timeTaken = currentThroneOwner.timestamp;\\n          timeSpentMapping[user] += uint32(block.timestamp - timeTaken);\\n        }\\n    }\\n\\n    function resetGameAndStartNextRound() private {\\n        uint32 participantSize = uint32(participants.length);\\n        for (uint32 i = 0; i < participantSize; i++) {\\n            address participant = participants[i];\\n            delete timeSpentMapping[participant]; // clear mapping entry\\n            delete attemptsMapping[participant];\\n        }\\n        delete participants; // clear all participants\\n        delete currentThroneOwner; // reset current owner\\n\\n        // prepare for new round\\n        round = round + 1;\\n        lastRoundStartTime = block.timestamp;\\n    }\\n\\n    // modifier to check if caller is owner\\n    modifier isOwner() {\\n        require(msg.sender == contractOwner, \\\"Caller is not owner\\\");\\n        _;\\n    }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"maxAttemptsPerPlayer\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"prevOwnerTimeSpent\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"ThroneTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalTimeSpent\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalPlayers\",\"type\":\"uint32\"}],\"name\":\"WinnerChosen\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"accumulatedTimeSpent\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"awardPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPrizePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRoundTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentThroneOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTimeSpent\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoundStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAttempts\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"numberOfAttemts\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeThrone\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"throneCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalTimeSpent\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EthroneContract","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000002386f26fc10000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}