{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SwitchSigner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport './modules/Initializable.sol';\\nimport './modules/Configable.sol';\\n\\ncontract SwitchSigner is Configable, Initializable{\\n    address[] public signWallets;\\n    mapping(address => uint) public signerStatus; // 1; on, 2: off\\n    bool public isMultSign;\\n    uint public minSigner;\\n\\n    event MinSignerChanged(address indexed user, uint minSigner);\\n    event SignerStatusChanged(address indexed user, address wallet, uint value);\\n\\n    function initialize() external initializer {\\n        owner = msg.sender;\\n        minSigner = 1;\\n    }\\n\\n    function setMultSign(bool _value) external onlyDev {\\n        isMultSign = _value;\\n    }\\n\\n    function setMinSigner(uint _minSigner) external onlyDev {\\n        require(_minSigner >0, 'SwitchSigner: MUST_BE_GREATE_ZERO');\\n        minSigner = _minSigner;\\n        emit MinSignerChanged(msg.sender, _minSigner);\\n    }\\n\\n    function setSigner(address _wallet, uint _value) external onlyDev {\\n        require(signerStatus[_wallet] != _value, 'SwitchSigner: NO_CHANGE');\\n        require(1 == _value || 2 == _value, 'SwitchSigner: INVALID_PARAM');\\n        if(signerStatus[_wallet] == 0) {\\n            signWallets.push(_wallet);\\n        }\\n        signerStatus[_wallet] = _value;\\n        emit SignerStatusChanged(msg.sender, _wallet, _value);\\n    }\\n\\n    function countSigner() external view returns (uint) {\\n        return signWallets.length;\\n    }\\n\\n    function checkUser(address _user) external view returns (bool) {\\n        return signerStatus[_user] != 1;\\n    }\\n\\n    function verify(uint _mode, address _user, address _signer, bytes32 _message, bytes memory _signature) public view returns (bool) {\\n        bytes32 hash = _toEthBytes32SignedMessageHash(_message);\\n        address[] memory signList = _recoverAddresses(hash, _signature);\\n        if(isMultSign) {\\n            require(signList[0] != _signer, 'SwitchSigner: MUST_BE_ANOTHER');\\n        }\\n        if(_mode == 1) {\\n            require(signList[0] != _user, 'SwitchSigner: MUST_BE_NOT_SELF');\\n        }\\n        return signerStatus[signList[0]] == 1;\\n    }\\n\\n    function mverify(uint _mode, address _user, address _signer, bytes32 _message, bytes[] memory _signatures) external view returns (bool) {\\n        require(minSigner >0, 'SwitchSigner: MINSIGER_MUST_BE_GREATE_ZERO');\\n        if(_signatures.length == 1 && minSigner == 1) {\\n            return verify(_mode, _user, _signer, _message, _signatures[0]);\\n        }\\n\\n        bytes32 hash = _toEthBytes32SignedMessageHash(_message);\\n        address[] memory signers = new address[](_signatures.length);\\n        for(uint i; i<_signatures.length; i++) {\\n            address[] memory signList = _recoverAddresses(hash, _signatures[i]);\\n            require(signerStatus[signList[0]] ==1, 'SwitchSigner: INVALID_SIGNATURE');   \\n            signers[i] = signList[0];\\n        }\\n\\n        uint passed;\\n        for(uint i; i<signers.length; i++) {\\n            require(_checkSigners(signers[i], signers), 'SwitchSigner: DUPLICATED_SIGNER');\\n            passed++;\\n        }\\n        \\n        if(passed >= minSigner) {\\n            return true;\\n        }\\n        return false;\\n    }\\n      \\n    function _checkSigners(address _signer, address[] memory signers) internal pure returns (bool) {\\n        uint count;\\n        for(uint i; i<signers.length; i++) {\\n            if(signers[i] == _signer) {\\n                count++;\\n            }\\n        }\\n        if(count == 1) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    function _toEthBytes32SignedMessageHash (bytes32 _msg) pure internal returns (bytes32 signHash) {\\n        signHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _msg));\\n    }\\n    \\n    function _recoverAddresses(bytes32 _hash, bytes memory _signatures) pure internal returns (address[] memory addresses) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint count = _countSignatures(_signatures);\\n        addresses = new address[](count);\\n        for (uint i = 0; i < count; i++) {\\n            (v, r, s) = _parseSignature(_signatures, i);\\n            addresses[i] = ecrecover(_hash, v, r, s);\\n        }\\n    }\\n    \\n    function _parseSignature(bytes memory _signatures, uint _pos) pure internal returns (uint8 v, bytes32 r, bytes32 s) {\\n        uint offset = _pos * 65;\\n        assembly {\\n            r := mload(add(_signatures, add(32, offset)))\\n            s := mload(add(_signatures, add(64, offset)))\\n            v := and(mload(add(_signatures, add(65, offset))), 0xff)\\n        }\\n\\n        if (v < 27) v += 27;\\n\\n        require(v == 27 || v == 28);\\n    }\\n    \\n    function _countSignatures(bytes memory _signatures) pure internal returns (uint) {\\n        return _signatures.length % 65 == 0 ? _signatures.length / 65 : 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Configable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6;\\n\\ninterface IConfig {\\n    function dev() external view returns (address);\\n    function admin() external view returns (address);\\n}\\n\\ncontract Configable {\\n    address public config;\\n    address public owner;\\n\\n    event ConfigChanged(address indexed _user, address indexed _old, address indexed _new);\\n    event OwnerChanged(address indexed _user, address indexed _old, address indexed _new);\\n \\n    function setupConfig(address _config) external onlyOwner {\\n        emit ConfigChanged(msg.sender, config, _config);\\n        config = _config;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'OWNER FORBIDDEN');\\n        _;\\n    }\\n\\n    function admin() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).admin();\\n        }\\n        return owner;\\n    }\\n\\n    function dev() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).dev();\\n        }\\n        return owner;\\n    }\\n\\n    function changeOwner(address _user) external onlyOwner {\\n        require(owner != _user, 'Owner: NO CHANGE');\\n        emit OwnerChanged(msg.sender, owner, _user);\\n        owner = _user;\\n    }\\n    \\n    modifier onlyDev() {\\n        require(msg.sender == dev() || msg.sender == owner, 'dev FORBIDDEN');\\n        _;\\n    }\\n    \\n    modifier onlyAdmin() {\\n        require(msg.sender == admin(), 'admin FORBIDDEN');\\n        _;\\n    }\\n  \\n    modifier onlyManager() {\\n        require(msg.sender == dev() || msg.sender == admin() || msg.sender == owner, 'manager FORBIDDEN');\\n        _;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSigner\",\"type\":\"uint256\"}],\"name\":\"MinSignerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SignerStatusChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countSigner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMultSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSigner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"}],\"name\":\"mverify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minSigner\",\"type\":\"uint256\"}],\"name\":\"setMinSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setMultSign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signerStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SwitchSigner","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}