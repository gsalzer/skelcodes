{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.4\r\n\"\"\"\r\n@title Token Distributor\r\n@author Lixir Finance\r\n@license MIT\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface VaultGauge:\r\n    # Presumably, other gauges will provide the same interfaces\r\n    def integrate_fraction(addr: address) -> uint256: view\r\n    def user_checkpoint(addr: address) -> bool: nonpayable\r\n\r\ninterface LixirRegistry:\r\n    def isGovOrDelegate(account: address) -> bool: view\r\n    def emergencyReturn() -> address: view\r\n\r\ninterface GaugeController:\r\n    def gauge_types(addr: address) -> int128: view\r\n\r\nevent UpdateMiningParameters:\r\n    time: uint256\r\n    rate: uint256\r\n    supply: uint256\r\n\r\nevent Distributed:\r\n    recipient: indexed(address)\r\n    gauge: address\r\n    distributed: uint256\r\n\r\n\r\n###### CRV20 vars\r\n# General constants\r\nYEAR: constant(uint256) = 86400 * 365\r\n\r\n\r\n# Supply parameters\r\nINITIAL_RATE: constant(uint256) = 759720 * 10 ** 18 / YEAR # .32LIX/block\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1153846153846153846 # 15/13 * 10 ** 18\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nDISTRIBUTION_DELAY: constant(uint256) = 86400\r\n\r\n# Supply variables\r\ninitial_supply: public(uint256)\r\nmining_epoch: public(int128)\r\nstart_epoch_time: public(uint256)\r\nrate: public(uint256)\r\n\r\nstart_epoch_supply: uint256\r\n##############\r\n\r\n# LIX\r\nlix: public(address)\r\ncontroller: public(address)\r\nregistry: public(address)\r\n\r\n# user -> gauge -> value\r\ndistributed: public(HashMap[address, HashMap[address, uint256]])\r\n\r\n@external\r\ndef __init__(_lix: address, _controller: address, _registry: address):\r\n    self.lix = _lix\r\n    self.controller = _controller\r\n    self.registry = _registry\r\n    self.start_epoch_time = block.timestamp + DISTRIBUTION_DELAY - RATE_REDUCTION_TIME\r\n    self.mining_epoch = -1\r\n    self.rate = 0\r\n    self.start_epoch_supply = 0 # _init_supply\r\n\r\n\r\n@internal\r\ndef _update_mining_parameters():\r\n    \"\"\"\r\n    @dev Update mining rate and supply at the start of the epoch\r\n         Any modifying mining call must also call this\r\n         Called whenever the previous epoch has concluded\r\n    \"\"\"\r\n    _rate: uint256 = self.rate\r\n    _start_epoch_supply: uint256 = self.start_epoch_supply\r\n\r\n    self.start_epoch_time += RATE_REDUCTION_TIME\r\n    self.mining_epoch += 1\r\n\r\n    if _rate == 0:\r\n        _rate = INITIAL_RATE\r\n    else:\r\n        _start_epoch_supply += _rate * RATE_REDUCTION_TIME\r\n        self.start_epoch_supply = _start_epoch_supply\r\n        _rate = _rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n\r\n    self.rate = _rate\r\n\r\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\r\n\r\n\r\n@internal\r\n@view\r\ndef _available_to_distribute() -> uint256:\r\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\r\n\r\n\r\n@external\r\n@view\r\ndef available_to_distribute() -> uint256:\r\n    \"\"\"\r\n    @notice Current number of tokens distributed by this contract (claimed or unclaimed)\r\n    \"\"\"\r\n    return self._available_to_distribute()\r\n\r\n\r\n@external\r\ndef update_mining_parameters():\r\n    \"\"\"\r\n    @notice Update mining rate and supply at the start of the epoch\r\n    @dev Callable by any address, but only once per epoch\r\n         Total supply becomes slightly larger if this function is called late\r\n    \"\"\"\r\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\r\n    self._update_mining_parameters()\r\n\r\n\r\n@external\r\ndef start_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the current mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time\r\n    else:\r\n        return _start_epoch_time\r\n\r\n\r\n@external\r\ndef future_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the next mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the next epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time + RATE_REDUCTION_TIME\r\n    else:\r\n        return _start_epoch_time + RATE_REDUCTION_TIME\r\n\r\n\r\n@external\r\n@view\r\ndef distributable_in_timeframe(start: uint256, end: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice How much supply is mintable from start timestamp till end timestamp\r\n    @param start Start of the time interval (timestamp)\r\n    @param end End of the time interval (timestamp)\r\n    @return Tokens mintable from `start` till `end`\r\n    \"\"\"\r\n    assert start <= end  # dev: start > end\r\n    to_mint: uint256 = 0\r\n    current_epoch_time: uint256 = self.start_epoch_time\r\n    current_rate: uint256 = self.rate\r\n\r\n    # Special case if end is in future (not yet minted) epoch\r\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\r\n        current_epoch_time += RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n\r\n    assert end <= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\r\n\r\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\r\n        if end >= current_epoch_time:\r\n            current_end: uint256 = end\r\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\r\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\r\n\r\n            current_start: uint256 = start\r\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\r\n                break  # We should never get here but what if...\r\n            elif current_start < current_epoch_time:\r\n                current_start = current_epoch_time\r\n\r\n            to_mint += current_rate * (current_end - current_start)\r\n\r\n            if start >= current_epoch_time:\r\n                break\r\n\r\n        current_epoch_time -= RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\r\n        assert current_rate <= INITIAL_RATE  # This should never happen\r\n\r\n    return to_mint\r\n\r\n\r\n@internal\r\ndef _distribute_for(gauge_addr: address, _for: address):\r\n    assert GaugeController(self.controller).gauge_types(gauge_addr) >= 0  # dev: gauge is not added\r\n    assert _for != ZERO_ADDRESS  # dev: zero address\r\n\r\n    VaultGauge(gauge_addr).user_checkpoint(_for)\r\n    total_dist: uint256 = VaultGauge(gauge_addr).integrate_fraction(_for) # TODO: write some tests to make sure the gauges are doing the correct thing here\r\n    to_dist: uint256 = total_dist - self.distributed[_for][gauge_addr]\r\n\r\n    if to_dist != 0:\r\n        if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\r\n            self._update_mining_parameters()\r\n        ERC20(self.lix).transfer(_for, to_dist)\r\n        self.distributed[_for][gauge_addr] = total_dist\r\n\r\n        log Distributed(_for, gauge_addr, total_dist)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef distribute(gauge_addr: address):\r\n    \"\"\"\r\n    @notice Distribute everything which belongs to `msg.sender` and send to them\r\n    @param gauge_addr `VaultGauge` address to get mintable amount from\r\n    \"\"\"\r\n    self._distribute_for(gauge_addr, msg.sender)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef dist_many(gauge_addrs: address[8]):\r\n    \"\"\"\r\n    @notice Distribute everything which belongs to `msg.sender` across multiple gauges\r\n    @param gauge_addrs List of `VaultGauge` addresses\r\n    \"\"\"\r\n    for i in range(8):\r\n        if gauge_addrs[i] == ZERO_ADDRESS:\r\n            break\r\n        self._distribute_for(gauge_addrs[i], msg.sender)\r\n\r\n\r\n@external\r\ndef recover_balance(_coin: address) -> bool:\r\n    \"\"\"\r\n    @notice Recover ERC20 tokens from this contract\r\n    @dev Tokens are sent to the emergency return address.\r\n    @param _coin Token address\r\n    @return bool success\r\n    \"\"\"\r\n    assert LixirRegistry(self.registry).isGovOrDelegate(msg.sender)\r\n    emergency_return: address = LixirRegistry(self.registry).emergencyReturn()\r\n    assert emergency_return != ZERO_ADDRESS\r\n\r\n    amount: uint256 = ERC20(_coin).balanceOf(self)\r\n    response: Bytes[32] = raw_call(\r\n        _coin,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(emergency_return, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    return True","ABI":"[{\"name\":\"UpdateMiningParameters\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"time\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"rate\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"supply\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Distributed\",\"inputs\":[{\"type\":\"address\",\"name\":\"recipient\",\"indexed\":true},{\"type\":\"address\",\"name\":\"gauge\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"distributed\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_lix\"},{\"type\":\"address\",\"name\":\"_controller\"},{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"available_to_distribute\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3838},{\"name\":\"update_mining_parameters\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":148808},{\"name\":\"start_epoch_time_write\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":149663},{\"name\":\"future_epoch_time_write\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":149866},{\"name\":\"distributable_in_timeframe\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"start\"},{\"type\":\"uint256\",\"name\":\"end\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2216141},{\"name\":\"distribute\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"gauge_addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":396420},{\"name\":\"dist_many\",\"outputs\":[],\"inputs\":[{\"type\":\"address[8]\",\"name\":\"gauge_addrs\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":2778088},{\"name\":\"recover_balance\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_coin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":7543},{\"name\":\"initial_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1481},{\"name\":\"mining_epoch\",\"outputs\":[{\"type\":\"int128\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1511},{\"name\":\"start_epoch_time\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1541},{\"name\":\"rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1571},{\"name\":\"lix\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1601},{\"name\":\"controller\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1631},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1661},{\"name\":\"distributed\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1999}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000d0345d30fd918d7682398acbcdf139c8089987090000000000000000000000005352efb4bccec5dfbe122864af94c282ea56696400000000000000000000000018bf8a3ee39be5730189a0c88d90f744e3c55b20","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}