{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/periphery/QueryHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Types.sol\\\";\\nimport \\\"../lib/DexData.sol\\\";\\n\\n\\ncontract QueryHelper {\\n    using DexData for bytes;\\n    using SafeMath for uint;\\n\\n    constructor ()\\n    {\\n\\n    }\\n    struct PositionVars {\\n        uint deposited;\\n        uint held;\\n        uint borrowed;\\n        uint marginRatio;\\n        uint32 marginLimit;\\n    }\\n    enum LiqStatus{\\n        HEALTHY, // Do nothing\\n        UPDATE, // Need update price\\n        WAITING, // Waiting\\n        LIQ, // Can liquidate\\n        NOP// No position\\n    }\\n\\n    struct LiqVars {\\n        LiqStatus status;\\n        uint lastUpdateTime;\\n        uint currentMarginRatio;\\n        uint cAvgMarginRatio;\\n        uint hAvgMarginRatio;\\n        uint32 marginLimit;\\n    }\\n\\n    struct PoolVars {\\n        uint totalBorrows;\\n        uint cash;\\n        uint totalReserves;\\n        uint availableForBorrow;\\n        uint insurance;\\n        uint supplyRatePerBlock;\\n        uint borrowRatePerBlock;\\n        uint reserveFactorMantissa;\\n        uint exchangeRate;\\n        uint baseRatePerBlock;\\n        uint multiplierPerBlock;\\n        uint jumpMultiplierPerBlock;\\n        uint kink;\\n    }\\n\\n    struct XOLEVars {\\n        uint totalStaked;\\n        uint totalShared;\\n        uint tranferedToAccount;\\n        uint devFund;\\n        uint balanceOf;\\n    }\\n\\n    function getTraderPositons(IOpenLev openLev, uint16 marketId, address[] calldata traders, bool[] calldata longTokens, bytes calldata dexData) external view returns (PositionVars[] memory results){\\n        results = new PositionVars[](traders.length);\\n        IOpenLev.MarketVar memory market = openLev.markets(marketId);\\n        for (uint i = 0; i < traders.length; i++) {\\n            PositionVars memory item;\\n            Types.Trade memory trade = openLev.activeTrades(traders[i], marketId, longTokens[i]);\\n            if (trade.held == 0) {\\n                results[i] = item;\\n                continue;\\n            }\\n            item.held = trade.held;\\n            item.deposited = trade.deposited;\\n            (item.marginRatio,,,item.marginLimit) = openLev.marginRatio(traders[i], marketId, longTokens[i], dexData);\\n            item.borrowed = longTokens[i] ? market.pool0.borrowBalanceCurrent(traders[i]) : market.pool1.borrowBalanceCurrent(traders[i]);\\n            results[i] = item;\\n        }\\n        return results;\\n    }\\n\\n    struct LiqReqVars {\\n        IOpenLev openLev;\\n        address owner;\\n        uint16 marketId;\\n        bool longToken;\\n        uint256 token0price;\\n        uint256 token0cAvgPrice;\\n        uint256 token1price;\\n        uint256 token1cAvgPrice;\\n        uint256 timestamp;\\n        bytes dexData;\\n    }\\n    //offchain call\\n    function getTraderLiqs(IOpenLev openLev, uint16 marketId, address[] calldata traders, bool[] calldata longTokens, bytes calldata dexData) external returns (LiqVars[] memory results){\\n        results = new LiqVars[](traders.length);\\n        LiqReqVars memory reqVar;\\n        reqVar.openLev = openLev;\\n        reqVar.marketId = marketId;\\n        reqVar.dexData = dexData;\\n        IOpenLev.MarketVar memory market = reqVar.openLev.markets(reqVar.marketId);\\n        IOpenLev.AddressConfig memory adrConf = reqVar.openLev.addressConfig();\\n        IOpenLev.CalculateConfig memory calConf = reqVar.openLev.getCalculateConfig();\\n        (,,,, reqVar.timestamp) = adrConf.dexAggregator.getPriceCAvgPriceHAvgPrice(market.token0, market.token1, calConf.twapDuration, reqVar.dexData);\\n        openLev.updatePrice(marketId, dexData);\\n        (reqVar.token0price, reqVar.token0cAvgPrice,,,) = adrConf.dexAggregator.getPriceCAvgPriceHAvgPrice(market.token0, market.token1, calConf.twapDuration, reqVar.dexData);\\n        (reqVar.token1price, reqVar.token1cAvgPrice,,,) = adrConf.dexAggregator.getPriceCAvgPriceHAvgPrice(market.token1, market.token0, calConf.twapDuration, reqVar.dexData);\\n\\n        for (uint i = 0; i < traders.length; i++) {\\n            reqVar.owner = traders[i];\\n            reqVar.longToken = longTokens[i];\\n            LiqVars memory item;\\n            Types.Trade memory trade = reqVar.openLev.activeTrades(reqVar.owner, reqVar.marketId, reqVar.longToken);\\n            if (trade.held == 0) {\\n                item.status = LiqStatus.NOP;\\n                results[i] = item;\\n                continue;\\n            }\\n            item.lastUpdateTime = reqVar.timestamp;\\n            (item.currentMarginRatio, item.cAvgMarginRatio, item.hAvgMarginRatio, item.marginLimit) = reqVar.openLev.marginRatio(reqVar.owner, reqVar.marketId, reqVar.longToken, reqVar.dexData);\\n            if (item.currentMarginRatio > item.marginLimit && item.cAvgMarginRatio > item.marginLimit && item.hAvgMarginRatio > item.marginLimit) {\\n                item.status = LiqStatus.HEALTHY;\\n            }\\n            else if (item.currentMarginRatio < item.marginLimit && item.cAvgMarginRatio > item.marginLimit && item.hAvgMarginRatio > item.marginLimit) {\\n                if (dexData.isUniV2Class()) {\\n                    if (block.timestamp - calConf.twapDuration > item.lastUpdateTime) {\\n                        item.status = LiqStatus.UPDATE;\\n                    } else {\\n                        item.status = LiqStatus.WAITING;\\n                    }\\n                } else {\\n                    item.status = LiqStatus.WAITING;\\n                }\\n            } else if (item.currentMarginRatio < item.marginLimit && item.cAvgMarginRatio < item.marginLimit) {\\n                //Liq\\n                if (block.timestamp - calConf.twapDuration > item.lastUpdateTime || item.hAvgMarginRatio < item.marginLimit) {\\n                    // cAvgRatio diff currentRatio >+-5% ,waiting\\n                    if ((longTokens[i] == false && reqVar.token0cAvgPrice > reqVar.token0price && reqVar.token0cAvgPrice.mul(100).div(reqVar.token0price) - 100 >= calConf.maxLiquidationPriceDiffientRatio)\\n                        || (longTokens[i] == true && reqVar.token1cAvgPrice > reqVar.token1price && reqVar.token1cAvgPrice.mul(100).div(reqVar.token1price) - 100 >= calConf.maxLiquidationPriceDiffientRatio)) {\\n                        if (dexData.isUniV2Class()) {\\n                            item.status = LiqStatus.UPDATE;\\n                        } else {\\n                            item.status = LiqStatus.WAITING;\\n                        }\\n                    } else {\\n                        item.status = LiqStatus.LIQ;\\n                    }\\n                } else {\\n                    item.status = LiqStatus.WAITING;\\n                }\\n            }\\n            results[i] = item;\\n        }\\n        return results;\\n    }\\n    // offchain call\\n    function calPriceCAvgPriceHAvgPrice(IOpenLev openLev, uint16 marketId, address desToken, address quoteToken, uint32 secondsAgo, bytes memory dexData) external\\n    returns (uint price, uint cAvgPrice, uint256 hAvgPrice, uint8 decimals, uint256 timestamp){\\n        IOpenLev.AddressConfig memory adrConf = openLev.addressConfig();\\n        (,,,, timestamp) = adrConf.dexAggregator.getPriceCAvgPriceHAvgPrice(desToken, quoteToken, secondsAgo, dexData);\\n        openLev.updatePrice(marketId, dexData);\\n        (price, cAvgPrice, hAvgPrice, decimals,) = adrConf.dexAggregator.getPriceCAvgPriceHAvgPrice(desToken, quoteToken, secondsAgo, dexData);\\n    }\\n\\n    struct LiqCallVars {\\n        uint defaultFees;\\n        uint newFees;\\n        uint penalty;\\n        uint heldAfterFees;\\n        uint borrows;\\n        uint currentBuyAmount;\\n        uint currentSellAmount;\\n        bool canRepayBorrows;\\n    }\\n    //offchain call slippage 10%=>100\\n    function getLiqCallData(IOpenLev openLev, IV3Quoter v3Quoter, uint16 marketId, uint16 slippage, address trader, bool longToken, bytes memory dexData) external returns (uint minOrMaxAmount,\\n        bytes memory callDexData)\\n    {\\n        IOpenLev.MarketVar memory market = openLev.markets(marketId);\\n        Types.Trade memory trade = openLev.activeTrades(trader, marketId, longToken);\\n        LiqCallVars memory callVars;\\n        // cal remain held after fees and penalty\\n        callVars.defaultFees = trade.held.mul(market.feesRate).div(10000);\\n        callVars.newFees = callVars.defaultFees;\\n        IOpenLev.AddressConfig memory adrConf = openLev.addressConfig();\\n        IOpenLev.CalculateConfig memory calConf = openLev.getCalculateConfig();\\n        // if trader holds more xOLE, then should enjoy trading discount.\\n        if (IXOLE(adrConf.xOLE).balanceOf(trader) > calConf.feesDiscountThreshold) {\\n            callVars.newFees = callVars.defaultFees.sub(callVars.defaultFees.mul(calConf.feesDiscount).div(100));\\n        }\\n        // if trader update price, then should enjoy trading discount.\\n        if (market.priceUpdater == trader) {\\n            callVars.newFees = callVars.newFees.sub(callVars.defaultFees.mul(calConf.updatePriceDiscount).div(100));\\n        }\\n        callVars.penalty = trade.held.mul(calConf.penaltyRatio).div(10000);\\n        callVars.heldAfterFees = trade.held.sub(callVars.penalty).sub(callVars.newFees);\\n        callVars.borrows = longToken ? market.pool0.borrowBalanceCurrent(trader) : market.pool1.borrowBalanceCurrent(trader);\\n\\n        callVars.currentBuyAmount = dexData.isUniV2Class() ?\\n        adrConf.dexAggregator.calBuyAmount(longToken ?\\n            market.token0 : market.token1, longToken ? market.token1 : market.token0, callVars.heldAfterFees, dexData) :\\n        v3Quoter.quoteExactInputSingle(longToken ? market.token1 : market.token0, longToken ? market.token0 : market.token1, dexData.toFee(), callVars.heldAfterFees, 0);\\n        callVars.canRepayBorrows = callVars.currentBuyAmount >= callVars.borrows;\\n        //flash sell,cal minBuyAmount\\n        if (trade.depositToken != longToken || !callVars.canRepayBorrows) {\\n            minOrMaxAmount = callVars.currentBuyAmount.sub(callVars.currentBuyAmount.mul(slippage).div(1000));\\n            callDexData = dexData.isUniV2Class() ? dexData : abi.encodePacked(dexData, hex\\\"01\\\");\\n        }\\n        // flash buy,cal maxSellAmount\\n        else {\\n            callVars.currentSellAmount = dexData.isUniV2Class() ?\\n            adrConf.dexAggregator.calSellAmount(longToken ?\\n                market.token0 : market.token1, longToken ? market.token1 : market.token0, callVars.borrows, dexData) :\\n            v3Quoter.quoteExactOutputSingle(longToken ? market.token1 : market.token0, longToken ? market.token0 : market.token1, dexData.toFee(), callVars.borrows, 0);\\n            minOrMaxAmount = callVars.currentSellAmount.add(callVars.currentSellAmount.mul(slippage).div(1000));\\n            callDexData = dexData.isUniV2Class() ? dexData : abi.encodePacked(dexData, hex\\\"00\\\");\\n        }\\n    }\\n\\n    function getPoolDetails(IOpenLev openLev, uint16[] calldata marketIds, LPoolInterface[] calldata pools) external view returns (PoolVars[] memory results){\\n        results = new PoolVars[](pools.length);\\n        for (uint i = 0; i < pools.length; i++) {\\n            LPoolInterface pool = pools[i];\\n            IOpenLev.MarketVar memory market = openLev.markets(marketIds[i]);\\n            PoolVars memory item;\\n            item.insurance = address(market.pool0) == address(pool) ? market.pool0Insurance : market.pool1Insurance;\\n            item.cash = pool.getCash();\\n            item.totalBorrows = pool.totalBorrowsCurrent();\\n            item.totalReserves = pool.totalReserves();\\n            item.availableForBorrow = pool.availableForBorrow();\\n            item.supplyRatePerBlock = pool.supplyRatePerBlock();\\n            item.borrowRatePerBlock = pool.borrowRatePerBlock();\\n            item.reserveFactorMantissa = pool.reserveFactorMantissa();\\n            item.exchangeRate = pool.exchangeRateStored();\\n            item.baseRatePerBlock = pool.baseRatePerBlock();\\n            item.multiplierPerBlock = pool.multiplierPerBlock();\\n            item.jumpMultiplierPerBlock = pool.jumpMultiplierPerBlock();\\n            item.kink = pool.kink();\\n            results[i] = item;\\n        }\\n        return results;\\n    }\\n\\n    function getXOLEDetail(IXOLE xole, IERC20 balanceOfToken) external view returns (XOLEVars memory vars){\\n        vars.totalStaked = xole.totalLocked();\\n        vars.totalShared = xole.totalRewarded();\\n        vars.tranferedToAccount = xole.withdrewReward();\\n        vars.devFund = xole.devFund();\\n        if (address(0) != address(balanceOfToken)) {\\n            vars.balanceOf = balanceOfToken.balanceOf(address(xole));\\n        }\\n    }\\n}\\n\\ninterface IXOLE {\\n    function totalLocked() external view returns (uint256);\\n\\n    function totalRewarded() external view returns (uint256);\\n\\n    function withdrewReward() external view returns (uint256);\\n\\n    function devFund() external view returns (uint256);\\n\\n    function balanceOf(address addr) external view returns (uint256);\\n\\n\\n}\\n\\ninterface DexAggregatorInterface {\\n    function calBuyAmount(address buyToken, address sellToken, uint sellAmount, bytes memory data) external view returns (uint);\\n\\n    function calSellAmount(address buyToken, address sellToken, uint buyAmount, bytes memory data) external view returns (uint);\\n\\n    function getPriceCAvgPriceHAvgPrice(address desToken, address quoteToken, uint32 secondsAgo, bytes memory dexData) external view returns (uint price, uint cAvgPrice, uint256 hAvgPrice, uint8 decimals, uint256 timestamp);\\n\\n}\\n\\ninterface IV3Quoter {\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\\ninterface IOpenLev {\\n    struct MarketVar {// Market info\\n        LPoolInterface pool0;       // Lending Pool 0\\n        LPoolInterface pool1;       // Lending Pool 1\\n        address token0;              // Lending Token 0\\n        address token1;              // Lending Token 1\\n        uint16 marginLimit;         // Margin ratio limit for specific trading pair. Two decimal in percentage, ex. 15.32% => 1532\\n        uint16 feesRate;            // feesRate 30=>0.3%\\n        uint16 priceDiffientRatio;\\n        address priceUpdater;\\n        uint pool0Insurance;        // Insurance balance for token 0\\n        uint pool1Insurance;        // Insurance balance for token 1\\n    }\\n\\n    struct AddressConfig {\\n        DexAggregatorInterface dexAggregator;\\n        address controller;\\n        address wETH;\\n        address xOLE;\\n    }\\n\\n    struct CalculateConfig {\\n        uint16 defaultFeesRate; // 30 =>0.003\\n        uint8 insuranceRatio; // 33=>33%\\n        uint16 defaultMarginLimit; // 3000=>30%\\n        uint16 priceDiffientRatio; //10=>10%\\n        uint16 updatePriceDiscount;//25=>25%\\n        uint16 feesDiscount; // 25=>25%\\n        uint128 feesDiscountThreshold; //  30 * (10 ** 18) minimal holding of xOLE to enjoy fees discount\\n        uint16 penaltyRatio;//100=>1%\\n        uint8 maxLiquidationPriceDiffientRatio;//30=>30%\\n        uint16 twapDuration;//28=>28s\\n    }\\n\\n    function activeTrades(address owner, uint16 marketId, bool longToken) external view returns (Types.Trade memory);\\n\\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external view returns (uint current, uint cAvg, uint hAvg, uint32 limit);\\n\\n    function markets(uint16 marketId) external view returns (MarketVar memory);\\n\\n    function getMarketSupportDexs(uint16 marketId) external view returns (uint32[] memory);\\n\\n    function addressConfig() external view returns (AddressConfig memory);\\n\\n    function getCalculateConfig() external view returns (CalculateConfig memory);\\n\\n    function updatePrice(uint16 marketId, bytes memory dexData) external;\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/liquidity/LPoolInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\n\\nabstract contract LPoolStorage {\\n\\n    //Guard variable for re-entrancy checks\\n    bool internal _notEntered;\\n\\n    /**\\n     * EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n    * Total number of tokens in circulation\\n    */\\n    uint public totalSupply;\\n\\n\\n    //Official record of token balances for each account\\n    mapping(address => uint) internal accountTokens;\\n\\n    //Approved token transfer amounts on behalf of others\\n    mapping(address => mapping(address => uint)) internal transferAllowances;\\n\\n\\n    //Maximum borrow rate that can ever be applied (.0005% / block)\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n    /**\\n    * Maximum fraction of borrower cap(80%)\\n    */\\n    uint public  borrowCapFactorMantissa;\\n    /**\\n     * Contract which oversees inter-lToken operations\\n     */\\n    address public controller;\\n\\n\\n    // Initial exchange rate used when minting the first lTokens (used when totalSupply = 0)\\n    uint internal initialExchangeRateMantissa;\\n\\n    /**\\n     * Block number that interest was last accrued at\\n     */\\n    uint public accrualBlockNumber;\\n\\n    /**\\n     * Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint public borrowIndex;\\n\\n    /**\\n     * Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint public totalBorrows;\\n\\n    uint internal totalCash;\\n\\n    /**\\n    * @notice Fraction of interest currently set aside for reserves 20%\\n    */\\n    uint public reserveFactorMantissa;\\n\\n    uint public totalReserves;\\n\\n    address public underlying;\\n\\n    bool public isWethPool;\\n\\n    /**\\n     * Container for borrow balance information\\n     * principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint principal;\\n        uint interestIndex;\\n    }\\n\\n    uint256 public baseRatePerBlock;\\n    uint256 public multiplierPerBlock;\\n    uint256 public jumpMultiplierPerBlock;\\n    uint256 public kink;\\n\\n    // Mapping of account addresses to outstanding borrow balances\\n\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n\\n\\n\\n    /*** Token Events ***/\\n\\n    /**\\n    * Event emitted when tokens are minted\\n    */\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n    /**\\n     * EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\n    /**\\n     * Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n    /**\\n     * Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address borrower, address payee, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint badDebtsAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * Event emitted when controller is changed\\n     */\\n    event NewController(address oldController, address newController);\\n\\n    /**\\n     * Event emitted when interestParam is changed\\n     */\\n    event NewInterestParam(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\\n\\n    /**\\n    * @notice Event emitted when the reserve factor is changed\\n    */\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address to, uint reduceAmount, uint newTotalReserves);\\n\\n    event NewBorrowCapFactorMantissa(uint oldBorrowCapFactorMantissa, uint newBorrowCapFactorMantissa);\\n\\n}\\n\\nabstract contract LPoolInterface is LPoolStorage {\\n\\n\\n    /*** User Interface ***/\\n\\n    function transfer(address dst, uint amount) external virtual returns (bool);\\n\\n    function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\\n\\n    function approve(address spender, uint amount) external virtual returns (bool);\\n\\n    function allowance(address owner, address spender) external virtual view returns (uint);\\n\\n    function balanceOf(address owner) external virtual view returns (uint);\\n\\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\\n\\n    /*** Lender & Borrower Functions ***/\\n\\n    function mint(uint mintAmount) external virtual;\\n\\n    function mintTo(address to) external payable virtual;\\n\\n    function mintEth() external payable virtual;\\n\\n    function redeem(uint redeemTokens) external virtual;\\n\\n    function redeemUnderlying(uint redeemAmount) external virtual;\\n\\n    function borrowBehalf(address borrower, uint borrowAmount) external virtual;\\n\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external virtual;\\n\\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external virtual;\\n\\n    function availableForBorrow() external view virtual returns (uint);\\n\\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint);\\n\\n    function borrowRatePerBlock() external virtual view returns (uint);\\n\\n    function supplyRatePerBlock() external virtual view returns (uint);\\n\\n    function totalBorrowsCurrent() external virtual view returns (uint);\\n\\n    function borrowBalanceCurrent(address account) external virtual view returns (uint);\\n\\n    function borrowBalanceStored(address account) external virtual view returns (uint);\\n\\n    function exchangeRateCurrent() public virtual returns (uint);\\n\\n    function exchangeRateStored() public virtual view returns (uint);\\n\\n    function getCash() external view virtual returns (uint);\\n\\n    function accrueInterest() public virtual;\\n\\n    function sync() public virtual;\\n\\n    /*** Admin Functions ***/\\n\\n    function setController(address newController) external virtual;\\n\\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external virtual;\\n\\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external virtual;\\n\\n    function setReserveFactor(uint newReserveFactorMantissa) external virtual;\\n\\n    function addReserves(uint addAmount) external virtual;\\n\\n    function reduceReserves(address payable to, uint reduceAmount) external virtual;\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/DexData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nlibrary DexData {\\n    uint256 private constant ADDR_SIZE = 20;\\n    uint256 private constant FEE_SIZE = 3;\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n\\n    uint constant dexNameStart = 0;\\n    uint constant dexNameLength = 1;\\n    uint constant feeStart = 1;\\n    uint constant feeLength = 3;\\n    uint constant uniV3QuoteFlagStart = 4;\\n    uint constant uniV3QuoteFlagLength = 1;\\n\\n    uint8 constant DEX_UNIV2 = 1;\\n    uint8 constant DEX_UNIV3 = 2;\\n    uint8 constant DEX_PANCAKE = 3;\\n    uint8 constant DEX_SUSHI = 4;\\n    uint8 constant DEX_MDEX = 5;\\n    uint8 constant DEX_TRADERJOE = 6;\\n    uint8 constant DEX_SPOOKY = 7;\\n    uint8 constant DEX_QUICK = 8;\\n    uint8 constant DEX_SHIBA = 9;\\n    uint8 constant DEX_APE = 10;\\n\\n    bytes constant UNIV2 = hex\\\"01\\\";\\n\\n    struct V3PoolData {\\n        address tokenA;\\n        address tokenB;\\n        uint24 fee;\\n    }\\n\\n    function toDex(bytes memory data) internal pure returns (uint8) {\\n        require(data.length >= dexNameLength, 'dex error');\\n        uint8 temp;\\n        assembly {\\n            temp := byte(0, mload(add(data, add(0x20, dexNameStart))))\\n        }\\n        return temp;\\n    }\\n\\n    function toFee(bytes memory data) internal pure returns (uint24) {\\n        require(data.length >= dexNameLength + feeLength, 'fee error');\\n        uint temp;\\n        assembly {\\n            temp := mload(add(data, add(0x20, feeStart)))\\n        }\\n        return uint24(temp >> (256 - (feeLength * 8)));\\n    }\\n\\n    function toDexDetail(bytes memory data) internal pure returns (uint32) {\\n        if (data.length == dexNameLength) {\\n            uint8 temp;\\n            assembly {\\n                temp := byte(0, mload(add(data, add(0x20, dexNameStart))))\\n            }\\n            return uint32(temp);\\n        } else {\\n            uint temp;\\n            assembly {\\n                temp := mload(add(data, add(0x20, dexNameStart)))\\n            }\\n            return uint32(temp >> (256 - ((feeLength + dexNameLength) * 8)));\\n        }\\n    }\\n    // true ,sell all\\n    function toUniV3QuoteFlag(bytes memory data) internal pure returns (bool) {\\n        require(data.length >= dexNameLength + feeLength + uniV3QuoteFlagLength, 'v3flag error');\\n        uint8 temp;\\n        assembly {\\n            temp := byte(0, mload(add(data, add(0x20, uniV3QuoteFlagStart))))\\n        }\\n        return temp > 0;\\n    }\\n\\n    // univ2 class\\n    function isUniV2Class(bytes memory data) internal pure returns (bool) {\\n        return (data.length - dexNameLength) % 20 == 0;\\n    }\\n    // v2 path\\n    function toUniV2Path(bytes memory data) internal pure returns (address[] memory path) {\\n        data = slice(data, dexNameLength, data.length - dexNameLength);\\n        uint pathLength = data.length / 20;\\n        path = new address[](pathLength);\\n        for (uint i = 0; i < pathLength; i++) {\\n            path[i] = toAddress(data, 20 * i);\\n        }\\n    }\\n\\n    // v3 path\\n    function toUniV3Path(bytes memory data) internal pure returns (V3PoolData[] memory path) {\\n        data = slice(data, uniV3QuoteFlagStart + uniV3QuoteFlagLength, data.length - (uniV3QuoteFlagStart + uniV3QuoteFlagLength));\\n        uint pathLength = numPools(data);\\n        path = new V3PoolData[](pathLength);\\n        for (uint i = 0; i < pathLength; i++) {\\n            V3PoolData memory pool;\\n            if (i != 0) {\\n                data = slice(data, NEXT_OFFSET, data.length - NEXT_OFFSET);\\n            }\\n            pool.tokenA = toAddress(data, 0);\\n            pool.fee = toUint24(data, ADDR_SIZE);\\n            pool.tokenB = toAddress(data, NEXT_OFFSET);\\n            path[i] = pool;\\n        }\\n    }\\n\\n    function numPools(bytes memory path) internal pure returns (uint256) {\\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, 'toUint24_overflow');\\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\\n        uint24 tempUint;\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n        return tempUint;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, 'toAddress_overflow');\\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\\n        address tempAddress;\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n        return tempAddress;\\n    }\\n\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, 'slice_overflow');\\n        require(_start + _length >= _start, 'slice_overflow');\\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n            // The first word of the slice result is potentially a partial\\n            // word read from the original array. To read it, we calculate\\n            // the length of that partial word and start copying that many\\n            // bytes into the array. The first word we copy will start with\\n            // data we don't care about, but the last `lengthmod` bytes will\\n            // land at the beginning of the contents of the new array. When\\n            // we're done copying, we overwrite the full first word with\\n            // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n            // The multiplication in the next line is necessary\\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\\n            // the following copy loop was copying the origin's length\\n            // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                // The multiplication in the next line has the same exact purpose\\n                // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n            //update free-memory pointer\\n            //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n            //zero out the 32 bytes slice we are about to return\\n            //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\n\\nimport \\\"./liquidity/LPoolInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n\\nlibrary Types {\\n    using SafeERC20 for IERC20;\\n\\n    struct Market {// Market info\\n        LPoolInterface pool0;       // Lending Pool 0\\n        LPoolInterface pool1;       // Lending Pool 1\\n        address token0;              // Lending Token 0\\n        address token1;              // Lending Token 1\\n        uint16 marginLimit;         // Margin ratio limit for specific trading pair. Two decimal in percentage, ex. 15.32% => 1532\\n        uint16 feesRate;            // feesRate 30=>0.3%\\n        uint16 priceDiffientRatio;\\n        address priceUpdater;\\n        uint pool0Insurance;        // Insurance balance for token 0\\n        uint pool1Insurance;        // Insurance balance for token 1\\n        uint32[] dexs;\\n    }\\n\\n    struct Trade {// Trade storage\\n        uint deposited;             // Balance of deposit token\\n        uint held;                  // Balance of held position\\n        bool depositToken;          // Indicate if the deposit token is token 0 or token 1\\n        uint128 lastBlockNum;       // Block number when the trade was touched last time, to prevent more than one operation within same block\\n    }\\n\\n    struct MarketVars {// A variables holder for market info\\n        LPoolInterface buyPool;     // Lending pool address of the token to buy. It's a calculated field on open or close trade.\\n        LPoolInterface sellPool;    // Lending pool address of the token to sell. It's a calculated field on open or close trade.\\n        IERC20 buyToken;            // Token to buy\\n        IERC20 sellToken;           // Token to sell\\n        uint buyPoolInsurance;      // Insurance balance of token to buy\\n        uint sellPoolInsurance;     // Insurance balance of token to sell\\n        uint16 marginLimit;         // Margin Ratio Limit for specific trading pair.\\n        uint16 priceDiffientRatio;\\n        uint32[] dexs;\\n    }\\n\\n    struct TradeVars {// A variables holder for trade info\\n        uint depositValue;          // Deposit value\\n        IERC20 depositErc20;        // Deposit Token address\\n        uint fees;                  // Fees value\\n        uint depositAfterFees;      // Deposit minus fees\\n        uint tradeSize;             // Trade amount to be swap on DEX\\n        uint newHeld;               // Latest held position\\n        uint borrowValue;\\n        uint token0Price;\\n        uint32 dexDetail;\\n    }\\n\\n    struct CloseTradeVars {// A variables holder for close trade info\\n        uint16 marketId;\\n        bool longToken;\\n        bool depositToken;\\n        uint closeRatio;          // Close ratio\\n        bool isPartialClose;        // Is partial close\\n        uint closeAmountAfterFees;  // Close amount sub Fees value\\n        uint repayAmount;           // Repay to pool value\\n        uint depositDecrease;       // Deposit decrease\\n        uint depositReturn;         // Deposit actual returns\\n        uint sellAmount;\\n        uint receiveAmount;\\n        uint token0Price;\\n        uint fees;                  // Fees value\\n        uint32 dexDetail;\\n    }\\n\\n\\n    struct LiquidateVars {// A variable holder for liquidation process\\n        uint16 marketId;\\n        bool longToken;\\n        uint borrowed;              // Total borrowed balance of trade\\n        uint fees;                  // Fees for liquidation process\\n        uint penalty;               // Penalty\\n        uint remainHeldAfterFees;   // Held-fees-penalty\\n        bool isSellAllHeld;         // Is need sell all held\\n        uint depositDecrease;       // Deposit decrease\\n        uint depositReturn;         // Deposit actual returns\\n        uint sellAmount;\\n        uint receiveAmount;\\n        uint token0Price;\\n        uint outstandingAmount;\\n        uint32 dexDetail;\\n    }\\n\\n    struct MarginRatioVars {\\n        address heldToken;\\n        address sellToken;\\n        address owner;\\n        uint held;\\n        bytes dexData;\\n        uint16 multiplier;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IOpenLev\",\"name\":\"openLev\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"marketId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"desToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"secondsAgo\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"dexData\",\"type\":\"bytes\"}],\"name\":\"calPriceCAvgPriceHAvgPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cAvgPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hAvgPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOpenLev\",\"name\":\"openLev\",\"type\":\"address\"},{\"internalType\":\"contract IV3Quoter\",\"name\":\"v3Quoter\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"marketId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"slippage\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"longToken\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"dexData\",\"type\":\"bytes\"}],\"name\":\"getLiqCallData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minOrMaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callDexData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOpenLev\",\"name\":\"openLev\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"marketIds\",\"type\":\"uint16[]\"},{\"internalType\":\"contract LPoolInterface[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"getPoolDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableForBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"insurance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplierPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jumpMultiplierPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kink\",\"type\":\"uint256\"}],\"internalType\":\"struct QueryHelper.PoolVars[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOpenLev\",\"name\":\"openLev\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"marketId\",\"type\":\"uint16\"},{\"internalType\":\"address[]\",\"name\":\"traders\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"longTokens\",\"type\":\"bool[]\"},{\"internalType\":\"bytes\",\"name\":\"dexData\",\"type\":\"bytes\"}],\"name\":\"getTraderLiqs\",\"outputs\":[{\"components\":[{\"internalType\":\"enum QueryHelper.LiqStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentMarginRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cAvgMarginRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hAvgMarginRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"marginLimit\",\"type\":\"uint32\"}],\"internalType\":\"struct QueryHelper.LiqVars[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOpenLev\",\"name\":\"openLev\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"marketId\",\"type\":\"uint16\"},{\"internalType\":\"address[]\",\"name\":\"traders\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"longTokens\",\"type\":\"bool[]\"},{\"internalType\":\"bytes\",\"name\":\"dexData\",\"type\":\"bytes\"}],\"name\":\"getTraderPositons\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"held\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marginRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"marginLimit\",\"type\":\"uint32\"}],\"internalType\":\"struct QueryHelper.PositionVars[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IXOLE\",\"name\":\"xole\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"balanceOfToken\",\"type\":\"address\"}],\"name\":\"getXOLEDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShared\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tranferedToAccount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devFund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOf\",\"type\":\"uint256\"}],\"internalType\":\"struct QueryHelper.XOLEVars\",\"name\":\"vars\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"QueryHelper","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}