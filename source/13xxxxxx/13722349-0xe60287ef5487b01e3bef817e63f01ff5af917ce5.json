{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: --DG--\r\n\r\npragma solidity ^0.8.9;\r\n\r\ncontract DGKeeper {\r\n\r\n    address public gateKeeper;\r\n    address public gateOverseer;\r\n    address public distributionToken;\r\n    uint256 public totalRequired;\r\n\r\n    uint256 immutable MIN_TIME_FRAME;\r\n    address immutable ZERO_ADDRESS;\r\n\r\n    struct KeeperInfo {\r\n        bool isImmutable;\r\n        uint256 keeperRate;\r\n        uint256 keeperFrom;\r\n        uint256 keeperTill;\r\n        uint256 keeperBalance;\r\n        uint256 keeperPayouts;\r\n    }\r\n\r\n    mapping(address => KeeperInfo) public keeperList;\r\n\r\n    modifier onlyGateKeeper() {\r\n        require(\r\n            msg.sender == gateKeeper,\r\n            'DGKeeper: keeper denied!'\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyGateOverseer() {\r\n        require(\r\n            msg.sender == gateOverseer,\r\n            'DGKeeper: overseer denied!'\r\n        );\r\n        _;\r\n    }\r\n\r\n    event tokensScraped (\r\n        address indexed scraper,\r\n        uint256 scrapedAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event recipientCreated (\r\n        address indexed recipient,\r\n        uint256 timeLock,\r\n        uint256 timeReward,\r\n        uint256 instantReward,\r\n        uint256 timestamp,\r\n        bool isImmutable\r\n    );\r\n\r\n    event recipientDestroyed (\r\n        address indexed recipient,\r\n        uint256 timestamp\r\n    );\r\n\r\n    constructor(\r\n        address _distributionToken,\r\n        address _gateOverseer,\r\n        address _gateKeeper,\r\n        uint256 _minTimeFrame\r\n    ) {\r\n        require(\r\n            _minTimeFrame > 0,\r\n            'DGKeeper: increase _timeFrame'\r\n        );\r\n\r\n        distributionToken = _distributionToken;\r\n        gateOverseer = _gateOverseer;\r\n        gateKeeper = _gateKeeper;\r\n        MIN_TIME_FRAME = _minTimeFrame;\r\n        ZERO_ADDRESS = address(0);\r\n    }\r\n\r\n    function allocateTokensBulk(\r\n        address[] memory _recipients,\r\n        uint256[] memory _tokensOpened,\r\n        uint256[] memory _tokensLocked,\r\n        uint256[] memory _timeFrame,\r\n        bool[] memory _immutable\r\n    )\r\n        external\r\n        onlyGateKeeper\r\n    {\r\n        for (uint256 i = 0; i < _recipients.length; i++) {\r\n            allocateTokens(\r\n                _recipients[i],\r\n                _tokensOpened[i],\r\n                _tokensLocked[i],\r\n                _timeFrame[i],\r\n                _immutable[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function allocateTokens(\r\n        address _recipient,\r\n        uint256 _tokensOpened,\r\n        uint256 _tokensLocked,\r\n        uint256 _timeFrame,\r\n        bool _isImmutable\r\n    )\r\n        public\r\n        onlyGateKeeper\r\n    {\r\n        require(\r\n            _timeFrame >= MIN_TIME_FRAME,\r\n            'DGKeeper: _timeFrame below minimum'\r\n        );\r\n\r\n        require(\r\n            keeperList[_recipient].keeperFrom == 0,\r\n            'DGKeeper: _recipient is active'\r\n        );\r\n\r\n        totalRequired = totalRequired\r\n            + _tokensOpened\r\n            + _tokensLocked;\r\n\r\n        _safeBalanceOf(\r\n            distributionToken,\r\n            address(this),\r\n            totalRequired\r\n        );\r\n\r\n        uint256 timestamp = getNow();\r\n\r\n        keeperList[_recipient].keeperFrom = timestamp;\r\n        keeperList[_recipient].keeperTill = timestamp\r\n            + _timeFrame;\r\n\r\n        keeperList[_recipient].keeperRate = _tokensLocked\r\n            / _timeFrame;\r\n\r\n        keeperList[_recipient].keeperBalance = _tokensLocked\r\n            % _timeFrame\r\n            + _tokensOpened;\r\n\r\n        keeperList[_recipient].isImmutable = _isImmutable;\r\n\r\n        emit recipientCreated (\r\n            _recipient,\r\n            _timeFrame,\r\n            _tokensLocked,\r\n            _tokensOpened,\r\n            timestamp,\r\n            _isImmutable\r\n        );\r\n    }\r\n\r\n    function scrapeMyTokens()\r\n        external\r\n    {\r\n        _scrapeTokens(\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function _scrapeTokens(\r\n        address _recipient\r\n    )\r\n        internal\r\n    {\r\n        uint256 scrapeAmount = availableBalance(\r\n            _recipient\r\n        );\r\n\r\n        keeperList[_recipient].keeperPayouts =\r\n        keeperList[_recipient].keeperPayouts + scrapeAmount;\r\n\r\n        _safeTransfer(\r\n            distributionToken,\r\n            _recipient,\r\n            scrapeAmount\r\n        );\r\n\r\n        totalRequired =\r\n        totalRequired - scrapeAmount;\r\n\r\n        emit tokensScraped (\r\n            _recipient,\r\n            scrapeAmount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function destroyRecipient(\r\n        address _recipient\r\n    )\r\n        external\r\n        onlyGateOverseer\r\n    {\r\n        require(\r\n            keeperList[_recipient].isImmutable == false,\r\n            'DGKeeper: _recipient is immutable'\r\n        );\r\n\r\n        _scrapeTokens(\r\n            _recipient\r\n        );\r\n\r\n        totalRequired =\r\n        totalRequired - lockedBalance(_recipient);\r\n\r\n        delete keeperList[_recipient];\r\n\r\n        emit recipientDestroyed (\r\n            _recipient,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function availableBalance(\r\n        address _recipient\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        uint256 timePassed =\r\n            getNow() < keeperList[_recipient].keeperTill ?\r\n            getNow() - keeperList[_recipient].keeperFrom : _diff(_recipient);\r\n\r\n        balance = keeperList[_recipient].keeperRate\r\n            * timePassed\r\n            + keeperList[_recipient].keeperBalance\r\n            - keeperList[_recipient].keeperPayouts;\r\n    }\r\n\r\n    function lockedBalance(\r\n        address _recipient\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        uint256 timeRemaining =\r\n            keeperList[_recipient].keeperTill > getNow() ?\r\n            keeperList[_recipient].keeperTill - getNow() : 0;\r\n\r\n        balance = keeperList[_recipient].keeperRate * timeRemaining;\r\n    }\r\n\r\n    function getNow()\r\n        public\r\n        view\r\n        returns (uint256 time)\r\n    {\r\n        time = block.timestamp;\r\n    }\r\n\r\n    function changeDistributionToken(\r\n        address _newDistributionToken\r\n    )\r\n        external\r\n        onlyGateKeeper\r\n    {\r\n        distributionToken = _newDistributionToken;\r\n    }\r\n\r\n    function renounceKeeperOwnership()\r\n        external\r\n        onlyGateKeeper\r\n    {\r\n        gateKeeper = ZERO_ADDRESS;\r\n    }\r\n\r\n    function renounceOverseerOwnership()\r\n        external\r\n        onlyGateOverseer\r\n    {\r\n        gateOverseer = ZERO_ADDRESS;\r\n    }\r\n\r\n    function _diff(\r\n        address _recipient\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 difference)\r\n    {\r\n        difference = keeperList[_recipient].keeperTill - keeperList[_recipient].keeperFrom;\r\n    }\r\n\r\n    bytes4 private constant TRANSFER = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                'transfer(address,uint256)'\r\n            )\r\n        )\r\n    );\r\n\r\n    bytes4 private constant BALANCEOF = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                'balanceOf(address)'\r\n            )\r\n        )\r\n    );\r\n\r\n    function _safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        private\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            'DGKeeper: TRANSFER_FAILED'\r\n        );\r\n    }\r\n\r\n    function _safeBalanceOf(\r\n        address _token,\r\n        address _owner,\r\n        uint256 _required\r\n    )\r\n        private\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                BALANCEOF,\r\n                _owner\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && abi.decode(\r\n                data, (uint256)\r\n            ) >= _required,\r\n            'DGKeeper: BALANCEOF_FAILED'\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributionToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gateOverseer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gateKeeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTimeFrame\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeLock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"instantReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isImmutable\",\"type\":\"bool\"}],\"name\":\"recipientCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"recipientDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"scraper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"tokensScraped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeFrame\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isImmutable\",\"type\":\"bool\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensOpened\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensLocked\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timeFrame\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"_immutable\",\"type\":\"bool[]\"}],\"name\":\"allocateTokensBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDistributionToken\",\"type\":\"address\"}],\"name\":\"changeDistributionToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateOverseer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keeperList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isImmutable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"keeperRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperTill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperPayouts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceKeeperOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOverseerOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scrapeMyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DGKeeper","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004b520c812e8430659fc9f12f6d0c39026c83588d0000000000000000000000004ec5073ecb51f54d8f62b57a1b268a9079ff1dc30000000000000000000000004ec5073ecb51f54d8f62b57a1b268a9079ff1dc30000000000000000000000000000000000000000000000000000000000b71b00","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f1d8302ecb8bd518389701e5e61add80776de2d9d94ef6cf854cb74d49c4252b"}]}