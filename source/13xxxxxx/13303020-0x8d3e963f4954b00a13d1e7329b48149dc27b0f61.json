{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/0xerc1155/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(\\n    address _operator,\\n    address _from,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(\\n    address _operator,\\n    address _from,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/tokens/ERC1155/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport '../../interfaces/IERC1155TokenReceiver.sol';\\nimport '../../utils/ERC165.sol';\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC165, IERC1155TokenReceiver {\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address,\\n    address,\\n    uint256[] memory,\\n    uint256[] memory,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  function supportsInterface(bytes4 _interfaceID)\\n    public\\n    pure\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    if (_interfaceID == type(IERC1155TokenReceiver).interfaceId) {\\n      return true;\\n    }\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n  // Default hash for EOA accounts returned by extcodehash\\n  bytes32 internal constant ACCOUNT_HASH =\\n    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract.\\n   * @param _address address of the account to check\\n   * @return Whether the target address is a contract\\n   */\\n  function isContract(address _address) internal view returns (bool) {\\n    bytes32 codehash;\\n\\n    // Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(_address)\\n    }\\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), 'Address: No contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), 'Address: No contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\nabstract contract ERC165 {\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID)\\n    public\\n    pure\\n    virtual\\n    returns (bool)\\n  {\\n    return _interfaceID == this.supportsInterface.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\n\\npragma solidity 0.7.6;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../utils/SafeMath.sol';\\nimport '../utils/Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    // solhint-disable-next-line max-line-length\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n    );\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(\\n      data,\\n      'SafeERC20: low-level call failed'\\n    );\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        'SafeERC20: ERC20 operation did not succeed'\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath#mul: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, 'SafeMath#div: DIVISION_BY_ZERO');\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, 'SafeMath#sub: UNDERFLOW');\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two unsigned integers, reverts on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath#add: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n   * reverts when dividing by zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'SafeMath#mod: DIVISION_BY_ZERO');\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/CurveDepositInterface4.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/* solhint-disable func-name-mixedcase */\\nabstract contract ICurveFiDeposit4 {\\n  function add_liquidity(uint256[4] calldata uAmounts, uint256 minMintAmount)\\n    external\\n    virtual;\\n\\n  function remove_liquidity(uint256 amount, uint256[4] calldata minUAmounts)\\n    external\\n    virtual;\\n\\n  function remove_liquidity_imbalance(\\n    uint256[4] calldata uAmounts,\\n    uint256 maxBurnAmount\\n  ) external virtual;\\n\\n  function calc_withdraw_one_coin(uint256 wrappedAmount, int128 coinIndex)\\n    external\\n    view\\n    virtual\\n    returns (uint256 underlyingAmount);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 wrappedAmount,\\n    int128 coinIndex,\\n    uint256 minAmount,\\n    bool donateDust\\n  ) external virtual;\\n\\n  function coins(int128 i) external view virtual returns (address);\\n\\n  function underlying_coins(int128 i) external view virtual returns (address);\\n\\n  function underlying_coins() external view virtual returns (address[4] memory);\\n\\n  function curve() external view virtual returns (address);\\n\\n  function token() external view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/interfaces/ICFolioItemHandler.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport '../../token/interfaces/ICFolioItemCallback.sol';\\n\\n/**\\n * @dev Interface to C-folio item contracts\\n */\\ninterface ICFolioItemHandler is ICFolioItemCallback {\\n  /**\\n   * @dev Called when a SFT tokens grade needs re-evaluation\\n   *\\n   * @param tokenId The ERC-1155 token ID. Rate is in 1E6 convention: 1E6 = 100%\\n   * @param newRate The new value rate\\n   */\\n  function sftUpgrade(uint256 tokenId, uint32 newRate) external;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Asset access\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Adds investments into a cFolioItem SFT\\n   *\\n   * Transfers amounts of assets from users wallet to the contract. In general,\\n   * an Approval call is required before the function is called.\\n   *\\n   * @param from must be msg.sender for calls not from sftMinter\\n   * @param baseTokenId cFolio tokenId, must be unlocked, or -1\\n   * @param tokenId cFolioItem tokenId, must be unlocked if not in unlocked cFolio\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function deposit(\\n    address from,\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Removes investments from a cFolioItem SFT\\n   *\\n   * Withdrawn token are transfered back to msg.sender.\\n   *\\n   * @param baseTokenId cFolio tokenId, must be unlocked, or -1\\n   * @param tokenId cFolioItem tokenId, must be unlocked if not in unlocked cFolio\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function withdraw(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Update investment values from sidechain\\n   *\\n   * Must be called from a registered root tunnel\\n   *\\n   * @param tokenId cFolioItem tokenId\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function update(uint256 tokenId, uint256[] calldata amounts) external;\\n\\n  /**\\n   * @dev Get the rewards collected by an SFT base card\\n   *\\n   * Calls only allowed from sftMinter.\\n   *\\n   * @param owner The owner of the NFT token\\n   * @param recipient Recipient of the rewards (- fees)\\n   * @param tokenId SFT base card tokenId, must be unlocked\\n   */\\n  function getRewards(\\n    address owner,\\n    address recipient,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Get amounts (handler specific) for a cfolioItem\\n   *\\n   * @param cfolioItem address of CFolioItem contract\\n   */\\n  function getAmounts(address cfolioItem)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @dev Get information obout the rewardFarm\\n   *\\n   * @param tokenIds List of basecard tokenIds\\n   * @return bytes of uint256[]: total, rewardDur, rewardRateForDur, [share, earned]\\n   */\\n  function getRewardInfo(uint256[] calldata tokenIds)\\n    external\\n    view\\n    returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/interfaces/ISFTEvaluator.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n// BOIS feature bitmask\\nuint256 constant LEVEL2BOIS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000F;\\nuint256 constant LEVEL2WOLF = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000F0;\\n\\ninterface ISFTEvaluator {\\n  /**\\n   * @dev Returns the reward in 1e6 factor notation (1e6 = 100%)\\n   */\\n  function rewardRate(uint256 sftTokenId) external view returns (uint32);\\n\\n  /**\\n   * @dev Calculate the current reward rate, and notify TFC in case of change\\n   *\\n   * Optional revert on unchange to save gas on external calls.\\n   */\\n  function setRewardRate(uint256 tokenId, bool revertUnchanged) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/polygon/interfaces/IRootTunnel.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @title IRootTunnel\\n */\\ninterface IRootTunnel {\\n  // One way mint / migration only\\n  function mintCFolioItems(bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/ICFolioItemCallback.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @dev Interface to receive callbacks when minted tokens are burnt\\n */\\ninterface ICFolioItemCallback {\\n  /**\\n   * @dev Called when a TradeFloor CFolioItem is transfered\\n   *\\n   * In case of mint `from` is address(0).\\n   * In case of burn `to` is address(0).\\n   *\\n   * cfolioHandlers are passed to let each cfolioHandler filter for its own\\n   * token. This eliminates the need for creating separate lists.\\n   *\\n   * @param from The account sending the token\\n   * @param to The account receiving the token\\n   * @param tokenIds The ERC-1155 token IDs\\n   * @param cfolioHandlers cFolioItem handlers\\n   */\\n  function onCFolioItemsTransferedFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata tokenIds,\\n    address[] calldata cfolioHandlers\\n  ) external;\\n\\n  /**\\n   * @dev Append data we use later for hashing\\n   *\\n   * @param cfolioItem The token ID of the c-folio item\\n   * @param current The current data being hashes\\n   *\\n   * @return The current data, with internal data appended\\n   */\\n  function appendHash(address cfolioItem, bytes calldata current)\\n    external\\n    view\\n    returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSCryptofolio.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSCryptofolio {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getter\\n  //////////////////////////////////////////////////////////////////////////////\\n  /**\\n   * @dev Return the handler (CFIH) of the underlying NFT\\n   */\\n  function handler() external view returns (address);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n  /**\\n   * @dev Set the handler of the underlying NFT\\n   *\\n   * This function is called during I-NFT setup\\n   *\\n   * @param newHandler The new handler of the underlying NFT,\\n   */\\n  function setHandler(address newHandler) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSERC1155.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Sft holder contract\\n */\\ninterface IWOWSERC1155 {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Get the token ID of a given address\\n   *\\n   * A cross check is required because token ID 0 is valid.\\n   *\\n   * @param tokenAddress The address to convert to a token ID\\n   *\\n   * @return The token ID on success, or uint256(-1) if `tokenAddress` does not\\n   * belong to a token ID\\n   */\\n  function addressToTokenId(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Get the address for a given token ID\\n   *\\n   * @param tokenId The token ID to convert\\n   *\\n   * @return The address, or address(0) in case the token ID does not belong\\n   * to an NFT\\n   */\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Return the level and the mint timestamp of tokenId\\n   *\\n   * @param tokenId The tokenId to query\\n   *\\n   * @return mintTimestamp The timestamp token was minted\\n   * @return level The level token belongs to\\n   */\\n  function getTokenData(uint256 tokenId)\\n    external\\n    view\\n    returns (uint64 mintTimestamp, uint8 level);\\n\\n  /**\\n   * @dev Return all tokenIds owned by account\\n   */\\n  function getTokenIds(address account)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @dev Returns the cFolioItemType of a given cFolioItem tokenId\\n   */\\n  function getCFolioItemType(uint256 tokenId) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param owner  The address of the token holder\\n   * @param tokenId ID of the Token\\n   * @return The _owner's balance of the token type requested\\n   */\\n  function balanceOf(address owner, uint256 tokenId)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param owners The addresses of the token holders\\n   * @param tokenIds ID of the Tokens\\n   * @return       The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(\\n    address[] calldata owners,\\n    uint256[] calldata tokenIds\\n  ) external view returns (uint256[] memory);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Mints tokenIds into 'to' account\\n   * @dev Emits SftTokenTransfer Event\\n   *\\n   * Throws if sender has no MINTER_ROLE\\n   * 'data' holds the CFolioItemHandler if CFI's are minted\\n   */\\n  function mintBatch(\\n    address to,\\n    uint256[] calldata tokenIds,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @notice Burns tokenIds owned by 'account'\\n   * @dev Emits SftTokenTransfer Event\\n   *\\n   * Burns all owned CFolioItems\\n   * Throws if CFolioItems have assets\\n   */\\n  function burnBatch(address account, uint256[] calldata tokenIds) external;\\n\\n  /**\\n   * @notice Transfers amount of an id from the from address to the 'to' address specified\\n   * @dev Emits SftTokenTransfer Event\\n   * Throws if 'to' is the zero address\\n   * Throws if 'from' is not the current owner\\n   * If 'to' is a smart contract, ERC1155TokenReceiver interface will checked\\n   * @param from    Source address\\n   * @param to      Target address\\n   * @param tokenId ID of the token type\\n   * @param amount  Transfered amount\\n   * @param data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @dev Batch version of {safeTransferFrom}\\n   */\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @dev Each custom card has its own level. Level will be used when\\n   * calculating rewards and raiding power.\\n   *\\n   * @param tokenId The ID of the token whose level is being set\\n   * @param cardLevel The new level of the specified token\\n   */\\n  function setCustomCardLevel(uint256 tokenId, uint8 cardLevel) external;\\n\\n  /**\\n   * @dev Sets the cfolioItemType of a cfolioItem tokenId, not yet used\\n   * sftHolder tokenId expected (without hash)\\n   */\\n  function setCFolioItemType(uint256 tokenId, uint256 cfolioItemType_) external;\\n\\n  /**\\n   * @dev Sets external NFT for display tokenId\\n   * By default NFT is rendered using our internal metadata\\n   *\\n   * Throws if not called from MINTER role\\n   */\\n  function setExternalNft(\\n    uint256 tokenId,\\n    address externalCollection,\\n    uint256 externalTokenId\\n  ) external;\\n\\n  /**\\n   * @dev Deletes external NFT settings\\n   *\\n   * Throws if not called from MINTER role\\n   */\\n  function deleteExternalNft(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/AddressBook.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary AddressBook {\\n  bytes32 public constant DEPLOYER = 'DEPLOYER';\\n  bytes32 public constant TEAM_WALLET = 'TEAM_WALLET';\\n  bytes32 public constant MARKETING_WALLET = 'MARKETING_WALLET';\\n  bytes32 public constant ADMIN_ACCOUNT = 'ADMIN_ACCOUNT';\\n  bytes32 public constant UNISWAP_V2_ROUTER02 = 'UNISWAP_V2_ROUTER02';\\n  bytes32 public constant WETH_WOWS_STAKE_FARM = 'WETH_WOWS_STAKE_FARM';\\n  bytes32 public constant WOWS_TOKEN = 'WOWS_TOKEN';\\n  bytes32 public constant UNISWAP_V2_PAIR = 'UNISWAP_V2_PAIR';\\n  bytes32 public constant WOWS_BOOSTER_PROXY = 'WOWS_BOOSTER_PROXY';\\n  bytes32 public constant REWARD_HANDLER = 'REWARD_HANDLER';\\n  bytes32 public constant SFT_MINTER_PROXY = 'SFT_MINTER_PROXY';\\n  bytes32 public constant SFT_HOLDER_PROXY = 'SFT_HOLDER_PROXY';\\n  bytes32 public constant SFT_EVALUATOR_PROXY = 'SFT_EVALUATOR_PROXY';\\n  bytes32 public constant TRADE_FLOOR_PROXY = 'TRADE_FLOOR_PROXY';\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/MigrateV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport { ERC1155Holder } from '../../0xerc1155/tokens/ERC1155/ERC1155Holder.sol';\\nimport { IERC20, SafeERC20 } from '../../0xerc1155/utils/SafeERC20.sol';\\nimport { SafeMath } from '../../0xerc1155/utils/SafeMath.sol';\\n\\nimport '../cfolio/interfaces/ICFolioItemHandler.sol';\\nimport '../cfolio/interfaces/ISFTEvaluator.sol';\\nimport '../token/interfaces/IWOWSCryptofolio.sol';\\nimport '../token/interfaces/IWOWSERC1155.sol';\\nimport '../polygon/interfaces/IRootTunnel.sol';\\nimport '../utils/AddressBook.sol';\\nimport '../utils/interfaces/IAddressRegistry.sol';\\nimport '../utils/TokenIds.sol';\\n\\nimport '../../interfaces/curve/CurveDepositInterface4.sol';\\n\\ninterface ISFTEvaluatorOld {\\n  /**\\n   * @dev Returns the reward in 1e6 factor notation (1e6 = 100%)\\n   */\\n  function rewardRate(uint256 sftTokenId) external view returns (uint32);\\n\\n  /**\\n   * @dev Returns the cFolioItemType of a given cFolioItem tokenId\\n   */\\n  function getCFolioItemType(uint256 tokenId) external view returns (uint256);\\n}\\n\\ninterface IWOWSERC1155Old {\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  function getTokenData(uint256 tokenId)\\n    external\\n    view\\n    returns (uint64 mintTimestamp, uint8 level);\\n\\n  function burn(\\n    address account,\\n    uint256 tokenId,\\n    uint256 value\\n  ) external;\\n\\n  function burnBatch(\\n    address account,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata values\\n  ) external;\\n}\\n\\ninterface IWOWSCryptofolioOld {\\n  function _tradefloors(uint256 index) external view returns (address);\\n\\n  function getCryptofolio(address tradefloor)\\n    external\\n    view\\n    returns (uint256[] memory tokenIds, uint256 idsLength);\\n}\\n\\ninterface IBoosterOld {\\n  function migrateInitialize(address cfolio)\\n    external\\n    returns (uint256 poolState);\\n\\n  function migrateDeletePool(uint256 poolState, address cfolio)\\n    external\\n    returns (bytes memory data);\\n\\n  function claimRewards(uint256 sftTokenId, bool reLock) external;\\n}\\n\\ninterface IMinterOld {\\n  function claimSFTRewards(uint256 sftTokenId, uint256 lockPeriod) external;\\n}\\n\\ninterface ICFolioItemHandlerOld {\\n  function cfolioFarm() external returns (address);\\n}\\n\\ninterface ICFolioFarmOld {\\n  function balanceOf(address account) external returns (uint256);\\n}\\n\\n/**\\n * @notice Migration from v1 -> v2 which processes:\\n * - remove investment from cfis on old contract (either into the account\\n *   or for yCrv optional into this contract to withdraw later to USDC and\\n *   distribute to wallets)\\n * - mint cfolio in new sft contract\\n * - bridge cfolio and all cfis to polygon if cfolios are existent\\n *   or if booster has a reward timelock running\\n * - burn old cfolio + cfis in old contract\\n */\\n\\ncontract MigrateToV2 is ERC1155Holder {\\n  using SafeERC20 for IERC20;\\n  using TokenIds for uint256;\\n  using SafeMath for uint256;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // CONSTANTS\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  bytes32 public constant SFT_MINTER = 'SFT_MINTER';\\n  bytes32 public constant SFT_HOLDER = 'SFT_HOLDER';\\n  bytes32 public constant CFOLIOITEM_BRIDGE_PROXY = 'CFOLIOITEM_BRIDGE_PROXY';\\n  bytes32 public constant CURVE_Y_TOKEN = 'CURVE_Y_TOKEN';\\n  bytes32 public constant CURVE_Y_DEPOSIT = 'CURVE_Y_DEPOSIT';\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Routing\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  IWOWSERC1155Old private immutable _sftContractOld;\\n  ISFTEvaluatorOld private immutable _sftEvaluatorOld;\\n  address private immutable _cfiBridgeOld;\\n  IBoosterOld private immutable _boosterOld;\\n  IMinterOld private immutable _sftMinterOld;\\n\\n  IERC20 private immutable _yCrvToken;\\n  ICurveFiDeposit4 private immutable _curveYDeposit;\\n\\n  IWOWSERC1155 private immutable _sftContract;\\n  address private immutable _admin;\\n  IERC20 private immutable _uniV2LPToken;\\n  ISFTEvaluator private immutable _sftEvaluator;\\n  IERC20 private immutable _wowsToken;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  // If we have cfolios or booster lock, we need to bridge to polygon\\n  IRootTunnel public rootTunnel;\\n\\n  struct BulkSlot {\\n    uint256 amount;\\n    uint256 partId;\\n  }\\n\\n  address[] public bulkParticipants;\\n  mapping(address => BulkSlot) public bulkLookup;\\n\\n  uint256 releaseBlock = 13377140;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Modifier\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == _admin, 'M: Only admin');\\n    _;\\n  }\\n\\n  modifier onlyOldSftContract() {\\n    require(msg.sender == address(_sftContractOld), 'M: Only sftContractOld');\\n    _;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n  constructor(IAddressRegistry regOld, IAddressRegistry reg) {\\n    _admin = reg.getRegistryEntry(AddressBook.ADMIN_ACCOUNT);\\n    _sftContract = IWOWSERC1155(\\n      reg.getRegistryEntry(AddressBook.SFT_HOLDER_PROXY)\\n    );\\n    _uniV2LPToken = IERC20(reg.getRegistryEntry(AddressBook.UNISWAP_V2_PAIR));\\n    _sftEvaluator = ISFTEvaluator(\\n      reg.getRegistryEntry(AddressBook.SFT_EVALUATOR_PROXY)\\n    );\\n    _wowsToken = IERC20(reg.getRegistryEntry(AddressBook.WOWS_TOKEN));\\n\\n    _sftContractOld = IWOWSERC1155Old(regOld.getRegistryEntry(SFT_HOLDER));\\n    _sftEvaluatorOld = ISFTEvaluatorOld(\\n      regOld.getRegistryEntry(AddressBook.SFT_EVALUATOR_PROXY)\\n    );\\n    _cfiBridgeOld = regOld.getRegistryEntry(CFOLIOITEM_BRIDGE_PROXY);\\n    _boosterOld = IBoosterOld(\\n      regOld.getRegistryEntry(AddressBook.WOWS_BOOSTER_PROXY)\\n    );\\n    _sftMinterOld = IMinterOld(regOld.getRegistryEntry(SFT_MINTER));\\n\\n    _yCrvToken = IERC20(regOld.getRegistryEntry(CURVE_Y_TOKEN));\\n    _curveYDeposit = ICurveFiDeposit4(regOld.getRegistryEntry(CURVE_Y_DEPOSIT));\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {IERC1155TokenReceiver-onERC1155Received}\\n   */\\n  function onERC1155Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes calldata data\\n  ) public override onlyOldSftContract returns (bytes4) {\\n    bool yCrvBulkWithdraw = data.length >= 32\\n      ? abi.decode(data, (bool))\\n      : false;\\n    require(amount == 1, 'M: Invalid amount');\\n\\n    uint256[] memory oneTokenIds = new uint256[](1);\\n    oneTokenIds[0] = tokenId;\\n\\n    _processTokenId(from, oneTokenIds, yCrvBulkWithdraw);\\n\\n    // Call ancestor\\n    return super.onERC1155Received(operator, from, tokenId, amount, data);\\n  }\\n\\n  /**\\n   * @dev See {IERC1155TokenReceiver-onERC1155BatchReceived}\\n   */\\n  function onERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts,\\n    bytes calldata data\\n  ) public override onlyOldSftContract returns (bytes4) {\\n    require(tokenIds.length == amounts.length, 'M: Invalid length');\\n\\n    bool yCrvBulkWithdraw = data.length >= 32\\n      ? abi.decode(data, (bool))\\n      : false;\\n\\n    uint256[] memory oneTokenIds = new uint256[](1);\\n\\n    for (uint256 i = 0; i < tokenIds.length; ++i) {\\n      require(amounts[i] == 1, 'M: Invalid amount');\\n\\n      oneTokenIds[0] = tokenIds[0];\\n\\n      _processTokenId(from, oneTokenIds, yCrvBulkWithdraw);\\n    }\\n\\n    // Call ancestor\\n    return\\n      super.onERC1155BatchReceived(operator, from, tokenIds, amounts, data);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Bulk SC swap\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  function distributeStable() external {\\n    require(block.number >= releaseBlock, 'M: Not open');\\n    releaseBlock = uint256(-1);\\n\\n    uint256 amountY = _yCrvToken.balanceOf(address(this));\\n    require(amountY > 0, 'M: Empty');\\n\\n    _yCrvToken.safeApprove(address(_curveYDeposit), amountY);\\n\\n    IERC20 tetherToken = IERC20(_curveYDeposit.underlying_coins(2));\\n    _curveYDeposit.remove_liquidity_one_coin(amountY, 2, 0, true);\\n\\n    // Now we have USDT in our contract: distribute to users\\n    uint256 availableUSDT = tetherToken.balanceOf(address(this));\\n    uint256 totalUSDT = availableUSDT;\\n\\n    require(totalUSDT > 0, 'M: Empty S');\\n\\n    for (uint256 i = 0; i < bulkParticipants.length; ++i) {\\n      uint256 amount = totalUSDT\\n        .mul(bulkLookup[bulkParticipants[i]].amount)\\n        .div(amountY);\\n      if (amount > availableUSDT) amount = availableUSDT;\\n      availableUSDT.sub(amount);\\n      if (amount > 0) {\\n        tetherToken.safeTransfer(bulkParticipants[i], amount);\\n      }\\n      delete (bulkLookup[bulkParticipants[i]]);\\n    }\\n    delete (bulkParticipants);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Maintanance\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the Root Tunnel which is deployed after Migrate\\n   */\\n  function setRootTunnel(address rootTunnel_) external onlyAdmin {\\n    require(rootTunnel_ != address(0), 'M: Zero address');\\n\\n    rootTunnel = IRootTunnel(rootTunnel_);\\n  }\\n\\n  /**\\n   * @dev Destruct implementation\\n   */\\n  function destructContract() external onlyAdmin {\\n    // slither-disable-next-line suicidal\\n    selfdestruct(payable(_admin));\\n  }\\n\\n  /**\\n   * @dev Start a new bulk stable withdraw period\\n   */\\n  function setReleaseBlock(uint256 newReleaseBlock) external onlyAdmin {\\n    releaseBlock = newReleaseBlock;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // INTERNAL IMPLEMENTATION\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  function _processTokenId(\\n    address from,\\n    uint256[] memory oneTokenIds,\\n    bool yCrvBulk\\n  ) private {\\n    (bytes memory migrateData, bool needBridge) = _processMigration(\\n      from,\\n      oneTokenIds[0],\\n      yCrvBulk\\n    );\\n    // Investment should be pulled out of old contract, burn old cfolio\\n    _sftContractOld.burn(address(this), oneTokenIds[0], 1);\\n\\n    if (oneTokenIds[0].isBaseCard()) {\\n      if (needBridge) {\\n        migrateData = abi.encodePacked(migrateData, uint256(from));\\n        _sftContract.mintBatch(address(rootTunnel), oneTokenIds, migrateData);\\n      } else {\\n        _sftContract.mintBatch(from, oneTokenIds, migrateData);\\n        _sftEvaluator.setRewardRate(oneTokenIds[0], false);\\n      }\\n    } else {\\n      rootTunnel.mintCFolioItems(migrateData);\\n    }\\n  }\\n\\n  function _processMigration(\\n    address from,\\n    uint256 tokenId,\\n    bool yCrvBulk\\n  ) private returns (bytes memory result, bool needBridge) {\\n    needBridge = false;\\n    if (tokenId.isBaseCard()) {\\n      address cfolio = _sftContractOld.tokenIdToAddress(tokenId);\\n\\n      (uint64 mintTimestamp, ) = _sftContractOld.getTokenData(tokenId);\\n      (uint256[] memory tokenIds, uint256 idsLength) = IWOWSCryptofolioOld(\\n        cfolio\\n      ).getCryptofolio(_cfiBridgeOld);\\n\\n      result = abi.encodePacked(uint256(mintTimestamp), idsLength);\\n      needBridge = idsLength > 0;\\n\\n      for (uint256 i = 0; i < idsLength; ++i) {\\n        uint256 cfiType = _sftEvaluatorOld.getCFolioItemType(tokenIds[i]);\\n        _removeInvestment(from, tokenId, tokenIds[i], cfiType, yCrvBulk);\\n        result = abi.encodePacked(result, cfiType);\\n      }\\n\\n      // Booster Pool\\n      uint256 poolState = _boosterOld.migrateInitialize(cfolio);\\n\\n      if ((poolState & 1) != 0) {\\n        // Acive booster pool, claim rewards into it\\n        _sftMinterOld.claimSFTRewards(tokenId, 1);\\n      } else {\\n        // No active booster Pool, claim everything into users wallet\\n        uint256 balance = _wowsToken.balanceOf(address(this));\\n        _sftMinterOld.claimSFTRewards(tokenId, 0);\\n        if ((poolState & 2) != 0) {\\n          _boosterOld.claimRewards(tokenId, false);\\n        }\\n        balance = _wowsToken.balanceOf(address(this)).sub(balance);\\n        if (balance > 0) {\\n          _wowsToken.safeTransfer(from, balance);\\n        }\\n      }\\n      result = abi.encodePacked(result, poolState & 1);\\n\\n      bytes memory poolData = _boosterOld.migrateDeletePool(poolState, cfolio);\\n      if ((poolState & 1) != 0) {\\n        // We have an active booster pool -> bridge\\n        result = abi.encodePacked(result, poolData);\\n        needBridge = true;\\n      }\\n    } else {\\n      uint256 cfiType = _sftEvaluatorOld.getCFolioItemType(tokenId);\\n      _removeInvestment(from, uint256(-1), tokenId, cfiType, yCrvBulk);\\n      result = abi.encodePacked(cfiType);\\n    }\\n  }\\n\\n  function _removeInvestment(\\n    address from,\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256 cfiType,\\n    bool yCrvBulk\\n  ) private {\\n    address cfolioItem = _sftContractOld.tokenIdToAddress(tokenId);\\n    require(cfolioItem != address(0), 'M: Invalid cfi');\\n    address handler = IWOWSCryptofolioOld(cfolioItem)._tradefloors(0);\\n    address farm = ICFolioItemHandlerOld(handler).cfolioFarm();\\n\\n    uint256 tokenAmount = ICFolioFarmOld(farm).balanceOf(cfolioItem);\\n\\n    if (cfiType >= 16) {\\n      // yearn\\n      if (tokenAmount > 0) {\\n        uint256[] memory amounts = new uint256[](5);\\n        amounts[4] = tokenAmount;\\n\\n        ICFolioItemHandler(handler).withdraw(baseTokenId, tokenId, amounts);\\n        if (yCrvBulk) {\\n          if (bulkLookup[from].amount == 0) {\\n            bulkLookup[from].partId = bulkParticipants.length;\\n            bulkParticipants.push(from);\\n          }\\n          bulkLookup[from].amount.add(amounts[4]);\\n        } else {\\n          _yCrvToken.safeTransfer(from, amounts[4]);\\n        }\\n      }\\n    } else {\\n      // LP token\\n      if (tokenAmount > 0) {\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = tokenAmount;\\n\\n        ICFolioItemHandler(handler).withdraw(baseTokenId, tokenId, amounts);\\n        _uniV2LPToken.safeTransfer(from, amounts[0]);\\n      }\\n    }\\n  }\\n} // Contract\\n\"\r\n    },\r\n    \"contracts/src/utils/TokenIds.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary TokenIds {\\n  // 128 bit underlying hash\\n  uint256 public constant HASH_MASK = (1 << 128) - 1;\\n\\n  function isBaseCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isStockCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 32);\\n  }\\n\\n  function isCustomCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 32) && (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isCFolioCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 64) && (tokenId & HASH_MASK) < (1 << 128);\\n  }\\n\\n  function toSftTokenId(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & HASH_MASK;\\n  }\\n\\n  function maskHash(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & ~HASH_MASK;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/interfaces/IAddressRegistry.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface IAddressRegistry {\\n  /**\\n   * @dev Set an abitrary key / address pair into the registry\\n   */\\n  function setRegistryEntry(bytes32 _key, address _location) external;\\n\\n  /**\\n   * @dev Get a registry enty with by key, returns 0 address if not existing\\n   */\\n  function getRegistryEntry(bytes32 _key) external view returns (address);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"regOld\",\"type\":\"address\"},{\"internalType\":\"contract IAddressRegistry\",\"name\":\"reg\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CFOLIOITEM_BRIDGE_PROXY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_Y_DEPOSIT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_Y_TOKEN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SFT_HOLDER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SFT_MINTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bulkLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bulkParticipants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destructContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootTunnel\",\"outputs\":[{\"internalType\":\"contract IRootTunnel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReleaseBlock\",\"type\":\"uint256\"}],\"name\":\"setReleaseBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rootTunnel_\",\"type\":\"address\"}],\"name\":\"setRootTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MigrateToV2","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000945466656995c9309ff66e05b4c268558bec964e000000000000000000000000fef1f573121b4418012d144534506ad35ef4b81a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}