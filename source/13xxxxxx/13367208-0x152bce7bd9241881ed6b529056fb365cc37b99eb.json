{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Album.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./AlbumBuyoutManager.sol\\\";\\nimport \\\"./AlbumNftManager.sol\\\";\\nimport \\\"./AlbumTokenSaleManager.sol\\\";\\n\\ncontract Album is\\n    Ownable,\\n    ERC721Holder,\\n    AlbumBuyoutManager,\\n    AlbumNftManager,\\n    AlbumTokenSaleManager\\n{\\n    // The token for this album.\\n    IERC20 public token;\\n\\n    constructor(\\n        address governance,\\n        address _token,\\n        address creator,\\n        TokenSaleParams memory tokenSaleParams,\\n        address[] memory _nftAddrs,\\n        uint256[] memory _nftIds,\\n        uint256 _minReservePrice\\n    ) AlbumTokenSaleManager(creator, tokenSaleParams) {\\n        transferOwnership(governance);\\n        token = IERC20(_token);\\n        _addNfts(_nftAddrs, _nftIds);\\n        _setMinReservePrice(_minReservePrice);\\n    }\\n\\n    function addNfts(address[] memory _nfts, uint256[] memory _ids)\\n        public\\n        onlyOwner\\n    {\\n        _addNfts(_nfts, _ids);\\n    }\\n\\n    function sendNfts(address to, uint256[] memory idxs) public onlyOwner {\\n        _sendNfts(to, idxs);\\n    }\\n\\n    function setTimeout(uint256 _timeout) public onlyOwner {\\n        _setTimeout(_timeout);\\n    }\\n\\n    function sendAllToSender() internal override {\\n        address[] memory nfts = getNfts();\\n        uint256[] memory ids = getIds();\\n        bool[] memory sent = getSent();\\n        for (uint256 i = 0; i < nfts.length; i++) {\\n            if (!sent[i]) {\\n                IERC721(nfts[i]).safeTransferFrom(\\n                    address(this),\\n                    msg.sender,\\n                    ids[i]\\n                );\\n            }\\n        }\\n    }\\n\\n    function setMinReservePrice(uint256 _minReservePrice) public onlyOwner {\\n        _setMinReservePrice(_minReservePrice);\\n    }\\n\\n    function setBuyout(address _buyer, uint256 _cost) public onlyOwner {\\n        _setBuyout(_buyer, _cost);\\n    }\\n\\n    function checkOwedAmount(uint256 _amount, uint256 buyoutCost)\\n        internal\\n        override\\n        returns (uint256 owed)\\n    {\\n        token.transferFrom(msg.sender, address(this), _amount);\\n        owed = (_amount * buyoutCost) / token.totalSupply();\\n    }\\n\\n    function getToken() public view override returns (IERC20) {\\n        return token;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AlbumBuyoutManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nabstract contract AlbumBuyoutManager {\\n    event BuyoutSet(address buyer, uint256 cost, uint256 end);\\n    event Buyout(address buyer, uint256 cost);\\n    event BuyoutPortionClaimed(address claimer, uint256 amount, uint256 owed);\\n    event MinReservePriceSet(uint256 minReservePrice);\\n\\n    address private buyer;\\n    uint256 private buyoutCost;\\n    uint256 private buyoutEnd;\\n    bool private bought;\\n    uint256 private minReservePrice;\\n    // Initialized to 7 days in seconds\\n    uint256 private timeout = 60 * 60 * 24 * 7;\\n\\n    function sendAllToSender() internal virtual;\\n\\n    function checkOwedAmount(uint256 _amount, uint256 _buyoutCost)\\n        internal\\n        virtual\\n        returns (uint256 owed);\\n\\n    // Requires no completed or ongoing buyout.\\n    modifier noBuyout() {\\n        require(!bought, \\\"A buyout was already completed\\\");\\n        require(\\n            block.timestamp >= buyoutEnd || buyer == address(0),\\n            \\\"A buyout is in progress\\\"\\n        );\\n        _;\\n    }\\n\\n    function getBuyoutData()\\n        public\\n        view\\n        returns (\\n            address _buyer,\\n            uint256 _buyoutCost,\\n            uint256 _buyoutEnd,\\n            bool _bought,\\n            uint256 _timeout,\\n            uint256 _minReservePrice\\n        )\\n    {\\n        return (buyer, buyoutCost, buyoutEnd, bought, timeout, minReservePrice);\\n    }\\n\\n    function _setTimeout(uint256 _timeout) internal {\\n        timeout = _timeout;\\n    }\\n\\n    function _setMinReservePrice(uint256 _minReservePrice) internal {\\n        minReservePrice = _minReservePrice;\\n        emit MinReservePriceSet(_minReservePrice);\\n    }\\n\\n    function _setBuyout(address _buyer, uint256 _cost) internal noBuyout {\\n        require(\\n            _cost >= minReservePrice,\\n            \\\"Album can't be bought out for amount less than minReservePrice!\\\"\\n        );\\n        buyer = _buyer;\\n        buyoutCost = _cost;\\n        buyoutEnd = block.timestamp + timeout;\\n        emit BuyoutSet(buyer, buyoutCost, buyoutEnd);\\n    }\\n\\n    function buyout() public payable {\\n        require(!bought, \\\"Album has already been bought out\\\");\\n        require(msg.sender == buyer, \\\"Caller is not the buyer.\\\");\\n        require(msg.value == buyoutCost, \\\"Not enough ETH.\\\");\\n        require(block.timestamp < buyoutEnd, \\\"Buyout timeout already passed.\\\");\\n        sendAllToSender();\\n        bought = true;\\n        emit Buyout(buyer, buyoutCost);\\n    }\\n\\n    function claim(uint256 _amount) public {\\n        require(bought, \\\"No buyout yet.\\\");\\n        uint256 owed = checkOwedAmount(_amount, buyoutCost);\\n        payable(msg.sender).transfer(owed);\\n        emit BuyoutPortionClaimed(msg.sender, _amount, owed);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AlbumNftManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nabstract contract AlbumNftManager {\\n    event AddNfts(address[] nfts, uint256[] ids);\\n    event SendNfts(address to, uint256[] idxs);\\n\\n    // NFTs owned by this album.\\n    address[] private nfts;\\n    uint256[] private ids;\\n    bool[] private sent;\\n\\n    function getNfts() public view returns (address[] memory) {\\n        return nfts;\\n    }\\n\\n    function getIds() public view returns (uint256[] memory) {\\n        return ids;\\n    }\\n\\n    function getSent() public view returns (bool[] memory) {\\n        return sent;\\n    }\\n\\n    function _addNfts(address[] memory _nfts, uint256[] memory _ids) internal {\\n        require(\\n            _nfts.length == _ids.length,\\n            \\\"Input array lenghts don't match.\\\"\\n        );\\n        for (uint256 i = 0; i < _nfts.length; i++) {\\n            address nftAddr = _nfts[i];\\n            IERC721 nft = IERC721(nftAddr);\\n            uint256 id = _ids[i];\\n            address owner = nft.ownerOf(id);\\n            if (owner != address(this)) {\\n                nft.safeTransferFrom(owner, address(this), id);\\n            }\\n            nfts.push(nftAddr);\\n            ids.push(id);\\n            sent.push(false);\\n        }\\n        emit AddNfts(_nfts, _ids);\\n    }\\n\\n    function _sendNfts(address to, uint256[] memory idxs) internal {\\n        uint256 idx;\\n        for (uint256 i = 0; i < idxs.length; i++) {\\n            idx = idxs[i];\\n            IERC721(nfts[idx]).safeTransferFrom(address(this), to, ids[idx]);\\n            sent[idx] = true;\\n        }\\n        emit SendNfts(to, idxs);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AlbumTokenSaleManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nabstract contract AlbumTokenSaleManager {\\n    event SaleInitialized(\\n        address creator,\\n        uint256 tokensPerMilliEth,\\n        uint256 saleStart,\\n        uint256 saleEnd,\\n        uint256 numTokens\\n    );\\n    event TokenSale(address buyer, uint256 amount, uint256 paid);\\n    event SaleSwept(uint256 saleProceeds, uint256 amountUnsold);\\n\\n    uint256 public constant MILLIETH = 1e15;\\n\\n    address public immutable CREATOR;\\n    // Number of tokens to sell per wei (1e-18 ETH)\\n    uint256 public immutable TOKENS_PER_WEI;\\n    uint256 public immutable SALE_START;\\n    uint256 public immutable SALE_END;\\n\\n    uint256 private saleProceeds;\\n    uint256 private amountUnsold;\\n    bool private swept;\\n\\n    modifier saleOver(bool want) {\\n        bool isOver = block.timestamp >= SALE_END;\\n        require(want == isOver, \\\"Sale state is invalid for this method\\\");\\n        _;\\n    }\\n\\n    struct TokenSaleParams {\\n        uint256 price;\\n        uint256 saleStart;\\n        uint256 saleEnd;\\n        uint256 numTokens;\\n    }\\n\\n    constructor(address creator, TokenSaleParams memory params) {\\n        require(params.saleStart < params.saleEnd);\\n        CREATOR = creator;\\n        TOKENS_PER_WEI = params.price;\\n        SALE_START = params.saleStart;\\n        SALE_END = params.saleEnd;\\n        amountUnsold = params.numTokens;\\n        emit SaleInitialized(\\n            creator,\\n            params.price,\\n            params.saleStart,\\n            params.saleEnd,\\n            params.numTokens\\n        );\\n    }\\n\\n    function getToken() public view virtual returns (IERC20 token);\\n\\n    function buyTokens() public payable saleOver(false) {\\n        require(block.timestamp >= SALE_START, \\\"Sale has not started yet\\\");\\n        uint256 amount = msg.value * TOKENS_PER_WEI;\\n        require(amountUnsold >= amount, \\\"Attempted to purchase too many tokens!\\\");\\n        amountUnsold -= amount;\\n        getToken().transfer(msg.sender, amount);\\n        saleProceeds += msg.value;\\n        emit TokenSale(msg.sender, amount, msg.value);\\n    }\\n\\n    // Anyone can trigger a sweep, but the proceeds always get sent to the creator.\\n    function sweepProceeds() public saleOver(true) {\\n        require(!swept, \\\"Already swept\\\");\\n        swept = true;\\n        payable(CREATOR).transfer(saleProceeds);\\n        getToken().transfer(CREATOR, amountUnsold);\\n        emit SaleSwept(saleProceeds, amountUnsold);\\n    }\\n\\n    function getTokenSaleData()\\n        public\\n        view\\n        returns (\\n            address creator,\\n            uint256 tokensPerWei,\\n            uint256 saleStart,\\n            uint256 saleEnd,\\n            uint256 _saleProceeds,\\n            uint256 _amountUnsold,\\n            bool _swept\\n        )\\n    {\\n        return (\\n            CREATOR,\\n            TOKENS_PER_WEI,\\n            SALE_START,\\n            SALE_END,\\n            saleProceeds,\\n            amountUnsold,\\n            swept\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct AlbumTokenSaleManager.TokenSaleParams\",\"name\":\"tokenSaleParams\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_nftAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_minReservePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"AddNfts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"Buyout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"name\":\"BuyoutPortionClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"BuyoutSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minReservePrice\",\"type\":\"uint256\"}],\"name\":\"MinReservePriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensPerMilliEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"SaleInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleProceeds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUnsold\",\"type\":\"uint256\"}],\"name\":\"SaleSwept\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"idxs\",\"type\":\"uint256[]\"}],\"name\":\"SendNfts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"name\":\"TokenSale\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CREATOR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MILLIETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_END\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKENS_PER_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nfts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"addNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyout\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyoutData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_buyoutCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyoutEnd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_bought\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minReservePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNfts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSent\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenSaleData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_saleProceeds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountUnsold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swept\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"idxs\",\"type\":\"uint256[]\"}],\"name\":\"sendNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cost\",\"type\":\"uint256\"}],\"name\":\"setBuyout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minReservePrice\",\"type\":\"uint256\"}],\"name\":\"setMinReservePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"setTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepProceeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Album","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000256bfefdb0cf9acb14bde0ef307337cb2a71e1be0000000000000000000000005554891d88fb18035b2fb2343ef35ab2d1d970f500000000000000000000000088f09bdc8e99272588242a808052eb32702f88d00000000000000000000000000000000000000000000000000000000001312d0000000000000000000000000000000000000000000000000000000000615df48800000000000000000000000000000000000000000000000000000000615df5b400000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000eb68f1fbb84db4a63bf19ff364cfc3e496daf910000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000009aa","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}