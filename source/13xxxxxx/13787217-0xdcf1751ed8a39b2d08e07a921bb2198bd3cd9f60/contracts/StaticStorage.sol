pragma solidity ^0.8.2;

// Adapted from ChunkStorage by Agustin Aguilar
// https://medium.com/@agusx1211/evm-istambul-storage-pricing-5befaac32403
library StaticStorage {
  function createData(bytes memory _data) internal returns (address) {
    address slot;
    assembly {
      // Load data to store, size and offset
      let data_size := mload(_data)
      let dataOffset := add(_data, 0x20)

      // Calculate expected data-contract size
      let known_size

      // We know that 0x120 bytes of the data are stored using
      // PUSH1, and thus that size is fixed, we need to calculate
      // the remaining size
      let tmp_data_size := sub(data_size, 0x120)
      let words := div(tmp_data_size, 0x20)

      // divRound number of words, if we need to store half word
      // it's the same as storing a full one
      if iszero(iszero(mod(tmp_data_size, 0x20))){
          words := add(words, 0x01)
      }

      // Each word takes 0x25 bytes to store (PUSH 32 + 32 bytes + PUSH2 + 2 bytes + MSTORE)
      // the 0x06 extra bytes for the "return" opcodes and
      // we need to add the 0x145 bytes of the PUSH1 data
      known_size := add(0x145, add(0x06, mul(words, 0x25)))
      // We add the 0x09 words of the PUSH1 data
      words := add(0x09, words)
  
      // Get free memory to store the generated bytecode
      let bytecodeOffset := mload(0x40)

      // Contract constructor, adding the calculated size of the contract
      mstore(bytecodeOffset, or(shl(232, known_size), 0x610000600081600B8239F3000000000000000000000000000000000000000000))

      // Create the bytecode pointer to start writing the contract
      let bytecode_pointer := add(0x0b, bytecodeOffset)

      // Iteare the data array, using 32 bytes words
      for { let data_c := 0 } lt(data_c, data_size) { } {
        // Write PUSH32 opcode and update pointer
        mstore(bytecode_pointer, 0x7f00000000000000000000000000000000000000000000000000000000000000)
        bytecode_pointer := add(bytecode_pointer, 0x01)
        // Copy data to bytecode, 32 bytes
        mstore(bytecode_pointer, mload(add(dataOffset, data_c)))
        bytecode_pointer := add(bytecode_pointer, 0x20)

        // Check if the MSTORE opcode uses a PUSH1 or a PUSH2
        let one_byte_opcode := lt(data_c, 0x0100)
        if one_byte_opcode {
            // Write PUSH1 [data_c] MSTORE and update pointer
            mstore(bytecode_pointer, or(shl(0xf0, data_c), 0x6000520000000000000000000000000000000000000000000000000000000000))
            bytecode_pointer := add(bytecode_pointer, 0x03)
        }

        if iszero(one_byte_opcode) {
            // Write PUSH2 [data_c] MSTORE and update pointer
            mstore(bytecode_pointer, or(shl(0xe8, data_c), 0x6100005200000000000000000000000000000000000000000000000000000000))
            bytecode_pointer := add(bytecode_pointer, 0x04)
        }

        // Move the data pointer 32 bytes
        data_c := add(data_c, 0x20)
      }

      // Write return function for the data-contract code and update the pointer
      mstore(bytecode_pointer, or(shl(232, data_size), 0x6100006000f30000000000000000000000000000000000000000000000000000))
      bytecode_pointer := add(bytecode_pointer, 0x06)

      // Execute create using the generated bytecode
      slot := create(0, bytecodeOffset, sub(bytecode_pointer, bytecodeOffset))
    }

    require(slot != address(0), "Storage mint failed");
    return slot;
  }

  function readData(address slot) internal view returns (bytes memory data) {
    if (slot == address(0)) {
      data = bytes("");
    } else {
      (, data) = slot.staticcall("");
    }
  }
}

