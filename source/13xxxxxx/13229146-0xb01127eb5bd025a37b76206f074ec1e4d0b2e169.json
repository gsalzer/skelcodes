{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SwapAndLiquifyProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./SwapAndLiquifyEvents.sol\\\";\\n\\n/// @title Upgradable Registry Contract\\ncontract SwapAndLiquifyProxy is Upgradeable, SwapAndLiquifyEvents {\\n    /// @notice Contract constructor\\n    /// @dev Calls Upgradable contract constructor and sets contract name\\n    constructor() {}\\n    \\n    receive() external payable {}\\n    \\n    /// @notice Performs a delegatecall to the implementation contract.\\n    /// @dev Fallback function allows to perform a delegatecall to the given implementation.\\n    /// This function will return whatever the implementation call returns.\\n    fallback() external payable {\\n        require(msg.data.length > 0, \\\"Calldata must not be empty\\\");\\n        address _impl = getImplementation();\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize())\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/// @title Upgradeable contract\\ncontract Upgradeable is Ownable {\\n    /// @notice Storage position of the current implementation address.\\n    /// @dev The address of the current implementation is stored in a\\n    /// constant pseudorandom slot of the contract proxy contract storage\\n    /// (slot number obtained as a result of hashing a certain message),\\n    /// the probability of rewriting which is almost zero\\n    bytes32 private constant implementationPosition = keccak256(\\n        \\\"implementation\\\"\\n    );\\n\\n    /// @notice Contract constructor\\n    /// @dev Calls Ownable contract constructor\\n    constructor() {}\\n\\n    /// @notice Returns the current implementation contract address\\n    function getImplementation() public view returns (address implementation) {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            implementation := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new implementation contract address as current\\n    /// @param _newImplementation New implementation contract address\\n    function setImplementation(address _newImplementation) public onlyOwner {\\n        require(_newImplementation != address(0), \\\"New implementation must have non-zero address\\\");\\n        address currentImplementation = getImplementation();\\n        require(currentImplementation != _newImplementation, \\\"New implementation must have new address\\\");\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            sstore(position, _newImplementation)\\n        }\\n    }\\n\\n    /// @notice Sets new implementation contract address and call its initializer.\\n    /// @dev New implementation call is a low level delegatecall.\\n    /// @param _newImplementation the new implementation address.\\n    /// @param _newImplementaionCallData represents the msg.data to bet sent through the low level delegatecall.\\n    /// This parameter may include the initializer function signature with the needed payload.\\n    function setImplementationAndCall(\\n        address _newImplementation,\\n        bytes calldata _newImplementaionCallData\\n    ) external payable {\\n        setImplementation(_newImplementation);\\n        if (_newImplementaionCallData.length > 0) {\\n            (bool success, ) = address(this).call{value: msg.value}(\\n                _newImplementaionCallData\\n            );\\n            require(success, \\\"Delegatecall has failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SwapAndLiquifyEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ncontract SwapAndLiquifyEvents {\\n    event Initialized(address aldnAddress, address uniswapV2RouterAddress);\\n    event SwapAndLiquified(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\\n    event LiquidityInitialized(uint256 tokensIntoLiquidity, uint256 ethIntoLiquidity);\\n}\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n// File: @openzeppelin/contracts/access/Ownable.sol\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _authorizedNewOwner;\\n\\n    event OwnershipTransferAuthorization(address indexed authorizedAddress);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current authorized new owner.\\n     */\\n    function authorizedNewOwner() public view virtual returns (address) {\\n        return _authorizedNewOwner;\\n    }\\n\\n    /**\\n     * @notice Authorizes the transfer of ownership from _owner to the provided address.\\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership( ).\\n     * This authorization may be removed by another call to this function authorizing\\n     * the null address.\\n     *\\n     * @param authorizedAddress The address authorized to become the new owner.\\n     */\\n    function authorizeOwnershipTransfer(address authorizedAddress) external onlyOwner {\\n        _authorizedNewOwner = authorizedAddress;\\n        emit OwnershipTransferAuthorization(_authorizedNewOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of this contract to the _authorizedNewOwner.\\n     */\\n    function assumeOwnership() external {\\n        require(_msgSender() == _authorizedNewOwner, \\\"Ownable: only the authorized new owner can accept ownership\\\");\\n        emit OwnershipTransferred(_owner, _authorizedNewOwner);\\n        _owner = _authorizedNewOwner;\\n        _authorizedNewOwner = address(0);\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     *\\n     * @param confirmAddress The address wants to give up ownership.\\n     */\\n    function renounceOwnership(address confirmAddress) public virtual onlyOwner {\\n        require(confirmAddress == _owner, \\\"Ownable: confirm address is wrong\\\");\\n        emit OwnershipTransferred(_owner, address(0));\\n        _authorizedNewOwner = address(0);\\n        _owner = address(0);\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aldnAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uniswapV2RouterAddress\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"OwnershipTransferAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquified\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"assumeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedAddress\",\"type\":\"address\"}],\"name\":\"authorizeOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorizedNewOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"confirmAddress\",\"type\":\"address\"}],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_newImplementaionCallData\",\"type\":\"bytes\"}],\"name\":\"setImplementationAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SwapAndLiquifyProxy","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}