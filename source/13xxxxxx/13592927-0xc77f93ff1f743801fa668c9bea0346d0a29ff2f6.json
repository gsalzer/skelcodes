{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/stark-proxy/v2/StarkProxyV2.sol\": {\r\n      \"content\": \"// Contracts by dYdX Foundation. Individual files are released under different licenses.\\n//\\n// https://dydx.community\\n// https://github.com/dydxfoundation/governance-contracts\\n//\\n// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { ILiquidityStakingV1 } from '../../interfaces/ILiquidityStakingV1.sol';\\nimport { IMerkleDistributorV1 } from '../../interfaces/IMerkleDistributorV1.sol';\\nimport { IStarkPerpetual } from '../../interfaces/IStarkPerpetual.sol';\\nimport { SafeERC20 } from '../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SP2Withdrawals } from './impl/SP2Withdrawals.sol';\\nimport { SP1Getters } from '../v1/impl/SP1Getters.sol';\\nimport { SP2Guardian } from './impl/SP2Guardian.sol';\\nimport { SP2Owner } from './impl/SP2Owner.sol';\\n\\n/**\\n * @title StarkProxyV2\\n * @author dYdX\\n *\\n * @notice Proxy contract allowing a LiquidityStaking borrower to use borrowed funds (as well as\\n *  their own funds, if desired) on the dYdX L2 exchange. Restrictions are put in place to\\n *  prevent borrowed funds being used outside the exchange. Furthermore, a guardian address is\\n *  specified which has the ability to restrict borrows and make repayments.\\n *\\n *  Owner actions may be delegated to various roles as defined in SP1Roles. Other actions are\\n *  available to guardian roles, to be nominated by dYdX governance.\\n */\\ncontract StarkProxyV2 is\\n  SP2Guardian,\\n  SP2Owner,\\n  SP2Withdrawals,\\n  SP1Getters\\n{\\n  using SafeERC20 for IERC20;\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    ILiquidityStakingV1 liquidityStaking,\\n    IStarkPerpetual starkPerpetual,\\n    IERC20 token,\\n    IMerkleDistributorV1 merkleDistributor\\n  )\\n    SP2Guardian(liquidityStaking, starkPerpetual, token)\\n    SP2Withdrawals(merkleDistributor)\\n  {}\\n\\n  // ============ External Functions ============\\n\\n  function initialize()\\n    external\\n    initializer\\n  {}\\n\\n  // ============ Internal Functions ============\\n\\n  /**\\n   * @dev Returns the revision of the implementation contract.\\n   *\\n   * @return The revision number.\\n   */\\n  function getRevision()\\n    internal\\n    pure\\n    override\\n    returns (uint256)\\n  {\\n    return 2;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n* @dev Interface of the ERC20 standard as defined in the EIP.\\n*/\\ninterface IERC20 {\\n  /**\\n    * @dev Returns the amount of tokens in existence.\\n    */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n    * @dev Returns the amount of tokens owned by `account`.\\n    */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Returns the remaining number of tokens that `spender` will be\\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n    * zero by default.\\n    *\\n    * This value changes when {approve} or {transferFrom} are called.\\n    */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n    * that someone may use both the old and the new allowance by unfortunate\\n    * transaction ordering. One possible solution to mitigate this race\\n    * condition is to first reduce the spender's allowance to 0 and set the\\n    * desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    *\\n    * Emits an {Approval} event.\\n    */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n    * allowance mechanism. `amount` is then deducted from the caller's\\n    * allowance.\\n    *\\n    * Returns a boolean value indicating whether the operation succeeded.\\n    *\\n    * Emits a {Transfer} event.\\n    */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n    * another (`to`).\\n    *\\n    * Note that `value` may be zero.\\n    */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n    * a call to {approve}. `value` is the new allowance.\\n    */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityStakingV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title ILiquidityStakingV1\\n * @author dYdX\\n *\\n * @notice Partial interface for LiquidityStakingV1.\\n */\\ninterface ILiquidityStakingV1 {\\n\\n  function getToken() external view virtual returns (address);\\n\\n  function getBorrowedBalance(address borrower) external view virtual returns (uint256);\\n\\n  function getBorrowerDebtBalance(address borrower) external view virtual returns (uint256);\\n\\n  function isBorrowingRestrictedForBorrower(address borrower) external view virtual returns (bool);\\n\\n  function getTimeRemainingInEpoch() external view virtual returns (uint256);\\n\\n  function inBlackoutWindow() external view virtual returns (bool);\\n\\n  // LS1Borrowing\\n  function borrow(uint256 amount) external virtual;\\n\\n  function repayBorrow(address borrower, uint256 amount) external virtual;\\n\\n  function getAllocatedBalanceCurrentEpoch(address borrower)\\n    external\\n    view\\n    virtual\\n    returns (uint256);\\n\\n  function getAllocatedBalanceNextEpoch(address borrower) external view virtual returns (uint256);\\n\\n  function getBorrowableAmount(address borrower) external view virtual returns (uint256);\\n\\n  // LS1DebtAccounting\\n  function repayDebt(address borrower, uint256 amount) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleDistributorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title IMerkleDistributorV1\\n * @author dYdX\\n *\\n * @notice Partial interface for the MerkleDistributorV1 contract.\\n */\\ninterface IMerkleDistributorV1 {\\n\\n  function getIpnsName()\\n    external\\n    virtual\\n    view\\n    returns (string memory);\\n\\n  function getRewardsParameters()\\n    external\\n    virtual\\n    view\\n    returns (uint256, uint256, uint256);\\n\\n  function getActiveRoot()\\n    external\\n    virtual\\n    view\\n    returns (bytes32 merkleRoot, uint256 epoch, bytes memory ipfsCid);\\n\\n  function getNextRootEpoch()\\n    external\\n    virtual\\n    view\\n    returns (uint256);\\n\\n  function claimRewards(\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStarkPerpetual.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title IStarkPerpetual\\n * @author dYdX\\n *\\n * @notice Partial interface for the StarkPerpetual contract, for accessing the dYdX L2 exchange.\\n * @dev See https://github.com/starkware-libs/starkex-contracts\\n */\\ninterface IStarkPerpetual {\\n\\n  function registerUser(\\n    address ethKey,\\n    uint256 starkKey,\\n    bytes calldata signature\\n  ) external;\\n\\n  function deposit(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    uint256 quantizedAmount\\n  ) external;\\n\\n  function withdraw(uint256 starkKey, uint256 assetType) external;\\n\\n  function forcedWithdrawalRequest(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    uint256 quantizedAmount,\\n    bool premiumCost\\n  ) external;\\n\\n  function forcedTradeRequest(\\n    uint256 starkKeyA,\\n    uint256 starkKeyB,\\n    uint256 vaultIdA,\\n    uint256 vaultIdB,\\n    uint256 collateralAssetId,\\n    uint256 syntheticAssetId,\\n    uint256 amountCollateral,\\n    uint256 amountSynthetic,\\n    bool aIsBuyingSynthetic,\\n    uint256 submissionExpirationTime,\\n    uint256 nonce,\\n    bytes calldata signature,\\n    bool premiumCost\\n  ) external;\\n\\n  function mainAcceptGovernance() external;\\n  function proxyAcceptGovernance() external;\\n\\n  function mainRemoveGovernor(address governorForRemoval) external;\\n  function proxyRemoveGovernor(address governorForRemoval) external;\\n\\n  function registerAssetConfigurationChange(uint256 assetId, bytes32 configHash) external;\\n  function applyAssetConfigurationChange(uint256 assetId, bytes32 configHash) external;\\n\\n  function registerGlobalConfigurationChange(bytes32 configHash) external;\\n  function applyGlobalConfigurationChange(bytes32 configHash) external;\\n\\n  function getEthKey(uint256 starkKey) external view returns (address);\\n\\n  function depositCancel(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId\\n  ) external;\\n\\n  function depositReclaim(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport { IERC20 } from '../../interfaces/IERC20.sol';\\nimport { SafeMath } from './SafeMath.sol';\\nimport { Address } from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\\n * Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v2/impl/SP2Withdrawals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { IMerkleDistributorV1 } from '../../../interfaces/IMerkleDistributorV1.sol';\\nimport { IStarkPerpetual } from '../../../interfaces/IStarkPerpetual.sol';\\nimport { SP2Exchange } from './SP2Exchange.sol';\\n\\n/**\\n * @title SP2Withdrawals\\n * @author dYdX\\n *\\n * @dev Actions which may be called only by WITHDRAWAL_OPERATOR_ROLE. Allows for withdrawing\\n *  funds from the contract to external addresses that were approved by OWNER_ROLE.\\n */\\nabstract contract SP2Withdrawals is\\n  SP2Exchange\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  IMerkleDistributorV1 public immutable MERKLE_DISTRIBUTOR;\\n\\n  // ============ Events ============\\n\\n  event ExternalWithdrewToken(\\n    address recipient,\\n    uint256 amount\\n  );\\n\\n  event ExternalWithdrewOtherToken(\\n    address token,\\n    address recipient,\\n    uint256 amount\\n  );\\n\\n  event ExternalWithdrewEther(\\n    address recipient,\\n    uint256 amount\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IMerkleDistributorV1 merkleDistributor\\n  ) {\\n    MERKLE_DISTRIBUTOR = merkleDistributor;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Claim rewards from the Merkle distributor. They will be held in this contract until\\n   *  withdrawn by the WITHDRAWAL_OPERATOR_ROLE.\\n   *\\n   * @param  cumulativeAmount  The total all-time rewards this contract has earned.\\n   * @param  merkleProof       The Merkle proof for this contract address and cumulative amount.\\n   *\\n   * @return The amount of new reward received.\\n   */\\n  function claimRewardsFromMerkleDistributor(\\n    uint256 cumulativeAmount,\\n    bytes32[] calldata merkleProof\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(WITHDRAWAL_OPERATOR_ROLE)\\n    returns (uint256)\\n  {\\n    return MERKLE_DISTRIBUTOR.claimRewards(cumulativeAmount, merkleProof);\\n  }\\n\\n  /**\\n   * @notice Withdraw a token amount in excess of the borrowed balance, or an amount approved by\\n   *  the GUARDIAN_ROLE.\\n   *\\n   *  The contract may hold an excess balance if, for example, additional funds were added by the\\n   *  contract owner for use with the same exchange account, or if profits were earned from\\n   *  activity on the exchange.\\n   *\\n   * @param  recipient  The recipient to receive tokens. Must be authorized by OWNER_ROLE.\\n   */\\n  function externalWithdrawToken(\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(WITHDRAWAL_OPERATOR_ROLE)\\n    onlyAllowedRecipient(recipient)\\n  {\\n    // If we are approved for the full amount, then skip the borrowed balance check.\\n    uint256 approvedAmount = _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_;\\n    if (approvedAmount >= amount) {\\n      _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_ = approvedAmount.sub(amount);\\n    } else {\\n      uint256 owedBalance = getBorrowedAndDebtBalance();\\n      uint256 tokenBalance = getTokenBalance();\\n      require(tokenBalance > owedBalance, 'SP2Withdrawals: No withdrawable balance');\\n      uint256 availableBalance = tokenBalance.sub(owedBalance);\\n      require(amount <= availableBalance, 'SP2Withdrawals: Amount exceeds withdrawable balance');\\n\\n      // Always decrease the approval amount.\\n      _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_ = 0;\\n    }\\n\\n    TOKEN.safeTransfer(recipient, amount);\\n    emit ExternalWithdrewToken(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw any ERC20 token balance other than the token used for borrowing.\\n   *\\n   * @param  recipient  The recipient to receive tokens. Must be authorized by OWNER_ROLE.\\n   */\\n  function externalWithdrawOtherToken(\\n    address token,\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(WITHDRAWAL_OPERATOR_ROLE)\\n    onlyAllowedRecipient(recipient)\\n  {\\n    require(\\n      token != address(TOKEN),\\n      'SP2Withdrawals: Cannot use this function to withdraw borrowed token'\\n    );\\n    IERC20(token).safeTransfer(recipient, amount);\\n    emit ExternalWithdrewOtherToken(token, recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw any ether.\\n   *\\n   *  Note: The contract is not expected to hold Ether so this is not normally needed.\\n   *\\n   * @param  recipient  The recipient to receive Ether. Must be authorized by OWNER_ROLE.\\n   */\\n  function externalWithdrawEther(\\n    address recipient,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(WITHDRAWAL_OPERATOR_ROLE)\\n    onlyAllowedRecipient(recipient)\\n  {\\n    payable(recipient).transfer(amount);\\n    emit ExternalWithdrewEther(recipient, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v1/impl/SP1Getters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { SP1Storage } from './SP1Storage.sol';\\n\\n/**\\n * @title SP1Getters\\n * @author dYdX\\n *\\n * @dev Simple external getter functions.\\n */\\nabstract contract SP1Getters is\\n  SP1Storage\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Check whether a STARK key is on the allowlist for exchange operations.\\n   *\\n   * @param  starkKey  The STARK key to check.\\n   *\\n   * @return Boolean `true` if the STARK key is allowed, otherwise `false`.\\n   */\\n  function isStarkKeyAllowed(\\n    uint256 starkKey\\n  )\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _ALLOWED_STARK_KEYS_[starkKey];\\n  }\\n\\n  /**\\n   * @notice Check whether a recipient is on the allowlist to receive withdrawals.\\n   *\\n   * @param  recipient  The recipient to check.\\n   *\\n   * @return Boolean `true` if the recipient is allowed, otherwise `false`.\\n   */\\n  function isRecipientAllowed(\\n    address recipient\\n  )\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _ALLOWED_RECIPIENTS_[recipient];\\n  }\\n\\n  /**\\n   * @notice Get the amount approved by the guardian for external withdrawals.\\n   *  Note that withdrawals are always permitted if the amount is in excess of the borrowed amount.\\n   *\\n   * @return The amount approved for external withdrawals.\\n   */\\n  function getApprovedAmountForExternalWithdrawal()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_;\\n  }\\n\\n  /**\\n   * @notice Check whether this borrower contract is restricted from new borrowing, as well as\\n   *  restricted from depositing borrowed funds to the exchange.\\n   *\\n   * @return Boolean `true` if the borrower is restricted, otherwise `false`.\\n   */\\n  function isBorrowingRestricted()\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return _IS_BORROWING_RESTRICTED_;\\n  }\\n\\n  /**\\n   * @notice Get the timestamp at which a forced trade request was queued.\\n   *\\n   * @param  argsHash  The hash of the forced trade request args.\\n   *\\n   * @return Timestamp at which the forced trade was queued, or zero, if it was not queued or was\\n   *  vetoed by the VETO_GUARDIAN_ROLE.\\n   */\\n  function getQueuedForcedTradeTimestamp(\\n    bytes32 argsHash\\n  )\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return _QUEUED_FORCED_TRADE_TIMESTAMPS_[argsHash];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v2/impl/SP2Guardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { ILiquidityStakingV1 } from '../../../interfaces/ILiquidityStakingV1.sol';\\nimport { IStarkPerpetual } from '../../../interfaces/IStarkPerpetual.sol';\\nimport { SP1Borrowing } from '../../v1/impl/SP1Borrowing.sol';\\nimport { SP2Exchange } from './SP2Exchange.sol';\\n\\n/**\\n * @title SP2Guardian\\n * @author dYdX\\n *\\n * @dev Defines guardian powers, to be owned or delegated by dYdX governance.\\n */\\nabstract contract SP2Guardian is\\n  SP1Borrowing,\\n  SP2Exchange\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event BorrowingRestrictionChanged(\\n    bool isBorrowingRestricted\\n  );\\n\\n  event GuardianVetoedForcedTradeRequest(\\n    bytes32 argsHash\\n  );\\n\\n  event GuardianUpdateApprovedAmountForExternalWithdrawal(\\n    uint256 amount\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    ILiquidityStakingV1 liquidityStaking,\\n    IStarkPerpetual starkPerpetual,\\n    IERC20 token\\n  )\\n    SP1Borrowing(liquidityStaking, token)\\n    SP2Exchange(starkPerpetual)\\n  {}\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Approve an additional amount for external withdrawal by WITHDRAWAL_OPERATOR_ROLE.\\n   *\\n   * @param  amount  The additional amount to approve for external withdrawal.\\n   *\\n   * @return The new amount approved for external withdrawal.\\n   */\\n  function increaseApprovedAmountForExternalWithdrawal(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n    returns (uint256)\\n  {\\n    uint256 newApprovedAmount = _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_.add(\\n      amount\\n    );\\n    _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_ = newApprovedAmount;\\n    emit GuardianUpdateApprovedAmountForExternalWithdrawal(newApprovedAmount);\\n    return newApprovedAmount;\\n  }\\n\\n  /**\\n   * @notice Set the approved amount for external withdrawal to zero.\\n   *\\n   * @return The amount that was previously approved for external withdrawal.\\n   */\\n  function resetApprovedAmountForExternalWithdrawal()\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n    returns (uint256)\\n  {\\n    uint256 previousApprovedAmount = _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_;\\n    _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_ = 0;\\n    emit GuardianUpdateApprovedAmountForExternalWithdrawal(0);\\n    return previousApprovedAmount;\\n  }\\n\\n  /**\\n   * @notice Guardian method to restrict borrowing or depositing borrowed funds to the exchange.\\n   */\\n  function guardianSetBorrowingRestriction(\\n    bool isBorrowingRestricted\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    _IS_BORROWING_RESTRICTED_ = isBorrowingRestricted;\\n    emit BorrowingRestrictionChanged(isBorrowingRestricted);\\n  }\\n\\n  /**\\n   * @notice Guardian method to repay this contract's borrowed balance, using this contract's funds.\\n   *\\n   * @param  amount  Amount to repay.\\n   */\\n  function guardianRepayBorrow(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    _repayBorrow(amount, true);\\n  }\\n\\n  /**\\n   * @notice Guardian method to repay a debt balance owed by the borrower.\\n   *\\n   * @param  amount  Amount to repay.\\n   */\\n  function guardianRepayDebt(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    _repayDebt(amount, true);\\n  }\\n\\n  /**\\n   * @notice Guardian method to trigger a withdrawal. This will transfer funds from StarkPerpetual\\n   *  to this contract. This requires a (slow) withdrawal from L2 to have been previously processed.\\n   *\\n   *  Note: This function is intentionally not protected by the onlyAllowedKey modifier.\\n   *\\n   * @return The ERC20 token amount received by this contract.\\n   */\\n  function guardianWithdrawFromExchange(\\n    uint256 starkKey,\\n    uint256 assetType\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n    returns (uint256)\\n  {\\n    return _withdrawFromExchange(starkKey, assetType, true);\\n  }\\n\\n  /**\\n   * @notice Guardian method to trigger a forced withdrawal request.\\n   *  Reverts if the borrower has no overdue debt.\\n   *\\n   *  Note: This function is intentionally not protected by the onlyAllowedKey modifier.\\n   */\\n  function guardianForcedWithdrawalRequest(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    uint256 quantizedAmount,\\n    bool premiumCost\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    require(\\n      getDebtBalance() > 0,\\n      'SP2Guardian: Cannot call forced action if borrower has no overdue debt'\\n    );\\n    _forcedWithdrawalRequest(\\n      starkKey,\\n      vaultId,\\n      quantizedAmount,\\n      premiumCost,\\n      true // isGuardianAction\\n    );\\n  }\\n\\n  /**\\n   * @notice Guardian method to trigger a forced trade request.\\n   *  Reverts if the borrower has no overdue debt.\\n   *\\n   *  Note: This function is intentionally not protected by the onlyAllowedKey modifier.\\n   */\\n  function guardianForcedTradeRequest(\\n    uint256[12] calldata args,\\n    bytes calldata signature\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    require(\\n      getDebtBalance() > 0,\\n      'SP2Guardian: Cannot call forced action if borrower has no overdue debt'\\n    );\\n    _forcedTradeRequest(args, signature, true);\\n  }\\n\\n  /**\\n   * @notice Guardian method to prevent queued forced trade requests from being executed.\\n   *\\n   *  May only be called by VETO_GUARDIAN_ROLE.\\n   *\\n   * @param  argsHashes  An array of hashes for each forced trade request to veto.\\n   */\\n  function guardianVetoForcedTradeRequests(\\n    bytes32[] calldata argsHashes\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(VETO_GUARDIAN_ROLE)\\n  {\\n    for (uint256 i = 0; i < argsHashes.length; i++) {\\n      bytes32 argsHash = argsHashes[i];\\n      _QUEUED_FORCED_TRADE_TIMESTAMPS_[argsHash] = 0;\\n      emit GuardianVetoedForcedTradeRequest(argsHash);\\n    }\\n  }\\n\\n  /**\\n   * @notice Guardian method to request to cancel a pending deposit to the exchange.\\n   *\\n   * @param  starkKey   The STARK key of the account.\\n   * @param  assetType  The exchange asset ID for the deposit.\\n   * @param  vaultId    The exchange position ID for the deposit.\\n   *\\n   *  Note: This function is intentionally not protected by the onlyAllowedKey modifier.\\n   */\\n  function guardianDepositCancel(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    _depositCancel(starkKey, assetType, vaultId, true);\\n  }\\n\\n  /**\\n   * @notice Guardian method to reclaim a canceled pending deposit to the exchange. Requires\\n   * that `depositCancel` was previously called.\\n   *\\n   * @param  starkKey   The STARK key of the account.\\n   * @param  assetType  The exchange asset ID for the deposit.\\n   * @param  vaultId    The exchange position ID for the deposit.\\n   *\\n   *  Note: This function is intentionally not protected by the onlyAllowedKey modifier.\\n   */\\n  function guardianDepositReclaim(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(GUARDIAN_ROLE)\\n  {\\n    _depositReclaim(starkKey, assetType, vaultId, true);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v2/impl/SP2Owner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeERC20 } from '../../../dependencies/open-zeppelin/SafeERC20.sol';\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { IStarkPerpetual } from '../../../interfaces/IStarkPerpetual.sol';\\nimport { SP1Borrowing } from '../../v1/impl/SP1Borrowing.sol';\\nimport { SP2Exchange } from './SP2Exchange.sol';\\n\\n/**\\n * @title SP2Owner\\n * @author dYdX\\n *\\n * @dev Actions which may be called only by OWNER_ROLE. These include actions with a larger amount\\n *  of control over the funds held by the contract.\\n */\\nabstract contract SP2Owner is\\n  SP1Borrowing,\\n  SP2Exchange\\n{\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  /// @notice Time that must elapse before a queued forced trade request can be submitted.\\n  uint256 public constant FORCED_TRADE_WAITING_PERIOD = 7 days;\\n\\n  /// @notice Max time that may elapse after the waiting period before a queued forced trade\\n  ///  request expires.\\n  uint256 public constant FORCED_TRADE_GRACE_PERIOD = 7 days;\\n\\n  // ============ Events ============\\n\\n  event UpdatedStarkKey(\\n    uint256 starkKey,\\n    bool isAllowed\\n  );\\n\\n  event UpdatedExternalRecipient(\\n    address recipient,\\n    bool isAllowed\\n  );\\n\\n  event QueuedForcedTradeRequest(\\n    uint256[12] args,\\n    bytes32 argsHash\\n  );\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Allow exchange functions to be called for a particular STARK key.\\n   *\\n   *  Will revert if the STARK key is not registered to this contract's address on the\\n   *  StarkPerpetual contract.\\n   *\\n   * @param  starkKey  The STARK key to allow.\\n   */\\n  function allowStarkKey(\\n    uint256 starkKey\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    // This will revert with 'USER_UNREGISTERED' if the STARK key was not registered.\\n    address ethKey = STARK_PERPETUAL.getEthKey(starkKey);\\n\\n    // Require the STARK key to be registered to this contract before we allow it to be used.\\n    require(ethKey == address(this), 'SP2Owner: STARK key not registered to this contract');\\n\\n    require(!_ALLOWED_STARK_KEYS_[starkKey], 'SP2Owner: STARK key already allowed');\\n    _ALLOWED_STARK_KEYS_[starkKey] = true;\\n    emit UpdatedStarkKey(starkKey, true);\\n  }\\n\\n  /**\\n   * @notice Remove a STARK key from the allowed list.\\n   *\\n   * @param  starkKey  The STARK key to disallow.\\n   */\\n  function disallowStarkKey(\\n    uint256 starkKey\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    require(_ALLOWED_STARK_KEYS_[starkKey], 'SP2Owner: STARK key already disallowed');\\n    _ALLOWED_STARK_KEYS_[starkKey] = false;\\n    emit UpdatedStarkKey(starkKey, false);\\n  }\\n\\n  /**\\n   * @notice Allow withdrawals of excess funds to be made to a particular recipient.\\n   *\\n   * @param  recipient  The recipient to allow.\\n   */\\n  function allowExternalRecipient(\\n    address recipient\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    require(!_ALLOWED_RECIPIENTS_[recipient], 'SP2Owner: Recipient already allowed');\\n    _ALLOWED_RECIPIENTS_[recipient] = true;\\n    emit UpdatedExternalRecipient(recipient, true);\\n  }\\n\\n  /**\\n   * @notice Remove a recipient from the allowed list.\\n   *\\n   * @param  recipient  The recipient to disallow.\\n   */\\n  function disallowExternalRecipient(\\n    address recipient\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    require(_ALLOWED_RECIPIENTS_[recipient], 'SP2Owner: Recipient already disallowed');\\n    _ALLOWED_RECIPIENTS_[recipient] = false;\\n    emit UpdatedExternalRecipient(recipient, false);\\n  }\\n\\n  /**\\n   * @notice Set ERC20 token allowance for the exchange contract.\\n   *\\n   * @param  token   The ERC20 token to set the allowance for.\\n   * @param  amount  The new allowance amount.\\n   */\\n  function setExchangeContractAllowance(\\n    address token,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    // SafeERC20 safeApprove requires setting to zero first.\\n    IERC20(token).safeApprove(address(STARK_PERPETUAL), 0);\\n    IERC20(token).safeApprove(address(STARK_PERPETUAL), amount);\\n  }\\n\\n  /**\\n   * @notice Set ERC20 token allowance for the staking contract.\\n   *\\n   * @param  token   The ERC20 token to set the allowance for.\\n   * @param  amount  The new allowance amount.\\n   */\\n  function setStakingContractAllowance(\\n    address token,\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    // SafeERC20 safeApprove requires setting to zero first.\\n    IERC20(token).safeApprove(address(LIQUIDITY_STAKING), 0);\\n    IERC20(token).safeApprove(address(LIQUIDITY_STAKING), amount);\\n  }\\n\\n  /**\\n   * @notice Request a forced withdrawal from the exchange.\\n   *\\n   * @param  starkKey         The STARK key of the account. Must be authorized by OWNER_ROLE.\\n   * @param  vaultId          The exchange position ID for the account to deposit to.\\n   * @param  quantizedAmount  The withdrawal amount denominated in the exchange base units.\\n   * @param  premiumCost      Whether to pay a higher fee for faster inclusion in certain scenarios.\\n   */\\n  function forcedWithdrawalRequest(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    uint256 quantizedAmount,\\n    bool premiumCost\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n    onlyAllowedKey(starkKey)\\n  {\\n    _forcedWithdrawalRequest(starkKey, vaultId, quantizedAmount, premiumCost, false);\\n  }\\n\\n  /**\\n   * @notice Queue a forced trade request to be submitted after the waiting period.\\n   *\\n   * @param  args  Arguments for the forced trade request.\\n   */\\n  function queueForcedTradeRequest(\\n    uint256[12] calldata args\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n  {\\n    bytes32 argsHash = keccak256(abi.encodePacked(args));\\n    _QUEUED_FORCED_TRADE_TIMESTAMPS_[argsHash] = block.timestamp;\\n    emit QueuedForcedTradeRequest(args, argsHash);\\n  }\\n\\n  /**\\n   * @notice Submit a forced trade request that was previously queued.\\n   *\\n   * @param  args       Arguments for the forced trade request.\\n   * @param  signature  The signature of the counterparty to the trade.\\n   */\\n  function forcedTradeRequest(\\n    uint256[12] calldata args,\\n    bytes calldata signature\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n    onlyAllowedKey(args[0]) // starkKeyA\\n  {\\n    bytes32 argsHash = keccak256(abi.encodePacked(args));\\n    uint256 timestamp = _QUEUED_FORCED_TRADE_TIMESTAMPS_[argsHash];\\n    require(\\n      timestamp != 0,\\n      'SP2Owner: Forced trade not queued or was vetoed'\\n    );\\n    uint256 elapsed = block.timestamp.sub(timestamp);\\n    require(\\n      elapsed >= FORCED_TRADE_WAITING_PERIOD,\\n      'SP2Owner: Waiting period has not elapsed for forced trade'\\n    );\\n    require(\\n      elapsed <= FORCED_TRADE_WAITING_PERIOD.add(FORCED_TRADE_GRACE_PERIOD),\\n      'SP2Owner: Grace period has elapsed for forced trade'\\n    );\\n    _QUEUED_FORCED_TRADE_TIMESTAMPS_[argsHash] = 0;\\n    _forcedTradeRequest(args, signature, false);\\n  }\\n\\n  /**\\n   * @notice Request to cancel a pending deposit to the exchange.\\n   *\\n   * @param  starkKey   The STARK key of the account. Must be authorized by OWNER_ROLE.\\n   * @param  assetType  The exchange asset ID for the deposit.\\n   * @param  vaultId    The exchange position ID for the deposit.\\n   */\\n  function depositCancel(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n    onlyAllowedKey(starkKey)\\n  {\\n    _depositCancel(starkKey, assetType, vaultId, false);\\n  }\\n\\n  /**\\n   * @notice Reclaim a canceled pending deposit to the exchange. Requires that `depositCancel`\\n   *  was previously called.\\n   *\\n   * @param  starkKey   The STARK key of the account. Must be authorized by OWNER_ROLE.\\n   * @param  assetType  The exchange asset ID for the deposit.\\n   * @param  vaultId    The exchange position ID for the deposit.\\n   */\\n  function depositReclaim(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(OWNER_ROLE)\\n    onlyAllowedKey(starkKey)\\n  {\\n    _depositReclaim(starkKey, assetType, vaultId, false);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v2/impl/SP2Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { IStarkPerpetual } from '../../../interfaces/IStarkPerpetual.sol';\\nimport { SP1Balances } from '../../v1/impl/SP1Balances.sol';\\n\\n/**\\n * @title SP2Exchange\\n * @author dYdX\\n *\\n * @dev Handles calls to the StarkPerpetual contract, for interacting with the dYdX L2 exchange.\\n *\\n *  Standard exchange operation is handled by EXCHANGE_OPERATOR_ROLE. The “forced” actions can only\\n *  be called by the OWNER_ROLE or GUARDIAN_ROLE. Some other functions are also callable by\\n *  the GUARDIAN_ROLE.\\n *\\n *  See SP1Roles, SP2Guardian, SP2Owner, and SP2Withdrawals.\\n */\\nabstract contract SP2Exchange is\\n  SP1Balances\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  IStarkPerpetual public immutable STARK_PERPETUAL;\\n\\n  // ============ Events ============\\n\\n  event DepositedToExchange(\\n    uint256 starkKey,\\n    uint256 starkAssetType,\\n    uint256 starkVaultId,\\n    uint256 tokenAmount\\n  );\\n\\n  event WithdrewFromExchange(\\n    uint256 starkKey,\\n    uint256 starkAssetType,\\n    uint256 tokenAmount,\\n    bool isGuardianAction\\n  );\\n\\n  /// @dev Limited fields included. Details can be retrieved from Starkware logs if needed.\\n  event RequestedForcedWithdrawal(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    bool isGuardianAction\\n  );\\n\\n  /// @dev Limited fields included. Details can be retrieved from Starkware logs if needed.\\n  event RequestedForcedTrade(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    bool isGuardianAction\\n  );\\n\\n  event DepositCanceled(\\n    uint256 starkKey,\\n    uint256 starkAssetType,\\n    uint256 vaultId,\\n    bool isGuardianAction\\n  );\\n\\n  event DepositReclaimed(\\n    uint256 starkKey,\\n    uint256 starkAssetType,\\n    uint256 vaultId,\\n    uint256 fundsReclaimed,\\n    bool isGuardianAction\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    IStarkPerpetual starkPerpetual\\n  ) {\\n    STARK_PERPETUAL = starkPerpetual;\\n  }\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Deposit funds to the exchange.\\n   *\\n   *  IMPORTANT: The caller is responsible for providing `quantizedAmount` in the right units.\\n   *             Currently, the exchange collateral is USDC, denominated in ERC20 token units, but\\n   *             this could change.\\n   *\\n   * @param  starkKey         The STARK key of the account. Must be authorized by OWNER_ROLE.\\n   * @param  assetType        The exchange asset ID for the asset to deposit.\\n   * @param  vaultId          The exchange position ID for the account to deposit to.\\n   * @param  quantizedAmount  The deposit amount denominated in the exchange base units.\\n   *\\n   * @return The ERC20 token amount spent.\\n   */\\n  function depositToExchange(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    uint256 quantizedAmount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(EXCHANGE_OPERATOR_ROLE)\\n    onlyAllowedKey(starkKey)\\n    returns (uint256)\\n  {\\n    // Deposit and get the deposited token amount.\\n    uint256 startingBalance = getTokenBalance();\\n    STARK_PERPETUAL.deposit(starkKey, assetType, vaultId, quantizedAmount);\\n    uint256 endingBalance = getTokenBalance();\\n    uint256 tokenAmount = startingBalance.sub(endingBalance);\\n\\n    // Disallow depositing borrowed funds to the exchange if the guardian has restricted borrowing.\\n    if (_IS_BORROWING_RESTRICTED_) {\\n      require(\\n        endingBalance >= getBorrowedAndDebtBalance(),\\n        'SP2Exchange: Cannot deposit borrowed funds to the exchange while Restricted'\\n      );\\n    }\\n\\n    emit DepositedToExchange(starkKey, assetType, vaultId, tokenAmount);\\n    return tokenAmount;\\n  }\\n\\n  /**\\n   * @notice Trigger a withdrawal of account funds held in the exchange contract. This can be\\n   *  called after a (slow) withdrawal has already been processed by the L2 exchange.\\n   *\\n   * @param  starkKey   The STARK key of the account. Must be authorized by OWNER_ROLE.\\n   * @param  assetType  The exchange asset ID for the asset to withdraw.\\n   *\\n   * @return The ERC20 token amount received by this contract.\\n   */\\n  function withdrawFromExchange(\\n    uint256 starkKey,\\n    uint256 assetType\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(EXCHANGE_OPERATOR_ROLE)\\n    onlyAllowedKey(starkKey)\\n    returns (uint256)\\n  {\\n    return _withdrawFromExchange(starkKey, assetType, false);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _withdrawFromExchange(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    bool isGuardianAction\\n  )\\n    internal\\n    returns (uint256)\\n  {\\n    uint256 startingBalance = getTokenBalance();\\n    STARK_PERPETUAL.withdraw(starkKey, assetType);\\n    uint256 endingBalance = getTokenBalance();\\n    uint256 tokenAmount = endingBalance.sub(startingBalance);\\n    emit WithdrewFromExchange(starkKey, assetType, tokenAmount, isGuardianAction);\\n    return tokenAmount;\\n  }\\n\\n  function _forcedWithdrawalRequest(\\n    uint256 starkKey,\\n    uint256 vaultId,\\n    uint256 quantizedAmount,\\n    bool premiumCost,\\n    bool isGuardianAction\\n  )\\n    internal\\n  {\\n    STARK_PERPETUAL.forcedWithdrawalRequest(starkKey, vaultId, quantizedAmount, premiumCost);\\n    emit RequestedForcedWithdrawal(starkKey, vaultId, isGuardianAction);\\n  }\\n\\n  function _forcedTradeRequest(\\n    uint256[12] calldata args,\\n    bytes calldata signature,\\n    bool isGuardianAction\\n  )\\n    internal\\n  {\\n    // Split into two functions to avoid error 'call stack too deep'.\\n    if (args[11] != 0) {\\n      _forcedTradeRequestPremiumCostTrue(args, signature);\\n    } else {\\n      _forcedTradeRequestPremiumCostFalse(args, signature);\\n    }\\n    emit RequestedForcedTrade(\\n      args[0], // starkKeyA\\n      args[2], // vaultIdA\\n      isGuardianAction\\n    );\\n  }\\n\\n  function _depositCancel(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    bool isGuardianAction\\n  )\\n    internal \\n  {\\n    STARK_PERPETUAL.depositCancel(starkKey, assetType, vaultId);\\n    emit DepositCanceled(starkKey, assetType, vaultId, isGuardianAction);\\n  }\\n\\n  function _depositReclaim(\\n    uint256 starkKey,\\n    uint256 assetType,\\n    uint256 vaultId,\\n    bool isGuardianAction\\n  )\\n    internal \\n  {\\n    uint256 startingBalance = getTokenBalance();\\n    STARK_PERPETUAL.depositReclaim(starkKey, assetType, vaultId);\\n    uint256 endingBalance = getTokenBalance();\\n    uint256 tokenAmount = endingBalance.sub(startingBalance);\\n    emit DepositReclaimed(\\n      starkKey,\\n      assetType,\\n      vaultId,\\n      tokenAmount,\\n      isGuardianAction\\n    );\\n  }\\n\\n  // ============ Private Functions ============\\n\\n  // Split into two functions to avoid error 'call stack too deep'.\\n  function _forcedTradeRequestPremiumCostTrue(\\n    uint256[12] calldata args,\\n    bytes calldata signature\\n  )\\n    private\\n  {\\n    STARK_PERPETUAL.forcedTradeRequest(\\n      args[0],      // starkKeyA\\n      args[1],      // starkKeyB\\n      args[2],      // vaultIdA\\n      args[3],      // vaultIdB\\n      args[4],      // collateralAssetId\\n      args[5],      // syntheticAssetId\\n      args[6],      // amountCollateral\\n      args[7],      // amountSynthetic\\n      args[8] != 0, // aIsBuyingSynthetic\\n      args[9],      // submissionExpirationTime\\n      args[10],     // nonce\\n      signature,\\n      true          // premiumCost\\n    );\\n  }\\n\\n  // Split into two functions to avoid error 'call stack too deep'.\\n  function _forcedTradeRequestPremiumCostFalse(\\n    uint256[12] calldata args,\\n    bytes calldata signature\\n  )\\n    private\\n  {\\n    STARK_PERPETUAL.forcedTradeRequest(\\n      args[0],      // starkKeyA\\n      args[1],      // starkKeyB\\n      args[2],      // vaultIdA\\n      args[3],      // vaultIdB\\n      args[4],      // collateralAssetId\\n      args[5],      // syntheticAssetId\\n      args[6],      // amountCollateral\\n      args[7],      // amountSynthetic\\n      args[8] != 0, // aIsBuyingSynthetic\\n      args[9],      // submissionExpirationTime\\n      args[10],     // nonce\\n      signature,\\n      false         // premiumCost\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v1/impl/SP1Balances.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { ILiquidityStakingV1 } from '../../../interfaces/ILiquidityStakingV1.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { SP1Roles } from './SP1Roles.sol';\\n\\n/**\\n * @title SP1Balances\\n * @author dYdX\\n *\\n * @dev Contains common constants and functions related to token balances.\\n */\\nabstract contract SP1Balances is\\n  SP1Roles\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Constants ============\\n\\n  IERC20 public immutable TOKEN;\\n\\n  ILiquidityStakingV1 public immutable LIQUIDITY_STAKING;\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    ILiquidityStakingV1 liquidityStaking,\\n    IERC20 token\\n  ) {\\n    LIQUIDITY_STAKING = liquidityStaking;\\n    TOKEN = token;\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  function getAllocatedBalanceCurrentEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return LIQUIDITY_STAKING.getAllocatedBalanceCurrentEpoch(address(this));\\n  }\\n\\n  function getAllocatedBalanceNextEpoch()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return LIQUIDITY_STAKING.getAllocatedBalanceNextEpoch(address(this));\\n  }\\n\\n  function getBorrowableAmount()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    if (_IS_BORROWING_RESTRICTED_) {\\n      return 0;\\n    }\\n    return LIQUIDITY_STAKING.getBorrowableAmount(address(this));\\n  }\\n\\n  function getBorrowedBalance()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return LIQUIDITY_STAKING.getBorrowedBalance(address(this));\\n  }\\n\\n  function getDebtBalance()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return LIQUIDITY_STAKING.getBorrowerDebtBalance(address(this));\\n  }\\n\\n  function getBorrowedAndDebtBalance()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return getBorrowedBalance().add(getDebtBalance());\\n  }\\n\\n  function getTokenBalance()\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return TOKEN.balanceOf(address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../dependencies/open-zeppelin/SafeMath.sol';\\n\\n/**\\n * @title Math\\n * @author dYdX\\n *\\n * @dev Library for non-standard Math functions.\\n */\\nlibrary Math {\\n  using SafeMath for uint256;\\n\\n  // ============ Library Functions ============\\n\\n  /**\\n   * @dev Return `ceil(numerator / denominator)`.\\n   */\\n  function divRoundUp(\\n    uint256 numerator,\\n    uint256 denominator\\n  )\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    if (numerator == 0) {\\n      // SafeMath will check for zero denominator\\n      return SafeMath.div(0, denominator);\\n    }\\n    return numerator.sub(1).div(denominator).add(1);\\n  }\\n\\n  /**\\n   * @dev Returns the minimum between a and b.\\n   */\\n  function min(\\n    uint256 a,\\n    uint256 b\\n  )\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the maximum between a and b.\\n   */\\n  function max(\\n    uint256 a,\\n    uint256 b\\n  )\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return a > b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v1/impl/SP1Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SP1Storage } from './SP1Storage.sol';\\n\\n/**\\n * @title SP1Roles\\n * @author dYdX\\n *\\n * @dev Defines roles used in the StarkProxyV1 contract. The hierarchy and powers of each role\\n *  are described below. Not all roles need to be used.\\n *\\n *  Overview:\\n *\\n *    During operation of this contract, funds will flow between the following three\\n *    contracts:\\n *\\n *        LiquidityStaking <> StarkProxy <> StarkPerpetual\\n *\\n *    Actions which move fund from left to right are called “open” actions, whereas actions which\\n *    move funds from right to left are called “close” actions.\\n *\\n *    Also note that the “forced” actions (forced trade and forced withdrawal) require special care\\n *    since they directly impact the financial risk of positions held on the exchange.\\n *\\n *  Roles:\\n *\\n *    GUARDIAN_ROLE\\n *      | -> May perform “close” actions as defined above, but “forced” actions can only be taken\\n *      |    if the borrower has an outstanding debt balance.\\n *      | -> May restrict “open” actions as defined above, except w.r.t. funds in excess of the\\n *      |    borrowed balance.\\n *      | -> May approve a token amount to be withdrawn externally by the WITHDRAWAL_OPERATOR_ROLE\\n *      |    to an allowed address.\\n *      |\\n *      +-- VETO_GUARDIAN_ROLE\\n *            -> May veto forced trade requests initiated by the owner, during the waiting period.\\n *\\n *    OWNER_ROLE\\n *      | -> May add or remove allowed recipients who may receive excess funds.\\n *      | -> May add or remove allowed STARK keys for use on the exchange.\\n *      | -> May set ERC20 allowances on the LiquidityStakingV1 and StarkPerpetual contracts.\\n *      | -> May call the “forced” actions: forcedWithdrawalRequest and forcedTradeRequest.\\n *      |\\n *      +-- DELEGATION_ADMIN_ROLE\\n *            |\\n *            +-- BORROWER_ROLE\\n *            |     -> May call functions on LiquidityStakingV1: autoPayOrBorrow, borrow, repay,\\n *            |        and repayDebt.\\n *            |\\n *            +-- EXCHANGE_OPERATOR_ROLE\\n *            |     -> May call functions on StarkPerpetual: depositToExchange and\\n *            |        withdrawFromExchange.\\n *            |\\n *            +-- WITHDRAWAL_OPERATOR_ROLE\\n *                  -> May withdraw funds in excess of the borrowed balance to an allowed recipient.\\n */\\nabstract contract SP1Roles is\\n  SP1Storage\\n{\\n  bytes32 public constant GUARDIAN_ROLE = keccak256('GUARDIAN_ROLE');\\n  bytes32 public constant VETO_GUARDIAN_ROLE = keccak256('VETO_GUARDIAN_ROLE');\\n  bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n  bytes32 public constant DELEGATION_ADMIN_ROLE = keccak256('DELEGATION_ADMIN_ROLE');\\n  bytes32 public constant BORROWER_ROLE = keccak256('BORROWER_ROLE');\\n  bytes32 public constant EXCHANGE_OPERATOR_ROLE = keccak256('EXCHANGE_OPERATOR_ROLE');\\n  bytes32 public constant WITHDRAWAL_OPERATOR_ROLE = keccak256('WITHDRAWAL_OPERATOR_ROLE');\\n\\n  function __SP1Roles_init(\\n    address guardian\\n  )\\n    internal\\n  {\\n    // Assign GUARDIAN_ROLE.\\n    _setupRole(GUARDIAN_ROLE, guardian);\\n\\n    // Assign OWNER_ROLE and DELEGATION_ADMIN_ROLE to the sender.\\n    _setupRole(OWNER_ROLE, msg.sender);\\n    _setupRole(DELEGATION_ADMIN_ROLE, msg.sender);\\n\\n    // Set admins for all roles. (Don't use the default admin role.)\\n    _setRoleAdmin(GUARDIAN_ROLE, GUARDIAN_ROLE);\\n    _setRoleAdmin(VETO_GUARDIAN_ROLE, GUARDIAN_ROLE);\\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(DELEGATION_ADMIN_ROLE, OWNER_ROLE);\\n    _setRoleAdmin(BORROWER_ROLE, DELEGATION_ADMIN_ROLE);\\n    _setRoleAdmin(EXCHANGE_OPERATOR_ROLE, DELEGATION_ADMIN_ROLE);\\n    _setRoleAdmin(WITHDRAWAL_OPERATOR_ROLE, DELEGATION_ADMIN_ROLE);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v1/impl/SP1Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {\\n  AccessControlUpgradeable\\n} from '../../../dependencies/open-zeppelin/AccessControlUpgradeable.sol';\\nimport { ReentrancyGuard } from '../../../utils/ReentrancyGuard.sol';\\nimport { VersionedInitializable } from '../../../utils/VersionedInitializable.sol';\\n\\n/**\\n * @title SP1Storage\\n * @author dYdX\\n *\\n * @dev Storage contract. Contains or inherits from all contracts with storage.\\n */\\nabstract contract SP1Storage is\\n  AccessControlUpgradeable,\\n  ReentrancyGuard,\\n  VersionedInitializable\\n{\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @dev Modifier to ensure the STARK key is allowed.\\n   */\\n  modifier onlyAllowedKey(\\n    uint256 starkKey\\n  ) {\\n    require(_ALLOWED_STARK_KEYS_[starkKey], 'SP1Storage: STARK key is not on the allowlist');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to ensure the recipient is allowed.\\n   */\\n  modifier onlyAllowedRecipient(\\n    address recipient\\n  ) {\\n    require(_ALLOWED_RECIPIENTS_[recipient], 'SP1Storage: Recipient is not on the allowlist');\\n    _;\\n  }\\n\\n  // ============ Storage ============\\n\\n  mapping(uint256 => bool) internal _ALLOWED_STARK_KEYS_;\\n\\n  mapping(address => bool) internal _ALLOWED_RECIPIENTS_;\\n\\n  /// @dev Note that withdrawals are always permitted if the amount is in excess of the borrowed\\n  ///  amount. Also, this approval only applies to the primary ERC20 token, `TOKEN`.\\n  uint256 internal _APPROVED_AMOUNT_FOR_EXTERNAL_WITHDRAWAL_;\\n\\n  /// @dev Note that this is different from _IS_BORROWING_RESTRICTED_ in LiquidityStakingV1.\\n  bool internal _IS_BORROWING_RESTRICTED_;\\n\\n  /// @dev Mapping from args hash to timestamp.\\n  mapping(bytes32 => uint256) internal _QUEUED_FORCED_TRADE_TIMESTAMPS_;\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './Context.sol';\\nimport './Strings.sol';\\nimport './ERC165.sol';\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n  function grantRole(bytes32 role, address account) external;\\n\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Context, IAccessControlUpgradeable, ERC165 {\\n  struct RoleData {\\n    mapping(address => bool) members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Modifier that checks that an account has a specific role. Reverts\\n   * with a standardized message including the required role.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   *\\n   * _Available since v4.1._\\n   */\\n  modifier onlyRole(bytes32 role) {\\n    _checkRole(role, _msgSender());\\n    _;\\n  }\\n\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return\\n      interfaceId == type(IAccessControlUpgradeable).interfaceId ||\\n      super.supportsInterface(interfaceId);\\n  }\\n\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) public view override returns (bool) {\\n    return _roles[role].members[account];\\n  }\\n\\n  /**\\n   * @dev Revert with a standard message if `account` is missing `role`.\\n   *\\n   * The format of the revert reason is given by the following regular expression:\\n   *\\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n   */\\n  function _checkRole(bytes32 role, address account) internal view {\\n    if (!hasRole(role, account)) {\\n      revert(\\n        string(\\n          abi.encodePacked(\\n            'AccessControl: account ',\\n            Strings.toHexString(uint160(account), 20),\\n            ' is missing role ',\\n            Strings.toHexString(uint256(role), 32)\\n          )\\n        )\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   *\\n   * To change a role's admin, use {_setRoleAdmin}.\\n   */\\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account)\\n    public\\n    virtual\\n    override\\n    onlyRole(getRoleAdmin(role))\\n  {\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) public virtual override {\\n    require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event. Note that unlike {grantRole}, this function doesn't perform any\\n   * checks on the calling account.\\n   *\\n   * [WARNING]\\n   * ====\\n   * This function should only be called from the constructor when setting\\n   * up the initial roles for the system.\\n   *\\n   * Using this function in any other way is effectively circumventing the admin\\n   * system imposed by {AccessControl}.\\n   * ====\\n   */\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  /**\\n   * @dev Sets `adminRole` as ``role``'s admin role.\\n   *\\n   * Emits a {RoleAdminChanged} event.\\n   */\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (!hasRole(role, account)) {\\n      _roles[role].members[account] = true;\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (hasRole(role, account)) {\\n      _roles[role].members[account] = false;\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n\\n  uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\n/**\\n * @title ReentrancyGuard\\n * @author dYdX\\n *\\n * @dev Updated ReentrancyGuard library designed to be used with Proxy Contracts.\\n */\\nabstract contract ReentrancyGuard {\\n  uint256 private constant NOT_ENTERED = 1;\\n  uint256 private constant ENTERED = uint256(int256(-1));\\n\\n  uint256 private _STATUS_;\\n\\n  constructor()\\n    internal\\n  {\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n\\n  modifier nonReentrant() {\\n    require(_STATUS_ != ENTERED, 'ReentrancyGuard: reentrant call');\\n    _STATUS_ = ENTERED;\\n    _;\\n    _STATUS_ = NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\n/**\\n * @title VersionedInitializable\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n */\\nabstract contract VersionedInitializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    uint256 internal lastInitializedRevision = 0;\\n\\n   /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(revision > lastInitializedRevision, \\\"Contract instance has already been initialized\\\");\\n\\n        lastInitializedRevision = revision;\\n\\n        _;\\n\\n    }\\n\\n    /// @dev returns the revision number of the contract.\\n    /// Needs to be defined in the inherited class as a constant.\\n    function getRevision() internal pure virtual returns(uint256);\\n\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n  bytes16 private constant alphabet = '0123456789abcdef';\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n   */\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return '0';\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n   */\\n  function toHexString(uint256 value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0x00';\\n    }\\n    uint256 temp = value;\\n    uint256 length = 0;\\n    while (temp != 0) {\\n      length++;\\n      temp >>= 8;\\n    }\\n    return toHexString(value, length);\\n  }\\n\\n  /**\\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n   */\\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n    bytes memory buffer = new bytes(2 * length + 2);\\n    buffer[0] = '0';\\n    buffer[1] = 'x';\\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\\n      buffer[i] = alphabet[value & 0xf];\\n      value >>= 4;\\n    }\\n    require(value == 0, 'Strings: hex length insufficient');\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport './IERC165.sol';\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/open-zeppelin/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/stark-proxy/v1/impl/SP1Borrowing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport { SafeMath } from '../../../dependencies/open-zeppelin/SafeMath.sol';\\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\\nimport { ILiquidityStakingV1 } from '../../../interfaces/ILiquidityStakingV1.sol';\\nimport { Math } from '../../../utils/Math.sol';\\nimport { SP1Balances } from './SP1Balances.sol';\\n\\n/**\\n * @title SP1Borrowing\\n * @author dYdX\\n *\\n * @dev Handles calls to the LiquidityStaking contract to borrow and repay funds.\\n */\\nabstract contract SP1Borrowing is\\n  SP1Balances\\n{\\n  using SafeMath for uint256;\\n\\n  // ============ Events ============\\n\\n  event Borrowed(\\n    uint256 amount,\\n    uint256 newBorrowedBalance\\n  );\\n\\n  event RepaidBorrow(\\n    uint256 amount,\\n    uint256 newBorrowedBalance,\\n    bool isGuardianAction\\n  );\\n\\n  event RepaidDebt(\\n    uint256 amount,\\n    uint256 newDebtBalance,\\n    bool isGuardianAction\\n  );\\n\\n  // ============ Constructor ============\\n\\n  constructor(\\n    ILiquidityStakingV1 liquidityStaking,\\n    IERC20 token\\n  )\\n    SP1Balances(liquidityStaking, token)\\n  {}\\n\\n  // ============ External Functions ============\\n\\n  /**\\n   * @notice Automatically repay or borrow to bring borrowed balance to the next allocated balance.\\n   *  Must be called during the blackout window, to ensure allocated balance will not change before\\n   *  the start of the next epoch. Reverts if there are insufficient funds to prevent a shortfall.\\n   *\\n   *  Can be called with eth_call to view amounts that will be borrowed or repaid.\\n   *\\n   * @return The newly borrowed amount.\\n   * @return The borrow amount repaid.\\n   * @return The debt amount repaid.\\n   */\\n  function autoPayOrBorrow()\\n    external\\n    nonReentrant\\n    onlyRole(BORROWER_ROLE)\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    // Ensure we are in the blackout window.\\n    require(\\n      LIQUIDITY_STAKING.inBlackoutWindow(),\\n      'SP1Borrowing: Auto-pay may only be used during the blackout window'\\n    );\\n\\n    // Get the borrowed balance, next allocated balance, and token balance.\\n    uint256 borrowedBalance = getBorrowedBalance();\\n    uint256 nextAllocatedBalance = getAllocatedBalanceNextEpoch();\\n    uint256 tokenBalance = getTokenBalance();\\n\\n    // Return values.\\n    uint256 borrowAmount = 0;\\n    uint256 repayBorrowAmount = 0;\\n    uint256 repayDebtAmount = 0;\\n\\n    if (borrowedBalance > nextAllocatedBalance) {\\n      // Make the necessary repayment due by the end of the current epoch.\\n      repayBorrowAmount = borrowedBalance.sub(nextAllocatedBalance);\\n      require(\\n        tokenBalance >= repayBorrowAmount,\\n        'SP1Borrowing: Insufficient funds to avoid falling short on repayment'\\n      );\\n      _repayBorrow(repayBorrowAmount, false);\\n    } else {\\n      // Borrow the max borrowable amount.\\n      borrowAmount = getBorrowableAmount();\\n      if (borrowAmount != 0) {\\n        _borrow(borrowAmount);\\n      }\\n    }\\n\\n    // Finally, use remaining funds to pay any overdue debt.\\n    uint256 debtBalance = getDebtBalance();\\n    repayDebtAmount = Math.min(debtBalance, tokenBalance);\\n    if (repayDebtAmount != 0) {\\n      _repayDebt(repayDebtAmount, false);\\n    }\\n\\n    return (borrowAmount, repayBorrowAmount, repayDebtAmount);\\n  }\\n\\n  function borrow(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(BORROWER_ROLE)\\n  {\\n    // Disallow if the guardian has restricted borrowing.\\n    require(\\n      !_IS_BORROWING_RESTRICTED_,\\n      'SP1Borrowing: Cannot borrow while Restricted'\\n    );\\n\\n    _borrow(amount);\\n  }\\n\\n  function repayBorrow(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(BORROWER_ROLE)\\n  {\\n    _repayBorrow(amount, false);\\n  }\\n\\n  function repayDebt(\\n    uint256 amount\\n  )\\n    external\\n    nonReentrant\\n    onlyRole(BORROWER_ROLE)\\n  {\\n    _repayDebt(amount, false);\\n  }\\n\\n  // ============ Internal Functions ============\\n\\n  function _borrow(\\n    uint256 amount\\n  )\\n    internal\\n  {\\n    LIQUIDITY_STAKING.borrow(amount);\\n    emit Borrowed(amount, getBorrowedBalance());\\n  }\\n\\n  function _repayBorrow(\\n    uint256 amount,\\n    bool isGovernanceAction\\n  )\\n    internal\\n  {\\n    LIQUIDITY_STAKING.repayBorrow(address(this), amount);\\n    emit RepaidBorrow(amount, getBorrowedBalance(), isGovernanceAction);\\n  }\\n\\n  function _repayDebt(\\n    uint256 amount,\\n    bool isGovernanceAction\\n  )\\n    internal\\n  {\\n    LIQUIDITY_STAKING.repayDebt(address(this), amount);\\n    emit RepaidDebt(amount, getDebtBalance(), isGovernanceAction);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ILiquidityStakingV1\",\"name\":\"liquidityStaking\",\"type\":\"address\"},{\"internalType\":\"contract IStarkPerpetual\",\"name\":\"starkPerpetual\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IMerkleDistributorV1\",\"name\":\"merkleDistributor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowedBalance\",\"type\":\"uint256\"}],\"name\":\"Borrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBorrowingRestricted\",\"type\":\"bool\"}],\"name\":\"BorrowingRestrictionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkAssetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"DepositCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkAssetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsReclaimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"DepositReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkAssetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkVaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"DepositedToExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExternalWithdrewEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExternalWithdrewOtherToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExternalWithdrewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GuardianUpdateApprovedAmountForExternalWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"argsHash\",\"type\":\"bytes32\"}],\"name\":\"GuardianVetoedForcedTradeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[12]\",\"name\":\"args\",\"type\":\"uint256[12]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"argsHash\",\"type\":\"bytes32\"}],\"name\":\"QueuedForcedTradeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBorrowedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"RepaidBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebtBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"RepaidDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"RequestedForcedTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"RequestedForcedWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"UpdatedExternalRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"UpdatedStarkKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"starkAssetType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isGuardianAction\",\"type\":\"bool\"}],\"name\":\"WithdrewFromExchange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BORROWER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELEGATION_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXCHANGE_OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FORCED_TRADE_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FORCED_TRADE_WAITING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARDIAN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_STAKING\",\"outputs\":[{\"internalType\":\"contract ILiquidityStakingV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MERKLE_DISTRIBUTOR\",\"outputs\":[{\"internalType\":\"contract IMerkleDistributorV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STARK_PERPETUAL\",\"outputs\":[{\"internalType\":\"contract IStarkPerpetual\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VETO_GUARDIAN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAWAL_OPERATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"allowExternalRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"}],\"name\":\"allowStarkKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoPayOrBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimRewardsFromMerkleDistributor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"depositReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"}],\"name\":\"depositToExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"disallowExternalRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"}],\"name\":\"disallowStarkKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"externalWithdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"externalWithdrawOtherToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"externalWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"args\",\"type\":\"uint256[12]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"forcedTradeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"premiumCost\",\"type\":\"bool\"}],\"name\":\"forcedWithdrawalRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllocatedBalanceCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllocatedBalanceNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApprovedAmountForExternalWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBorrowableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBorrowedAndDebtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBorrowedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDebtBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"argsHash\",\"type\":\"bytes32\"}],\"name\":\"getQueuedForcedTradeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"guardianDepositCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"guardianDepositReclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"args\",\"type\":\"uint256[12]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"guardianForcedTradeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantizedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"premiumCost\",\"type\":\"bool\"}],\"name\":\"guardianForcedWithdrawalRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"guardianRepayBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"guardianRepayDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBorrowingRestricted\",\"type\":\"bool\"}],\"name\":\"guardianSetBorrowingRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"argsHashes\",\"type\":\"bytes32[]\"}],\"name\":\"guardianVetoForcedTradeRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"guardianWithdrawFromExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseApprovedAmountForExternalWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBorrowingRestricted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"isRecipientAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"}],\"name\":\"isStarkKeyAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"args\",\"type\":\"uint256[12]\"}],\"name\":\"queueForcedTradeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetApprovedAmountForExternalWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setExchangeContractAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setStakingContractAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"starkKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetType\",\"type\":\"uint256\"}],\"name\":\"withdrawFromExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StarkProxyV2","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005aa653a076c1dbb47cec8c1b4d152444cad91941000000000000000000000000d54f502e184b6b739d7d27a6410a67dc462d69c8000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000001d3348601968ab85b4bb028979006eac235a588","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}