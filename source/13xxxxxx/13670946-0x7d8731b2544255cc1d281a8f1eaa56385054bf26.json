{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"main/version-5/poolv1-uniswap.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\nimport \\\"../../other/reetrancy.sol\\\";\\nimport \\\"../../other/Initializable.sol\\\";\\n\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n    /**\\n     * @dev Returns the decimal of tokens in existence.\\n     */\\n    function decimals() external view returns (uint8);\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface IOracle{\\n\\tfunction getiTokenDetails(uint _poolIndex) external returns(string memory, string memory,string memory); \\n     function getTokenDetails(uint _poolIndex) external returns(address[] memory,uint[] memory,uint ,uint);\\n}\\n\\ninterface Iitokendeployer{\\n\\tfunction createnewitoken(string calldata _name, string calldata _symbol) external returns(address);\\n}\\n\\ninterface Iitoken{\\n\\tfunction mint(address account, uint256 amount) external returns (bool);\\n\\tfunction burn(address account, uint256 amount) external returns (bool);\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\tfunction totalSupply() external view returns (uint256);\\n}\\n\\ninterface IMAsterChef{\\n\\tfunction depositFromDaaAndDAO(uint256 _pid, uint256 _amount, uint256 vault, address _sender,bool isPremium) external;\\n\\tfunction distributeExitFeeShare(uint256 _amount) external;\\n}\\n\\ninterface IPoolConfiguration{\\n\\t function checkDao(address daoAddress) external returns(bool);\\n\\t function getperformancefees() external view returns(uint256);\\n\\t function getmaxTokenSupported() external view returns(uint256);\\n\\t function getslippagerate() external view returns(uint256);\\n\\t function getoracleaddress() external view returns(address);\\n\\t function getEarlyExitfees() external view returns(uint256);\\n\\t function checkStableCoin(address _stable) external view returns(bool);\\n}\\n\\ninterface DexAggregator{\\n\\tfunction getBestExchangeRate(\\n        IERC20 _tokenIn,\\n        IERC20 _tokenOut,\\n        uint256 _amountIn\\n    ) external payable returns (uint256, uint8);\\n\\tfunction swapFromBestExchange(\\n        IERC20 _tokenIn,\\n        IERC20 _tokenOut,\\n        uint256 _amountIn,\\n        uint256 _amountOutMinimum,\\n        uint24 _exchange\\n    ) external payable returns (uint256);\\n\\n}\\n\\ncontract PoolV2 is ReentrancyGuard,Initializable {\\n    \\n    using SafeMath for uint;\\n\\tusing SafeERC20 for IERC20;\\n\\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n\\taddress public EXCHANGE_CONTRACT;\\n\\taddress public WETH_ADDRESS;\\n\\taddress public baseStableCoin;\\n\\n\\t// ASTRA token Address\\n\\taddress public ASTRTokenAddress;\\n\\t// Manager Account Address\\n\\taddress public managerAddresses;\\n\\t// Pool configuration contract address. This contract manage the configuration for this contract.\\n\\taddress public _poolConf;\\n\\t// Chef contract address for staking\\n\\taddress public poolChef;\\n\\t// Address of itoken deployer. This will contract will be responsible for deploying itokens.\\n    address public itokendeployer;\\n\\t// Structure for storing the pool details\\n\\tstruct PoolInfo {\\n\\t\\t// Array for token addresses.\\n        address[] tokens;    \\n\\t\\t// Weight for each token. Share is calculated by dividing the weight with total weight.\\n        uint256[]  weights;        \\n\\t\\t// Total weight. Sum of all the weight in array.\\n        uint256 totalWeight;\\n\\t\\t// Check if pool is active or not      \\n        bool active; \\n\\t\\t// Next rebalance time for pool/index in unix timestamp        \\n        uint256 rebaltime;\\n\\t\\t// Threshold value. Minimum value after that pool will start buying token\\n        uint256 threshold;\\n\\t\\t// Number of rebalance performed on this pool.\\n        uint256 currentRebalance;\\n\\t\\t// Unix timeseamp for the last rebalance time\\n        uint256 lastrebalance;\\n\\t\\t// itoken Created address\\n\\t\\taddress itokenaddr;\\n\\t\\t// Owner address for owner \\n\\t\\taddress owner;\\n\\t\\t//description for token\\n\\t\\tstring description;\\n    }\\n    struct PoolUser \\n    {   \\n\\t\\t// Balance of user in pool\\n        uint256 currentBalance;\\n\\t\\t// Number of rebalance pupto which user account is synced \\n        uint256 currentPool; \\n\\t\\t// Pending amount for which no tokens are bought\\n        uint256 pendingBalance; \\n\\t\\t// Total amount deposited in stable coin.\\n\\t\\tuint256 USDTdeposit;\\n\\t\\t// ioktne balance for that pool. This will tell the total itoken balance either staked at chef or hold at account.\\n\\t\\tuint256 Itokens;\\n\\t\\t// Check id user account is active\\n        bool active;\\n\\t\\t// Check if user account is whitelisted or not.\\n        bool isenabled;\\n    } \\n    \\n\\t// Mapping for user infor based on the structure created above.\\n    mapping ( uint256 =>mapping(address => PoolUser)) public poolUserInfo; \\n\\n\\t// Array for storing indices details\\n    PoolInfo[] public poolInfo;\\n    \\n\\t// Private array variable use internally by functions.\\n    uint256[] private buf; \\n    \\n    // address[] private _Tokens;\\n    // uint256[] private _Values;\\n    \\n    address[] private _TokensStable;\\n    uint256[] private _ValuesStable;\\n\\n\\t// Mapping to show the token balance for a particular pool.\\n\\tmapping(uint256 => mapping(address => uint256)) public tokenBalances;\\n\\t// Store the tota pool balance\\n\\tmapping(uint256 => uint256) public totalPoolbalance;\\n\\t// Store the pending balance for which tokens are not bought.\\n\\tmapping(uint256 => uint256) public poolPendingbalance;\\n\\t//Track the initial block where user deposit amount.\\n\\tmapping(address =>mapping (uint256 => uint256)) public initialDeposit;\\n\\t//Check if user already exist or not.\\n\\tmapping(address =>mapping (uint256 => bool)) public existingUser;\\n\\n\\tbool public active; \\n\\n\\tmapping(address => bool) public systemAddresses;\\n\\t\\n\\t/**\\n     * @dev Modifier to check if the called is Admin or not.\\n     */\\n\\tmodifier systemOnly {\\n\\t    require(systemAddresses[msg.sender], \\\"EO1\\\");\\n\\t    _;\\n\\t}\\n\\n\\t// Event emitted\\n\\tevent Transfer(address indexed src, address indexed dst, uint wad);\\n\\tevent Withdrawn(address indexed from, uint value);\\n\\tevent WithdrawnToken(address indexed from, address indexed token, uint amount);\\n\\t\\n\\t/**\\n     * Error code:\\n     * EO1: system only\\n     * E02: Invalid Pool Index\\n     * E03: Already whitelisted\\n     * E04: Only manager can whitelist\\n     * E05: Only owner can whitelist\\n     * E06: Invalid config length\\n     * E07: Only whitelisted user\\n     * E08: Only one token allowed\\n     * E09: Deposit some amount\\n     * E10: Only stable coins\\n     * E11: Not enough tokens\\n     * E12: Rebalnce time not reached\\n     * E13: Only owner can update the public pool\\n     * E14: No balance in Pool\\n     * E15: Zero address\\n     * E16: More than allowed token in indices\\n    */\\n\\t\\n\\tfunction initialize(address _ASTRTokenAddress, address poolConfiguration,address _itokendeployer, address _chef,address _exchange, address _weth, address _stable) public initializer{\\n\\t\\trequire(_ASTRTokenAddress != address(0), \\\"E15\\\");\\n\\t\\trequire(poolConfiguration != address(0), \\\"E15\\\");\\n\\t\\trequire(_itokendeployer != address(0), \\\"E15\\\");\\n\\t\\trequire(_chef != address(0), \\\"E15\\\");\\n\\t\\tReentrancyGuard.__init();\\n\\t\\tsystemAddresses[msg.sender] = true;\\n\\t\\tASTRTokenAddress = _ASTRTokenAddress;\\n\\t\\tmanagerAddresses = msg.sender;\\n\\t\\t_poolConf = poolConfiguration;\\n\\t\\titokendeployer = _itokendeployer;\\n\\t\\tpoolChef = _chef;\\n\\t\\tactive = true;\\n\\t\\tEXCHANGE_CONTRACT = _exchange;\\n\\t    WETH_ADDRESS = _weth;\\n\\t    baseStableCoin = _stable;\\n\\t}\\n\\n\\tfunction calculateTotalWeight(uint[] memory _weights) internal view returns(uint){\\n\\t\\tuint _totalWeight;\\n\\t\\t// Calculate total weight for new index.\\n\\t\\tfor(uint i = 0; i < _weights.length; i++) {\\n\\t\\t\\t_totalWeight = _totalWeight.add(_weights[i]);\\n\\t\\t}\\n\\t\\treturn _totalWeight;\\n\\t}\\n\\t/**\\n     * @notice Add public pool\\n     * @param _tokens tokens to purchase in pool.\\n     * @param _weights Weight of new tokens.\\n\\t * @param _threshold Threshold amount to purchase token.\\n\\t * @param _rebalanceTime Next Rebalance time.\\n\\t * @param _name itoken name.\\n\\t * @param _symbol itoken symbol.\\n\\t * @dev Add new public pool by any users.Here any users can add there custom pools\\n     */\\n\\tfunction addPublicPool(address[] memory _tokens, uint[] memory _weights,uint _threshold,uint _rebalanceTime,string memory _name,string memory _symbol,string memory _description) public{\\n        //Currently it will only check if configuration is correct as staking amount is not decided to add the new pool.\\n\\t\\taddress _itokenaddr;\\n\\t\\taddress _poolOwner;\\n\\t\\tuint _poolIndex = poolInfo.length;\\n\\t\\taddress _OracleAddress = IPoolConfiguration(_poolConf).getoracleaddress();\\n\\n\\t\\tif(_tokens.length == 0){\\n\\t\\t\\trequire(systemAddresses[msg.sender], \\\"EO1\\\");\\n\\t\\t\\t(_tokens, _weights,_threshold,_rebalanceTime) = IOracle(_OracleAddress).getTokenDetails(_poolIndex);\\n            // Get the new itoken name and symbol from pool\\n\\t\\t    (_name,_symbol,_description) = IOracle(_OracleAddress).getiTokenDetails(_poolIndex);\\n\\t\\t\\t_poolOwner = address(this);\\n\\t\\t}else{\\n\\t\\t\\t_poolOwner = msg.sender;\\n\\t\\t}\\n\\n\\t\\trequire (_tokens.length == _weights.length, \\\"E06\\\");\\n        require (_tokens.length <= IPoolConfiguration(_poolConf).getmaxTokenSupported(), \\\"E16\\\");\\n\\t\\t// Deploy new itokens\\n        _itokenaddr = Iitokendeployer(itokendeployer).createnewitoken(_name, _symbol);\\n\\t\\t\\n\\t\\t// Add new index.\\n\\t\\tpoolInfo.push(PoolInfo({\\n            tokens : _tokens,   \\n            weights : _weights,        \\n            totalWeight : calculateTotalWeight(_weights),      \\n            active : true,          \\n            rebaltime : _rebalanceTime,\\n            currentRebalance : 0,\\n            threshold: _threshold,\\n            lastrebalance: block.timestamp,\\n\\t\\t    itokenaddr: _itokenaddr,\\n\\t\\t\\towner: _poolOwner,\\n\\t\\t\\tdescription:_description\\n        }));\\n    }\\n\\n\\t/**\\n\\t* @notice Internal function to Buy Astra Tokens.\\n\\t* @param _Amount Amount of Astra token to buy.\\n    * @dev Buy Astra Tokens if user want to pay fees early exit fees by deposit in Astra\\n    */\\n\\tfunction buyAstraToken(uint _Amount) internal returns(uint256){ \\n\\t\\tuint _amount;\\n\\t\\tuint8 _distribution;\\n\\t\\tIERC20(baseStableCoin).approve(EXCHANGE_CONTRACT, _Amount);\\n\\t\\t// Get the expected amount of Astra you will recieve for the stable coin.\\n\\t \\t(_amount, _distribution) = DexAggregator(EXCHANGE_CONTRACT).getBestExchangeRate(IERC20(baseStableCoin), IERC20(ASTRTokenAddress), _Amount);\\n\\t\\tuint256 minReturn = calculateMinimumReturn(_amount);\\n\\t\\t// Swap the stabe coin for Astra\\n\\t\\t_amount = DexAggregator(EXCHANGE_CONTRACT).swapFromBestExchange(IERC20(baseStableCoin), IERC20(ASTRTokenAddress), _Amount, minReturn, _distribution);\\n\\t\\treturn _amount;\\n\\t}\\n\\n\\t/**\\n\\t* @notice Stake Astra Tokens.\\n\\t* @param _amount Amount of Astra token to stake.\\n    * @dev Stake Astra tokens for various functionality like Staking.\\n    */\\n\\tfunction stakeAstra(uint _amount,bool premium)internal{\\n\\t\\t//Approve the astra amount to stake.\\n\\t\\tIERC20(ASTRTokenAddress).approve(address(poolChef),_amount);\\n\\t\\t// Stake the amount on chef contract. It will be staked for 6 months by default 0 pool id will be for the astra pool.\\n\\t\\tIMAsterChef(poolChef).depositFromDaaAndDAO(0,_amount,6,msg.sender,premium);\\n\\t}\\t\\n\\n\\t/**\\n\\t* @notice Calculate Fees.\\n\\t* @param _account User account.\\n\\t* @param _amount Amount user wants to withdraw.\\n\\t* @param _poolIndex Pool Index\\n\\t* @dev Calculate Early Exit fees\\n\\t* feeRate = Early Exit fee rate (Const 2%)\\n    * startBlock = Deposit block\\n    *  withdrawBlock = Withdrawal block \\n    *  n = number of blocks between n1 and n2  \\n    *  Averageblockperday = Average block per day (assumed: 6500) \\n    *  feeconstant =early exit fee cool down period (const 182) \\n    *  Wv = withdrawal value\\n    *  EEFv = Wv x  EEFr  - (EEFr    x n/ABPx t)\\n    *  If EEFv <=0 then EEFv  = 0 \\n\\t */\\n\\n\\t function calculatefee(address _account, uint _amount,uint _poolIndex)internal returns(uint256){\\n\\t\\t// Calculate the early eit fees based on the formula mentioned above.\\n\\t\\t uint256 feeRate = IPoolConfiguration(_poolConf).getEarlyExitfees();\\n\\t\\t uint256 startBlock = initialDeposit[_account][_poolIndex];\\n\\t\\t uint256 withdrawBlock = block.number;\\n\\t\\t uint256 Averageblockperday = 6500;\\n\\t\\t uint256 feeconstant = 182;\\n\\t\\t uint256 blocks = withdrawBlock.sub(startBlock);\\n\\t\\t uint feesValue = feeRate.mul(blocks).div(100);\\n\\t\\t feesValue = feesValue.div(Averageblockperday).div(feeconstant);\\n\\t\\t feesValue = _amount.mul(feeRate).div(100).sub(feesValue);\\n\\t\\t return feesValue;\\n\\t }\\n\\t\\t\\n\\t/**\\n\\t * @notice Buy Tokens.\\n\\t * @param _poolIndex Pool Index.\\n     * @dev Buy token initially once threshold is reached this can only be called by poolIn function\\n     */\\n    function buytokens(uint _poolIndex) internal {\\n\\t// Check if pool configuration is correct or not.\\n\\t// This function is called inernally when user deposit in pool or during rebalance to purchase the tokens for given stable coin amount.\\n     require(_poolIndex<poolInfo.length, \\\"E02\\\");\\n     address[] memory returnedTokens;\\n\\t uint[] memory returnedAmounts;\\n     uint ethValue = poolPendingbalance[_poolIndex]; \\n     uint[] memory buf3;\\n\\t buf = buf3;\\n     // Buy tokens for the pending stable amount\\n     (returnedTokens, returnedAmounts) = swap2(baseStableCoin, ethValue, poolInfo[_poolIndex].tokens, poolInfo[_poolIndex].weights, poolInfo[_poolIndex].totalWeight,buf);\\n     // After tokens are purchased update its details in mapping.\\n      for (uint i = 0; i < returnedTokens.length; i++) {\\n\\t\\t\\ttokenBalances[_poolIndex][returnedTokens[i]] = tokenBalances[_poolIndex][returnedTokens[i]].add(returnedAmounts[i]);\\n\\t  }\\n\\t  // Update the pool details for the purchased tokens\\n\\t  totalPoolbalance[_poolIndex] = totalPoolbalance[_poolIndex].add(ethValue);\\n\\t  poolPendingbalance[_poolIndex] = 0;\\n\\t  if (poolInfo[_poolIndex].currentRebalance == 0){\\n\\t      poolInfo[_poolIndex].currentRebalance = poolInfo[_poolIndex].currentRebalance.add(1);\\n\\t  }\\n\\t\\t\\n    }\\n\\n\\t/**\\n\\t* @param _amount Amount of user to Update.\\n\\t* @param _poolIndex Pool Index.\\n    * @dev Update user Info at the time of deposit in pool\\n    */\\n    \\n    function updateuserinfo(uint _amount,uint _poolIndex) internal { \\n        // Update the user details in mapping. This function is called internally when user deposit in pool or withdraw from pool.\\n        if(poolUserInfo[_poolIndex][msg.sender].active){\\n\\t\\t\\t// Check if user account is synced with latest rebalance or not. In case not it will update its details.\\n            if(poolUserInfo[_poolIndex][msg.sender].currentPool < poolInfo[_poolIndex].currentRebalance){\\n                poolUserInfo[_poolIndex][msg.sender].currentBalance = poolUserInfo[_poolIndex][msg.sender].currentBalance.add(poolUserInfo[_poolIndex][msg.sender].pendingBalance);\\n                poolUserInfo[_poolIndex][msg.sender].currentPool = poolInfo[_poolIndex].currentRebalance;\\n                poolUserInfo[_poolIndex][msg.sender].pendingBalance = _amount;\\n            }\\n            else{\\n               poolUserInfo[_poolIndex][msg.sender].pendingBalance = poolUserInfo[_poolIndex][msg.sender].pendingBalance.add(_amount); \\n            }\\n        }\\n       \\n    } \\n\\n\\t/**\\n     * @dev Get the Token details in Index pool.\\n     */\\n    function getIndexTokenDetails(uint _poolIndex) external view returns(address[] memory){\\n        return (poolInfo[_poolIndex].tokens);\\n    }\\n\\n\\t/**\\n     * @dev Get the Token weight details in Index pool.\\n     */\\n    function getIndexWeightDetails(uint _poolIndex) external view returns(uint[] memory){\\n        return (poolInfo[_poolIndex].weights);\\n    }\\n\\n\\t/**\\n\\t @param _amount Amount to chec for slippage.\\n    * @dev Function to calculate the Minimum return for slippage\\n    */\\n\\tfunction calculateMinimumReturn(uint _amount) internal view returns (uint){\\n\\t\\t// This will get the slippage rate from configuration contract and calculate how much amount user can get after slippage.\\n\\t\\tuint256 sliprate= IPoolConfiguration(_poolConf).getslippagerate();\\n        uint rate = _amount.mul(sliprate).div(100);\\n        // Return amount after calculating slippage\\n\\t\\treturn _amount.sub(rate);\\n        \\n    }\\n\\t/**\\n    * @dev Get amount of itoken to be received.\\n\\t* Iv = index value \\n    * Pt = total iTokens outstanding \\n    * Dv = deposit USDT value \\n    * DPv = total USDT value in the pool\\n    * pTR = iTokens received\\n    * If Iv = 0 then pTR =  DV\\n    * If pt > 0 then pTR  =  (Dv/Iv)* Pt\\n    */\\n\\tfunction getItokenValue(uint256 outstandingValue, uint256 indexValue, uint256 depositValue, uint256 totalDepositValue) public view returns(uint256){\\n\\t\\t// Get the itoken value based on the pool value and total itokens. This method is used in pool In.\\n\\t\\t// outstandingValue is total itokens.\\n\\t\\t// Index value is pool current value.\\n\\t\\t// deposit value is stable coin amount user will deposit\\n\\t\\t// totalDepositValue is total stable coin value deposited over the pool.\\n\\t\\tif(indexValue == uint(0)){\\n\\t\\t\\treturn depositValue;\\n\\t\\t}else if(outstandingValue>0){\\n\\t\\t\\treturn depositValue.mul(outstandingValue).div(indexValue);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\treturn depositValue;\\n\\t\\t}\\n\\t}\\n\\n    /**\\n     * @dev Deposit in Indices pool either public pool or pool created by Astra.\\n     * @param _tokens Token in which user want to give the amount. Currenly ony Stable stable coin is used.\\n     * @param _values Amount to spend.\\n\\t * @param _poolIndex Pool Index in which user wants to invest.\\n     */\\n\\tfunction poolIn(address[] calldata _tokens, uint[] calldata _values, uint _poolIndex) external payable nonReentrant {\\n\\t\\t// Only stable coin and Ether can be used in the initial stages.  \\n\\t\\trequire(_poolIndex<poolInfo.length, \\\"E02\\\");\\n\\t\\trequire(_tokens.length <2 && _values.length<2, \\\"E08\\\");\\n\\t\\t// Check if is the first deposit or user already deposit before this. It will be used to calculate early exit fees\\n\\t\\tif(!existingUser[msg.sender][_poolIndex]){\\n\\t\\t\\texistingUser[msg.sender][_poolIndex] = true;\\n\\t\\t\\tinitialDeposit[msg.sender][_poolIndex] = block.number;\\n\\t\\t\\tPoolUser memory newPoolUser = PoolUser(0, poolInfo[_poolIndex].currentRebalance,0,0,0,true,true);\\n            poolUserInfo[_poolIndex][msg.sender] = newPoolUser;\\n\\t\\t}\\n\\n\\t\\t// Variable that are used internally for logic/calling other functions.\\n\\t\\tuint ethValue;\\n\\t\\tuint fees;\\n\\t\\tuint stableValue;\\n\\t\\taddress[] memory returnedTokens;\\n\\t    uint[] memory returnedAmounts;\\n\\t    \\n\\t\\t//Global variable mainted to push values in it. Now we are removing the any value that are stored prior to this.\\n\\t    _TokensStable = returnedTokens;\\n\\t    _ValuesStable = returnedAmounts;\\n\\t\\t//Check if give token length is greater than 0 or not.\\n\\t\\t// If it is zero then user should deposit in ether.\\n\\t\\t// Other deposit in stable coin\\n\\t\\tif(_tokens.length == 0) {\\n\\t\\t\\t// User must deposit some amount in pool\\n\\t\\t\\trequire (msg.value > 0.001 ether, \\\"E09\\\");\\n\\n\\t\\t\\t// Swap the ether with stable coin.\\n\\t\\t\\tethValue = msg.value;\\n\\t\\t\\t_TokensStable.push(baseStableCoin);\\n\\t\\t\\t_ValuesStable.push(1);\\n    \\t    (returnedTokens, returnedAmounts) = swap(ETH_ADDRESS, ethValue, _TokensStable, _ValuesStable, 1);\\n    \\t    stableValue = returnedAmounts[0];\\n     \\n\\t\\t} else {\\n\\t\\t\\t// //Check if the entered address in the parameter of stable coin or not.\\n\\t\\t    // bool checkaddress = (address(_tokens[0]) == address(baseStableCoin));\\n\\t\\t\\t// // Check if user send some stable amount and user account has that much stable coin balance\\n\\t\\t    // require(checkaddress,\\\"poolIn: Can only submit Stable coin\\\");\\n\\t\\t\\t// require(msg.value == 0, \\\"poolIn: Submit one token at a time\\\");\\n\\t\\t\\trequire(IPoolConfiguration(_poolConf).checkStableCoin(_tokens[0]) == true,\\\"E10\\\");\\n\\t\\t\\trequire(IERC20(_tokens[0]).balanceOf(msg.sender) >= _values[0], \\\"E11\\\");\\n\\n\\t\\t\\tif(address(_tokens[0]) == address(baseStableCoin)){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tstableValue = _values[0];\\n\\t\\t\\t\\t//Transfer the stable coin from users addresses to contract address.\\n\\t\\t\\t\\tIERC20(baseStableCoin).safeTransferFrom(msg.sender,address(this),stableValue);\\n\\t\\t\\t}else{\\n                IERC20(_tokens[0]).safeTransferFrom(msg.sender,address(this),_values[0]);\\n\\t\\t\\t    stableValue = sellTokensForStable(_tokens, _values); \\n\\t\\t\\t}\\n\\t\\t\\trequire(stableValue > 0.001 ether,\\\"E09\\\");\\t\\t\\t\\n\\t\\t}\\n\\t\\t// else{\\n\\t\\t// \\trequire(supportedStableCoins[_tokens[0]] == true,\\\"poolIn: Can only submit Stable coin\\\");\\n\\t\\t// \\t// require(IERC20(_tokens[0]).balanceOf(msg.sender) >= _values[0], \\\"poolIn: Not enough tokens\\\");\\n\\t\\t// \\tIERC20(_tokens[0]).safeTransferFrom(msg.sender,address(this),_values[0]);\\n\\t\\t// \\tstableValue = sellTokensForStable(_tokens, _values); \\n\\t\\t// }\\n\\n\\t\\t// Get the value of itoken to mint.\\n\\t\\tuint256 ItokenValue = getItokenValue(Iitoken(poolInfo[_poolIndex].itokenaddr).totalSupply(), getPoolValue(_poolIndex), stableValue, totalPoolbalance[_poolIndex]);\\t\\n\\t\\t //Update the balance initially as the pending amount. Once the tokens are purchased it will be updated.\\n\\t\\t poolPendingbalance[_poolIndex] = poolPendingbalance[_poolIndex].add(stableValue);\\n\\t\\t //Check if total balance in pool if  the threshold is reached.\\n\\t\\t uint checkbalance = totalPoolbalance[_poolIndex].add(poolPendingbalance[_poolIndex]);\\n\\t\\t //Update the user details in mapping.\\n\\t\\t poolUserInfo[_poolIndex][msg.sender].Itokens = poolUserInfo[_poolIndex][msg.sender].Itokens.add(ItokenValue);\\n\\t\\t updateuserinfo(stableValue,_poolIndex);\\n\\n\\t\\t //Buy the tokens if threshold is reached.\\n\\t\\t  if (poolInfo[_poolIndex].currentRebalance == 0){\\n\\t\\t     if(poolInfo[_poolIndex].threshold <= checkbalance){\\n\\t\\t        buytokens( _poolIndex);\\n\\t\\t     }     \\n\\t\\t  }\\n\\t\\t// poolOutstandingValue[_poolIndex] =  poolOutstandingValue[_poolIndex].add();\\n\\t\\t// Again update details after tokens are bought.\\n\\t\\tupdateuserinfo(0,_poolIndex);\\n\\t\\t//Mint new itokens and store details in mapping.\\n\\t\\tIitoken(poolInfo[_poolIndex].itokenaddr).mint(msg.sender, ItokenValue);\\n\\t}\\n\\n\\n\\t /**\\n     * @dev Withdraw from Pool using itoken.\\n\\t * @param _poolIndex Pool Index to withdraw funds from.\\n\\t * @param stakeEarlyFees Choose to stake early fees or not.\\n\\t * @param withdrawAmount Amount to withdraw\\n     */\\n\\tfunction withdraw(uint _poolIndex, bool stakeEarlyFees,bool stakePremium, uint withdrawAmount) external nonReentrant{\\n\\t    require(_poolIndex<poolInfo.length, \\\"E02\\\");\\n\\t\\trequire(Iitoken(poolInfo[_poolIndex].itokenaddr).balanceOf(msg.sender)>=withdrawAmount, \\\"E11\\\");\\n\\t    // Update user info before withdrawal.\\n\\t\\tupdateuserinfo(0,_poolIndex);\\n\\t\\t// Get the user share on the pool\\n\\t\\tuint userShare = poolUserInfo[_poolIndex][msg.sender].currentBalance.add(poolUserInfo[_poolIndex][msg.sender].pendingBalance).mul(withdrawAmount).div(poolUserInfo[_poolIndex][msg.sender].Itokens);\\n\\t\\tuint _balance;\\n\\t\\tuint _pendingAmount;\\n\\n\\t\\t// Check if withdrawn amount is greater than pending amount. It will use the pending stable balance after that it will \\n\\t\\tif(userShare>poolUserInfo[_poolIndex][msg.sender].pendingBalance){\\n\\t\\t\\t_balance = userShare.sub(poolUserInfo[_poolIndex][msg.sender].pendingBalance);\\n\\t\\t\\t_pendingAmount = poolUserInfo[_poolIndex][msg.sender].pendingBalance;\\n\\t\\t}else{\\n\\t\\t\\t_pendingAmount = userShare;\\n\\t\\t}\\n\\t\\t// Call the functions to sell the tokens and recieve stable based on the user share in that pool\\n\\t\\tuint256 _totalAmount = withdrawTokens(_poolIndex,_balance);\\n\\t\\tuint fees;\\n\\t\\tuint256 earlyfees;\\n\\t\\tuint256 pendingEarlyfees;\\n\\t\\t// Check if user actually make profit or not.\\n\\t\\tif(_totalAmount>_balance){\\n\\t\\t\\t// Charge the performance fees on profit\\n\\t\\t\\tfees = _totalAmount.sub(_balance).mul(IPoolConfiguration(_poolConf).getperformancefees()).div(100);\\n\\t\\t}\\n         \\n\\t\\tearlyfees = earlyfees.add(calculatefee(msg.sender,_totalAmount.sub(fees),_poolIndex));\\n\\t\\tpendingEarlyfees =calculatefee(msg.sender,_pendingAmount,_poolIndex);\\n\\t\\tpoolUserInfo[_poolIndex][msg.sender].Itokens = poolUserInfo[_poolIndex][msg.sender].Itokens.sub(withdrawAmount);\\n\\t\\t//Update details in mapping for the withdrawn aount.\\n        poolPendingbalance[_poolIndex] = poolPendingbalance[_poolIndex].sub( _pendingAmount);\\n        poolUserInfo[_poolIndex][msg.sender].pendingBalance = poolUserInfo[_poolIndex][msg.sender].pendingBalance.sub(_pendingAmount);\\n        totalPoolbalance[_poolIndex] = totalPoolbalance[_poolIndex].sub(_balance);\\n\\t\\tpoolUserInfo[_poolIndex][msg.sender].currentBalance = poolUserInfo[_poolIndex][msg.sender].currentBalance.sub(_balance);\\n\\t\\t// Burn the itokens and update details in mapping.\\n\\t\\tIitoken(poolInfo[_poolIndex].itokenaddr).burn(msg.sender, withdrawAmount);\\n\\t\\twithdrawUserAmount(_poolIndex,fees,_totalAmount.sub(fees).sub(earlyfees),_pendingAmount.sub(pendingEarlyfees),earlyfees.add(pendingEarlyfees),stakeEarlyFees,stakePremium);\\n\\t\\temit Withdrawn(msg.sender, _balance);\\n\\t}\\n    // Withdraw amoun and charge fees. Now this single function will be used instead of chargePerformancefees,chargeEarlyFees,withdrawStable,withdrawPendingAmount.\\n\\t// Some comment code line is for refrence what original code looks like.\\n\\tfunction withdrawUserAmount(uint _poolIndex,uint fees,uint totalAmount,uint _pendingAmount, uint earlyfees,bool stakeEarlyFees,bool stakePremium) internal{\\n\\t\\t// This logic is similar to charge early fees.\\n\\t\\t//  If user choose to stake early exit fees it will buy astra and stake them.\\n\\t\\t// If user don't want to stake it will be distributes among stakers and index onwer.\\n\\t\\t// Distribution logic is similar to performance fees so it is integrated with that. Early fees is added with performance fees. \\n\\t\\tif(stakeEarlyFees == true){\\n\\t\\t\\tuint returnAmount= buyAstraToken(earlyfees);\\n\\t\\t\\tstakeAstra(returnAmount,false);\\n\\t\\t}else{\\n\\t\\t\\tfees = fees.add(earlyfees);\\n\\t\\t}\\n\\n\\t\\t// This logic is similar to withdrawStable stable coins.\\n\\t\\t// If user choose to stake the amount instead of withdraw it will buy Astra and stake them.\\n\\t\\t// If user don't want to stake then they will recieve on there account in base stable coins.\\n\\t\\tif(stakePremium == true){\\n            uint returnAmount= buyAstraToken(totalAmount);\\n\\t\\t\\tstakeAstra(returnAmount,true);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\ttransferTokens(baseStableCoin,msg.sender,totalAmount);\\n\\t\\t\\t// IERC20(baseStableCoin).safeTransfer(msg.sender, totalAmount);\\n\\t\\t}\\n\\t\\t// This logic is similar to withdrawPendingAmount. Early exit fees for pending amount is calculated previously.\\n\\t\\t// It transfer the pending amount to user account for which token are not bought.\\n\\t\\ttransferTokens(baseStableCoin,msg.sender,_pendingAmount);\\n\\t\\t// IERC20(baseStableCoin).safeTransfer(msg.sender, _pendingAmount);\\n\\n\\t\\t// This logic is similar to chargePerformancefees.\\n\\t\\t// 80 percent of fees will be send to the inde creator. Remaining 20 percent will be distributed among stakers.\\n        if(fees>0){\\n\\t\\tuint distribution = fees.mul(80).div(100);\\n\\t\\t\\tif(poolInfo[_poolIndex].owner==address(this)){\\n\\t\\t\\t\\ttransferTokens(baseStableCoin,managerAddresses,distribution);\\n\\t\\t\\t\\t// IERC20(baseStableCoin).safeTransfer(managerAddresses, distribution);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\ttransferTokens(baseStableCoin,poolInfo[_poolIndex].owner,distribution);\\n\\t\\t\\t\\t//IERC20(baseStableCoin).safeTransfer(poolInfo[_poolIndex].owner, distribution);\\n\\t\\t\\t}\\n\\t\\t\\tuint returnAmount= buyAstraToken(fees.sub(distribution));\\n\\t\\t\\ttransferTokens(ASTRTokenAddress,address(poolChef),returnAmount);\\n\\t\\t\\t// IERC20(ASTRTokenAddress).safeTransfer(address(poolChef),returnAmount);\\n\\t\\t\\tIMAsterChef(poolChef).distributeExitFeeShare(returnAmount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction transferTokens(address _token, address _reciever,uint _amount) internal{\\n\\t\\tIERC20(_token).safeTransfer(_reciever, _amount);\\n\\t}\\n\\n\\t/**\\n     * @dev Internal fucntion to Withdraw from Pool using itoken.\\n\\t * @param _poolIndex Pool Index to withdraw funds from.\\n\\t * @param _balance Amount to withdraw from Pool.\\n     */\\n\\n\\tfunction withdrawTokens(uint _poolIndex,uint _balance) internal returns(uint256){\\n\\t\\tuint localWeight;\\n\\n\\t\\t// Check if total pool balance is more than 0. \\n\\t\\tif(totalPoolbalance[_poolIndex]>0){\\n\\t\\t\\tlocalWeight = _balance.mul(1 ether).div(totalPoolbalance[_poolIndex]);\\n\\t\\t\\t// localWeight = _balance.mul(1 ether).div(Iitoken(poolInfo[_poolIndex].itokenaddr).totalSupply());\\n\\t\\t}  \\n\\t\\t\\n\\t\\tuint _totalAmount;\\n\\n\\t\\t// Run loop over the tokens in the indices pool to sell the user share.\\n\\t\\tfor (uint i = 0; i < poolInfo[_poolIndex].tokens.length; i++) {\\n\\t\\t\\tuint _amount;\\n\\t\\t    uint8 _distribution;\\n\\t\\t\\t// Get the total token balance in that Pool.\\n\\t\\t\\tuint tokenBalance = tokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]];\\n\\t\\t    // Get the user share from the total token amount\\n\\t\\t    uint withdrawBalance = tokenBalance.mul(localWeight).div(1 ether);\\n\\t\\t    if (withdrawBalance == 0) {\\n\\t\\t        continue;\\n\\t\\t    }\\n\\t\\t\\t// Skip if withdraw amount is 0\\n\\t\\t    if (poolInfo[_poolIndex].tokens[i] == baseStableCoin) {\\n\\t\\t        _totalAmount = _totalAmount.add(withdrawBalance);\\n\\t\\t        continue;\\n\\t\\t    }\\n\\t\\t\\t// Approve the Exchnage contract before selling thema.\\n\\t\\t    IERC20(poolInfo[_poolIndex].tokens[i]).approve(EXCHANGE_CONTRACT, withdrawBalance);\\n\\t\\t\\t// Get the expected amount of  tokens to sell\\n\\t\\t\\t(_amount, _distribution) = DexAggregator(EXCHANGE_CONTRACT).getBestExchangeRate(IERC20(poolInfo[_poolIndex].tokens[i]), IERC20(baseStableCoin), withdrawBalance);\\n\\t\\t\\tif (_amount == 0) {\\n\\t\\t        continue;\\n\\t\\t    }\\n\\t\\t\\t// Swap the tokens and get stable in return so that users can withdraw.\\n\\t\\t\\t_amount = DexAggregator(EXCHANGE_CONTRACT).swapFromBestExchange(IERC20(poolInfo[_poolIndex].tokens[i]), IERC20(baseStableCoin), withdrawBalance, _amount, _distribution);\\n\\n\\t\\t\\t_totalAmount = _totalAmount.add(_amount);\\n\\t\\t\\ttokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]] = tokenBalance.sub(withdrawBalance);\\n\\t\\t}\\n\\t\\treturn _totalAmount;\\n\\t}\\n\\n\\t/**\\n\\t * @param _poolIndex Pool Index to withdraw funds from.\\n\\t * @param _pendingAmount Pending Amounts to withdraw from Pool.\\n\\t* @dev Withdraw the pending amount that is submitted before next.\\n\\t*/\\n\\n\\tfunction withdrawPendingAmount(uint256 _poolIndex,uint _pendingAmount)internal returns(uint256){\\n\\t\\tuint _earlyfee;\\n\\t\\t// Withdraw the pending Stable amount for which no tokens are bought. Here early exit fees wil be charged before transfering to user\\n         if(_pendingAmount>0){\\n\\t\\t\\t //Calculate how much early exit fees must be applicable\\n\\t\\t _earlyfee = calculatefee(msg.sender,_pendingAmount,_poolIndex);\\n\\t\\t IERC20(baseStableCoin).safeTransfer(msg.sender, _pendingAmount.sub(_earlyfee));\\n\\t\\t}\\n\\t\\treturn _earlyfee;\\n\\t}\\n\\n\\t /**\\n     * @dev Update pool function to do the rebalaning.\\n     * @param _tokens New tokens to purchase after rebalance.\\n     * @param _weights Weight of new tokens.\\n\\t * @param _threshold Threshold amount to purchase token.\\n\\t * @param _rebalanceTime Next Rebalance time.\\n\\t * @param _poolIndex Pool Index to do rebalance.\\n     */\\n\\tfunction updatePool(address[] memory _tokens,uint[] memory _weights,uint _threshold,uint _rebalanceTime,uint _poolIndex) public nonReentrant{\\t    \\n\\t    require(block.timestamp >= poolInfo[_poolIndex].rebaltime,\\\"E12\\\");\\n\\t\\t// require(poolUserInfo[_poolIndex][msg.sender].currentBalance>poolInfo[_poolIndex].threshold,\\\"Threshold not reached\\\");\\n\\t\\t// Check if entered indices pool is public or Astra managed.\\n\\t\\t// Also check if is public pool then request came from the owner or not.\\n\\t\\tif(poolInfo[_poolIndex].owner != address(this)){\\n\\t\\t    require(_tokens.length == _weights.length, \\\"E02\\\");\\n\\t\\t\\trequire(poolInfo[_poolIndex].owner == msg.sender, \\\"E13\\\");\\n\\t\\t}else{\\n\\t\\t\\t(_tokens, _weights,_threshold,_rebalanceTime) = IOracle(IPoolConfiguration(_poolConf).getoracleaddress()).getTokenDetails(_poolIndex);\\n\\t\\t}\\n\\t\\trequire (_tokens.length <= IPoolConfiguration(_poolConf).getmaxTokenSupported(), \\\"E16\\\");\\n\\n\\t    address[] memory newTokens;\\n\\t    uint[] memory newWeights;\\n\\t    uint newTotalWeight;\\n\\t\\t\\n\\t\\tuint _newTotalWeight;\\n\\n\\t\\t// Loop over the tokens details to update its total weight.\\n\\t\\tfor(uint i = 0; i < _tokens.length; i++) {\\n\\t\\t\\trequire (_tokens[i] != ETH_ADDRESS && _tokens[i] != WETH_ADDRESS);\\t\\t\\t\\n\\t\\t\\t_newTotalWeight = _newTotalWeight.add(_weights[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Update new tokens details\\n\\t\\tnewTokens = _tokens;\\n\\t\\tnewWeights = _weights;\\n\\t\\tnewTotalWeight = _newTotalWeight;\\n\\t\\t// Update the pool details for next rebalance\\n\\t\\tpoolInfo[_poolIndex].threshold = _threshold;\\n\\t\\tpoolInfo[_poolIndex].rebaltime = _rebalanceTime;\\n\\t\\t//Sell old tokens and buy new tokens.\\n\\t\\trebalance(newTokens, newWeights,newTotalWeight,_poolIndex);\\n\\t\\t\\n\\n\\t\\t// Buy the token for Stable which is in pending state.\\n\\t\\tif(poolPendingbalance[_poolIndex]>0){\\n\\t\\t buytokens(_poolIndex);   \\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n\\t/**\\n\\t* @dev Enable or disable Pool can only be called by admin\\n\\t*/\\n\\tfunction setPoolStatus(bool _active,uint _poolIndex) external systemOnly {\\n\\t\\tpoolInfo[_poolIndex].active = _active;\\n\\t}\\t\\n\\t\\n\\t/** \\n\\t * @dev Internal function called while updating the pool.\\n\\t */\\n\\n\\tfunction rebalance(address[] memory newTokens, uint[] memory newWeights,uint newTotalWeight, uint _poolIndex) internal {\\n\\t    require(poolInfo[_poolIndex].currentRebalance >0, \\\"E14\\\");\\n\\t\\t// Variable used to call the functions internally\\n\\t\\tuint[] memory buf2;\\n\\t\\tbuf = buf2;\\n\\t\\tuint ethValue;\\n\\t\\taddress[] memory returnedTokens;\\n\\t    uint[] memory returnedAmounts;\\n\\n\\t\\t//Updating the balancing of tokens you are selling in storage and make update the balance in main mapping.\\n\\t\\tfor (uint i = 0; i < poolInfo[_poolIndex].tokens.length; i++) {\\n\\t\\t\\tbuf.push(tokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]]);\\n\\t\\t\\ttokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]] = 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Sell the Tokens in pool to recieve tokens\\n\\t\\tif(totalPoolbalance[_poolIndex]>0){\\n\\t\\t ethValue = sellTokensForStable(poolInfo[_poolIndex].tokens, buf);   \\n\\t\\t}\\n\\n\\t\\t// Updating pool configuration/mapping to update the new tokens details\\n\\t\\tpoolInfo[_poolIndex].tokens = newTokens;\\n\\t\\tpoolInfo[_poolIndex].weights = newWeights;\\n\\t\\tpoolInfo[_poolIndex].totalWeight = newTotalWeight;\\n\\t\\tpoolInfo[_poolIndex].currentRebalance = poolInfo[_poolIndex].currentRebalance.add(1);\\n\\t\\tpoolInfo[_poolIndex].lastrebalance = block.timestamp;\\n\\t\\t\\n\\t\\t// Return if you recieve 0 value for selling all the tokens\\n\\t\\tif (ethValue == 0) {\\n\\t\\t    return;\\n\\t\\t}\\n\\t\\t\\n\\t\\tuint[] memory buf3;\\n\\t\\tbuf = buf3;\\n\\t\\t\\n\\t\\t// Buy new tokens for the pool.\\n\\t\\tif(totalPoolbalance[_poolIndex]>0){\\n\\t\\t\\t//Buy new tokens\\n\\t\\t (returnedTokens, returnedAmounts) = swap2(baseStableCoin, ethValue, newTokens, newWeights,newTotalWeight,buf);\\n\\t\\t// Update those tokens details in mapping.\\n\\t\\tfor(uint i = 0; i < poolInfo[_poolIndex].tokens.length; i++) {\\n\\t\\t\\ttokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]] = buf[i];\\n\\t    \\t\\n\\t\\t}  \\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n\\t/** \\n\\t * @dev Get the current value of pool to check the value of pool\\n\\t */\\n\\n\\tfunction getPoolValue(uint256 _poolIndex)internal returns(uint256){\\n\\t\\t// Used to get the Expected amount for the token you are selling.\\n\\t\\tuint _amount;\\n\\t\\t// Used to get the distributing dex details for the token you are selling.\\n\\t\\tuint8 _distribution;\\n\\t\\t// Return the total Amount of Stable you will recieve for selling. This will be total value of pool that it has purchased.\\n\\t\\tuint _totalAmount;\\n\\n\\t\\t// Run loops over the tokens in the pool to get the token worth.\\n\\t\\tfor (uint i = 0; i < poolInfo[_poolIndex].tokens.length; i++) {\\n\\t\\t\\tif(tokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]]>0){\\n\\t\\t\\t(_amount, _distribution) = DexAggregator(EXCHANGE_CONTRACT).getBestExchangeRate(IERC20(poolInfo[_poolIndex].tokens[i]), IERC20(baseStableCoin), tokenBalances[_poolIndex][poolInfo[_poolIndex].tokens[i]]);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t_amount = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif (_amount == 0) {\\n\\t\\t        continue;\\n\\t\\t    }\\n\\t\\t    _totalAmount = _totalAmount.add(_amount);\\n\\t\\t}\\n\\n\\t\\t// Return the total values of pool locked\\n\\t\\treturn _totalAmount;\\n\\t}\\n\\n\\t/** \\n\\t * @dev Function to swap two token. Used by other functions during buying and selling. It used where ether is used like at the time of ether deposit.\\n\\t */\\n\\n\\tfunction swap(address _token, uint _value, address[] memory _tokens, uint[] memory _weights, uint _totalWeight) internal returns(address[] memory, uint[] memory) {\\n\\t\\t// Use to get the share of particular token based on there share.\\n\\t\\tuint _tokenPart;\\n\\t\\t// Used to get the Expected amount for the token you are selling.\\n\\t\\tuint _amount;\\n\\t\\t// Used to get the distributing dex details for the token you are selling. \\n\\t\\tuint8 _distribution;\\n        // Run loops over the tokens in the parametess to buy them.\\n\\t\\tfor(uint i = 0; i < _tokens.length; i++) { \\n\\t\\t    // Calculate the share of token based on the weight and the buy for that.\\n\\t\\t    _tokenPart = _value.mul(_weights[i]).div(_totalWeight);\\n\\n\\t\\t\\t// Get the amount of tokens pool will recieve based on the token selled.\\n\\t\\t\\t(_amount, _distribution) = DexAggregator(EXCHANGE_CONTRACT).getBestExchangeRate(IERC20(_token), IERC20(_tokens[i]), _tokenPart);\\n\\t\\t    // calculate slippage\\n\\t\\t\\tuint256 minReturn = calculateMinimumReturn(_amount);\\n\\n\\t\\t\\t// Check condition if token you are selling is ETH or another ERC20 and then sell the tokens.\\n\\t\\t\\tif (_token == ETH_ADDRESS) {\\n\\t\\t\\t\\t_amount = DexAggregator(EXCHANGE_CONTRACT).swapFromBestExchange.value(_tokenPart)(IERC20(_token), IERC20(_tokens[i]), _tokenPart, minReturn, _distribution);\\n\\t\\t\\t} else {\\n\\t\\t\\t    IERC20(_tokens[i]).approve(EXCHANGE_CONTRACT, _tokenPart);\\n\\t\\t\\t\\t_amount = DexAggregator(EXCHANGE_CONTRACT).swapFromBestExchange(IERC20(_token), IERC20(_tokens[i]), _tokenPart, minReturn, _distribution);\\n\\t\\t\\t}\\n\\t\\t\\t_weights[i] = _amount;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (_tokens, _weights);\\n\\t}\\n\\n\\t/** \\n\\t * @dev Function to swap two token. It used in case of ERC20 - ERC20 swap.\\n\\t */\\n\\t\\n\\tfunction swap2(address _token, uint _value, address[] memory newTokens, uint[] memory newWeights,uint newTotalWeight, uint[] memory _buf) internal returns(address[] memory, uint[] memory) {\\n\\t\\t// Use to get the share of particular token based on there share.\\n\\t\\tuint _tokenPart;\\n\\t\\t// Used to get the Expected amount for the token you are selling.\\n\\t\\tuint _amount;\\n\\t\\tbuf = _buf;\\n\\t\\t// Used to get the distributing dex details for the token you are selling.\\n\\t\\tuint8 _distribution;\\n\\t\\t// Approve before selling the tokens\\n\\t\\tIERC20(_token).approve(EXCHANGE_CONTRACT, _value);\\n\\t\\t // Run loops over the tokens in the parametess to buy them.\\n\\t\\tfor(uint i = 0; i < newTokens.length; i++) {\\n            \\n\\t\\t\\t_tokenPart = _value.mul(newWeights[i]).div(newTotalWeight);\\n\\t\\t\\t\\n\\t\\t\\tif(_tokenPart == 0) {\\n\\t\\t\\t    buf.push(0);\\n\\t\\t\\t    continue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t(_amount, _distribution) = DexAggregator(EXCHANGE_CONTRACT).getBestExchangeRate(IERC20(_token), IERC20(newTokens[i]), _tokenPart);\\n\\t\\t\\tuint256 minReturn = calculateMinimumReturn(_amount);\\n\\t\\t\\t_amount = DexAggregator(EXCHANGE_CONTRACT).swapFromBestExchange(IERC20(_token), IERC20(newTokens[i]), _tokenPart, minReturn, _distribution);\\n\\t\\t\\tbuf.push(_amount);\\n            newWeights[i] = _amount;\\n\\t\\t}\\n\\t\\treturn (newTokens, newWeights);\\n\\t}\\n\\n\\t/** \\n\\t * @dev Sell tokens for Stable is used during the rebalancing to sell previous token and buy new tokens\\n\\t */\\n\\tfunction sellTokensForStable(address[] memory _tokens, uint[] memory _amounts) internal returns(uint) {\\n\\t\\t// Used to get the Expected amount for the token you are selling. \\n\\t\\tuint _amount;\\n        // Used to get the distributing dex details for the token you are selling. \\n\\t\\tuint8 _distribution;\\n\\n\\t\\t// Return the total Amount of Stable you will recieve for selling\\n\\t\\tuint _totalAmount;\\n\\t\\t\\n\\t\\t// Run loops over the tokens in the parametess to sell them.\\n\\t\\tfor(uint i = 0; i < _tokens.length; i++) {\\n\\t\\t    if (_amounts[i] == 0) {\\n\\t\\t        continue;\\n\\t\\t    }\\n\\t\\t    \\n\\t\\t    if (_tokens[i] == baseStableCoin) {\\n\\t\\t        _totalAmount = _totalAmount.add(_amounts[i]);\\n\\t\\t        continue;\\n\\t\\t    }\\n\\n\\t\\t\\t// Approve token access to Exchange contract.\\n\\t\\t    IERC20(_tokens[i]).approve(EXCHANGE_CONTRACT, _amounts[i]);\\n\\t\\t    // Get the amount of Stable tokens you will recieve for selling tokens \\n\\t\\t\\t(_amount, _distribution) = DexAggregator(EXCHANGE_CONTRACT).getBestExchangeRate(IERC20(_tokens[i]), IERC20(baseStableCoin), _amounts[i]);\\n\\t\\t\\t// Skip remaining execution if no token is available\\n\\t\\t\\tif (_amount == 0) {\\n\\t\\t        continue;\\n\\t\\t    }\\n\\t\\t\\t// Calculate slippage over the the expected amount\\n\\t\\t    uint256 minReturn = calculateMinimumReturn(_amount);\\n\\t\\t\\t// Actually swap tokens\\n\\t\\t\\t_amount = DexAggregator(EXCHANGE_CONTRACT).swapFromBestExchange(IERC20(_tokens[i]), IERC20(baseStableCoin), _amounts[i], minReturn, _distribution);\\n\\t\\t\\t_totalAmount = _totalAmount.add(_amount);\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\treturn _totalAmount;\\n\\t}\\n\\n}\"\r\n    },\r\n    \"other/reetrancy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    function __init() internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\"\r\n    },\r\n    \"other/Initializable.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool wasInitializing = initializing;\\n    initializing = true;\\n    initialized = true;\\n\\n    _;\\n\\n    initializing = wasInitializing;\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    uint256 cs;\\n    assembly { cs := extcodesize(address) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawnToken\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASTRTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXCHANGE_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_poolConf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebalanceTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"addPublicPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseStableCoin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"}],\"name\":\"getIndexTokenDetails\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"}],\"name\":\"getIndexWeightDetails\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outstandingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositValue\",\"type\":\"uint256\"}],\"name\":\"getItokenValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initialDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ASTRTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolConfiguration\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_itokendeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chef\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stable\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"itokendeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolChef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"}],\"name\":\"poolIn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rebaltime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRebalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastrebalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"itokenaddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolPendingbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDTdeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Itokens\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isenabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"}],\"name\":\"setPoolStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"systemAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPoolbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebalanceTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stakeEarlyFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"stakePremium\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PoolV2","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}