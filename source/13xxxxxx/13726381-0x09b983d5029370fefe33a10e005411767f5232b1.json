{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Incinerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"IUniswapRouter.sol\\\";\\n\\ncontract Incinerator {\\n\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    IUniswapRouter public router;\\n    address public management;\\n    mapping (address => uint) public tokensBurned;\\n\\n    event TokensIncinerated(address tokenAddr, uint amount);\\n    event ManagementUpdated(address oldManagement, address newManagement);\\n    event RouterUpdated(address oldRouter, address newRouter);\\n\\n    modifier managementOnly() {\\n        require (msg.sender == management, 'Only management may call this');\\n        _;\\n    }\\n\\n    constructor(address routerAddr, address mgmt) {\\n        router = IUniswapRouter(routerAddr);\\n        management = mgmt;\\n    }\\n\\n    // change which exchange we send tokens to\\n    function setRouter(address newRouter) external managementOnly {\\n        address oldRouter = address(router);\\n        router = IUniswapRouter(newRouter);\\n        emit RouterUpdated(oldRouter, newRouter);\\n    }\\n\\n    // change the management key\\n    function setManagement(address newMgmt) external managementOnly {\\n        address oldMgmt =  management;\\n        management = newMgmt;\\n        emit ManagementUpdated(oldMgmt, newMgmt);\\n    }\\n\\n    // buy tokens at market rate and burn them\\n    function incinerate(address tokenAddr) external payable {\\n        // set amountMin to 0 since we don't care how many tokens we burn\\n        uint amountOutMin = 0;\\n        address[] memory path = new address[](2);\\n        path[0] = WETH;\\n        path[1] = tokenAddr;\\n\\n        address burnAddress = address(0);\\n        uint deadline = block.timestamp + 1;\\n        uint[] memory amounts = router.swapExactETHForTokens{value: msg.value}(amountOutMin, path, burnAddress, deadline);\\n        tokensBurned[tokenAddr] += amounts[1];\\n        emit TokensIncinerated(tokenAddr, amounts[1]);\\n    }\\n\\n//    function incineratePath(address[] memory path, address inputToken) external payable {\\n//        // set amountMin to 0 since we don't care how many tokens we burn\\n//        uint amountOutMin = 0;\\n//\\n//        address burnAddress = address(0);\\n//        uint deadline = block.timestamp + 1;\\n//        uint[] memory amounts = router.swapTokensForExactTokens(amountOutMin, path, burnAddress, deadline);\\n//        uint lastAmount = amounts[amounts.length - 1];\\n//        address lastAddress = path[path.length - 1];\\n//        tokensBurned[lastAddress] += lastAmount;\\n//        emit TokensIncinerated(lastAddress, lastAmount);\\n//    }\\n\\n}\\n\"\r\n    },\r\n    \"IUniswapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\ninterface IUniswapRouter {\\n\\n    event LiquidityAdded(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n//        virtual\\n//        override\\n        payable\\n//        ensure(deadline)\\n        returns (uint[] memory amounts);\\n//    {\\n//        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\\n//        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\\n//        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n//        IWETH(WETH).deposit{value: amounts[0]}();\\n//        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\\n//        _swap(amounts, path, to);\\n//    }\\n\\n        function swapTokensForExactTokens(\\n            uint amountOut,\\n            uint amountInMax,\\n            address[] calldata path,\\n            address to,\\n            uint deadline)\\n        external\\n//        virtual\\n//        override\\n        returns (uint[] memory amounts);\\n//    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n//        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\\n//        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\\n//        TransferHelper.safeTransferFrom(\\n//            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\\n//        );\\n//        _swap(amounts, path, to);\\n//    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"Incinerator.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"RouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensIncinerated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"incinerate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Incinerator","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}