{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Castle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\n/// @dev A simple contract to orchestrate comings and going from the OrcsPortal\\ncontract Castle {\\n\\n    address implementation_;\\n    address public admin;\\n    \\n    address public portal;\\n    address public allies;\\n    address public orcs;\\n    address public zug;\\n    address public shr;\\n\\n    mapping (address => address) public reflection;\\n    mapping (uint256 => address) public orcOwner;\\n    mapping (uint256 => address) public allyOwner;\\n\\n    function initialize(address portal_, address orc_, address zug_, address shr_) external {\\n        require(msg.sender == admin);\\n        portal = portal_;\\n        orcs   = orc_;\\n        zug = zug_;\\n        shr = shr_;\\n    }\\n\\n    function setReflection(address key_, address reflection_) external {\\n        require(msg.sender == admin);\\n        reflection[key_] = reflection_;\\n        reflection[reflection_] = key_;\\n    }\\n\\n    /// @dev Send Orcs, allies and tokens to PolyLand\\n    function travel(uint256[] calldata orcIds, uint256[] calldata allyIds, uint256 zugAmount, uint256 shrAmount) external {\\n        address target = reflection[address(this)];\\n\\n        uint256 len       = orcIds.length;\\n        uint256 currIndex = 0;\\n\\n        bytes[] memory calls = new bytes[]((len > 0 ? len + 1 : 0) + (zugAmount > 0 ? 1 : 0) + (shrAmount > 0 ? 1 : 0));\\n\\n\\n        if (len > 0) {\\n            _pullIds(orcs, orcIds);\\n\\n            // This will create orcs exactly as they exist in this chain\\n            for (uint256 i = 0; i < orcIds.length; i++) {\\n                calls[i] = _buildData(orcIds[i]);\\n            }\\n\\n            calls[len] = abi.encodeWithSelector(this.unstakeMany.selector,reflection[orcs], msg.sender,  orcIds);\\n            currIndex += len + 1;\\n        }\\n\\n        if (zugAmount > 0) {\\n            ERC20Like(zug).burn(msg.sender, zugAmount);\\n            calls[currIndex] = abi.encodeWithSelector(this.mintToken.selector, reflection[address(zug)], msg.sender, zugAmount);\\n            currIndex++;\\n        }\\n\\n        if (shrAmount > 0) {\\n            ERC20Like(shr).burn(msg.sender, shrAmount);\\n            calls[currIndex] = abi.encodeWithSelector(this.mintToken.selector, reflection[address(shr)], msg.sender, shrAmount);\\n        }\\n\\n        PortalLike(portal).sendMessage(abi.encode(target, calls));\\n    }\\n\\n    function callOrcs(bytes calldata data) external {\\n        _onlyPortal();\\n\\n        (bool succ, ) = orcs.call(data);\\n        require(succ);\\n    }\\n\\n    function unstakeMany(address token, address owner, uint256[] calldata ids) external {\\n        _onlyPortal();\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            if (token == orcs)   delete orcOwner[ids[i]];\\n            if (token == allies) delete allyOwner[ids[i]];\\n            ERC721Like(token).transfer(owner, ids[i]);\\n        }\\n    }\\n\\n    function mintToken(address token, address to, uint256 amount) external { \\n        _onlyPortal();\\n\\n        ERC20Like(token).mint(to, amount);\\n    }\\n\\n    function _pullIds(address token, uint256[] calldata ids) internal {\\n        // The ownership will be checked to the token contract\\n        OrcishLike(token).pull(msg.sender, ids);\\n    }\\n\\n    function pullCallback(address owner, uint256[] calldata ids) external {\\n        require(msg.sender == orcs || msg.sender == allies);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _stake(msg.sender, ids[i], owner);\\n        }\\n    }\\n\\n    function _buildData(uint256 id) internal view returns (bytes memory data) {\\n        (uint8 b, uint8 h, uint8 m, uint8 o, uint16 l, uint16 zM, uint32 lP) = OrcishLike(orcs).orcs(id);\\n        data = abi.encodeWithSelector(this.callOrcs.selector, abi.encodeWithSelector(OrcishLike.manuallyAdjustOrc.selector,id, b, h, m, o, l, zM, lP));   \\n    }\\n\\n    function _stake(address token, uint256 id, address owner) internal {\\n        require((token == orcs ? orcOwner[id] : allyOwner[id]) == address(0), \\\"already staked\\\");\\n        require(msg.sender == token, \\\"not orcs contract\\\");\\n        require(ERC721Like(token).ownerOf(id) == address(this), \\\"orc not transferred\\\");\\n\\n        if (token == orcs)   orcOwner[id]  = owner;\\n        if (token == allies) allyOwner[id] = owner;\\n    }\\n\\n    function _onlyPortal() view internal {\\n        require(msg.sender == portal, \\\"not portal\\\");\\n    } \\n\\n}\\n\\ninterface OrcishLike {\\n    function pull(address owner, uint256[] calldata ids) external;\\n    function manuallyAdjustOrc(uint256 id, uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress) external;\\n    function transfer(address to, uint256 tokenId) external;\\n    function orcs(uint256 id) external view returns(uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress);\\n}\\n\\ninterface PortalLike {\\n    function sendMessage(bytes calldata message_) external;\\n}\\n\\ninterface ERC20Like {\\n    function burn(address from, uint256 amount) external;\\n    function mint(address from, uint256 amount) external;\\n} \\n\\ninterface ERC721Like {\\n    function ownerOf(uint256 id) external returns (address owner);\\n    function transfer(address to, uint256 tokenid) external;\\n    function mint(address to, uint256 tokenid) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callOrcs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"portal_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"orc_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zug_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"shr_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orcOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orcs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"portal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"pullCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reflection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"key_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reflection_\",\"type\":\"address\"}],\"name\":\"setReflection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orcIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allyIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"zugAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shrAmount\",\"type\":\"uint256\"}],\"name\":\"travel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"unstakeMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zug\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Castle","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}