{"status":"1","message":"OK","result":[{"SourceCode":"{\"BasicToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.8;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./ERC20Basic.sol\\u0027;\\n\\n/**\\n * @title BasicToken\\n * @dev Basic version of Token, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n  mapping(address =\\u003e uint256) public balances;\\n\\n  /**\\n   * BasicToken transfer function\\n   * @dev transfer token for a specified address\\n   * @param _to address to transfer to.\\n   * @param _value amount to be transferred.\\n   */\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    require(msg.sender != _to, \\u0027cannot send to same account\\u0027);\\n    //Safemath fnctions will throw if value is invalid\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * BasicToken balanceOf function\\n   * @dev Gets the balance of the specified address.\\n   * @param _owner address to get balance of.\\n   * @return uint256 amount owned by the address.\\n   */\\n  function balanceOf(address _owner) public view returns (uint256 bal) {\\n    return balances[_owner];\\n  }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.8;\\n\\nimport \\u0027./ERC20Basic.sol\\u0027;\\n\\n/**\\n * ERC20 interface\\n * @title ERC20 interface\\n * @notice https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n  /**\\n   * allowance\\n   */\\n  function allowance(address owner, address spender)\\n    public\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * transferFrom\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) public returns (bool);\\n\\n  /**\\n   * approve\\n   */\\n  function approve(address spender, uint256 value) public returns (bool);\\n\\n  /**\\n   * Approval event\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.8;\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simple version of ERC20 interface\\n * @notice https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  /**\\n   * total supply\\n   */\\n  uint256 public totalSupply;\\n\\n  /**\\n   * balance of address\\n   */\\n  function balanceOf(address who) public view returns (uint256);\\n\\n  /**\\n   * transfer value to address\\n   */\\n  function transfer(address to, uint256 value) public returns (bool);\\n\\n  /**\\n   * Transfer event\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"GrexieToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.8;\\n\\nimport \\u0027./Token.sol\\u0027;\\n\\n/**\\n * @title Grexie Token\\n * @dev Simple ERC20 Token with standard token functions.\\n */\\ncontract GrexieToken is Token {\\n  string public constant NAME = \\u0027Grexie\\u0027;\\n  string public constant SYMBOL = \\u0027GREX\\u0027;\\n  uint256 public constant DECIMALS = 18;\\n\\n  uint256 public constant INITIAL_SUPPLY = 10**15 * 10**18;\\n\\n  /**\\n   * Grexie Token Constructor\\n   * @dev Create and issue tokens to msg.sender.\\n   */\\n  constructor() public {\\n    totalSupply = INITIAL_SUPPLY;\\n    balances[msg.sender] = INITIAL_SUPPLY;\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.8;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n * @notice https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n */\\nlibrary SafeMath {\\n  /**\\n   * SafeMath mul function\\n   * @dev function for safe multiply\\n   **/\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a * b;\\n    assert(a == 0 || c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n   * SafeMath div funciotn\\n   * @dev function for safe devide\\n   **/\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a / b;\\n    return c;\\n  }\\n\\n  /**\\n   * SafeMath sub function\\n   * @dev function for safe subtraction\\n   **/\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n   * SafeMath add fuction\\n   * @dev function for safe addition\\n   **/\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n\\n  function toString(uint256 _i) internal pure returns (string memory) {\\n    if (_i == 0) {\\n      return \\u00270\\u0027;\\n    }\\n    uint256 j = _i;\\n    uint256 len;\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n    bytes memory bstr = new bytes(len);\\n    uint256 k = len;\\n    while (_i != 0) {\\n      k = k - 1;\\n      uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n      bytes1 b1 = bytes1(temp);\\n      bstr[k] = b1;\\n      _i /= 10;\\n    }\\n    return string(bstr);\\n  }\\n}\\n\"},\"Token.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.8;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./BasicToken.sol\\u0027;\\nimport \\u0027./ERC20.sol\\u0027;\\n\\n/**\\n * @title Token\\n * @dev Token to meet the ERC20 standard\\n * @notice https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract Token is ERC20, BasicToken {\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\n\\n  /**\\n   * Token transferFrom function\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address to send tokens from\\n   * @param _to address to transfer to\\n   * @param _value amout of tokens to be transfered\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  ) public returns (bool) {\\n    uint256 _allowance = allowed[_from][msg.sender];\\n    // Safe math functions will throw if value invalid\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * Token approve function\\n   * @dev Aprove address to spend amount of tokens\\n   * @param _spender address to spend the funds.\\n   * @param _value amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    // To change the approve amount you first have to reduce the addresses`\\n    // allowance to zero by calling `approve(_spender, 0)` if it is not\\n    // already 0 to mitigate the race condition described here:\\n    // @notice https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * Token allowance method\\n   * @dev Ckeck that owners tokens is allowed to send to spender\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifing the amount of tokens still available for the spender.\\n   */\\n  function allowance(address _owner, address _spender)\\n    public\\n    view\\n    returns (uint256 remaining)\\n  {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GrexieToken","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://76b8b94857ba78aca614ebf6b1a02f3b17487825da9bc288211b6870d8216502"}]}