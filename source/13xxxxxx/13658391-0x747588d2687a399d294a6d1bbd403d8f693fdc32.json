{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC721.sol\":{\"content\":\"pragma solidity \\u003c=8.7.0;\\npragma experimental ABIEncoderV2;\\n//SPDX-License-Identifier: MIT\\n\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address payable) {\\n\\t\\treturn payable(msg.sender);\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes memory) {\\n\\t\\tthis;\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n\\nlibrary Base64 {\\n\\tbytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n\\tfunction encode(bytes memory data) internal pure returns (string memory) {\\n\\t\\tuint256 len = data.length;\\n\\t\\tif (len == 0) return \\\"\\\";\\n\\n\\t\\tuint256 encodedLen = 4 * ((len + 2) / 3);\\n\\t\\tbytes memory result = new bytes(encodedLen + 32);\\n\\t\\tbytes memory table = TABLE;\\n\\n\\t\\tassembly {\\n\\t\\t\\tlet tablePtr := add(table, 1)\\n\\t\\t\\tlet resultPtr := add(result, 32)\\n\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tlet i := 0\\n\\t\\t\\t} lt(i, len) {\\n\\n\\t\\t\\t} {\\n\\t\\t\\t\\ti := add(i, 3)\\n\\t\\t\\t\\tlet input := and(mload(add(data, i)), 0xffffff)\\n\\n\\t\\t\\t\\tlet out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(224, out)\\n\\n\\t\\t\\t\\tmstore(resultPtr, out)\\n\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 4)\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch mod(len, 3)\\n\\t\\t\\tcase 1 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n\\t\\t\\t}\\n\\t\\t\\tcase 2 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\\n\\t\\t\\t}\\n\\n\\t\\t\\tmstore(result, encodedLen)\\n\\t\\t}\\n\\n\\t\\treturn string(result);\\n\\t}\\n}\\n\\nabstract contract Ownable is Context {\\n\\taddress payable private _owner;\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\tconstructor () {\\n\\t\\taddress payable msgSender = _msgSender();\\n\\t\\t_owner = msgSender;\\n\\t\\temit OwnershipTransferred(address(0), msgSender);\\n\\t}\\n\\n\\tfunction owner() public view virtual returns (address payable) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n/*\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\temit OwnershipTransferred(_owner, address(0));\\n\\t\\t_owner = address(0);\\n\\t}\\n\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}*/\\n}\\n\\nabstract contract ReentrancyGuard {\\n\\tuint256 private constant _NOT_ENTERED = 1;\\n\\tuint256 private constant _ENTERED = 2;\\n\\tuint256 private _status;\\n\\n\\tconstructor() {\\n\\t\\t_status = _NOT_ENTERED;\\n\\t}\\n\\n\\tmodifier nonReentrant() {\\n\\t\\trequire(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\t\\t_status = _ENTERED;\\n\\t\\t_;\\n\\t\\t_status = _NOT_ENTERED;\\n\\t}\\n}\\n\\ninterface IERC721Receiver {\\n\\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\\nlibrary Strings {\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (value == 0) {\\n\\t\\t\\t\\treturn \\\"0\\\";\\n\\t\\t\\t}\\n\\t\\t\\tuint256 temp = value;\\n\\t\\t\\tuint256 digits;\\n\\t\\t\\twhile (temp != 0) {\\n\\t\\t\\t\\tdigits++;\\n\\t\\t\\t\\ttemp /= 10;\\n\\t\\t\\t}\\n\\t\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\t\\tuint256 index = digits - 1;\\n\\t\\t\\ttemp = value;\\n\\t\\t\\twhile (temp != 0) {\\n\\t\\t\\t\\tbuffer[index--] = bytes1(uint8(48 + temp % 10));\\n\\t\\t\\t\\ttemp /= 10;\\n\\t\\t\\t}\\n\\t\\t\\treturn string(buffer);\\n\\t\\t}\\n\\t}\\n}\\n\\nlibrary EnumerableMap {\\n\\tstruct MapEntry {\\n\\t\\tbytes32 _key;\\n\\t\\tbytes32 _value;\\n\\t}\\n\\n\\tstruct Map {\\n\\t\\tMapEntry[] _entries;\\n\\t\\tmapping (bytes32 =\\u003e uint256) _indexes;\\n\\t}\\n\\n\\tfunction _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex == 0) {\\n\\t\\t\\tmap._entries.push(MapEntry({ _key: key, _value: value }));\\n\\t\\t\\tmap._indexes[key] = map._entries.length;\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tmap._entries[keyIndex - 1]._value = value;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Map storage map, bytes32 key) private returns (bool) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex != 0) {\\n\\t\\t\\tuint256 toDeleteIndex = keyIndex - 1;\\n\\t\\t\\tuint256 lastIndex = map._entries.length - 1;\\n\\t\\t\\tMapEntry storage lastEntry = map._entries[lastIndex];\\n\\t\\t\\tmap._entries[toDeleteIndex] = lastEntry;\\n\\t\\t\\tmap._indexes[lastEntry._key] = toDeleteIndex + 1;\\n\\t\\t\\tmap._entries.pop();\\n\\t\\t\\tdelete map._indexes[key];\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _contains(Map storage map, bytes32 key) private view returns (bool) {\\n\\t\\treturn map._indexes[key] != 0;\\n\\t}\\n\\n\\tfunction _length(Map storage map) private view returns (uint256) {\\n\\t\\treturn map._entries.length;\\n\\t}\\n\\n\\tfunction _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n\\t\\trequire(map._entries.length \\u003e index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n\\t\\tMapEntry storage entry = map._entries[index];\\n\\t\\treturn (entry._key, entry._value);\\n\\t}\\n\\n\\tfunction _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex == 0) return (false, 0);\\n\\t\\treturn (true, map._entries[keyIndex - 1]._value);\\n\\t}\\n\\n\\tfunction _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\trequire(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\");\\n\\t\\treturn map._entries[keyIndex - 1]._value;\\n\\t}\\n\\n\\tfunction _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\trequire(keyIndex != 0, errorMessage);\\n\\t\\treturn map._entries[keyIndex - 1]._value;\\n\\t}\\n\\n\\tstruct UintToAddressMap {\\n\\t\\tMap _inner;\\n\\t}\\n\\n\\tfunction set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n\\t\\treturn _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n\\t\\treturn _remove(map._inner, bytes32(key));\\n\\t}\\n\\n\\tfunction contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n\\t\\treturn _contains(map._inner, bytes32(key));\\n\\t}\\n\\n\\tfunction length(UintToAddressMap storage map) internal view returns (uint256) {\\n\\t\\treturn _length(map._inner);\\n\\t}\\n\\n\\tfunction at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n\\t\\t(bytes32 key, bytes32 value) = _at(map._inner, index);\\n\\t\\treturn (uint256(key), address(uint160(uint256(value))));\\n\\t}\\n\\n\\tfunction tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n\\t\\t(bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n\\t\\treturn (success, address(uint160(uint256(value))));\\n\\t}\\n\\n\\tfunction get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n\\t}\\n\\n\\tfunction get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n\\t}\\n}\\n\\nlibrary EnumerableSet {\\n\\tstruct Set {\\n\\t\\tbytes32[] _values;\\n\\t\\tmapping (bytes32 =\\u003e uint256) _indexes;\\n\\t}\\n\\n\\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\\n\\t\\tif (!_contains(set, value)) {\\n\\t\\t\\tset._values.push(value);\\n\\t\\t\\tset._indexes[value] = set._values.length;\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\\n\\t\\tuint256 valueIndex = set._indexes[value];\\n\\t\\tif (valueIndex != 0) {\\n\\t\\t\\tuint256 toDeleteIndex = valueIndex - 1;\\n\\t\\t\\tuint256 lastIndex = set._values.length - 1;\\n\\t\\t\\tbytes32 lastvalue = set._values[lastIndex];\\n\\t\\t\\tset._values[toDeleteIndex] = lastvalue;\\n\\t\\t\\tset._indexes[lastvalue] = toDeleteIndex + 1;\\n\\t\\t\\tset._values.pop();\\n\\t\\t\\tdelete set._indexes[value];\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\\n\\t\\treturn set._indexes[value] != 0;\\n\\t}\\n\\n\\tfunction _length(Set storage set) private view returns (uint256) {\\n\\t\\treturn set._values.length;\\n\\t}\\n\\n\\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\\n\\t\\trequire(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n\\t\\treturn set._values[index];\\n\\t}\\n\\n\\tstruct Bytes32Set {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, value);\\n\\t}\\n\\n\\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, value);\\n\\t}\\n\\n\\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, value);\\n\\t}\\n\\n\\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n\\t\\treturn _at(set._inner, index);\\n\\t}\\n\\n\\tstruct AddressSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction add(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\tfunction length(AddressSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_at(set._inner, index))));\\n\\t}\\n\\n\\tstruct UintSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(value));\\n\\t}\\n\\n\\tfunction length(UintSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n\\t\\treturn uint256(_at(set._inner, index));\\n\\t}\\n}\\n\\nlibrary Address {\\n\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\tuint256 size;\\n\\t\\tassembly { size := extcodesize(account) }\\n\\t\\treturn size \\u003e 0;\\n\\t}\\n\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\n\\t\\trequire(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\t\\t(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n\\t\\trequire(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n\\t}\\n\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\trequire(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\t\\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n\\t\\treturn functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n\\t}\\n\\n\\tfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\t\\t(bool success, bytes memory returndata) = target.staticcall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n\\t}\\n\\n\\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\t\\t(bool success, bytes memory returndata) = target.delegatecall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nlibrary SafeMath {\\n\\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\tif (c \\u003c a) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b \\u003e a) return (false, 0);\\n\\t\\treturn (true, a - b);\\n\\t}\\n\\n\\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (a == 0) return (true, 0);\\n\\t\\tuint256 c = a * b;\\n\\t\\tif (c / a != b) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a / b);\\n\\t}\\n\\n\\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a % b);\\n\\t}\\n\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tif (a == 0) return 0;\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n\\t\\treturn a % b;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, errorMessage);\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\\ninterface IERC165 {\\n\\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n\\tbytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\tmapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n\\tconstructor() {\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC165);\\n\\t}\\n\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n\\t\\treturn _supportedInterfaces[interfaceId];\\n\\t}\\n\\n\\tfunction _registerInterface(bytes4 interfaceId) internal virtual {\\n\\t\\trequire(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n\\t\\t_supportedInterfaces[interfaceId] = true;\\n\\t}\\n}\\n\\ninterface IERC721 is IERC165 {\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256 balance);\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\tfunction transferFrom(address from, address to, uint256 tokenId) external;\\n\\tfunction approve(address to, uint256 tokenId) external;\\n\\tfunction getApproved(uint256 tokenId) external view returns (address operator);\\n\\tfunction setApprovalForAll(address operator, bool _approved) external;\\n\\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\\ninterface IERC721Enumerable is IERC721 {\\n\\tfunction totalSupply() external view returns (uint256);\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\tfunction tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\\ninterface IERC721Metadata is IERC721 {\\n\\tfunction name() external view returns (string memory);\\n\\tfunction symbol() external view returns (string memory);\\n\\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\tusing EnumerableSet for EnumerableSet.UintSet;\\n\\tusing EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\tusing Strings for uint256;\\n\\n\\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\tmapping (address =\\u003e EnumerableSet.UintSet) private _holderTokens;\\n\\tEnumerableMap.UintToAddressMap private _tokenOwners;\\n\\tmapping (uint256 =\\u003e address) private _tokenApprovals;\\n\\tmapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\n\\tstring private _name;\\n\\tstring private _symbol;\\n\\tmapping (uint256 =\\u003e string) private _tokenURIs;\\n\\tstring private _baseURI;\\n\\tbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\tbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\tbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\tconstructor (string memory name_, string memory symbol_) {\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721);\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n\\t}\\n\\n\\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\\n\\t\\trequire(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\t\\treturn _holderTokens[owner].length();\\n\\t}\\n\\n\\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n\\t\\treturn _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n\\t}\\n\\n\\tfunction name() public view virtual override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction symbol() public view virtual override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\t\\tstring memory _tokenURI = _tokenURIs[tokenId];\\n\\t\\tstring memory base = baseURI();\\n\\t\\tif (bytes(base).length == 0) {\\n\\t\\t\\treturn _tokenURI;\\n\\t\\t}\\n\\t\\tif (bytes(_tokenURI).length \\u003e 0) {\\n\\t\\t\\treturn string(abi.encodePacked(base, _tokenURI));\\n\\t\\t}\\n\\t\\treturn string(abi.encodePacked(base, tokenId.toString(), string(\\\".json\\\")));\\n\\t}\\n\\n\\tfunction baseURI() public view virtual returns (string memory) {\\n\\t\\treturn _baseURI;\\n\\t}\\n\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n\\t\\treturn _holderTokens[owner].at(index);\\n\\t}\\n\\n\\tfunction totalSupply() public view virtual override returns (uint256) {\\n\\t\\treturn _tokenOwners.length();\\n\\t}\\n\\n\\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n\\t\\t(uint256 tokenId, ) = _tokenOwners.at(index);\\n\\t\\treturn tokenId;\\n\\t}\\n\\n\\tfunction approve(address to, uint256 tokenId) public virtual override {\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\trequire(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\t\\trequire(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n\\t\\t\\t\\\"ERC721: approve caller is not owner nor approved for all\\\"\\n\\t\\t);\\n\\t\\t_approve(to, tokenId);\\n\\t}\\n\\n\\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\t\\treturn _tokenApprovals[tokenId];\\n\\t}\\n\\n\\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\\n\\t\\trequire(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\t\\t_operatorApprovals[_msgSender()][operator] = approved;\\n\\t\\temit ApprovalForAll(_msgSender(), operator, approved);\\n\\t}\\n\\n\\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n\\t\\treturn _operatorApprovals[owner][operator];\\n\\t}\\n\\n\\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\t\\t_transfer(from, to, tokenId);\\n\\t}\\n\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n\\t\\tsafeTransferFrom(from, to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\t\\t_safeTransfer(from, to, tokenId, _data);\\n\\t}\\n\\n\\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n\\t\\t_transfer(from, to, tokenId);\\n\\t\\trequire(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t}\\n\\n\\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\\n\\t\\treturn _tokenOwners.contains(tokenId);\\n\\t}\\n\\n\\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\treturn (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n\\t}\\n\\n\\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\\n\\t\\t_safeMint(to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n\\t\\t_mint(to, tokenId);\\n\\t\\trequire(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t}\\n\\n\\tfunction _mint(address to, uint256 tokenId) internal virtual {\\n\\t\\trequire(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n\\t\\trequire(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\t\\t_beforeTokenTransfer(address(0), to, tokenId);\\n\\t\\t_holderTokens[to].add(tokenId);\\n\\t\\t_tokenOwners.set(tokenId, to);\\n\\t\\temit Transfer(address(0), to, tokenId);\\n\\t}\\n\\n\\tfunction _burn(uint256 tokenId) internal virtual {\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\t_beforeTokenTransfer(owner, address(0), tokenId);\\n\\t\\t_approve(address(0), tokenId);\\n\\t\\tif (bytes(_tokenURIs[tokenId]).length != 0) {\\n\\t\\t\\tdelete _tokenURIs[tokenId];\\n\\t\\t}\\n\\t\\t_holderTokens[owner].remove(tokenId);\\n\\t\\t_tokenOwners.remove(tokenId);\\n\\t\\temit Transfer(owner, address(0), tokenId);\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\\n\\t\\trequire(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n\\t\\trequire(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\t\\t_beforeTokenTransfer(from, to, tokenId);\\n\\t\\t_approve(address(0), tokenId);\\n\\t\\t_holderTokens[from].remove(tokenId);\\n\\t\\t_holderTokens[to].add(tokenId);\\n\\t\\t_tokenOwners.set(tokenId, to);\\n\\t\\temit Transfer(from, to, tokenId);\\n\\t}\\n\\n\\tfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n\\t\\t_tokenURIs[tokenId] = _tokenURI;\\n\\t}\\n\\n\\tfunction _setBaseURI(string memory baseURI_) internal virtual {\\n\\t\\t_baseURI = baseURI_;\\n\\t}\\n\\n\\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n\\tprivate returns (bool)\\n\\t{\\n\\t\\tif (!to.isContract()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n\\t\\t\\t\\tIERC721Receiver(to).onERC721Received.selector,\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\ttokenId,\\n\\t\\t\\t\\t_data\\n\\t\\t\\t), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t\\tbytes4 retval = abi.decode(returndata, (bytes4));\\n\\t\\treturn (retval == _ERC721_RECEIVED);\\n\\t}\\n\\n\\tfunction _approve(address to, uint256 tokenId) internal virtual {\\n\\t\\t_tokenApprovals[tokenId] = to;\\n\\t\\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n\\t}\\n\\n\\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"},\"LGBTNFT.sol\":{\"content\":\"pragma solidity \\u003c=8.7.0;\\npragma experimental ABIEncoderV2;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./ERC721.sol\\\";\\n\\ncontract LGBTNFT is ERC721, ReentrancyGuard, Ownable {\\n\\tuint256 public price = 100000000000000000;\\n\\tuint256 public maxSupply = 4869;\\n\\tuint256 public currentSupply = 0;\\n\\taddress public LGBTokenContract;\\n\\tuint256 public LGBTokenDropPerMint = 1000000000000;\\n\\tuint256 public openAt = 1638554400;\\n\\n\\tconstructor() ERC721(\\\"LGBT NFT\\\", \\\"LGBT+\\\") {\\n\\t\\t_setBaseURI(string(\\\"https://lgbt-nft.online/meta/\\\"));\\n\\t}\\n\\n\\tfunction isOpen() public view returns (bool) {\\n\\t\\tif (block.timestamp \\u003e= openAt) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction mint() public payable nonReentrant {\\n\\t\\trequire(isOpen(), \\\"Minting is not yet enabled\\\");\\n\\t\\trequire(price \\u003c= msg.value, \\\"Not enough Ether sent\\\");\\n\\t\\tuint256 Count = msg.value/price;\\n\\t\\trequire(currentSupply \\u003c maxSupply, \\\"Minting closed\\\");\\n\\t\\tuint256 remaining = maxSupply-currentSupply;\\n\\t\\trequire(Count \\u003c= remaining, \\\"Not enough NFT remaining for this Ether amount\\\");\\n\\t\\tfor (uint256 i=0; i\\u003cCount; i++) {\\n\\t\\t\\t_safeMint(msg.sender, currentSupply);\\n\\t\\t\\tif (currentSupply \\u003c maxSupply/2) {\\n\\t\\t\\t\\tERC20(LGBTokenContract).transfer(msg.sender, LGBTokenDropPerMint);\\n\\t\\t\\t}\\n\\t\\t\\tcurrentSupply += 1;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction withdraw() public onlyOwner {\\n\\t\\tuint256 balance = address(this).balance;\\n\\t\\tpayable(msg.sender).transfer(balance);\\n\\t}\\n\\n\\tfunction setLGBTokenContract(address contractAddress) external onlyOwner {\\n\\t\\tLGBTokenContract = contractAddress;\\n\\t}\\n\\n\\treceive() external payable {}\\n}\\n\\ninterface ERC20 {\\n\\tfunction transfer(address, uint256) external returns (bool);\\n\\tfunction approve(address, uint256) external returns (bool);\\n\\tfunction transferFrom(address, address, uint256) external returns (bool);\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LGBTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LGBTokenDropPerMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setLGBTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LGBTNFT","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://91f6c2a1212b28bf2453d1d5489c403918f4efab8a3b9bf3859115ecd245c7bd"}]}