{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (IDEXFactory);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface ITokenConverter {\r\n    function convertViaWETH(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amount\r\n    ) external view returns (uint256);\r\n\r\n    function DEFAULT_FACTORY() external view returns (IDEXFactory);\r\n}\r\n\r\nabstract contract Auth {\r\n    address public owner;\r\n    mapping(address => bool) public isAuthorized;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        isAuthorized[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"!OWNER\");\r\n        _;\r\n    }\r\n    modifier authorized() {\r\n        require(isAuthorized[msg.sender], \"!AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function authorize(address adr) external onlyOwner {\r\n        isAuthorized[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) external onlyOwner {\r\n        isAuthorized[adr] = false;\r\n    }\r\n\r\n    function setAuthorizationMultiple(address[] memory adr, bool value) external onlyOwner {\r\n        for (uint256 i = 0; i < adr.length; i++) {\r\n            isAuthorized[adr[i]] = value;\r\n        }\r\n    }\r\n\r\n    function transferOwnership(address payable adr) external onlyOwner {\r\n        isAuthorized[owner] = false;\r\n        owner = adr;\r\n        isAuthorized[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ncontract DividendDistributor {\r\n    address public _token;\r\n    IWETH WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IERC20 public dividendToken;\r\n    IDEXRouter public router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n        uint256 index;\r\n        uint256 lastClaimed;\r\n    }\r\n    mapping(address => Share) public shares;\r\n    address[] shareholders;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public _ACCURACY_ = 1e36;\r\n    uint256 public minPeriod = 30 minutes;\r\n    uint256 public minDistribution = 1e18;\r\n    uint256 public shareThreshold = 0;\r\n\r\n    uint256 public currentIndex;\r\n    uint256 public maxGas = 500000;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20 _dividendToken) {\r\n        dividendToken = _dividendToken;\r\n        _token = msg.sender;\r\n    }\r\n\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution,\r\n        uint256 _shareThreshold\r\n    ) external onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n        shareThreshold = _shareThreshold;\r\n    }\r\n\r\n    function setMaxGas(uint256 gas) external onlyToken {\r\n        maxGas = gas;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external onlyToken {\r\n        Share storage _S = shares[shareholder];\r\n        if (_S.amount > 0) {\r\n            _sendDividend(shareholder);\r\n            if (amount < shareThreshold) _removeShareholder(shareholder);\r\n        } else if (amount >= shareThreshold) _addShareholder(shareholder);\r\n        totalShares -= _S.amount;\r\n        totalShares += amount;\r\n        _S.amount = amount;\r\n        _S.totalExcluded = _getCumulativeDividends(shareholder);\r\n    }\r\n\r\n    function deposit() external payable onlyToken {\r\n        uint256 gotDividendToken;\r\n        gotDividendToken = dividendToken.balanceOf(address(this));\r\n        if (address(dividendToken) == address(WETH)) {\r\n            WETH.deposit{value: msg.value}();\r\n        } else {\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(WETH);\r\n            path[1] = address(dividendToken);\r\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n        }\r\n        gotDividendToken = dividendToken.balanceOf(address(this)) - gotDividendToken;\r\n\r\n        totalDividends += gotDividendToken;\r\n        dividendsPerShare += (_ACCURACY_ * gotDividendToken) / totalShares;\r\n    }\r\n\r\n    function sendDividends() external onlyToken {\r\n        uint256 shareholderCount = shareholders.length;\r\n        if (shareholderCount == 0) return;\r\n\r\n        uint256 gasUsed;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 _currentIndex = currentIndex;\r\n        for (uint256 i = 0; i < shareholderCount && gasUsed < maxGas; i++) {\r\n            if (_currentIndex >= shareholderCount) _currentIndex = 0;\r\n            address _shareholder = shareholders[_currentIndex];\r\n            if (\r\n                block.timestamp > shares[_shareholder].lastClaimed + minPeriod &&\r\n                getUnpaidEarnings(_shareholder) > minDistribution\r\n            ) {\r\n                _sendDividend(_shareholder);\r\n            }\r\n            gasUsed += gasLeft - gasleft();\r\n            gasLeft = gasleft();\r\n            _currentIndex++;\r\n        }\r\n        currentIndex = _currentIndex;\r\n    }\r\n\r\n    function _getCumulativeDividends(address shareholder) internal view returns (uint256) {\r\n        return (shares[shareholder].amount * dividendsPerShare) / _ACCURACY_;\r\n    }\r\n\r\n    function _sendDividend(address shareholder) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if (amount == 0) return;\r\n\r\n        dividendToken.transfer(shareholder, amount);\r\n        totalDistributed += amount;\r\n        shares[shareholder].totalRealised += amount;\r\n        shares[shareholder].totalExcluded = _getCumulativeDividends(shareholder);\r\n        shares[shareholder].lastClaimed = block.timestamp;\r\n    }\r\n\r\n    function _addShareholder(address shareholder) internal {\r\n        shares[shareholder].index = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function _removeShareholder(address shareholder) internal {\r\n        _sendDividend(shareholder);\r\n        shareholders[shares[shareholder].index] = shareholders[shareholders.length - 1];\r\n        shares[shareholders[shareholders.length - 1]].index = shares[shareholder].index;\r\n        delete shares[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function claimDividend() external {\r\n        _sendDividend(msg.sender);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        uint256 _dividends = _getCumulativeDividends(shareholder);\r\n        uint256 _excluded = shares[shareholder].totalExcluded;\r\n        return _dividends > _excluded ? _dividends - _excluded : 0;\r\n    }\r\n}\r\n\r\ncontract HyperSonic is Auth {\r\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    ITokenConverter public TOKEN_CONVERTER = ITokenConverter(address(0));\r\n\r\n    string public constant name = \"HyperSonic\";\r\n    string public constant symbol = \"HYPERSONIC\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant totalSupply = 1e6 * 1e18;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    mapping(address => bool) public isFeeExempt;\r\n    mapping(address => bool) public isBuyLimitExempt;\r\n    mapping(address => bool) public isWalletLimitExempt;\r\n    mapping(address => bool) public isDividendExempt;\r\n\r\n    mapping(address => bool) public isPair;\r\n    mapping(address => bool) public isRouter;\r\n\r\n    bool public buyLimitEnabled = true;\r\n    uint256 public buyLimitBUSD = 5000e18;\r\n\r\n    uint256 public walletLimit = 5000e18;\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n    DividendDistributor public distributor;\r\n\r\n    uint256 public launchedAt;\r\n    bool public tradingOpen;\r\n\r\n    struct FeeSettings {\r\n        uint256 liquidity;\r\n        uint256 dividends;\r\n        uint256 total;\r\n        uint256 _burn;\r\n        uint256 _denominator;\r\n    }\r\n    struct SwapbackSettings {\r\n        bool enabled;\r\n        uint256 amount;\r\n    }\r\n\r\n    FeeSettings public fees =\r\n        FeeSettings({liquidity: 100, dividends: 300, total: 400, _burn: 100, _denominator: 10000});\r\n    SwapbackSettings public swapback = SwapbackSettings({enabled: true, amount: totalSupply / 1000});\r\n\r\n    bool inSwap;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountTKN);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    constructor() {\r\n        // UNISWAP V2 ROUTER 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        pair = router.factory().createPair(WETH, address(this));\r\n        allowance[address(this)][address(router)] = ~uint256(0);\r\n\r\n        distributor = new DividendDistributor(IERC20(WETH));\r\n\r\n        isFeeExempt[DEAD] = true;\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isFeeExempt[address(router)] = true;\r\n\r\n        isBuyLimitExempt[DEAD] = true;\r\n        isBuyLimitExempt[msg.sender] = true;\r\n        isBuyLimitExempt[address(this)] = true;\r\n        isBuyLimitExempt[address(router)] = true;\r\n\r\n        isWalletLimitExempt[DEAD] = true;\r\n        isWalletLimitExempt[msg.sender] = true;\r\n        isWalletLimitExempt[address(this)] = true;\r\n        isWalletLimitExempt[address(router)] = true;\r\n\r\n        isDividendExempt[DEAD] = true;\r\n        isDividendExempt[msg.sender] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[address(router)] = true;\r\n\r\n        isDividendExempt[pair] = true;\r\n        isWalletLimitExempt[pair] = true;\r\n\r\n        isPair[pair] = true;\r\n        isRouter[address(router)] = true;\r\n\r\n        // Owner must manually whitelist DXSale presale contract\r\n        // isFeeExempt[_presaleContract] = true;\r\n        // isBuyLimitExempt[_presaleContract] = true;\r\n        // isDividendExempt[_presaleContract] = true;\r\n\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, ~uint256(0));\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        if (allowance[sender][msg.sender] != ~uint256(0)) allowance[sender][msg.sender] -= amount;\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if (inSwap) return _basicTransfer(sender, recipient, amount);\r\n        if (!tradingOpen) require(isAuthorized[sender], \"Trading not open yet\");\r\n\r\n        bool _isBuy = isPair[sender] && !isRouter[recipient];\r\n        bool _isTradingOperation = isPair[sender] ||\r\n            isPair[recipient] ||\r\n            isPair[msg.sender] ||\r\n            isRouter[sender] ||\r\n            isRouter[recipient] ||\r\n            isRouter[msg.sender];\r\n        bool _isFirst24Hours = block.timestamp < (launchedAt + 24 hours);\r\n        bool _mustLimitBuyAmount = buyLimitEnabled && !isBuyLimitExempt[recipient];\r\n        bool _isTemporaryTaxFreeBuy = _isFirst24Hours && _isBuy;\r\n\r\n        // Limit wallet balance during first 24h\r\n        if (_isFirst24Hours && !isWalletLimitExempt[recipient])\r\n            require(balanceOf[recipient] + amount <= walletLimit, \"Recipient balance limit exceeded\");\r\n\r\n        // Limit BUY during first 24h\r\n        if (_isBuy && _mustLimitBuyAmount) {\r\n            uint256 _BUSDEquivalent = TOKEN_CONVERTER.convertViaWETH(address(this), USDT, amount);\r\n            if (_BUSDEquivalent > 0) require(_BUSDEquivalent <= buyLimitBUSD, \"BUY limit exceeded\");\r\n        }\r\n\r\n        // Sells accumulated fee for BNB and distribute\r\n        if (swapback.enabled && (balanceOf[address(this)] >= swapback.amount) && !_isTradingOperation) {\r\n            // (?swapback enabled?) Sells accumulated TKN fees for BNB\r\n            _sellAndDistributeAccumulatedTKNFee();\r\n        }\r\n\r\n        // Launch at first liquidity\r\n        if (launchedAt == 0 && isPair[recipient]) {\r\n            require(balanceOf[sender] > 0);\r\n            launchedAt = block.timestamp;\r\n        }\r\n\r\n        // Take fee; burn;\r\n        // Exchange balances\r\n        balanceOf[sender] -= amount;\r\n        uint256 amountReceived = amount;\r\n        if (!isFeeExempt[sender] && !isFeeExempt[recipient] && !_isTemporaryTaxFreeBuy) {\r\n            if (fees.total > 0) {\r\n                uint256 feeAmount = (amount * fees.total) / fees._denominator;\r\n                balanceOf[address(this)] += feeAmount;\r\n                emit Transfer(sender, address(this), feeAmount);\r\n                amountReceived -= feeAmount;\r\n            }\r\n            if (fees._burn > 0) {\r\n                uint256 burnAmount = (amount * fees._burn) / fees._denominator;\r\n                balanceOf[DEAD] += burnAmount;\r\n                emit Transfer(sender, DEAD, burnAmount);\r\n                amountReceived -= burnAmount;\r\n            }\r\n        }\r\n        balanceOf[recipient] += amountReceived;\r\n        emit Transfer(sender, recipient, amountReceived);\r\n\r\n        // Dividend tracker\r\n        if (!isDividendExempt[sender]) try distributor.setShare(sender, balanceOf[sender]) {} catch {}\r\n        if (!isDividendExempt[recipient]) try distributor.setShare(recipient, balanceOf[recipient]) {} catch {}\r\n        try distributor.sendDividends() {} catch {}\r\n\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        balanceOf[sender] -= amount;\r\n        balanceOf[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _sellAndDistributeAccumulatedTKNFee() internal swapping {\r\n        // Swap the fee taken above to BNB and distribute to liquidity and dividends;\r\n        // Add some liquidity\r\n        uint256 halfLiquidityFee = fees.liquidity / 2;\r\n        uint256 TKNtoLiquidity = (swapback.amount * halfLiquidityFee) / fees.total;\r\n        uint256 amountToSwap = swapback.amount - TKNtoLiquidity;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WETH;\r\n        uint256 gotBNB = address(this).balance;\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        gotBNB = address(this).balance - gotBNB;\r\n\r\n        uint256 totalBNBFee = fees.total - halfLiquidityFee;\r\n        uint256 BNBtoLiquidity = (gotBNB * halfLiquidityFee) / totalBNBFee;\r\n        uint256 BNBtoDividends = (gotBNB * fees.dividends) / totalBNBFee;\r\n\r\n        try distributor.deposit{value: BNBtoDividends}() {} catch {}\r\n\r\n        if (TKNtoLiquidity > 0) {\r\n            router.addLiquidityETH{value: BNBtoLiquidity}(address(this), TKNtoLiquidity, 0, 0, owner, block.timestamp);\r\n            emit AutoLiquify(BNBtoLiquidity, TKNtoLiquidity);\r\n        }\r\n    }\r\n\r\n    function _sellBNB(uint256 amount, address to) internal swapping {\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = address(this);\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(0, path, to, block.timestamp);\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return totalSupply - balanceOf[DEAD] - balanceOf[ZERO];\r\n    }\r\n\r\n    // SET EXEMPTS\r\n\r\n    function setIsFeeExempt(address[] memory holders, bool exempt) public onlyOwner {\r\n        for (uint256 i = 0; i < holders.length; i++) {\r\n            isFeeExempt[holders[i]] = exempt;\r\n        }\r\n    }\r\n\r\n    function setIsBuyLimitExempt(address[] memory holders, bool exempt) public onlyOwner {\r\n        for (uint256 i = 0; i < holders.length; i++) {\r\n            isBuyLimitExempt[holders[i]] = exempt;\r\n        }\r\n    }\r\n\r\n    function setIsWalletLimitExempt(address[] memory holders, bool exempt) public onlyOwner {\r\n        for (uint256 i = 0; i < holders.length; i++) {\r\n            isWalletLimitExempt[holders[i]] = exempt;\r\n        }\r\n    }\r\n\r\n    function setIsDividendExempt(address[] memory holders, bool exempt) public onlyOwner {\r\n        for (uint256 i = 0; i < holders.length; i++) {\r\n            require(holders[i] != address(this) && !(isPair[holders[i]] && !exempt)); // Forbid including back token and pairs\r\n            isDividendExempt[holders[i]] = exempt;\r\n            distributor.setShare(holders[i], exempt ? 0 : balanceOf[holders[i]]);\r\n        }\r\n    }\r\n\r\n    function setFullExempt(address[] memory holders, bool exempt) public onlyOwner {\r\n        setIsFeeExempt(holders, exempt);\r\n        setIsBuyLimitExempt(holders, exempt);\r\n        setIsWalletLimitExempt(holders, exempt);\r\n        setIsDividendExempt(holders, exempt);\r\n    }\r\n\r\n    function setIsPair(address[] memory addresses, bool isPair_) public onlyOwner {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            isPair[addresses[i]] = isPair_;\r\n        }\r\n        setIsDividendExempt(addresses, isPair_);\r\n        setIsWalletLimitExempt(addresses, isPair_);\r\n    }\r\n\r\n    function setIsRouter(address[] memory addresses, bool isRouter_) public onlyOwner {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            isRouter[addresses[i]] = isRouter_;\r\n        }\r\n        setFullExempt(addresses, isRouter_);\r\n    }\r\n\r\n    // TOKEN SETTINGS\r\n\r\n    function setBuyLimitSettings(uint256 amount, bool enabled) external onlyOwner {\r\n        buyLimitBUSD = amount;\r\n        buyLimitEnabled = enabled;\r\n    }\r\n\r\n    function setWalletLimitSettings(uint256 amount) external onlyOwner {\r\n        walletLimit = amount;\r\n    }\r\n\r\n    function setFees(\r\n        uint256 _liquidity,\r\n        uint256 _dividends,\r\n        uint256 _burn,\r\n        uint256 _denominator\r\n    ) external onlyOwner {\r\n        fees = FeeSettings({\r\n            liquidity: _liquidity,\r\n            dividends: _dividends,\r\n            total: _liquidity + _dividends,\r\n            _burn: _burn,\r\n            _denominator: _denominator\r\n        });\r\n        require(fees.total + _burn < fees._denominator / 4);\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external onlyOwner {\r\n        swapback.enabled = _enabled;\r\n        swapback.amount = _amount;\r\n    }\r\n\r\n    function setTradingStatus(bool _status) external onlyOwner {\r\n        tradingOpen = _status;\r\n    }\r\n\r\n    // DISTRIBUTOR SETTINGS\r\n\r\n    function deployNewDistributor(IERC20 _dividendToken) external onlyOwner {\r\n        distributor = new DividendDistributor(_dividendToken);\r\n    }\r\n\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution,\r\n        uint256 _shareThreshold\r\n    ) external onlyOwner {\r\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution, _shareThreshold);\r\n    }\r\n\r\n    function setDistributorGas(uint256 gas) external onlyOwner {\r\n        require(gas <= 750000, \"Max 750000 gas allowed\");\r\n        distributor.setMaxGas(gas);\r\n    }\r\n\r\n    function setTokenConverter(ITokenConverter tokenConverter) external onlyOwner {\r\n        TOKEN_CONVERTER = tokenConverter;\r\n    }\r\n\r\n    /* Airdrop Begins */\r\n    function makeItRain(address[] memory addresses, uint256[] memory tokens) external onlyOwner {\r\n        uint256 showerCapacity = 0;\r\n        require(addresses.length == tokens.length, \"Mismatch between Address and token count\");\r\n        for (uint256 i = 0; i < addresses.length; i++) showerCapacity += tokens[i];\r\n        require(balanceOf[msg.sender] >= showerCapacity, \"Not enough tokens to airdrop\");\r\n        for (uint256 i = 0; i < addresses.length; i++) _basicTransfer(msg.sender, addresses[i], tokens[i]);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTKN\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TOKEN_CONVERTER\",\"outputs\":[{\"internalType\":\"contract ITokenConverter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLimitBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_dividendToken\",\"type\":\"address\"}],\"name\":\"deployNewDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBuyLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWalletLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"makeItRain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAuthorizationMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setBuyLimitSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shareThreshold\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setFullExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsBuyLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isPair_\",\"type\":\"bool\"}],\"name\":\"setIsPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isRouter_\",\"type\":\"bool\"}],\"name\":\"setIsRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsWalletLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenConverter\",\"name\":\"tokenConverter\",\"type\":\"address\"}],\"name\":\"setTokenConverter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setTradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setWalletLimitSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"HyperSonic","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4b4cf70ba9bf3f20178f81d8f43365c4241d2f276b727bb317b3fcd87a403b91"}]}