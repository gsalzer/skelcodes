{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.9;\r\n\r\ninterface IMoonCatAcclimator {\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ninterface IMoonCatRescue {\r\n    function rescueOrder(uint256 tokenId) external view returns (bytes5);\r\n    function catOwners(bytes5 catId) external view returns (address);\r\n}\r\n\r\ninterface IMoonCatAccessories {\r\n    function doesMoonCatOwnAccessory (uint256 rescueOrder, uint256 accessoryId) external view returns (bool);\r\n}\r\n\r\nlibrary MoonCatBitSet {\r\n\r\n    bytes32 constant Mask =  0x0000000000000000000000000000000000000000000000000000000000000001;\r\n\r\n    function setBit(bytes32[100] storage set, uint16 index)\r\n        internal\r\n    {\r\n        uint16 wordIndex = index / 256;\r\n        uint16 bitIndex = index % 256;\r\n        bytes32 mask = Mask << (255 - bitIndex);\r\n        set[wordIndex] |= mask;\r\n    }\r\n\r\n    function clearBit(bytes32[100] storage set, uint16 index)\r\n        internal\r\n    {\r\n        uint16 wordIndex = index / 256;\r\n        uint16 bitIndex = index % 256;\r\n        bytes32 mask = ~(Mask << (255 - bitIndex));\r\n        set[wordIndex] &= mask;\r\n    }\r\n\r\n    function checkBit(bytes32[100] memory set, uint256 index)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 wordIndex = index / 256;\r\n        uint256 bitIndex = index % 256;\r\n        bytes32 mask = Mask << (255 - bitIndex);\r\n        return (mask & set[wordIndex]) != 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title MoonCatPop Raffle Validator\r\n * @dev Does checks for the data submitted to the MoonCatPop raffle contract for validity.\r\n */\r\ncontract MoonCatPopRaffleValidator {\r\n\r\n    ///// External Contracts /////\r\n    IMoonCatAcclimator MCA = IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69);\r\n    IMoonCatRescue MCR = IMoonCatRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6);\r\n    IMoonCatAccessories ACC = IMoonCatAccessories(0x8d33303023723dE93b213da4EB53bE890e747C63);\r\n\r\n    bytes32[100] public Available;\r\n\r\n    address immutable raffleContractAddress;\r\n\r\n    /**\r\n     * @dev Is a given MoonCat already entered in the raffle?\r\n     */\r\n    function isAvailable (uint256 rescueOrder) public view returns (bool) {\r\n        return MoonCatBitSet.checkBit(Available, rescueOrder);\r\n    }\r\n\r\n    /**\r\n     * @dev Callback function for the Raffle contract to check if a ticket should be allowed.\r\n     */\r\n    function validate (address account, bytes memory metadata) public returns (bool) {\r\n        require(msg.sender == raffleContractAddress, \"Invalid Sender\");\r\n        require(metadata.length >= 4, \"Invalid Metadata\");\r\n\r\n        uint16 rescueOrder;\r\n        assembly {\r\n            rescueOrder := mload(add(add(metadata, 0x2), 0))\r\n        }\r\n\r\n        require(MoonCatBitSet.checkBit(Available, rescueOrder), \"Already Minted\");\r\n        MoonCatBitSet.clearBit(Available, rescueOrder);\r\n\r\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \"Not Acclimated\");\r\n\r\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\r\n        require((account == moonCatOwner)\r\n                || (account == MCA.getApproved(rescueOrder))\r\n                || (MCA.isApprovedForAll(moonCatOwner, account)),\r\n                \"Not Owner or Approved\");\r\n\r\n\r\n        uint16 accessoryCount;\r\n        assembly {\r\n            accessoryCount := mload(add(add(metadata, 0x2), 2))\r\n        }\r\n\r\n        require(metadata.length >= accessoryCount * 2 + 4, \"Invalid Metadata\");\r\n\r\n        uint16 accessoryId;\r\n        for (uint i = 0; i < accessoryCount; i++) {\r\n            uint256 offset = (i + 2) * 2;\r\n            assembly {\r\n              accessoryId := mload(add(add(metadata, 0x2), offset))\r\n            }\r\n            require(ACC.doesMoonCatOwnAccessory(rescueOrder, accessoryId), \"Accessory Not Owned\");\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    constructor (address raffleContract) {\r\n        for (uint i = 0; i < 100; i++) {\r\n            //initialize all BitSet Values to save ticker buyers gas\r\n            Available[i] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n        }\r\n        raffleContractAddress = raffleContract;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"raffleContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Available\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"isAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MoonCatPopRaffleValidator","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004a859ad2e94004dbd65ad75b26719f289370083f","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7f16dc2a1277a986ba741c50a62bd48381150b48b34199dca501f42725bae030"}]}