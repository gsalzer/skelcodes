{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.16\r\n\"\"\"\r\n@title \"Zap\" Depositer for permissionless ibBTC metapools\r\n@author tabish@badger.finance\r\n\"\"\"\r\n\r\ninterface ERC20:\r\n    def transfer(_receiver: address, _amount: uint256): nonpayable\r\n    def transferFrom(_sender: address, _receiver: address, _amount: uint256): nonpayable\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def decimals() -> uint256: view\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\ninterface CurveMeta:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256, _receiver: address) -> uint256: nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) -> uint256[N_COINS]: nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256, _receiver: address) -> uint256: nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) -> uint256: nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\r\n    def exchange_underlying(i: int128, j: int128, _dx: uint256, _min_dy: uint256, _receiver: address) -> uint256: nonpayable\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CurveBase:\r\n    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[BASE_N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[BASE_N_COINS], max_burn_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[BASE_N_COINS], deposit: bool) -> uint256: view\r\n    def coins(i: int128) -> address: view\r\n    def fee() -> uint256: view\r\n\r\ninterface WrappedIbbtcEth:\r\n    def mint(_shares: uint256): nonpayable\r\n    def burn(_shares: uint256): nonpayable\r\n    def balanceOf(_user: address) -> uint256: view\r\n    def sharesOf(_user: address) -> uint256: view\r\n    def balanceToShares(_balance: uint256) -> uint256: view\r\n    def sharesToBalance(_balance: uint256) -> uint256: view\r\n\r\n\r\nN_COINS: constant(int128) = 2 # wibbtc, crvRenWSBTC\r\nMAX_COIN: constant(int128) = N_COINS-1\r\nBASE_N_COINS: constant(int128) = 3 # renBTC, wBTC, sBTC\r\nN_ALL_COINS: constant(int128) = N_COINS + BASE_N_COINS - 1\r\n\r\nBASE_POOL: constant(address) = 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714\r\nBASE_LP_TOKEN: constant(address) = 0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3\r\nBASE_COINS: constant(address[3]) = [\r\n    0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D,  # renBTC\r\n    0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599,  # wBTC\r\n    0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6,  # sBTC\r\n]\r\n\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nFEE_IMPRECISION: constant(uint256) = 100 * 10 ** 8  # % of the fee\r\n\r\nIBBTC_WRAPPER_PROXY: constant(address) = 0x8751D4196027d4e6DA63716fA7786B5174F04C15\r\nWIBBTC_TOKEN: constant(address) = 0x8751D4196027d4e6DA63716fA7786B5174F04C15\r\nIBBTC_TOKEN: constant(address) = 0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F\r\n\r\n# coin -> pool -> is approved to transfer?\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\n\r\n@external\r\ndef __init__():\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    \"\"\"\r\n    base_coins: address[3] = BASE_COINS\r\n    for coin in base_coins:\r\n        ERC20(coin).approve(BASE_POOL, MAX_UINT256)\r\n\r\n    ERC20(IBBTC_TOKEN).approve(IBBTC_WRAPPER_PROXY, MAX_UINT256)\r\n\r\n@external\r\ndef add_liquidity(\r\n    _pool: address,\r\n    _deposit_amounts: uint256[N_ALL_COINS],\r\n    _min_mint_amount: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Wrap underlying coins and deposit them into `_pool`\r\n    @param _pool Address of the pool to deposit into\r\n    @param _deposit_amounts List of amounts of underlying coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n    base_coins: address[3] = BASE_COINS\r\n\r\n    # for ibbtc deposit\r\n    if _deposit_amounts[0] != 0:\r\n        coin: address = IBBTC_TOKEN\r\n\r\n        ERC20(coin).transferFrom(msg.sender, self, _deposit_amounts[0])\r\n        \r\n        before_balance_wibbtc: uint256 = WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceOf(self)\r\n        WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).mint(_deposit_amounts[0])\r\n        after_balance_wibbtc: uint256 = WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceOf(self)\r\n        \r\n        meta_amounts[0] = after_balance_wibbtc - before_balance_wibbtc\r\n\r\n        # approve wibbtc for _pool to use\r\n        if not self.is_approved[WIBBTC_TOKEN][_pool]:\r\n            ERC20(WIBBTC_TOKEN).approve(_pool, MAX_UINT256)\r\n            self.is_approved[WIBBTC_TOKEN][_pool] = True\r\n\r\n    # for all coins(other than ibbtc)\r\n    for i in range(1, N_ALL_COINS):\r\n        amount: uint256 = _deposit_amounts[i]\r\n        if amount == 0:\r\n            continue\r\n        deposit_base = True\r\n        base_idx: uint256 = i - 1\r\n        coin: address = base_coins[base_idx]\r\n\r\n        ERC20(coin).transferFrom(msg.sender, self, amount)\r\n        # Handle potential Tether fees\r\n        if i == N_ALL_COINS - 1:\r\n            base_amounts[base_idx] = ERC20(coin).balanceOf(self)\r\n        else:\r\n            base_amounts[base_idx] = amount\r\n\r\n    # Deposit to the base pool\r\n    if deposit_base:\r\n        coin: address = BASE_LP_TOKEN\r\n        CurveBase(BASE_POOL).add_liquidity(base_amounts, 0)\r\n        meta_amounts[MAX_COIN] = ERC20(coin).balanceOf(self)\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[coin][_pool] = True\r\n\r\n    # Deposit to the meta pool\r\n    return CurveMeta(_pool).add_liquidity(meta_amounts, _min_mint_amount, _receiver)\r\n\r\n\r\n@external\r\ndef remove_liquidity(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    _min_amounts: uint256[N_ALL_COINS],\r\n    _receiver: address = msg.sender\r\n) -> uint256[N_ALL_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _pool Address of the pool to deposit into\r\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _receiver Address that receives the LP tokens\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    ERC20(_pool).transferFrom(msg.sender, self, _burn_amount)\r\n\r\n    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\r\n\r\n    # Withdraw from meta\r\n    meta_received: uint256[N_COINS] = CurveMeta(_pool).remove_liquidity(\r\n        _burn_amount,\r\n        [_min_amounts[0], convert(0, uint256)]\r\n    )\r\n\r\n    # convert wibbtc to ibbtc\r\n    coin: address = CurveMeta(_pool).coins(0)\r\n    \r\n    before_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n    WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).burn(WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceToShares(meta_received[0]))\r\n    after_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n    \r\n    amounts[0] = after_ibbtc_balance - before_ibbtc_balance\r\n    ERC20(IBBTC_TOKEN).transfer(_receiver, amounts[0])\r\n    \r\n    # Withdraw from base\r\n    for i in range(BASE_N_COINS):\r\n        min_amounts_base[i] = _min_amounts[MAX_COIN+i]\r\n    CurveBase(BASE_POOL).remove_liquidity(meta_received[1], min_amounts_base)\r\n\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n    for i in range(1, N_ALL_COINS):\r\n        coin = base_coins[i-1]\r\n        amounts[i] = ERC20(coin).balanceOf(self)\r\n        ERC20(coin).transfer(_receiver, amounts[i])\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    i: int128,\r\n    _min_amount: uint256,\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap a single coin from the pool\r\n    @param _pool Address of the pool to deposit into\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of underlying coin to receive\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    ERC20(_pool).transferFrom(msg.sender, self, _burn_amount)\r\n    coin_amount: uint256 = 0\r\n\r\n    if i == 0:\r\n        coin_amount = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, i, _min_amount, self)\r\n        \r\n        before_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n        WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).burn(WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceToShares(coin_amount))\r\n        after_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n        \r\n        coin_amount = after_ibbtc_balance - before_ibbtc_balance\r\n        ERC20(IBBTC_TOKEN).transfer(_receiver, coin_amount)\r\n    else:\r\n        base_coins: address[BASE_N_COINS] = BASE_COINS\r\n        coin: address = base_coins[i - MAX_COIN]\r\n        # Withdraw a base pool coin\r\n        coin_amount = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, MAX_COIN, 0, self)\r\n        CurveBase(BASE_POOL).remove_liquidity_one_coin(coin_amount, i-MAX_COIN, _min_amount)\r\n        coin_amount = ERC20(coin).balanceOf(self)\r\n        ERC20(coin).transfer(_receiver, coin_amount)\r\n\r\n    return coin_amount\r\n\r\n@external\r\ndef remove_liquidity_imbalance(\r\n    _pool: address,\r\n    _amounts: uint256[N_ALL_COINS],\r\n    _max_burn_amount: uint256,\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n    fee: uint256 = CurveBase(BASE_POOL).fee() * BASE_N_COINS / (4 * (BASE_N_COINS - 1))\r\n    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\r\n\r\n    # Transfer the LP token in\r\n    ERC20(_pool).transferFrom(msg.sender, self, _max_burn_amount)\r\n\r\n    withdraw_base: bool = False\r\n    amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    # determine amounts to withdraw from base pool\r\n    for i in range(BASE_N_COINS):\r\n        amount: uint256 = _amounts[MAX_COIN + i]\r\n        if amount != 0:\r\n            amounts_base[i] = amount\r\n            withdraw_base = True\r\n\r\n    # determine amounts to withdraw from metapool\r\n    amounts_meta[0] = _amounts[0]\r\n    if withdraw_base:\r\n        amounts_meta[MAX_COIN] = CurveBase(BASE_POOL).calc_token_amount(amounts_base, False)\r\n        amounts_meta[MAX_COIN] += amounts_meta[MAX_COIN] * fee / FEE_DENOMINATOR + 1\r\n\r\n    # withdraw from metapool and return the remaining LP tokens\r\n    burn_amount: uint256 = CurveMeta(_pool).remove_liquidity_imbalance(amounts_meta, _max_burn_amount)\r\n    ERC20(_pool).transfer(msg.sender, _max_burn_amount - burn_amount)\r\n\r\n    # withdraw from base pool\r\n    if withdraw_base:\r\n        CurveBase(BASE_POOL).remove_liquidity_imbalance(amounts_base, amounts_meta[MAX_COIN])\r\n        coin: address = BASE_LP_TOKEN\r\n        leftover: uint256 = ERC20(coin).balanceOf(self)\r\n\r\n        if leftover > 0:\r\n            # if some base pool LP tokens remain, re-deposit them for the caller\r\n            if not self.is_approved[coin][_pool]:\r\n                ERC20(coin).approve(_pool, MAX_UINT256)\r\n                self.is_approved[coin][_pool] = True\r\n            burn_amount -= CurveMeta(_pool).add_liquidity([convert(0, uint256), leftover], 0, msg.sender)\r\n\r\n        # transfer withdrawn base pool tokens to caller\r\n        base_coins: address[BASE_N_COINS] = BASE_COINS\r\n        for i in range(BASE_N_COINS):\r\n            ERC20(base_coins[i]).transfer(_receiver, amounts_base[i])\r\n\r\n    # transfer withdrawn metapool tokens to caller\r\n    if _amounts[0] > 0:\r\n        coin: address = CurveMeta(_pool).coins(0)\r\n        \r\n        before_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n        WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).burn(WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceToShares(_amounts[0]))\r\n        after_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n        \r\n        ERC20(coin).transfer(_receiver, after_ibbtc_balance - before_ibbtc_balance)\r\n\r\n    return burn_amount\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_pool: address, _token_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing and unwrapping a single coin\r\n    @param _pool Address of the pool to deposit into\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the underlying coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    if i < MAX_COIN:\r\n        # we get balance we convert it into ibbtc shares we will receive.\r\n        return WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceToShares(CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, i))\r\n    else:\r\n        _base_tokens: uint256 = CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\r\n        return CurveBase(BASE_POOL).calc_withdraw_one_coin(_base_tokens, i-MAX_COIN)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(_pool: address, _amounts: uint256[N_ALL_COINS], _is_deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @dev This calculation accounts for slippage, but not fees.\r\n         Needed to prevent front-running, not for precise calculations!\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts Amount of each underlying coin being deposited\r\n    @param _is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n\r\n    meta_amounts[0] = WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).sharesToBalance(_amounts[0])\r\n    for i in range(BASE_N_COINS):\r\n        base_amounts[i] = _amounts[i + MAX_COIN]\r\n\r\n    base_tokens: uint256 = CurveBase(BASE_POOL).calc_token_amount(base_amounts, _is_deposit)\r\n    meta_amounts[MAX_COIN] = base_tokens\r\n\r\n    return CurveMeta(_pool).calc_token_amount(meta_amounts, _is_deposit)\r\n\r\n@external\r\ndef exchange_underlying(_pool: address, i: int128, j: int128, _dx: uint256, _min_dy: uint256, _receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice swaps and wrap/unwrap coin\r\n    \"\"\"\r\n    input_amount: uint256 = _dx\r\n\r\n    if i==0:\r\n        ERC20(IBBTC_TOKEN).transferFrom(msg.sender, self, _dx)\r\n \r\n        before_balance_wibbtc: uint256 = WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceOf(self)\r\n        WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).mint(_dx)\r\n        after_balance_wibbtc: uint256 = WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceOf(self)\r\n\r\n        input_amount = after_balance_wibbtc - before_balance_wibbtc\r\n    else:   \r\n        base_coins: address[BASE_N_COINS] = BASE_COINS\r\n        coin: address = base_coins[i - MAX_COIN]\r\n        ERC20(coin).transferFrom(msg.sender, self, _dx)\r\n\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[coin][_pool] = True\r\n\r\n    output_amount: uint256 = CurveMeta(_pool).exchange_underlying(i, j, input_amount, _min_dy, self)\r\n\r\n    if j==0:\r\n        \r\n        before_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n        WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).burn(WrappedIbbtcEth(IBBTC_WRAPPER_PROXY).balanceToShares(output_amount))\r\n        after_ibbtc_balance: uint256 = ERC20(IBBTC_TOKEN).balanceOf(self)\r\n\r\n        output_amount = after_ibbtc_balance - before_ibbtc_balance\r\n\r\n        ERC20(IBBTC_TOKEN).transfer(_receiver, output_amount)\r\n    else:\r\n        base_coins: address[BASE_N_COINS] = BASE_COINS\r\n        coin: address = base_coins[j - MAX_COIN]\r\n        ERC20(coin).transfer(_receiver, output_amount)\r\n\r\n    return output_amount","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5765},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":9047},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.16","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}