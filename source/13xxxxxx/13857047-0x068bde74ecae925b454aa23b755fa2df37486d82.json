{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/mainnet/resolvers/ubiquity/helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract Helpers {\\n    address internal constant dsaConnectorAddress = 0x8EC066D75d665616A94F2EccDBE49b54eAeefc78;\\n\\n    IUbiquityAlgorithmicDollarManager internal constant ubiquityManager =\\n        IUbiquityAlgorithmicDollarManager(0x4DA97a8b831C345dBe6d16FF7432DF2b7b776d98);\\n\\n    struct UbiquityAddresses {\\n        address ubiquityManagerAddress;\\n        address masterChefAddress;\\n        address twapOracleAddress;\\n        address uadAddress;\\n        address uarAddress;\\n        address udebtAddress;\\n        address ubqAddress;\\n        address cr3Address;\\n        address uadcrv3Address;\\n        address bondingShareAddress;\\n        address dsaResolverAddress;\\n        address dsaConnectorAddress;\\n    }\\n\\n    struct UbiquityDatas {\\n        uint256 twapPrice;\\n        uint256 uadTotalSupply;\\n        uint256 uarTotalSupply;\\n        uint256 udebtTotalSupply;\\n        uint256 ubqTotalSupply;\\n        uint256 uadcrv3TotalSupply;\\n        uint256 bondingSharesTotalSupply;\\n        uint256 lpTotalSupply;\\n    }\\n\\n    struct UbiquityInventory {\\n        uint256 uadBalance;\\n        uint256 uarBalance;\\n        uint256 udebtBalance;\\n        uint256 ubqBalance;\\n        uint256 crv3Balance;\\n        uint256 uad3crvBalance;\\n        uint256 ubqRewards;\\n        uint256 bondingSharesBalance;\\n        uint256 lpBalance;\\n        uint256 bondBalance;\\n        uint256 ubqPendingBalance;\\n    }\\n\\n    function getMasterChef() internal view returns (IMasterChefV2) {\\n        return IMasterChefV2(ubiquityManager.masterChefAddress());\\n    }\\n\\n    function getTWAPOracle() internal view returns (ITWAPOracle) {\\n        return ITWAPOracle(ubiquityManager.twapOracleAddress());\\n    }\\n\\n    function getUAD() internal view returns (IERC20) {\\n        return IERC20(ubiquityManager.dollarTokenAddress());\\n    }\\n\\n    function getUAR() internal view returns (IERC20) {\\n        return IERC20(ubiquityManager.autoRedeemTokenAddress());\\n    }\\n\\n    function getUBQ() internal view returns (IERC20) {\\n        return IERC20(ubiquityManager.governanceTokenAddress());\\n    }\\n\\n    function getCRV3() internal view returns (IERC20) {\\n        return IERC20(ubiquityManager.curve3PoolTokenAddress());\\n    }\\n\\n    function getUADCRV3() internal view returns (IERC20) {\\n        return IERC20(ubiquityManager.stableSwapMetaPoolAddress());\\n    }\\n\\n    function getUDEBT() internal view returns (IERC1155) {\\n        return IERC1155(ubiquityManager.debtCouponAddress());\\n    }\\n\\n    function getBondingShare() internal view returns (IBondingShareV2) {\\n        return IBondingShareV2(ubiquityManager.bondingShareAddress());\\n    }\\n\\n    function getBondingShareIds(address user) internal view returns (uint256[] memory bondIds) {\\n        return getBondingShare().holderTokens(user);\\n    }\\n\\n    function getBondingShareBalanceOf(address user) internal view returns (uint256 balance) {\\n        uint256[] memory bondIds = getBondingShareIds(user);\\n        for (uint256 i = 0; i < bondIds.length; i += 1) {\\n            balance += getBondingShare().getBond(bondIds[i]).lpAmount;\\n        }\\n    }\\n\\n    function getPendingUBQ(address user) internal view returns (uint256 amount) {\\n        uint256[] memory bondIds = getBondingShareIds(user);\\n        for (uint256 i = 0; i < bondIds.length; i += 1) {\\n            amount += getMasterChef().pendingUGOV(bondIds[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/resolvers/ubiquity/interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IERC1155.sol\\\";\\n\\ninterface ITWAPOracle {\\n    function update() external;\\n\\n    function token0() external view returns (address);\\n\\n    function consult(address token) external view returns (uint256 amountOut);\\n}\\n\\ninterface IUbiquityAlgorithmicDollarManager {\\n    function twapOracleAddress() external view returns (address);\\n\\n    function dollarTokenAddress() external view returns (address);\\n\\n    function autoRedeemTokenAddress() external view returns (address);\\n\\n    function governanceTokenAddress() external view returns (address);\\n\\n    function curve3PoolTokenAddress() external view returns (address);\\n\\n    function stableSwapMetaPoolAddress() external view returns (address);\\n\\n    function debtCouponAddress() external view returns (address);\\n\\n    function bondingShareAddress() external view returns (address);\\n\\n    function masterChefAddress() external view returns (address);\\n}\\n\\ninterface IBondingShareV2 {\\n    struct Bond {\\n        address minter;\\n        uint256 lpFirstDeposited;\\n        uint256 creationBlock;\\n        uint256 lpRewardDebt;\\n        uint256 endBlock;\\n        uint256 lpAmount;\\n    }\\n\\n    function holderTokens(address) external view returns (uint256[] memory);\\n\\n    function totalLP() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getBond(uint256 id) external view returns (Bond memory);\\n}\\n\\ninterface IMasterChefV2 {\\n    function lastPrice() external view returns (uint256);\\n\\n    function pendingUGOV(uint256) external view returns (uint256);\\n\\n    function minPriceDiffToUpdateMultiplier() external view returns (uint256);\\n\\n    function pool() external view returns (uint256 lastRewardBlock, uint256 accuGOVPerShare);\\n\\n    function totalShares() external view returns (uint256);\\n\\n    function uGOVDivider() external view returns (uint256);\\n\\n    function uGOVPerBlock() external view returns (uint256);\\n\\n    function uGOVmultiplier() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/resolvers/ubiquity/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/resolvers/ubiquity/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/resolvers/ubiquity/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/resolvers/ubiquity/main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces.sol\\\";\\nimport \\\"./helpers.sol\\\";\\n\\ncontract Resolver is Helpers {\\n    function getUbiquityAddresses() public view returns (UbiquityAddresses memory addresses) {\\n        addresses.ubiquityManagerAddress = address(ubiquityManager);\\n        addresses.masterChefAddress = address(getMasterChef());\\n        addresses.twapOracleAddress = address(getTWAPOracle());\\n        addresses.uadAddress = address(getUAD());\\n        addresses.uarAddress = address(getUAR());\\n        addresses.udebtAddress = address(getUDEBT());\\n        addresses.ubqAddress = address(getUBQ());\\n        addresses.cr3Address = address(getCRV3());\\n        addresses.uadcrv3Address = address(getUADCRV3());\\n        addresses.bondingShareAddress = address(getBondingShare());\\n        addresses.dsaResolverAddress = address(this);\\n        addresses.dsaConnectorAddress = address(dsaConnectorAddress);\\n    }\\n\\n    function getUbiquityDatas() public view returns (UbiquityDatas memory datas) {\\n        datas.twapPrice = getTWAPOracle().consult(getTWAPOracle().token0());\\n        datas.uadTotalSupply = getUAD().totalSupply();\\n        datas.uarTotalSupply = getUAR().totalSupply();\\n        datas.ubqTotalSupply = getUBQ().totalSupply();\\n        datas.uadcrv3TotalSupply = getUADCRV3().totalSupply();\\n        datas.bondingSharesTotalSupply = getBondingShare().totalSupply();\\n        datas.lpTotalSupply = getBondingShare().totalLP();\\n    }\\n\\n    function getUbiquityInventory(address user) public view returns (UbiquityInventory memory inventory) {\\n        inventory.uadBalance = getUAD().balanceOf(user);\\n        inventory.uarBalance = getUAR().balanceOf(user);\\n        inventory.ubqBalance = getUBQ().balanceOf(user);\\n        inventory.crv3Balance = getCRV3().balanceOf(user);\\n        inventory.uad3crvBalance = getUADCRV3().balanceOf(user);\\n        inventory.bondingSharesBalance = getBondingShareBalanceOf(user);\\n        inventory.lpBalance = getBondingShareBalanceOf(user);\\n        inventory.bondBalance = getBondingShareIds(user).length;\\n        inventory.ubqPendingBalance = getPendingUBQ(user);\\n    }\\n}\\n\\ncontract InstaUbiquityResolver is Resolver {\\n    string public constant name = \\\"Ubiquity-Resolver-v0.1\\\";\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"getUbiquityAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ubiquityManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"masterChefAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"twapOracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uadAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uarAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"udebtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ubqAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cr3Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uadcrv3Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bondingShareAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dsaResolverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dsaConnectorAddress\",\"type\":\"address\"}],\"internalType\":\"struct Helpers.UbiquityAddresses\",\"name\":\"addresses\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUbiquityDatas\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"twapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uadTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uarTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"udebtTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ubqTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uadcrv3TotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondingSharesTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.UbiquityDatas\",\"name\":\"datas\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUbiquityInventory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"uadBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uarBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"udebtBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ubqBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crv3Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uad3crvBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ubqRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondingSharesBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bondBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ubqPendingBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.UbiquityInventory\",\"name\":\"inventory\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InstaUbiquityResolver","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}