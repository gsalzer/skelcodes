{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/CrowdfundWithPodiumEditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {ERC721} from \\\"../../../external/ERC721.sol\\\";\\nimport {ICrowdfundWithPodiumEditions} from \\\"./interface/ICrowdfundWithPodiumEditions.sol\\\";\\n\\n/**\\n * @title CrowdfundWithPodiumEditions\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundWithPodiumEditions is ERC721, ICrowdfundWithPodiumEditions {\\n    // ============ Constants ============\\n\\n    string public constant name = \\\"Crowdfunded Mirror Editions\\\";\\n    string public constant symbol = \\\"CROWDFUND_EDITIONS\\\";\\n\\n    bytes32 public constant PRODUCER_TYPE = \\\"0x123123\\\";\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    // ============ Setup Storage ============\\n\\n    // The CrowdfundFactory that is able to create editions.\\n    address public editionCreator;\\n\\n    // ============ Mutable Storage ============\\n\\n    // Mapping of edition id to descriptive data.\\n    mapping(uint256 => Edition) public editions;\\n    // Mapping of token id to edition id.\\n    mapping(uint256 => uint256) public tokenToEdition;\\n    // The contract that is able to mint.\\n    mapping(uint256 => address) public editionToMinter;\\n    // `nextTokenId` increments with each token purchased, globally across all editions.\\n    uint256 private nextTokenId;\\n    // Editions start at 1, in order that unsold tokens don't map to the first edition.\\n    uint256 private nextEditionId = 1;\\n    // Reentrancy\\n    uint256 internal reentrancyStatus;\\n    // Administration\\n    address public owner;\\n    address public nextOwner;\\n    // Base URI can be modified by multisig owner, for intended future\\n    // migration of API domain to a decentralized one.\\n    string public baseURI;\\n\\n    // ============ Events ============\\n\\n    event EditionCreated(\\n        uint256 quantity,\\n        uint256 price,\\n        address fundingRecipient,\\n        uint256 indexed editionId\\n    );\\n\\n    event EditionPurchased(\\n        uint256 indexed editionId,\\n        uint256 indexed tokenId,\\n        // `numSold` at time of purchase represents the \\\"serial number\\\" of the NFT.\\n        uint256 numSold,\\n        uint256 amountPaid,\\n        // The account that paid for and received the NFT.\\n        address buyer,\\n        address receiver\\n    );\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    event EditionCreatorChanged(\\n        address indexed previousCreator,\\n        address indexed newCreator\\n    );\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyMinter(uint256 editionId) {\\n        // Only the minter can call this function.\\n        // This allows us to mint through another contract, and\\n        // there not have to transfer funds into this contract to purchase.\\n        require(\\n            msg.sender == editionToMinter[editionId],\\n            \\\"sender not allowed minter\\\"\\n        );\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(string memory baseURI_, address owner_) {\\n        baseURI = baseURI_;\\n        owner = owner_;\\n    }\\n\\n    // ============ Setup ============\\n\\n    function setEditionCreator(address editionCreator_) external {\\n        require(editionCreator == address(0), \\\"already set\\\");\\n        editionCreator = editionCreator_;\\n        emit EditionCreatorChanged(address(0), editionCreator_);\\n    }\\n\\n    // ============ Edition Methods ============\\n\\n    function createEditions(\\n        EditionTier[] memory tiers,\\n        // The account that should receive the revenue.\\n        address payable fundingRecipient,\\n        // The address (e.g. crowdfund proxy) that is allowed to mint\\n        // tokens in this edition.\\n        address minter\\n    ) external override {\\n        // Only the crowdfund factory can create editions.\\n        require(msg.sender == editionCreator);\\n        // Copy the next edition id, which we reference in the loop.\\n        uint256 firstEditionId = nextEditionId;\\n        // Update the next edition id to what we expect after the loop.\\n        nextEditionId += tiers.length;\\n        // Execute a loop that created editions.\\n        for (uint8 x = 0; x < tiers.length; x++) {\\n            uint256 id = firstEditionId + x;\\n            uint256 quantity = tiers[x].quantity;\\n            uint256 price = tiers[x].price;\\n            bytes32 contentHash = tiers[x].contentHash;\\n\\n            editions[id] = Edition({\\n                quantity: quantity,\\n                price: price,\\n                fundingRecipient: fundingRecipient,\\n                numSold: 0,\\n                contentHash: contentHash\\n            });\\n\\n            editionToMinter[id] = minter;\\n\\n            emit EditionCreated(quantity, price, fundingRecipient, id);\\n        }\\n    }\\n\\n    function buyEdition(uint256 editionId, address recipient)\\n        external\\n        payable\\n        override\\n        onlyMinter(editionId)\\n        returns (uint256 tokenId)\\n    {\\n        return _buyEdition(editionId, recipient);\\n    }\\n\\n    function _buyEdition(uint256 editionId, address recipient)\\n        internal\\n        returns (uint256 tokenId)\\n    {\\n        // Track and update token id.\\n        tokenId = nextTokenId;\\n        nextTokenId++;\\n        // Check that the edition exists. Note: this is redundant\\n        // with the next check, but it is useful for clearer error messaging.\\n        require(editions[editionId].quantity > 0, \\\"Edition does not exist\\\");\\n        // Check that there are still tokens available to purchase.\\n        require(\\n            editions[editionId].numSold < editions[editionId].quantity,\\n            \\\"This edition is already sold out.\\\"\\n        );\\n        // Increment the number of tokens sold for this edition.\\n        editions[editionId].numSold++;\\n        // Mint a new token for the sender, using the `tokenId`.\\n        _mint(recipient, tokenId);\\n        // Store the mapping of token id to the edition being purchased.\\n        tokenToEdition[tokenId] = editionId;\\n\\n        emit EditionPurchased(\\n            editionId,\\n            tokenId,\\n            editions[editionId].numSold,\\n            msg.value,\\n            msg.sender,\\n            recipient\\n        );\\n\\n        return tokenId;\\n    }\\n\\n    // ============ NFT Methods ============\\n\\n    // Returns e.g. https://mirror-api.com/editions/[editionId]/[tokenId]\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        // If the token does not map to an edition, it'll be 0.\\n        require(tokenToEdition[tokenId] > 0, \\\"Token has not been sold yet\\\");\\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\\n        return\\n            string(\\n                abi.encodePacked(\\n                    baseURI,\\n                    _toString(tokenToEdition[tokenId]),\\n                    \\\"/\\\",\\n                    _toString(tokenId)\\n                )\\n            );\\n    }\\n\\n    // Returns e.g. https://mirror-api.com/editions/metadata\\n    function contractURI() public view override returns (string memory) {\\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\\n        return string(abi.encodePacked(baseURI, \\\"metadata\\\"));\\n    }\\n\\n    // Given an edition's ID, returns its price.\\n    function editionPrice(uint256 editionId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return editions[editionId].price;\\n    }\\n\\n    // The hash of the given content for the NFT. Can be used\\n    // for IPFS storage, verifying authenticity, etc.\\n    function getContentHash(uint256 tokenId) public view returns (bytes32) {\\n        // If the token does not map to an edition, it'll be 0.\\n        require(tokenToEdition[tokenId] > 0, \\\"Token has not been sold yet\\\");\\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\\n        return editions[tokenToEdition[tokenId]].contentHash;\\n    }\\n\\n    function getRoyaltyRecipient(uint256 tokenId)\\n        public\\n        view\\n        returns (address)\\n    {\\n        require(tokenToEdition[tokenId] > 0, \\\"Token has not been minted yet\\\");\\n        return editions[tokenToEdition[tokenId]].fundingRecipient;\\n    }\\n\\n    function setRoyaltyRecipient(\\n        uint256 editionId,\\n        address payable newFundingRecipient\\n    ) public {\\n        require(\\n            editions[editionId].fundingRecipient == msg.sender,\\n            \\\"Only current fundingRecipient can modify its value\\\"\\n        );\\n\\n        editions[editionId].fundingRecipient = newFundingRecipient;\\n    }\\n\\n    // ============ Admin Methods ============\\n\\n    function changeBaseURI(string memory baseURI_) public onlyOwner {\\n        baseURI = baseURI_;\\n    }\\n\\n    // Allows the creator contract to be swapped out for an upgraded one.\\n    // NOTE: This does not affect existing editions already minted.\\n    function changeEditionCreator(address editionCreator_) public onlyOwner {\\n        emit EditionCreatorChanged(editionCreator, editionCreator_);\\n        editionCreator = editionCreator_;\\n    }\\n\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n\\n        owner = msg.sender;\\n    }\\n\\n    function renounceOwnership() external onlyOwner {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    // ============ Private Methods ============\\n\\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n    function _toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IERC721, IERC721Metadata, IERC721Receiver, IERC165} from \\\"./interface/IERC721.sol\\\";\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\n/**\\n * Based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\\n */\\ncontract ERC721 is ERC165, IERC721 {\\n    mapping(uint256 => address) private _owners;\\n    mapping(address => uint256) private _balances;\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function balanceOf(address owner)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: balance query for the zero address\\\"\\n        );\\n        return _balances[owner];\\n    }\\n\\n    function ownerOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        address owner = _owners[tokenId];\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: owner query for nonexistent token\\\"\\n        );\\n        return owner;\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        returns (string memory)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721Metadata: URI query for nonexistent token\\\"\\n        );\\n\\n        string memory baseURI = _baseURI();\\n        return\\n            bytes(baseURI).length > 0\\n                ? string(abi.encodePacked(baseURI, tokenId))\\n                : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721: approved query for nonexistent token\\\"\\n        );\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721: operator query for nonexistent token\\\"\\n        );\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(\\n            ERC721.ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer of token that is not own\\\"\\n        );\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (isContract(to)) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n                    );\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/interface/ICrowdfundWithPodiumEditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ICrowdfundWithPodiumEditions {\\n    struct Edition {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        // The account that will receive sales revenue.\\n        address payable fundingRecipient;\\n        // The number of tokens sold so far.\\n        uint256 numSold;\\n        bytes32 contentHash;\\n    }\\n\\n    struct EditionTier {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        bytes32 contentHash;\\n    }\\n\\n    function buyEdition(uint256 editionId, address recipient)\\n        external\\n        payable\\n        returns (uint256 tokenId);\\n\\n    function editionPrice(uint256 editionId) external view returns (uint256);\\n\\n    function createEditions(\\n        EditionTier[] memory tier,\\n        // The account that should receive the revenue.\\n        address payable fundingRecipient,\\n        address minter\\n    ) external;\\n\\n    function contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC721 {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"}],\"name\":\"EditionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousCreator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"EditionCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"EditionPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRODUCER_TYPE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buyEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"changeBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"editionCreator_\",\"type\":\"address\"}],\"name\":\"changeEditionCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct ICrowdfundWithPodiumEditions.EditionTier[]\",\"name\":\"tiers\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"createEditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editionCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"}],\"name\":\"editionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editionToMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numSold\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getContentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"editionCreator_\",\"type\":\"address\"}],\"name\":\"setEditionCreator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"newFundingRecipient\",\"type\":\"address\"}],\"name\":\"setRoyaltyRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CrowdfundWithPodiumEditions","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b57000000000000000000000000000000000000000000000000000000000000002f68747470733a2f2f6d6972726f722d6170692e636f6d2f65646974696f6e732f63726f776466756e6465642f76332f0000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}