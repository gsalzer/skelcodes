{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/URSStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface Factory {\\n    function mint(address) external;\\n}\\n\\ninterface Pass {\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\\ncontract URSStore is Ownable {\\n    Pass public constant pass =\\n        Pass(0xe0e19Aa07cb819664001adFFeA6a176A75897899);\\n    Factory public constant ursFactory =\\n        Factory(0x08f0B2A4351514E63E9E03A661aDFe58D463CfBc);\\n\\n    /**\\n        Numbers for URS Factory\\n     */\\n    uint256 public constant maxURS = 10000;\\n\\n    /**\\n        Team withdraw fund\\n     */\\n    // claimed\\n    bool internal claimed = false;\\n\\n    /**\\n        Team allocated URS\\n     */\\n    // URS which is minted by the owner\\n    uint256 public preMintedURS = 0;\\n    // MAX URS which owner can mint\\n    uint256 public constant maxPreMintURS = 50;\\n\\n    /**\\n        Mint Pass\\n     */\\n    uint256 public newlyMintedURSWithPass = 0;\\n    uint256 public constant maxURSPerPass = 5;\\n    mapping(address => uint256) public mintedURSOf;\\n\\n    /**\\n        Scheduling\\n     */\\n    uint256 public openingHours = 1631318400; // Sat Sep 11 2021 00:00:00 GMT+0000\\n    uint256 public constant operationSecondsForVIP = 3600 * 9; // 9 hours\\n    uint256 public constant operationSeconds = 3600 * 24; // 24 hours\\n\\n    /**\\n        Ticket\\n     */\\n    uint256 public constant ticketPrice = 0.08 ether;\\n    uint256 public totalTickets = 0;\\n    mapping(address => ticket) public ticketsOf;\\n    struct ticket {\\n        uint256 index; // Incl\\n        uint256 amount;\\n    }\\n\\n    /**\\n        Security\\n     */\\n    uint256 public constant maxMintPerTx = 30;\\n\\n    /**\\n        Raffle\\n     */\\n    uint256 public raffleNumber;\\n    uint256 public offsetInSlot;\\n    uint256 public slotSize;\\n    uint256 public lastTargetIndex; // index greater than this is dis-regarded\\n    mapping(address => result) public resultOf;\\n    struct result {\\n        bool executed;\\n        uint256 validTicketAmount;\\n    }\\n\\n    // event SetPass(address pass);\\n    // event SetURSFactory(address ursFactory);\\n    event SetOpeningHours(uint256 openingHours);\\n    event MintWithPass(address account, uint256 amount, uint256 changes);\\n    event TakingTickets(address account, uint256 amount, uint256 changes);\\n    event RunRaffle(uint256 raffleNumber);\\n    event SetResult(\\n        address account,\\n        uint256 validTicketAmount,\\n        uint256 changes\\n    );\\n    event MintURS(address account, uint256 mintRequestAmount);\\n    event Withdraw(address to);\\n\\n    constructor() {}\\n\\n    modifier whenOpened() {\\n        require(\\n            block.timestamp >= openingHours + operationSecondsForVIP,\\n            \\\"Store is not opened\\\"\\n        );\\n        require(\\n            block.timestamp <\\n                openingHours + operationSecondsForVIP + operationSeconds,\\n            \\\"Store is closed\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier whenVIPOpened() {\\n        require(block.timestamp >= openingHours, \\\"Store is not opened for VIP\\\");\\n        require(\\n            block.timestamp < openingHours + operationSecondsForVIP,\\n            \\\"Store is closed for VIP\\\"\\n        );\\n        _;\\n    }\\n\\n    // function setPass(Pass _pass) external onlyOwner {\\n    //     pass = _pass;\\n    //     emit SetPass(address(_pass));\\n    // }\\n\\n    // function setURSFactory(Factory _ursFactory) external onlyOwner {\\n    //     ursFactory = _ursFactory;\\n    //     emit SetURSFactory(address(_ursFactory));\\n    // }\\n\\n    function setOpeningHours(uint256 _openingHours) external onlyOwner {\\n        openingHours = _openingHours;\\n        emit SetOpeningHours(_openingHours);\\n    }\\n\\n    // Do not update newlyMintedURS to prevent withdrawal\\n    function preMintURS(address[] memory recipients) external onlyOwner {\\n        require(\\n            block.timestamp <\\n                openingHours + operationSecondsForVIP + operationSeconds,\\n            \\\"Not available after ticketing period\\\"\\n        );\\n        uint256 totalRecipients = recipients.length;\\n\\n        require(\\n            totalRecipients > 0,\\n            \\\"Number of recipients must be greater than 0\\\"\\n        );\\n        require(\\n            preMintedURS + totalRecipients <= maxPreMintURS,\\n            \\\"Exceeds max pre-mint URS\\\"\\n        );\\n\\n        for (uint256 i = 0; i < totalRecipients; i++) {\\n            address to = recipients[i];\\n            require(to != address(0), \\\"receiver can not be empty address\\\");\\n            ursFactory.mint(to);\\n        }\\n\\n        preMintedURS += totalRecipients;\\n    }\\n\\n    function mintWithPass(uint256 _amount) external payable whenVIPOpened {\\n        require(_amount <= maxMintPerTx, \\\"mint amount exceeds maximum\\\");\\n        require(_amount > 0, \\\"Need to mint more than 0\\\");\\n\\n        uint256 mintedURS = mintedURSOf[msg.sender];\\n        uint256 passAmount = pass.balanceOf(msg.sender);\\n        require(\\n            passAmount * maxURSPerPass - mintedURS >= _amount,\\n            \\\"Not enough Pass\\\"\\n        );\\n\\n        uint256 totalPrice = ticketPrice * _amount;\\n        require(totalPrice <= msg.value, \\\"Not enough money\\\");\\n\\n        for (uint256 i = 0; i < _amount; i += 1) {\\n            ursFactory.mint(msg.sender);\\n        }\\n\\n        mintedURSOf[msg.sender] = mintedURS + _amount;\\n        newlyMintedURSWithPass += _amount;\\n\\n        // Refund changes\\n        uint256 changes = msg.value - totalPrice;\\n        emit MintWithPass(msg.sender, _amount, changes);\\n\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n    }\\n\\n    function takingTickets(uint256 _amount) external payable whenOpened {\\n        require(_amount > 0, \\\"Need to take ticket more than 0\\\");\\n\\n        ticket storage myTicket = ticketsOf[msg.sender];\\n        require(myTicket.amount == 0, \\\"Already registered\\\");\\n\\n        uint256 totalPrice = ticketPrice * _amount;\\n        require(totalPrice <= msg.value, \\\"Not enough money\\\");\\n\\n        myTicket.index = totalTickets;\\n        myTicket.amount = _amount;\\n\\n        totalTickets = totalTickets + _amount;\\n\\n        // Refund changes\\n        uint256 changes = msg.value - totalPrice;\\n        emit TakingTickets(msg.sender, _amount, changes);\\n\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n    }\\n\\n    function runRaffle(uint256 _raffleNumber) external onlyOwner {\\n        require(raffleNumber == 0, \\\"raffle number is already set\\\");\\n\\n        raffleNumber = _raffleNumber;\\n        uint256 remainingURS = maxURS - preMintedURS - newlyMintedURSWithPass;\\n\\n        // Hopefully consider that totalTickets number is more than remainingURS\\n        // Actually this number can be controlled from team by taking tickets\\n        slotSize = totalTickets / remainingURS;\\n        offsetInSlot = _raffleNumber % slotSize;\\n        lastTargetIndex = slotSize * remainingURS - 1;\\n\\n        emit RunRaffle(_raffleNumber);\\n    }\\n\\n    function calculateValidTicketAmount(\\n        uint256 index,\\n        uint256 amount,\\n        uint256 _slotSize,\\n        uint256 _offsetInSlot,\\n        uint256 _lastTargetIndex\\n    ) internal pure returns (uint256 validTicketAmount) {\\n        /**\\n\\n        /_____fio___\\\\___________________________________/lio\\\\___________\\n                v   f |         v     |         v     |     l   v     |\\n        ______slot #n__|___slot #n+1___|____slot #n+2__|____slot #n+3__|\\n\\n            f : first index (incl.)\\n            l : last index (incl.)\\n            v : win ticket\\n            fio : first index offset\\n            lio : last index offset\\n            n, n+1,... : slot index\\n            \\n            v in (slot #n+1) is ths firstWinIndex\\n            v in (slot #n+2) is ths lastWinIndex\\n        */\\n        uint256 lastIndex = index + amount - 1; // incl.\\n        if (lastIndex > _lastTargetIndex) {\\n            lastIndex = _lastTargetIndex;\\n        }\\n\\n        uint256 firstIndexOffset = index % _slotSize;\\n        uint256 lastIndexOffset = lastIndex % _slotSize;\\n\\n        uint256 firstWinIndex;\\n        if (firstIndexOffset <= _offsetInSlot) {\\n            firstWinIndex = index + _offsetInSlot - firstIndexOffset;\\n        } else {\\n            firstWinIndex =\\n                index +\\n                _slotSize +\\n                _offsetInSlot -\\n                firstIndexOffset;\\n        }\\n\\n        // Nothing is selected\\n        if (firstWinIndex > _lastTargetIndex) {\\n            validTicketAmount = 0;\\n        } else {\\n            uint256 lastWinIndex;\\n            if (lastIndexOffset >= _offsetInSlot) {\\n                lastWinIndex = lastIndex + _offsetInSlot - lastIndexOffset;\\n            } else if (lastIndex < _slotSize) {\\n                lastWinIndex = 0;\\n            } else {\\n                lastWinIndex =\\n                    lastIndex +\\n                    _offsetInSlot -\\n                    lastIndexOffset -\\n                    _slotSize;\\n            }\\n\\n            if (firstWinIndex > lastWinIndex) {\\n                validTicketAmount = 0;\\n            } else {\\n                validTicketAmount =\\n                    (lastWinIndex - firstWinIndex) /\\n                    _slotSize +\\n                    1;\\n            }\\n        }\\n    }\\n\\n    function calculateMyResult() external {\\n        require(raffleNumber > 0, \\\"raffle number is not set yet\\\");\\n\\n        ticket storage myTicket = ticketsOf[msg.sender];\\n        require(myTicket.amount > 0, \\\"No available ticket\\\");\\n\\n        result storage myResult = resultOf[msg.sender];\\n        require(!myResult.executed, \\\"Already checked\\\");\\n\\n        uint256 validTicketAmount = calculateValidTicketAmount(\\n            myTicket.index,\\n            myTicket.amount,\\n            slotSize,\\n            offsetInSlot,\\n            lastTargetIndex\\n        );\\n\\n        myResult.validTicketAmount = validTicketAmount;\\n        myResult.executed = true;\\n\\n        uint256 remainingTickets = myTicket.amount - validTicketAmount;\\n        uint256 changes = remainingTickets * ticketPrice;\\n\\n        emit SetResult(msg.sender, validTicketAmount, changes);\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n    }\\n\\n    function mintURS() external {\\n        result storage myResult = resultOf[msg.sender];\\n\\n        require(myResult.executed, \\\"result is not calculated yet\\\");\\n        require(myResult.validTicketAmount > 0, \\\"No valid tickets\\\");\\n\\n        uint256 mintRequestAmount = 0;\\n\\n        if (myResult.validTicketAmount > maxMintPerTx) {\\n            mintRequestAmount = maxMintPerTx;\\n            myResult.validTicketAmount -= maxMintPerTx;\\n        } else {\\n            mintRequestAmount = myResult.validTicketAmount;\\n            myResult.validTicketAmount = 0;\\n        }\\n\\n        for (uint256 i = 0; i < mintRequestAmount; i += 1) {\\n            ursFactory.mint(msg.sender);\\n        }\\n\\n        emit MintURS(msg.sender, mintRequestAmount);\\n    }\\n\\n    // withdraw eth for sold URS\\n    function withdraw(address payable _to) external onlyOwner {\\n        require(_to != address(0), \\\"receiver can not be empty address\\\");\\n        require(!claimed, \\\"Already claimed\\\");\\n        require(\\n            maxURS - maxPreMintURS <= totalTickets + newlyMintedURSWithPass,\\n            \\\"Not enough ethers are collected\\\"\\n        );\\n\\n        uint256 withdrawalAmount = ticketPrice * (maxURS - maxPreMintURS);\\n\\n        // Send eth to designated receiver\\n        emit Withdraw(_to);\\n\\n        claimed = true;\\n        _to.transfer(withdrawalAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintRequestAmount\",\"type\":\"uint256\"}],\"name\":\"MintURS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changes\",\"type\":\"uint256\"}],\"name\":\"MintWithPass\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleNumber\",\"type\":\"uint256\"}],\"name\":\"RunRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingHours\",\"type\":\"uint256\"}],\"name\":\"SetOpeningHours\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validTicketAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changes\",\"type\":\"uint256\"}],\"name\":\"SetResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changes\",\"type\":\"uint256\"}],\"name\":\"TakingTickets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"calculateMyResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTargetIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPreMintURS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxURS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxURSPerPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintURS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintWithPass\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedURSOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newlyMintedURSWithPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetInSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openingHours\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationSecondsForVIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pass\",\"outputs\":[{\"internalType\":\"contract Pass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"preMintURS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preMintedURS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"resultOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validTicketAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raffleNumber\",\"type\":\"uint256\"}],\"name\":\"runRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openingHours\",\"type\":\"uint256\"}],\"name\":\"setOpeningHours\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"takingTickets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ursFactory\",\"outputs\":[{\"internalType\":\"contract Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"URSStore","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}