{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/InterestRateModel/StablecoinInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../library/SafeRatioMath.sol\\\";\\n\\n/**\\n * @title dForce's lending InterestRateModel Contract\\n * @author dForce\\n */\\ncontract StablecoinInterestRateModel {\\n    using SafeMathUpgradeable for uint256;\\n    using SafeRatioMath for uint256;\\n\\n    uint256 private constant BASE = 1e18;\\n\\n    /**\\n     * @notice The approximate number of Ethereum blocks produced each year\\n     */\\n    uint256 public constant blocksPerYear = 2425846;\\n\\n    /*********************************/\\n    /******** Security Check *********/\\n    /*********************************/\\n\\n    /**\\n     * @notice Ensure this is an interest rate model contract.\\n     */\\n    function isInterestRateModel() external pure returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Calculate the utilization rate: `_borrows / (_cash + _borrows - _reserves)`\\n     * @param _cash Asset balance\\n     * @param _borrows Asset borrows\\n     * @param _reserves Asset reserves\\n     * @return Asset utilization [0, 1e18]\\n     */\\n    function utilizationRate(\\n        uint256 _cash,\\n        uint256 _borrows,\\n        uint256 _reserves\\n    ) internal pure returns (uint256) {\\n        // Utilization rate is 0 when there are no borrows\\n        if (_borrows == 0) return 0;\\n\\n        // Utilization rate is 100% when _grossSupply is less than or equal to borrows\\n        uint256 _grossSupply = _cash.add(_borrows);\\n        if (_grossSupply <= _reserves) return BASE;\\n\\n        // Utilization rate is 100% when _borrows is greater than _supply\\n        uint256 _supply = _grossSupply.sub(_reserves);\\n        if (_borrows > _supply) return BASE;\\n\\n        return _borrows.mul(BASE).div(_supply);\\n    }\\n\\n    /**\\n     * @notice Get the current borrow rate per block, 18 decimal places\\n     * @param _balance Asset balance\\n     * @param _borrows Asset borrows\\n     * @param _reserves Asset reserves\\n     * @return _borrowRate Current borrow rate APR\\n     */\\n    function getBorrowRate(\\n        uint256 _balance,\\n        uint256 _borrows,\\n        uint256 _reserves\\n    ) external pure returns (uint256 _borrowRate) {\\n        uint256 _util = utilizationRate(_balance, _borrows, _reserves);\\n\\n        // Borrow rate is: (UR^2 + UR^4 + UR^7 + 2*UR^32) * 5%\\n        uint256 _temp = _util.rpow(2, BASE);\\n        _temp = _temp.add(_util.rpow(4, BASE));\\n        _temp = _temp.add(_util.rpow(7, BASE));\\n        _temp = _temp.add(_util.rpow(32, BASE).mul(2));\\n\\n        uint256 _annualBorrowRateScaled = _temp.mul(5).div(100);\\n\\n        // And then divide down by blocks per year.\\n        _borrowRate = _annualBorrowRateScaled.div(blocksPerYear);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/SafeRatioMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\\\";\\n\\nlibrary SafeRatioMath {\\n    using SafeMathUpgradeable for uint256;\\n\\n    uint256 private constant BASE = 10**18;\\n    uint256 private constant DOUBLE = 10**36;\\n\\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.add(y.sub(1)).div(y);\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.mul(y).div(BASE);\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.mul(BASE).div(y);\\n    }\\n\\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x.mul(BASE).add(y.sub(1)).div(y);\\n    }\\n\\n    function tmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 z\\n    ) internal pure returns (uint256 result) {\\n        result = x.mul(y).mul(z).div(DOUBLE);\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 base\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n                case 0 {\\n                    switch n\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := 0\\n                        }\\n                }\\n                default {\\n                    switch mod(n, 2)\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := x\\n                        }\\n                    let half := div(base, 2) // for rounding.\\n\\n                    for {\\n                        n := div(n, 2)\\n                    } n {\\n                        n := div(n, 2)\\n                    } {\\n                        let xx := mul(x, x)\\n                        if iszero(eq(div(xx, x), x)) {\\n                            revert(0, 0)\\n                        }\\n                        let xxRound := add(xx, half)\\n                        if lt(xxRound, xx) {\\n                            revert(0, 0)\\n                        }\\n                        x := div(xxRound, base)\\n                        if mod(n, 2) {\\n                            let zx := mul(z, x)\\n                            if and(\\n                                iszero(iszero(x)),\\n                                iszero(eq(div(zx, x), z))\\n                            ) {\\n                                revert(0, 0)\\n                            }\\n                            let zxRound := add(zx, half)\\n                            if lt(zxRound, zx) {\\n                                revert(0, 0)\\n                            }\\n                            z := div(zxRound, base)\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"blocksPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserves\",\"type\":\"uint256\"}],\"name\":\"getBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_borrowRate\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInterestRateModel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"StablecoinInterestRateModel","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}