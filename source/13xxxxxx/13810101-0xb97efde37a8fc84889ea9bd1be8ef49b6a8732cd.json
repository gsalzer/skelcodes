{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/mainnet/EtherOrcsAllies.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"./ERC721.sol\\\"; \\nimport \\\"../interfaces/Interfaces.sol\\\";\\n\\ncontract EtherOrcsAllies is ERC721 {\\n\\n    uint256 constant startId = 5050;\\n\\n    mapping(uint256 => Ally) public allies;\\n    mapping(address => bool) public auth;\\n\\n    uint16 shSupply;\\n    uint16 ogSupply;\\n    uint16 mgSupply;\\n    uint16 rgSupply;\\n\\n    ERC20 boneShards;\\n\\n    MetadataHandlerAllies metadaHandler;\\n\\n    address public castle;\\n    bool    public openForMint;\\n    \\n    bytes32 internal entropySauce;\\n\\n    struct Ally {uint8 class; uint16 level; uint32 lvlProgress; uint16 modF; uint8 skillCredits; bytes22 details;}\\n\\n    struct Shaman {uint8 body; uint8 featA; uint8 featB; uint8 helm; uint8 mainhand; uint8 offhand;}\\n\\n    modifier noCheaters() {\\n        uint256 size = 0;\\n        address acc = msg.sender;\\n        assembly { size := extcodesize(acc)}\\n\\n        require(auth[msg.sender] || (msg.sender == tx.origin && size == 0), \\\"you're trying to cheat!\\\");\\n        _;\\n\\n        // We'll use the last caller hash to add entropy to next caller\\n        entropySauce = keccak256(abi.encodePacked(acc, block.coinbase));\\n    }\\n\\n    function initialize(address ct, address bs, address meta) external {\\n        require(msg.sender == admin);\\n\\n        castle = ct;\\n        boneShards = ERC20(bs);\\n        metadaHandler = MetadataHandlerAllies(meta);\\n    }\\n\\n    function setAuth(address add_, bool status) external {\\n        require(msg.sender == admin);\\n        auth[add_] = status;\\n    }\\n\\n    function setMintOpen(bool open_) external {\\n        require(msg.sender == admin);\\n        openForMint = open_;\\n    }\\n\\n    function tokenURI(uint256 id) external view returns(string memory) {\\n        Ally memory ally = allies[id];\\n        return metadaHandler.getTokenURI(id, ally.class, ally.level, ally.modF, ally.skillCredits, ally.details);\\n    }\\n\\n    function mintShamans(uint256 amount) external {\\n        for (uint256 i = 0; i < amount; i++) {\\n            mintShaman();\\n        }\\n    }\\n\\n    function mintShaman() public noCheaters {\\n        require(openForMint || auth[msg.sender], \\\"not open for mint\\\");\\n        boneShards.burn(msg.sender, 60 ether);\\n\\n        _mintShaman(_rand());\\n    } \\n\\n    function pull(address owner_, uint256[] calldata ids) external {\\n        require (msg.sender == castle, \\\"not castle\\\");\\n        for (uint256 index = 0; index < ids.length; index++) {\\n            _transfer(owner_, msg.sender, ids[index]);\\n        }\\n        CastleLike(msg.sender).pullCallback(owner_, ids);\\n    }\\n\\n    function adjustAlly(uint256 id, uint8 class_, uint16 level_, uint32 lvlProgress_, uint16 modF_, uint8 skillCredits_, bytes22 details_) external {\\n        require(auth[msg.sender], \\\"not authorized\\\");\\n\\n        allies[id] = Ally({class: class_, level: level_, lvlProgress: lvlProgress_, modF: modF_, skillCredits: skillCredits_, details: details_});\\n    }\\n\\n    function shamans(uint256 id) external view returns(uint16 level, uint32 lvlProgress, uint16 modF, uint8 skillCredits, uint8 body, uint8 featA, uint8 featB, uint8 helm, uint8 mainhand, uint8 offhand) {\\n        Ally memory ally = allies[id];\\n        level        = ally.level;\\n        lvlProgress  = ally.lvlProgress;\\n        modF         = ally.modF;\\n        skillCredits = ally.skillCredits;\\n\\n        Shaman memory sh = _shaman(ally.details);\\n        body     = sh.body;\\n        featA    = sh.featA;\\n        featB    = sh.featB;\\n        helm     = sh.helm;\\n        mainhand = sh.mainhand;\\n        offhand  = sh.offhand;\\n    }\\n\\n    function _shaman(bytes22 details) internal pure returns(Shaman memory sh) {\\n        uint8 body     = uint8(bytes1(details));\\n        uint8 featA    = uint8(bytes1(details << 8));\\n        uint8 featB    = uint8(bytes1(details << 16));\\n        uint8 helm     = uint8(bytes1(details << 24));\\n        uint8 mainhand = uint8(bytes1(details << 32));\\n        uint8 offhand  = uint8(bytes1(details << 40));\\n\\n        sh.body     = body;\\n        sh.featA    = featA;\\n        sh.featB    = featB;\\n        sh.helm     = helm;\\n        sh.mainhand = mainhand;\\n        sh.offhand  = offhand;\\n    }\\n\\n\\n    function _mintShaman(uint256 rand) internal returns (uint16 id) {\\n        id = uint16(shSupply + 1 + startId); //check that supply is less than 3000\\n        require(shSupply++ <= 3000, \\\"max supply reached\\\");\\n\\n        // Getting Random traits\\n        uint8 body = _getBody(_randomize(rand, \\\"BODY\\\", id));\\n\\n        uint8 featB    = uint8(_randomize(rand, \\\"featB\\\",     id) % 22) + 1; \\n        uint8 featA    = uint8(_randomize(rand, \\\"featA\\\",    id) % 20) + 1; \\n        uint8 helm     = uint8(_randomize(rand, \\\"HELM\\\",     id) %  7) + 1;\\n        uint8 mainhand = uint8(_randomize(rand, \\\"MAINHAND\\\", id) %  7) + 1; \\n        uint8 offhand  = uint8(_randomize(rand, \\\"OFFHAND\\\",  id) %  7) + 1;\\n\\n        _mint(msg.sender, id);\\n\\n        allies[id] = Ally({class: 1, level: 25, lvlProgress: 25000, modF: 0, skillCredits: 100, details: bytes22(abi.encodePacked(body, featA, featB, helm, mainhand, offhand))});\\n    }\\n\\n    function _getBody(uint256 rand) internal pure returns (uint8) {\\n        uint256 sixtyFivePct = type(uint16).max / 100 * 65;\\n        uint256 nineSevenPct = type(uint16).max / 100 * 97;\\n        uint256 nineNinePct  = type(uint16).max / 100 * 99;\\n\\n        if (uint16(rand) < sixtyFivePct) return uint8(rand % 5) + 1;\\n        if (uint16(rand) < nineSevenPct) return uint8(rand % 4) + 6;\\n        if (uint16(rand) < nineNinePct) return 10;\\n        return 11;\\n    } \\n\\n    /// @dev Create a bit more of randomness\\n    function _randomize(uint256 rand, string memory val, uint256 spicy) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(rand, val, spicy)));\\n    }\\n\\n    function _rand() internal view returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.basefee, block.timestamp, entropySauce)));\\n    }\\n}\"\r\n    },\r\n    \"src/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// Taken from Solmate: https://github.com/Rari-Capital/solmate\\n\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external view virtual returns (string memory);\\n    function symbol() external view virtual returns (string memory);\\n    function decimals() external view virtual returns (uint8);\\n\\n    // string public constant name     = \\\"ZUG\\\";\\n    // string public constant symbol   = \\\"ZUG\\\";\\n    // uint8  public constant decimals = 18;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    mapping(address => bool) public isMinter;\\n\\n    address public ruler;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor() { ruler = msg.sender;}\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        balanceOf[msg.sender] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        balanceOf[from] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ORC PRIVILEGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mint(address to, uint256 value) external {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO MINT\\\");\\n        _mint(to, value);\\n    }\\n\\n    function burn(address from, uint256 value) external {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO BURN\\\");\\n        _burn(from, value);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Ruler Function\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setMinter(address minter, bool status) external {\\n        require(msg.sender == ruler, \\\"NOT ALLOWED TO RULE\\\");\\n\\n        isMinter[minter] = status;\\n    }\\n\\n    function setRuler(address ruler_) external {\\n        require(msg.sender == ruler ||ruler == address(0), \\\"NOT ALLOWED TO RULE\\\");\\n\\n        ruler = ruler_;\\n    }\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply += value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // This is safe because a user won't ever\\n        // have a balance larger than totalSupply!\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mainnet/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.7;\\n\\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\\n/// including the MetaData, and partially, Enumerable extensions.\\ncontract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n    \\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    address        implementation_;\\n    address public admin; //Lame requirement from opensea\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                             ERC-721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n    \\n    mapping(address => uint256) public balanceOf;\\n    \\n    mapping(uint256 => address) public ownerOf;\\n        \\n    mapping(uint256 => address) public getApproved;\\n \\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             VIEW FUNCTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function owner() external view returns (address) {\\n        return admin;\\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                              ERC-20-LIKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function transfer(address to, uint256 tokenId) external {\\n        require(msg.sender == ownerOf[tokenId], \\\"NOT_OWNER\\\");\\n        \\n        _transfer(msg.sender, to, tokenId);\\n        \\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                              ERC-721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\\n    }\\n    \\n    function approve(address spender, uint256 tokenId) external {\\n        address owner_ = ownerOf[tokenId];\\n        \\n        require(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \\\"NOT_APPROVED\\\");\\n        \\n        getApproved[tokenId] = spender;\\n        \\n        emit Approval(owner_, spender, tokenId); \\n    }\\n    \\n    function setApprovalForAll(address operator, bool approved) external {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n        \\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public {        \\n        require(\\n            msg.sender == from \\n            || msg.sender == getApproved[tokenId]\\n            || isApprovedForAll[from][msg.sender], \\n            \\\"NOT_APPROVED\\\"\\n        );\\n        \\n        _transfer(from, to, tokenId);\\n        \\n    }\\n    \\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n    \\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\\n        transferFrom(from, to, tokenId); \\n        \\n        if (to.code.length != 0) {\\n            // selector = `onERC721Received(address,address,uint,bytes)`\\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\\n                msg.sender, address(0), tokenId, data));\\n                \\n            bytes4 selector = abi.decode(returned, (bytes4));\\n            \\n            require(selector == 0x150b7a02, \\\"NOT_ERC721_RECEIVER\\\");\\n        }\\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf[tokenId] == from, \\\"not owner\\\");\\n\\n        balanceOf[from]--; \\n        balanceOf[to]++;\\n        \\n        delete getApproved[tokenId];\\n        \\n        ownerOf[tokenId] = to;\\n        emit Transfer(from, to, tokenId); \\n\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal { \\n        require(ownerOf[tokenId] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        totalSupply++;\\n        \\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n        \\n        ownerOf[tokenId] = to;\\n                \\n        emit Transfer(address(0), to, tokenId); \\n    }\\n    \\n    function _burn(uint256 tokenId) internal { \\n        address owner_ = ownerOf[tokenId];\\n        \\n        require(ownerOf[tokenId] != address(0), \\\"NOT_MINTED\\\");\\n        \\n        totalSupply--;\\n        balanceOf[owner_]--;\\n        \\n        delete ownerOf[tokenId];\\n                \\n        emit Transfer(owner_, address(0), tokenId); \\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.7;\\n\\ninterface OrcishLike {\\n    function pull(address owner, uint256[] calldata ids) external;\\n    function manuallyAdjustOrc(uint256 id, uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress) external;\\n    function transfer(address to, uint256 tokenId) external;\\n    function orcs(uint256 id) external view returns(uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress);\\n    function allies(uint256 id) external view returns (uint8 class, uint16 level, uint32 lvlProgress, uint16 modF, uint8 skillCredits, bytes22 details);\\n    function adjustAlly(uint256 id, uint8 class_, uint16 level_, uint32 lvlProgress_, uint16 modF_, uint8 skillCredits_, bytes22 details_) external;\\n}\\n\\ninterface PortalLike {\\n    function sendMessage(bytes calldata message_) external;\\n}\\n\\ninterface OracleLike {\\n    function request() external returns (uint64 key);\\n    function getRandom(uint64 id) external view returns(uint256 rand);\\n}\\n\\ninterface MetadataHandlerLike {\\n    function getTokenURI(uint16 id, uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier) external view returns (string memory);\\n}\\n\\ninterface MetadataHandlerAllies {\\n    function getTokenURI(uint256 id_, uint256 class_, uint256 level_, uint256 modF_, uint256 skillCredits_, bytes22 details_) external view returns (string memory);\\n}\\n\\ninterface RaidsLike {\\n    function stakeManyAndStartCampaign(uint256[] calldata ids_, address owner_, uint256 location_, bool double_) external;\\n    function startCampaignWithMany(uint256[] calldata ids, uint256 location_, bool double_) external;\\n    function commanders(uint256 id) external returns(address);\\n    function unstake(uint256 id) external;\\n}\\n\\ninterface RaidsLikePoly {\\n    function stakeManyAndStartCampaign(uint256[] calldata ids_, address owner_, uint256 location_, bool double_, uint256[] calldata potions_) external;\\n    function startCampaignWithMany(uint256[] calldata ids, uint256 location_, bool double_,  uint256[] calldata potions_) external;\\n    function commanders(uint256 id) external returns(address);\\n    function unstake(uint256 id) external;\\n}\\n\\ninterface CastleLike {\\n    function pullCallback(address owner, uint256[] calldata ids) external;\\n}\\n\\ninterface EtherOrcsLike {\\n    function ownerOf(uint256 id) external view returns (address owner_);\\n    function activities(uint256 id) external view returns (address owner, uint88 timestamp, uint8 action);\\n    function orcs(uint256 orcId) external view returns (uint8 body, uint8 helm, uint8 mainhand, uint8 offhand, uint16 level, uint16 zugModifier, uint32 lvlProgress);\\n}\\n\\ninterface ERC20Like {\\n    function balanceOf(address from) external view returns(uint256 balance);\\n    function burn(address from, uint256 amount) external;\\n    function mint(address from, uint256 amount) external;\\n    function transfer(address to, uint256 amount) external;\\n}\\n\\ninterface ERC1155Like {\\n    function mint(address to, uint256 id, uint256 amount) external;\\n    function burn(address from, uint256 id, uint256 amount) external;\\n}\\n\\ninterface ERC721Like {\\n    function transferFrom(address from, address to, uint256 id) external;   \\n    function transfer(address to, uint256 id) external;\\n    function ownerOf(uint256 id) external returns (address owner);\\n    function mint(address to, uint256 tokenid) external;\\n}\\n\\ninterface HallOfChampionsLike {\\n    function joined(uint256 orcId) external view returns (uint256 joinDate);\\n} \\n\\ninterface AlliesLike {\\n    function allies(uint256 id) external view returns (uint8 class, uint16 level, uint32 lvlProgress, uint16 modF, uint8 skillCredits, bytes22 details);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"class_\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"level_\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lvlProgress_\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"modF_\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"skillCredits_\",\"type\":\"uint8\"},{\"internalType\":\"bytes22\",\"name\":\"details_\",\"type\":\"bytes22\"}],\"name\":\"adjustAlly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allies\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"class\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"level\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lvlProgress\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"modF\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"skillCredits\",\"type\":\"uint8\"},{\"internalType\":\"bytes22\",\"name\":\"details\",\"type\":\"bytes22\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"castle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bs\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"meta\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintShaman\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintShamans\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openForMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAuth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"open_\",\"type\":\"bool\"}],\"name\":\"setMintOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"shamans\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"level\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"lvlProgress\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"modF\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"skillCredits\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"featA\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"featB\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"helm\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"mainhand\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offhand\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EtherOrcsAllies","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}