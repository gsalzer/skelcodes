{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENCED\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOracleWrapper {\r\n    function getPrice(address _coinAddress, address pair) external view returns (uint256);\r\n}\r\n\r\nlibrary PlanLibrary {\r\n    \r\n    struct PlanDetails { //check packing\r\n        uint64 risk;\r\n        uint64 reward;\r\n        uint120 drop;\r\n        bool isActive;\r\n    }\r\n    \r\n    function setPlan(PlanDetails storage plan, uint256 _reward, uint256 _risk, uint256 _drop) internal {\r\n        require(_risk >= 0 && _risk <= 100, \"PlanLibrary : Invalid\");\r\n        require(_drop > 0 && _drop <= 100, \"PlanLibrary : Invalid\");\r\n        \r\n        plan.reward = uint64(_reward);\r\n        plan.risk = uint64(_risk);\r\n        plan.drop = uint120(_drop);\r\n        plan.isActive = true;\r\n    }\r\n    \r\n    function setReward(PlanDetails storage plan, uint256 _reward) internal {\r\n        require(_reward > 0, \"PlanLibrary : Invalid reward\");\r\n        \r\n        plan.reward = uint64(_reward);\r\n    }\r\n    \r\n    function setRisk(PlanDetails storage plan, uint256 _risk) internal {\r\n        require(_risk >= 0 && _risk <= 100, \"PlanLibrary : Invalid\");\r\n        \r\n        plan.risk = uint64(_risk);\r\n    }\r\n    \r\n    function setDrop(PlanDetails storage plan, uint256 _drop) internal {\r\n        require(_drop > 0 && _drop <= 100, \"PlanLibrary : Invalid\");\r\n        \r\n        plan.drop = uint120(_drop);\r\n        \r\n    }\r\n    \r\n    function setStatus(PlanDetails storage plan, bool status) internal {\r\n        \r\n        if (plan.isActive != status) {\r\n                plan.isActive = status;\r\n            }\r\n    }\r\n}\r\n\r\nlibrary UserLibrary {\r\n    \r\n    struct UserDetails {\r\n        uint256 lastBetIndex;\r\n    }\r\n   \r\n}\r\n\r\nlibrary BettingLibrary {\r\n    \r\n    struct BettingDetailsOne { //check packing\r\n        uint128 amount;\r\n        uint120 status; //1 => Win, 2 => Loose\r\n        bool isInverse;\r\n        uint96 initialPrice;\r\n        uint96 priceInXIV;\r\n        address betTokenAddress;\r\n        address coinAddress;\r\n        \r\n    }\r\n    \r\n    struct BettingDetailsTwo { //check packing\r\n        uint64 reward;\r\n        uint32 risk;\r\n        uint32 dropValue;\r\n        uint48 planType;\r\n        uint32 startTime;\r\n        uint32 endTime;\r\n        bool isInToken;\r\n        bool isClaimed;\r\n    }\r\n\r\n    function setBetDetailsOne(BettingDetailsOne storage bet, uint256 _amount, uint256 _initialPrice, uint256 _priceInXIV, address _coinAddress, address betToken, bool _isInverse) internal {\r\n        bet.amount = uint128(_amount);\r\n        bet.isInverse = _isInverse;\r\n        bet.initialPrice = uint96(_initialPrice);\r\n        bet.priceInXIV = uint96(_priceInXIV);\r\n        bet.coinAddress = _coinAddress;\r\n        bet.betTokenAddress = betToken;\r\n    }\r\n    \r\n    function setBetDetailsTwo(BettingDetailsTwo storage bet, uint256 _reward, uint256 _riak, uint256 _drop, uint256 _planType, uint256 _startTime, uint256 _endTime) internal {\r\n        bet.reward = uint64(_reward);\r\n        bet.risk = uint32(_riak);\r\n        bet.dropValue = uint32(_drop);\r\n        bet.planType = uint48(_planType);\r\n        bet.startTime = uint32(_startTime);\r\n        bet.endTime = uint32(_endTime);\r\n    }\r\n\r\n    function changeClaimedStatus (BettingDetailsTwo storage bet) internal {\r\n        if (bet.isClaimed == false) {\r\n            bet.isClaimed = true;\r\n        }\r\n    }\r\n    \r\n    function declareBet(BettingDetailsOne storage bet, uint finalPrice, uint drop) internal returns (uint120) {\r\n        uint256 initialPrice = uint256(bet.initialPrice);\r\n        uint256 dip;\r\n\r\n        if (bet.isInverse) {\r\n            if (finalPrice < initialPrice) {\r\n                dip = ((initialPrice - finalPrice) * 100) / initialPrice;\r\n                if (dip >= drop) {\r\n                    return bet.status = 1;\r\n                }\r\n            }    \r\n        } else {\r\n            if (finalPrice > initialPrice) {\r\n                dip = (((finalPrice - initialPrice) * 100) / initialPrice);\r\n                if (dip >= drop) {\r\n                    return bet.status = 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        return bet.status = 2;\r\n    }\r\n}\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{ value: value }(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\ninterface InverseV0Events {\r\n\r\n   event LPEvent(uint typeOfLP,address  userAddress,uint amount,uint timestamp);\r\n   event Addcoins(uint coinType, uint planType, uint counter, bool status, address coinAddress);\r\n   event CoinStatus(address coinAddress, uint coinType, uint planType, bool status);\r\n   event IndexCoinStatus(uint coinType, uint planType, bool status);\r\n   event NewBet(address indexed user, address coinAddress, address betCoin, uint indexed betIndex, uint planIndex, uint planDays, uint startTime, uint indexed endTime);\r\n   event BetResolved(address indexed user, uint indexed index, uint indexed result, uint endTime);\r\n   event BetClaimed(address indexed user, uint indexed betIndex, uint timeOfClaim, uint winningAmount);\r\n   event UserPenalized(address indexed user, uint256 indexed betIndex, bool indexed isClaimed);\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    \r\n    \r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n    \r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary StakingLibrary {\r\n   \r\n    struct StakingCycle {\r\n        uint64 stakingTime;\r\n        uint64 lastIndex;\r\n        uint128 stakedAmount;\r\n    }\r\n\r\n    struct StakingReward {\r\n        uint96 betEndStake;\r\n        uint96 stakingReward;\r\n        uint32 betEndTime;\r\n        uint32 status;\r\n    }\r\n    \r\n    struct ClaimDetails {\r\n        uint128 lastStakedAmount;\r\n        uint128 amountUnstaked;//check if this is required\r\n        uint128 stakeResidual;\r\n        uint128 profit;\r\n        uint128 losses;\r\n        uint32 lastStakedTime;\r\n        uint32 lastClaimedBet;\r\n        uint32 stakeCounter;\r\n        uint32 lastUnstakeIndex;\r\n    }\r\n\r\n    function setStakingRewards(StakingReward storage stake, uint256 endStake, uint256 _stakingReward, uint256 result) internal {\r\n        stake.betEndStake = uint96(endStake);\r\n        stake.stakingReward = uint96(_stakingReward);\r\n        stake.betEndTime = uint32(block.timestamp);\r\n        stake.status = uint32(result);\r\n    }\r\n    \r\n    function setStakeCycle(StakingCycle storage cycle, uint256 amount) internal {\r\n        cycle.stakingTime = uint64(block.timestamp);\r\n        cycle.stakedAmount = uint128(amount);\r\n    }\r\n    \r\n    function setStakingDetails(ClaimDetails storage stake, uint256 amount) internal {\r\n        stake.lastStakedAmount += uint128(amount);\r\n        stake.lastStakedTime = uint32(block.timestamp);\r\n        stake.stakeCounter++;\r\n    }\r\n    \r\n    function setClaimDetails(ClaimDetails storage stake, uint256 balance, uint256 amount, uint256 claimedIndex) internal {\r\n        uint256 diff;\r\n        if (stake.losses > stake.profit) {\r\n            diff = uint256(stake.losses - stake.profit);\r\n        }\r\n        require(balance + uint256(stake.stakeResidual) >= (amount + diff), \"StakingLibrary: Insufficient\");\r\n        require(uint256(stake.lastStakedAmount) >= amount, \"StakingLibrary: Insufficient\");\r\n        \r\n        uint256 residual = ((balance + uint256(stake.stakeResidual)) - (amount + diff));\r\n        \r\n        stake.stakeResidual = uint128(residual);\r\n        \r\n        if (diff > 0) {\r\n            stake.profit = uint128(0);\r\n            stake.losses = uint128(0);\r\n        }\r\n        \r\n        stake.lastStakedTime = uint32(block.timestamp);\r\n        \r\n        if (stake.lastUnstakeIndex != uint32(claimedIndex)) {\r\n            stake.lastUnstakeIndex = uint32(claimedIndex);\r\n        }\r\n        \r\n        stake.amountUnstaked += uint128(amount + diff);\r\n        if (amount + diff <= uint256(stake.lastStakedAmount)) {\r\n            stake.lastStakedAmount -= uint128(amount);\r\n        }\r\n        \r\n    }\r\n}\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title CustomOwnable\r\n * @dev This contract has the owner address providing basic authorization control\r\n */\r\ncontract CustomOwnable is Context  {\r\n    /**\r\n     * @dev Event to show ownership has been transferred\r\n     * @param previousOwner representing the address of the previous owner\r\n     * @param newOwner representing the address of the new owner\r\n     */\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Owner of the contract\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_msgSender() == owner(), \"CustomOwnable: FORBIDDEN\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return the address of the owner\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new owner address\r\n     */\r\n    function _setOwner(address newOwner) internal {\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"CustomOwnable: FORBIDDEN\");\r\n        emit OwnershipTransferred(owner(), newOwner);\r\n        _setOwner(newOwner);\r\n    }\r\n}\r\n\r\n\r\ncontract InverseV0 is InverseV0Events, CustomOwnable, ReentrancyGuard {\r\n\r\n    using StakingLibrary for StakingLibrary.StakingCycle;\r\n    using StakingLibrary for StakingLibrary.StakingReward;\r\n    using StakingLibrary for StakingLibrary.ClaimDetails;\r\n    using BettingLibrary for BettingLibrary.BettingDetailsOne;\r\n    using BettingLibrary for BettingLibrary.BettingDetailsTwo;\r\n    using UserLibrary for UserLibrary.UserDetails;\r\n    using PlanLibrary for PlanLibrary.PlanDetails;\r\n    \r\n    uint256 public SECONDS_IN_DAY;         // Seconds in a day\r\n\r\n\r\n    bool internal isInitialized;\r\n    uint256 public globalPool;         //total amount in pool\r\n    uint256 public miniStakeAmount ;   // Min amount of token that user can stake \r\n    uint256 public maxStakeAmount ;   // Max amount of token that user can stake \r\n    uint256 public betFactorLP;               // this is the ratio according to which users can bet considering the amount staked..\r\n    uint256 public miniBetAmount;             // min amount that user can bet on.\r\n    uint256 public maxBetAmount;            // max amount that user can bet on.\r\n    uint256 public defiCoinsCounter;          // Number of Defi plans\r\n    uint256 public chainCoinsCounter;         // Number of Chain plans      \r\n    uint256 public NFTCoinsCounter;           // Number of NFT plan\r\n    uint256 public stakerIncentiveCounter;\r\n    uint256 public planCounter;\r\n    uint256 public planDaysCounter;\r\n    uint256 public maxWalks;\r\n    uint256 public bufferTime;\r\n    uint256 public betFees;\r\n    uint256 public threshold;\r\n    uint256 public accumulatedXIV;\r\n    bool public isMultiTokenActive;\r\n    \r\n    address public oracleAddress;\r\n    address public revokeComissionAddress;\r\n\r\n    IERC20 public XIV;\r\n    IERC20 coin;\r\n    IERC20 public usdt;\r\n    IOracleWrapper public oracle;\r\n\r\n    mapping(address => UserLibrary.UserDetails) public users;\r\n    mapping(address => mapping (uint256 => StakingLibrary.StakingCycle)) public stakes;\r\n    mapping(address => StakingLibrary.ClaimDetails) public stakeDetails;\r\n    mapping(address => uint256) public betCounter;\r\n    mapping(address => mapping(uint256 => mapping (uint256 => bool))) public coinStatus;\r\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => address))) public coins;\r\n    mapping(address => mapping(address => bool)) public isEligibleForBet;\r\n    mapping(address => mapping(uint256 => BettingLibrary.BettingDetailsOne)) public userBetsOne;\r\n    mapping(address => mapping(uint256 => BettingLibrary.BettingDetailsTwo)) public userBetsTwo;\r\n    mapping(uint256 => StakingLibrary.StakingReward) public stakerRewards;\r\n    \r\n    mapping(uint256 => PlanLibrary.PlanDetails) public plans;\r\n    mapping(uint256 => uint256) public planDaysIndexed;\r\n    mapping(uint256 => mapping(uint256 => uint256)) public penalty;\r\n    \r\n    modifier typeValidation(uint256 _coinType, uint256 planType) {\r\n        require((_coinType == 1 || _coinType == 2 || _coinType == 3), \"Invalid\");\r\n        require((planType == 1 || planType == 2), \"Invalid PlanType\");\r\n        _;\r\n    }\r\n    \r\n    modifier planValidation(uint256 coinType, uint256 planType) {\r\n        require((coinType == 1 || coinType == 2 || coinType == 3), \"Invalid\");\r\n        require((planType == 1 || planType == 2), \"Invalid PlanType\");\r\n        _;\r\n    }\r\n\r\n    modifier validateBetArguments(address coinAddress, uint coinType, uint planType, address betToken)  {\r\n        require(betToken != address(0), \"Invalid\");\r\n        \r\n        if (!isMultiTokenActive) {\r\n            require(betToken == address(XIV), \"Multi token inactive\");\r\n        }\r\n        require(coinStatus[coinAddress][coinType][planType], \"Not active\");\r\n        require(!isEligibleForBet[_msgSender()][coinAddress], \"Bet already active\");\r\n        \r\n        _;\r\n    }\r\n    \r\n    modifier amountValidation(uint amount) {\r\n        require(amount > 0, \"Invalid\");\r\n        _;\r\n    }\r\n    \r\n    modifier countValidation(uint256 count, uint256 counter) {\r\n        require(count >= 0 && (count < counter), \"Invalid\");\r\n        _;\r\n    }\r\n   \r\n\r\n    function initialize(address _admin, address _XIVAddress, address _revokeComissionAddress, uint _miniStakeAmount, uint _betFactorLP, uint _miniBetAmount, uint _maxBetAmount, address _oracle, address _usdt) public {\r\n        require(!isInitialized);\r\n        isInitialized = true;\r\n        miniStakeAmount  = _miniStakeAmount;\r\n        maxStakeAmount = (100000 * 10**18);\r\n        betFactorLP = _betFactorLP;\r\n        miniBetAmount = _miniBetAmount;\r\n        maxBetAmount = _maxBetAmount;\r\n        bufferTime = 3600;\r\n        XIV = IERC20(_XIVAddress);\r\n        oracle = IOracleWrapper(_oracle);\r\n        usdt = IERC20(_usdt);\r\n        _setOwner(_admin);\r\n        maxWalks = 100;\r\n        SECONDS_IN_DAY = 86400;\r\n        setPlanDetails([6,3,5,7], [300,50,100,200], [0,0,0,0]);\r\n        planCounter = 4;\r\n        betFees = 7;\r\n        threshold = (10000 * 10**18);\r\n        revokeComissionAddress = _revokeComissionAddress;\r\n        \r\n        planDaysIndexed[0] = 1;\r\n        planDaysIndexed[1] = 1;\r\n        planDaysIndexed[2] = 3;\r\n        planDaysIndexed[3] = 7;\r\n        \r\n        penalty[1][0] = 7;\r\n        penalty[3][0] = 7;\r\n        penalty[3][1] = 7;\r\n        penalty[3][2] = 7;\r\n        penalty[7][0] = 7;\r\n        penalty[7][1] = 7;\r\n        penalty[7][2] = 7;\r\n        penalty[7][3] = 7;\r\n        penalty[7][4] = 7;\r\n        penalty[7][5] = 7;\r\n        penalty[7][6] = 7;\r\n        \r\n        \r\n        planDaysCounter = 4;\r\n    }\r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n    \r\n    function stakeTokens(uint256 amount) external nonReentrant {\r\n        require(amount >= miniStakeAmount && amount <= maxStakeAmount, \"Invalid\");\r\n        _updateRewards(_msgSender());\r\n        StakingLibrary.ClaimDetails storage stake = stakeDetails[_msgSender()];\r\n        require((stake.lastClaimedBet == stakerIncentiveCounter) || (stake.stakeCounter == uint32(0)), \"Claim all bets\");\r\n        TransferHelper.safeTransferFrom(address(XIV), _msgSender(), address(this), amount);\r\n        \r\n        uint256 count = stake.stakeCounter;\r\n        \r\n        stakes[_msgSender()][count].setStakeCycle(amount);\r\n        stake.setStakingDetails(amount);\r\n        globalPool += amount;\r\n    }\r\n    \r\n    function unstakeTokens(uint256 amount) external nonReentrant {\r\n        _updateRewards(_msgSender());\r\n        require(stakeDetails[_msgSender()].lastClaimedBet == stakerIncentiveCounter, \"Claim all bets\");\r\n        (uint256 balance, uint256 claimedIndex) = amountToUnlock(_msgSender());\r\n        \r\n        require(globalPool >= amount, \"Insufficient funds\");\r\n        \r\n        stakeDetails[_msgSender()].setClaimDetails(balance, amount, claimedIndex);\r\n        globalPool -= amount;\r\n        TransferHelper.safeTransfer(address(XIV), _msgSender(), amount);\r\n    }\r\n    \r\n    function amountToUnlock(address user) public view returns (uint256, uint256) {\r\n        StakingLibrary.ClaimDetails storage stake = stakeDetails[user];\r\n        uint256 count = uint256(stake.stakeCounter);\r\n        uint256 lastIndex = uint256(stake.lastUnstakeIndex);\r\n        uint256 balance;\r\n        uint256 claimedIndex = lastIndex;\r\n        \r\n        require(count >= lastIndex, \"Invalid\");\r\n        \r\n        if (count > lastIndex) {\r\n            for (uint256 i = lastIndex; i < count; i++) {\r\n                StakingLibrary.StakingCycle storage cycle = stakes[user][i];\r\n                \r\n                balance += uint256(cycle.stakedAmount);\r\n                claimedIndex = (i+1);\r\n            }\r\n        }\r\n        \r\n        return (balance, claimedIndex);\r\n    }\r\n    \r\n    function updateRewards(address user) external nonReentrant {\r\n        require(stakeDetails[user].lastClaimedBet < stakerIncentiveCounter, \"Already updated\");\r\n        _updateRewards(user);\r\n    }\r\n    \r\n    function _updateRewards(address user) internal returns (bool) {\r\n        StakingLibrary.ClaimDetails storage stake = stakeDetails[user];\r\n        \r\n        if (stake.lastClaimedBet == stakerIncentiveCounter) {\r\n            return true;\r\n        }\r\n        \r\n        if (stake.stakeCounter == uint32(0)) {\r\n            stake.lastClaimedBet = uint32(stakerIncentiveCounter);\r\n            return true;\r\n        }\r\n        \r\n        (uint256 rewards, uint256 loss, uint256 lastClaimed) = getRewards(user);\r\n        \r\n        if (rewards == 0 && loss == 0) {\r\n            return true;\r\n        }\r\n        \r\n        if (rewards > 0) {\r\n            stake.profit += uint128(rewards);\r\n        }\r\n        \r\n        if (loss > 0) {\r\n            stake.losses += uint128(loss);\r\n        }\r\n        \r\n        stake.lastClaimedBet = uint32(lastClaimed);\r\n        \r\n        if (lastClaimed == stakerIncentiveCounter) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function claimRewards() external nonReentrant {\r\n        _updateRewards(_msgSender());\r\n        StakingLibrary.ClaimDetails storage stake = stakeDetails[_msgSender()];\r\n        \r\n        require(stake.profit > stake.losses, \"No rewards\");\r\n        uint256 amount = (stake.profit - stake.losses);\r\n        \r\n        stake.profit = uint128(0);\r\n        stake.losses = uint128(0);\r\n        \r\n        TransferHelper.safeTransfer(address(XIV), _msgSender(), amount);\r\n    }\r\n    \r\n    function getRewards(address user) public view returns (uint256, uint256, uint256) {\r\n        StakingLibrary.ClaimDetails storage stake = stakeDetails[user];\r\n        uint256 start = uint256(stake.lastClaimedBet);\r\n        uint256 time = uint256(stake.lastStakedTime);\r\n        uint256 amount = uint256(stake.lastStakedAmount);\r\n        uint256 incentive;\r\n        uint256 loss;\r\n        uint256 end;\r\n        \r\n        if (start + maxWalks >= stakerIncentiveCounter) {\r\n            end = stakerIncentiveCounter;\r\n        } else {\r\n            end = start + maxWalks;\r\n        }\r\n        \r\n        for (uint256 i = start; i < end; i++) {\r\n            StakingLibrary.StakingReward storage reward = stakerRewards[i];\r\n            \r\n            if (reward.betEndTime > time) {\r\n                if (uint256(reward.status) == 2) {\r\n                    incentive += ((uint256(reward.stakingReward) * amount) / uint256(reward.betEndStake));\r\n                } else if (uint256(reward.status) == 1) {\r\n                    loss += ((uint256(reward.stakingReward) * amount) / uint256(reward.betEndStake));\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (incentive, loss, end);\r\n    }\r\n    \r\n    function betFlexible(uint amount, uint coinType, address coinAddress, address betToken, uint index, uint _daysIndex, bool _isInverse) external payable validateBetArguments(coinAddress, coinType, 2, betToken) nonReentrant {\r\n        uint256 planDays = planDaysIndexed[_daysIndex];\r\n        \r\n        require(((index > 0) && (index < planCounter)));\r\n        require(planDays != 0, \"Invalid\");\r\n        \r\n        saveBetDetailsOne(_msgSender(), amount, coinAddress, betToken, _isInverse);\r\n        saveBetDetailsTwo(_msgSender(), index, planDays, 2);\r\n    }\r\n    \r\n    function betFixed(uint amount, uint coinType, address coinAddress, address betToken, bool _isInverse) external payable validateBetArguments(coinAddress, coinType, 1, betToken) nonReentrant {     \r\n        saveBetDetailsOne(_msgSender(), amount, coinAddress, betToken, _isInverse);\r\n        saveBetDetailsTwo(_msgSender(), 0, planDaysIndexed[0],  1);\r\n    }\r\n    \r\n    function saveBetDetailsOne(address user, uint256 amount, address _coinAddress, address betToken, bool _isInverse) internal {\r\n        uint256 fees = (amount * betFees) / 100;\r\n        uint256 actualAmount = amount;\r\n        amount = (amount - fees);\r\n        uint256 priceInXIV;\r\n        \r\n        \r\n        if (betToken != address(XIV)) {\r\n            priceInXIV = getPriceInXIV(betToken);\r\n            \r\n            uint256 amountInXIV;\r\n            \r\n            if (betToken == address(1)) {\r\n                require(msg.value == actualAmount, \"Invalid\");\r\n                amountInXIV = (actualAmount  * priceInXIV) / (10 ** 18);\r\n            } else {\r\n                amountInXIV = (actualAmount  * priceInXIV) / (10 ** (IERC20(betToken).decimals()));\r\n            }\r\n            \r\n            // check this condition\r\n            if (XIV.balanceOf(address(this)) > globalPool) {\r\n                require((betFactorLP * globalPool) >= ((XIV.balanceOf(address(this)) - globalPool) + amountInXIV), \"Betfactor\");\r\n            }\r\n            \r\n            require(amountInXIV >= miniBetAmount && amountInXIV <= maxBetAmount ,\"Invalid\");\r\n        } else {\r\n            //check this condition\r\n            if (XIV.balanceOf(address(this)) > globalPool) {\r\n                require((betFactorLP * globalPool) >= ((XIV.balanceOf(address(this)) - globalPool) + actualAmount), \"Betfactor\");\r\n            }\r\n            \r\n            require(actualAmount >= miniBetAmount && actualAmount <= maxBetAmount ,\"Invalid\");\r\n        }\r\n\r\n        BettingLibrary.BettingDetailsOne storage betOne = userBetsOne[user][betCounter[user]];\r\n        BettingLibrary.BettingDetailsTwo storage betTwo = userBetsTwo[user][betCounter[user]];\r\n\r\n        if (msg.value == 0 && (betToken != address(1))) {\r\n            TransferHelper.safeTransferFrom(betToken, user, address(this), actualAmount);\r\n            \r\n            if (fees > 0 && betToken != address(XIV)) {\r\n                TransferHelper.safeTransfer(betToken, revokeComissionAddress, fees);\r\n            } else if (fees > 0 && betToken == address(XIV)) {\r\n                accumulatedXIV += fees;\r\n                \r\n                if (accumulatedXIV > threshold) {\r\n                    stakerRewards[stakerIncentiveCounter].setStakingRewards(globalPool, accumulatedXIV, 2);\r\n                    stakerIncentiveCounter++;\r\n                    accumulatedXIV = 0;\r\n                }\r\n            }\r\n            \r\n            betTwo.isInToken = true;\r\n        } else {\r\n            require(betToken == address(1), \"BetToken must be 0x1\");\r\n            if (fees > 0) {\r\n                TransferHelper.safeTransferETH(revokeComissionAddress, fees);\r\n            }\r\n            \r\n        }\r\n\r\n        betOne.setBetDetailsOne(amount, oracle.getPrice(_coinAddress, address(usdt)), priceInXIV, _coinAddress, betToken, _isInverse);\r\n    }\r\n    \r\n    function saveBetDetailsTwo(address user, uint256 planIndex, uint _days, uint _planType) internal {\r\n        BettingLibrary.BettingDetailsOne storage betOne = userBetsOne[user][betCounter[user]];\r\n        BettingLibrary.BettingDetailsTwo storage betTwo = userBetsTwo[user][betCounter[user]];\r\n        \r\n        if (_planType == 1) {\r\n            betTwo.setBetDetailsTwo((plans[planIndex].reward), (plans[planIndex].risk), (plans[planIndex].drop), _planType, block.timestamp, (block.timestamp + (_days * (SECONDS_IN_DAY / 2))));\r\n        } else {\r\n            betTwo.setBetDetailsTwo((plans[planIndex].reward), (plans[planIndex].risk), (plans[planIndex].drop), _planType, block.timestamp, (block.timestamp + (_days * SECONDS_IN_DAY)));\r\n        }\r\n\r\n        \r\n        isEligibleForBet[user][betOne.coinAddress] = true;\r\n        \r\n        emit NewBet(user, betOne.coinAddress, betOne.betTokenAddress, betCounter[user], planIndex, _days, block.timestamp, (block.timestamp + (_days * SECONDS_IN_DAY)));\r\n        betCounter[user]++;\r\n    }\r\n\r\n    function resolveBet(uint[] memory index, address[] memory user, bool timeCheck) external onlyOwner nonReentrant {\r\n        require(index.length == user.length, \"Length mismatch\");\r\n        \r\n        for (uint256 i; i < index.length; i++) {\r\n            require((index[i] < betCounter[user[i]]) ,\"Invalid\");\r\n            BettingLibrary.BettingDetailsOne storage betOne = userBetsOne[user[i]][index[i]];\r\n            BettingLibrary.BettingDetailsTwo storage betTwo = userBetsTwo[user[i]][index[i]];\r\n            require(betOne.status == 0, \"Already resolved\");\r\n    \r\n            if (timeCheck) {\r\n                require(block.timestamp > betTwo.endTime && block.timestamp <= betTwo.endTime + bufferTime, \"EndTime error\");\r\n            }\r\n            \r\n            uint currentPrice = oracle.getPrice(betOne.coinAddress, address(usdt));\r\n    \r\n            //Find the result\r\n            uint256 result = betOne.declareBet(currentPrice, uint256(betTwo.dropValue));\r\n            \r\n            if(result == 2 || result == 1) {\r\n                uint256 betRewards;\r\n                uint256 amount = uint256(betOne.amount);\r\n                uint256 priceInXIV = uint256(betOne.priceInXIV);\r\n                uint256 risk = uint256(betTwo.reward);\r\n                \r\n                if (betOne.priceInXIV != 0 && (betOne.betTokenAddress != address(XIV))) {\r\n                    if (betOne.betTokenAddress == address(1)) {\r\n                        betRewards = (amount * priceInXIV * risk) / (10 ** 20);\r\n                    } else {\r\n                        betRewards = (amount * priceInXIV * risk) / (100 * (10 ** (IERC20(betOne.betTokenAddress).decimals())));\r\n                    }\r\n                } else {\r\n                    betRewards = (amount * risk) / 100;\r\n                }\r\n                \r\n                stakerRewards[stakerIncentiveCounter].setStakingRewards(globalPool, betRewards, result);\r\n                stakerIncentiveCounter++;\r\n            }\r\n            \r\n            isEligibleForBet[user[i]][betOne.coinAddress] = false;\r\n            \r\n            emit BetResolved(user[i], index[i], result, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function claimBets() external nonReentrant {\r\n        \r\n        uint256 amountInETH;\r\n        uint256 amountInXIV;\r\n        uint256 lossInXIV;\r\n        uint256 claimedIndex;\r\n        uint256 lastIndex = users[_msgSender()].lastBetIndex;\r\n        \r\n        require(betCounter[_msgSender()] > lastIndex, \"No new bet\");\r\n        \r\n        for(uint256 i = lastIndex; i < betCounter[_msgSender()]; i++) {\r\n            BettingLibrary.BettingDetailsOne storage betOne = userBetsOne[_msgSender()][i];\r\n            BettingLibrary.BettingDetailsTwo storage betTwo = userBetsTwo[_msgSender()][i];\r\n            \r\n            if (!betTwo.isClaimed && (betOne.status != 0)) {\r\n                uint256 amount = uint256(betOne.amount);\r\n                uint256 reward = uint256(betTwo.reward);\r\n                uint256 risk = uint256(betTwo.risk);\r\n                uint256 winningAmount;\r\n                \r\n                if((betOne.status == 1)) {\r\n                    if (betTwo.isInToken) {\r\n                        if (betOne.betTokenAddress != address(XIV)) {\r\n                            TransferHelper.safeTransfer(betOne.betTokenAddress, _msgSender(), amount);\r\n                        } else {\r\n                            amountInXIV += amount;\r\n                        }\r\n                    } else {\r\n                        amountInETH += amount;\r\n                    }\r\n\r\n                    if ((betOne.betTokenAddress != address(XIV)) && (betOne.priceInXIV > 0)) {\r\n                        if (betOne.betTokenAddress == address(1)) {\r\n                            winningAmount = ((amount * uint256(betOne.priceInXIV) * reward) /  (10 ** 20));\r\n                        } else {\r\n                            winningAmount = ((amount * uint256(betOne.priceInXIV) * reward) / (100 * (10 ** IERC20(betOne.betTokenAddress).decimals())));\r\n                        }\r\n                        \r\n                        amountInXIV += winningAmount;\r\n                    } else {\r\n                        winningAmount = (amount * reward) / 100;\r\n                        amountInXIV += winningAmount;\r\n                    }\r\n                    \r\n                    betTwo.changeClaimedStatus();\r\n                    \r\n                } else if (betOne.status == 2) {\r\n                    require(risk <= 100, \"Invalid\");\r\n                    \r\n                    uint256 loss = (risk * amount) / 100;\r\n                    uint256 balance = (amount - loss);\r\n                        \r\n                    if (betTwo.isInToken) {\r\n                        if (betOne.betTokenAddress != address(XIV)) {\r\n                            if (balance > 0) {\r\n                                TransferHelper.safeTransfer(betOne.betTokenAddress, _msgSender(), balance);\r\n                            }\r\n                            \r\n                        } else {\r\n                            amountInXIV += balance;\r\n                            lossInXIV += loss;\r\n                        }\r\n                        \r\n                    } else {\r\n                        amountInETH += balance;\r\n                        \r\n                        if (loss > 0) {\r\n                            TransferHelper.safeTransferETH(revokeComissionAddress, loss);\r\n                        }\r\n                        \r\n                    }\r\n                    \r\n                    betTwo.changeClaimedStatus();\r\n                }\r\n                \r\n                emit BetClaimed(_msgSender(), i, block.timestamp, winningAmount);\r\n            }\r\n            \r\n            claimedIndex = (i+1);\r\n        }\r\n        \r\n        users[_msgSender()].lastBetIndex = uint64(claimedIndex);\r\n        \r\n        if (amountInETH > 0) {\r\n            TransferHelper.safeTransferETH(_msgSender(), amountInETH);\r\n        }\r\n            \r\n        if (amountInXIV > 0) {\r\n            TransferHelper.safeTransfer(address(XIV), _msgSender(), amountInXIV);\r\n        }\r\n        \r\n        if (lossInXIV > 0) {\r\n            TransferHelper.safeTransfer(address(XIV), revokeComissionAddress, lossInXIV);\r\n        }\r\n    }\r\n    \r\n    function betPenalty(uint256 betIndex) external nonReentrant {\r\n        require(betCounter[_msgSender()] > betIndex, \"Invalid\");\r\n        BettingLibrary.BettingDetailsOne storage betOne = userBetsOne[_msgSender()][betIndex];\r\n        BettingLibrary.BettingDetailsTwo storage betTwo = userBetsTwo[_msgSender()][betIndex];\r\n        require(!betTwo.isClaimed && uint256(betTwo.endTime) > block.timestamp, \"EndTime\");\r\n        \r\n        uint256 fine;\r\n        uint256 claim;\r\n        uint256 penaltyAmount;\r\n        \r\n        uint256 dayPassed = (block.timestamp - betTwo.startTime) / SECONDS_IN_DAY;\r\n        uint256 planDaysIndex = uint256(betTwo.endTime - betTwo.startTime) / SECONDS_IN_DAY;\r\n        fine = penalty[planDaysIndex][dayPassed];\r\n        \r\n        require(fine <= 100);\r\n        \r\n        penaltyAmount = (fine * uint256(betOne.amount)) / 100;\r\n        claim = (uint256(betOne.amount) - penaltyAmount);\r\n        \r\n        \r\n        if (claim > 0) {\r\n            if (betTwo.isInToken) {\r\n                TransferHelper.safeTransfer(betOne.betTokenAddress, _msgSender(), claim);\r\n            } else {\r\n                TransferHelper.safeTransferETH(_msgSender(), claim);\r\n            }\r\n        }\r\n        \r\n        if (penaltyAmount > 0) {\r\n            if (betTwo.isInToken) {\r\n                TransferHelper.safeTransfer(betOne.betTokenAddress, revokeComissionAddress, penaltyAmount);\r\n            } else {\r\n                TransferHelper.safeTransferETH(revokeComissionAddress, penaltyAmount);\r\n            }\r\n        }\r\n        \r\n        betTwo.isClaimed = true;\r\n        isEligibleForBet[_msgSender()][betOne.coinAddress] = false;\r\n        \r\n        emit UserPenalized(_msgSender(), betIndex, betTwo.isClaimed);\r\n    }\r\n    \r\n    function getBetRewards(address user) public view returns (uint256) {\r\n        uint256 lastIndex = users[user].lastBetIndex;\r\n        \r\n        if (betCounter[user] == 0 || betCounter[user] == lastIndex) {\r\n            return 0;\r\n        }\r\n        \r\n        require(betCounter[user] > lastIndex, \"No new bet\");\r\n        \r\n        uint256 amountInXIV;\r\n        \r\n        for(uint256 i = lastIndex; i < betCounter[user]; i++) {\r\n            BettingLibrary.BettingDetailsOne storage betOne = userBetsOne[user][i];\r\n            BettingLibrary.BettingDetailsTwo storage betTwo = userBetsTwo[user][i];\r\n            \r\n            if (!betTwo.isClaimed && (block.timestamp > betTwo.endTime)) {\r\n                uint256 amount = uint256(betOne.amount);\r\n                uint256 reward = uint256(betTwo.reward);\r\n                \r\n                if((betOne.status == 1)) {\r\n                    if ((betOne.betTokenAddress != address(XIV)) && (betOne.priceInXIV > 0)) {\r\n                        if (betOne.betTokenAddress == address(1)) {\r\n                            amountInXIV += ((amount * uint256(betOne.priceInXIV) * reward) / (10 ** 20));\r\n                        } else {\r\n                            amountInXIV += ((amount * uint256(betOne.priceInXIV) * reward) / (100 * (10 ** (IERC20(betOne.betTokenAddress).decimals()))));\r\n                        }\r\n                    } else {\r\n                        amountInXIV += (amount * reward) / 100;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return amountInXIV;\r\n    }\r\n\r\n    function addCoins(uint _coinType, uint planType, address coinAddress) external onlyOwner typeValidation(_coinType, planType) {\r\n        require(coinAddress != address(0), \"Invalid\");\r\n        require(!coinStatus[coinAddress][_coinType][planType], \"Already added\");\r\n        \r\n        uint counter;\r\n\r\n        if (_coinType == 1) {\r\n            counter =  defiCoinsCounter;\r\n            defiCoinsCounter++;\r\n        } else if (_coinType == 2) {\r\n            counter =  chainCoinsCounter;\r\n            chainCoinsCounter++;\r\n        } else {\r\n            counter =  NFTCoinsCounter;\r\n            NFTCoinsCounter++;\r\n        }\r\n    \r\n        coins[_coinType][planType][counter] = coinAddress;\r\n        coinStatus[coinAddress][_coinType][planType] = true;\r\n        emit Addcoins(_coinType, planType, counter, true, coinAddress);\r\n    }\r\n\r\n    function changeCoinStaus(address coinAddress, uint coinType, uint planType, bool status) external onlyOwner planValidation(coinType, planType) {\r\n        \r\n        if (coinStatus[coinAddress][coinType][planType] != status) {\r\n            coinStatus[coinAddress][coinType][planType] = status;\r\n            emit CoinStatus(coinAddress, coinType, planType, status);\r\n        }\r\n    }\r\n\r\n    function updateOracle(address _oracle) external onlyOwner {\r\n        require(_oracle != address(0));\r\n        oracle = IOracleWrapper(_oracle);\r\n    }\r\n    \r\n    function updateMiniStakeAmount(uint256 _miniStakeAmount ) external onlyOwner {\r\n        miniStakeAmount  = _miniStakeAmount ;\r\n    }\r\n    \r\n    function updateMaxStakeAmount(uint256 _maxStakeAmount ) external onlyOwner amountValidation(_maxStakeAmount) {\r\n        maxStakeAmount  = _maxStakeAmount ;\r\n    }\r\n\r\n    function updateBetFactorLP(uint256 _betFactorLP) external onlyOwner amountValidation(_betFactorLP) {\r\n        betFactorLP = _betFactorLP;\r\n    }\r\n\r\n    function updateMaxBetAmount(uint256 _maxBetAmount) external onlyOwner amountValidation(_maxBetAmount) {\r\n        maxBetAmount = _maxBetAmount;\r\n    }\r\n\r\n    function updateMinBetAmount(uint256 _miniBetAmount) external onlyOwner {\r\n        miniBetAmount = _miniBetAmount;\r\n    }\r\n    \r\n    function setPlanDetails(uint8[4] memory drop, uint16[4] memory reward, uint8[4] memory risk) public onlyOwner {\r\n        require(risk.length > 0 && risk.length == drop.length, \"Invalid\");\r\n        \r\n        for (uint256 i; i < drop.length; i++) {\r\n            plans[i].setPlan(uint256(reward[i]), uint256(risk[i]), uint256(drop[i]));\r\n        }\r\n        \r\n        planCounter = drop.length;\r\n    }\r\n    \r\n    function setReward(uint256 count, uint _reward) external onlyOwner countValidation(count, planCounter) {\r\n        plans[count].setReward(_reward);\r\n    }\r\n    \r\n    function setRisk(uint256 count, uint _risk) external onlyOwner countValidation(count, planCounter) {\r\n        plans[count].setRisk(_risk);\r\n    }\r\n    \r\n    function setDropValue(uint256 count, uint _drop) external onlyOwner countValidation(count, planCounter) {\r\n        plans[count].setDrop(_drop);\r\n    }\r\n    \r\n    function setStatus(uint256 count, bool status) external onlyOwner countValidation(count, planCounter) {\r\n        plans[count].setStatus(status);\r\n    }\r\n    \r\n    function setMultiTokenStatus(bool status) external onlyOwner {\r\n        if (isMultiTokenActive != status) {\r\n            isMultiTokenActive = status;\r\n        }\r\n    }\r\n    \r\n    function setPlanDays(uint256 index, uint256 planDays) external onlyOwner {\r\n        require(index >= 0 && (index <= planDaysCounter));\r\n            \r\n        if ((index == planDaysCounter) && (planDays != 0)) {\r\n            planDaysIndexed[index] = planDays;\r\n            planDaysCounter++;\r\n        } else {\r\n            planDaysIndexed[index] = planDays;\r\n        }\r\n    }\r\n    \r\n    function addPlan(uint256 _reward, uint256 _risk, uint256 _drop, bool status) external onlyOwner {\r\n        uint256 count = planCounter;\r\n        \r\n        PlanLibrary.PlanDetails storage plan = plans[count];\r\n        \r\n        plan.setReward(_reward);\r\n        plan.setRisk(_risk);\r\n        plan.setDrop(_drop);\r\n        plan.setStatus(status);\r\n        planCounter++;\r\n    }\r\n\r\n    function checkCoinStatus(address _coin, uint256 _coinType, uint256 _planType) external view returns (bool) {\r\n        return coinStatus[_coin][_coinType][_planType];\r\n    }\r\n    \r\n    function setBufferTime(uint256 time) public onlyOwner {\r\n        bufferTime = time;\r\n    }\r\n    \r\n    function setPenalty(uint256 value, uint256 _days, uint256 planDaysIndex) external onlyOwner {\r\n        require(value >= 0 && value <= 100);\r\n        require(_days >= 0 && _days < planDaysIndex);\r\n        \r\n        penalty[planDaysIndex][_days] = value;\r\n        \r\n    }\r\n    \r\n    function setRevokeComissionAddress(address newAddress) external onlyOwner {\r\n        require(newAddress != address(0));\r\n        revokeComissionAddress = newAddress;\r\n    }\r\n    \r\n    function setMaxWalks(uint256 value) external onlyOwner amountValidation(value) {\r\n        maxWalks = value;\r\n    }\r\n    \r\n    function setBetFees(uint256 fees) external onlyOwner {\r\n        require(fees >= 0 && fees <= 100);\r\n        betFees = fees;\r\n    }\r\n    \r\n    function setThreshold(uint256 value) external onlyOwner amountValidation(value) {\r\n        threshold = value;\r\n    }\r\n    \r\n    function getPriceInXIV(address betToken) public view returns (uint256 priceInXIV) {\r\n        if (betToken == address(XIV)) {\r\n            return priceInXIV = 1;\r\n        }\r\n        return priceInXIV = ((oracle.getPrice(betToken, address(usdt)) * (10 ** 18)) / oracle.getPrice(address(XIV), address(usdt)));\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"}],\"name\":\"Addcoins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeOfClaim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningAmount\",\"type\":\"uint256\"}],\"name\":\"BetClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"BetResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"CoinStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"IndexCoinStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typeOfLP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LPEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"betCoin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"NewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"}],\"name\":\"UserPenalized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFTCoinsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"XIV\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulatedXIV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coinType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"}],\"name\":\"addCoins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_risk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_drop\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"addPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"amountToUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"betCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betFactorLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"betToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isInverse\",\"type\":\"bool\"}],\"name\":\"betFixed\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"betToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daysIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isInverse\",\"type\":\"bool\"}],\"name\":\"betFlexible\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"betPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bufferTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainCoinsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeCoinStaus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_coinType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_planType\",\"type\":\"uint256\"}],\"name\":\"checkCoinStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coinStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coins\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiCoinsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBetRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"betToken\",\"type\":\"address\"}],\"name\":\"getPriceInXIV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceInXIV\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_XIVAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_revokeComissionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_miniStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betFactorLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_miniBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isEligibleForBet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMultiTokenActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miniBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miniStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracleWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"penalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"planCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"planDaysCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"planDaysIndexed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"risk\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"reward\",\"type\":\"uint64\"},{\"internalType\":\"uint120\",\"name\":\"drop\",\"type\":\"uint120\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"index\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"timeCheck\",\"type\":\"bool\"}],\"name\":\"resolveBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeComissionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"setBetFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setBufferTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_drop\",\"type\":\"uint256\"}],\"name\":\"setDropValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxWalks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setMultiTokenStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planDaysIndex\",\"type\":\"uint256\"}],\"name\":\"setPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planDays\",\"type\":\"uint256\"}],\"name\":\"setPlanDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[4]\",\"name\":\"drop\",\"type\":\"uint8[4]\"},{\"internalType\":\"uint16[4]\",\"name\":\"reward\",\"type\":\"uint16[4]\"},{\"internalType\":\"uint8[4]\",\"name\":\"risk\",\"type\":\"uint8[4]\"}],\"name\":\"setPlanDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setRevokeComissionAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_risk\",\"type\":\"uint256\"}],\"name\":\"setRisk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeDetails\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"lastStakedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amountUnstaked\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"stakeResidual\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"profit\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"losses\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastStakedTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastClaimedBet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"stakeCounter\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastUnstakeIndex\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakerIncentiveCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakerRewards\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"betEndStake\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"stakingReward\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"betEndTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"status\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"stakingTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"stakedAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betFactorLP\",\"type\":\"uint256\"}],\"name\":\"updateBetFactorLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBetAmount\",\"type\":\"uint256\"}],\"name\":\"updateMaxBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"updateMaxStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_miniBetAmount\",\"type\":\"uint256\"}],\"name\":\"updateMinBetAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_miniStakeAmount\",\"type\":\"uint256\"}],\"name\":\"updateMiniStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"updateOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userBetsOne\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint120\",\"name\":\"status\",\"type\":\"uint120\"},{\"internalType\":\"bool\",\"name\":\"isInverse\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"initialPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"priceInXIV\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"betTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coinAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userBetsTwo\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"reward\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"risk\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"dropValue\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"planType\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isInToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBetIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"InverseV0","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://169059df3bb81db12599c306d1408a07128b912c77e2cb8bf9241df2c16bef53"}]}