{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenXDrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ninterface ERC20Mint {\\n    function mint(address to, uint256 amount) external;\\n}\\n\\ncontract Drop {\\n    using MerkleProof for bytes;\\n\\n    event DropClaimed(\\n        address indexed tokenAddress,\\n        uint256 index,\\n        address indexed account,\\n        uint256 amount,\\n        bytes32 indexed merkleRoot\\n    );\\n\\n    struct DropData {\\n        uint256 startDate;\\n        uint256 endDate;\\n        uint256 tokenAmount;\\n        address owner;\\n        bool isActive;\\n    }\\n\\n    mapping(uint256 => uint256) private claimedBitMap;\\n    DropData public dropData;\\n    bytes32 public merkleRoot;\\n    address public token;\\n    address public multisig;\\n\\n    constructor(\\n        bytes32 _merkleRoot,\\n        uint256 _startDate,\\n        uint256 _endDate,\\n        uint256 _tokenAmount,\\n        address _tokenAddress,\\n        address _multisig\\n    ) {\\n        token = _tokenAddress;\\n        merkleRoot = _merkleRoot;\\n        dropData = DropData(_startDate, _endDate, _tokenAmount, msg.sender, true);\\n        multisig = _multisig;\\n    }\\n\\n    function withdrawUnclaimed() external {\\n        require(block.timestamp > dropData.endDate, \\\"NOT_FINISHED\\\");\\n        ERC20Mint(token).mint(multisig, dropData.tokenAmount);\\n    }\\n\\n    function claimFromDrop(\\n        address, /*tokenAddress*/\\n        uint256 index,\\n        uint256 amount,\\n        bytes32, /*merkleRoot*/\\n        bytes32[] calldata merkleProof\\n    ) external {\\n        bytes32 _merkleRoot = merkleRoot;\\n        address account = msg.sender;\\n\\n        claim(index, account, amount, _merkleRoot, merkleProof);\\n\\n        emit DropClaimed(token, index, account, amount, _merkleRoot);\\n    }\\n\\n    function multipleClaimsFromDrop(\\n        address, /*tokenAddress*/\\n        uint256[] calldata indexes,\\n        uint256[] calldata amounts,\\n        bytes32[] calldata, /*merkleRoots*/\\n        bytes32[][] calldata merkleProofs\\n    ) external {\\n        address account = msg.sender;\\n        bytes32 _merkleRoot = merkleRoot;\\n        address _token = token;\\n\\n        for (uint256 i = 0; i < indexes.length; i++) {\\n            claim(indexes[i], account, amounts[i], _merkleRoot, merkleProofs[i]);\\n\\n            emit DropClaimed(_token, indexes[i], account, amounts[i], _merkleRoot);\\n        }\\n    }\\n\\n    function claim(\\n        uint256 index,\\n        address account,\\n        uint256 amount,\\n        bytes32 _merkleRoot,\\n        bytes32[] calldata merkleProof\\n    ) internal {\\n        DropData memory dd = dropData;\\n\\n        require(dd.startDate < block.timestamp, \\\"DROP_NOT_STARTED\\\");\\n        require(dd.endDate > block.timestamp, \\\"DROP_ENDED\\\");\\n        require(dd.isActive, \\\"DROP_NOT_ACTIVE\\\");\\n        require(!isClaimed(index), \\\"DROP_ALREADY_CLAIMED\\\");\\n\\n        // Verify the merkle proof.\\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\\n        require(MerkleProof.verify(merkleProof, _merkleRoot, node), \\\"DROP_INVALID_PROOF\\\");\\n\\n        // Subtract from the drop amount\\n        dropData.tokenAmount -= amount;\\n\\n        // Mark it claimed and send the tokens.\\n        _setClaimed(index);\\n        ERC20Mint(token).mint(account, amount);\\n    }\\n\\n    function isClaimed(uint256 index) public view returns (bool) {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    function pause() external {\\n        require(dropData.owner == msg.sender, \\\"NOT_OWNER\\\");\\n        dropData.isActive = false;\\n    }\\n\\n    function unpause() external {\\n        require(dropData.owner == msg.sender, \\\"NOT_OWNER\\\");\\n        dropData.isActive = true;\\n    }\\n\\n    function _setClaimed(uint256 index) private {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_multisig\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"DropClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimFromDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"merkleProofs\",\"type\":\"bytes32[][]\"}],\"name\":\"multipleClaimsFromDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUnclaimed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Drop","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"d234e1762fa243c0b38d9db63afe64f675d674f8de21ea8cb9520413af5e14b40000000000000000000000000000000000000000000000000000000061672cb0000000000000000000000000000000000000000000000000000000006190518000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000a396dac0babc6126dffd48b331495a13d31ba8a30000000000000000000000005089722613c2ccee071c39c59e9889641f435f15","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}