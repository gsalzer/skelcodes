{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DeTrust.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.0;\\n\\nimport \\\"./interfaces/IDeTrust.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\ncontract DeTrust is IDeTrust, Initializable {\\n\\n    uint private trustId;\\n\\n    /*\\n      Paid directly would be here.\\n    */\\n    mapping(address => uint) private settlorBalance;\\n\\n    mapping(uint => Trust) private trusts;\\n\\n    mapping(address => uint[]) private settlorToTrustIds;\\n\\n    mapping(address => uint[]) private beneficiaryToTrustIds;\\n\\n\\n    uint private unlocked;\\n\\n    modifier lock() {\\n        require(unlocked == 1, 'Trust: LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    /**\\n     * constructor replaced by initialize with timelock upgrade\\n     */\\n    function initialize() external initializer {\\n        unlocked = 1;\\n    }\\n\\n    /**\\n     * If ppl send the ether to this contract directly\\n     */\\n    receive() external payable {\\n        require(msg.value > 0, \\\"msg.value is 0\\\");\\n        settlorBalance[msg.sender] += msg.value;\\n    }\\n\\n    function getBalance(address account)\\n        external\\n        view\\n        override\\n        returns (uint balance)\\n    {\\n        return settlorBalance[account];\\n    }\\n\\n    function sendBalanceTo(address to, uint amount) external override {\\n        address settlor = msg.sender;\\n        uint balance = settlorBalance[settlor];\\n        require(balance >= amount, \\\"balance insufficient\\\");\\n        settlorBalance[settlor] -= amount;\\n        require(payable(to).send(amount), \\\"send balance failed\\\");\\n    }\\n\\n    function getTrustListAsBeneficiary(address account)\\n        external\\n        view\\n        override\\n        returns (Trust[] memory)\\n    {\\n        uint[] memory trustIds = beneficiaryToTrustIds[account];\\n        uint length = trustIds.length;\\n        Trust[] memory trustsAsBeneficiary = new Trust[](length);\\n        for (uint i = 0; i < length; i++) {\\n            Trust storage t = trusts[trustIds[i]];\\n            trustsAsBeneficiary[i] = t;\\n        }\\n        return trustsAsBeneficiary;\\n    }\\n\\n    function getTrustListAsSettlor(address account)\\n        external\\n        view\\n        override\\n        returns (Trust[] memory)\\n    {\\n        uint[] memory trustIds = settlorToTrustIds[account];\\n        uint length = trustIds.length;\\n        Trust[] memory trustsAsSettlor = new Trust[](length);\\n        for (uint i = 0; i < length; i++) {\\n            Trust storage t = trusts[trustIds[i]];\\n            trustsAsSettlor[i] = t;\\n        }\\n        return trustsAsSettlor;\\n    }\\n\\n    function addTrustFromBalance(\\n        string memory name,\\n        address beneficiary,\\n        uint startReleaseTime,\\n        uint timeInterval,\\n        uint amountPerTimeInterval,\\n        uint totalAmount,\\n        bool revocable\\n    )\\n        external\\n        override\\n        lock\\n        returns (uint tId)\\n    {\\n        address settlor = msg.sender;\\n        uint balance = settlorBalance[settlor];\\n        require(balance >= totalAmount, \\\"balance insufficient\\\");\\n\\n        settlorBalance[settlor] -= totalAmount;\\n\\n        return _addTrust(\\n            name,\\n            beneficiary,\\n            settlor,\\n            startReleaseTime,\\n            timeInterval,\\n            amountPerTimeInterval,\\n            totalAmount,\\n            revocable\\n        );\\n    }\\n\\n    function addTrust(\\n        string memory name,\\n        address beneficiary,\\n        uint startReleaseTime,\\n        uint timeInterval,\\n        uint amountPerTimeInterval,\\n        bool revocable\\n    )\\n        external\\n        payable\\n        override\\n        lock returns (uint tId)\\n    {\\n        uint totalAmount = msg.value;\\n        require(totalAmount > 0, \\\"msg.value is 0\\\");\\n\\n        return _addTrust(\\n            name,\\n            beneficiary,\\n            msg.sender,\\n            startReleaseTime,\\n            timeInterval,\\n            amountPerTimeInterval,\\n            totalAmount,\\n            revocable\\n        );\\n    }\\n\\n    function setIrrevocable(uint tId) external override lock {\\n        Trust storage t = trusts[tId];\\n        uint totalAmount = t.totalAmount;\\n        require(totalAmount > 0, \\\"trust not found\\\");\\n        require(t.settlor == msg.sender, \\\"settlor error\\\");\\n        if (!t.revocable) {\\n            return;\\n        }\\n        t.revocable = false;\\n    }\\n\\n    function revoke(uint tId) external override lock {\\n        Trust storage t = trusts[tId];\\n        uint totalAmount = t.totalAmount;\\n        require(totalAmount > 0, \\\"trust not found\\\");\\n        require(t.settlor == msg.sender, \\\"settlor error\\\");\\n        require(t.revocable, \\\"trust irrevocable\\\");\\n        _deleteTrust(tId, t.beneficiary, t.settlor);\\n\\n        require(payable(msg.sender).send(totalAmount), \\\"revoke failed\\\");\\n        emit TrustRevoked(tId);\\n    }\\n\\n    function topUp(uint tId) external payable override lock {\\n        uint amount = msg.value;\\n        require(amount > 0, \\\"msg.value is 0\\\");\\n        Trust storage t = trusts[tId];\\n        require(t.totalAmount > 0, \\\"trust not found\\\");\\n        t.totalAmount += amount;\\n        emit TrustFundAdded(tId, amount);\\n    }\\n\\n    function topUpFromBalance(uint tId, uint amount) external override lock {\\n        address settlor = msg.sender;\\n        uint balance = settlorBalance[settlor];\\n        require(balance >= amount, \\\"balance insufficient\\\");\\n        settlorBalance[settlor] -= amount;\\n        Trust storage t = trusts[tId];\\n        require(t.totalAmount > 0, \\\"trust not found\\\");\\n        t.totalAmount += amount;\\n        emit TrustFundAdded(tId, amount);\\n    }\\n\\n    function release(uint tId) external override lock {\\n        address beneficiary = msg.sender;\\n        _release(tId, beneficiary, beneficiary);\\n    }\\n\\n    function releaseTo(uint tId, address to) external override lock {\\n        _release(tId, msg.sender, to);\\n    }\\n\\n    function releaseAll() external override lock {\\n        address beneficiary = msg.sender;\\n        _releaseAll(beneficiary, beneficiary);\\n    }\\n\\n    function releaseAllTo(address to) external override lock {\\n        _releaseAll(msg.sender, to);\\n    }\\n\\n    // internal functions\\n\\n    function _release(uint tId, address beneficiary, address to) internal {\\n        Trust storage t = trusts[tId];\\n        require(t.totalAmount > 0, \\\"trust not found\\\");\\n        require(t.beneficiary == beneficiary, \\\"beneficiary error\\\");\\n        uint releaseAmount = _releaseTrust(t);\\n        if (releaseAmount == 0) {\\n            revert(\\\"nothing to release\\\");\\n        }\\n        bool isDeleted = (t.totalAmount == 0);\\n        if (isDeleted) {\\n            _deleteTrust(tId, t.beneficiary, t.settlor);\\n            emit TrustFinished(tId);\\n        }\\n        require(payable(to).send(releaseAmount), \\\"release failed\\\");\\n        emit Release(beneficiary, releaseAmount);\\n    }\\n\\n    function _releaseAll(address beneficiary, address to) internal {\\n        uint[] storage trustIds = beneficiaryToTrustIds[beneficiary];\\n        require(trustIds.length > 0, \\\"nothing to release\\\");\\n        uint i;\\n        uint j;\\n        uint totalReleaseAmount;\\n        uint tId;\\n        bool isDeleted;\\n        uint length = trustIds.length;\\n        for (i = 0; i < length && trustIds.length > 0; i++) {\\n            tId = trustIds[j];\\n            Trust storage t = trusts[tId];\\n            uint releaseAmount = _releaseTrust(t);\\n            if (releaseAmount != 0) {\\n                totalReleaseAmount += releaseAmount;\\n            }\\n            isDeleted = (t.totalAmount == 0);\\n            if (isDeleted) {\\n                _deleteTrust(tId, t.beneficiary, t.settlor);\\n                emit TrustFinished(tId);\\n            } else {\\n                j++;\\n            }\\n        }\\n        if (totalReleaseAmount == 0) {\\n            revert(\\\"nothing to release\\\");\\n        }\\n\\n        require(payable(to).send(totalReleaseAmount), \\\"release failed\\\");\\n        emit Release(beneficiary, totalReleaseAmount);\\n    }\\n\\n    function _deleteTrust(uint tId, address beneficiary, address settlor) internal {\\n        delete trusts[tId];\\n        uint[] storage trustIds = beneficiaryToTrustIds[beneficiary];\\n        if (trustIds.length == 1) {\\n            trustIds.pop();\\n        } else {\\n            uint i;\\n            for (i = 0; i < trustIds.length; i++) {\\n                if (trustIds[i] == tId) {\\n                    if (i != trustIds.length - 1) {\\n                        trustIds[i] = trustIds[trustIds.length - 1];\\n                    }\\n                    trustIds.pop();\\n                }\\n            }\\n        }\\n        uint[] storage settlorTIds = settlorToTrustIds[settlor];\\n        if (settlorTIds.length == 1) {\\n            settlorTIds.pop();\\n            return;\\n        }\\n        uint k;\\n        for (k = 0; k < settlorTIds.length; k++) {\\n            if (settlorTIds[k] == tId) {\\n                if (k != settlorTIds.length - 1) {\\n                    settlorTIds[k] = settlorTIds[settlorTIds.length - 1];\\n                }\\n                settlorTIds.pop();\\n            }\\n        }\\n    }\\n\\n    function _addTrust(\\n        string memory name,\\n        address beneficiary,\\n        address settlor,\\n        uint startReleaseTime,\\n        uint timeInterval,\\n        uint amountPerTimeInterval,\\n        uint totalAmount,\\n        bool revocable\\n    )\\n        internal\\n        returns (uint _id)\\n    {\\n        require(timeInterval != 0, \\\"timeInterval should be positive\\\");\\n        _id = ++trustId;\\n        trusts[_id].id = _id;\\n        trusts[_id].name = name;\\n        trusts[_id].settlor = settlor;\\n        trusts[_id].beneficiary = beneficiary;\\n        trusts[_id].nextReleaseTime = startReleaseTime;\\n        trusts[_id].timeInterval = timeInterval;\\n        trusts[_id].amountPerTimeInterval = amountPerTimeInterval;\\n        trusts[_id].totalAmount = totalAmount;\\n        trusts[_id].revocable = revocable;\\n\\n        settlorToTrustIds[settlor].push(_id);\\n        beneficiaryToTrustIds[beneficiary].push(_id);\\n\\n        emit TrustAdded(\\n            name,\\n            settlor,\\n            beneficiary,\\n            _id,\\n            startReleaseTime,\\n            timeInterval,\\n            amountPerTimeInterval,\\n            totalAmount,\\n            revocable\\n        );\\n\\n        return _id;\\n    }\\n\\n    function _releaseTrust(Trust storage t) internal returns (uint) {\\n        uint nowTimestamp = block.timestamp;\\n        if (t.nextReleaseTime > nowTimestamp) {\\n            return 0;\\n        }\\n        uint distributionAmount = (nowTimestamp - t.nextReleaseTime) / t.timeInterval + 1;\\n        uint releaseAmount = distributionAmount * t.amountPerTimeInterval;\\n        if (releaseAmount >= t.totalAmount) {\\n            releaseAmount = t.totalAmount;\\n            t.totalAmount = 0;\\n        } else {\\n            t.totalAmount -= releaseAmount;\\n            t.nextReleaseTime += distributionAmount * t.timeInterval;\\n        }\\n        emit TrustReleased(t.id, t.beneficiary, releaseAmount, t.nextReleaseTime);\\n        return releaseAmount;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDeTrust.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.0;\\n\\ninterface IDeTrust {\\n\\n    struct Trust {\\n        uint id;  // the id of the trust\\n        string name;  // the name of the trust, like 'trust for Bob's son'\\n        address settlor;  // the settlor of the trust\\n        address beneficiary;  // the beneficiary of the trust, such as Bob's son\\n        uint nextReleaseTime;  // when would the money begin to release to beneficiary\\n        uint timeInterval;  // how often the money is going to release to beneficiary\\n        uint amountPerTimeInterval;  // how much can a beneficiary to get the money\\n        uint totalAmount;  // total money in this trust\\n        bool revocable;  // is this trust revocable or irrevocable\\n    }\\n\\n    /*\\n     * Event that a new trust is added\\n     *\\n     * @param name the name of the trust\\n     * @param settlor the settlor address of the trust\\n     * @param beneficiary the beneficiary address of the trust\\n     * @param trustId the trustId of the trust\\n     * @param startReleaseTime will this trust start to release money, UTC in seconds\\n     * @param timeInterval how often can a beneficiary to get the money in seconds\\n     * @param amountPerTimeInterval how much can a beneficiary to get the money\\n     * @param totalAmount how much money are put in the trust\\n     * @param revocable whether this trust is revocalbe\\n     */\\n    event TrustAdded(\\n        string name,\\n        address indexed settlor,\\n        address indexed beneficiary,\\n        uint indexed trustId,\\n        uint startReleaseTime,\\n        uint timeInterval,\\n        uint amountPerTimeInterval,\\n        uint totalAmount,\\n        bool revocable\\n    );\\n\\n    /*\\n     * Event that new fund are added into a existing trust\\n     *\\n     * @param trustId the trustId of the trust\\n     * @param amount how much money are added into the trust\\n     */\\n    event TrustFundAdded(uint indexed trustId, uint amount);\\n\\n    /*\\n     * Event that a trust is finished\\n     *\\n     * @param trustId the trustId of the trust\\n     */\\n    event TrustFinished(uint indexed trustId);\\n\\n    /*\\n     * Event that a trust is releaseed\\n     *\\n     * @param trustId the trustId of the trust\\n     */\\n    event TrustReleased(\\n        uint indexed trustId,\\n        address indexed beneficiary,\\n        uint amount,\\n        uint nextReleaseTime\\n    );\\n\\n    /*\\n     * Event that a trust is revoked\\n     *\\n     * @param trustId the trustId of the trust\\n     */\\n    event TrustRevoked(uint indexed trustId);\\n\\n    /*\\n     * Event that beneficiary get some money from the contract\\n     *\\n     * @param beneficiary the address of beneficiary\\n     * @param totalAmount how much the beneficiary released from this contract\\n     */\\n    event Release(address indexed beneficiary, uint totalAmount);\\n\\n    /*\\n     * Get the balance in this contract, which is not send to any trust\\n     * @return the balance of the settlor in this contract\\n     *\\n     */\\n    function getBalance(address account) external view returns (uint balance);\\n\\n    /*\\n     * If money is send to this contract by accident, can use this\\n     * function to get money back ASAP.\\n     *\\n     * @param to the address money would send to\\n     * @param amount how much money are added into the trust\\n     */\\n    function sendBalanceTo(address to, uint amount) external;\\n\\n    /*\\n     * Get beneficiary's all trusts\\n     *\\n     * @return array of trusts which's beneficiary is the tx.orgigin\\n     */\\n    function getTrustListAsBeneficiary(address account)\\n        external\\n        view\\n        returns(Trust[] memory);\\n\\n\\n    /*\\n     * Get settlor's all trusts\\n     *\\n     * @return array of trusts which's settlor is the tx.orgigin\\n     */\\n    function getTrustListAsSettlor(address account)\\n        external\\n        view\\n        returns(Trust[] memory);\\n\\n    /*\\n     * Add a new trust from settlor's balance in this contract.\\n     *\\n     * @param name the trust's name\\n     * @param beneficiary the beneficiary's address to receive the trust fund\\n     * @param startReleaseTime the start time beneficiary can start to get money,\\n                               UTC seconds\\n     * @param timeInterval how often the beneficiary can get money\\n     * @param amountPerTimeInterval how much money can beneficiary get after one timeInterval\\n     * @param totalAmount how much money is added to the trust\\n     * @param revocable whether this trust is revocable\\n     */\\n    function addTrustFromBalance(\\n        string memory name,\\n        address beneficiary,\\n        uint startReleaseTime,\\n        uint timeInterval,\\n        uint amountPerTimeInterval,\\n        uint totalAmount,\\n        bool revocable\\n    )\\n        external\\n        returns (uint trustId);\\n\\n    /*\\n     * Add a new trust by pay\\n     *\\n     * @param name the trust's name\\n     * @param beneficiary the beneficiary's address to receive the trust fund\\n     * @param startReleaseTime the start time beneficiary can start to get money,\\n                               UTC seconds\\n     * @param timeInterval how often the beneficiary can get money\\n     * @param amountPerTimeInterval how much money can beneficiary get after one timeInterval\\n     * @param revocable whether this trust is revocalbe\\n     */\\n    function addTrust(\\n        string memory name,\\n        address beneficiary,\\n        uint startReleaseTime,\\n        uint timeInterval,\\n        uint amountPerTimeInterval,\\n        bool revocable\\n    )\\n        external\\n        payable\\n        returns (uint trustId);\\n\\n    /*\\n     * Set trust to irrevocable\\n     *\\n     * @param trustId the trustId settlor want to set irrevocable\\n     */\\n    function setIrrevocable(uint trustId) external;\\n\\n    /*\\n     * Revoke a trust, withdraw all the money out\\n     *\\n     * @param trustId the trustId settlor want to top up\\n     */\\n    function revoke(uint trustId) external;\\n\\n    /*\\n     * Top up a trust by payment\\n     * @param trustId the trustId settlor want to top up\\n     */\\n    function topUp(uint trustId) external payable;\\n\\n    /*\\n     * Top up from balance to a trust by trustId\\n     *\\n     * @param trustId the trustId settlor want add to top up\\n     * @param amount the amount of money settlor want to top up\\n     */\\n    function topUpFromBalance(uint trustId, uint amount) external;\\n\\n    /*\\n     * Beneficiary release one trust asset by this function\\n     *\\n     * @param trustId the trustId beneficiary want to release\\n     *\\n     */\\n    function release(uint trustId) external;\\n\\n    /*\\n     * Beneficiary release one trust asset by this function\\n     *\\n     * @param trustId the trustId beneficiary want to release\\n     * @param to the address beneficiary want to release to\\n     *\\n     */\\n    function releaseTo(uint trustId, address to) external;\\n\\n    /*\\n     * Beneficiary get token by this function, release all the\\n     * trust releaeable assets in the contract\\n     */\\n    function releaseAll() external;\\n\\n    /*\\n     * Beneficiary get token by this function, release all the\\n     * trust releaeable assets in the contract\\n     *\\n     * @param to the address beneficiary want to release to\\n     */\\n    function releaseAllTo(address to) external;\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"settlor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"trustId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startReleaseTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPerTimeInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"}],\"name\":\"TrustAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"trustId\",\"type\":\"uint256\"}],\"name\":\"TrustFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"trustId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TrustFundAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"trustId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextReleaseTime\",\"type\":\"uint256\"}],\"name\":\"TrustReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"trustId\",\"type\":\"uint256\"}],\"name\":\"TrustRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerTimeInterval\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"}],\"name\":\"addTrust\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerTimeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"}],\"name\":\"addTrustFromBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTrustListAsBeneficiary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"settlor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nextReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerTimeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"}],\"internalType\":\"struct IDeTrust.Trust[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTrustListAsSettlor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"settlor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nextReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerTimeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"revocable\",\"type\":\"bool\"}],\"internalType\":\"struct IDeTrust.Trust[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"releaseAllTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"releaseTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendBalanceTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"}],\"name\":\"setIrrevocable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"}],\"name\":\"topUp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"topUpFromBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DeTrust","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"50","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}