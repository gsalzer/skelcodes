{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/// @title ERC-165 Standard Interface Detection\r\n/// @dev Reference https://eips.ethereum.org/EIPS/eip-165\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev Reference https://eips.ethereum.org/EIPS/eip-721\r\ninterface ERC721 /* is ERC165 */ {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    function name() external pure returns (string _name);\r\n    function symbol() external pure returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/// @title A reusable contract to comply with ERC-165\r\n/// @author William Entriken (https://phor.net)\r\ncontract SupportsInterface is ERC165 {\r\n    /// @dev Every interface that we support, do not set 0xffffffff to true\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    constructor() internal {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n    }\r\n\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\r\n    }\r\n}\r\n\r\n/// @title Compliance with ERC-721 for Su Squares\r\n/// @dev This implementation assumes:\r\n///  - A fixed supply of NFTs, cannot mint or burn\r\n///  - ids are numbered sequentially starting at 1.\r\n///  - NFTs are initially assigned to this contract\r\n///  - This contract does not externally call its own functions\r\n/// @author William Entriken (https://phor.net)\r\ncontract CryptoStarsNFTs is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, SupportsInterface {\r\n    /// @dev The authorized address for each NFT\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    /// @dev The authorized operators for each address\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    /// @dev Guarantees msg.sender is the owner of _tokenId\r\n    /// @param _tokenId The token to validate belongs to msg.sender\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // assert(msg.sender != address(this))\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier mustBeOwnedByThisContract(uint256 _tokenId) {\r\n        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        require(owner == address(0) || owner == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier canOperate(uint256 _tokenId) {\r\n        // assert(msg.sender != address(this))\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        require(msg.sender == owner || operatorApprovals[owner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        // assert(msg.sender != address(this))\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        require(msg.sender == owner ||\r\n          msg.sender == tokenApprovals[_tokenId] ||\r\n          operatorApprovals[owner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier mustBeValidToken(uint256 _tokenId) {\r\n        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\r\n        _;\r\n    }\r\n\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return _tokensOfOwnerWithSubstitutions[_owner].length;\r\n    }\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        mustBeValidToken(_tokenId)\r\n        returns (address _owner)\r\n    {\r\n        _owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Do owner address substitution\r\n        if (_owner == address(0)) {\r\n            _owner = address(this);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable\r\n    {\r\n        _safeTransferFrom(_from, _to, _tokenId, data);\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable\r\n    {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        payable\r\n        mustBeValidToken(_tokenId)\r\n        canTransfer(_tokenId)\r\n    {\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Do owner address substitution\r\n        if (owner == address(0)) {\r\n            owner = address(this);\r\n        }\r\n        require(owner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_tokenId, _to);\r\n    }\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId)\r\n        external\r\n        payable\r\n        // assert(mustBeValidToken(_tokenId))\r\n        canOperate(_tokenId)\r\n    {\r\n        address _owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Do owner address substitution\r\n        if (_owner == address(0)) {\r\n            _owner = address(this);\r\n        }\r\n        tokenApprovals[_tokenId] = _approved;\r\n        emit Approval(_owner, _approved, _tokenId);\r\n    }\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to\r\n    ///  manage all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        operatorApprovals[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        mustBeValidToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    // COMPLIANCE WITH ERC721Metadata //////////////////////////////////////////\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string) {\r\n        return \"Crypto Stars\";\r\n    }\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string) {\r\n        return \"CSTARS\";\r\n    }\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId)\r\n        external\r\n        view\r\n        mustBeValidToken(_tokenId)\r\n        returns (string _tokenURI)\r\n    {\r\n\r\n        _tokenURI = \"ipfs://QmcAmuwE6n2YGrbjgfRe2pJCmPd1RcBEhr55TmDznhgPv9/cryptostar0000.json\";\r\n        bytes memory _tokenURIBytes = bytes(_tokenURI);\r\n        _tokenURIBytes[64] = bytes1(uint8(48+(_tokenId / 1000) % 10));\r\n        _tokenURIBytes[65] = bytes1(uint8(48+(_tokenId / 100) % 10));\r\n        _tokenURIBytes[66] = bytes1(uint8(48+(_tokenId / 10) % 10));\r\n        _tokenURIBytes[67] = bytes1(uint8(48+(_tokenId / 1) % 10));\r\n\r\n    }\r\n\r\n    // COMPLIANCE WITH ERC721Enumerable ////////////////////////////////////////\r\n\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one\r\n    ///  has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256) {\r\n        return TOTAL_SUPPLY;\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < TOTAL_SUPPLY);\r\n        return _index + 1;\r\n    }\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\r\n        require(_owner != address(0));\r\n        require(_index < _tokensOfOwnerWithSubstitutions[_owner].length);\r\n        _tokenId = _tokensOfOwnerWithSubstitutions[_owner][_index];\r\n        // Handle substitutions\r\n        if (_owner == address(this)) {\r\n            if (_tokenId == 0) {\r\n                _tokenId = _index + 1;\r\n            }\r\n        }\r\n    }\r\n\r\n/*    function available(uint8 needed) public view returns (uint8) {\r\n        uint8 count=0;\r\n        for (uint8 t=1;t<1002;t++) {\r\n            if (_tokenOwnerWithSubstitutions[t] == address(0))\r\n             count++;\r\n        //    if (count>=needed)\r\n        //    {\r\n        //        return count;\r\n            //    break;\r\n           // }    \r\n        }\r\n        return count;\r\n    } */\r\n\r\n    function starsAvailable() public view returns (uint256) {\r\n        return _tokensOfOwnerWithSubstitutions[address(this)].length;\r\n    }\r\n\r\n\r\n    function buyCryptoStars(uint256 count) external payable {\r\n        require(msg.value >= count*0.001 ether);\r\n        require(starsAvailable()>=count);\r\n// function id\t\t\t\"buyCryptoStars(uint16)\": \"d29b13b1\",\r\n        uint256 claimed=0;\r\n        uint256 tokenid;\r\n        do {\r\n            tokenid=uint(keccak256(abi.encodePacked(block.timestamp*(tokenid+1)*(claimed+1), block.difficulty))) % 1001+1;\r\n            while (_tokenOwnerWithSubstitutions[tokenid] != address(0)) {\r\n              tokenid++;\r\n              if (tokenid==1002) tokenid=1;\r\n            }  \r\n            _transfer(tokenid, msg.sender);\r\n            claimed++;\r\n        } while (claimed<count);        \r\n    \r\n    }\r\n\r\n    function giftCryptoStars(uint256 count, address friend) internal {\r\n        uint256 claimed=0;\r\n        uint256 tokenid;\r\n        do {\r\n            tokenid=uint256(keccak256(abi.encodePacked(block.timestamp*(tokenid+1)*(claimed+1), block.difficulty))) % 1001+1;\r\n            while (_tokenOwnerWithSubstitutions[tokenid] != address(0)) {\r\n              tokenid++;\r\n              if (tokenid==1002) tokenid=1;\r\n            }  \r\n            _transfer(tokenid, friend);\r\n            claimed++;\r\n        } while (claimed<count);        \r\n    }\r\n\r\n    // INTERNAL INTERFACE //////////////////////////////////////////////////////\r\n\r\n    /// @dev Actually do a transfer, does NO precondition checking\r\n    function _transfer(uint256 _tokenId, address _to) internal {\r\n        // Here are the preconditions we are not checking:\r\n        // assert(canTransfer(_tokenId))\r\n        // assert(mustBeValidToken(_tokenId))\r\n        require(_to != address(0));\r\n\r\n        // Find the FROM address\r\n        address from = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Do owner address substitution\r\n        if (from == address(0)) {\r\n            from = address(this);\r\n        }\r\n\r\n        // Take away from the FROM address\r\n        // The Entriken algorithm for deleting from an indexed, unsorted array\r\n        uint256 indexToDelete = _ownedTokensIndexWithSubstitutions[_tokenId];\r\n        // Do owned tokens substitution\r\n        if (indexToDelete == 0) {\r\n            indexToDelete = _tokenId - 1;\r\n        } else {\r\n            indexToDelete = indexToDelete - 1;\r\n        }\r\n        // We can only shrink an array from its end. If the item we want to\r\n        // delete is in the middle then copy last item to middle and shrink\r\n        // the end.\r\n        if (indexToDelete != _tokensOfOwnerWithSubstitutions[from].length - 1) {\r\n            uint256 lastNft = _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1];\r\n            // Do tokens of owner substitution\r\n            if (lastNft == 0) {\r\n                // assert(from ==  address(0) || from == address(this));\r\n                lastNft = _tokensOfOwnerWithSubstitutions[from].length; // - 1 + 1\r\n            }\r\n            _tokensOfOwnerWithSubstitutions[from][indexToDelete] = lastNft;\r\n            _ownedTokensIndexWithSubstitutions[lastNft] = indexToDelete + 1;\r\n        }\r\n        // Next line also deletes the contents at the last position of the array (gas refund)\r\n        _tokensOfOwnerWithSubstitutions[from].length--;\r\n        // Right now _ownedTokensIndexWithSubstitutions[_tokenId] is invalid, set it below based on the new owner\r\n\r\n        // Give to the TO address\r\n        _tokensOfOwnerWithSubstitutions[_to].push(_tokenId);\r\n        _ownedTokensIndexWithSubstitutions[_tokenId] = (_tokensOfOwnerWithSubstitutions[_to].length - 1) + 1;\r\n\r\n        // External processing\r\n        _tokenOwnerWithSubstitutions[_tokenId] = _to;\r\n        tokenApprovals[_tokenId] = address(0);\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    // PRIVATE STORAGE AND FUNCTIONS ///////////////////////////////////////////\r\n\r\n    // See Solidity issue #3356, it would be clearer to initialize in SuMain\r\n    uint256 private constant TOTAL_SUPPLY = 1001;\r\n\r\n    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n\r\n    /// @dev The owner of each NFT\r\n    ///  If value == address(0), NFT is owned by address(this)\r\n    ///  If value != address(0), NFT is owned by value\r\n    ///  assert(This contract never assigns ownership to address(0) or destroys NFTs)\r\n    ///  See commented out code in constructor, saves hella gas\r\n    ///  In other words address(0) in storage means address(this) outside\r\n    mapping (uint256 => address) private _tokenOwnerWithSubstitutions;\r\n\r\n    /// @dev The list of NFTs owned by each address\r\n    ///  Nomenclature: arr[key][index] = value\r\n    ///  If key != address(this) or value != 0, then value represents an NFT\r\n    ///  If key == address(this) and value == 0, then index + 1 is the NFT\r\n    ///  assert(0 is not a valid NFT)\r\n    ///  See commented out code in constructor, saves hella gas\r\n    ///  In other words [0, 0, a, 0] is equivalent to [1, 2, a, 4] for address(this)\r\n    mapping (address => uint256[]) private _tokensOfOwnerWithSubstitutions;\r\n\r\n    /// @dev (Location + 1) of each NFT in its owner's list\r\n    ///  Nomenclature: arr[nftId] = value\r\n    ///  If value != 0, _tokensOfOwnerWithSubstitutions[owner][value - 1] = nftId\r\n    ///  If value == 0, _tokensOfOwnerWithSubstitutions[owner][nftId - 1] = nftId\r\n    ///  assert(2**256-1 is not a valid NFT)\r\n    ///  See commented out code in constructor, saves hella gas\r\n    ///  In other words mapping {a=>a} is equivalent to {a=>0}\r\n    mapping (uint256 => uint256) private _ownedTokensIndexWithSubstitutions;\r\n\r\n    // Due to implementation choices (no mint, no burn, contiguous NFT ids), it\r\n    // is not necessary to keep an array of NFT ids nor where each NFT id is\r\n    // located in that array.\r\n    // address[] private nftIds;\r\n    // mapping (uint256 => uint256) private nftIndexOfId;\r\n\r\n    constructor() internal {\r\n        // Publish interfaces with ERC-165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n        supportedInterfaces[0x8153916a] = true; // ERC721 + 165 (not needed)\r\n\r\n        // The effect of substitution makes storing address(this), address(this)\r\n        // ..., address(this) for a total of TOTAL_SUPPLY times unnecessary at\r\n        // deployment time\r\n        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\r\n        //     _tokenOwnerWithSubstitutions[i] = address(this);\r\n        // }\r\n\r\n        // The effect of substitution makes storing 1, 2, ..., TOTAL_SUPPLY\r\n        // unnecessary at deployment time\r\n        _tokensOfOwnerWithSubstitutions[address(this)].length = TOTAL_SUPPLY;\r\n        // for (uint256 i = 0; i < TOTAL_SUPPLY; i++) {\r\n        //     _tokensOfOwnerWithSubstitutions[address(this)][i] = i + 1;\r\n        // }\r\n        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\r\n        //     _ownedTokensIndexWithSubstitutions[i] = i - 1;\r\n        // }\r\n    }\r\n\r\n    /// @dev Actually perform the safeTransferFrom\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\r\n        private\r\n        mustBeValidToken(_tokenId)\r\n        canTransfer(_tokenId)\r\n    {\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Do owner address substitution\r\n        if (owner == address(0)) {\r\n            owner = address(this);\r\n        }\r\n        require(owner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_tokenId, _to);\r\n\r\n        // Do the callback after everything is done to avoid reentrancy attack\r\n        uint256 codeSize;\r\n        assembly { codeSize := extcodesize(_to) }\r\n        if (codeSize == 0) {\r\n            return;\r\n        }\r\n        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, data);\r\n        require(retval == ERC721_RECEIVED);\r\n    }\r\n}\r\n\r\n\r\n/* SuMain.sol *****************************************************************/\r\n\r\n/// @title The features that deed owners can use\r\n/// @author William Entriken (https://phor.net)\r\ncontract CryptoStars is CryptoStarsNFTs {\r\n    constructor() public {\r\n        \r\n       \r\n //Chris Rare        \r\n _transfer(12, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(956, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(632, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(910, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(397, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(829, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(520, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(26, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(853, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(79, 0x1494c6E369B4c262E2b8e3C7bDF173b602D32eF9);\r\n _transfer(81, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(134, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(229, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(350, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(621, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(581, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(561, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(428, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(657, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(683, 0x00F64A288821daE5cd50A30b29D059a065aceC20);\r\n _transfer(834, 0xA598741A18D7c8eD53fb122C77490914831976Ba);\r\n _transfer(881, 0xA598741A18D7c8eD53fb122C77490914831976Ba);\r\n _transfer(1001, 0xA598741A18D7c8eD53fb122C77490914831976Ba);\r\n _transfer(29, 0xA598741A18D7c8eD53fb122C77490914831976Ba);\r\n _transfer(9, 0xA598741A18D7c8eD53fb122C77490914831976Ba);\r\n\r\n //Morgane Rare\r\n _transfer(1, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(274, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(290, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(431, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(534, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(312, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(619, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(194, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(807, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(41, 0x0Ff7ede572b24b0f4ac239700EEC9C942a01A70F);\r\n _transfer(100, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(252, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(221, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(432, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(465, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(545, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(588, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(644, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(697, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(732, 0xcD7F73ca6B3Bfb454698658446392E2FdCE1aB31);\r\n _transfer(975, 0x7287583F6A348cC1Ea40c271e6dc6Babb5919E0b);\r\n _transfer(948, 0x7287583F6A348cC1Ea40c271e6dc6Babb5919E0b);\r\n _transfer(389, 0x7287583F6A348cC1Ea40c271e6dc6Babb5919E0b);\r\n _transfer(4, 0x7287583F6A348cC1Ea40c271e6dc6Babb5919E0b);\r\n _transfer(46, 0x7287583F6A348cC1Ea40c271e6dc6Babb5919E0b);\r\n\r\n //Cookie Rare\r\n _transfer(757, 0x69a80Ce346B8F6f6A9Cc11908D26d77BF81BB299);\r\n giftCryptoStars(9, 0xeF97c92C47a76756CF8f33fB8b227Cd8ebd7638D);\r\n\r\n //Dikasso Rare\r\n _transfer(169, 0x36ED2D75A82e180e0871456b15c239b73B4EE9F4);\r\n giftCryptoStars(9, 0x36ED2D75A82e180e0871456b15c239b73B4EE9F4);\r\n\r\n //james Rare\r\n _transfer(907, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(666, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(737, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(758, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(742, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(878, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(917, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n _transfer(99, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n giftCryptoStars(2, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n\r\n //gift casey \r\n giftCryptoStars(10, 0x6c9Cb75B97bEb33095927fAe1C5401cCC05FeCae);\r\n\r\n //gift hugh\r\n giftCryptoStars(10, 0x4e0438B9F5133897844336442207f9b181e73C55);\r\n \r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"buyCryptoStars\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starsAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"CryptoStars","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3262664116c49a1e371579c6faee43f9124c0a276729c0259d4f9bc1ca0899a1"}]}