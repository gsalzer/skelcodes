{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MatrixPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./balancer-core/BPool.sol\\\";\\nimport \\\"./interfaces/MatrixPoolInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Initializable.sol\\\";\\n\\ncontract MatrixPool is BPool, Initializable {\\n    /// @notice The event emitted when a dynamic weight set to token.\\n    event SetDynamicWeight(\\n        address indexed token,\\n        uint256 fromDenorm,\\n        uint256 targetDenorm,\\n        uint256 fromTimestamp,\\n        uint256 targetTimestamp\\n    );\\n\\n    /// @notice The event emitted when weight per second bounds set.\\n    event SetWeightPerSecondBounds(uint256 minWeightPerSecond, uint256 maxWeightPerSecond);\\n\\n    struct DynamicWeight {\\n        uint256 fromTimestamp;\\n        uint256 targetTimestamp;\\n        uint256 targetDenorm;\\n    }\\n\\n    /// @dev Mapping for storing dynamic weights settings. fromDenorm stored in _records mapping as denorm variable.\\n    mapping(address => DynamicWeight) private _dynamicWeights;\\n\\n    /// @dev Min weight per second limit.\\n    uint256 private _minWeightPerSecond;\\n    /// @dev Max weight per second limit.\\n    uint256 private _maxWeightPerSecond;\\n\\n    constructor() public BPool(\\\"\\\", \\\"\\\") {}\\n\\n    function initialize(\\n        string calldata name,\\n        string calldata symbol,\\n        address controller,\\n        uint256 minWeightPerSecond,\\n        uint256 maxWeightPerSecond\\n    ) external initializer {\\n        _name = name;\\n        _symbol = symbol;\\n        _controller = controller;\\n        _minWeightPerSecond = minWeightPerSecond;\\n        _maxWeightPerSecond = maxWeightPerSecond;\\n    }\\n\\n    /*** Controller Interface ***/\\n\\n    /**\\n     * @notice Set minimum and maximum weight per second by controller.\\n     * @param minWeightPerSecond Minimum weight per second.\\n     * @param maxWeightPerSecond Maximum weight per second.\\n     */\\n    function setWeightPerSecondBounds(uint256 minWeightPerSecond, uint256 maxWeightPerSecond) public _logs_ _lock_ {\\n        _onlyController();\\n        _minWeightPerSecond = minWeightPerSecond;\\n        _maxWeightPerSecond = maxWeightPerSecond;\\n\\n        emit SetWeightPerSecondBounds(minWeightPerSecond, maxWeightPerSecond);\\n    }\\n\\n    /**\\n     * @notice Set dynamic weight for token by controller contract.\\n     * @param token Token to change weight.\\n     * @param targetDenorm Target weight. fromDenorm will fetch from current value of _getDenormWeight.\\n     * @param fromTimestamp Start timestamp for changing weight.\\n     * @param targetTimestamp Target timestamp for changing weight.\\n     */\\n    function setDynamicWeight(\\n        address token,\\n        uint256 targetDenorm,\\n        uint256 fromTimestamp,\\n        uint256 targetTimestamp\\n    ) public _logs_ _lock_ {\\n        _onlyController();\\n        _requireTokenIsBound(token);\\n\\n        require(fromTimestamp > block.timestamp, \\\"CANT_SET_PAST_TIMESTAMP\\\");\\n        require(targetTimestamp > fromTimestamp, \\\"TIMESTAMP_INCORRECT_DELTA\\\");\\n        require(targetDenorm >= MIN_WEIGHT && targetDenorm <= MAX_WEIGHT, \\\"TARGET_WEIGHT_BOUNDS\\\");\\n\\n        uint256 fromDenorm = _getDenormWeight(token);\\n        uint256 weightPerSecond = _getWeightPerSecond(fromDenorm, targetDenorm, fromTimestamp, targetTimestamp);\\n        require(weightPerSecond <= _maxWeightPerSecond, \\\"MAX_WEIGHT_PER_SECOND\\\");\\n        require(weightPerSecond >= _minWeightPerSecond, \\\"MIN_WEIGHT_PER_SECOND\\\");\\n\\n        _records[token].denorm = fromDenorm;\\n\\n        _dynamicWeights[token] = DynamicWeight({\\n        fromTimestamp : fromTimestamp,\\n        targetTimestamp : targetTimestamp,\\n        targetDenorm : targetDenorm\\n        });\\n\\n        uint256 denormSum = 0;\\n        uint256 len = _tokens.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            denormSum = badd(denormSum, _dynamicWeights[_tokens[i]].targetDenorm);\\n        }\\n\\n        require(denormSum <= MAX_TOTAL_WEIGHT, \\\"MAX_TARGET_TOTAL_WEIGHT\\\");\\n\\n        emit SetDynamicWeight(token, fromDenorm, targetDenorm, fromTimestamp, targetTimestamp);\\n    }\\n\\n    /**\\n     * @notice Bind and setDynamicWeight at the same time.\\n     * @param token Token for bind.\\n     * @param balance Initial token balance.\\n     * @param targetDenorm Target weight.\\n     * @param fromTimestamp Start timestamp to change weight.\\n     * @param targetTimestamp Target timestamp to change weight.\\n     */\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 targetDenorm,\\n        uint256 fromTimestamp,\\n        uint256 targetTimestamp\\n    )\\n    external\\n    _logs_ // _lock_  Bind does not lock because it jumps to `rebind` and `setDynamicWeight`, which does\\n    {\\n        super.bind(token, balance, MIN_WEIGHT);\\n\\n        setDynamicWeight(token, targetDenorm, fromTimestamp, targetTimestamp);\\n    }\\n\\n    /**\\n     * @dev Override parent unbind function.\\n     * @param token Token for unbind.\\n     */\\n    function unbind(address token) public override {\\n        super.unbind(token);\\n\\n        _dynamicWeights[token] = DynamicWeight(0, 0, 0);\\n    }\\n\\n    /**\\n     * @dev Override parent bind function and disable.\\n     */\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) public override {\\n        super.bind(token, balance, denorm);\\n    }\\n\\n    /**\\n     * @notice Override parent rebind function. Allowed only for calling from bind function.\\n     * @param token Token for rebind.\\n     * @param balance Balance for rebind.\\n     * @param denorm Weight for rebind.\\n     */\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) public override {\\n        super.rebind(token, balance, denorm);\\n        _dynamicWeights[token].fromTimestamp = 0;\\n        _dynamicWeights[token].targetTimestamp = 0;\\n        _dynamicWeights[token].targetDenorm = 0;\\n    }\\n\\n    /*** View Functions ***/\\n\\n    function getDynamicWeightSettings(address token)\\n    external\\n    view\\n    returns (\\n        uint256 fromTimestamp,\\n        uint256 targetTimestamp,\\n        uint256 fromDenorm,\\n        uint256 targetDenorm\\n    )\\n    {\\n        DynamicWeight storage dw = _dynamicWeights[token];\\n        return (dw.fromTimestamp, dw.targetTimestamp, _records[token].denorm, dw.targetDenorm);\\n    }\\n\\n    function getWeightPerSecondBounds() external view returns (uint256 minWeightPerSecond, uint256 maxWeightPerSecond) {\\n        return (_minWeightPerSecond, _maxWeightPerSecond);\\n    }\\n\\n    /*** Internal Functions ***/\\n\\n    function _getDenormWeight(address token) internal view override returns (uint256) {\\n        DynamicWeight memory dw = _dynamicWeights[token];\\n        uint256 fromDenorm = _records[token].denorm;\\n\\n        if (dw.fromTimestamp == 0 || dw.targetDenorm == fromDenorm || block.timestamp <= dw.fromTimestamp) {\\n            return fromDenorm;\\n        }\\n        if (block.timestamp >= dw.targetTimestamp) {\\n            return dw.targetDenorm;\\n        }\\n\\n        uint256 weightPerSecond = _getWeightPerSecond(fromDenorm, dw.targetDenorm, dw.fromTimestamp, dw.targetTimestamp);\\n        uint256 deltaCurrentTime = bsub(block.timestamp, dw.fromTimestamp);\\n        if (dw.targetDenorm > fromDenorm) {\\n            return badd(fromDenorm, deltaCurrentTime * weightPerSecond);\\n        } else {\\n            return bsub(fromDenorm, deltaCurrentTime * weightPerSecond);\\n        }\\n    }\\n\\n    function _getWeightPerSecond(\\n        uint256 fromDenorm,\\n        uint256 targetDenorm,\\n        uint256 fromTimestamp,\\n        uint256 targetTimestamp\\n    ) internal pure returns (uint256) {\\n        uint256 delta = targetDenorm > fromDenorm ? bsub(targetDenorm, fromDenorm) : bsub(fromDenorm, targetDenorm);\\n        return div(delta, bsub(targetTimestamp, fromTimestamp));\\n    }\\n\\n    function _getTotalWeight() internal view override returns (uint256) {\\n        uint256 sum = 0;\\n        uint256 len = _tokens.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            sum = badd(sum, _getDenormWeight(_tokens[i]));\\n        }\\n        return sum;\\n    }\\n\\n    function _addTotalWeight(uint256 _amount) internal virtual override {\\n        // storage total weight don't change, it's calculated only by _getTotalWeight()\\n    }\\n\\n    function _subTotalWeight(uint256 _amount) internal virtual override {\\n        // storage total weight don't change, it's calculated only by _getTotalWeight()\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\nimport \\\"../interfaces/IPoolRestrictions.sol\\\";\\nimport \\\"../interfaces/BPoolInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\ncontract BPool is BToken, BMath, BPoolInterface {\\n    using SafeERC20 for IERC20;\\n\\n    struct Record {\\n        bool bound;   // is token bound to pool\\n        uint index;   // private\\n        uint denorm;  // denormalized weight\\n        uint balance;\\n    }\\n\\n  /* ==========  EVENTS  ========== */\\n\\n    /** @dev Emitted when tokens are swapped. */\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    /** @dev Emitted when underlying tokens are deposited for pool tokens. */\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    /** @dev Emitted when pool tokens are burned for underlying. */\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    /** @dev Emitted on calling any method with `_logs_` modifier. */\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    /** @dev Emitted on calling external voting contract. */\\n    event LOG_CALL_VOTING(\\n        address indexed voting,\\n        bool    indexed success,\\n        bytes4  indexed inputSig,\\n        bytes           inputData,\\n        bytes           outputData\\n    );\\n\\n    /** @dev Emitted on taking community fee. */\\n    event LOG_COMMUNITY_FEE(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed token,\\n        uint256         tokenAmount\\n    );\\n\\n  /* ==========  Modifiers  ========== */\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        _preventReentrancy();\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        _preventReentrancy();\\n        _;\\n    }\\n\\n  /* ==========  Storage  ========== */\\n\\n    bool private _mutex;\\n\\n    // CONTROLLER contract. Able to modify swap fee, swap community fee,\\n    // community entree fee, community exit fee,\\n    // change token weights, bind, unbind and rebind tokens,\\n    // set wrapper contract, enable wrapper mode, change CONTROLLER.\\n    address internal _controller;\\n\\n    // True if PUBLIC can call SWAP & JOIN functions\\n    bool private _swapsDisabled;\\n\\n    // Address of contract which wraps pool operations:\\n    // join, exit and swaps.\\n    address private _wrapper;\\n    // Restriction to execute pool operations only from wrapper contract.\\n    // True if only wrapper can execute pool operations.\\n    bool private _wrapperMode;\\n\\n    // Contract for getting restrictions:\\n    // Max total supply and voting calls.\\n    IPoolRestrictions private _restrictions;\\n\\n    // `setSwapFee` require CONTROLLER\\n    uint private _swapFee;\\n    // `_communitySwapFee`, `_communityJoinFee`, `_communityExitFee`\\n    // defines the commissions sent to `_communityFeeReceiver`\\n    uint private _communitySwapFee;\\n    uint private _communityJoinFee;\\n    uint private _communityExitFee;\\n    // Community commission contract. Collects\\n    // `_communitySwapFee`, `_communityJoinFee`, `_communityExitFee`\\n    // for voting in underlying protocols, receiving rewards.\\n    address private _communityFeeReceiver;\\n    // `finalize` require CONTROLLER\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    bool private _finalized;\\n\\n    // Array of underlying pool tokens.\\n    address[] internal _tokens;\\n    // Pool's underlying tokens Internal records.\\n    mapping(address => Record) internal _records;\\n    // Total pool's denormalized weight.\\n    uint internal _totalWeight;\\n\\n    // Last block when account address made a swap.\\n    mapping(address => uint256) internal _lastSwapBlock;\\n\\n    constructor(string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _controller = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _communitySwapFee = 0;\\n        _communityJoinFee = 0;\\n        _communityExitFee = 0;\\n        _swapsDisabled = false;\\n        _finalized = false;\\n    }\\n\\n  /* ==========  Token Queries  ========== */\\n\\n    /**\\n     * @notice Check if a token is bound to the pool.\\n     * @param t Token contracts address.\\n     * @return TRUE if the token is bounded, FALSE - if not.\\n     */\\n    function isBound(address t)\\n        external view override\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens bound to the pool.\\n     * @return bound tokens number.\\n     */\\n    function getNumTokens()\\n        external view\\n        returns (uint)\\n    {\\n        return _tokens.length;\\n    }\\n\\n    /**\\n      * @notice Get all bound tokens.\\n      * @return tokens - bound token address array.\\n     */\\n    function getCurrentTokens()\\n        external view override\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    /**\\n      * @notice Get all bound tokens with a finalization check.\\n      * @return tokens - bound token address array.\\n     */\\n    function getFinalTokens()\\n        external view override\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        _requireContractIsFinalized();\\n        return _tokens;\\n    }\\n\\n    /**\\n      * @notice Returns the denormalized weight of a bound token.\\n      * @param token Token contract address.\\n      * @return Bound token denormalized weight.\\n     */\\n    function getDenormalizedWeight(address token)\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        _requireTokenIsBound(token);\\n        return _getDenormWeight(token);\\n    }\\n\\n    /**\\n     * @notice Get the total denormalized weight of the pool.\\n     * @return Total denormalized weight of all bound tokens.\\n     */\\n    function getTotalDenormalizedWeight()\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _getTotalWeight();\\n    }\\n\\n    /**\\n     * @notice Returns the normalized weight of a bound token.\\n     * @param token Token contract address.\\n     * @return Bound token normalized weight.\\n     */\\n    function getNormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        _requireTokenIsBound(token);\\n        return bdiv(_getDenormWeight(token), _getTotalWeight());\\n    }\\n\\n    /**\\n     * @notice Returns the stored balance of a bound token.\\n     * @param token Token contract address.\\n     * @return Bound token balance\\n     */\\n    function getBalance(address token)\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        _requireTokenIsBound(token);\\n        return _records[token].balance;\\n    }\\n\\n  /* ==========  Config Queries  ========== */\\n\\n    /**\\n     * @notice Check if tokens swap and joining the pool allowed.\\n     * @return TRUE if allowed, FALSE if not.\\n     */\\n    function isSwapsDisabled()\\n        external view override\\n        returns (bool)\\n    {\\n        return _swapsDisabled;\\n    }\\n\\n    /**\\n     * @notice Check if pool is finalized.\\n     * @return TRUE if finalized, FALSE if not.\\n     */\\n    function isFinalized()\\n        external view override\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    /**\\n     * @notice Returns the swap fee rate.\\n     * @return pool's swap fee rate.\\n     */\\n    function getSwapFee()\\n        external view override\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _swapFee;\\n    }\\n\\n    /**\\n     * @notice Returns the community fee rate and community fee receiver.\\n     * @return communitySwapFee - community swap fee rate.\\n     * @return communityJoinFee - community join fee rate.\\n     * @return communityExitFee - community exit fee rate.\\n     * @return communityFeeReceiver - community fee receiver address.\\n     */\\n    function getCommunityFee()\\n        external view override\\n        _viewlock_\\n        returns (uint communitySwapFee, uint communityJoinFee, uint communityExitFee, address communityFeeReceiver)\\n    {\\n        return (_communitySwapFee, _communityJoinFee, _communityExitFee, _communityFeeReceiver);\\n    }\\n\\n    /**\\n     * @notice Returns the controller address.\\n     * @return controller contract address.\\n     */\\n    function getController()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @notice Returns the wrapper address.\\n     * @return pool wrapper contract address.\\n     */\\n    function getWrapper()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _wrapper;\\n    }\\n\\n    /**\\n     * @notice Check if wrapper mode is enabled.\\n     * @return TRUE if wrapper mode enabled, FALSE if not.\\n     */\\n    function getWrapperMode()\\n        external view\\n        _viewlock_\\n        returns (bool)\\n    {\\n        return _wrapperMode;\\n    }\\n\\n    /**\\n     * @notice Returns the restrictions contract address.\\n     * @return pool restrictions contract address.\\n     */\\n    function getRestrictions()\\n        external view override\\n        _viewlock_\\n        returns (address)\\n    {\\n        return address(_restrictions);\\n    }\\n\\n  /* ==========  Configuration Actions  ========== */\\n\\n    /**\\n     * @notice Set the swap fee.\\n     * @dev Swap fee must be between 0.0001% and 10%.\\n     * @param swapFee swap fee left in the pool.\\n     */\\n    function setSwapFee(uint swapFee)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireFeeInBounds(swapFee);\\n        _swapFee = swapFee;\\n    }\\n\\n    /**\\n     * @notice Set the community fee and community fee receiver.\\n     * @dev Community fee must be between 0.0001% and 10%.\\n     * @param communitySwapFee Fee for Community treasury from each swap\\n     * @param communityJoinFee Fee for Community treasury from each join.\\n     * @param communityExitFee Fee for Community treasury from each exit.\\n     * @param communityFeeReceiver Community treasury contract address.\\n     */\\n    function setCommunityFeeAndReceiver(\\n        uint communitySwapFee,\\n        uint communityJoinFee,\\n        uint communityExitFee,\\n        address communityFeeReceiver\\n    )\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireFeeInBounds(communitySwapFee);\\n        _requireFeeInBounds(communityJoinFee);\\n        _requireFeeInBounds(communityExitFee);\\n        _communitySwapFee = communitySwapFee;\\n        _communityJoinFee = communityJoinFee;\\n        _communityExitFee = communityExitFee;\\n        _communityFeeReceiver = communityFeeReceiver;\\n    }\\n\\n    /**\\n     * @notice Set the restrictions contract address.\\n     * @param restrictions Pool's restrictions contract.\\n     */\\n    function setRestrictions(IPoolRestrictions restrictions)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _restrictions = restrictions;\\n    }\\n\\n    /**\\n     * @notice Set the controller address.\\n     * @param manager New controller contract address.\\n     */\\n    function setController(address manager)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _controller = manager;\\n    }\\n\\n    /**\\n     * @notice Enable or disable swaps.\\n     * @param disabled_ boolean variable, TRUE if disable, FALSE if not.\\n     */\\n    function setSwapsDisabled(bool disabled_)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _swapsDisabled = disabled_;\\n    }\\n\\n    /**\\n     * @notice Set the wrapper contract address and mode.\\n     * @param wrapper Wrapper contract address.\\n     * @param wrapperMode TRUE if enabled, FALSE if disabled.\\n     */\\n    function setWrapper(address wrapper, bool wrapperMode)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _wrapper = wrapper;\\n        _wrapperMode = wrapperMode;\\n    }\\n\\n    /**\\n     * @notice Finalize the pool, enable swaps, mint pool share token.\\n     */\\n    function finalize()\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireContractIsNotFinalized();\\n        require(_tokens.length >= MIN_BOUND_TOKENS, \\\"MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n    /* ==========  Voting Management Actions  ========== */\\n\\n        /**\\n       * @notice Call target external contract with provided signature and data.\\n       * @param voting Destination contract address.\\n       * @param signature Destination contract method signature.\\n       * @param args Arguments of the called method.\\n       * @param value Transaction value.\\n       * @dev Can call only controller contract. Checks if destination address and signature allowed.\\n       */\\n\\n\\n    function callVoting(address voting, bytes4 signature, bytes calldata args, uint256 value)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        require(_restrictions.isVotingSignatureAllowed(voting, signature), \\\"NOT_ALLOWED_SIG\\\");\\n        _onlyController();\\n\\n        (bool success, bytes memory data) = voting.call{ value: value }(abi.encodePacked(signature, args));\\n        require(success, \\\"NOT_SUCCESS\\\");\\n        emit LOG_CALL_VOTING(voting, success, signature, args, data);\\n    }\\n\\n    /* ==========  Token Management Actions  ========== */\\n\\n    /**\\n     * @notice Bind a token with depositing initial balance.\\n     * @param token Address of the token to bind.\\n     * @param balance Initial token balance.\\n     * @param denorm Token denormalized weight.\\n     */\\n    function bind(address token, uint balance, uint denorm)\\n        public override\\n        virtual\\n        _logs_\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        _onlyController();\\n        require(!_records[token].bound, \\\"IS_BOUND\\\");\\n\\n        require(_tokens.length < MAX_BOUND_TOKENS, \\\"MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0,    // balance and denorm will be validated\\n            balance: 0   // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    /**\\n     * @notice Rebind token with changing balance and denormalized weight.\\n     * @param token Address of the token to rebind.\\n     * @param balance New token balance.\\n     * @param denorm Desired weight for the token.\\n     */\\n    function rebind(address token, uint balance, uint denorm)\\n        public override\\n        virtual\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireTokenIsBound(token);\\n\\n        require(denorm >= MIN_WEIGHT && denorm <= MAX_WEIGHT, \\\"WEIGHT_BOUNDS\\\");\\n        require(balance >= MIN_BALANCE, \\\"MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm > oldWeight) {\\n            _addTotalWeight(bsub(denorm, oldWeight));\\n        } else if (denorm < oldWeight) {\\n            _subTotalWeight(bsub(oldWeight, denorm));\\n        }\\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance > oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance < oldBalance) {\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove a token from the pool.\\n     * @dev Replaces the address in the tokens array with the last address, then removes it from the array.\\n     * @param token Bound token address.\\n     */\\n    function unbind(address token)\\n        public override\\n        virtual\\n        _logs_\\n        _lock_\\n    {\\n        _onlyController();\\n        _requireTokenIsBound(token);\\n\\n        uint tokenBalance = _records[token].balance;\\n\\n        _subTotalWeight(_records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            index: 0,\\n            denorm: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, msg.sender, tokenBalance);\\n    }\\n\\n    /**\\n     * @notice Absorb any tokens that have been sent to this contract into the pool.\\n     * @param token Bound token address.\\n     */\\n    function gulp(address token)\\n        external override\\n    {\\n    }\\n\\n    /* ==========  Price Queries  ========== */\\n\\n    /**\\n     * @notice Returns the spot price for `tokenOut` in terms of `tokenIn`.\\n     * @param tokenIn Bound tokenIn address.\\n     * @param tokenOut Bound tokenOut address.\\n     * @return spotPrice - amount of tokenIn in wei for 1 ether of tokenOut.\\n     */\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound && _records[tokenOut].bound, \\\"NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, _getDenormWeight(tokenIn), outRecord.balance, _getDenormWeight(tokenOut), _swapFee);\\n    }\\n\\n    /**\\n     * @notice Returns the spot price for `tokenOut` in terms of `tokenIn` without swapFee.\\n     * @param tokenIn Bound tokenIn address.\\n     * @param tokenOut Bound tokenOut address.\\n     * @return spotPrice - amount of tokenIn in wei for 1 ether of tokenOut.\\n     */\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        _requireTokenIsBound(tokenIn);\\n        _requireTokenIsBound(tokenOut);\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, _getDenormWeight(tokenIn), outRecord.balance, _getDenormWeight(tokenOut), 0);\\n    }\\n\\n  function calcTokensForAmount(uint256 _amount) external view returns (address[] memory tokens, uint256[] memory amounts)\\n  {\\n    tokens = _tokens;\\n    amounts = new uint256[](tokens.length);\\n    uint poolTotal = totalSupply();\\n    uint256 ratio = bdiv(_amount, poolTotal);\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address t = tokens[i];\\n      uint256 bal = _records[t].balance;\\n      uint256 amount = bmul(ratio, bal);\\n      amounts[i] = amount;\\n    }\\n  }\\n\\n    /* ==========  Liquidity Provider Actions and Token Swaps  ========== */\\n\\n    /**\\n     * @notice Mint new pool tokens by providing the proportional amount of each\\n     * underlying token's balance relative to the proportion of pool tokens minted.\\n     * @param poolAmountOut Amount of pool tokens to mint\\n     * @param maxAmountsIn Maximum amount of each token to pay in the same order as the pool's _tokens list.\\n     */\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireContractIsFinalized();\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        _requireMathApprox(ratio);\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            _requireMathApprox(tokenAmountIn);\\n            require(tokenAmountIn < maxAmountsIn[i], \\\"LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n\\n//        (uint poolAmountOutAfterFee, uint poolAmountOutFee) = calcAmountWithCommunityFee(\\n//            poolAmountOut,\\n//            _communityJoinFee,\\n//            msg.sender\\n//        );\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n//        _pushPoolShare(_communityFeeReceiver, poolAmountOutFee);\\n//        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountOutFee);\\n    }\\n\\n    /**\\n     * @notice Burns `poolAmountIn` pool tokens in exchange for the amounts of each\\n     * underlying token's balance proportional to the ratio of tokens burned to\\n     * total pool supply. The amount of each token transferred to the caller must\\n     * be greater than or equal to the associated minimum output amount from the\\n     * `minAmountsOut` array.\\n     *\\n     * @param poolAmountIn Exact amount of pool tokens to burn\\n     * @param minAmountsOut Minimum amount of each token to receive, in the same\\n     * order as the pool's _tokens list.\\n     */\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n        external override\\n        _logs_\\n        _lock_\\n    {\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireContractIsFinalized();\\n\\n        (uint poolAmountInAfterFee, uint poolAmountInFee) = calcAmountWithCommunityFee(\\n            poolAmountIn,\\n            _communityExitFee,\\n            msg.sender\\n        );\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountInAfterFee, poolTotal);\\n        _requireMathApprox(ratio);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_communityFeeReceiver, poolAmountInFee);\\n        _burnPoolShare(poolAmountInAfterFee);\\n\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountOut = bmul(ratio, bal);\\n            _requireMathApprox(tokenAmountOut);\\n            require(tokenAmountOut > minAmountsOut[i], \\\"LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountInFee);\\n    }\\n\\n    /**\\n    * @notice Execute a token swap with a specified amount of input\\n    * tokens and a minimum amount of output tokens.\\n    * @dev Will revert if `tokenOut` is uninitialized.\\n    * @param tokenIn Token to swap in.\\n    * @param tokenAmountIn Exact amount of `tokenIn` to swap in.\\n    * @param tokenOut Token to swap out.\\n    * @param minAmountOut Minimum amount of `tokenOut` to receive.\\n    * @param maxPrice Maximum ratio of input to output tokens.\\n    * @return tokenAmountOut\\n    * @return spotPriceAfter\\n    */\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n        _checkSwapsDisabled();\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n        _requireTokenIsBound(tokenOut);\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    _getDenormWeight(tokenIn),\\n                                    outRecord.balance,\\n                                    _getDenormWeight(tokenOut),\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        (uint tokenAmountInAfterFee, uint tokenAmountInFee) = calcAmountWithCommunityFee(\\n                                                                tokenAmountIn,\\n                                                                _communitySwapFee,\\n                                                                msg.sender\\n                                                            );\\n\\n        require(tokenAmountInAfterFee <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            tokenAmountInAfterFee,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut >= minAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountInAfterFee);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                _getDenormWeight(tokenIn),\\n                                outRecord.balance,\\n                                _getDenormWeight(tokenOut),\\n                                _swapFee\\n                            );\\n        require(\\n            spotPriceAfter >= spotPriceBefore &&\\n            spotPriceBefore <= bdiv(tokenAmountInAfterFee, tokenAmountOut),\\n            \\\"MATH_APPROX\\\"\\n        );\\n        require(spotPriceAfter <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountInAfterFee, tokenAmountOut);\\n\\n        _pullCommunityFeeUnderlying(tokenIn, msg.sender, tokenAmountInFee);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountInAfterFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenIn, tokenAmountInFee);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n    /**\\n    * @dev Trades at most `maxAmountIn` of `tokenIn` for exactly `tokenAmountOut`\\n    * of `tokenOut`.\\n    *\\n    * Returns the actual input amount and the new spot price after the swap,\\n    * which can not exceed `maxPrice`.\\n    *\\n    * @param tokenIn Token to swap in\\n    * @param maxAmountIn Maximum amount of `tokenIn` to pay\\n    * @param tokenOut Token to swap out\\n    * @param tokenAmountOut Exact amount of `tokenOut` to receive\\n    * @param maxPrice Maximum ratio of input to output tokens\\n    * @return tokenAmountIn\\n    * @return spotPriceAfter\\n    */\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPrice\\n    )\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        _checkSwapsDisabled();\\n        _preventSameTxOrigin();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n        _requireTokenIsBound(tokenOut);\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"OUT_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    _getDenormWeight(tokenIn),\\n                                    outRecord.balance,\\n                                    _getDenormWeight(tokenOut),\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\\n            tokenAmountOut,\\n            _communitySwapFee,\\n            msg.sender\\n        );\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn <= maxAmountIn, \\\"LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                _getDenormWeight(tokenIn),\\n                                outRecord.balance,\\n                                _getDenormWeight(tokenOut),\\n                                _swapFee\\n                            );\\n        require(\\n            spotPriceAfter >= spotPriceBefore &&\\n            spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOutAfterFee),\\n            \\\"MATH_APPROX\\\"\\n        );\\n        require(spotPriceAfter <= maxPrice, \\\"LIMIT_PRICE\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOutAfterFee);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n    /**\\n     * @dev Pay `tokenAmountIn` of `tokenIn` to mint at least `minPoolAmountOut`\\n     * pool tokens.\\n     *\\n     * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\\n     * underlying tokens. Thus a swap fee is charged against the input tokens.\\n     *\\n     * @param tokenIn Token to send the pool\\n     * @param tokenAmountIn Exact amount of `tokenIn` to pay\\n     * @param minPoolAmountOut Minimum amount of pool tokens to mint\\n     * @return poolAmountOut - Amount of pool tokens minted\\n     */\\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountOut)\\n\\n    {\\n        _checkSwapsDisabled();\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        (uint tokenAmountInAfterFee, uint tokenAmountInFee) = calcAmountWithCommunityFee(\\n            tokenAmountIn,\\n            _communityJoinFee,\\n            msg.sender\\n        );\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            tokenAmountInAfterFee,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountOut >= minPoolAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountInAfterFee);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountInAfterFee);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullCommunityFeeUnderlying(tokenIn, msg.sender, tokenAmountInFee);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountInAfterFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenIn, tokenAmountInFee);\\n\\n        return poolAmountOut;\\n    }\\n\\n    /**\\n     * @dev Pay up to `maxAmountIn` of `tokenIn` to mint exactly `poolAmountOut`.\\n     *\\n     * The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other\\n     * underlying tokens. Thus a swap fee is charged against the input tokens.\\n     *\\n     * @param tokenIn Token to send the pool\\n     * @param poolAmountOut Exact amount of pool tokens to mint\\n     * @param maxAmountIn Maximum amount of `tokenIn` to pay\\n     * @return tokenAmountIn - Amount of `tokenIn` paid\\n     */\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn)\\n    {\\n        _checkSwapsDisabled();\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenIn);\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        (uint poolAmountOutAfterFee, uint poolAmountOutFee) = calcAmountWithCommunityFee(\\n            poolAmountOut,\\n            _communityJoinFee,\\n            msg.sender\\n        );\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n                            inRecord.balance,\\n                            _getDenormWeight(tokenIn),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            poolAmountOut,\\n                            _swapFee\\n                        );\\n\\n        _requireMathApprox(tokenAmountIn);\\n        require(tokenAmountIn <= maxAmountIn, \\\"LIMIT_IN\\\");\\n\\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOutAfterFee);\\n        _pushPoolShare(_communityFeeReceiver, poolAmountOutFee);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, address(this), poolAmountOutFee);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    /**\\n     * @dev Burns `poolAmountIn` pool tokens in exchange for at least `minAmountOut`\\n     * of `tokenOut`. Returns the number of tokens sent to the caller.\\n     *\\n     * The pool implicitly burns the tokens for all underlying tokens and swaps them\\n     * to the desired output token. A swap fee is charged against the output tokens.\\n     *\\n     * @param tokenOut Token to receive\\n     * @param poolAmountIn Exact amount of pool tokens to burn\\n     * @param minAmountOut Minimum amount of `tokenOut` to receive\\n     * @return tokenAmountOut - Amount of `tokenOut` received\\n     */\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut)\\n    {\\n        _checkSwapsDisabled();\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenOut);\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            poolAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountOut >= minAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"OUT_RATIO\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\\n            tokenAmountOut,\\n            _communityExitFee,\\n            msg.sender\\n        );\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOutAfterFee);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(poolAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\\n\\n        return tokenAmountOutAfterFee;\\n    }\\n\\n    /**\\n    * @dev Burn up to `maxPoolAmountIn` for exactly `tokenAmountOut` of `tokenOut`.\\n    * Returns the number of pool tokens burned.\\n    *\\n    * The pool implicitly burns the tokens for all underlying tokens and swaps them\\n    * to the desired output token. A swap fee is charged against the output tokens.\\n    *\\n    * @param tokenOut Token to receive\\n    * @param tokenAmountOut Exact amount of `tokenOut` to receive\\n    * @param maxPoolAmountIn Maximum amount of pool tokens to burn\\n    * @return poolAmountIn - Amount of pool tokens burned\\n    */\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\n        external override\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountIn)\\n    {\\n        _checkSwapsDisabled();\\n        _preventSameTxOrigin();\\n        _requireContractIsFinalized();\\n        _onlyWrapperOrNotWrapperMode();\\n        _requireTokenIsBound(tokenOut);\\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"OUT_RATIO\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        (uint tokenAmountOutAfterFee, uint tokenAmountOutFee) = calcAmountWithCommunityFee(\\n            tokenAmountOut,\\n            _communityExitFee,\\n            msg.sender\\n        );\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n                            outRecord.balance,\\n                            _getDenormWeight(tokenOut),\\n                            _totalSupply,\\n                            _getTotalWeight(),\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n\\n        _requireMathApprox(poolAmountIn);\\n        require(poolAmountIn <= maxPoolAmountIn, \\\"LIMIT_IN\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOutAfterFee);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(poolAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOutAfterFee);\\n        _pushUnderlying(tokenOut, _communityFeeReceiver, tokenAmountOutFee);\\n\\n        emit LOG_COMMUNITY_FEE(msg.sender, _communityFeeReceiver, tokenOut, tokenAmountOutFee);\\n\\n        return poolAmountIn;\\n    }\\n\\n    /* ==========  Underlying Token Internal Functions  ========== */\\n\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERC20_FALSE\\\");\\n    }\\n\\n    function _pullCommunityFeeUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, _communityFeeReceiver, amount);\\n        require(xfer, \\\"ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        if(address(_restrictions) != address(0)) {\\n            uint maxTotalSupply = _restrictions.getMaxTotalSupply(address(this));\\n            require(badd(_totalSupply, amount) <= maxTotalSupply, \\\"MAX_SUPPLY\\\");\\n        }\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n    /* ==========  Require Checks Functions  ========== */\\n\\n    function _requireTokenIsBound(address token)\\n        internal view\\n    {\\n        require(_records[token].bound, \\\"NOT_BOUND\\\");\\n    }\\n\\n    function _onlyController()\\n        internal view\\n    {\\n        require(msg.sender == _controller, \\\"NOT_CONTROLLER\\\");\\n    }\\n\\n    function _requireContractIsNotFinalized()\\n        internal view\\n    {\\n        require(!_finalized, \\\"IS_FINALIZED\\\");\\n    }\\n\\n    function _requireContractIsFinalized()\\n        internal view\\n    {\\n        require(_finalized, \\\"NOT_FINALIZED\\\");\\n    }\\n\\n    function _requireFeeInBounds(uint256 _fee)\\n        internal pure\\n    {\\n        require(_fee >= MIN_FEE && _fee <= MAX_FEE, \\\"FEE_BOUNDS\\\");\\n    }\\n\\n    function _requireMathApprox(uint256 _value)\\n        internal pure\\n    {\\n        require(_value != 0, \\\"MATH_APPROX\\\");\\n    }\\n\\n    function _preventReentrancy()\\n        internal view\\n    {\\n        require(!_mutex, \\\"REENTRY\\\");\\n    }\\n\\n    function _onlyWrapperOrNotWrapperMode()\\n        internal view\\n    {\\n        require(!_wrapperMode || msg.sender == _wrapper, \\\"ONLY_WRAPPER\\\");\\n    }\\n\\n    function _preventSameTxOrigin()\\n        internal\\n    {\\n      require(block.number > _lastSwapBlock[tx.origin], \\\"SAME_TX_ORIGIN\\\");\\n      _lastSwapBlock[tx.origin] = block.number;\\n    }\\n\\n    function _checkSwapsDisabled()\\n        internal\\n    {\\n      require(!_swapsDisabled, \\\"SWAPS_DISABLED\\\");\\n    }\\n\\n    /* ==========  Token Query Internal Functions  ========== */\\n\\n    function _getDenormWeight(address token)\\n        internal view virtual\\n        returns (uint)\\n    {\\n        return _records[token].denorm;\\n    }\\n\\n    function _getTotalWeight()\\n        internal view virtual\\n        returns (uint)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function _addTotalWeight(uint _amount) internal virtual {\\n    }\\n\\n    function _subTotalWeight(uint _amount) internal virtual {\\n    }\\n\\n    /* ==========  Other Public getters  ========== */\\n    /**\\n    * @dev Calculate result amount after taking community fee.\\n    * @param tokenAmountIn Token amount.\\n    * @param communityFee Community fee amount.\\n    * @return tokenAmountInAfterFee Amount after taking fee.\\n    * @return tokenAmountFee Result fee amount.\\n    */\\n    function calcAmountWithCommunityFee(\\n        uint tokenAmountIn,\\n        uint communityFee,\\n        address operator\\n    )\\n        public view override\\n        returns (uint tokenAmountInAfterFee, uint tokenAmountFee)\\n    {\\n        if (address(_restrictions) != address(0) && _restrictions.isWithoutFee(operator)) {\\n            return (tokenAmountIn, 0);\\n        }\\n        uint adjustedIn = bsub(BONE, communityFee);\\n        tokenAmountInAfterFee = bmul(tokenAmountIn, adjustedIn);\\n        tokenAmountFee = bsub(tokenAmountIn, tokenAmountInAfterFee);\\n        return (tokenAmountInAfterFee, tokenAmountFee);\\n    }\\n\\n    /**\\n    * @dev Returns MIN_WEIGHT constant.\\n    * @return MIN_WEIGHT.\\n    */\\n    function getMinWeight()\\n        external view override\\n        returns (uint)\\n    {\\n        return MIN_WEIGHT;\\n    }\\n\\n    /**\\n    * @dev Returns MAX_BOUND_TOKENS constant.\\n    * @return MAX_BOUND_TOKENS.\\n    */\\n    function getMaxBoundTokens()\\n        external view override\\n        returns (uint)\\n    {\\n      return MAX_BOUND_TOKENS;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/MatrixPoolInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BPoolInterface.sol\\\";\\n\\ninterface MatrixPoolInterface is BPoolInterface {\\n  function initialize(\\n    string calldata name,\\n    string calldata symbol,\\n    uint256 minWeightPerSecond,\\n    uint256 maxWeightPerSecond\\n  ) external;\\n\\n  function bind(\\n    address,\\n    uint256,\\n    uint256,\\n    uint256,\\n    uint256\\n  ) external;\\n\\n  function setDynamicWeight(\\n    address token,\\n    uint256 targetDenorm,\\n    uint256 fromTimestamp,\\n    uint256 targetTimestamp\\n  ) external;\\n\\n  function getDynamicWeightSettings(address token)\\n    external\\n    view\\n    returns (\\n      uint256 fromTimestamp,\\n      uint256 targetTimestamp,\\n      uint256 fromDenorm,\\n      uint256 targetDenorm\\n    );\\n\\n  function getMinWeight() external view override returns (uint256);\\n\\n  function getWeightPerSecondBounds() external view returns (uint256, uint256);\\n\\n  function setWeightPerSecondBounds(uint256, uint256) external;\\n\\n  function setWrapper(address, bool) external;\\n\\n  function getWrapperMode() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _validateAddress(src);\\n        _validateAddress(dst);\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n\\n    function _validateAddress(address addr) internal {\\n        require(addr != address(0), \\\"ERR_NULL_ADDRESS\\\");\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    string  internal _name;\\n    string  internal _symbol;\\n    uint8   private _decimals;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return 18;\\n    }\\n\\n    function allowance(address src, address dst) external override view returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external override view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public override view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _validateAddress(dst);\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _validateAddress(dst);\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        _validateAddress(dst);\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(src, msg.sender, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BNum.sol\\\";\\nimport \\\"../interfaces/BMathInterface.sol\\\";\\n\\ncontract BMath is BConst, BNum, BMathInterface {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        public pure virtual\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure virtual\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure virtual override\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure virtual\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        ///  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        public pure virtual override\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight);\\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      //       pS - pAi        \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee\\n    )\\n        public pure virtual\\n        returns (uint tokenAmountOut)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        uint newPoolSupply = bsub(poolSupply, poolAmountIn);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side\\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight                                                                          //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure virtual\\n        returns (uint poolAmountIn)\\n    {\\n\\n        // charge swap fee on the output token side\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee);\\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountIn = bsub(poolSupply, newPoolSupply);\\n        return poolAmountIn;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolRestrictions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IPoolRestrictions {\\n  function getMaxTotalSupply(address _pool) external view returns (uint256);\\n\\n  function isVotingSignatureAllowed(address _votingAddress, bytes4 _signature) external view returns (bool);\\n\\n  function isVotingSenderAllowed(address _votingAddress, address _sender) external view returns (bool);\\n\\n  function isWithoutFee(address _addr) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BPoolInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./BMathInterface.sol\\\";\\n\\ninterface BPoolInterface is IERC20, BMathInterface {\\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n  function swapExactAmountIn(\\n    address,\\n    uint256,\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256, uint256);\\n\\n  function swapExactAmountOut(\\n    address,\\n    uint256,\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256, uint256);\\n\\n  function joinswapExternAmountIn(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function joinswapPoolAmountOut(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function exitswapPoolAmountIn(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function exitswapExternAmountOut(\\n    address,\\n    uint256,\\n    uint256\\n  ) external returns (uint256);\\n\\n  function getDenormalizedWeight(address) external view returns (uint256);\\n\\n  function getBalance(address) external view returns (uint256);\\n\\n  function getSwapFee() external view returns (uint256);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getCommunityFee()\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      address\\n    );\\n\\n  function calcAmountWithCommunityFee(\\n    uint256,\\n    uint256,\\n    address\\n  ) external view returns (uint256, uint256);\\n\\n  function getRestrictions() external view returns (address);\\n\\n  function isSwapsDisabled() external view returns (bool);\\n\\n  function isFinalized() external view returns (bool);\\n\\n  function isBound(address t) external view returns (bool);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function getFinalTokens() external view returns (address[] memory tokens);\\n\\n  function setSwapFee(uint256) external;\\n\\n  function setCommunityFeeAndReceiver(\\n    uint256,\\n    uint256,\\n    uint256,\\n    address\\n  ) external;\\n\\n  function setController(address) external;\\n\\n  function setSwapsDisabled(bool) external;\\n\\n  function finalize() external;\\n\\n  function bind(\\n    address,\\n    uint256,\\n    uint256\\n  ) external;\\n\\n  function rebind(\\n    address,\\n    uint256,\\n    uint256\\n  ) external;\\n\\n  function unbind(address) external;\\n\\n  function gulp(address) external;\\n\\n  function callVoting(\\n    address voting,\\n    bytes4 signature,\\n    bytes calldata args,\\n    uint256 value\\n  ) external;\\n\\n  function getMinWeight() external view returns (uint256);\\n\\n  function getMaxBoundTokens() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n      require(b > 0, \\\"ERR_DIV_ZERO\\\");\\n      return a / b;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);\\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/balancer-core/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.6.12;\\n\\ncontract BConst {\\n    uint public constant BONE              = 10**18;\\n    // Minimum number of tokens in the pool\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    // Maximum number of tokens in the pool\\n    uint public constant MAX_BOUND_TOKENS  = 21;\\n    // Minimum swap fee\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    // Maximum swap fee\\n    uint public constant MAX_FEE           = BONE / 10;\\n    // Minimum weight for token\\n    uint public constant MIN_WEIGHT        = 1000000000;\\n    // Maximum weight for token\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    // Maximum total weight\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    // Minimum balance for a token\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n    // Initial pool tokens supply\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n    // Maximum input tokens balance ratio for swaps.\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    // Maximum output tokens balance ratio for swaps.\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BMathInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface BMathInterface {\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) external pure returns (uint256 tokenAmountIn);\\n\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) external pure returns (uint256 tokenAmountIn);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voting\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"inputSig\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"outputData\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL_VOTING\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_COMMUNITY_FEE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromDenorm\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"}],\"name\":\"SetDynamicWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"name\":\"SetWeightPerSecondBounds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"calcAmountWithCommunityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountInAfterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleInGivenPoolOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calcTokensForAmount\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voting\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"signature\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"callVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommunityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"communitySwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityJoinFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityExitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"communityFeeReceiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDynamicWeightSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromDenorm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBoundTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRestrictions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeightPerSecondBounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrapperMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapsDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"rebind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"communitySwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityJoinFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityExitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"communityFeeReceiver\",\"type\":\"address\"}],\"name\":\"setCommunityFeeAndReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetDenorm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTimestamp\",\"type\":\"uint256\"}],\"name\":\"setDynamicWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPoolRestrictions\",\"name\":\"restrictions\",\"type\":\"address\"}],\"name\":\"setRestrictions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled_\",\"type\":\"bool\"}],\"name\":\"setSwapsDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minWeightPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWeightPerSecond\",\"type\":\"uint256\"}],\"name\":\"setWeightPerSecondBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"wrapperMode\",\"type\":\"bool\"}],\"name\":\"setWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MatrixPool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"2","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}