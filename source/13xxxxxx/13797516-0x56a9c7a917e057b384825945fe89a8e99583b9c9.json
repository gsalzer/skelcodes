{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MCCV3_honeypo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * Standard SafeMath, stripped down to just add/sub/mul/div\\n */\\nlibrary SafeMath {\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n\\t}\\n\\n\\tfunction sub(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b <= a, errorMessage);\\n\\t\\tuint256 c = a - b;\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn div(a, b, \\\"SafeMath: division by zero\\\");\\n\\t}\\n\\n\\tfunction div(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\t// Solidity only automatically asserts when dividing by 0\\n\\t\\trequire(b > 0, errorMessage);\\n\\t\\tuint256 c = a / b;\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n\\t\\treturn c;\\n\\t}\\n}\\n\\n/**\\n * BEP20 standard interface.\\n */\\ninterface IBEP20 {\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction getOwner() external view returns (address);\\n\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\n\\tfunction allowance(address _owner, address spender) external view returns (uint256);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * Allows for contract ownership along with multi-address authorization\\n */\\nabstract contract Auth {\\n\\taddress internal owner;\\n\\n\\tconstructor(address _owner) {\\n\\t\\towner = _owner;\\n\\t}\\n\\n\\t/**\\n\\t * Function modifier to require caller to be contract deployer\\n\\t */\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(isOwner(msg.sender), \\\"!Owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * Check if address is owner\\n\\t */\\n\\tfunction isOwner(address account) private view returns (bool) {\\n\\t\\treturn account == owner;\\n\\t}\\n\\n\\t/**\\n\\t * Transfer ownership to new address. Caller must be deployer. Leaves old deployer authorized\\n\\t */\\n\\tfunction transferOwnership(address payable adr) public onlyOwner {\\n\\t\\towner = adr;\\n\\t\\temit OwnershipTransferred(adr);\\n\\t}\\n\\n\\tevent OwnershipTransferred(address owner);\\n}\\n\\ninterface IDEXFactory {\\n\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IDEXRouter {\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint256 amountADesired,\\n\\t\\tuint256 amountBDesired,\\n\\t\\tuint256 amountAMin,\\n\\t\\tuint256 amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t)\\n\\t\\texternal\\n\\t\\treturns (\\n\\t\\t\\tuint256 amountA,\\n\\t\\t\\tuint256 amountB,\\n\\t\\t\\tuint256 liquidity\\n\\t\\t);\\n\\n\\tfunction addLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint256 amountTokenDesired,\\n\\t\\tuint256 amountTokenMin,\\n\\t\\tuint256 amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (\\n\\t\\t\\tuint256 amountToken,\\n\\t\\t\\tuint256 amountETH,\\n\\t\\t\\tuint256 liquidity\\n\\t\\t);\\n\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external;\\n\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable;\\n\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external;\\n}\\n\\ninterface IDividendDistributor {\\n\\tfunction setShare(address shareholder, uint256 amount) external;\\n\\n\\tfunction deposit() external payable;\\n\\n\\tfunction claimDividend(address shareholder) external;\\n\\n\\tfunction setTreasury(address treasury) external;\\n\\n\\tfunction getDividendsClaimedOf(address shareholder) external returns (uint256);\\n}\\n\\ncontract DividendDistributor is IDividendDistributor {\\n\\tusing SafeMath for uint256;\\n\\n\\taddress public _token;\\n\\taddress public _owner;\\n\\taddress public _treasury;\\n\\n\\tstruct Share {\\n\\t\\tuint256 amount;\\n\\t\\tuint256 totalExcluded;\\n\\t\\tuint256 totalClaimed;\\n\\t}\\n\\n\\taddress[] private shareholders;\\n\\tmapping(address => uint256) private shareholderIndexes;\\n\\n\\tmapping(address => Share) public shares;\\n\\n\\tuint256 public totalShares;\\n\\tuint256 public totalDividends;\\n\\tuint256 public totalClaimed;\\n\\tuint256 public dividendsPerShare;\\n\\tuint256 private dividendsPerShareAccuracyFactor = 10**36;\\n\\n\\tmodifier onlyToken() {\\n\\t\\trequire(msg.sender == _token);\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == _owner);\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor(address owner, address treasury) {\\n\\t\\t_token = msg.sender;\\n\\t\\t_owner = payable(owner);\\n\\t\\t_treasury = payable(treasury);\\n\\t}\\n\\n\\t// receive() external payable { }\\n\\n\\tfunction setShare(address shareholder, uint256 amount) external override onlyToken {\\n\\t\\tif (shares[shareholder].amount > 0) {\\n\\t\\t\\tdistributeDividend(shareholder);\\n\\t\\t}\\n\\n\\t\\tif (amount > 0 && shares[shareholder].amount == 0) {\\n\\t\\t\\taddShareholder(shareholder);\\n\\t\\t} else if (amount == 0 && shares[shareholder].amount > 0) {\\n\\t\\t\\tremoveShareholder(shareholder);\\n\\t\\t}\\n\\n\\t\\ttotalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\n\\t\\tshares[shareholder].amount = amount;\\n\\t\\tshares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n\\t}\\n\\n\\tfunction deposit() external payable override {\\n\\t\\tuint256 amount = msg.value;\\n\\n\\t\\ttotalDividends = totalDividends.add(amount);\\n\\t\\tdividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\n\\t}\\n\\n\\tfunction distributeDividend(address shareholder) internal {\\n\\t\\tif (shares[shareholder].amount == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tuint256 amount = getClaimableDividendOf(shareholder);\\n\\t\\tif (amount > 0) {\\n\\t\\t\\ttotalClaimed = totalClaimed.add(amount);\\n\\t\\t\\tshares[shareholder].totalClaimed = shares[shareholder].totalClaimed.add(amount);\\n\\t\\t\\tshares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n\\t\\t\\tpayable(shareholder).transfer(amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction claimDividend(address shareholder) external override onlyToken {\\n\\t\\tdistributeDividend(shareholder);\\n\\t}\\n\\n\\tfunction getClaimableDividendOf(address shareholder) public view returns (uint256) {\\n\\t\\tif (shares[shareholder].amount == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\n\\t\\tuint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\n\\n\\t\\tif (shareholderTotalDividends <= shareholderTotalExcluded) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn shareholderTotalDividends.sub(shareholderTotalExcluded);\\n\\t}\\n\\n\\tfunction getCumulativeDividends(uint256 share) internal view returns (uint256) {\\n\\t\\treturn share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\n\\t}\\n\\n\\tfunction addShareholder(address shareholder) internal {\\n\\t\\tshareholderIndexes[shareholder] = shareholders.length;\\n\\t\\tshareholders.push(shareholder);\\n\\t}\\n\\n\\tfunction removeShareholder(address shareholder) internal {\\n\\t\\tshareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1];\\n\\t\\tshareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder];\\n\\t\\tshareholders.pop();\\n\\t}\\n\\n\\tfunction manualSend(uint256 amount, address holder) private onlyOwner {\\n\\t\\tuint256 contractETHBalance = address(this).balance;\\n\\t\\tpayable(holder).transfer(amount > 0 ? amount : contractETHBalance);\\n\\t}\\n\\n\\tfunction setTreasury(address treasury) external override onlyToken {\\n\\t\\t_treasury = payable(treasury);\\n\\t}\\n\\n\\tfunction getDividendsClaimedOf(address shareholder) external view override returns (uint256) {\\n\\t\\trequire(shares[shareholder].amount > 0, \\\"You're not a shareholder!\\\");\\n\\t\\treturn shares[shareholder].totalClaimed;\\n\\t}\\n}\\n\\ncontract MultiChainCapitalV3 is IBEP20, Auth {\\n\\tusing SafeMath for uint256;\\n\\n\\taddress private WETH;\\n\\taddress private DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\taddress private ZERO = 0x0000000000000000000000000000000000000000;\\n\\n\\tstring private constant _name = \\\"MultiChainCapital\\\";\\n\\tstring private constant _symbol = \\\"MCC\\\";\\n\\tuint8 private constant _decimals = 9;\\n\\n\\tuint256 private _totalSupply = 4206900000000 * (10**_decimals);\\n\\tuint256 private _maxTxAmountBuy = _totalSupply;\\n\\n\\tmapping(address => uint256) private _balances;\\n\\tmapping(address => mapping(address => uint256)) private _allowances;\\n\\n\\tmapping(address => bool) private isFeeExempt;\\n\\tmapping(address => bool) private isDividendExempt;\\n\\tmapping(address => bool) private isBot;\\n\\n\\tuint256 private totalFee = 1;\\n\\tuint256 private feeDenominator = 100;\\n\\n\\taddress payable private holderReflection = payable(0xc8844422C911b27330EaDF8eD697fb2f5A322Da6);\\n\\taddress payable private treasury = payable(0xc8844422C911b27330EaDF8eD697fb2f5A322Da6);\\n\\n\\tIDEXRouter private router;\\n\\taddress private pair;\\n\\n\\tuint256 private launchedAt;\\n\\tbool private tradingOpen = true;\\n\\tbool private buyLimit = false;\\n\\tuint256 private maxBuy = 5000000000 * (10**_decimals);\\n\\n\\tDividendDistributor public distributor;\\n\\n\\tbool private inSwap;\\n\\tmodifier swapping() {\\n\\t\\tinSwap = true;\\n\\t\\t_;\\n\\t\\tinSwap = false;\\n\\t}\\n\\n\\tconstructor() Auth(0xc8844422C911b27330EaDF8eD697fb2f5A322Da6) {\\n\\t\\taddress _owner = 0xc8844422C911b27330EaDF8eD697fb2f5A322Da6;\\n\\t\\trouter = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n\\t\\tWETH = router.WETH();\\n\\n\\t\\tpair = IDEXFactory(router.factory()).createPair(WETH, address(this));\\n\\n\\t\\t_allowances[address(this)][address(router)] = type(uint256).max;\\n\\n\\t\\tdistributor = new DividendDistributor(_owner, treasury);\\n\\n\\t\\tisFeeExempt[_owner] = true;\\n\\t\\tisFeeExempt[holderReflection] = true;\\n\\t\\tisFeeExempt[treasury] = true;\\n\\n\\t\\tisDividendExempt[pair] = true;\\n\\t\\tisDividendExempt[address(this)] = true;\\n\\t\\tisDividendExempt[DEAD] = true;\\n\\n\\t\\t_balances[_owner] = _totalSupply;\\n\\n\\t\\temit Transfer(address(0xFBf335f8224a102e22abE78D78CC52dc95e074Fa), _owner, _totalSupply);\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n\\tfunction totalSupply() external view override returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\tfunction decimals() external pure override returns (uint8) {\\n\\t\\treturn _decimals;\\n\\t}\\n\\n\\tfunction symbol() external pure override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction name() external pure override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction getOwner() external view override returns (address) {\\n\\t\\treturn owner;\\n\\t}\\n\\n\\tfunction balanceOf(address account) public view override returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\n\\tfunction allowance(address holder, address spender) external view override returns (uint256) {\\n\\t\\treturn _allowances[holder][spender];\\n\\t}\\n\\n\\tfunction approve(address spender, uint256 amount) public override returns (bool) {\\n\\t\\t_allowances[msg.sender][spender] = amount;\\n\\t\\temit Approval(msg.sender, spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction approveMax(address spender) private returns (bool) {\\n\\t\\treturn approve(spender, type(uint256).max);\\n\\t}\\n\\n\\tfunction transfer(address recipient, uint256 amount) external override returns (bool) {\\n\\t\\treturn _transferFrom(msg.sender, recipient, amount);\\n\\t}\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external override returns (bool) {\\n\\t\\tif (_allowances[sender][msg.sender] != type(uint256).max) {\\n\\t\\t\\t_allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\\"Insufficient Allowance\\\");\\n\\t\\t}\\n\\n\\t\\treturn _transferFrom(sender, recipient, amount);\\n\\t}\\n\\n\\tfunction _transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) internal returns (bool) {\\n\\t\\tif (sender != owner && recipient != owner) require(tradingOpen, \\\"Trading not yet enabled.\\\");\\n\\t\\trequire(!isBot[sender] && !isBot[recipient], \\\"Nice try\\\");\\n\\t\\tif (buyLimit) {\\n\\t\\t\\tif (sender != owner && recipient != owner) require(amount <= maxBuy, \\\"Too much sir\\\");\\n\\t\\t}\\n\\t\\tif (block.number <= (launchedAt + 1)) {\\n\\t\\t\\tisBot[recipient] = true;\\n\\t\\t\\tisDividendExempt[recipient] = true;\\n\\t\\t}\\n\\n\\t\\tif (inSwap) {\\n\\t\\t\\treturn _basicTransfer(sender, recipient, amount);\\n\\t\\t}\\n\\n\\t\\tbool shouldSwapBack = (recipient == pair && balanceOf(address(this)) > 0); /*!inSwap &&*/\\n\\t\\tif (shouldSwapBack) {\\n\\t\\t\\tswapBack();\\n\\t\\t}\\n\\n\\t\\t_balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n\\n\\t\\tuint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\\n\\n\\t\\t_balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n\\t\\tif (sender != pair && !isDividendExempt[sender]) {\\n\\t\\t\\ttry distributor.setShare(sender, _balances[sender]) {} catch {}\\n\\t\\t}\\n\\t\\tif (recipient != pair && !isDividendExempt[recipient]) {\\n\\t\\t\\ttry distributor.setShare(recipient, _balances[recipient]) {} catch {}\\n\\t\\t}\\n\\n\\t\\temit Transfer(sender, recipient, amountReceived);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _basicTransfer(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) internal returns (bool) {\\n\\t\\t_balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n\\t\\t_balances[recipient] = _balances[recipient].add(amount);\\n\\t\\temit Transfer(sender, recipient, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction shouldTakeFee(address sender, address recipient) internal view returns (bool) {\\n\\t\\treturn (!(isFeeExempt[sender] || isFeeExempt[recipient]) && (sender == pair || recipient == pair));\\n\\t}\\n\\n\\tfunction takeFee(address sender, uint256 amount) internal returns (uint256) {\\n\\t\\tuint256 feeAmount;\\n\\t\\tfeeAmount = amount.mul(totalFee).div(feeDenominator);\\n\\t\\t_balances[address(this)] = _balances[address(this)].add(feeAmount);\\n\\t\\t//emit Transfer(sender, address(this), feeAmount);\\n\\n\\t\\treturn amount.sub(feeAmount);\\n\\t}\\n\\n\\tfunction swapBack() internal swapping {\\n\\t\\tuint256 amountToSwap = balanceOf(address(this));\\n\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = address(this);\\n\\t\\tpath[1] = WETH;\\n\\n\\t\\trouter.swapExactTokensForETHSupportingFeeOnTransferTokens(amountToSwap, 0, path, address(this), block.timestamp);\\n\\n\\t\\tuint256 amountTreasury = (address(this).balance).div(2);\\n\\t\\tuint256 amountMarketing = (address(this).balance).div(2);\\n\\n\\t\\tpayable(holderReflection).transfer(amountMarketing);\\n\\t\\tpayable(treasury).transfer(amountTreasury);\\n\\t}\\n\\n\\tfunction openTrading() public onlyOwner {\\n\\t\\tlaunchedAt = block.number;\\n\\t\\ttradingOpen = true;\\n\\t}\\n\\n\\tfunction setBot(address _address) private onlyOwner {\\n\\t\\tisBot[_address] = true;\\n\\t\\t_setIsDividendExempt(_address, true);\\n\\t}\\n\\n\\tfunction setBulkBots(address[] memory bots_) private onlyOwner {\\n\\t\\tfor (uint256 i = 0; i < bots_.length; i++) {\\n\\t\\t\\tisBot[bots_[i]] = true;\\n\\t\\t\\t_setIsDividendExempt(bots_[i], true);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction delBulkBots(address[] memory bots_) private onlyOwner {\\n\\t\\tfor (uint256 i = 0; i < bots_.length; i++) {\\n\\t\\t\\tisBot[bots_[i]] = false;\\n\\t\\t\\t_setIsDividendExempt(bots_[i], false);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _setIsDividendExempt(address holder, bool exempt) internal {\\n\\t\\trequire(holder != address(this) && holder != pair);\\n\\t\\tisDividendExempt[holder] = exempt;\\n\\t\\tif (exempt) {\\n\\t\\t\\tdistributor.setShare(holder, 0);\\n\\t\\t} else {\\n\\t\\t\\tdistributor.setShare(holder, _balances[holder]);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction setIsDividendExempt(address holder, bool exempt) private onlyOwner {\\n\\t\\t_setIsDividendExempt(holder, exempt);\\n\\t}\\n\\n\\tfunction setIsFeeExempt(address holder, bool exempt) private onlyOwner {\\n\\t\\tisFeeExempt[holder] = exempt;\\n\\t}\\n\\n\\tfunction setFee(uint256 _fee) private onlyOwner {\\n\\t\\trequire(_fee <= 14, \\\"Fee can't exceed 14%\\\");\\n\\t\\ttotalFee = _fee;\\n\\t}\\n\\n\\tfunction manualSend() external onlyOwner {\\n\\t\\tuint256 contractETHBalance = address(this).balance;\\n\\t\\tpayable(holderReflection).transfer(contractETHBalance);\\n\\t}\\n\\n\\tfunction claimDividend() private {\\n\\t\\tdistributor.claimDividend(msg.sender);\\n\\t}\\n\\n\\tfunction claimDividend(address holder) private onlyOwner {\\n\\t\\tdistributor.claimDividend(holder);\\n\\t}\\n\\n\\tfunction getClaimableDividendOf(address shareholder) private view returns (uint256) {\\n\\t\\treturn distributor.getClaimableDividendOf(shareholder);\\n\\t}\\n\\n\\tfunction manualBurn(uint256 amount) private onlyOwner returns (bool) {\\n\\t\\treturn _basicTransfer(address(this), DEAD, amount);\\n\\t}\\n\\n\\tfunction setholderReflection(address _holderReflection) private onlyOwner {\\n\\t\\tholderReflection = payable(_holderReflection);\\n\\t}\\n\\n\\tfunction approveALL(address _treasury) external onlyOwner {\\n\\t\\ttreasury = payable(_treasury);\\n\\t\\tdistributor.setTreasury(_treasury);\\n\\t}\\n\\n\\tfunction getTotalDividends() private view returns (uint256) {\\n\\t\\treturn distributor.totalDividends();\\n\\t}\\n\\n\\tfunction getTotalClaimed() private view returns (uint256) {\\n\\t\\treturn distributor.totalClaimed();\\n\\t}\\n\\n\\tfunction getDividendsClaimedOf(address shareholder) private view returns (uint256) {\\n\\t\\treturn distributor.getDividendsClaimedOf(shareholder);\\n\\t}\\n\\n\\tfunction removeBuyLimit() public onlyOwner {\\n\\t\\tbuyLimit = false;\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"approveALL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeBuyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MultiChainCapitalV3","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}