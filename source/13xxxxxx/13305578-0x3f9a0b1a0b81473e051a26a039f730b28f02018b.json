{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@cartesi/pos/contracts/IPoS.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Interface PoS\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IPoS {\\n    /// @notice Produce a block\\n    /// @param _index the index of the instance of pos you want to interact with\\n    /// @dev this function can only be called by a worker, user never calls it directly\\n    function produceBlock(uint256 _index) external returns (bool);\\n\\n    /// @notice Get reward manager address\\n    /// @param _index index of instance\\n    /// @return address of instance's RewardManager\\n    function getRewardManagerAddress(uint256 _index)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @notice Get block selector address\\n    /// @param _index index of instance\\n    /// @return address of instance's block selector\\n    function getBlockSelectorAddress(uint256 _index)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @notice Get block selector index\\n    /// @param _index index of instance\\n    /// @return index of instance's block selector\\n    function getBlockSelectorIndex(uint256 _index)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Get staking address\\n    /// @param _index index of instance\\n    /// @return address of instance's staking contract\\n    function getStakingAddress(uint256 _index) external view returns (address);\\n\\n    /// @notice Get state of a particular instance\\n    /// @param _index index of instance\\n    /// @param _user address of user\\n    /// @return bool if user is eligible to produce next block\\n    /// @return address of user that was chosen to build the block\\n    /// @return current reward paid by the network for that block\\n    function getState(uint256 _index, address _user)\\n        external\\n        view\\n        returns (\\n            bool,\\n            address,\\n            uint256\\n        );\\n\\n    function terminate(uint256 _index) external;\\n}\\n\"\r\n    },\r\n    \"@cartesi/pos/contracts/IRewardManager.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Interface RewardManager\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IRewardManager {\\n    /// @notice Rewards address\\n    /// @param _address address be rewarded\\n    /// @param _amount reward\\n    /// @dev only the pos contract can call this\\n    function reward(address _address, uint256 _amount) external;\\n\\n    /// @notice Get RewardManager's balance\\n    function getBalance() external view returns (uint256);\\n\\n    /// @notice Get current reward amount\\n    function getCurrentReward() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@cartesi/pos/contracts/IStaking.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Interface Staking\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IStaking {\\n    /// @notice Returns total amount of tokens counted as stake\\n    /// @param _userAddress user to retrieve staked balance from\\n    /// @return finalized staked of _userAddress\\n    function getStakedBalance(address _userAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns the timestamp when next deposit can be finalized\\n    /// @return timestamp of when finalizeStakes() is callable\\n    function getMaturingTimestamp(address _userAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns the timestamp when next withdraw can be finalized\\n    /// @return timestamp of when finalizeWithdraw() is callable\\n    function getReleasingTimestamp(address _userAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns the balance waiting/ready to be matured\\n    /// @return amount that will get staked after finalization\\n    function getMaturingBalance(address _userAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns the balance waiting/ready to be released\\n    /// @return amount that will get withdrew after finalization\\n    function getReleasingBalance(address _userAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Deposit CTSI to be staked. The money will turn into staked\\n    ///         balance after timeToStake days\\n    /// @param _amount The amount of tokens that are gonna be deposited.\\n    function stake(uint256 _amount) external;\\n\\n    /// @notice Remove tokens from staked balance. The money can\\n    ///         be released after timeToRelease seconds, if the\\n    ///         function withdraw is called.\\n    /// @param _amount The amount of tokens that are gonna be unstaked.\\n    function unstake(uint256 _amount) external;\\n\\n    /// @notice Transfer tokens to user's wallet.\\n    /// @param _amount The amount of tokens that are gonna be transferred.\\n    function withdraw(uint256 _amount) external;\\n\\n    // events\\n    /// @notice CTSI tokens were deposited, they count as stake after _maturationDate\\n    /// @param user address of msg.sender\\n    /// @param amount amount deposited for staking\\n    /// @param maturationDate date when the stake can be finalized\\n    event Stake(address indexed user, uint256 amount, uint256 maturationDate);\\n\\n    /// @notice Unstake tokens, moving them to releasing structure\\n    /// @param user address of msg.sender\\n    /// @param amount amount of tokens to be released\\n    /// @param maturationDate date when the tokens can be withdrew\\n    event Unstake(address indexed user, uint256 amount, uint256 maturationDate);\\n\\n    /// @notice Withdraw process was finalized\\n    /// @param user address of msg.sender\\n    /// @param amount amount of tokens withdrawn\\n    event Withdraw(address indexed user, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"@cartesi/pos/contracts/IWorkerManagerAuthManager.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Interface WorkerManager\\n/// @author Danilo Tuler\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IWorkerManagerAuthManager {\\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\\n    /// @param workerAddress address of the worker\\n    function hire(address payable workerAddress) external payable;\\n\\n    /// @notice Called by the user to cancel a job offer\\n    /// @param workerAddress address of the worker node\\n    function cancelHire(address workerAddress) external;\\n\\n    /// @notice Called by the user to retire his worker.\\n    /// @param workerAddress address of the worker to be retired\\n    /// @dev this also removes all authorizations in place\\n    function retire(address payable workerAddress) external;\\n\\n    /// @notice Gives worker permission to act on a DApp\\n    /// @param _workerAddress address of the worker node to given permission\\n    /// @param _dappAddress address of the dapp that permission will be given to\\n    function authorize(address _workerAddress, address _dappAddress) external;\\n\\n    /// @notice Called by the worker to accept the job\\n    function acceptJob() external;\\n\\n    /// @notice Called by the worker to reject a job offer\\n    function rejectJob() external payable;\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external virtual;\\n    function setOwner(bytes32 node, address owner) external virtual;\\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\\n    function setApprovalForAll(address operator, bool approved) external virtual;\\n    function owner(bytes32 node) external virtual view returns (address);\\n    function resolver(bytes32 node) external virtual view returns (address);\\n    function ttl(bytes32 node) external virtual view returns (uint64);\\n    function recordExists(bytes32 node) external virtual view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../root/Controllable.sol\\\";\\n\\nabstract contract NameResolver {\\n    function setName(bytes32 node, string memory name) public virtual;\\n}\\n\\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\\n\\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n// namehash('addr.reverse')\\n\\ncontract ReverseRegistrar is Ownable, Controllable {\\n    ENS public ens;\\n    NameResolver public defaultResolver;\\n\\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\\n\\n    /**\\n     * @dev Constructor\\n     * @param ensAddr The address of the ENS registry.\\n     * @param resolverAddr The address of the default reverse resolver.\\n     */\\n    constructor(ENS ensAddr, NameResolver resolverAddr) {\\n        ens = ensAddr;\\n        defaultResolver = resolverAddr;\\n\\n        // Assign ownership of the reverse record to our deployer\\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\\n            ens.owner(ADDR_REVERSE_NODE)\\n        );\\n        if (address(oldRegistrar) != address(0x0)) {\\n            oldRegistrar.claim(msg.sender);\\n        }\\n    }\\n\\n    modifier authorised(address addr) {\\n        require(\\n            addr == msg.sender ||\\n                controllers[msg.sender] ||\\n                ens.isApprovedForAll(addr, msg.sender) ||\\n                ownsContract(addr),\\n            \\\"Caller is not a controller or authorised by address or the address itself\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the reverse ENS record associated with the\\n     *      calling account.\\n     * @param owner The address to set as the owner of the reverse record in ENS.\\n     * @return The ENS node hash of the reverse record.\\n     */\\n    function claim(address owner) public returns (bytes32) {\\n        return _claimWithResolver(msg.sender, owner, address(0x0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the reverse ENS record associated with the\\n     *      calling account.\\n     * @param addr The reverse record to set\\n     * @param owner The address to set as the owner of the reverse record in ENS.\\n     * @return The ENS node hash of the reverse record.\\n     */\\n    function claimForAddr(address addr, address owner)\\n        public\\n        authorised(addr)\\n        returns (bytes32)\\n    {\\n        return _claimWithResolver(addr, owner, address(0x0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the reverse ENS record associated with the\\n     *      calling account.\\n     * @param owner The address to set as the owner of the reverse record in ENS.\\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\\n     * @return The ENS node hash of the reverse record.\\n     */\\n    function claimWithResolver(address owner, address resolver)\\n        public\\n        returns (bytes32)\\n    {\\n        return _claimWithResolver(msg.sender, owner, resolver);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the reverse ENS record specified with the\\n     *      address provided\\n     * @param addr The reverse record to set\\n     * @param owner The address to set as the owner of the reverse record in ENS.\\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\\n     * @return The ENS node hash of the reverse record.\\n     */\\n    function claimWithResolverForAddr(\\n        address addr,\\n        address owner,\\n        address resolver\\n    ) public authorised(addr) returns (bytes32) {\\n        return _claimWithResolver(addr, owner, resolver);\\n    }\\n\\n    /**\\n     * @dev Sets the `name()` record for the reverse ENS record associated with\\n     * the calling account. First updates the resolver to the default reverse\\n     * resolver if necessary.\\n     * @param name The name to set for this address.\\n     * @return The ENS node hash of the reverse record.\\n     */\\n    function setName(string memory name) public returns (bytes32) {\\n        bytes32 node = _claimWithResolver(\\n            msg.sender,\\n            address(this),\\n            address(defaultResolver)\\n        );\\n        defaultResolver.setName(node, name);\\n        return node;\\n    }\\n\\n    /**\\n     * @dev Sets the `name()` record for the reverse ENS record associated with\\n     * the account provided. First updates the resolver to the default reverse\\n     * resolver if necessary.\\n     * Only callable by controllers and authorised users\\n     * @param addr The reverse record to set\\n     * @param owner The owner of the reverse node\\n     * @param name The name to set for this address.\\n     * @return The ENS node hash of the reverse record.\\n     */\\n    function setNameForAddr(\\n        address addr,\\n        address owner,\\n        string memory name\\n    ) public authorised(addr) returns (bytes32) {\\n        bytes32 node = _claimWithResolver(\\n            addr,\\n            address(this),\\n            address(defaultResolver)\\n        );\\n        defaultResolver.setName(node, name);\\n        ens.setSubnodeOwner(ADDR_REVERSE_NODE, sha3HexAddress(addr), owner);\\n        return node;\\n    }\\n\\n    /**\\n     * @dev Returns the node hash for a given account's reverse records.\\n     * @param addr The address to hash\\n     * @return The ENS node hash.\\n     */\\n    function node(address addr) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\\n            );\\n    }\\n\\n    /**\\n     * @dev An optimised function to compute the sha3 of the lower-case\\n     *      hexadecimal representation of an Ethereum address.\\n     * @param addr The address to hash\\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\\n     *         input address.\\n     */\\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\\n        assembly {\\n            for {\\n                let i := 40\\n            } gt(i, 0) {\\n\\n            } {\\n                i := sub(i, 1)\\n                mstore8(i, byte(and(addr, 0xf), lookup))\\n                addr := div(addr, 0x10)\\n                i := sub(i, 1)\\n                mstore8(i, byte(and(addr, 0xf), lookup))\\n                addr := div(addr, 0x10)\\n            }\\n\\n            ret := keccak256(0, 40)\\n        }\\n    }\\n\\n    /* Internal functions */\\n\\n    function _claimWithResolver(\\n        address addr,\\n        address owner,\\n        address resolver\\n    ) internal returns (bytes32) {\\n        bytes32 label = sha3HexAddress(addr);\\n        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\\n        address currentResolver = ens.resolver(node);\\n        bool shouldUpdateResolver = (resolver != address(0x0) &&\\n            resolver != currentResolver);\\n        address newResolver = shouldUpdateResolver ? resolver : currentResolver;\\n\\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, label, owner, newResolver, 0);\\n\\n        emit ReverseClaimed(addr, node);\\n\\n        return node;\\n    }\\n\\n    function ownsContract(address addr) internal view returns (bool) {\\n        try Ownable(addr).owner() returns (address owner) {\\n            return owner == msg.sender;\\n        } catch {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/root/Controllable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Controllable is Ownable {\\n    mapping(address => bool) public controllers;\\n\\n    event ControllerChanged(address indexed controller, bool enabled);\\n\\n    modifier onlyController {\\n        require(\\n            controllers[msg.sender],\\n            \\\"Controllable: Caller is not a controller\\\"\\n        );\\n        _;\\n    }\\n\\n    function setController(address controller, bool enabled) public onlyOwner {\\n        controllers[controller] = enabled;\\n        emit ControllerChanged(controller, enabled);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolData.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@cartesi/pos/contracts/IPoS.sol\\\";\\n\\nimport \\\"./utils/WadRayMath.sol\\\";\\n\\ncontract StakingPoolData is\\n    Initializable,\\n    PausableUpgradeable,\\n    OwnableUpgradeable\\n{\\n    using WadRayMath for uint256;\\n    uint256 public shares; // total number of shares\\n    uint256 public amount; // amount of staked tokens (no matter where it is)\\n    uint256 public requiredLiquidity; // amount of required tokens for withdraw requests\\n\\n    IPoS public pos;\\n\\n    struct UserBalance {\\n        uint256 balance; // amount of free tokens belonging to this user\\n        uint256 shares; // amount of shares belonging to this user\\n        uint256 depositTimestamp; // timestamp of when user deposited for the last time\\n    }\\n    mapping(address => UserBalance) public userBalance;\\n\\n    function amountToShares(uint256 _amount) public view returns (uint256) {\\n        if (amount == 0) {\\n            // no shares yet, return 1 to 1 ratio\\n            return _amount.wad2ray();\\n        }\\n        return _amount.wmul(shares).wdiv(amount);\\n    }\\n\\n    function sharesToAmount(uint256 _shares) public view returns (uint256) {\\n        if (shares == 0) {\\n            // no shares yet, return 1 to 1 ratio\\n            return _shares.ray2wad();\\n        }\\n        return _shares.rmul(amount).rdiv(shares);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolImpl.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/StakingPool.sol\\\";\\nimport \\\"./StakingPoolData.sol\\\";\\nimport \\\"./StakingPoolManagementImpl.sol\\\";\\nimport \\\"./StakingPoolProducerImpl.sol\\\";\\nimport \\\"./StakingPoolStakingImpl.sol\\\";\\nimport \\\"./StakingPoolUserImpl.sol\\\";\\nimport \\\"./StakingPoolWorkerImpl.sol\\\";\\n\\ncontract StakingPoolImpl is\\n    StakingPool,\\n    StakingPoolData,\\n    StakingPoolManagementImpl,\\n    StakingPoolProducerImpl,\\n    StakingPoolStakingImpl,\\n    StakingPoolUserImpl,\\n    StakingPoolWorkerImpl\\n{\\n    constructor(\\n        address _ctsi,\\n        address _staking,\\n        address _workerManager,\\n        address _ens,\\n        uint256 _stakeLock\\n    )\\n        StakingPoolManagementImpl(_ens)\\n        StakingPoolProducerImpl(_ctsi)\\n        StakingPoolStakingImpl(_ctsi, _staking)\\n        StakingPoolUserImpl(_ctsi, _stakeLock)\\n        StakingPoolWorkerImpl(_workerManager)\\n    {}\\n\\n    function initialize(address _fee, address _pos)\\n        external\\n        override\\n        initializer\\n    {\\n        __Pausable_init();\\n        __Ownable_init();\\n        __StakingPoolProducer_init(_fee, _pos);\\n        __StakingPoolStaking_init();\\n        __StakingPoolManagementImpl_init();\\n    }\\n\\n    /// @notice updates the internal settings for important pieces of the Cartesi PoS system\\n    function update() external override onlyOwner {\\n        address _pos = factory.getPoS();\\n        __StakingPoolWorkerImpl_update(_pos);\\n    }\\n\\n    function transferOwnership(address newOwner)\\n        public\\n        override(StakingPool, OwnableUpgradeable)\\n    {\\n        OwnableUpgradeable.transferOwnership(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolManagementImpl.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol\\\";\\nimport \\\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\\\";\\n\\nimport \\\"./interfaces/StakingPoolManagement.sol\\\";\\nimport \\\"./interfaces/StakingPoolFactory.sol\\\";\\nimport \\\"./StakingPoolData.sol\\\";\\n\\ncontract StakingPoolManagementImpl is StakingPoolManagement, StakingPoolData {\\n    bytes32 private constant ADDR_REVERSE_NODE =\\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n    ENS public immutable ens;\\n    StakingPoolFactory public factory;\\n\\n    // all immutable variables can stay at the constructor\\n    constructor(address _ens) initializer {\\n        require(_ens != address(0), \\\"parameter can not be zero address\\\");\\n        ens = ENS(_ens);\\n\\n        // make sure reference code is pause so no one stake to it\\n        _pause();\\n    }\\n\\n    function __StakingPoolManagementImpl_init() internal {\\n        factory = StakingPoolFactory(msg.sender);\\n    }\\n\\n    /// @notice sets a name for the pool using ENS service\\n    function setName(string memory name) external override onlyOwner {\\n        ReverseRegistrar ensReverseRegistrar = ReverseRegistrar(\\n            ens.owner(ADDR_REVERSE_NODE)\\n        );\\n\\n        // call the ENS reverse registrar resolving pool address to name\\n        ensReverseRegistrar.setName(name);\\n\\n        // emit event, for subgraph processing\\n        emit StakingPoolRenamed(name);\\n    }\\n\\n    /// @notice pauses new staking on the pool\\n    function pause() external override onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice unpauses new staking on the pool\\n    function unpause() external override onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolProducerImpl.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@cartesi/pos/contracts/IPoS.sol\\\";\\nimport \\\"@cartesi/pos/contracts/IRewardManager.sol\\\";\\nimport \\\"./interfaces/Fee.sol\\\";\\nimport \\\"./interfaces/StakingPoolProducer.sol\\\";\\nimport \\\"./StakingPoolData.sol\\\";\\n\\ncontract StakingPoolProducerImpl is StakingPoolProducer, StakingPoolData {\\n    IERC20 public immutable ctsi;\\n    Fee public fee;\\n\\n    constructor(address _ctsi) {\\n        ctsi = IERC20(_ctsi);\\n    }\\n\\n    function __StakingPoolProducer_init(address _fee, address _pos) internal {\\n        fee = Fee(_fee);\\n        pos = IPoS(_pos);\\n    }\\n\\n    /// @notice routes produceBlock to POS contract and\\n    /// updates internal states of the pool\\n    /// @return true when everything went fine\\n    function produceBlock(uint256 _index) external override returns (bool) {\\n        IRewardManager rewardManager = IRewardManager(\\n            pos.getRewardManagerAddress(_index)\\n        );\\n\\n        // get block reward\\n        uint256 reward = rewardManager.getCurrentReward();\\n\\n        // produce block in the PoS\\n        require(\\n            pos.produceBlock(_index),\\n            \\\"StakingPoolProducerImpl: failed to produce block\\\"\\n        );\\n\\n        // calculate pool commission\\n        uint256 commission = fee.getCommission(_index, reward);\\n        require(\\n            commission <= reward,\\n            \\\"StakingPoolProducerImpl: commission is greater than block reward\\\"\\n        );\\n\\n        uint256 remainingReward = reward - commission; // this is a safety check\\n        // if commission is over the reward amount, it will underflow\\n\\n        // increase pool amount, this will change the pool exchange rate\\n        amount += remainingReward;\\n\\n        // send commission directly to pool owner\\n        if (commission > 0) {\\n            require(\\n                ctsi.transfer(owner(), commission),\\n                \\\"StakingPoolProducerImpl: failed to transfer commission\\\"\\n            );\\n        }\\n\\n        // remainingReward is part of the balance, so it will automatically be staked by StakingPoolStakingImpl\\n        emit BlockProduced(reward, commission);\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolStakingImpl.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@cartesi/pos/contracts/IStaking.sol\\\";\\nimport \\\"./interfaces/StakingPoolStaking.sol\\\";\\nimport \\\"./StakingPoolData.sol\\\";\\n\\n/// @notice This contract takes care of the interaction between the pool and the staking contract\\n/// It makes sure that there is enough liquidity in the pool to fullfil all unstake request from\\n/// users, by requesting to withdraw or unstake from Staking contract.\\n/// The remaining balance is staked.\\ncontract StakingPoolStakingImpl is StakingPoolStaking, StakingPoolData {\\n    IERC20 private immutable ctsi;\\n    IStaking private immutable staking;\\n\\n    constructor(address _ctsi, address _staking) {\\n        ctsi = IERC20(_ctsi);\\n        staking = IStaking(_staking);\\n    }\\n\\n    function __StakingPoolStaking_init() internal {\\n        require(\\n            ctsi.approve(address(staking), type(uint256).max),\\n            \\\"Failed to approve CTSI for staking contract\\\"\\n        );\\n    }\\n\\n    function rebalance() external override {\\n        // get amounts\\n        (uint256 _stake, uint256 _unstake, uint256 _withdraw) = amounts();\\n\\n        if (_stake > 0) {\\n            // we can stake\\n            staking.stake(_stake);\\n        }\\n\\n        if (_unstake > 0) {\\n            // we need to provide liquidity\\n            staking.unstake(_unstake);\\n        }\\n\\n        if (_withdraw > 0) {\\n            // we need to provide liquidity\\n            staking.withdraw(_withdraw);\\n        }\\n    }\\n\\n    function amounts()\\n        public\\n        view\\n        override\\n        returns (\\n            uint256 stake,\\n            uint256 unstake,\\n            uint256 withdraw\\n        )\\n    {\\n        // get this contract balance first\\n        uint256 balance = ctsi.balanceOf(address(this));\\n\\n        if (balance > requiredLiquidity) {\\n            // we have spare tokens we can stake\\n            // check if there is anything already maturing, to avoid reset the maturation clock\\n            uint256 maturing = staking.getMaturingBalance(address(this));\\n            if (maturing == 0) {\\n                // nothing is maturing, we can stake the balance, preserving the liquidity\\n                stake = balance - requiredLiquidity;\\n            }\\n        } else if (requiredLiquidity > balance) {\\n            // we don't have enough tokens to provide liquidity\\n            uint256 missingLiquidity = requiredLiquidity - balance;\\n\\n            // let's first check releasing balance\\n            uint256 releasing = staking.getReleasingBalance(address(this));\\n            if (releasing > 0) {\\n                // some is already releasing\\n\\n                // let's check timestamp to see if we can withdrawn it\\n                uint256 timestamp = staking.getReleasingTimestamp(\\n                    address(this)\\n                );\\n                if (timestamp < block.timestamp) {\\n                    // there it is, let's grab it\\n                    withdraw = releasing;\\n                }\\n\\n                // requiredLiquidity may be more than what is already releasing\\n                // but we won't unstake more to not reset the clock\\n            } else {\\n                // no unstake maturing, let's queue some\\n                unstake = missingLiquidity;\\n            }\\n        } else {\\n            // balance is exactly required liquidity, we can't move any tokens around\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolUserImpl.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/StakingPoolUser.sol\\\";\\nimport \\\"./StakingPoolData.sol\\\";\\n\\ncontract StakingPoolUserImpl is StakingPoolUser, StakingPoolData {\\n    IERC20 private immutable ctsi;\\n    uint256 public immutable lockTime;\\n\\n    /// @dev Constructor\\n    /// @param _ctsi The contract that provides the staking pool's token\\n    /// @param _lockTime The user deposit lock period\\n    constructor(address _ctsi, uint256 _lockTime) {\\n        ctsi = IERC20(_ctsi);\\n        lockTime = _lockTime;\\n    }\\n\\n    function deposit(uint256 _amount) external override whenNotPaused {\\n        // transfer tokens from caller to this contract\\n        // user must have approved the transfer a priori\\n        // tokens will be lying around, until actually staked by pool owner at a later time\\n        require(\\n            _amount > 0,\\n            \\\"StakingPoolUserImpl: amount must be greater than 0\\\"\\n        );\\n\\n        // add tokens to user's balance\\n        UserBalance storage user = userBalance[msg.sender];\\n        user.balance += _amount;\\n\\n        // reset deposit timestamp\\n        user.depositTimestamp = block.timestamp;\\n\\n        // reserve the balance as required liquidity (don't stake to Staking)\\n        requiredLiquidity += _amount;\\n\\n        require(\\n            ctsi.transferFrom(msg.sender, address(this), _amount),\\n            \\\"StakingPoolUserImpl: failed to transfer tokens\\\"\\n        );\\n\\n        // emit event containing user and amount\\n        emit Deposit(msg.sender, _amount, block.timestamp + lockTime);\\n    }\\n\\n    /// @notice Stake an amount of tokens, immediately earning pool shares in returns\\n    /// @param _amount amount of tokens to convert from user's balance\\n    function stake(uint256 _amount) external override whenNotPaused {\\n        // get user balance\\n        UserBalance storage user = userBalance[msg.sender];\\n\\n        // transfer tokens from caller to this contract\\n        // user must have approved the transfer a priori\\n        // tokens will be lying around, until actually staked by pool owner at a later time\\n        require(\\n            _amount > 0,\\n            \\\"StakingPoolUserImpl: amount must be greater than 0\\\"\\n        );\\n        require(\\n            _amount <= user.balance,\\n            \\\"StakingPoolUserImpl: not enough tokens available for staking\\\"\\n        );\\n\\n        // check if user can already stake or if it's too early\\n        require(\\n            block.timestamp >= user.depositTimestamp + lockTime,\\n            \\\"StakingPoolUserImpl: not enough time has passed since last deposit\\\"\\n        );\\n\\n        // calculate amount of shares as of now\\n        uint256 _shares = amountToShares(_amount);\\n\\n        // make sure he get at least one share (rounding errors)\\n        require(\\n            _shares > 0,\\n            \\\"StakingPoolUserImpl: stake not enough to emit 1 share\\\"\\n        );\\n\\n        // allocate new shares to user, immediately\\n        user.shares += _shares;\\n        user.balance -= _amount;\\n\\n        // increase total shares and amount (not changing share value)\\n        amount += _amount;\\n        shares += _shares;\\n\\n        // remove from required liquidity, as it's moving to Staking\\n        requiredLiquidity -= _amount;\\n\\n        // emit event containing user, amount, shares and unlock time\\n        emit Stake(msg.sender, _amount, _shares);\\n    }\\n\\n    /// @notice allow for users to defined exactly how many shares they\\n    /// want to unstake. Estimated value is then emitted on Unstake event\\n    function unstake(uint256 _shares) external override {\\n        UserBalance storage user = userBalance[msg.sender];\\n\\n        // check if shares is valid value\\n        require(_shares > 0, \\\"StakingPoolUserImpl: invalid amount of shares\\\");\\n\\n        // check if user has enough shares to unstake\\n        require(\\n            user.shares >= _shares,\\n            \\\"StakingPoolUserImpl: insufficient shares\\\"\\n        );\\n\\n        // reduce user number of shares\\n        user.shares -= _shares;\\n\\n        // calculate amount of tokens from shares\\n        uint256 _amount = sharesToAmount(_shares);\\n\\n        // reduce total shares and amount\\n        shares -= _shares;\\n        amount -= _amount;\\n\\n        // add amount user can withdraw (if available)\\n        user.balance += _amount;\\n\\n        // increase required liquidity\\n        requiredLiquidity += _amount;\\n\\n        // emit event containing user, amount and shares\\n        emit Unstake(msg.sender, _amount, _shares);\\n    }\\n\\n    /// @notice Transfer tokens back to calling user wallet\\n    /// @dev this will transfer all free tokens for the calling user\\n    function withdraw(uint256 _amount) external override {\\n        UserBalance storage user = userBalance[msg.sender];\\n\\n        // check user released value\\n        require(\\n            user.balance > 0,\\n            \\\"StakingPoolUserImpl: no balance to withdraw\\\"\\n        );\\n\\n        // clear user released value\\n        user.balance -= _amount; // if _amount >  user.balance this will revert\\n\\n        // decrease required liquidity\\n        requiredLiquidity -= _amount; // if _amount >  requiredLiquidity this will revert\\n\\n        // transfer token back to user\\n        require(\\n            ctsi.transfer(msg.sender, _amount),\\n            \\\"StakingPoolUserImpl: failed to transfer tokens\\\"\\n        );\\n\\n        // emit event containing user and token amount\\n        emit Withdraw(msg.sender, _amount);\\n    }\\n\\n    function getWithdrawBalance() external view override returns (uint256) {\\n        UserBalance storage user = userBalance[msg.sender];\\n\\n        // get maximum amount user can withdraw (his balance)\\n        uint256 _amount = user.balance;\\n\\n        // check contract balance\\n        uint256 balance = ctsi.balanceOf(address(this));\\n\\n        // he can withdraw whatever is available at the contract, up to his balance\\n        return balance >= _amount ? _amount : balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolWorkerImpl.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@cartesi/pos/contracts/IWorkerManagerAuthManager.sol\\\";\\nimport \\\"./interfaces/StakingPoolWorker.sol\\\";\\nimport \\\"./StakingPoolData.sol\\\";\\n\\ncontract StakingPoolWorkerImpl is StakingPoolWorker, StakingPoolData {\\n    IWorkerManagerAuthManager immutable workerManager;\\n\\n    // all immutable variables can stay at the constructor\\n    constructor(address _workerManager) {\\n        require(\\n            _workerManager != address(0),\\n            \\\"parameter can not be zero address\\\"\\n        );\\n        workerManager = IWorkerManagerAuthManager(_workerManager);\\n    }\\n\\n    receive() external payable {}\\n\\n    function __StakingPoolWorkerImpl_update(address _pos) internal {\\n        workerManager.authorize(address(this), _pos);\\n        pos = IPoS(_pos);\\n    }\\n\\n    /// @notice allows for the pool to act on its own behalf when producing blocks.\\n    function selfhire() external payable override {\\n        // pool needs to be both user and worker\\n        workerManager.hire{value: msg.value}(payable(address(this)));\\n        workerManager.authorize(address(this), address(pos));\\n        workerManager.acceptJob();\\n        payable(msg.sender).transfer(msg.value);\\n    }\\n\\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\\n    /// @param workerAddress address of the worker\\n    function hire(address payable workerAddress)\\n        external\\n        payable\\n        override\\n        onlyOwner\\n    {\\n        workerManager.hire{value: msg.value}(workerAddress);\\n        workerManager.authorize(workerAddress, address(pos));\\n    }\\n\\n    /// @notice Called by the user to cancel a job offer\\n    /// @param workerAddress address of the worker node\\n    function cancelHire(address workerAddress) external override onlyOwner {\\n        workerManager.cancelHire(workerAddress);\\n    }\\n\\n    /// @notice Called by the user to retire his worker.\\n    /// @param workerAddress address of the worker to be retired\\n    /// @dev this also removes all authorizations in place\\n    function retire(address payable workerAddress) external override onlyOwner {\\n        workerManager.retire(workerAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Fee.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @title Calculator of pool owner commission for each block reward\\n/// @author Danilo Tuler\\n/// @notice This provides flexibility for different commission models\\ninterface Fee {\\n    /// @notice calculates the total amount of the reward that will be directed to the pool owner\\n    /// @return amount of tokens taken by the pool owner as commission\\n    function getCommission(uint256 posIndex, uint256 rewardAmount)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPool.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"./StakingPoolManagement.sol\\\";\\nimport \\\"./StakingPoolProducer.sol\\\";\\nimport \\\"./StakingPoolStaking.sol\\\";\\nimport \\\"./StakingPoolUser.sol\\\";\\nimport \\\"./StakingPoolWorker.sol\\\";\\n\\n/// @title Staking Pool interface\\n/// @author Danilo Tuler\\n/// @notice This interface aggregates all facets of a staking pool.\\n/// It is broken down into the following sub-interfaces:\\n/// - StakingPoolManagement: management operations on the pool, called by the owner\\n/// - StakingPoolProducer: operations related to block production\\n/// - StakingPoolStaking: interaction between the pool and the staking contract\\n/// - StakingPoolUser: interaction between the pool users and the pool\\n/// - StakingPoolWorker: interaction between the pool and the worker node\\ninterface StakingPool is\\n    StakingPoolManagement,\\n    StakingPoolProducer,\\n    StakingPoolStaking,\\n    StakingPoolUser,\\n    StakingPoolWorker\\n{\\n    /// @notice initialize pool (from reference)\\n    function initialize(address fee, address _pos) external;\\n\\n    /// @notice Transfer ownership of pool to its deployer\\n    function transferOwnership(address newOwner) external;\\n\\n    /// @notice updates the internal settings for important pieces of the Cartesi PoS system\\n    function update() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPoolFactory.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\ninterface StakingPoolFactory {\\n    /// @notice Creates a new staking pool using a flat commission model\\n    /// emits NewFlatRateCommissionStakingPool with the parameters of the new pool\\n    /// @return new pool address\\n    function createFlatRateCommission(uint256 commission)\\n        external\\n        payable\\n        returns (address);\\n\\n    /// @notice Creates a new staking pool using a gas tax commission model\\n    /// emits NewGasTaxCommissionStakingPool with the parameters of the new pool\\n    /// @return new pool address\\n    function createGasTaxCommission(uint256 gas)\\n        external\\n        payable\\n        returns (address);\\n\\n    /// @notice Returns configuration for the working pools of the current version\\n    /// @return _pos address for the PoS contract\\n    function getPoS() external view returns (address _pos);\\n\\n    /// @notice Event emmited when a pool is created\\n    /// @param pool address of the new pool\\n    /// @param fee address of the commission contract\\n    event NewFlatRateCommissionStakingPool(address indexed pool, address fee);\\n\\n    /// @notice Event emmited when a pool is created\\n    /// @param pool address of the new pool\\n    /// @param fee address of thhe commission contract\\n    event NewGasTaxCommissionStakingPool(address indexed pool, address fee);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPoolManagement.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\ninterface StakingPoolManagement {\\n    /// @notice sets a name for the pool using ENS service\\n    function setName(string memory name) external;\\n\\n    /// @notice pauses new staking on the pool\\n    function pause() external;\\n\\n    /// @notice unpauses new staking on the pool\\n    function unpause() external;\\n\\n    /// @notice Event emmited when a pool is rename\\n    event StakingPoolRenamed(string name);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPoolProducer.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\n/// @title Interaction between a pool and the PoS block production.\\n/// @author Danilo Tuler\\n/// @notice This interface provides an opportunity to handle the necessary logic\\n/// after a block is produced.\\n/// A commission is taken from the block reward, and the remaining stays in the pool,\\n/// raising the pool share value, and being further staked.\\ninterface StakingPoolProducer {\\n    /// @notice routes produceBlock to POS contract and\\n    /// updates internal states of the pool\\n    /// @return true when everything went fine\\n    function produceBlock(uint256 _index) external returns (bool);\\n\\n    /// @notice this event is emitted at every produceBlock call\\n    /// reward is the block reward\\n    /// commission is how much CTSI is directed to the pool owner\\n    event BlockProduced(uint256 reward, uint256 commission);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPoolStaking.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\n/// @title Interaction between a pool and the staking contract\\n/// @author Danilo Tuler\\n/// @notice This interface models all interactions between a pool and the staking contract,\\n/// including staking, unstaking and withdrawing.\\n/// Tokens staked by pool users will stay at the pool until the pool owner decides to\\n/// stake them in the staking contract. On the other hand, tokens unstaked by pool users\\n/// are added to a required liquidity accumulator, and must be unstaked and withdrawn from\\n/// the staking contract.\\ninterface StakingPoolStaking {\\n    /// @notice Move tokens from pool to staking or vice-versa, according to required liquidity.\\n    /// If the pool has more liquidity then necessary, it stakes tokens.\\n    /// If the pool has less liquidity then necessary, and has not started an unstake, it unstakes.\\n    /// If the pool has less liquity than necessary, and has started an unstake, it withdraws if possible.\\n    function rebalance() external;\\n\\n    /// @notice provide information for offchain about the amount for each\\n    /// staking operation on the main Staking contract\\n    /// @return stake amount of tokens that can be staked\\n    /// @return unstake amount of tokens that must be unstaked to add liquidity\\n    /// @return withdraw amount of tokens that can be withdrawn to add liquidity\\n    function amounts()\\n        external\\n        view\\n        returns (\\n            uint256 stake,\\n            uint256 unstake,\\n            uint256 withdraw\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPoolUser.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\n/// @title Interaction between a pool user and a pool\\n/// @author Danilo Tuler\\n/// @notice This interface models all interactions between a pool user and a pool,\\n/// including staking, unstaking and withdrawing. A pool user always holds pool shares.\\n/// When a user stakes tokens, he immediately receive shares. When he unstakes shares\\n/// he is asking to release tokens. Those tokens need to be withdrawn by an additional\\n/// call to withdraw()\\ninterface StakingPoolUser {\\n    /// @notice Deposit tokens to user pool balance\\n    /// @param amount amount of token deposited in the pool\\n    function deposit(uint256 amount) external;\\n\\n    /// @notice Stake an amount of tokens, immediately earning pool shares in returns\\n    /// @param amount amount of tokens to convert to shares\\n    function stake(uint256 amount) external;\\n\\n    /// @notice Unstake an specified amount of shares of the calling user\\n    /// @dev Shares are immediately converted to tokens, and added to the pool liquidity requirement\\n    function unstake(uint256 shares) external;\\n\\n    /// @notice Transfer tokens back to calling user wallet\\n    /// @dev this will transfer tokens from user pool account to user's wallet\\n    function withdraw(uint256 amount) external;\\n\\n    /// @notice Returns the amount of tokens that can be immediately withdrawn by the calling user\\n    /// @dev there is no way to know the exact time in the future the requested tokens will be available\\n    /// @return the amount of tokens that can be immediately withdrawn by the calling user\\n    function getWithdrawBalance() external returns (uint256);\\n\\n    /// @notice Tokens were deposited, available for staking or withdrawal\\n    /// @param user address of msg.sender\\n    /// @param amount amount of tokens deposited by the user\\n    /// @param stakeTimestamp instant when the amount can be staked\\n    event Deposit(address indexed user, uint256 amount, uint256 stakeTimestamp);\\n\\n    /// @notice Tokens were deposited, they count as shares immediatly\\n    /// @param user address of msg.sender\\n    /// @param amount amount deposited by the user\\n    /// @param shares number of shares emitted for user\\n    event Stake(address indexed user, uint256 amount, uint256 shares);\\n\\n    /// @notice Request to unstake tokens. Additional liquidity requested for the pool\\n    /// @param user address of msg.sender\\n    /// @param amount amount of tokens to be released\\n    /// @param shares number of shares being liquidated\\n    event Unstake(address indexed user, uint256 amount, uint256 shares);\\n\\n    /// @notice Withdraw performed by a user\\n    /// @param user address of msg.sender\\n    /// @param amount amount of tokens withdrawn\\n    event Withdraw(address indexed user, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/StakingPoolWorker.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity >=0.7.0;\\n\\ninterface StakingPoolWorker {\\n    /// @notice allows for the pool to act on its own behalf when producing blocks.\\n    function selfhire() external payable;\\n\\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\\n    /// @param workerAddress address of the worker\\n    function hire(address payable workerAddress) external payable;\\n\\n    /// @notice Called by the user to cancel a job offer\\n    /// @param workerAddress address of the worker node\\n    function cancelHire(address workerAddress) external;\\n\\n    /// @notice Called by the user to retire his worker.\\n    /// @param workerAddress address of the worker to be retired\\n    /// @dev this also removes all authorizations in place\\n    function retire(address payable workerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/WadRayMath.sol\": {\r\n      \"content\": \"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Wad and Ray Math library\\n/// @dev Math operations for wads (fixed point with 18 digits) and rays (fixed points with 27 digits)\\npragma solidity ^0.8.0;\\n\\nlibrary WadRayMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant RATIO = 1e9;\\n\\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ((WAD / 2) + (a * b)) / WAD;\\n    }\\n\\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n        return (halfB + (a * WAD)) / b;\\n    }\\n\\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ((RAY / 2) + (a * b)) / RAY;\\n    }\\n\\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n        return (halfB + (a * RAY)) / b;\\n    }\\n\\n    function ray2wad(uint256 a) internal pure returns (uint256) {\\n        uint256 halfRatio = RATIO / 2;\\n        return (halfRatio + a) / RATIO;\\n    }\\n\\n    function wad2ray(uint256 a) internal pure returns (uint256) {\\n        return a * RATIO;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ctsi\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_workerManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ens\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeLock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"name\":\"BlockProduced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"StakingPoolRenamed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"amountToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"workerAddress\",\"type\":\"address\"}],\"name\":\"cancelHire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ctsi\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract StakingPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"contract Fee\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"workerAddress\",\"type\":\"address\"}],\"name\":\"hire\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pos\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pos\",\"outputs\":[{\"internalType\":\"contract IPoS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"produceBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"workerAddress\",\"type\":\"address\"}],\"name\":\"retire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfhire\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"sharesToAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"StakingPoolImpl","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000491604c0fdf08347dd1fa4ee062a822a5dd06b5d0000000000000000000000009edeadfde65bcfd0907db3acdb3445229c764a69000000000000000000000000832d9f06970ddac7ba49be5a2ccad8f89df74c1300000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e0000000000000000000000000000000000000000000000000000000000005460","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}