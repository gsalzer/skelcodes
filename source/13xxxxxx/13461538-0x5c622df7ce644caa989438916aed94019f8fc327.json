{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/auction/MirrorDutchAuctionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IOwnableEvents} from \\\"../../lib/Ownable.sol\\\";\\nimport {IPausableEvents} from \\\"../../lib/Pausable.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../interface/ITreasuryConfig.sol\\\";\\nimport {ITributaryRegistry} from \\\"../../interface/ITributaryRegistry.sol\\\";\\nimport {IMirrorTreasury} from \\\"../../interface/IMirrorTreasury.sol\\\";\\nimport {MirrorDutchAuctionProxy} from \\\"./MirrorDutchAuctionProxy.sol\\\";\\nimport {IMirrorDutchAuctionLogic} from \\\"./interface/IMirrorDutchAuctionLogic.sol\\\";\\n\\ninterface IMirrorDutchAuctionFactory {\\n    /// @notice Emitted when a proxy is deployed\\n    event MirrorDutchAuctionProxyDeployed(\\n        address proxy,\\n        address operator,\\n        address logic,\\n        bytes initializationData\\n    );\\n\\n    function deploy(\\n        address operator,\\n        address tributary,\\n        IMirrorDutchAuctionLogic.AuctionConfig memory auctionConfig\\n    ) external returns (address proxy);\\n}\\n\\n/**\\n * @title MirrorDutchAuctionFactory\\n * @author MirrorXYZ\\n * This contract implements a factory to deploy a simple Dutch Auction\\n * proxies with a price reduction mechanism at fixed intervals.\\n */\\ncontract MirrorDutchAuctionFactory is\\n    IMirrorDutchAuctionFactory,\\n    IOwnableEvents,\\n    IPausableEvents\\n{\\n    /// @notice The contract that holds the Dutch Auction logic\\n    address public logic;\\n\\n    /// @notice The contract that holds the treasury configuration\\n    address public treasuryConfig;\\n\\n    /// @notice Address that holds the tributary registry for Mirror treasury\\n    address public tributaryRegistry;\\n\\n    constructor(\\n        address logic_,\\n        address treasuryConfig_,\\n        address tributaryRegistry_\\n    ) {\\n        logic = logic_;\\n        treasuryConfig = treasuryConfig_;\\n        tributaryRegistry = tributaryRegistry_;\\n    }\\n\\n    function deploy(\\n        address operator,\\n        address tributary,\\n        IMirrorDutchAuctionLogic.AuctionConfig memory auctionConfig\\n    ) external override returns (address proxy) {\\n        bytes memory initializationData = abi.encodeWithSelector(\\n            IMirrorDutchAuctionLogic.initialize.selector,\\n            operator,\\n            treasuryConfig,\\n            auctionConfig\\n        );\\n\\n        proxy = address(\\n            new MirrorDutchAuctionProxy{\\n                salt: keccak256(\\n                    abi.encode(\\n                        operator,\\n                        auctionConfig.recipient,\\n                        auctionConfig.nft\\n                    )\\n                )\\n            }(logic, initializationData)\\n        );\\n\\n        emit MirrorDutchAuctionProxyDeployed(\\n            proxy,\\n            operator,\\n            logic,\\n            initializationData\\n        );\\n\\n        ITributaryRegistry(tributaryRegistry).registerTributary(\\n            proxy,\\n            tributary\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IPausableEvents {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n}\\n\\ninterface IPausable {\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable, IPausableEvents {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITributaryRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITributaryRegistry {\\n    function addRegistrar(address registrar) external;\\n\\n    function removeRegistrar(address registrar) external;\\n\\n    function addSingletonProducer(address producer) external;\\n\\n    function removeSingletonProducer(address producer) external;\\n\\n    function registerTributary(address producer, address tributary) external;\\n\\n    function producerToTributary(address producer)\\n        external\\n        returns (address tributary);\\n\\n    function singletonProducer(address producer) external returns (bool);\\n\\n    function changeTributary(address producer, address newTributary) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/producers/auction/MirrorDutchAuctionProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title MirrorDutchAuctionProxy\\n * @author MirrorXYZ\\n */\\ncontract MirrorDutchAuctionProxy {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @notice Stores implementation logic.\\n     * @param implementation - the implementation holds the logic for all proxies\\n     * @param initializationData - initialization call\\n     */\\n    constructor(address implementation, bytes memory initializationData) {\\n        // Delegatecall into the relayer, supplying initialization calldata.\\n        (bool ok, ) = implementation.delegatecall(initializationData);\\n\\n        // Revert and include revert data if delegatecall to implementation reverts.\\n        if (!ok) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, implementation)\\n        }\\n    }\\n\\n    /**\\n     * @notice When any function is called on this contract, we delegate to\\n     * the logic contract stored in the implementation storage slot.\\n     */\\n    fallback() external payable {\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                sload(_IMPLEMENTATION_SLOT),\\n                ptr,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/producers/auction/interface/IMirrorDutchAuctionLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorDutchAuctionLogic {\\n    /// @notice Emitted when the auction starts\\n    event AuctionStarted(uint256 blockNumber);\\n\\n    /// @notice Emitted when a withdrawal takes place.\\n    event Withdrawal(address recipient, uint256 amount, uint256 fee);\\n\\n    /// @notice Emitted when a bid takes place.\\n    event Bid(address recipient, uint256 price, uint256 tokenId);\\n\\n    struct AuctionConfig {\\n        uint256[] prices;\\n        uint256 interval;\\n        uint256 startTokenId;\\n        uint256 endTokenId;\\n        address recipient;\\n        address nft;\\n        address nftOwner;\\n    }\\n\\n    /// @notice Get a list of prices\\n    function prices(uint256 index) external returns (uint256);\\n\\n    /// @notice Get the time interval in blocks\\n    function interval() external returns (uint256);\\n\\n    /// @notice Get the current tokenId\\n    function tokenId() external returns (uint256);\\n\\n    /// @notice Get the last tokenId\\n    function endTokenId() external returns (uint256);\\n\\n    /// @notice Get total time elapsed since auction started\\n    function globalTimeElapsed() external returns (uint256);\\n\\n    /// @notice Get the recipient of the funds for withdrawals\\n    function recipient() external returns (address);\\n\\n    /// @notice Get whether an account has purchased\\n    function purchased(address account) external returns (bool);\\n\\n    /// @notice Get the block at which auction started\\n    function auctionStartBlock() external returns (uint256);\\n\\n    /// @notice Get the block at which auction was paused, only set if auction has started\\n    function pauseBlock() external returns (uint256);\\n\\n    /// @notice Get the block at which auction was unpaused\\n    function unpauseBlock() external returns (uint256);\\n\\n    /// @notice Get the contract that holds the NFTs\\n    function nft() external returns (address);\\n\\n    /// @notice Set the owner of the nfts transfered\\n    function nftOwner() external returns (address);\\n\\n    /// @notice Get the ending price\\n    function endingPrice() external returns (uint256);\\n\\n    /// @notice Change the withdrawal recipient\\n    function changeRecipient(address newRecipient) external;\\n\\n    /// @notice Get the contract that holds the treasury configuration\\n    function getAllPrices() external returns (uint256[] memory);\\n\\n    /**\\n     * @dev This contract is used as the logic for proxies. Hence we include\\n     * the ability to call \\\"initialize\\\" when deploying a proxy to set initial\\n     * variables without having to define them and implement in the proxy's\\n     * constructor. This function reverts if called after deployment.\\n     */\\n    function initialize(\\n        address owner_,\\n        address treasuryConfig_,\\n        IMirrorDutchAuctionLogic.AuctionConfig memory auctionConfig_\\n    ) external;\\n\\n    /// @notice Pause auction\\n    function pause() external;\\n\\n    /// @notice Unpause auction\\n    function unpause() external;\\n\\n    /// @notice Withdraw all funds and destroy contract\\n    function cancel() external;\\n\\n    /// @notice Current price. Zero if auction has not started.\\n    function price() external view returns (uint256);\\n\\n    /// @notice Current time elapsed.\\n    function time() external view returns (uint256);\\n\\n    /**\\n     * @notice Bid for an NFT. If the price is met transfer NFT to sender.\\n     * If price drops before the transaction mines, refund value.\\n     */\\n    function bid() external payable;\\n\\n    /// @notice Withdraw all funds, and pay fee\\n    function withdraw() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"logic_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributaryRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"logic\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"initializationData\",\"type\":\"bytes\"}],\"name\":\"MirrorDutchAuctionProxyDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributary\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftOwner\",\"type\":\"address\"}],\"internalType\":\"struct IMirrorDutchAuctionLogic.AuctionConfig\",\"name\":\"auctionConfig\",\"type\":\"tuple\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributaryRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MirrorDutchAuctionFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000009ae96b2ef72cd6b671f4450157f289124ce5bc0200000000000000000000000021a93be569666527dae0fdbfbe7715299dec12020000000000000000000000001171b858777120a59a6cc8148edda8982f187cd8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}