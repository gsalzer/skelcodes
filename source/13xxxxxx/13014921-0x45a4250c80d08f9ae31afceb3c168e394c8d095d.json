{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.1;\r\n\r\n\r\ninterface IBlackhole {\r\n    function nextMinimumBet() external view returns(uint256);\r\n    function bet() external payable;\r\n    function win() external;\r\n}\r\ncontract UBI {\r\n    mapping(address=>bool) public bidders;\r\n    uint256 public totalBidders;\r\n    uint256 public totalAmount;\r\n    address public game;\r\n    bool public claimable;\r\n\r\n    constructor() public {\r\n        game = msg.sender;\r\n    }\r\n\r\n    modifier onlyGame() {\r\n        require(msg.sender == game, \"only the game itself can do this\");\r\n        _;\r\n    }\r\n\r\n    function addBidder(address bidder, uint256 amount) public onlyGame {\r\n        if (!bidders[bidder]) {\r\n            bidders[bidder] = true;\r\n            totalBidders = totalBidders + 1;\r\n        }\r\n        totalAmount = totalAmount + amount;\r\n    }\r\n\r\n    function endGame(address winner) public onlyGame {\r\n        bidders[winner] = false;\r\n        claimable = true;\r\n        totalBidders = totalBidders - 1;\r\n    }\r\n\r\n    function eachGets() public view returns (uint256) {\r\n        return totalAmount / totalBidders;\r\n    }\r\n\r\n    function claim() public onlyGame {\r\n        require(claimable, \"game isn't over yet\");\r\n        require(bidders[tx.origin], \"theres nothing for you here\");\r\n        bidders[tx.origin] = false;\r\n        if (eachGets() > addy().balance) {\r\n            payable(tx.origin).transfer(addy().balance);\r\n        } else {\r\n            require(payable(tx.origin).send(eachGets()), \"send failed\");\r\n        }\r\n    }\r\n    \r\n    function addy() public view returns(address payable) {\r\n        return payable(address(this));\r\n    }\r\n    \r\n    fallback() external payable {\r\n        \r\n    }\r\n}\r\n\r\ncontract Greenhole is IBlackhole {\r\n    \r\n    address public previousWinner;\r\n    address public feeTo;\r\n    address public currentLeader;\r\n    uint256 public currentBet;//amount of current bet in wei\r\n    uint256 public lastBet;//time of last bet in seconds\r\n    bool public currentGame;\r\n    UBI[] public ubis;\r\n\r\n    event NewBet(uint256 amount, address newLeader);\r\n    event NewGameStarted(uint256 amount, address creator, address ubi);\r\n    event Winrar(uint256 amount, address winner);\r\n    \r\n    constructor() {\r\n        previousWinner = msg.sender;\r\n        feeTo = msg.sender;\r\n    }\r\n\r\n    modifier onlyPreviousWinner() {\r\n        require(msg.sender == previousWinner, \"You aren't the previous winner\");\r\n        _;\r\n    }\r\n\r\n    function setFeeTo(address destination) public onlyPreviousWinner {\r\n        feeTo = destination;\r\n    }\r\n\r\n    function nextMinimumBet() public override view returns(uint256) {\r\n        if (currentGame) {\r\n            return currentBet+1;\r\n        } else {\r\n            return 1000;\r\n        }\r\n    }\r\n    \r\n    function currentUBI() public view returns (UBI) {\r\n        return ubis[ubis.length - 1];\r\n    }\r\n\r\n    function startNewGame() internal {\r\n            currentGame = true;\r\n            ubis.push(new UBI());\r\n            emit NewGameStarted(msg.value, msg.sender, address(currentUBI()));\r\n    }\r\n\r\n    function bet() public override payable {\r\n        require(msg.value >= nextMinimumBet(), \"bet more\");\r\n        if (!currentGame) {\r\n           startNewGame();\r\n        }\r\n        uint256 amount = msg.value;\r\n        payable(feeTo).transfer(amount / 1000);\r\n        uint256 ubiAmount = (amount / 20) * 7;\r\n        currentUBI().addBidder(msg.sender, ubiAmount);\r\n        payable(currentUBI().addy()).transfer(ubiAmount);\r\n        currentBet = amount;\r\n        lastBet = block.timestamp;\r\n        currentLeader = msg.sender;\r\n        emit NewBet(amount, msg.sender);\r\n    }\r\n\r\n    function win() public override {\r\n        require(block.timestamp >= lastBet + 1 hours, \"must be leader for 60 minutes to collect\");\r\n        require(msg.sender == currentLeader);\r\n        emit Winrar(address(this).balance, msg.sender);\r\n        payable(msg.sender).transfer(address(this).balance);\r\n        currentUBI().endGame(msg.sender);\r\n        currentGame = false;\r\n        currentBet = 0;\r\n        previousWinner = msg.sender;\r\n        feeTo = msg.sender;\r\n    }\r\n    \r\n    function claimUBI(uint256 index) public {\r\n        currentUBI().claim();\r\n    }\r\n    \r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLeader\",\"type\":\"address\"}],\"name\":\"NewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ubi\",\"type\":\"address\"}],\"name\":\"NewGameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"Winrar\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"claimUBI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentGame\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLeader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentUBI\",\"outputs\":[{\"internalType\":\"contract UBI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextMinimumBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ubis\",\"outputs\":[{\"internalType\":\"contract UBI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"win\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Greenhole","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4f03a2c0e52746d19ceecaa5e2f2f3f5f36ad7efa9353f86c84fef7398c4029f"}]}