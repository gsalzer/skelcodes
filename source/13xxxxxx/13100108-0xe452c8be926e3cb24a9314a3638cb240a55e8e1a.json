{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/xieshanfeng/IdeaProjects/COMP/contracts/CompStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.25;\\nabstract contract  IComp {\\n    mapping (uint256 => string) public geneMap;\\n    function ownerOf(uint256 tokenId) external view virtual returns (address owner);\\n    uint256  public tokenId;\\n}\\nabstract contract IERC20{\\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);\\n    function transfer(address recipient, uint256 amount) external virtual returns (bool);\\n    function balanceOf(address account) external view  virtual returns (uint256);\\n}\\ncontract CompStaking {\\n\\n    struct PoolInfo{\\n        uint32 startRedeemTokenId; // 2000\\n        address poolTokenContract; //\\n        uint32  initStakingRatio; //10\\n        uint32  onceCompReward; //20\\n        address initOwner;\\n        uint32 totalPower;\\n    }\\n\\n    uint32 private _syncTokenId=0;\\n\\n    mapping (address => mapping(uint32=>uint256) ) public compStakingMap;\\n    mapping (address => PoolInfo ) public pools;\\n\\n    uint8[][] public standTemplates=\\n    [\\n    [5,9,10,10,1,7,3,0,0],\\n    [5,9,10,3,10,1,0,0,0],\\n    [5,9,10,3,10,1,0,0,0],\\n    [5,8,5,10,3,4,1,0,0],\\n    [5,9,10,3,1,0,0,0,0],\\n    [5,9,3,10,1,4,0,0,0],\\n    [5,9,10,10,1,0,0,0,0],\\n    [5,8,5,10,1,3,0,0,0],\\n    [5,9,3,10,2,1,0,0,0],\\n    [5,9,3,10,5,1,0,0,0],\\n    [5,9,10,3,10,1,2,0,0],\\n    [5,9,10,10,3,1,0,0,0],\\n    [5,9,3,10,1,10,0,0,0],\\n    [5,9,10,10,1,10,10,5,0],\\n    [5,9,10,10,4,2,1,3,0],\\n    [5,9,10,1,3,0,0,0,0],\\n    [5,9,3,10,7,1,0,0,0],\\n    [5,9,10,10,1,0,0,0,0],\\n    [5,9,10,10,6,1,0,0,0],\\n    [5,9,10,3,9,1,0,0,0],\\n    [5,9,10,10,1,3,7,0,0],\\n    [5,9,10,3,1,0,0,0,0],\\n    [5,9,10,3,1,4,0,0,0],\\n    [5,9,10,1,10,3,7,5,0],\\n    [5,9,3,10,10,1,0,0,0],\\n    [5,9,10,10,3,1,0,0,0],\\n    [5,9,10,4,3,10,9,1,0],\\n    [5,9,1,3,0,0,0,0,0],\\n    [5,9,10,3,5,1,0,0,0],\\n    [5,9,2,3,10,1,0,0,0],\\n    [5,9,10,3,1,0,0,0,0],\\n    [5,9,1,2,7,3,0,0,0],\\n    [5,9,10,1,10,3,0,0,0],\\n    [5,9,10,1,3,0,0,0,0],\\n    [5,9,10,3,4,1,0,0,0],\\n    [5,9,10,10,3,4,1,10,0],\\n    [5,9,3,10,1,0,0,0,0],\\n    [5,9,10,10,10,1,3,0,0],\\n    [5,9,10,7,1,10,0,0,0],\\n    [5,9,10,1,10,10,0,0,0],\\n    [5,9,10,1,3,0,0,0,0],\\n    [5,9,10,1,0,0,0,0,0],\\n    [5,9,10,10,3,4,1,0,0],\\n    [5,9,10,10,10,3,1,0,0],\\n    [5,9,10,1,0,0,0,0,0],\\n    [5,9,10,1,7,3,0,0,0],\\n    [5,9,3,10,7,1,0,0,0],\\n    [5,9,1,3,7,0,0,0,0],\\n    [5,9,4,3,1,6,0,0,0],\\n    [5,9,10,1,3,0,0,0,0],\\n    [5,9,10,1,3,10,7,0,0],\\n    [5,9,2,1,3,7,0,0,0],\\n    [5,9,10,7,10,1,3,0,0],\\n    [5,8,10,10,1,10,0,0,0],\\n    [5,9,10,10,7,3,1,2,0],\\n    [5,9,10,7,1,3,10,0,0],\\n    [5,9,10,1,10,3,7,10,0],\\n    [5,9,1,10,10,2,10,0,0],\\n    [5,9,10,10,1,0,0,0,0],\\n    [5,9,10,10,3,5,1,0,0],\\n    [5,9,10,10,1,10,10,10,0],\\n    [5,9,10,10,3,1,10,0,0],\\n    [5,9,10,1,10,6,0,0,0],\\n    [5,9,2,10,10,1,3,0,0],\\n    [5,9,10,10,1,0,0,0,0],\\n    [5,9,10,10,3,1,0,0,0],\\n    [5,9,10,10,3,2,1,0,0],\\n    [5,9,10,10,1,0,0,0,0],\\n    [1,9,10,10,1,0,0,0,0],\\n    [5,9,10,2,4,3,1,10,0],\\n    [5,9,10,1,3,7,0,0,0],\\n    [5,9,10,1,3,0,0,0,0],\\n    [5,9,10,10,2,1,3,4,0],\\n    [5,9,10,10,3,10,1,0,0],\\n    [5,9,10,10,10,3,1,0,0],\\n    [5,9,10,1,10,0,0,0,0],\\n    [5,9,10,10,1,10,3,0,0],\\n    [5,9,10,10,10,3,1,4,0],\\n    [5,9,10,3,1,0,0,0,0],\\n    [5,9,10,1,3,10,0,0,0],\\n    [5,9,10,3,10,10,1,0,0],\\n    [5,9,10,10,3,1,4,10,10],\\n    [5,9,10,10,4,10,10,1,0],\\n    [5,9,4,10,3,10,1,2,0],\\n    [5,9,10,10,3,1,0,0,0],\\n    [5,9,10,1,3,0,0,0,0],\\n    [5,9,7,1,5,10,3,0,0],\\n    [5,9,10,10,3,4,1,0,0],\\n    [5,9,4,10,3,1,10,0,0],\\n    [5,9,10,1,3,10,0,0,0],\\n    [5,9,10,10,3,1,0,0,0],\\n    [5,9,10,4,10,1,3,0,0],\\n    [5,9,10,10,3,1,0,0,0],\\n    [5,9,10,3,1,5,9,0,0],\\n    [1,9,10,1,3,9,0,0,0],\\n    [5,9,10,2,10,3,10,1,0],\\n    [5,9,10,3,4,1,10,0,0],\\n    [5,9,1,10,10,3,0,0,0],\\n    [5,9,3,10,1,10,0,0,0],\\n    [5,9,10,10,7,1,3,0,0]\\n    ];\\n\\n    address  public compContract= address(0xABa31c041E916e4141036F080B554D40Cdb2BCD0);\\n    event Staking(address indexed from,uint32 power,uint256 amount);\\n    event Redeem(address indexed to,uint32 compId,uint32 power,uint256 amount);\\n\\n\\n    /**\\n   *\\n   * compPower\\n   *\\n   * Requirements\\n   * - `tokenId`  tokenId\\n   */\\n    function compPower(uint32 tokenId) public view returns(uint8){\\n        //fetch gene from contract\\n        IComp comp = IComp(compContract);\\n        string memory gene = comp.geneMap(tokenId);\\n\\n        require(bytes(gene).length > 0,'token is not exist');\\n\\n        uint8 power = 0;\\n\\n        uint8[] memory geneIntArray = _geneToIntArray(gene);\\n\\n        for(uint8 i= 1;i<geneIntArray.length; i++){\\n            if(geneIntArray[i]==99){ //stop flag\\n                //sex\\n                uint8 sexNum = geneIntArray[i-1];\\n                if(sexNum == 0){\\n                    power=power+5;\\n                }else if(sexNum==3){\\n                    power=power+1;\\n                }else{\\n                    power=power+3;\\n                }\\n                break;\\n            }\\n            //not sex gene and not match add 10 power\\n            else if((geneIntArray[i+1] != 99)  && (geneIntArray[i] != standTemplates[geneIntArray[0]][i-1] )){\\n                power=power+1;\\n            }\\n        }\\n\\n        return power*10;\\n\\n    }\\n    /**\\n   *\\n   * geneToIntArray\\n   *\\n   * Requirements\\n   * - `geneStr`  geneStr\\n   */\\n    function _geneToIntArray(string memory geneStr) private pure  returns(uint8[] memory){\\n\\n        uint8[] memory geneIntArray = new uint8[](12);\\n        bytes memory genebytes = bytes (geneStr);\\n        uint8 tempValue = 0;\\n        uint length=0;\\n        for(uint256 i=0;i<genebytes.length;i++){\\n            uint8 c = uint8(genebytes[i]);\\n            //is number: 0-9\\n            if(c >= 48 && c <= 57){\\n                tempValue = tempValue*10 + (c - 48);\\n            }else{\\n                geneIntArray[length] = tempValue;\\n                tempValue = 0;\\n                length++;\\n            }\\n        }\\n        geneIntArray[length]=tempValue;\\n\\n        geneIntArray[length+1] = 99; //stop flag\\n        return geneIntArray;\\n\\n    }\\n    /**\\n   *\\n   * staking params\\n   *\\n   * Requirements\\n   * - `compIdList`  compIdList\\n   * - `poolTokenContract`\\n   */\\n    function currentStakingParams(uint32[] memory compIdList,address poolTokenContract) public view returns( uint32, uint256) {\\n\\n        uint32 totalPower =0;\\n        for(uint8 i=0;i<compIdList.length;i++){\\n            totalPower += compPower(compIdList[i]);\\n        }\\n        return (totalPower,_currentStakingAmount(totalPower,poolTokenContract));\\n    }\\n\\n    /**\\n   *\\n   * currentStakingAmount\\n   *\\n   * Requirements\\n   * - `power`  tokenId list\\n   * - `poolTokenContract`\\n   */\\n    function _currentStakingAmount(uint32 power,address poolTokenContract) private view returns( uint256) {\\n        PoolInfo memory pool = pools[poolTokenContract];\\n        require(pool.initOwner != address(0), \\\"pool is not exist\\\");\\n\\n        uint availableBouns = poolAvailableBouns(poolTokenContract);\\n\\n        return  pool.totalPower>0? (availableBouns * power / pool.totalPower) : (power*pool.initStakingRatio * 10**uint256(18));\\n    }\\n\\n    function poolAvailableBouns(address poolTokenContract) public view returns(uint256){\\n        PoolInfo memory pool = pools[poolTokenContract];\\n        require(pool.initOwner != address(0), \\\"pool is not exist\\\");\\n\\n        IComp comp = IComp(compContract);\\n        IERC20 poolBalance = IERC20(poolTokenContract);\\n\\n        uint256 totalPower = pool.totalPower;\\n        uint256 maxTokenId = comp.tokenId();\\n        uint256 totalBouns = poolBalance.balanceOf(address(this));\\n\\n        if(maxTokenId> pool.startRedeemTokenId && totalPower>0){ //start\\n            if(block.number<13600000){ //stop time\\n                totalBouns -= (10000-(maxTokenId-1)) * pool.onceCompReward * 10**uint256(18);\\n            }\\n        }else{\\n            totalBouns =  totalPower*pool.initStakingRatio * 10**uint256(18);\\n        }\\n\\n        return totalBouns;\\n    }\\n\\n    /**\\n  *\\n  * staking\\n  *\\n  * Requirements\\n  * - `compIdList`  tokenId list\\n  * - `poolTokenContract`\\n  */\\n\\n    function staking(uint32[] memory compIdList , address poolTokenContract) public returns (bool){\\n\\n        PoolInfo storage poolInfo = pools[poolTokenContract];\\n        require(poolInfo.initOwner != address(0), \\\"pool is not exist\\\");\\n        require(compIdList.length > 0 , \\\"at least one comp\\\");\\n\\n\\n        uint32 stakingPower = 0;\\n        for(uint8 i=0;i<compIdList.length;i++){\\n\\n            IComp comp = IComp(compContract);\\n            address owner =  comp.ownerOf(compIdList[i]);\\n\\n            require(owner==msg.sender, \\\"must be owner of token\\\");\\n            require(compStakingMap[poolTokenContract][compIdList[i]]==0,\\\"already staking \\\");\\n\\n            uint32 power = compPower(compIdList[i]);\\n\\n            compStakingMap[poolTokenContract][compIdList[i]] = power;\\n            stakingPower += power;\\n        }\\n        uint256 stakingAmount = _currentStakingAmount(stakingPower,poolTokenContract);\\n        emit Staking(msg.sender,stakingPower,stakingAmount);\\n\\n        IERC20 erc20 = IERC20(poolTokenContract);\\n        erc20.transferFrom(msg.sender,address(this), stakingAmount);\\n        poolInfo.totalPower +=  stakingPower;\\n\\n        return true;\\n    }\\n    /**\\n  *\\n  * redeem staking\\n  *\\n  * Requirements\\n  * - `compId`  redeem compId\\n  * - `poolTokenContract`\\n  */\\n    function redeem(uint32 compId, address poolTokenContract)public returns (bool){\\n\\n        PoolInfo storage poolInfo = pools[poolTokenContract];\\n        require(poolInfo.initOwner != address(0), \\\"pool is not exist\\\");\\n\\n        IComp comp = IComp(compContract);\\n        address owner =  comp.ownerOf(compId);\\n        require(owner==msg.sender, \\\"must be owner of token\\\");\\n        require(compStakingMap[poolTokenContract][compId] !=0 , \\\"not staking\\\");\\n\\n        uint32 power= compPower(compId);\\n        require(poolInfo.totalPower>=power, \\\"power error\\\");\\n\\n        uint256  amount = _currentStakingAmount(power,poolTokenContract);\\n\\n        poolInfo.totalPower -= power;\\n\\n        IERC20 erc20 = IERC20(poolTokenContract);\\n\\n        uint256 redeemAmount = poolInfo.totalPower > 0 ? (amount * 99 / 100): amount;\\n        erc20.transfer(msg.sender, redeemAmount);  //1% fee\\n        compStakingMap[poolTokenContract][compId] = 0;\\n\\n\\n        emit Redeem(msg.sender, compId,power,redeemAmount);\\n\\n        return true;\\n\\n    }\\n\\n    /**\\n  *\\n  * add new pool\\n  *\\n  * Requirements\\n  * - `startRedeemTokenId`\\n  * - `poolTokenContract`\\n  * - `initStakingRatio`\\n  * - `onceCompReward`\\n  */\\n    function createPool(uint32 startRedeemTokenId,address poolTokenContract, uint32 initStakingRatio,uint32 onceCompReward) public returns (bool){\\n\\n        PoolInfo storage poolInfo = pools[poolTokenContract];\\n        require(poolInfo.initOwner == address(0), \\\"staking has started\\\");\\n\\n        IERC20 erc20 = IERC20(poolTokenContract);\\n        erc20.transferFrom(msg.sender,address(this), onceCompReward * 10000 * 10**uint256(18));\\n\\n        poolInfo.startRedeemTokenId = startRedeemTokenId;\\n        poolInfo.poolTokenContract = poolTokenContract;\\n        poolInfo.initStakingRatio = initStakingRatio;\\n        poolInfo.onceCompReward = onceCompReward;\\n        poolInfo.initOwner = msg.sender;\\n        return true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"compId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"power\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"power\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staking\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"compContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"compPower\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"compStakingMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"startRedeemTokenId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"poolTokenContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"initStakingRatio\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"onceCompReward\",\"type\":\"uint32\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"compIdList\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"poolTokenContract\",\"type\":\"address\"}],\"name\":\"currentStakingParams\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolTokenContract\",\"type\":\"address\"}],\"name\":\"poolAvailableBouns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startRedeemTokenId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"poolTokenContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"initStakingRatio\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"onceCompReward\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"initOwner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"totalPower\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"compId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"poolTokenContract\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"compIdList\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"poolTokenContract\",\"type\":\"address\"}],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"standTemplates\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompStaking","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}