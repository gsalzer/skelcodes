{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/DiamondLoupeFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"diamond-libraries/contracts/libraries/LibDiamondStorage.sol\\\";\\nimport \\\"diamond-libraries/contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"diamond-libraries/contracts/interfaces/IERC165.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n    // Diamond Loupe Functions\\n    ////////////////////////////////////////////////////////////////////\\n    /// These functions are expected to be called frequently by tools.\\n    //\\n    // struct Facet {\\n    //     address facetAddress;\\n    //     bytes4[] functionSelectors;\\n    // }\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external view override returns (Facet[] memory facets_) {\\n        LibDiamondStorage.DiamondStorage storage ds =\\n            LibDiamondStorage.diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n\\n        // create an array set to the maximum size possible\\n        facets_ = new Facet[](selectorCount);\\n\\n        // create an array for counting the number of selectors for each facet\\n        uint8[] memory numFacetSelectors = new uint8[](selectorCount);\\n\\n        // total number of facets\\n        uint256 numFacets;\\n\\n        // loop through function selectors\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < selectorCount;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = ds.selectors[selectorIndex];\\n            address facetAddress_ = ds.facets[selector].facetAddress;\\n            bool continueLoop = false;\\n\\n            // find the functionSelectors array for selector and add selector to it\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                if (facets_[facetIndex].facetAddress == facetAddress_) {\\n                    facets_[facetIndex].functionSelectors[\\n                        numFacetSelectors[facetIndex]\\n                    ] = selector;\\n                    // probably will never have more than 256 functions from one facet contract\\n                    require(numFacetSelectors[facetIndex] < 255);\\n                    numFacetSelectors[facetIndex]++;\\n                    continueLoop = true;\\n                    break;\\n                }\\n            }\\n\\n            // if functionSelectors array exists for selector then continue loop\\n            if (continueLoop) {\\n                continueLoop = false;\\n                continue;\\n            }\\n\\n            // create a new functionSelectors array for selector\\n            facets_[numFacets].facetAddress = facetAddress_;\\n            facets_[numFacets].functionSelectors = new bytes4[](selectorCount);\\n            facets_[numFacets].functionSelectors[0] = selector;\\n\\n            numFacetSelectors[numFacets] = 1;\\n            numFacets++;\\n        }\\n\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\n            // setting the number of selectors\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n\\n        // setting the number of facets\\n        assembly {\\n            mstore(facets_, numFacets)\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        override\\n        returns (bytes4[] memory _facetFunctionSelectors)\\n    {\\n        LibDiamondStorage.DiamondStorage storage ds =\\n            LibDiamondStorage.diamondStorage();\\n\\n        uint256 selectorCount = ds.selectors.length;\\n        uint256 numSelectors;\\n        _facetFunctionSelectors = new bytes4[](selectorCount);\\n\\n        // loop through function selectors\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < selectorCount;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = ds.selectors[selectorIndex];\\n            address facetAddress_ = ds.facets[selector].facetAddress;\\n            if (_facet == facetAddress_) {\\n                _facetFunctionSelectors[numSelectors] = selector;\\n                numSelectors++;\\n            }\\n        }\\n\\n        // Set the number of selectors in the array\\n        assembly {\\n            mstore(_facetFunctionSelectors, numSelectors)\\n        }\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        override\\n        returns (address[] memory facetAddresses_)\\n    {\\n        LibDiamondStorage.DiamondStorage storage ds =\\n            LibDiamondStorage.diamondStorage();\\n\\n        uint256 selectorCount = ds.selectors.length;\\n        // create an array set to the maximum size possible\\n        facetAddresses_ = new address[](selectorCount);\\n        uint256 numFacets;\\n\\n        // loop through function selectors\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < selectorCount;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = ds.selectors[selectorIndex];\\n            address facetAddress_ = ds.facets[selector].facetAddress;\\n            bool continueLoop = false;\\n\\n            // see if we have collected the address already and break out of loop if we have\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                if (facetAddress_ == facetAddresses_[facetIndex]) {\\n                    continueLoop = true;\\n                    break;\\n                }\\n            }\\n\\n            // continue loop if we already have the address\\n            if (continueLoop) {\\n                continueLoop = false;\\n                continue;\\n            }\\n\\n            // include address\\n            facetAddresses_[numFacets] = facetAddress_;\\n            numFacets++;\\n        }\\n\\n        // Set the number of facet addresses in the array\\n        assembly {\\n            mstore(facetAddresses_, numFacets)\\n        }\\n    }\\n\\n    /// @notice Gets the facet address that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        override\\n        returns (address facetAddress_)\\n    {\\n        LibDiamondStorage.DiamondStorage storage ds =\\n            LibDiamondStorage.diamondStorage();\\n        facetAddress_ = ds.facets[_functionSelector].facetAddress;\\n    }\\n\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceId)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        LibDiamondStorage.DiamondStorage storage ds =\\n            LibDiamondStorage.diamondStorage();\\n        return ds.supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/libraries/LibDiamondStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct Facet {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => Facet) facets;\\n        bytes4[] selectors;\\n\\n        // ERC165\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_facetFunctionSelectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DiamondLoupeFacet","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}