{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Controlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"../interfaces/IKernel.sol\\\";\\n\\nabstract contract Controlled is Initializable, ModuleMapConsumer {\\n  // controller address => is a controller\\n  mapping(address => bool) internal _controllers;\\n  address[] public controllers;\\n\\n  function __Controlled_init(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    for (uint256 i; i < controllers_.length; i++) {\\n      _controllers[controllers_[i]] = true;\\n    }\\n    controllers = controllers_;\\n    __ModuleMapConsumer_init(moduleMap_);\\n  }\\n\\n  function addController(address controller) external onlyOwner {\\n    _controllers[controller] = true;\\n    bool added;\\n    for (uint256 i; i < controllers.length; i++) {\\n      if (controller == controllers[i]) {\\n        added = true;\\n      }\\n    }\\n    if (!added) {\\n      controllers.push(controller);\\n    }\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isOwner(msg.sender),\\n      \\\"Controlled::onlyOwner: Caller is not owner\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyManager() {\\n    require(\\n      IKernel(moduleMap.getModuleAddress(Modules.Kernel)).isManager(msg.sender),\\n      \\\"Controlled::onlyManager: Caller is not manager\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyController() {\\n    require(\\n      _controllers[msg.sender],\\n      \\\"Controlled::onlyController: Caller is not controller\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ModuleMapConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IModuleMap.sol\\\";\\n\\nabstract contract ModuleMapConsumer is Initializable {\\n  IModuleMap public moduleMap;\\n\\n  function __ModuleMapConsumer_init(address moduleMap_) internal initializer {\\n    moduleMap = IModuleMap(moduleMap_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/core/StrategyMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ModuleMapConsumer.sol\\\";\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"../interfaces/IStrategyMap.sol\\\";\\nimport \\\"../interfaces/IIntegrationMap.sol\\\";\\nimport \\\"../interfaces/IUserPositions.sol\\\";\\nimport \\\"../interfaces/IYieldManager.sol\\\";\\n\\ncontract StrategyMap is\\n  Initializable,\\n  ModuleMapConsumer,\\n  Controlled,\\n  IStrategyMap\\n{\\n  // #### Global State\\n  // Strategy id => Strategy\\n  mapping(uint256 => Strategy) internal strategies;\\n\\n  // Strategy => token => balance\\n  mapping(uint256 => mapping(address => uint256)) internal strategyBalances;\\n\\n  // User => strategy => token => balance\\n  mapping(address => mapping(uint256 => mapping(address => uint256)))\\n    internal userStrategyBalances;\\n\\n  // User => token => balance\\n  mapping(address => mapping(address => uint256)) internal userInvestedBalances;\\n\\n  // Token => balance\\n  mapping(address => uint256) internal totalBalances;\\n\\n  // Integration => token => gross balance inclusive of reserve amount\\n  mapping(address => mapping(address => uint256)) internal integrationBalances;\\n\\n  // Integration => weight\\n  mapping(address => uint256) internal integrationWeights;\\n  uint256 internal totalSystemWeight;\\n\\n  uint256 public override idCounter;\\n\\n  // #### Functions\\n  function initialize(address[] memory controllers_, address moduleMap_)\\n    public\\n    initializer\\n  {\\n    __Controlled_init(controllers_, moduleMap_);\\n  }\\n\\n  function addStrategy(\\n    string calldata name,\\n    WeightedIntegration[] memory integrations,\\n    address[] calldata tokens\\n  ) external override onlyController {\\n    require(bytes(name).length > 0, \\\"Must have a name\\\");\\n    require(integrations.length > 0, \\\"Must have >= 1 integration\\\");\\n    require(tokens.length > 0, \\\"Must have tokens\\\");\\n\\n    idCounter++;\\n    uint256 strategyID = idCounter;\\n    strategies[strategyID].name = name;\\n    \\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      strategies[strategyID].enabledTokens[tokens[i]] = true;\\n      strategies[strategyID].tokens.push(tokens[i]);\\n    }\\n\\n    uint256 totalStrategyWeight = 0;\\n    uint256 _systemWeight = totalSystemWeight;\\n    for (uint256 i = 0; i < integrations.length; i++) {\\n      if (integrations[i].weight > 0) {\\n        _systemWeight += integrations[i].weight;\\n        integrationWeights[integrations[i].integration] += integrations[i]\\n          .weight;\\n        strategies[strategyID].integrations.push(integrations[i]);\\n        totalStrategyWeight += integrations[i].weight;\\n      }\\n    }\\n    totalSystemWeight = _systemWeight;\\n    strategies[strategyID].totalStrategyWeight = totalStrategyWeight;\\n\\n    emit NewStrategy(strategyID, name, integrations, tokens);\\n  }\\n\\n  function updateName(uint256 id, string calldata name)\\n    external\\n    override\\n    onlyController\\n  {\\n    require(bytes(name).length > 0, \\\"Must have a name\\\");\\n    require(\\n      strategies[id].integrations.length > 0 &&\\n        bytes(strategies[id].name).length > 0,\\n      \\\"Strategy must exist\\\"\\n    );\\n    strategies[id].name = name;\\n    emit UpdateName(id, name);\\n  }\\n\\n  function updateTokens(uint256 id, address[] calldata tokens)\\n    external\\n    override\\n    onlyController\\n  {\\n    address[] memory oldTokens = strategies[id].tokens;\\n    for (uint256 i; i < oldTokens.length; i++) {\\n      strategies[id].enabledTokens[oldTokens[i]] = false;\\n    }\\n    for (uint256 i; i < tokens.length; i++) {\\n      strategies[id].enabledTokens[tokens[i]] = true;\\n    }\\n    delete strategies[id].tokens;\\n    strategies[id].tokens = tokens;\\n    emit UpdateTokens(id, tokens);\\n  }\\n\\n  function updateIntegrations(\\n    uint256 id,\\n    WeightedIntegration[] memory integrations\\n  ) external override onlyController {\\n    StrategySummary memory currentStrategy = _getStrategySummary(id);\\n    require(\\n      currentStrategy.integrations.length > 0 &&\\n        bytes(currentStrategy.name).length > 0,\\n      \\\"Strategy must exist\\\"\\n    );\\n\\n    IIntegrationMap integrationMap = IIntegrationMap(\\n      moduleMap.getModuleAddress(Modules.IntegrationMap)\\n    );\\n    WeightedIntegration[] memory currentIntegrations = strategies[id]\\n      .integrations;\\n\\n    uint256 tokenCount = integrationMap.getTokenAddressesLength();\\n\\n    uint256 _systemWeight = totalSystemWeight;\\n    for (uint256 i = 0; i < currentIntegrations.length; i++) {\\n      _systemWeight -= currentIntegrations[i].weight;\\n      integrationWeights[\\n        currentIntegrations[i].integration\\n      ] -= currentIntegrations[i].weight;\\n    }\\n    delete strategies[id].integrations;\\n\\n    uint256 newStrategyTotalWeight;\\n    for (uint256 i = 0; i < integrations.length; i++) {\\n      if (integrations[i].weight > 0) {\\n        newStrategyTotalWeight += integrations[i].weight;\\n        strategies[id].integrations.push(integrations[i]);\\n        _systemWeight += integrations[i].weight;\\n        integrationWeights[integrations[i].integration] += integrations[i]\\n          .weight;\\n      }\\n    }\\n\\n    totalSystemWeight = _systemWeight;\\n    strategies[id].totalStrategyWeight = newStrategyTotalWeight;\\n\\n    for (uint256 i = 0; i < tokenCount; i++) {\\n      address token = integrationMap.getTokenAddress(i);\\n      if (strategyBalances[id][token] > 0) {\\n        for (uint256 j = 0; j < currentIntegrations.length; j++) {\\n          // Remove token amounts from integration balances\\n\\n          integrationBalances[currentIntegrations[j].integration][\\n            token\\n          ] -= _calculateIntegrationAllocation(\\n            strategyBalances[id][token],\\n            currentIntegrations[j].weight,\\n            currentStrategy.totalStrategyWeight\\n          );\\n        }\\n        for (uint256 j = 0; j < integrations.length; j++) {\\n          if (integrations[j].weight > 0) {\\n            // Add new token balances\\n            integrationBalances[integrations[j].integration][\\n              token\\n            ] += _calculateIntegrationAllocation(\\n              strategyBalances[id][token],\\n              integrations[j].weight,\\n              newStrategyTotalWeight\\n            );\\n          }\\n        }\\n      }\\n    }\\n\\n    emit UpdateIntegrations(id, integrations);\\n  }\\n\\n  function deleteStrategy(uint256 id) external override onlyController {\\n    StrategySummary memory currentStrategy = _getStrategySummary(id);\\n    // Checks\\n    IIntegrationMap integrationMap = IIntegrationMap(\\n      moduleMap.getModuleAddress(Modules.IntegrationMap)\\n    );\\n    uint256 tokenCount = integrationMap.getTokenAddressesLength();\\n\\n    for (uint256 i = 0; i < tokenCount; i++) {\\n      require(\\n        getStrategyTokenBalance(id, integrationMap.getTokenAddress(i)) == 0,\\n        \\\"Strategy in use\\\"\\n      );\\n    }\\n    uint256 _systemWeight = totalSystemWeight;\\n    for (uint256 i = 0; i < currentStrategy.integrations.length; i++) {\\n      _systemWeight -= currentStrategy.integrations[i].weight;\\n      integrationWeights[\\n        currentStrategy.integrations[i].integration\\n      ] -= currentStrategy.integrations[i].weight;\\n    }\\n    totalSystemWeight = _systemWeight;\\n\\n    delete strategies[id];\\n\\n    emit DeleteStrategy(\\n      id,\\n      currentStrategy.name,\\n      currentStrategy.tokens,\\n      currentStrategy.integrations\\n    );\\n  }\\n\\n  function _deposit(\\n    uint256 id,\\n    address user,\\n    StrategyTransaction memory deposits\\n  ) internal {\\n    StrategySummary memory strategy = _getStrategySummary(id);\\n    require(strategy.integrations.length > 0, \\\"Strategy doesn't exist\\\");\\n\\n    strategyBalances[id][deposits.token] += deposits.amount;\\n    userInvestedBalances[user][deposits.token] += deposits.amount;\\n    userStrategyBalances[user][id][deposits.token] += deposits.amount;\\n    totalBalances[deposits.token] += deposits.amount;\\n\\n    for (uint256 j = 0; j < strategy.integrations.length; j++) {\\n      integrationBalances[strategy.integrations[j].integration][\\n        deposits.token\\n      ] += _calculateIntegrationAllocation(\\n        deposits.amount,\\n        strategy.integrations[j].weight,\\n        strategy.totalStrategyWeight\\n      );\\n    }\\n  }\\n\\n  function _withdraw(\\n    uint256 id,\\n    address user,\\n    StrategyTransaction memory withdrawals\\n  ) internal {\\n    StrategySummary memory strategy = _getStrategySummary(id);\\n    require(strategy.integrations.length > 0, \\\"Strategy doesn't exist\\\");\\n\\n    strategyBalances[id][withdrawals.token] -= withdrawals.amount;\\n    userInvestedBalances[user][withdrawals.token] -= withdrawals.amount;\\n    userStrategyBalances[user][id][withdrawals.token] -= withdrawals.amount;\\n    totalBalances[withdrawals.token] -= withdrawals.amount;\\n\\n    for (uint256 j = 0; j < strategy.integrations.length; j++) {\\n      integrationBalances[strategy.integrations[j].integration][\\n        withdrawals.token\\n      ] -= _calculateIntegrationAllocation(\\n        withdrawals.amount,\\n        strategy.integrations[j].weight,\\n        strategy.totalStrategyWeight\\n      );\\n    }\\n  }\\n\\n  function enterStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external override onlyController {\\n    require(amounts.length == tokens.length, \\\"Length mismatch\\\");\\n    require(strategies[id].integrations.length > 0, \\\"Strategy must exist\\\");\\n    IIntegrationMap integrationMap = IIntegrationMap(\\n      moduleMap.getModuleAddress(Modules.IntegrationMap)\\n    );\\n\\n    IUserPositions userPositions = IUserPositions(\\n      moduleMap.getModuleAddress(Modules.UserPositions)\\n    );\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      require(amounts[i] > 0, \\\"Amount is 0\\\");\\n      require(strategies[id].enabledTokens[tokens[i]], \\\"Invalid token\\\");\\n      require(\\n        integrationMap.getTokenAcceptingDeposits(tokens[i]),\\n        \\\"Token unavailable\\\"\\n      );\\n\\n      // Check that a user has enough funds on deposit\\n      require(\\n        userPositions.userTokenBalance(tokens[i], user) >= amounts[i],\\n        \\\"User lacks funds\\\"\\n      );\\n      _deposit(\\n        id,\\n        user,\\n        IStrategyMap.StrategyTransaction(amounts[i], tokens[i])\\n      );\\n    }\\n\\n    emit EnterStrategy(id, user, tokens, amounts);\\n  }\\n\\n  function exitStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external override onlyController {\\n    require(amounts.length == tokens.length, \\\"Length mismatch\\\");\\n    IIntegrationMap integrationMap = IIntegrationMap(\\n      moduleMap.getModuleAddress(Modules.IntegrationMap)\\n    );\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      require(\\n        getUserInvestedAmountByToken(tokens[i], user) >= amounts[i],\\n        \\\"Insufficient Funds\\\"\\n      );\\n\\n      require(\\n        integrationMap.getTokenAcceptingWithdrawals(tokens[i]),\\n        \\\"Token unavailable\\\"\\n      );\\n      require(amounts[i] > 0, \\\"Amount is 0\\\");\\n\\n      _withdraw(\\n        id,\\n        user,\\n        IStrategyMap.StrategyTransaction(amounts[i], tokens[i])\\n      );\\n    }\\n\\n    emit ExitStrategy(id, user, tokens, amounts);\\n  }\\n\\n  /**\\n    @notice Calculates the amount of tokens to adjust an integration's expected invested amount by\\n    @param totalDepositedAmount  the total amount a user is depositing or withdrawing from a strategy\\n    @param integrationWeight  the weight of the integration as part of the strategy\\n    @param strategyWeight  the sum of all weights in the strategy\\n    @return amount  the amount to adjust the integration balance by\\n     */\\n  function _calculateIntegrationAllocation(\\n    uint256 totalDepositedAmount,\\n    uint256 integrationWeight,\\n    uint256 strategyWeight\\n  ) internal pure returns (uint256 amount) {\\n    return (totalDepositedAmount * integrationWeight) / strategyWeight;\\n  }\\n\\n  function _getStrategySummary(uint256 id)\\n    internal\\n    view\\n    returns (StrategySummary memory)\\n  {\\n    StrategySummary memory result;\\n    result.integrations = strategies[id].integrations;\\n    result.name = strategies[id].name;\\n    result.tokens = strategies[id].tokens;\\n    result.totalStrategyWeight = strategies[id].totalStrategyWeight;\\n    return result;\\n  }\\n\\n  function getStrategyTokenBalance(uint256 id, address token)\\n    public\\n    view\\n    override\\n    returns (uint256 amount)\\n  {\\n    amount = strategyBalances[id][token];\\n  }\\n\\n  function getUserStrategyBalanceByToken(\\n    uint256 id,\\n    address token,\\n    address user\\n  ) public view override returns (uint256 amount) {\\n    amount = userStrategyBalances[user][id][token];\\n  }\\n\\n  function getUserInvestedAmountByToken(address token, address user)\\n    public\\n    view\\n    override\\n    returns (uint256 amount)\\n  {\\n    amount = userInvestedBalances[user][token];\\n  }\\n\\n  function getTokenTotalBalance(address token)\\n    public\\n    view\\n    override\\n    returns (uint256 amount)\\n  {\\n    amount = totalBalances[token];\\n  }\\n\\n  function getStrategy(uint256 id)\\n    external\\n    view\\n    override\\n    returns (StrategySummary memory)\\n  {\\n    return _getStrategySummary(id);\\n  }\\n\\n  function getExpectedBalance(address integration, address token)\\n    external\\n    view\\n    override\\n    returns (uint256 balance)\\n  {\\n    return integrationBalances[integration][token];\\n  }\\n\\n  function getIntegrationWeight(address integration)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return integrationWeights[integration];\\n  }\\n\\n  function getIntegrationWeightSum() external view override returns (uint256) {\\n    return totalSystemWeight;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIntegration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IIntegration {\\n  /// @param tokenAddress The address of the deposited token\\n  /// @param amount The amount of the token being deposited\\n  function deposit(address tokenAddress, uint256 amount) external;\\n\\n  /// @param tokenAddress The address of the withdrawal token\\n  /// @param amount The amount of the token to withdraw\\n  function withdraw(address tokenAddress, uint256 amount) external;\\n\\n  /// @dev Deploys all tokens held in the integration contract to the integrated protocol\\n  function deploy() external;\\n\\n  /// @dev Harvests token yield from the Aave lending pool\\n  function harvestYield() external;\\n\\n  /// @dev This returns the total amount of the underlying token that\\n  /// @dev has been deposited to the integration contract\\n  /// @param tokenAddress The address of the deployed token\\n  /// @return The amount of the underlying token that can be withdrawn\\n  function getBalance(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIntegrationMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IIntegrationMap {\\n  struct Integration {\\n    bool added;\\n    string name;\\n  }\\n\\n  struct Token {\\n    uint256 id;\\n    bool added;\\n    bool acceptingDeposits;\\n    bool acceptingWithdrawals;\\n    uint256 biosRewardWeight;\\n    uint256 reserveRatioNumerator;\\n  }\\n\\n  /// @param contractAddress The address of the integration contract\\n  /// @param name The name of the protocol being integrated to\\n  function addIntegration(address contractAddress, string memory name) external;\\n\\n  /// @param tokenAddress The address of the ERC20 token contract\\n  /// @param acceptingDeposits Whether token deposits are enabled\\n  /// @param acceptingWithdrawals Whether token withdrawals are enabled\\n  /// @param biosRewardWeight Token weight for BIOS rewards\\n  /// @param reserveRatioNumerator Number that gets divided by reserve ratio denominator to get reserve ratio\\n  function addToken(\\n    address tokenAddress,\\n    bool acceptingDeposits,\\n    bool acceptingWithdrawals,\\n    uint256 biosRewardWeight,\\n    uint256 reserveRatioNumerator\\n  ) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function enableTokenDeposits(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function disableTokenDeposits(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function enableTokenWithdrawals(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  function disableTokenWithdrawals(address tokenAddress) external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @param rewardWeight The updated token BIOS reward weight\\n  function updateTokenRewardWeight(address tokenAddress, uint256 rewardWeight)\\n    external;\\n\\n  /// @param tokenAddress the address of the token ERC20 contract\\n  /// @param reserveRatioNumerator Number that gets divided by reserve ratio denominator to get reserve ratio\\n  function updateTokenReserveRatioNumerator(\\n    address tokenAddress,\\n    uint256 reserveRatioNumerator\\n  ) external;\\n\\n  /// @param integrationId The ID of the integration\\n  /// @return The address of the integration contract\\n  function getIntegrationAddress(uint256 integrationId)\\n    external\\n    view\\n    returns (address);\\n\\n  /// @param integrationAddress The address of the integration contract\\n  /// @return The name of the of the protocol being integrated to\\n  function getIntegrationName(address integrationAddress)\\n    external\\n    view\\n    returns (string memory);\\n\\n  /// @return The address of the WETH token\\n  function getWethTokenAddress() external view returns (address);\\n\\n  /// @return The address of the BIOS token\\n  function getBiosTokenAddress() external view returns (address);\\n\\n  /// @param tokenId The ID of the token\\n  /// @return The address of the token ERC20 contract\\n  function getTokenAddress(uint256 tokenId) external view returns (address);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The index of the token in the tokens array\\n  function getTokenId(address tokenAddress) external view returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The token BIOS reward weight\\n  function getTokenBiosRewardWeight(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return rewardWeightSum reward weight of depositable tokens\\n  function getBiosRewardWeightSum()\\n    external\\n    view\\n    returns (uint256 rewardWeightSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return bool indicating whether depositing this token is currently enabled\\n  function getTokenAcceptingDeposits(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return bool indicating whether withdrawing this token is currently enabled\\n  function getTokenAcceptingWithdrawals(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  // @param tokenAddress The address of the token ERC20 contract\\n  // @return bool indicating whether the token has been added\\n  function getIsTokenAdded(address tokenAddress) external view returns (bool);\\n\\n  // @param integrationAddress The address of the integration contract\\n  // @return bool indicating whether the integration has been added\\n  function getIsIntegrationAdded(address tokenAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @notice get the length of supported tokens\\n  /// @return The quantity of tokens added\\n  function getTokenAddressesLength() external view returns (uint256);\\n\\n  /// @notice get the length of supported integrations\\n  /// @return The quantity of integrations added\\n  function getIntegrationAddressesLength() external view returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The value that gets divided by the reserve ratio denominator\\n  function getTokenReserveRatioNumerator(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return The token reserve ratio denominator\\n  function getReserveRatioDenominator() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IKernel {\\n  /// @param account The address of the account to check if they are a manager\\n  /// @return Bool indicating whether the account is a manger\\n  function isManager(address account) external view returns (bool);\\n\\n  /// @param account The address of the account to check if they are an owner\\n  /// @return Bool indicating whether the account is an owner\\n  function isOwner(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\nenum Modules {\\n  Kernel, // 0\\n  UserPositions, // 1\\n  YieldManager, // 2\\n  IntegrationMap, // 3\\n  BiosRewards, // 4\\n  EtherRewards, // 5\\n  SushiSwapTrader, // 6\\n  UniswapTrader, // 7\\n  StrategyMap, // 8\\n  StrategyManager // 9\\n}\\n\\ninterface IModuleMap {\\n  function getModuleAddress(Modules key) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategyMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\nimport \\\"../interfaces/IIntegration.sol\\\";\\n\\ninterface IStrategyMap {\\n  // #### Structs\\n  struct WeightedIntegration {\\n    address integration;\\n    uint256 weight;\\n  }\\n\\n  struct Strategy {\\n    string name;\\n    uint256 totalStrategyWeight;\\n    mapping(address => bool) enabledTokens;\\n    address[] tokens;\\n    WeightedIntegration[] integrations;\\n  }\\n\\n  struct StrategySummary {\\n    string name;\\n    uint256 totalStrategyWeight;\\n    address[] tokens;\\n    WeightedIntegration[] integrations;\\n  }\\n\\n  struct StrategyTransaction {\\n    uint256 amount;\\n    address token;\\n  }\\n\\n  // #### Events\\n  event NewStrategy(\\n    uint256 indexed id,\\n    string name,\\n    WeightedIntegration[] integrations,\\n    address[] tokens\\n  );\\n  event UpdateName(uint256 indexed id, string name);\\n  event UpdateIntegrations(\\n    uint256 indexed id,\\n    WeightedIntegration[] integrations\\n  );\\n  event UpdateTokens(uint256 indexed id, address[] tokens);\\n  event DeleteStrategy(\\n    uint256 indexed id,\\n    string name,\\n    address[] tokens,\\n    WeightedIntegration[] integrations\\n  );\\n\\n  event EnterStrategy(\\n    uint256 indexed id,\\n    address indexed user,\\n    address[] tokens,\\n    uint256[] amounts\\n  );\\n  event ExitStrategy(\\n    uint256 indexed id,\\n    address indexed user,\\n    address[] tokens,\\n    uint256[] amounts\\n  );\\n\\n  // #### Functions\\n  /**\\n     @notice Adds a new strategy to the list of available strategies\\n     @param name  the name of the new strategy\\n     @param integrations  the integrations and weights that form the strategy\\n     */\\n  function addStrategy(\\n    string calldata name,\\n    WeightedIntegration[] memory integrations,\\n    address[] calldata tokens\\n  ) external;\\n\\n  /**\\n    @notice Updates the strategy name\\n    @param name  the new name\\n     */\\n  function updateName(uint256 id, string calldata name) external;\\n\\n  /**\\n  @notice Updates a strategy's accepted tokens\\n  @param id  The strategy ID\\n  @param tokens  The new tokens to allow\\n  */\\n  function updateTokens(uint256 id, address[] calldata tokens) external;\\n\\n  /**\\n    @notice Updates the strategy integrations \\n    @param integrations  the new integrations\\n     */\\n  function updateIntegrations(\\n    uint256 id,\\n    WeightedIntegration[] memory integrations\\n  ) external;\\n\\n  /**\\n    @notice Deletes a strategy\\n    @dev This can only be called successfully if the strategy being deleted doesn't have any assets invested in it\\n    @param id  the strategy to delete\\n     */\\n  function deleteStrategy(uint256 id) external;\\n\\n  /**\\n    @notice Increases the amount of a set of tokens in a strategy\\n    @param id  the strategy to deposit into\\n    @param tokens  the tokens to deposit\\n    @param amounts  The amounts to be deposited\\n     */\\n  function enterStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n    @notice Decreases the amount of a set of tokens invested in a strategy\\n    @param id  the strategy to withdraw assets from\\n    @param tokens  the tokens to withdraw\\n    @param amounts  The amounts to be withdrawn\\n     */\\n  function exitStrategy(\\n    uint256 id,\\n    address user,\\n    address[] calldata tokens,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n    @notice Getter function to return the nested arrays as well as the name\\n    @param id  the strategy to return\\n     */\\n  function getStrategy(uint256 id)\\n    external\\n    view\\n    returns (StrategySummary memory);\\n\\n  /**\\n    @notice Returns the expected balance of a given token in a given integration\\n    @param integration  the integration the amount should be invested in\\n    @param token  the token that is being invested\\n    @return balance  the balance of the token that should be currently invested in the integration \\n     */\\n  function getExpectedBalance(address integration, address token)\\n    external\\n    view\\n    returns (uint256 balance);\\n\\n  /**\\n    @notice Returns the amount of a given token currently invested in a strategy\\n    @param id  the strategy id to check\\n    @param token  The token to retrieve the balance for\\n    @return amount  the amount of token that is invested in the strategy\\n     */\\n  function getStrategyTokenBalance(uint256 id, address token)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n    @notice returns the amount of a given token a user has invested in a given strategy\\n    @param id  the strategy id\\n    @param token  the token address\\n    @param user  the user who holds the funds\\n    @return amount  the amount of token that the user has invested in the strategy \\n     */\\n  function getUserStrategyBalanceByToken(\\n    uint256 id,\\n    address token,\\n    address user\\n  ) external view returns (uint256 amount);\\n\\n  /**\\n    @notice Returns the amount of a given token that a user has invested across all strategies\\n    @param token  the token address\\n    @param user  the user holding the funds\\n    @return amount  the amount of tokens the user has invested across all strategies\\n     */\\n  function getUserInvestedAmountByToken(address token, address user)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n    @notice Returns the total amount of a token invested across all strategies\\n    @param token  the token to fetch the balance for\\n    @return amount  the amount of the token currently invested\\n    */\\n  function getTokenTotalBalance(address token)\\n    external\\n    view\\n    returns (uint256 amount);\\n\\n  /**\\n  @notice Returns the weight of an individual integration within the system\\n  @param integration  the integration to look up\\n  @return The weight of the integration\\n   */\\n  function getIntegrationWeight(address integration)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n  @notice Returns the sum of all weights in the system.\\n  @return The sum of all integration weights within the system\\n   */\\n  function getIntegrationWeightSum() external view returns (uint256);\\n\\n  /// @notice autogenerated getter definition\\n  function idCounter() external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUserPositions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IUserPositions {\\n  /// @param biosRewardsDuration_ The duration in seconds for a BIOS rewards period to last\\n  function setBiosRewardsDuration(uint32 biosRewardsDuration_) external;\\n\\n  /// @param sender The account seeding BIOS rewards\\n  /// @param biosAmount The amount of BIOS to add to rewards\\n  function seedBiosRewards(address sender, uint256 biosAmount) external;\\n\\n  /// @notice Sends all BIOS available in the Kernel to each token BIOS rewards pool based up configured weights\\n  function increaseBiosRewards() external;\\n\\n  /// @notice User is allowed to deposit whitelisted tokens\\n  /// @param depositor Address of the account depositing\\n  /// @param tokens Array of token the token addresses\\n  /// @param amounts Array of token amounts\\n  /// @param ethAmount The amount of ETH sent with the deposit\\n  function deposit(\\n    address depositor,\\n    address[] memory tokens,\\n    uint256[] memory amounts,\\n    uint256 ethAmount\\n  ) external;\\n\\n  /// @notice User is allowed to withdraw tokens\\n  /// @param recipient The address of the user withdrawing\\n  /// @param tokens Array of token the token addresses\\n  /// @param amounts Array of token amounts\\n  /// @param withdrawWethAsEth Boolean indicating whether should receive WETH balance as ETH\\n  function withdraw(\\n    address recipient,\\n    address[] memory tokens,\\n    uint256[] memory amounts,\\n    bool withdrawWethAsEth\\n  ) external returns (uint256 ethWithdrawn);\\n\\n  /// @notice Allows a user to withdraw entire balances of the specified tokens and claim rewards\\n  /// @param recipient The address of the user withdrawing tokens\\n  /// @param tokens Array of token address that user is exiting positions from\\n  /// @param withdrawWethAsEth Boolean indicating whether should receive WETH balance as ETH\\n  /// @return tokenAmounts The amounts of each token being withdrawn\\n  /// @return ethWithdrawn The amount of ETH being withdrawn\\n  /// @return ethClaimed The amount of ETH being claimed from rewards\\n  /// @return biosClaimed The amount of BIOS being claimed from rewards\\n  function withdrawAllAndClaim(\\n    address recipient,\\n    address[] memory tokens,\\n    bool withdrawWethAsEth\\n  )\\n    external\\n    returns (\\n      uint256[] memory tokenAmounts,\\n      uint256 ethWithdrawn,\\n      uint256 ethClaimed,\\n      uint256 biosClaimed\\n    );\\n\\n  /// @param user The address of the user claiming ETH rewards\\n  function claimEthRewards(address user) external returns (uint256 ethClaimed);\\n\\n  /// @notice Allows users to claim their BIOS rewards for each token\\n  /// @param recipient The address of the usuer claiming BIOS rewards\\n  function claimBiosRewards(address recipient)\\n    external\\n    returns (uint256 biosClaimed);\\n\\n  /// @param asset Address of the ERC20 token contract\\n  /// @return The total balance of the asset deposited in the system\\n  function totalTokenBalance(address asset) external view returns (uint256);\\n\\n  /// @param asset Address of the ERC20 token contract\\n  /// @param account Address of the user account\\n  function userTokenBalance(address asset, address account)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return The Bios Rewards Duration\\n  function getBiosRewardsDuration() external view returns (uint32);\\n\\n  /// @notice Transfers tokens to the StrategyMap\\n  /// @dev This is a ledger adjustment. The tokens remain in the kernel.\\n  /// @param recipient  The user to transfer funds for\\n  /// @param tokens  the tokens to be moved\\n  /// @param amounts  the amounts of each token to move\\n  function transferToStrategy(\\n    address recipient,\\n    address[] memory tokens,\\n    uint256[] memory amounts\\n  ) external;\\n\\n  /// @notice Transfers tokens from the StrategyMap\\n  /// @dev This is a ledger adjustment. The tokens remain in the kernel.\\n  /// @param recipient  The user to transfer funds for\\n  /// @param tokens  the tokens to be moved\\n  /// @param amounts  the amounts of each token to move\\n  function transferFromStrategy(\\n    address recipient,\\n    address[] memory tokens,\\n    uint256[] memory amounts\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IYieldManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.4;\\n\\ninterface IYieldManager {\\n  /// @param gasAccountTargetEthBalance_ The target ETH balance of the gas account\\n  function updateGasAccountTargetEthBalance(uint256 gasAccountTargetEthBalance_)\\n    external;\\n\\n  /// @param biosBuyBackEthWeight_ The relative weight of ETH to send to BIOS buy back\\n  /// @param treasuryEthWeight_ The relative weight of ETH to send to the treasury\\n  /// @param protocolFeeEthWeight_ The relative weight of ETH to send to protocol fee accrual\\n  /// @param rewardsEthWeight_ The relative weight of ETH to send to user rewards\\n  function updateEthDistributionWeights(\\n    uint32 biosBuyBackEthWeight_,\\n    uint32 treasuryEthWeight_,\\n    uint32 protocolFeeEthWeight_,\\n    uint32 rewardsEthWeight_\\n  ) external;\\n\\n  /// @param gasAccount_ The address of the account to send ETH to gas for executing bulk system functions\\n  function updateGasAccount(address payable gasAccount_) external;\\n\\n  /// @param treasuryAccount_ The address of the system treasury account\\n  function updateTreasuryAccount(address payable treasuryAccount_) external;\\n\\n  /// @notice Withdraws and then re-deploys tokens to integrations according to configured weights\\n  function rebalance() external;\\n\\n  /// @notice Deploys all tokens to all integrations according to configured weights\\n  function deploy() external;\\n\\n  /// @notice Harvests available yield from all tokens and integrations\\n  function harvestYield() external;\\n\\n  /// @notice Swaps harvested yield for all tokens for ETH\\n  function processYield() external;\\n\\n  /// @notice Distributes ETH to the gas account, BIOS buy back, treasury, protocol fee accrual, and user rewards\\n  function distributeEth() external;\\n\\n  /// @notice Uses WETH to buy back BIOS which is sent to the Kernel\\n  function biosBuyBack() external;\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return harvestedTokenBalance The amount of the token yield harvested held in the Kernel\\n  function getHarvestedTokenBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The amount of the token held in the Kernel as reserves\\n  function getReserveTokenBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The desired amount of the token to hold in the Kernel as reserves\\n  function getDesiredReserveTokenBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return ethWeightSum The sum of ETH distribution weights\\n  function getEthWeightSum() external view returns (uint32 ethWeightSum);\\n\\n  /// @return processedWethSum The sum of yields processed into WETH\\n  function getProcessedWethSum()\\n    external\\n    view\\n    returns (uint256 processedWethSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return The amount of WETH received from token yield processing\\n  function getProcessedWethByToken(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /// @return processedWethByTokenSum The sum of processed WETH\\n  function getProcessedWethByTokenSum()\\n    external\\n    view\\n    returns (uint256 processedWethByTokenSum);\\n\\n  /// @param tokenAddress The address of the token ERC20 contract\\n  /// @return tokenTotalIntegrationBalance The total amount of the token that can be withdrawn from integrations\\n  function getTokenTotalIntegrationBalance(address tokenAddress)\\n    external\\n    view\\n    returns (uint256 tokenTotalIntegrationBalance);\\n\\n  /// @return The address of the gas account\\n  function getGasAccount() external view returns (address);\\n\\n  /// @return The address of the treasury account\\n  function getTreasuryAccount() external view returns (address);\\n\\n  /// @return The last amount of ETH distributed to rewards\\n  function getLastEthRewardsAmount() external view returns (uint256);\\n\\n  /// @return The target ETH balance of the gas account\\n  function getGasAccountTargetEthBalance() external view returns (uint256);\\n\\n  /// @return The BIOS buyback ETH weight\\n  /// @return The Treasury ETH weight\\n  /// @return The Protocol fee ETH weight\\n  /// @return The rewards ETH weight\\n  function getEthDistributionWeights()\\n    external\\n    view\\n    returns (\\n      uint32,\\n      uint32,\\n      uint32,\\n      uint32\\n    );\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"}],\"name\":\"DeleteStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"EnterStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ExitStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"NewStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"}],\"name\":\"UpdateIntegrations\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"UpdateName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"UpdateTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"__Controlled_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"deleteStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"enterStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"exitStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getExpectedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"}],\"name\":\"getIntegrationWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIntegrationWeightSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStrategy\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalStrategyWeight\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IStrategyMap.StrategySummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getStrategyTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserInvestedAmountByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStrategyBalanceByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"controllers_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"moduleMap_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleMap\",\"outputs\":[{\"internalType\":\"contract IModuleMap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct IStrategyMap.WeightedIntegration[]\",\"name\":\"integrations\",\"type\":\"tuple[]\"}],\"name\":\"updateIntegrations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"updateName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"updateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StrategyMap","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}