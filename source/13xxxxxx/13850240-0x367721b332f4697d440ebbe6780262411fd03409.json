{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MoonCatMoments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IReverseResolver {\\n    function claim(address owner) external returns (bytes32);\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Utility library for managing a Set of items that also can be iterated over\\n * Based on the OpenZeppelin library: https://docs.openzeppelin.com/contracts/3.x/api/utils#EnumerableSet\\n * Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol\\n * Commit: b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        uint256[] _values;\\n        mapping (uint256 => uint256) _indexes;\\n    }\\n\\n    function at(Set storage set, uint256 index) internal view returns (uint256) {\\n        return set._values[index];\\n    }\\n\\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function length(Set storage set) internal view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function add(Set storage set, uint256 value) internal returns (bool) {\\n        if (!contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function remove(Set storage set, uint256 value) internal returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n            if (lastIndex != toDeleteIndex) {\\n                uint256 lastvalue = set._values[lastIndex];\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Compact representation of an access list for MoonCat assets\\n * If needing to store an access list of \\\"does token X have access?\\\" state, doing it as a mapping(uint256 => bool)\\n * needs one 'storage' action for each token ID stored (inefficient for a list with thousands of entries).\\n * This structure densly-packs \\\"booleans\\\" as individual bits in a 32-byte word, making it a maximum of 100 'storage' actions\\n * to set an access list for all 25,440 MoonCats.\\n */\\nlibrary MoonCatBitSet {\\n\\n    bytes32 constant Mask =  0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n    function setBit(bytes32[100] storage set, uint16 index)\\n        internal\\n    {\\n        uint16 wordIndex = index / 256;\\n        uint16 bitIndex = index % 256;\\n        bytes32 mask = Mask << (255 - bitIndex);\\n        set[wordIndex] |= mask;\\n    }\\n\\n    function clearBit(bytes32[100] storage set, uint16 index)\\n        internal\\n    {\\n        uint16 wordIndex = index / 256;\\n        uint16 bitIndex = index % 256;\\n        bytes32 mask = ~(Mask << (255 - bitIndex));\\n        set[wordIndex] &= mask;\\n    }\\n\\n    function checkBit(bytes32[100] memory set, uint256 index)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        uint256 wordIndex = index / 256;\\n        uint256 bitIndex = index % 256;\\n        bytes32 mask = Mask << (255 - bitIndex);\\n        return (mask & set[wordIndex]) != 0;\\n    }\\n\\n}\\n\\n/**\\n * @title MoonCatâ€‹Moments\\n * @notice NFTs of group photos MoonCats take together, commemorating special events\\n * @dev ERC721-compliant tokens, minted into existence as owned by the MoonCats themselves (ERC998 functionality)\\n */\\ncontract MoonCatMoments is IERC721Enumerable, IERC721Metadata {\\n\\n    // Acclimated MoonCats Address\\n    address public constant moonCatAcclimatorContract = 0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69;\\n\\n\\n    address public contractOwner;\\n\\n    bool public paused = true;\\n\\n    string public name = \\\"MoonCatMoments\\\";\\n    string public symbol = unicode\\\"ðŸ–¼\\\";\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private Owners;\\n\\n    using EnumerableSet for EnumerableSet.Set;\\n    // Mapping of owner address to owned token set\\n    mapping (address => EnumerableSet.Set) internal TokensByOwner;\\n    uint256 public acclimatorBalance = 0;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private TokenApprovals;\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private OperatorApprovals;\\n\\n    uint16 public totalMoments = 0;\\n\\n    struct Moment {\\n        uint16 momentId;\\n        uint16 startingTokenId;\\n        uint16 issuance;\\n        uint16 unclaimed;\\n        string tokenURI;\\n        bytes32[100] claimable;\\n    }\\n\\n    mapping(uint256 => Moment) public Moments;\\n\\n    uint256 public totalSupply = 0;\\n\\n    constructor() {\\n        contractOwner = msg.sender;\\n\\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148).claim(msg.sender);\\n    }\\n\\n    /* Enumerable */\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 tokenId) public pure returns (uint256) {\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(owner != moonCatAcclimatorContract, \\\"Cannot Enumerate Acclimator\\\");\\n        require(index < balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return TokensByOwner[owner].at(index);\\n    }\\n\\n    /* Owner Functions */\\n\\n    /**\\n     * @dev Allow current `owner` to transfer ownership to another address\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        contractOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Create a new Moment, and deliver the tokens directly to the indicated MoonCats\\n     */\\n    function mint(string calldata URI, uint16[] calldata rescueOrders) public onlyOwner {\\n        require(rescueOrders.length > 0, \\\"Empty rescueOrders\\\");\\n\\n        uint16 startingId = 0;\\n\\n        if (totalMoments > 0) {\\n            Moment memory previousMoment = Moments[totalMoments - 1];\\n            startingId = previousMoment.startingTokenId + previousMoment.issuance;\\n        }\\n\\n        bytes32[100] memory claimable;\\n\\n        Moments[totalMoments] = Moment(\\n            totalMoments,\\n            startingId,\\n            uint16(rescueOrders.length),\\n            0,\\n            URI,\\n            claimable\\n        );\\n        totalMoments++;\\n        totalSupply += rescueOrders.length;\\n\\n        for (uint i = 0; i < rescueOrders.length; i++) {\\n            uint256 tokenId = startingId + i;\\n            IERC721Receiver(moonCatAcclimatorContract).onERC721Received(\\n                address(this),\\n                address(this),\\n                tokenId,\\n                abi.encodePacked(uint256(rescueOrders[i]))\\n            );\\n            emit Transfer(address(0), moonCatAcclimatorContract, tokenId);\\n        }\\n        acclimatorBalance += rescueOrders.length;\\n    }\\n\\n    /**\\n     * @dev Create a new Moment, to be made available to MoonCat owners to claim\\n     */\\n    function mintClaimable(string calldata URI, uint16[] calldata rescueOrders) public onlyOwner {\\n        require(rescueOrders.length > 0, \\\"Empty rescueOrders\\\");\\n\\n        uint16 startingId = 0;\\n\\n        if (totalMoments > 0) {\\n            Moment memory previousMoment = Moments[totalMoments - 1];\\n            startingId = previousMoment.startingTokenId + previousMoment.issuance;\\n        }\\n\\n        bytes32[100] memory claimable;\\n\\n        Moments[totalMoments] = Moment(\\n            totalMoments,\\n            startingId,\\n            uint16(rescueOrders.length),\\n            uint16(rescueOrders.length),\\n            URI,\\n            claimable\\n        );\\n\\n        for (uint i = 0; i < rescueOrders.length; i++) {\\n            uint16 rescueOrder = rescueOrders[i];\\n            require(rescueOrder < 25440, \\\"Invalid rescueOrder\\\");\\n            require(!MoonCatBitSet.checkBit(Moments[totalMoments].claimable, rescueOrder), \\\"Duplicate RescueOrder\\\");\\n            MoonCatBitSet.setBit(Moments[totalMoments].claimable, rescueOrder);\\n        }\\n        totalMoments++;\\n        totalSupply += rescueOrders.length;\\n    }\\n\\n    /**\\n     * @dev Check and see if a given MoonCat is able to claim a given Moment\\n     */\\n    function isClaimable (uint256 momentId, uint256 rescueOrder) public view returns (bool) {\\n        return MoonCatBitSet.checkBit(Moments[momentId].claimable, rescueOrder);\\n    }\\n\\n    /**\\n     * @dev Given a list of MoonCat rescue orders, check a single Moment identifier and return a list of which of those MoonCats can claim it\\n     */\\n    function isClaimable (uint256 momentId, uint256[] calldata rescueOrders) public view returns (bool[] memory) {\\n        bool[] memory results = new bool[](rescueOrders.length);\\n        for (uint i = 0; i < rescueOrders.length; i++) {\\n            results[i] = isClaimable(momentId, rescueOrders[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Claim a Moment token that a given MoonCat is eligible for\\n     */\\n    function claim (uint256 momentId, uint256 rescueOrder) public whenNotPaused returns (uint256){\\n        require(isClaimable(momentId, rescueOrder), \\\"No Pending Claim\\\");\\n        MoonCatBitSet.clearBit(Moments[momentId].claimable, uint16(rescueOrder));\\n\\n        uint256 tokenId = Moments[momentId].startingTokenId + (Moments[momentId].issuance - Moments[momentId].unclaimed);\\n        Moments[momentId].unclaimed--;\\n        acclimatorBalance++;\\n        IERC721Receiver(moonCatAcclimatorContract).onERC721Received(\\n            address(this),\\n            address(this),\\n            tokenId,\\n            abi.encodePacked(rescueOrder)\\n        );\\n\\n        emit Transfer(address(0), moonCatAcclimatorContract, tokenId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev Claim several Moments that multiple MoonCats are eligible for\\n     */\\n    function batchClaim (uint256[] calldata momentIds, uint256[] calldata rescueOrders) public {\\n        require(momentIds.length == rescueOrders.length, \\\"Array length mismatch\\\");\\n        for (uint i = 0; i < momentIds.length; i++) {\\n            claim(momentIds[i], rescueOrders[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Claim a Moment that multiple MoonCats are eligible for\\n     */\\n    function batchClaim (uint256 momentId, uint256[] calldata rescueOrders) public {\\n        for (uint i = 0; i < rescueOrders.length; i++) {\\n            claim(momentId, rescueOrders[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Claim several Moments that a MoonCat is eligible for\\n     */\\n    function batchClaim (uint256[] calldata momentIds, uint256 rescueOrder) public {\\n        for (uint i = 0; i < momentIds.length; i++) {\\n            claim(momentIds[i], rescueOrder);\\n        }\\n    }\\n\\n    /**\\n     * @dev For a given MoonCat, claim any pending Moment they're eligible for\\n     */\\n    function batchClaim (uint256 rescueOrder) public {\\n        for (uint momentId = 0; momentId < totalMoments; momentId++) {\\n            if (isClaimable(momentId, rescueOrder)) {\\n                claim(momentId, rescueOrder);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev For multiple MoonCats, claim any pending Moments they're eligible for\\n     */\\n    function batchClaim (uint256[] calldata rescueOrders) public {\\n        for (uint i = 0; i < rescueOrders.length; i++) {\\n            batchClaim(rescueOrders[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev For a given MoonCat, fetch a list of Moment IDs that MoonCat is eligible to claim\\n     */\\n    function listClaimableMoments (uint256 rescueOrder) public view returns (uint16[] memory) {\\n        uint16[] memory claimableMoments = new uint16[](totalMoments);\\n        uint totalClaimable = 0;\\n        for (uint momentId = 0; momentId < totalMoments; momentId++) {\\n            if (isClaimable(momentId, rescueOrder)) {\\n                claimableMoments[totalClaimable] = uint16(momentId);\\n                totalClaimable++;\\n            }\\n        }\\n        uint16[] memory finalClaimable = new uint16[](totalClaimable);\\n        for (uint i = 0; i < totalClaimable; i++) {\\n            finalClaimable[i] = claimableMoments[i];\\n        }\\n        return finalClaimable;\\n    }\\n\\n    /**\\n     * @dev Update the metadata location for a given Moment\\n     */\\n    function setMomentURI(uint256 momentId, string calldata URI) public onlyOwner {\\n        require(momentId < totalMoments, \\\"Moment not Found\\\");\\n        Moments[momentId].tokenURI = URI;\\n    }\\n\\n    /**\\n     * @dev Prevent claiming of Moments\\n     */\\n    function paws () public onlyOwner {\\n        paused = true;\\n    }\\n\\n    /**\\n     * @dev Enable claiming of Moments\\n     */\\n    function unpaws () public onlyOwner {\\n        paused = false;\\n    }\\n\\n    /* Metadata */\\n\\n    /**\\n     * @dev For a given Moment token identifier, determine which Moment group it is a part of\\n     */\\n    function getMomentId(uint256 tokenId) public view returns (uint256) {\\n        require(tokenId < totalSupply, \\\"Nonexistent token\\\");\\n        uint256 count = 0;\\n        for (uint group = 0; group < totalMoments; group++) {\\n            count += Moments[group].issuance;\\n            if (tokenId < count) {\\n                return group;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        require(tokenId < totalSupply, \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n        return Moments[getMomentId(tokenId)].tokenURI;\\n    }\\n\\n    /**\\n     * @dev For a given Moment ID, fetch the metadata URI for that moment\\n     */\\n    function tokenURIByMomentId (uint256 momentId) public view returns (string memory) {\\n        require(momentId < totalMoments, \\\"Nonexistent Moment\\\");\\n        return Moments[momentId].tokenURI;\\n    }\\n\\n    /**\\n     * @dev Does a Moment token with the specified identifier exist?\\n     * Because some Moments are claimable, and don't come into existence until claimed, there will be gaps in the ID sequence.\\n     * This function gives a way to determine easily if a given identifier exists at all, before attempting further actions on it\\n     */\\n    function tokenExists(uint256 tokenId) public view returns (bool) {\\n        if (tokenId >= totalSupply) return false; // Out of bounds\\n        uint256 momentId = getMomentId(tokenId);\\n        if (tokenId - Moments[momentId].startingTokenId >= Moments[momentId].issuance - Moments[momentId].unclaimed) return false; // Unclaimed token\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        require(tokenExists(tokenId), \\\"Nonexistent token\\\");\\n        if (Owners[tokenId] == address(0)) {\\n            return moonCatAcclimatorContract;\\n        } else {\\n            return Owners[tokenId];\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return (owner == moonCatAcclimatorContract) ? acclimatorBalance : TokensByOwner[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\n        return\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC721Enumerable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal {\\n        TokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public  {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n                msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n                \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n                );\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(tokenId < totalSupply, \\\"ERC721: approved query for nonexistent token\\\");\\n        return TokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view  returns (bool) {\\n        return OperatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(\\n                               address operator,\\n                               bool approved\\n                               ) external virtual {\\n        require(msg.sender != operator, \\\"ERC721: approve to caller\\\");\\n        OperatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n        size := extcodesize(account)\\n                }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (isContract(to)) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                            }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal whenNotPaused {\\n        require(ownerOf(tokenId) == from , \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        // Remove tokenId from sender's registry\\n        if (from == moonCatAcclimatorContract) {\\n            acclimatorBalance--;\\n        } else {\\n            TokensByOwner[from].remove(tokenId);\\n        }\\n\\n        // Add tokenId to receiver's registry\\n        if (to == moonCatAcclimatorContract) {\\n            acclimatorBalance++;\\n        } else {\\n            TokensByOwner[to].add(tokenId);\\n        }\\n\\n        Owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(tokenId < totalSupply, \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /* Modifiers */\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == contractOwner, \\\"Not Owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(paused == false, \\\"Paused\\\");\\n        _;\\n    }\\n\\n    /* Rescuers */\\n\\n    /**\\n     * @dev Rescue ERC20 assets sent directly to this contract.\\n     */\\n    function withdrawForeignERC20(address tokenContract) public onlyOwner {\\n        IERC20 token = IERC20(tokenContract);\\n        token.transfer(contractOwner, token.balanceOf(address(this)));\\n        }\\n\\n    /**\\n     * @dev Rescue ERC721 assets sent directly to this contract.\\n     */\\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public onlyOwner {\\n        IERC721(tokenContract).safeTransferFrom(address(this), contractOwner, tokenId);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Moments\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"momentId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"startingTokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"issuance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"unclaimed\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acclimatorBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"momentIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"momentIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rescueOrders\",\"type\":\"uint256[]\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rescueOrders\",\"type\":\"uint256[]\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rescueOrders\",\"type\":\"uint256[]\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMomentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rescueOrders\",\"type\":\"uint256[]\"}],\"name\":\"isClaimable\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"isClaimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"listClaimableMoments\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"URI\",\"type\":\"string\"},{\"internalType\":\"uint16[]\",\"name\":\"rescueOrders\",\"type\":\"uint16[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"URI\",\"type\":\"string\"},{\"internalType\":\"uint16[]\",\"name\":\"rescueOrders\",\"type\":\"uint16[]\"}],\"name\":\"mintClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moonCatAcclimatorContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paws\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momentId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"URI\",\"type\":\"string\"}],\"name\":\"setMomentURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momentId\",\"type\":\"uint256\"}],\"name\":\"tokenURIByMomentId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMoments\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpaws\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawForeignERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MoonCatMoments","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}