{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface ERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @dev ERC-721 non-fungible token standard.\\r\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\r\\n */\\r\\ninterface ERC721\\r\\n{\\r\\n\\r\\n  /**\\r\\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\\r\\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\\r\\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\\r\\n   * transfer, the approved address for that NFT (if any) is reset to none.\\r\\n   */\\r\\n  event Transfer(\\r\\n    address indexed _from,\\r\\n    address indexed _to,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\\r\\n   * address indicates there is no approved address. When a Transfer event emits, this also\\r\\n   * indicates that the approved address for that NFT (if any) is reset to none.\\r\\n   */\\r\\n  event Approval(\\r\\n    address indexed _owner,\\r\\n    address indexed _approved,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\\r\\n   * all NFTs of the owner.\\r\\n   */\\r\\n  event ApprovalForAll(\\r\\n    address indexed _owner,\\r\\n    address indexed _operator,\\r\\n    bool _approved\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\r\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\r\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\r\\n   * function checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\r\\n   * `onERC721Received` on `_to` and throws if the return value is not\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\r\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\r\\n   * be changed to payable.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes calldata _data\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @notice This works identically to the other function with an extra data parameter, except this\\r\\n   * function just sets data to \\\"\\\"\\r\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\r\\n   * be changed to payable.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\r\\n   * they may be permanently lost.\\r\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\r\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\r\\n   * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.\\r\\n   * @param _from The current owner of the NFT.\\r\\n   * @param _to The new owner.\\r\\n   * @param _tokenId The NFT to transfer.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\r\\n   * the current NFT owner, or an authorized operator of the current owner.\\r\\n   * @param _approved The new approved NFT controller.\\r\\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\\r\\n   * @param _tokenId The NFT to approve.\\r\\n   */\\r\\n  function approve(\\r\\n    address _approved,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @notice The contract MUST allow multiple operators per owner.\\r\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\r\\n   * `msg.sender`\\u0027s assets. It also emits the ApprovalForAll event.\\r\\n   * @param _operator Address to add to the set of authorized operators.\\r\\n   * @param _approved True if the operators is approved, false to revoke approval.\\r\\n   */\\r\\n  function setApprovalForAll(\\r\\n    address _operator,\\r\\n    bool _approved\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\r\\n   * considered invalid, and this function throws for queries about the zero address.\\r\\n   * @notice Count all NFTs assigned to an owner.\\r\\n   * @param _owner Address for whom to query the balance.\\r\\n   * @return Balance of _owner.\\r\\n   */\\r\\n  function balanceOf(\\r\\n    address _owner\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice Find the owner of an NFT.\\r\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\\r\\n   * considered invalid, and queries about them do throw.\\r\\n   * @param _tokenId The identifier for an NFT.\\r\\n   * @return Address of _tokenId owner.\\r\\n   */\\r\\n  function ownerOf(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\r\\n   * @dev Get the approved address for a single NFT.\\r\\n   * @param _tokenId The NFT to find the approved address for.\\r\\n   * @return Address that _tokenId is approved for.\\r\\n   */\\r\\n  function getApproved(\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice Query if an address is an authorized operator for another address.\\r\\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\\r\\n   * @param _owner The address that owns the NFTs.\\r\\n   * @param _operator The address that acts on behalf of the owner.\\r\\n   * @return True if approved for all, false otherwise.\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address _owner,\\r\\n    address _operator\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n\\r\\n}\\r\\n\"},\"ethCustodial.sol\":{\"content\":\"pragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\ncontract ethCustodial {\\r\\n    mapping(address =\\u003e bool) public managers;\\r\\n\\r\\n    event ERC721TransferOut(ERC721 _contractAddress, address _to, uint256 _tokenId);\\r\\n    event ERC20TransferOut(ERC20 _contractAddress, address _to, uint256 _amount);\\r\\n    event EthWithdrawal(address _receiver, uint256 _amount);\\r\\n    event ManagerAdded(address _manager);\\r\\n    event ManagerRemoved(address _manager);\\r\\n\\r\\n    constructor() {\\r\\n        managers[msg.sender] = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyManagers() {\\r\\n        require(managers[msg.sender], \\\"Only managers allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addManager(address _manager) public onlyManagers {\\r\\n        managers[_manager] = true;\\r\\n        emit ManagerAdded(_manager);\\r\\n    }\\r\\n\\r\\n    function removeManager(address _manager) public onlyManagers {\\r\\n        managers[_manager] = false;\\r\\n        emit ManagerRemoved(_manager);\\r\\n    }\\r\\n\\r\\n    function transferOutERC721(ERC721 _erc721ContractAddress, uint256 _tokenId, address _receiver) public onlyManagers {\\r\\n        require(managers[_receiver], \\\"Only managers allowed as receiver\\\");\\r\\n        _erc721ContractAddress.transferFrom(address(this), _receiver, _tokenId);\\r\\n        emit ERC721TransferOut(_erc721ContractAddress, _receiver, _tokenId);\\r\\n    }\\r\\n\\r\\n    function transferOutERC20(ERC20 _erc20ContractAddress, uint256 _amount, address _receiver) public onlyManagers {\\r\\n        require(managers[_receiver], \\\"Only managers allowed as receiver\\\");\\r\\n        _erc20ContractAddress.transfer(_receiver, _amount);\\r\\n        emit ERC20TransferOut(_erc20ContractAddress, _receiver, _amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(address payable _receiver, uint256 _amount) public onlyManagers {\\r\\n        if(_amount == 0)\\r\\n            _amount = address(this).balance;\\r\\n\\r\\n        _receiver.transfer(_amount);\\r\\n        emit EthWithdrawal(_receiver, _amount);\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ERC20TransferOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC721\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721TransferOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EthWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_erc20ContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"transferOutERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC721\",\"name\":\"_erc721ContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"transferOutERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ethCustodial","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://447ea8c6497fba83e9eb38dbb2768c0c383e9d4b81b3c356db5cadac26bf21c2"}]}