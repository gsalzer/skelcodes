{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/proposals/ImplementationUpgradeExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {ILendingPoolConfigurator} from '../interfaces/ILendingPoolConfigurator.sol';\\nimport {IImplementationUpgradeExecutor} from '../interfaces/IImplementationUpgradeExecutor.sol';\\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\\nimport {ILendingPoolData} from '../interfaces/ILendingPoolData.sol';\\nimport {IATokenDetailed} from '../interfaces/IATokenDetailed.sol';\\nimport {DataTypes} from '../utils/DataTypes.sol';\\n\\ncontract ImplementationUpgradeExecutor is IImplementationUpgradeExecutor {\\n  address constant POOL_CONFIGURATOR = 0x311Bb771e4F8952E6Da169b425E7e92d6Ac45756;\\n  address constant INCENTIVES_CONTROLLER_PROXY_ADDRESS = 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5;\\n  address constant LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\\n\\n  uint256 constant DISTRIBUTION_DURATION = 7776000; // 90 days\\n  uint256 constant INITIAL_DISTRIBUTION_TIMESTAMP = 1629797400; // 24/08/2021\\n\\n  function execute() external override {\\n    address payable[10] memory reserves = [\\n      0xba100000625a3754423978a60c9317c58a424e3D, // BAL\\n      0x514910771AF9Ca656af840dff83E8264EcF986CA, // LINK\\n      0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2, // MKR\\n      0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919, // RAI\\n      0x57Ab1ec28D129707052df4dF418D58a2D46d5f51, // sUSD\\n      0x0000000000085d4780B73119b644AE5ecd22b376, // TUSD\\n      0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, // UNI\\n      0x8E870D67F660D95d5be530380D0eC0bd388289E1, // USDP\\n      0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272, // xSUSHI\\n      0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e // YFI\\n    ];\\n\\n    address payable[10] memory aTokenImplementations = [\\n      0x3FC5bBafE3285257CCe2Ede6736F153F78274e67, // aBAL\\n      0x491bEF802bFD56Ddee8410F6190025f802a75ef2, // aLINK\\n      0x6BF3D969B9Cdf277d17f9B7787B1223Ab07b47d6, // aMKR\\n      0xB97Fa7A950B19C8Fe7d9bcD06909D3e67F20f16a, // aRAI\\n      0x7590dCc7AE7Ce770C1243808ddf5677cBd913257, // sUSD\\n      0xeDa678212EB1E9694fC1455b2426c7aF30f69Bd5, // aTUSD\\n      0x66706cEfeBd6268D853bA5112a3E9e99eF476d08, // aUNI\\n      0x333660C060F56Fcb5DE92dfEB3EbaF3F1834b04f, // aUSDP\\n      0xEa90db312783e45B98502f55a62a81a924F8D492, // axSUSHI\\n      0x1cC1cF0AfE797b96bd66a194F0Bf2f37040Bf326 // aYFI\\n    ];\\n    address payable[10] memory variableDebtImplementations = [\\n      0x6C179Cc11aEe78e87c63d1c61B8602FaD6a1655d, // variable BAL\\n      0x8e12Af1ef540D740C5822799776a2Fd2730F8d06, // variable LINK\\n      0x5a11383F867137781C205Fe334B148E697e18637, // variable MKR\\n      0x36166a0B13759632365d28dfe69f3f4e5974BAfB, // variable RAI\\n      0xB421eBfd0854705696B0bD1cc3BB53891eC4416B, // variable sUSD\\n      0xD0fe84864a9d599AEd7D77f16D9ac196E57eCE79, // variable TUSD\\n      0x7681A51C93465f8e4f7B15bBE74C5F621B2d8396, // variable UNI\\n      0x42F7895b2CA1F9870574958cF2BF6879d445F1a3, // variable USDP\\n      0x8133267827F41902d32F6f9d8D6aAAF080f2aF8F, // variable xSUSHI\\n      0x8FEBfb5EaF456C1A420c0522DbC6ddbfb105e131 // variable YFI\\n    ];\\n\\n    require(\\n      aTokenImplementations.length == variableDebtImplementations.length &&\\n        aTokenImplementations.length == reserves.length,\\n      'ARRAY_LENGTH_MISMATCH'\\n    );\\n\\n    address[] memory assets = new address[](20);\\n\\n    uint256[] memory emissions = new uint256[](20);\\n\\n    emissions[0] = _recalculateEmission(10e18); // aBAL\\n    emissions[1] = 0; // vDebtBAL\\n    emissions[2] = _recalculateEmission(25e18); // aLINK\\n    emissions[3] = 0; // vDebtLINK\\n    emissions[4] = _recalculateEmission(15e18); // aMKR\\n    emissions[5] = 0; // vDebtMKR\\n    emissions[6] = _recalculateEmission(5e18); // aRAI\\n    emissions[7] = _recalculateEmission(5e18); // vDebtRAI\\n    emissions[8] = _recalculateEmission(10e18); // asUSD\\n    emissions[9] = _recalculateEmission(10e18); // vDebtsUSD\\n    emissions[10] = _recalculateEmission(5e18); // aTUSD\\n    emissions[11] = _recalculateEmission(5e18); // vDebtTUSD\\n    emissions[12] = _recalculateEmission(15e18); // aUNI\\n    emissions[13] = 0; // vDebtUNI\\n    emissions[14] = _recalculateEmission(2.5e18); // aUSDP\\n    emissions[15] = _recalculateEmission(2.5e18); // vDebtUSDP\\n    emissions[16] = _recalculateEmission(15e18); // axSUSHI\\n    emissions[17] = 0; // vDebtxSUSHI\\n    emissions[18] = _recalculateEmission(15e18); // aYFI\\n    emissions[19] = 0; // vDebtYFI\\n\\n    ILendingPoolConfigurator poolConfigurator = ILendingPoolConfigurator(POOL_CONFIGURATOR);\\n    IAaveIncentivesController incentivesController = IAaveIncentivesController(\\n      INCENTIVES_CONTROLLER_PROXY_ADDRESS\\n    );\\n\\n    uint256 tokensCounter;\\n    // Prepare the asset array for the incentives\\n    for (uint256 x = 0; x < reserves.length; x++) {\\n      require(\\n        IATokenDetailed(aTokenImplementations[x]).UNDERLYING_ASSET_ADDRESS() == reserves[x],\\n        'AToken underlying does not match'\\n      );\\n      require(\\n        IATokenDetailed(variableDebtImplementations[x]).UNDERLYING_ASSET_ADDRESS() == reserves[x],\\n        'Debt Token underlying does not match'\\n      );\\n\\n      // Update aToken impl\\n      poolConfigurator.updateAToken(reserves[x], aTokenImplementations[x]);\\n\\n      // Update variable debt impl\\n      poolConfigurator.updateVariableDebtToken(reserves[x], variableDebtImplementations[x]);\\n\\n      DataTypes.ReserveData memory reserveData = ILendingPoolData(LENDING_POOL).getReserveData(\\n        reserves[x]\\n      );\\n      assets[tokensCounter++] = reserveData.aTokenAddress;\\n      assets[tokensCounter++] = reserveData.variableDebtTokenAddress;\\n    }\\n    incentivesController.configureAssets(assets, emissions);\\n  }\\n\\n  // Proportianally incresing the rewards considering the time when emissions where\\n  function _recalculateEmission(uint256 emission) internal view returns (uint256) {\\n    return\\n      (emission * 90) /\\n      (DISTRIBUTION_DURATION - (block.timestamp - INITIAL_DISTRIBUTION_TIMESTAMP));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface ILendingPoolConfigurator {\\n  function updateAToken(address reserve, address implementation) external;\\n\\n  function updateVariableDebtToken(address reserve, address implementation) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImplementationUpgradeExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.7.5;\\n\\ninterface IImplementationUpgradeExecutor {\\n  function execute() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\\n\\ninterface IAaveIncentivesController is IAaveDistributionManager {\\n  \\n  event RewardsAccrued(address indexed user, uint256 amount);\\n  \\n  event RewardsClaimed(\\n    address indexed user,\\n    address indexed to,\\n    address indexed claimer,\\n    uint256 amount\\n  );\\n\\n  event ClaimerSet(address indexed user, address indexed claimer);\\n\\n  /**\\n   * @dev Whitelists an address to claim the rewards on behalf of another address\\n   * @param user The address of the user\\n   * @param claimer The address of the claimer\\n   */\\n  function setClaimer(address user, address claimer) external;\\n\\n  /**\\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n   * @param user The address of the user\\n   * @return The claimer address\\n   */\\n  function getClaimer(address user) external view returns (address);\\n\\n  /**\\n   * @dev Configure assets for a certain rewards emission\\n   * @param assets The assets to incentivize\\n   * @param emissionsPerSecond The emission for each asset\\n   */\\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\\n    external;\\n\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 userBalance,\\n    uint256 totalSupply\\n  ) external;\\n\\n  /**\\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n   * @param user The address of the user\\n   * @return The rewards\\n   **/\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n   * @param amount Amount of rewards to claim\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n   * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @return the unclaimed user rewards\\n   */\\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n  /**\\n  * @dev for backward compatibility with previous implementation of the Incentives controller\\n  */\\n  function REWARD_TOKEN() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveDistributionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\\n\\ninterface IAaveDistributionManager {\\n  \\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\\n  event AssetIndexUpdated(address indexed asset, uint256 index);\\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\\n  event DistributionEndUpdated(uint256 newDistributionEnd);\\n\\n  /**\\n  * @dev Sets the end date for the distribution\\n  * @param distributionEnd The end date timestamp\\n  **/\\n  function setDistributionEnd(uint256 distributionEnd) external;\\n\\n  /**\\n  * @dev Gets the end date for the distribution\\n  * @return The end of the distribution\\n  **/\\n  function getDistributionEnd() external view returns (uint256);\\n\\n  /**\\n  * @dev for backwards compatibility with the previous DistributionManager used\\n  * @return The end of the distribution\\n  **/\\n  function DISTRIBUTION_END() external view returns(uint256);\\n\\n   /**\\n   * @dev Returns the data of an user on a distribution\\n   * @param user Address of the user\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The new index\\n   **/\\n   function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n   /**\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n   function getAssetData(address asset) external view returns (uint256, uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DistributionTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary DistributionTypes {\\n  struct AssetConfigInput {\\n    uint104 emissionPerSecond;\\n    uint256 totalStaked;\\n    address underlyingAsset;\\n  }\\n\\n  struct UserStakeInput {\\n    address underlyingAsset;\\n    uint256 stakedByUser;\\n    uint256 totalStaked;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {DataTypes} from '../utils/DataTypes.sol';\\n\\ninterface ILendingPoolData {\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\nlibrary DataTypes {\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IATokenDetailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.5;\\n\\ninterface IATokenDetailed {\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ImplementationUpgradeExecutor","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}