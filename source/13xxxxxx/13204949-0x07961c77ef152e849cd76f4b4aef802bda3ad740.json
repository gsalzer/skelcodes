{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Migration_Mirfak.sol\": {\r\n      \"content\": \"/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n\\n* Synthetix: migrations/Migration_Mirfak.sol\\n*\\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Mirfak.sol\\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Mirfak\\n*\\n* Contract Dependencies: \\n*\\t- BaseMigration\\n*\\t- EternalStorage\\n*\\t- ExternStateToken\\n*\\t- IAddressResolver\\n*\\t- IERC20\\n*\\t- IExchangeState\\n*\\t- IFeePool\\n*\\t- IIssuer\\n*\\t- IRewardEscrow\\n*\\t- IRewardsDistribution\\n*\\t- ISynth\\n*\\t- ISynthetixState\\n*\\t- ISystemStatus\\n*\\t- LegacyOwned\\n*\\t- LimitedSetup\\n*\\t- MixinResolver\\n*\\t- MixinSystemSettings\\n*\\t- Owned\\n*\\t- Proxy\\n*\\t- Proxyable\\n*\\t- State\\n*\\t- Synth\\n* Libraries: \\n*\\t- SafeDecimalMath\\n*\\t- SafeMath\\n*\\t- VestingEntries\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\n\\n\\n\\npragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\\n\\ncontract BaseMigration is Owned {\\n    address public deployer;\\n\\n    constructor(address _owner) internal Owned(_owner) {\\n        deployer = msg.sender;\\n    }\\n\\n    // safety value to return ownership (anyone can invoke)\\n    function returnOwnership(address forContract) public {\\n        bytes memory payload = abi.encodeWithSignature(\\\"nominateNewOwner(address)\\\", owner);\\n\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, ) = forContract.call(payload);\\n\\n        if (!success) {\\n            // then try legacy way\\n            bytes memory legacyPayload = abi.encodeWithSignature(\\\"nominateOwner(address)\\\", owner);\\n\\n            // solhint-disable avoid-low-level-calls\\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\\n\\n            require(legacySuccess, \\\"Legacy nomination failed\\\");\\n        }\\n    }\\n\\n    function _requireDeployer() private view {\\n        require(msg.sender == deployer, \\\"Only the deployer can invoke this\\\");\\n    }\\n\\n    modifier onlyDeployer() {\\n        _requireDeployer();\\n        _;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\\ninterface ISynth {\\n    // Views\\n    function currencyKey() external view returns (bytes32);\\n\\n    function transferableSynths(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function transferAndSettle(address to, uint value) external returns (bool);\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Restricted: used internally to Synthetix\\n    function burn(address account, uint amount) external;\\n\\n    function issue(address account, uint amount) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\\ninterface IIssuer {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function canBurnSynths(address account) external view returns (bool);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\\n        external\\n        view\\n        returns (uint cratio, bool anyRateIsInvalid);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\\n\\n    function issuanceRatio() external view returns (uint);\\n\\n    function lastIssueEvent(address account) external view returns (uint);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function minimumStakeTime() external view returns (uint);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\\n\\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\\n        external\\n        view\\n        returns (uint transferable, bool anyRateIsInvalid);\\n\\n    // Restricted: used internally to Synthetix\\n    function issueSynths(address from, uint amount) external;\\n\\n    function issueSynthsOnBehalf(\\n        address issueFor,\\n        address from,\\n        uint amount\\n    ) external;\\n\\n    function issueMaxSynths(address from) external;\\n\\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\\n\\n    function burnSynths(address from, uint amount) external;\\n\\n    function burnSynthsOnBehalf(\\n        address burnForAddress,\\n        address from,\\n        uint amount\\n    ) external;\\n\\n    function burnSynthsToTarget(address from) external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\\n\\n    function burnForRedemption(\\n        address deprecatedSynthProxy,\\n        address account,\\n        uint balance\\n    ) external;\\n\\n    function liquidateDelinquentAccount(\\n        address account,\\n        uint susdAmount,\\n        address liquidator\\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\\n}\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\\ncontract MixinResolver {\\n    AddressResolver public resolver;\\n\\n    mapping(bytes32 => address) private addressCache;\\n\\n    constructor(address _resolver) internal {\\n        resolver = AddressResolver(_resolver);\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\\n        internal\\n        pure\\n        returns (bytes32[] memory combination)\\n    {\\n        combination = new bytes32[](first.length + second.length);\\n\\n        for (uint i = 0; i < first.length; i++) {\\n            combination[i] = first[i];\\n        }\\n\\n        for (uint j = 0; j < second.length; j++) {\\n            combination[first.length + j] = second[j];\\n        }\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\\n\\n    function rebuildCache() public {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        // The resolver must call this function whenver it updates its state\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination =\\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\\\"Resolver missing target: \\\", name)));\\n            addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event CacheUpdated(bytes32 name, address destination);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\\ncontract AddressResolver is Owned, IAddressResolver {\\n    mapping(bytes32 => address) public repository;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\\n        require(names.length == destinations.length, \\\"Input lengths must match\\\");\\n\\n        for (uint i = 0; i < names.length; i++) {\\n            bytes32 name = names[i];\\n            address destination = destinations[i];\\n            repository[name] = destination;\\n            emit AddressImported(name, destination);\\n        }\\n    }\\n\\n    /* ========= PUBLIC FUNCTIONS ========== */\\n\\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\\n        for (uint i = 0; i < destinations.length; i++) {\\n            destinations[i].rebuildCache();\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\\n        for (uint i = 0; i < names.length; i++) {\\n            if (repository[names[i]] != destinations[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function getAddress(bytes32 name) external view returns (address) {\\n        return repository[name];\\n    }\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\\n        address _foundAddress = repository[name];\\n        require(_foundAddress != address(0), reason);\\n        return _foundAddress;\\n    }\\n\\n    function getSynth(bytes32 key) external view returns (address) {\\n        IIssuer issuer = IIssuer(repository[\\\"Issuer\\\"]);\\n        require(address(issuer) != address(0), \\\"Cannot find Issuer address\\\");\\n        return address(issuer.synths(key));\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AddressImported(bytes32 name, address destination);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\\ncontract Proxyable is Owned {\\n    // This contract should be treated like an abstract contract\\n\\n    /* The proxy this contract exists behind. */\\n    Proxy public proxy;\\n    Proxy public integrationProxy;\\n\\n    /* The caller of the proxy, passed through to this contract.\\n     * Note that every function using this member must apply the onlyProxy or\\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\\n    address public messageSender;\\n\\n    constructor(address payable _proxy) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setProxy(address payable _proxy) external onlyOwner {\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setIntegrationProxy(address payable _integrationProxy) external onlyOwner {\\n        integrationProxy = Proxy(_integrationProxy);\\n    }\\n\\n    function setMessageSender(address sender) external onlyProxy {\\n        messageSender = sender;\\n    }\\n\\n    modifier onlyProxy {\\n        _onlyProxy();\\n        _;\\n    }\\n\\n    function _onlyProxy() private view {\\n        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \\\"Only the proxy can call\\\");\\n    }\\n\\n    modifier optionalProxy {\\n        _optionalProxy();\\n        _;\\n    }\\n\\n    function _optionalProxy() private {\\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n    }\\n\\n    modifier optionalProxy_onlyOwner {\\n        _optionalProxy_onlyOwner();\\n        _;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _optionalProxy_onlyOwner() private {\\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n        require(messageSender == owner, \\\"Owner only function\\\");\\n    }\\n\\n    event ProxyUpdated(address proxyAddress);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxy\\ncontract Proxy is Owned {\\n    Proxyable public target;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    function setTarget(Proxyable _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(_target);\\n    }\\n\\n    function _emit(\\n        bytes calldata callData,\\n        uint numTopics,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        bytes32 topic3,\\n        bytes32 topic4\\n    ) external onlyTarget {\\n        uint size = callData.length;\\n        bytes memory _callData = callData;\\n\\n        assembly {\\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\\n             * This means moving call_data across 32 bytes guarantees we correctly access\\n             * the data itself. */\\n            switch numTopics\\n                case 0 {\\n                    log0(add(_callData, 32), size)\\n                }\\n                case 1 {\\n                    log1(add(_callData, 32), size, topic1)\\n                }\\n                case 2 {\\n                    log2(add(_callData, 32), size, topic1, topic2)\\n                }\\n                case 3 {\\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\\n                }\\n                case 4 {\\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\\n                }\\n        }\\n    }\\n\\n    // solhint-disable no-complex-fallback\\n    function() external payable {\\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\\n        target.setMessageSender(msg.sender);\\n\\n        assembly {\\n            let free_ptr := mload(0x40)\\n            calldatacopy(free_ptr, 0, calldatasize)\\n\\n            /* We must explicitly forward ether to the underlying contract as well. */\\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\\n            returndatacopy(free_ptr, 0, returndatasize)\\n\\n            if iszero(result) {\\n                revert(free_ptr, returndatasize)\\n            }\\n            return(free_ptr, returndatasize)\\n        }\\n    }\\n\\n    modifier onlyTarget {\\n        require(Proxyable(msg.sender) == target, \\\"Must be proxy target\\\");\\n        _;\\n    }\\n\\n    event TargetUpdated(Proxyable newTarget);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/state\\ncontract State is Owned {\\n    // the address of the contract that can modify variables\\n    // this can only be changed by the owner of this contract\\n    address public associatedContract;\\n\\n    constructor(address _associatedContract) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyAssociatedContract {\\n        require(msg.sender == associatedContract, \\\"Only the associated contract can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AssociatedContractUpdated(address associatedContract);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/eternalstorage\\n/**\\n * @notice  This contract is based on the code available from this blog\\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\\n * and extensible option. This ensures data schema changes can be implemented without\\n * requiring upgrades to the storage contract.\\n */\\ncontract EternalStorage is Owned, State {\\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\\n\\n    /* ========== DATA TYPES ========== */\\n    mapping(bytes32 => uint) internal UIntStorage;\\n    mapping(bytes32 => string) internal StringStorage;\\n    mapping(bytes32 => address) internal AddressStorage;\\n    mapping(bytes32 => bytes) internal BytesStorage;\\n    mapping(bytes32 => bytes32) internal Bytes32Storage;\\n    mapping(bytes32 => bool) internal BooleanStorage;\\n    mapping(bytes32 => int) internal IntStorage;\\n\\n    // UIntStorage;\\n    function getUIntValue(bytes32 record) external view returns (uint) {\\n        return UIntStorage[record];\\n    }\\n\\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\\n        UIntStorage[record] = value;\\n    }\\n\\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\\n        delete UIntStorage[record];\\n    }\\n\\n    // StringStorage\\n    function getStringValue(bytes32 record) external view returns (string memory) {\\n        return StringStorage[record];\\n    }\\n\\n    function setStringValue(bytes32 record, string calldata value) external onlyAssociatedContract {\\n        StringStorage[record] = value;\\n    }\\n\\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\\n        delete StringStorage[record];\\n    }\\n\\n    // AddressStorage\\n    function getAddressValue(bytes32 record) external view returns (address) {\\n        return AddressStorage[record];\\n    }\\n\\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\\n        AddressStorage[record] = value;\\n    }\\n\\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\\n        delete AddressStorage[record];\\n    }\\n\\n    // BytesStorage\\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\\n        return BytesStorage[record];\\n    }\\n\\n    function setBytesValue(bytes32 record, bytes calldata value) external onlyAssociatedContract {\\n        BytesStorage[record] = value;\\n    }\\n\\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\\n        delete BytesStorage[record];\\n    }\\n\\n    // Bytes32Storage\\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\\n        return Bytes32Storage[record];\\n    }\\n\\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\\n        Bytes32Storage[record] = value;\\n    }\\n\\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\\n        delete Bytes32Storage[record];\\n    }\\n\\n    // BooleanStorage\\n    function getBooleanValue(bytes32 record) external view returns (bool) {\\n        return BooleanStorage[record];\\n    }\\n\\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\\n        BooleanStorage[record] = value;\\n    }\\n\\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\\n        delete BooleanStorage[record];\\n    }\\n\\n    // IntStorage\\n    function getIntValue(bytes32 record) external view returns (int) {\\n        return IntStorage[record];\\n    }\\n\\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\\n        IntStorage[record] = value;\\n    }\\n\\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\\n        delete IntStorage[record];\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/limitedsetup\\ncontract LimitedSetup {\\n    uint public setupExpiryTime;\\n\\n    /**\\n     * @dev LimitedSetup Constructor.\\n     * @param setupDuration The time the setup period will last for.\\n     */\\n    constructor(uint setupDuration) internal {\\n        setupExpiryTime = now + setupDuration;\\n    }\\n\\n    modifier onlyDuringSetup {\\n        require(now < setupExpiryTime, \\\"Can only perform this action during setup\\\");\\n        _;\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/feepooleternalstorage\\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\\n    bytes32 internal constant LAST_FEE_WITHDRAWAL = \\\"last_fee_withdrawal\\\";\\n\\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\\n\\n    function importFeeWithdrawalData(address[] calldata accounts, uint[] calldata feePeriodIDs)\\n        external\\n        onlyOwner\\n        onlyDuringSetup\\n    {\\n        require(accounts.length == feePeriodIDs.length, \\\"Length mismatch\\\");\\n\\n        for (uint8 i = 0; i < accounts.length; i++) {\\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\\n        }\\n    }\\n}\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\\n\\n// Libraries\\n\\n\\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\nlibrary SafeDecimalMath {\\n    using SafeMath for uint;\\n\\n    /* Number of decimal places in the representations. */\\n    uint8 public constant decimals = 18;\\n    uint8 public constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint public constant UNIT = 10**uint(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return Provides an interface to UNIT.\\n     */\\n    function unit() external pure returns (uint) {\\n        return UNIT;\\n    }\\n\\n    /**\\n     * @return Provides an interface to PRECISE_UNIT.\\n     */\\n    function preciseUnit() external pure returns (uint) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y) / UNIT;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of the specified precision unit.\\n     *\\n     * @dev The operands should be in the form of a the specified unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function _multiplyDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a precise unit.\\n     *\\n     * @dev The operands should be in the precise unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a standard unit.\\n     *\\n     * @dev The operands should be in the standard unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * decimal in the precision unit specified in the parameter.\\n     *\\n     * @dev y is divided after the product of x and the specified precision unit\\n     * is evaluated, so the product of x and the specified precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function _divideDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n        if (resultTimesTen % 10 >= 5) {\\n            resultTimesTen += 10;\\n        }\\n\\n        return resultTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * standard precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and the standard precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * high precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the high precision unit\\n     * is evaluated, so the product of x and the high precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    // Computes `a - b`, setting the value to 0 if b > a.\\n    function floorsub(uint a, uint b) internal pure returns (uint) {\\n        return b >= a ? 0 : a - b;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\\ninterface IFeePool {\\n    // Views\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function FEE_ADDRESS() external view returns (address);\\n\\n    function feesAvailable(address account) external view returns (uint, uint);\\n\\n    function feePeriodDuration() external view returns (uint);\\n\\n    function isFeesClaimable(address account) external view returns (bool);\\n\\n    function targetThreshold() external view returns (uint);\\n\\n    function totalFeesAvailable() external view returns (uint);\\n\\n    function totalRewardsAvailable() external view returns (uint);\\n\\n    // Mutative Functions\\n    function claimFees() external returns (bool);\\n\\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\\n\\n    function closeCurrentFeePeriod() external;\\n\\n    // Restricted: used internally to Synthetix\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint lockedAmount,\\n        uint debtEntryIndex\\n    ) external;\\n\\n    function recordFeePaid(uint sUSDAmount) external;\\n\\n    function setRewardsToDistribute(uint amount) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/feepoolstate\\ncontract FeePoolState is Owned, LimitedSetup {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    uint8 public constant FEE_PERIOD_LENGTH = 6;\\n\\n    address public feePool;\\n\\n    // The IssuanceData activity that's happened in a fee period.\\n    struct IssuanceData {\\n        uint debtPercentage;\\n        uint debtEntryIndex;\\n    }\\n\\n    // The IssuanceData activity that's happened in a fee period.\\n    mapping(address => IssuanceData[FEE_PERIOD_LENGTH]) public accountIssuanceLedger;\\n\\n    constructor(address _owner, IFeePool _feePool) public Owned(_owner) LimitedSetup(6 weeks) {\\n        feePool = address(_feePool);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice set the FeePool contract as it is the only authority to be able to call\\n     * appendAccountIssuanceRecord with the onlyFeePool modifer\\n     * @dev Must be set by owner when FeePool logic is upgraded\\n     */\\n    function setFeePool(IFeePool _feePool) external onlyOwner {\\n        feePool = address(_feePool);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Get an accounts issuanceData for\\n     * @param account users account\\n     * @param index Index in the array to retrieve. Upto FEE_PERIOD_LENGTH\\n     */\\n    function getAccountsDebtEntry(address account, uint index)\\n        public\\n        view\\n        returns (uint debtPercentage, uint debtEntryIndex)\\n    {\\n        require(index < FEE_PERIOD_LENGTH, \\\"index exceeds the FEE_PERIOD_LENGTH\\\");\\n\\n        debtPercentage = accountIssuanceLedger[account][index].debtPercentage;\\n        debtEntryIndex = accountIssuanceLedger[account][index].debtEntryIndex;\\n    }\\n\\n    /**\\n     * @notice Find the oldest debtEntryIndex for the corresponding closingDebtIndex\\n     * @param account users account\\n     * @param closingDebtIndex the last periods debt index on close\\n     */\\n    function applicableIssuanceData(address account, uint closingDebtIndex) external view returns (uint, uint) {\\n        IssuanceData[FEE_PERIOD_LENGTH] memory issuanceData = accountIssuanceLedger[account];\\n\\n        // We want to use the user's debtEntryIndex at when the period closed\\n        // Find the oldest debtEntryIndex for the corresponding closingDebtIndex\\n        for (uint i = 0; i < FEE_PERIOD_LENGTH; i++) {\\n            if (closingDebtIndex >= issuanceData[i].debtEntryIndex) {\\n                return (issuanceData[i].debtPercentage, issuanceData[i].debtEntryIndex);\\n            }\\n        }\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Logs an accounts issuance data in the current fee period which is then stored historically\\n     * @param account Message.Senders account address\\n     * @param debtRatio Debt of this account as a percentage of the global debt.\\n     * @param debtEntryIndex The index in the global debt ledger. synthetix.synthetixState().issuanceData(account)\\n     * @param currentPeriodStartDebtIndex The startingDebtIndex of the current fee period\\n     * @dev onlyFeePool to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\\n      accountIssuanceLedger[account][0] has the latest locked amount for the current period. This can be update as many time\\n      accountIssuanceLedger[account][1-2] has the last locked amount for a previous period they minted or burned\\n     */\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint debtRatio,\\n        uint debtEntryIndex,\\n        uint currentPeriodStartDebtIndex\\n    ) external onlyFeePool {\\n        // Is the current debtEntryIndex within this fee period\\n        if (accountIssuanceLedger[account][0].debtEntryIndex < currentPeriodStartDebtIndex) {\\n            // If its older then shift the previous IssuanceData entries periods down to make room for the new one.\\n            issuanceDataIndexOrder(account);\\n        }\\n\\n        // Always store the latest IssuanceData entry at [0]\\n        accountIssuanceLedger[account][0].debtPercentage = debtRatio;\\n        accountIssuanceLedger[account][0].debtEntryIndex = debtEntryIndex;\\n    }\\n\\n    /**\\n     * @notice Pushes down the entire array of debt ratios per fee period\\n     */\\n    function issuanceDataIndexOrder(address account) private {\\n        for (uint i = FEE_PERIOD_LENGTH - 2; i < FEE_PERIOD_LENGTH; i--) {\\n            uint next = i + 1;\\n            accountIssuanceLedger[account][next].debtPercentage = accountIssuanceLedger[account][i].debtPercentage;\\n            accountIssuanceLedger[account][next].debtEntryIndex = accountIssuanceLedger[account][i].debtEntryIndex;\\n        }\\n    }\\n\\n    /**\\n     * @notice Import issuer data from synthetixState.issuerData on FeePeriodClose() block #\\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\\n     * @param accounts Array of issuing addresses\\n     * @param ratios Array of debt ratios\\n     * @param periodToInsert The Fee Period to insert the historical records into\\n     * @param feePeriodCloseIndex An accounts debtEntryIndex is valid when within the fee peroid,\\n     * since the input ratio will be an average of the pervious periods it just needs to be\\n     * > recentFeePeriods[periodToInsert].startingDebtIndex\\n     * < recentFeePeriods[periodToInsert - 1].startingDebtIndex\\n     */\\n    function importIssuerData(\\n        address[] calldata accounts,\\n        uint[] calldata ratios,\\n        uint periodToInsert,\\n        uint feePeriodCloseIndex\\n    ) external onlyOwner onlyDuringSetup {\\n        require(accounts.length == ratios.length, \\\"Length mismatch\\\");\\n\\n        for (uint i = 0; i < accounts.length; i++) {\\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtPercentage = ratios[i];\\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtEntryIndex = feePeriodCloseIndex;\\n            emit IssuanceDebtRatioEntry(accounts[i], ratios[i], feePeriodCloseIndex);\\n        }\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyFeePool {\\n        require(msg.sender == address(feePool), \\\"Only the FeePool contract can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== Events ========== */\\n    event IssuanceDebtRatioEntry(address indexed account, uint debtRatio, uint feePeriodCloseIndex);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\\ninterface IERC20 {\\n    // ERC20 Optional Views\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    // Views\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // Mutative functions\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Events\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyerc20\\ncontract ProxyERC20 is Proxy, IERC20 {\\n    constructor(address _owner) public Proxy(_owner) {}\\n\\n    // ------------- ERC20 Details ------------- //\\n\\n    function name() public view returns (string memory) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).name();\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).symbol();\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).decimals();\\n    }\\n\\n    // ------------- ERC20 Interface ------------- //\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).totalSupply();\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param account The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        // Immutable static call from target contract\\n        return IERC20(address(target)).allowance(owner, spender);\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).transfer(to, value);\\n\\n        // Event emitting will occur via Synthetix.Proxy._emit()\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).approve(spender, value);\\n\\n        // Event emitting will occur via Synthetix.Proxy._emit()\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public returns (bool) {\\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\\n        target.setMessageSender(msg.sender);\\n\\n        // Forward the ERC20 call to the target contract\\n        IERC20(address(target)).transferFrom(from, to, value);\\n\\n        // Event emitting will occur via Synthetix.Proxy._emit()\\n        return true;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\\ninterface IExchangeState {\\n    // Views\\n    struct ExchangeEntry {\\n        bytes32 src;\\n        uint amount;\\n        bytes32 dest;\\n        uint amountReceived;\\n        uint exchangeFeeRate;\\n        uint timestamp;\\n        uint roundIdForSrc;\\n        uint roundIdForDest;\\n    }\\n\\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\\n\\n    function getEntryAt(\\n        address account,\\n        bytes32 currencyKey,\\n        uint index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32 src,\\n            uint amount,\\n            bytes32 dest,\\n            uint amountReceived,\\n            uint exchangeFeeRate,\\n            uint timestamp,\\n            uint roundIdForSrc,\\n            uint roundIdForDest\\n        );\\n\\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\\n\\n    // Mutative functions\\n    function appendExchangeEntry(\\n        address account,\\n        bytes32 src,\\n        uint amount,\\n        bytes32 dest,\\n        uint amountReceived,\\n        uint exchangeFeeRate,\\n        uint timestamp,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external;\\n\\n    function removeEntries(address account, bytes32 currencyKey) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/exchangestate\\ncontract ExchangeState is Owned, State, IExchangeState {\\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\\n\\n    uint public maxEntriesInQueue = 12;\\n\\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\\n\\n    /* ========== SETTERS ========== */\\n\\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\\n        maxEntriesInQueue = _maxEntriesInQueue;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function appendExchangeEntry(\\n        address account,\\n        bytes32 src,\\n        uint amount,\\n        bytes32 dest,\\n        uint amountReceived,\\n        uint exchangeFeeRate,\\n        uint timestamp,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external onlyAssociatedContract {\\n        require(exchanges[account][dest].length < maxEntriesInQueue, \\\"Max queue length reached\\\");\\n\\n        exchanges[account][dest].push(\\n            ExchangeEntry({\\n                src: src,\\n                amount: amount,\\n                dest: dest,\\n                amountReceived: amountReceived,\\n                exchangeFeeRate: exchangeFeeRate,\\n                timestamp: timestamp,\\n                roundIdForSrc: roundIdForSrc,\\n                roundIdForDest: roundIdForDest\\n            })\\n        );\\n    }\\n\\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\\n        delete exchanges[account][currencyKey];\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\\n        return exchanges[account][currencyKey].length;\\n    }\\n\\n    function getEntryAt(\\n        address account,\\n        bytes32 currencyKey,\\n        uint index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32 src,\\n            uint amount,\\n            bytes32 dest,\\n            uint amountReceived,\\n            uint exchangeFeeRate,\\n            uint timestamp,\\n            uint roundIdForSrc,\\n            uint roundIdForDest\\n        )\\n    {\\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\\n        return (\\n            entry.src,\\n            entry.amount,\\n            entry.dest,\\n            entry.amountReceived,\\n            entry.exchangeFeeRate,\\n            entry.timestamp,\\n            entry.roundIdForSrc,\\n            entry.roundIdForDest\\n        );\\n    }\\n\\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\\n        uint timestamp = 0;\\n        for (uint i = 0; i < userEntries.length; i++) {\\n            if (userEntries[i].timestamp > timestamp) {\\n                timestamp = userEntries[i].timestamp;\\n            }\\n        }\\n        return timestamp;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\\ninterface ISystemStatus {\\n    struct Status {\\n        bool canSuspend;\\n        bool canResume;\\n    }\\n\\n    struct Suspension {\\n        bool suspended;\\n        // reason is an integer code,\\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\\n        uint248 reason;\\n    }\\n\\n    // Views\\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\\n\\n    function requireSystemActive() external view;\\n\\n    function requireIssuanceActive() external view;\\n\\n    function requireExchangeActive() external view;\\n\\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\\n\\n    function requireSynthActive(bytes32 currencyKey) external view;\\n\\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\\n\\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\\n\\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\\n\\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\\n\\n    function getSynthSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory suspensions, uint256[] memory reasons);\\n\\n    // Restricted functions\\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\\n\\n    function updateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\\ncontract SystemStatus is Owned, ISystemStatus {\\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\\n\\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\\n\\n    bytes32 public constant SECTION_SYSTEM = \\\"System\\\";\\n    bytes32 public constant SECTION_ISSUANCE = \\\"Issuance\\\";\\n    bytes32 public constant SECTION_EXCHANGE = \\\"Exchange\\\";\\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \\\"SynthExchange\\\";\\n    bytes32 public constant SECTION_SYNTH = \\\"Synth\\\";\\n\\n    Suspension public systemSuspension;\\n\\n    Suspension public issuanceSuspension;\\n\\n    Suspension public exchangeSuspension;\\n\\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\\n\\n    mapping(bytes32 => Suspension) public synthSuspension;\\n\\n    constructor(address _owner) public Owned(_owner) {}\\n\\n    /* ========== VIEWS ========== */\\n    function requireSystemActive() external view {\\n        _internalRequireSystemActive();\\n    }\\n\\n    function requireIssuanceActive() external view {\\n        // Issuance requires the system be active\\n        _internalRequireSystemActive();\\n\\n        // and issuance itself of course\\n        _internalRequireIssuanceActive();\\n    }\\n\\n    function requireExchangeActive() external view {\\n        // Exchanging requires the system be active\\n        _internalRequireSystemActive();\\n\\n        // and exchanging itself of course\\n        _internalRequireExchangeActive();\\n    }\\n\\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n        _internalRequireSynthExchangeActive(currencyKey);\\n    }\\n\\n    function requireSynthActive(bytes32 currencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n        _internalRequireSynthActive(currencyKey);\\n    }\\n\\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n        _internalRequireSynthActive(sourceCurrencyKey);\\n        _internalRequireSynthActive(destinationCurrencyKey);\\n    }\\n\\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\\n        // Synth exchange and transfer requires the system be active\\n        _internalRequireSystemActive();\\n\\n        // and exchanging must be active\\n        _internalRequireExchangeActive();\\n\\n        // and the synth exchanging between the synths must be active\\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\\n\\n        // and finally, the synths cannot be suspended\\n        _internalRequireSynthActive(sourceCurrencyKey);\\n        _internalRequireSynthActive(destinationCurrencyKey);\\n    }\\n\\n    function isSystemUpgrading() external view returns (bool) {\\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\\n    }\\n\\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\\n    {\\n        exchangeSuspensions = new bool[](synths.length);\\n        reasons = new uint256[](synths.length);\\n\\n        for (uint i = 0; i < synths.length; i++) {\\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\\n        }\\n    }\\n\\n    function getSynthSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory suspensions, uint256[] memory reasons)\\n    {\\n        suspensions = new bool[](synths.length);\\n        reasons = new uint256[](synths.length);\\n\\n        for (uint i = 0; i < synths.length; i++) {\\n            suspensions[i] = synthSuspension[synths[i]].suspended;\\n            reasons[i] = synthSuspension[synths[i]].reason;\\n        }\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n    function updateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) external onlyOwner {\\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\\n    }\\n\\n    function updateAccessControls(\\n        bytes32[] calldata sections,\\n        address[] calldata accounts,\\n        bool[] calldata canSuspends,\\n        bool[] calldata canResumes\\n    ) external onlyOwner {\\n        require(\\n            sections.length == accounts.length &&\\n                accounts.length == canSuspends.length &&\\n                canSuspends.length == canResumes.length,\\n            \\\"Input array lengths must match\\\"\\n        );\\n        for (uint i = 0; i < sections.length; i++) {\\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\\n        }\\n    }\\n\\n    function suspendSystem(uint256 reason) external {\\n        _requireAccessToSuspend(SECTION_SYSTEM);\\n        systemSuspension.suspended = true;\\n        systemSuspension.reason = uint248(reason);\\n        emit SystemSuspended(systemSuspension.reason);\\n    }\\n\\n    function resumeSystem() external {\\n        _requireAccessToResume(SECTION_SYSTEM);\\n        systemSuspension.suspended = false;\\n        emit SystemResumed(uint256(systemSuspension.reason));\\n        systemSuspension.reason = 0;\\n    }\\n\\n    function suspendIssuance(uint256 reason) external {\\n        _requireAccessToSuspend(SECTION_ISSUANCE);\\n        issuanceSuspension.suspended = true;\\n        issuanceSuspension.reason = uint248(reason);\\n        emit IssuanceSuspended(reason);\\n    }\\n\\n    function resumeIssuance() external {\\n        _requireAccessToResume(SECTION_ISSUANCE);\\n        issuanceSuspension.suspended = false;\\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\\n        issuanceSuspension.reason = 0;\\n    }\\n\\n    function suspendExchange(uint256 reason) external {\\n        _requireAccessToSuspend(SECTION_EXCHANGE);\\n        exchangeSuspension.suspended = true;\\n        exchangeSuspension.reason = uint248(reason);\\n        emit ExchangeSuspended(reason);\\n    }\\n\\n    function resumeExchange() external {\\n        _requireAccessToResume(SECTION_EXCHANGE);\\n        exchangeSuspension.suspended = false;\\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\\n        exchangeSuspension.reason = 0;\\n    }\\n\\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalSuspendSynthExchange(currencyKeys, reason);\\n    }\\n\\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\\n        _internalSuspendSynthExchange(currencyKeys, reason);\\n    }\\n\\n    function resumeSynthExchange(bytes32 currencyKey) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalResumeSynthsExchange(currencyKeys);\\n    }\\n\\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\\n        _internalResumeSynthsExchange(currencyKeys);\\n    }\\n\\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalSuspendSynths(currencyKeys, reason);\\n    }\\n\\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\\n        _internalSuspendSynths(currencyKeys, reason);\\n    }\\n\\n    function resumeSynth(bytes32 currencyKey) external {\\n        bytes32[] memory currencyKeys = new bytes32[](1);\\n        currencyKeys[0] = currencyKey;\\n        _internalResumeSynths(currencyKeys);\\n    }\\n\\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\\n        _internalResumeSynths(currencyKeys);\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _requireAccessToSuspend(bytes32 section) internal view {\\n        require(accessControl[section][msg.sender].canSuspend, \\\"Restricted to access control list\\\");\\n    }\\n\\n    function _requireAccessToResume(bytes32 section) internal view {\\n        require(accessControl[section][msg.sender].canResume, \\\"Restricted to access control list\\\");\\n    }\\n\\n    function _internalRequireSystemActive() internal view {\\n        require(\\n            !systemSuspension.suspended,\\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\\n                ? \\\"Synthetix is suspended, upgrade in progress... please stand by\\\"\\n                : \\\"Synthetix is suspended. Operation prohibited\\\"\\n        );\\n    }\\n\\n    function _internalRequireIssuanceActive() internal view {\\n        require(!issuanceSuspension.suspended, \\\"Issuance is suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalRequireExchangeActive() internal view {\\n        require(!exchangeSuspension.suspended, \\\"Exchange is suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\\n        require(!synthExchangeSuspension[currencyKey].suspended, \\\"Synth exchange suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\\n        require(!synthSuspension[currencyKey].suspended, \\\"Synth is suspended. Operation prohibited\\\");\\n    }\\n\\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\\n        _requireAccessToSuspend(SECTION_SYNTH);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            synthSuspension[currencyKey].suspended = true;\\n            synthSuspension[currencyKey].reason = uint248(reason);\\n            emit SynthSuspended(currencyKey, reason);\\n        }\\n    }\\n\\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\\n        _requireAccessToResume(SECTION_SYNTH);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\\n            delete synthSuspension[currencyKey];\\n        }\\n    }\\n\\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            synthExchangeSuspension[currencyKey].suspended = true;\\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\\n            emit SynthExchangeSuspended(currencyKey, reason);\\n        }\\n    }\\n\\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\\n            delete synthExchangeSuspension[currencyKey];\\n        }\\n    }\\n\\n    function _internalUpdateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) internal {\\n        require(\\n            section == SECTION_SYSTEM ||\\n                section == SECTION_ISSUANCE ||\\n                section == SECTION_EXCHANGE ||\\n                section == SECTION_SYNTH_EXCHANGE ||\\n                section == SECTION_SYNTH,\\n            \\\"Invalid section supplied\\\"\\n        );\\n        accessControl[section][account].canSuspend = canSuspend;\\n        accessControl[section][account].canResume = canResume;\\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event SystemSuspended(uint256 reason);\\n    event SystemResumed(uint256 reason);\\n\\n    event IssuanceSuspended(uint256 reason);\\n    event IssuanceResumed(uint256 reason);\\n\\n    event ExchangeSuspended(uint256 reason);\\n    event ExchangeResumed(uint256 reason);\\n\\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\\n\\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\\n\\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\\n}\\n\\n\\ncontract LegacyOwned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        owner = _owner;\\n    }\\n\\n    function nominateOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner);\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\\n\\ncontract LegacyTokenState is LegacyOwned {\\n    // the address of the contract that can modify balances and allowances\\n    // this can only be changed by the owner of this contract\\n    address public associatedContract;\\n\\n    // ERC20 fields.\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    constructor(address _owner, address _associatedContract) public LegacyOwned(_owner) {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    function setAllowance(\\n        address tokenOwner,\\n        address spender,\\n        uint value\\n    ) external onlyAssociatedContract {\\n        allowance[tokenOwner][spender] = value;\\n    }\\n\\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\\n        balanceOf[account] = value;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyAssociatedContract {\\n        require(msg.sender == associatedContract);\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AssociatedContractUpdated(address _associatedContract);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixstate\\ninterface ISynthetixState {\\n    // Views\\n    function debtLedger(uint index) external view returns (uint);\\n\\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\\n\\n    function debtLedgerLength() external view returns (uint);\\n\\n    function hasIssued(address account) external view returns (bool);\\n\\n    function lastDebtLedgerEntry() external view returns (uint);\\n\\n    // Mutative functions\\n    function incrementTotalIssuerCount() external;\\n\\n    function decrementTotalIssuerCount() external;\\n\\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\\n\\n    function appendDebtLedgerValue(uint value) external;\\n\\n    function clearIssuanceData(address account) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/synthetixstate\\ncontract SynthetixState is Owned, State, ISynthetixState {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    // A struct for handing values associated with an individual user's debt position\\n    struct IssuanceData {\\n        // Percentage of the total debt owned at the time\\n        // of issuance. This number is modified by the global debt\\n        // delta array. You can figure out a user's exit price and\\n        // collateralisation ratio using a combination of their initial\\n        // debt and the slice of global debt delta which applies to them.\\n        uint initialDebtOwnership;\\n        // This lets us know when (in relative terms) the user entered\\n        // the debt pool so we can calculate their exit price and\\n        // collateralistion ratio\\n        uint debtEntryIndex;\\n    }\\n\\n    // Issued synth balances for individual fee entitlements and exit price calculations\\n    mapping(address => IssuanceData) public issuanceData;\\n\\n    // The total count of people that have outstanding issued synths in any flavour\\n    uint public totalIssuerCount;\\n\\n    // Global debt pool tracking\\n    uint[] public debtLedger;\\n\\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice Set issuance data for an address\\n     * @dev Only the associated contract may call this.\\n     * @param account The address to set the data for.\\n     * @param initialDebtOwnership The initial debt ownership for this address.\\n     */\\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external onlyAssociatedContract {\\n        issuanceData[account].initialDebtOwnership = initialDebtOwnership;\\n        issuanceData[account].debtEntryIndex = debtLedger.length;\\n    }\\n\\n    /**\\n     * @notice Clear issuance data for an address\\n     * @dev Only the associated contract may call this.\\n     * @param account The address to clear the data for.\\n     */\\n    function clearIssuanceData(address account) external onlyAssociatedContract {\\n        delete issuanceData[account];\\n    }\\n\\n    /**\\n     * @notice Increment the total issuer count\\n     * @dev Only the associated contract may call this.\\n     */\\n    function incrementTotalIssuerCount() external onlyAssociatedContract {\\n        totalIssuerCount = totalIssuerCount.add(1);\\n    }\\n\\n    /**\\n     * @notice Decrement the total issuer count\\n     * @dev Only the associated contract may call this.\\n     */\\n    function decrementTotalIssuerCount() external onlyAssociatedContract {\\n        totalIssuerCount = totalIssuerCount.sub(1);\\n    }\\n\\n    /**\\n     * @notice Append a value to the debt ledger\\n     * @dev Only the associated contract may call this.\\n     * @param value The new value to be added to the debt ledger.\\n     */\\n    function appendDebtLedgerValue(uint value) external onlyAssociatedContract {\\n        debtLedger.push(value);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Retrieve the length of the debt ledger array\\n     */\\n    function debtLedgerLength() external view returns (uint) {\\n        return debtLedger.length;\\n    }\\n\\n    /**\\n     * @notice Retrieve the most recent entry from the debt ledger\\n     */\\n    function lastDebtLedgerEntry() external view returns (uint) {\\n        return debtLedger[debtLedger.length - 1];\\n    }\\n\\n    /**\\n     * @notice Query whether an account has issued and has an outstanding debt balance\\n     * @param account The address to query for\\n     */\\n    function hasIssued(address account) external view returns (bool) {\\n        return issuanceData[account].initialDebtOwnership > 0;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\\ninterface IRewardEscrow {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function numVestingEntries(address account) external view returns (uint);\\n\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n\\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\\n\\n    function getNextVestingIndex(address account) external view returns (uint);\\n\\n    // Mutative functions\\n    function appendVestingEntry(address account, uint quantity) external;\\n\\n    function vest() external;\\n}\\n\\n\\ninterface IVirtualSynth {\\n    // Views\\n    function balanceOfUnderlying(address account) external view returns (uint);\\n\\n    function rate() external view returns (uint);\\n\\n    function readyToSettle() external view returns (bool);\\n\\n    function secsLeftInWaitingPeriod() external view returns (uint);\\n\\n    function settled() external view returns (bool);\\n\\n    function synth() external view returns (ISynth);\\n\\n    // Mutative functions\\n    function settle(address account) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\\ninterface ISynthetix {\\n    // Views\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\\n\\n    function availableSynthCount() external view returns (uint);\\n\\n    function availableSynths(uint index) external view returns (ISynth);\\n\\n    function collateral(address account) external view returns (uint);\\n\\n    function collateralisationRatio(address issuer) external view returns (uint);\\n\\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\\n\\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\\n\\n    function remainingIssuableSynths(address issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        );\\n\\n    function synths(bytes32 currencyKey) external view returns (ISynth);\\n\\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\\n\\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\\n\\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\\n\\n    function transferableSynthetix(address account) external view returns (uint transferable);\\n\\n    // Mutative Functions\\n    function burnSynths(uint amount) external;\\n\\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\\n\\n    function burnSynthsToTarget() external;\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\\n\\n    function exchange(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalf(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTracking(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithTrackingForInitiator(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeOnBehalfWithTracking(\\n        address exchangeForAddress,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived);\\n\\n    function exchangeWithVirtual(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function issueMaxSynths() external;\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\\n\\n    function issueSynths(uint amount) external;\\n\\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\\n\\n    function mint() external returns (bool);\\n\\n    function settle(bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    // Liquidations\\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\\n\\n    // Restricted Functions\\n\\n    function mintSecondary(address account, uint amount) external;\\n\\n    function mintSecondaryRewards(uint amount) external;\\n\\n    function burnSecondary(address account, uint amount) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\\ncontract RewardEscrow is Owned, IRewardEscrow {\\n    using SafeMath for uint;\\n\\n    /* The corresponding Synthetix contract. */\\n    ISynthetix public synthetix;\\n\\n    IFeePool public feePool;\\n\\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\\n     * These are the times at which each given quantity of SNX vests. */\\n    mapping(address => uint[2][]) public vestingSchedules;\\n\\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\\n    mapping(address => uint) public totalEscrowedAccountBalance;\\n\\n    /* An account's total vested reward synthetix. */\\n    mapping(address => uint) public totalVestedAccountBalance;\\n\\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\\n    uint public totalEscrowedBalance;\\n\\n    uint internal constant TIME_INDEX = 0;\\n    uint internal constant QUANTITY_INDEX = 1;\\n\\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\\n     * There are 5 years of the supply schedule */\\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _owner,\\n        ISynthetix _synthetix,\\n        IFeePool _feePool\\n    ) public Owned(_owner) {\\n        synthetix = _synthetix;\\n        feePool = _feePool;\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\\n     */\\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\\n        synthetix = _synthetix;\\n        emit SynthetixUpdated(address(_synthetix));\\n    }\\n\\n    /**\\n     * @notice set the FeePool contract as it is the only authority to be able to call\\n     * appendVestingEntry with the onlyFeePool modifer\\n     */\\n    function setFeePool(IFeePool _feePool) external onlyOwner {\\n        feePool = _feePool;\\n        emit FeePoolUpdated(address(_feePool));\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\\n     */\\n    function balanceOf(address account) public view returns (uint) {\\n        return totalEscrowedAccountBalance[account];\\n    }\\n\\n    function _numVestingEntries(address account) internal view returns (uint) {\\n        return vestingSchedules[account].length;\\n    }\\n\\n    /**\\n     * @notice The number of vesting dates in an account's schedule.\\n     */\\n    function numVestingEntries(address account) external view returns (uint) {\\n        return vestingSchedules[account].length;\\n    }\\n\\n    /**\\n     * @notice Get a particular schedule entry for an account.\\n     * @return A pair of uints: (timestamp, synthetix quantity).\\n     */\\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\\n        return vestingSchedules[account][index];\\n    }\\n\\n    /**\\n     * @notice Get the time at which a given schedule entry will vest.\\n     */\\n    function getVestingTime(address account, uint index) public view returns (uint) {\\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\\n    }\\n\\n    /**\\n     * @notice Get the quantity of SNX associated with a given schedule entry.\\n     */\\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\\n    }\\n\\n    /**\\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\\n     */\\n    function getNextVestingIndex(address account) public view returns (uint) {\\n        uint len = _numVestingEntries(account);\\n        for (uint i = 0; i < len; i++) {\\n            if (getVestingTime(account, i) != 0) {\\n                return i;\\n            }\\n        }\\n        return len;\\n    }\\n\\n    /**\\n     * @notice Obtain the next schedule entry that will vest for a given user.\\n     * @return A pair of uints: (timestamp, synthetix quantity). */\\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\\n        uint index = getNextVestingIndex(account);\\n        if (index == _numVestingEntries(account)) {\\n            return [uint(0), 0];\\n        }\\n        return getVestingScheduleEntry(account, index);\\n    }\\n\\n    /**\\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\\n     */\\n    function getNextVestingTime(address account) external view returns (uint) {\\n        return getNextVestingEntry(account)[TIME_INDEX];\\n    }\\n\\n    /**\\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\\n     */\\n    function getNextVestingQuantity(address account) external view returns (uint) {\\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\\n    }\\n\\n    /**\\n     * @notice return the full vesting schedule entries vest for a given user.\\n     * @dev For DApps to display the vesting schedule for the\\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\\n     */\\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\\n        uint[520] memory _result;\\n        uint schedules = _numVestingEntries(account);\\n        for (uint i = 0; i < schedules; i++) {\\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\\n            _result[i * 2] = pair[0];\\n            _result[i * 2 + 1] = pair[1];\\n        }\\n        return _result;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function _appendVestingEntry(address account, uint quantity) internal {\\n        /* No empty or already-passed vesting entries allowed. */\\n        require(quantity != 0, \\\"Quantity cannot be zero\\\");\\n\\n        /* There must be enough balance in the contract to provide for the vesting entry. */\\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\\n        require(\\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\\n            \\\"Must be enough balance in the contract to provide for the vesting entry\\\"\\n        );\\n\\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\\n        uint scheduleLength = vestingSchedules[account].length;\\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \\\"Vesting schedule is too long\\\");\\n\\n        /* Escrow the tokens for 1 year. */\\n        uint time = now + 52 weeks;\\n\\n        if (scheduleLength == 0) {\\n            totalEscrowedAccountBalance[account] = quantity;\\n        } else {\\n            /* Disallow adding new vested SNX earlier than the last one.\\n             * Since entries are only appended, this means that no vesting date can be repeated. */\\n            require(\\n                getVestingTime(account, scheduleLength - 1) < time,\\n                \\\"Cannot add new vested entries earlier than the last one\\\"\\n            );\\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\\n        }\\n\\n        vestingSchedules[account].push([time, quantity]);\\n\\n        emit VestingEntryCreated(account, now, quantity);\\n    }\\n\\n    /**\\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\\n     * to ensure that when the funds are withdrawn, there is enough balance.\\n     * Note; although this function could technically be used to produce unbounded\\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\\n     * @param account The account to append a new vesting entry to.\\n     * @param quantity The quantity of SNX that will be escrowed.\\n     */\\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\\n        _appendVestingEntry(account, quantity);\\n    }\\n\\n    /**\\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\\n     */\\n    function vest() external {\\n        uint numEntries = _numVestingEntries(msg.sender);\\n        uint total;\\n        for (uint i = 0; i < numEntries; i++) {\\n            uint time = getVestingTime(msg.sender, i);\\n            /* The list is sorted; when we reach the first future time, bail out. */\\n            if (time > now) {\\n                break;\\n            }\\n            uint qty = getVestingQuantity(msg.sender, i);\\n            if (qty > 0) {\\n                vestingSchedules[msg.sender][i] = [0, 0];\\n                total = total.add(qty);\\n            }\\n        }\\n\\n        if (total != 0) {\\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\\n            IERC20(address(synthetix)).transfer(msg.sender, total);\\n            emit Vested(msg.sender, now, total);\\n        }\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyFeePool() {\\n        bool isFeePool = msg.sender == address(feePool);\\n\\n        require(isFeePool, \\\"Only the FeePool contracts can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event SynthetixUpdated(address newSynthetix);\\n\\n    event FeePoolUpdated(address newFeePool);\\n\\n    event Vested(address indexed beneficiary, uint time, uint value);\\n\\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\\ninterface IRewardsDistribution {\\n    // Structs\\n    struct DistributionData {\\n        address destination;\\n        uint amount;\\n    }\\n\\n    // Views\\n    function authority() external view returns (address);\\n\\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\\n\\n    function distributionsLength() external view returns (uint);\\n\\n    // Mutative Functions\\n    function distributeRewards(uint amount) external returns (bool);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraires\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/rewardsdistribution\\ncontract RewardsDistribution is Owned, IRewardsDistribution {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /**\\n     * @notice Authorised address able to call distributeRewards\\n     */\\n    address public authority;\\n\\n    /**\\n     * @notice Address of the Synthetix ProxyERC20\\n     */\\n    address public synthetixProxy;\\n\\n    /**\\n     * @notice Address of the RewardEscrow contract\\n     */\\n    address public rewardEscrow;\\n\\n    /**\\n     * @notice Address of the FeePoolProxy\\n     */\\n    address public feePoolProxy;\\n\\n    /**\\n     * @notice An array of addresses and amounts to send\\n     */\\n    DistributionData[] public distributions;\\n\\n    /**\\n     * @dev _authority maybe the underlying synthetix contract.\\n     * Remember to set the authority on a synthetix upgrade\\n     */\\n    constructor(\\n        address _owner,\\n        address _authority,\\n        address _synthetixProxy,\\n        address _rewardEscrow,\\n        address _feePoolProxy\\n    ) public Owned(_owner) {\\n        authority = _authority;\\n        synthetixProxy = _synthetixProxy;\\n        rewardEscrow = _rewardEscrow;\\n        feePoolProxy = _feePoolProxy;\\n    }\\n\\n    // ========== EXTERNAL SETTERS ==========\\n\\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\\n        synthetixProxy = _synthetixProxy;\\n    }\\n\\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\\n        rewardEscrow = _rewardEscrow;\\n    }\\n\\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\\n        feePoolProxy = _feePoolProxy;\\n    }\\n\\n    /**\\n     * @notice Set the address of the contract authorised to call distributeRewards()\\n     * @param _authority Address of the authorised calling contract.\\n     */\\n    function setAuthority(address _authority) external onlyOwner {\\n        authority = _authority;\\n    }\\n\\n    // ========== EXTERNAL FUNCTIONS ==========\\n\\n    /**\\n     * @notice Adds a Rewards DistributionData struct to the distributions\\n     * array. Any entries here will be iterated and rewards distributed to\\n     * each address when tokens are sent to this contract and distributeRewards()\\n     * is called by the autority.\\n     * @param destination An address to send rewards tokens too\\n     * @param amount The amount of rewards tokens to send\\n     */\\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\\n        require(destination != address(0), \\\"Cant add a zero address\\\");\\n        require(amount != 0, \\\"Cant add a zero amount\\\");\\n\\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\\n        distributions.push(rewardsDistribution);\\n\\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Deletes a RewardDistribution from the distributions\\n     * so it will no longer be included in the call to distributeRewards()\\n     * @param index The index of the DistributionData to delete\\n     */\\n    function removeRewardDistribution(uint index) external onlyOwner {\\n        require(index <= distributions.length - 1, \\\"index out of bounds\\\");\\n\\n        // shift distributions indexes across\\n        for (uint i = index; i < distributions.length - 1; i++) {\\n            distributions[i] = distributions[i + 1];\\n        }\\n        distributions.length--;\\n\\n        // Since this function must shift all later entries down to fill the\\n        // gap from the one it removed, it could in principle consume an\\n        // unbounded amount of gas. However, the number of entries will\\n        // presumably always be very low.\\n    }\\n\\n    /**\\n     * @notice Edits a RewardDistribution in the distributions array.\\n     * @param index The index of the DistributionData to edit\\n     * @param destination The destination address. Send the same address to keep or different address to change it.\\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\\n     */\\n    function editRewardDistribution(\\n        uint index,\\n        address destination,\\n        uint amount\\n    ) external onlyOwner returns (bool) {\\n        require(index <= distributions.length - 1, \\\"index out of bounds\\\");\\n\\n        distributions[index].destination = destination;\\n        distributions[index].amount = amount;\\n\\n        return true;\\n    }\\n\\n    function distributeRewards(uint amount) external returns (bool) {\\n        require(amount > 0, \\\"Nothing to distribute\\\");\\n        require(msg.sender == authority, \\\"Caller is not authorised\\\");\\n        require(rewardEscrow != address(0), \\\"RewardEscrow is not set\\\");\\n        require(synthetixProxy != address(0), \\\"SynthetixProxy is not set\\\");\\n        require(feePoolProxy != address(0), \\\"FeePoolProxy is not set\\\");\\n        require(\\n            IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\\n            \\\"RewardsDistribution contract does not have enough tokens to distribute\\\"\\n        );\\n\\n        uint remainder = amount;\\n\\n        // Iterate the array of distributions sending the configured amounts\\n        for (uint i = 0; i < distributions.length; i++) {\\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\\n                remainder = remainder.sub(distributions[i].amount);\\n\\n                // Transfer the SNX\\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\\n\\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\\n                bytes memory payload = abi.encodeWithSignature(\\\"notifyRewardAmount(uint256)\\\", distributions[i].amount);\\n\\n                // solhint-disable avoid-low-level-calls\\n                (bool success, ) = distributions[i].destination.call(payload);\\n\\n                if (!success) {\\n                    // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\\n                }\\n            }\\n        }\\n\\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\\n\\n        // Tell the FeePool how much it has to distribute to the stakers\\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\\n\\n        emit RewardsDistributed(amount);\\n        return true;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Retrieve the length of the distributions array\\n     */\\n    function distributionsLength() external view returns (uint) {\\n        return distributions.length;\\n    }\\n\\n    /* ========== Events ========== */\\n\\n    event RewardDistributionAdded(uint index, address destination, uint amount);\\n    event RewardsDistributed(uint amount);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\\ninterface IFlexibleStorage {\\n    // Views\\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\\n\\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\\n\\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\\n\\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\\n\\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\\n\\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\\n\\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\\n\\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\\n\\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\\n\\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\\n\\n    // Mutative functions\\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\\n\\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\\n\\n    function setUIntValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        uint value\\n    ) external;\\n\\n    function setUIntValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        uint[] calldata values\\n    ) external;\\n\\n    function setIntValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        int value\\n    ) external;\\n\\n    function setIntValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        int[] calldata values\\n    ) external;\\n\\n    function setAddressValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        address value\\n    ) external;\\n\\n    function setAddressValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        address[] calldata values\\n    ) external;\\n\\n    function setBoolValue(\\n        bytes32 contractName,\\n        bytes32 record,\\n        bool value\\n    ) external;\\n\\n    function setBoolValues(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        bool[] calldata values\\n    ) external;\\n\\n    function setBytes32Value(\\n        bytes32 contractName,\\n        bytes32 record,\\n        bytes32 value\\n    ) external;\\n\\n    function setBytes32Values(\\n        bytes32 contractName,\\n        bytes32[] calldata records,\\n        bytes32[] calldata values\\n    ) external;\\n}\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\\ncontract MixinSystemSettings is MixinResolver {\\n    bytes32 internal constant SETTING_CONTRACT_NAME = \\\"SystemSettings\\\";\\n\\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \\\"waitingPeriodSecs\\\";\\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \\\"priceDeviationThresholdFactor\\\";\\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \\\"issuanceRatio\\\";\\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \\\"feePeriodDuration\\\";\\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \\\"targetThreshold\\\";\\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \\\"liquidationDelay\\\";\\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \\\"liquidationRatio\\\";\\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \\\"liquidationPenalty\\\";\\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \\\"rateStalePeriod\\\";\\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \\\"exchangeFeeRate\\\";\\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \\\"minimumStakeTime\\\";\\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \\\"aggregatorWarningFlags\\\";\\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \\\"tradingRewardsEnabled\\\";\\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \\\"debtSnapshotStaleTime\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \\\"crossDomainDepositGasLimit\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \\\"crossDomainEscrowGasLimit\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \\\"crossDomainRewardGasLimit\\\";\\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \\\"crossDomainWithdrawalGasLimit\\\";\\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \\\"etherWrapperMaxETH\\\";\\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \\\"etherWrapperMintFeeRate\\\";\\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \\\"etherWrapperBurnFeeRate\\\";\\n\\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \\\"FlexibleStorage\\\";\\n\\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal}\\n\\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\\n\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        addresses = new bytes32[](1);\\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\\n    }\\n\\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\\n    }\\n\\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\\n        } else {\\n            revert(\\\"Unknown gas limit type\\\");\\n        }\\n    }\\n\\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\\n    }\\n\\n    function getTradingRewardsEnabled() internal view returns (bool) {\\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\\n    }\\n\\n    function getWaitingPeriodSecs() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\\n    }\\n\\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\\n    }\\n\\n    function getIssuanceRatio() internal view returns (uint) {\\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\\n    }\\n\\n    function getFeePeriodDuration() internal view returns (uint) {\\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\\n    }\\n\\n    function getTargetThreshold() internal view returns (uint) {\\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\\n    }\\n\\n    function getLiquidationDelay() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\\n    }\\n\\n    function getLiquidationRatio() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\\n    }\\n\\n    function getLiquidationPenalty() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\\n    }\\n\\n    function getRateStalePeriod() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\\n    }\\n\\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\\n        return\\n            flexibleStorage().getUIntValue(\\n                SETTING_CONTRACT_NAME,\\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\\n            );\\n    }\\n\\n    function getMinimumStakeTime() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\\n    }\\n\\n    function getAggregatorWarningFlags() internal view returns (address) {\\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\\n    }\\n\\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\\n    }\\n\\n    function getEtherWrapperMaxETH() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\\n    }\\n\\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\\n    }\\n\\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\\ninterface IExchanger {\\n    // Views\\n    function calculateAmountAfterSettlement(\\n        address from,\\n        bytes32 currencyKey,\\n        uint amount,\\n        uint refunded\\n    ) external view returns (uint amountAfterSettlement);\\n\\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\\n\\n    function settlementOwing(address account, bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint reclaimAmount,\\n            uint rebateAmount,\\n            uint numEntries\\n        );\\n\\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\\n\\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\\n        external\\n        view\\n        returns (uint exchangeFeeRate);\\n\\n    function getAmountsForExchange(\\n        uint sourceAmount,\\n        bytes32 sourceCurrencyKey,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint amountReceived,\\n            uint fee,\\n            uint exchangeFeeRate\\n        );\\n\\n    function priceDeviationThresholdFactor() external view returns (uint);\\n\\n    function waitingPeriodSecs() external view returns (uint);\\n\\n    // Mutative functions\\n    function exchange(\\n        address exchangeForAddress,\\n        address from,\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        address destinationAddress,\\n        bool virtualSynth,\\n        address rewardAddress,\\n        bytes32 trackingCode\\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\\n\\n    function settle(address from, bytes32 currencyKey)\\n        external\\n        returns (\\n            uint reclaimed,\\n            uint refunded,\\n            uint numEntries\\n        );\\n\\n    function setLastExchangeRateForSynth(bytes32 currencyKey, uint rate) external;\\n\\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\\n\\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\\n}\\n\\n\\npragma experimental ABIEncoderV2;\\n\\nlibrary VestingEntries {\\n    struct VestingEntry {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n    }\\n    struct VestingEntryWithID {\\n        uint64 endTime;\\n        uint256 escrowAmount;\\n        uint256 entryID;\\n    }\\n}\\n\\ninterface IRewardEscrowV2 {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function numVestingEntries(address account) external view returns (uint);\\n\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n\\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\\n\\n    function getVestingSchedules(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\\n\\n    function getAccountVestingEntryIDs(\\n        address account,\\n        uint256 index,\\n        uint256 pageSize\\n    ) external view returns (uint256[] memory);\\n\\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\\n\\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\\n\\n    // Mutative functions\\n    function vest(uint256[] calldata entryIDs) external;\\n\\n    function createEscrowEntry(\\n        address beneficiary,\\n        uint256 deposit,\\n        uint256 duration\\n    ) external;\\n\\n    function appendVestingEntry(\\n        address account,\\n        uint256 quantity,\\n        uint256 duration\\n    ) external;\\n\\n    function migrateVestingSchedule(address _addressToMigrate) external;\\n\\n    function migrateAccountEscrowBalances(\\n        address[] calldata accounts,\\n        uint256[] calldata escrowBalances,\\n        uint256[] calldata vestedBalances\\n    ) external;\\n\\n    // Account Merging\\n    function startMergingWindow() external;\\n\\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\\n\\n    function nominateAccountToMerge(address account) external;\\n\\n    function accountMergingIsOpen() external view returns (bool);\\n\\n    // L2 Migration\\n    function importVestingEntries(\\n        address account,\\n        uint256 escrowedAmount,\\n        VestingEntries.VestingEntry[] calldata vestingEntries\\n    ) external;\\n\\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\\n    function burnForMigration(address account, uint256[] calldata entryIDs)\\n        external\\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\\ninterface IDelegateApprovals {\\n    // Views\\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\\n\\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\\n\\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\\n\\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\\n\\n    // Mutative\\n    function approveAllDelegatePowers(address delegate) external;\\n\\n    function removeAllDelegatePowers(address delegate) external;\\n\\n    function approveBurnOnBehalf(address delegate) external;\\n\\n    function removeBurnOnBehalf(address delegate) external;\\n\\n    function approveIssueOnBehalf(address delegate) external;\\n\\n    function removeIssueOnBehalf(address delegate) external;\\n\\n    function approveClaimOnBehalf(address delegate) external;\\n\\n    function removeClaimOnBehalf(address delegate) external;\\n\\n    function approveExchangeOnBehalf(address delegate) external;\\n\\n    function removeExchangeOnBehalf(address delegate) external;\\n}\\n\\n\\ninterface ICollateralManager {\\n    // Manager information\\n    function hasCollateral(address collateral) external view returns (bool);\\n\\n    function isSynthManaged(bytes32 currencyKey) external view returns (bool);\\n\\n    // State information\\n    function long(bytes32 synth) external view returns (uint amount);\\n\\n    function short(bytes32 synth) external view returns (uint amount);\\n\\n    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid);\\n\\n    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid);\\n\\n    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid);\\n\\n    function getShortRate(bytes32 synth) external view returns (uint shortRate, bool rateIsInvalid);\\n\\n    function getRatesAndTime(uint index)\\n        external\\n        view\\n        returns (\\n            uint entryRate,\\n            uint lastRate,\\n            uint lastUpdated,\\n            uint newIndex\\n        );\\n\\n    function getShortRatesAndTime(bytes32 currency, uint index)\\n        external\\n        view\\n        returns (\\n            uint entryRate,\\n            uint lastRate,\\n            uint lastUpdated,\\n            uint newIndex\\n        );\\n\\n    function exceedsDebtLimit(uint amount, bytes32 currency) external view returns (bool canIssue, bool anyRateIsInvalid);\\n\\n    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\\n        external\\n        view\\n        returns (bool);\\n\\n    function areShortableSynthsSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\\n        external\\n        view\\n        returns (bool);\\n\\n    // Loans\\n    function getNewLoanId() external returns (uint id);\\n\\n    // Manager mutative\\n    function addCollaterals(address[] calldata collaterals) external;\\n\\n    function removeCollaterals(address[] calldata collaterals) external;\\n\\n    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external;\\n\\n    function removeSynths(bytes32[] calldata synths, bytes32[] calldata synthKeys) external;\\n\\n    function addShortableSynths(bytes32[2][] calldata requiredSynthAndInverseNamesInResolver, bytes32[] calldata synthKeys)\\n        external;\\n\\n    function removeShortableSynths(bytes32[] calldata synths) external;\\n\\n    // State mutative\\n    function updateBorrowRates(uint rate) external;\\n\\n    function updateShortRates(bytes32 currency, uint rate) external;\\n\\n    function incrementLongs(bytes32 synth, uint amount) external;\\n\\n    function decrementLongs(bytes32 synth, uint amount) external;\\n\\n    function incrementShorts(bytes32 synth, uint amount) external;\\n\\n    function decrementShorts(bytes32 synth, uint amount) external;\\n}\\n\\n\\ninterface IWETH {\\n    // ERC20 Optional Views\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    // Views\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // Mutative functions\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // WETH-specific functions.\\n    function deposit() external payable;\\n\\n    function withdraw(uint amount) external;\\n\\n    // Events\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Deposit(address indexed to, uint amount);\\n    event Withdrawal(address indexed to, uint amount);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ietherwrapper\\ncontract IEtherWrapper {\\n    function mint(uint amount) external;\\n\\n    function burn(uint amount) external;\\n\\n    function distributeFees() external;\\n\\n    function capacity() external view returns (uint);\\n\\n    function getReserves() external view returns (uint);\\n\\n    function totalIssuedSynths() external view returns (uint);\\n\\n    function calculateMintFee(uint amount) public view returns (uint);\\n\\n    function calculateBurnFee(uint amount) public view returns (uint);\\n\\n    function maxETH() public view returns (uint256);\\n\\n    function mintFeeRate() public view returns (uint256);\\n\\n    function burnFeeRate() public view returns (uint256);\\n\\n    function weth() public view returns (IWETH);\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/feepool\\ncontract FeePool is Owned, Proxyable, LimitedSetup, MixinSystemSettings, IFeePool {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    bytes32 public constant CONTRACT_NAME = \\\"FeePool\\\";\\n\\n    // Where fees are pooled in sUSD.\\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\\n\\n    // sUSD currencyKey. Fees stored and paid in sUSD\\n    bytes32 private sUSD = \\\"sUSD\\\";\\n\\n    // This struct represents the issuance activity that's happened in a fee period.\\n    struct FeePeriod {\\n        uint64 feePeriodId;\\n        uint64 startingDebtIndex;\\n        uint64 startTime;\\n        uint feesToDistribute;\\n        uint feesClaimed;\\n        uint rewardsToDistribute;\\n        uint rewardsClaimed;\\n    }\\n\\n    // A staker(mintr) can claim from the previous fee period (7 days) only.\\n    // Fee Periods stored and managed from [0], such that [0] is always\\n    // the current active fee period which is not claimable until the\\n    // public function closeCurrentFeePeriod() is called closing the\\n    // current weeks collected fees. [1] is last weeks feeperiod\\n    uint8 public constant FEE_PERIOD_LENGTH = 2;\\n\\n    FeePeriod[FEE_PERIOD_LENGTH] private _recentFeePeriods;\\n    uint256 private _currentFeePeriod;\\n\\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\\n\\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \\\"SystemStatus\\\";\\n    bytes32 private constant CONTRACT_SYNTHETIX = \\\"Synthetix\\\";\\n    bytes32 private constant CONTRACT_FEEPOOLSTATE = \\\"FeePoolState\\\";\\n    bytes32 private constant CONTRACT_FEEPOOLETERNALSTORAGE = \\\"FeePoolEternalStorage\\\";\\n    bytes32 private constant CONTRACT_EXCHANGER = \\\"Exchanger\\\";\\n    bytes32 private constant CONTRACT_ISSUER = \\\"Issuer\\\";\\n    bytes32 private constant CONTRACT_SYNTHETIXSTATE = \\\"SynthetixState\\\";\\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \\\"RewardEscrowV2\\\";\\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \\\"DelegateApprovals\\\";\\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \\\"CollateralManager\\\";\\n    bytes32 private constant CONTRACT_REWARDSDISTRIBUTION = \\\"RewardsDistribution\\\";\\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \\\"EtherWrapper\\\";\\n\\n    /* ========== ETERNAL STORAGE CONSTANTS ========== */\\n\\n    bytes32 private constant LAST_FEE_WITHDRAWAL = \\\"last_fee_withdrawal\\\";\\n\\n    constructor(\\n        address payable _proxy,\\n        address _owner,\\n        address _resolver\\n    ) public Owned(_owner) Proxyable(_proxy) LimitedSetup(3 weeks) MixinSystemSettings(_resolver) {\\n        // Set our initial fee period\\n        _recentFeePeriodsStorage(0).feePeriodId = 1;\\n        _recentFeePeriodsStorage(0).startTime = uint64(now);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\\n        bytes32[] memory newAddresses = new bytes32[](12);\\n        newAddresses[0] = CONTRACT_SYSTEMSTATUS;\\n        newAddresses[1] = CONTRACT_SYNTHETIX;\\n        newAddresses[2] = CONTRACT_FEEPOOLSTATE;\\n        newAddresses[3] = CONTRACT_FEEPOOLETERNALSTORAGE;\\n        newAddresses[4] = CONTRACT_EXCHANGER;\\n        newAddresses[5] = CONTRACT_ISSUER;\\n        newAddresses[6] = CONTRACT_SYNTHETIXSTATE;\\n        newAddresses[7] = CONTRACT_REWARDESCROW_V2;\\n        newAddresses[8] = CONTRACT_DELEGATEAPPROVALS;\\n        newAddresses[9] = CONTRACT_REWARDSDISTRIBUTION;\\n        newAddresses[10] = CONTRACT_COLLATERALMANAGER;\\n        newAddresses[11] = CONTRACT_ETHER_WRAPPER;\\n        addresses = combineArrays(existingAddresses, newAddresses);\\n    }\\n\\n    function systemStatus() internal view returns (ISystemStatus) {\\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\\n    }\\n\\n    function synthetix() internal view returns (ISynthetix) {\\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\\n    }\\n\\n    function feePoolState() internal view returns (FeePoolState) {\\n        return FeePoolState(requireAndGetAddress(CONTRACT_FEEPOOLSTATE));\\n    }\\n\\n    function feePoolEternalStorage() internal view returns (FeePoolEternalStorage) {\\n        return FeePoolEternalStorage(requireAndGetAddress(CONTRACT_FEEPOOLETERNALSTORAGE));\\n    }\\n\\n    function exchanger() internal view returns (IExchanger) {\\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\\n    }\\n\\n    function collateralManager() internal view returns (ICollateralManager) {\\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\\n    }\\n\\n    function issuer() internal view returns (IIssuer) {\\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\\n    }\\n\\n    function synthetixState() internal view returns (ISynthetixState) {\\n        return ISynthetixState(requireAndGetAddress(CONTRACT_SYNTHETIXSTATE));\\n    }\\n\\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\\n    }\\n\\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\\n    }\\n\\n    function rewardsDistribution() internal view returns (IRewardsDistribution) {\\n        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));\\n    }\\n\\n    function etherWrapper() internal view returns (IEtherWrapper) {\\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\\n    }\\n\\n    function issuanceRatio() external view returns (uint) {\\n        return getIssuanceRatio();\\n    }\\n\\n    function feePeriodDuration() external view returns (uint) {\\n        return getFeePeriodDuration();\\n    }\\n\\n    function targetThreshold() external view returns (uint) {\\n        return getTargetThreshold();\\n    }\\n\\n    function recentFeePeriods(uint index)\\n        external\\n        view\\n        returns (\\n            uint64 feePeriodId,\\n            uint64 startingDebtIndex,\\n            uint64 startTime,\\n            uint feesToDistribute,\\n            uint feesClaimed,\\n            uint rewardsToDistribute,\\n            uint rewardsClaimed\\n        )\\n    {\\n        FeePeriod memory feePeriod = _recentFeePeriodsStorage(index);\\n        return (\\n            feePeriod.feePeriodId,\\n            feePeriod.startingDebtIndex,\\n            feePeriod.startTime,\\n            feePeriod.feesToDistribute,\\n            feePeriod.feesClaimed,\\n            feePeriod.rewardsToDistribute,\\n            feePeriod.rewardsClaimed\\n        );\\n    }\\n\\n    function _recentFeePeriodsStorage(uint index) internal view returns (FeePeriod storage) {\\n        return _recentFeePeriods[(_currentFeePeriod + index) % FEE_PERIOD_LENGTH];\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Logs an accounts issuance data per fee period\\n     * @param account Message.Senders account address\\n     * @param debtRatio Debt percentage this account has locked after minting or burning their synth\\n     * @param debtEntryIndex The index in the global debt ledger. synthetixState.issuanceData(account)\\n     * @dev onlyIssuer to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\\n     */\\n    function appendAccountIssuanceRecord(\\n        address account,\\n        uint debtRatio,\\n        uint debtEntryIndex\\n    ) external onlyIssuerAndSynthetixState {\\n        feePoolState().appendAccountIssuanceRecord(\\n            account,\\n            debtRatio,\\n            debtEntryIndex,\\n            _recentFeePeriodsStorage(0).startingDebtIndex\\n        );\\n\\n        emitIssuanceDebtRatioEntry(account, debtRatio, debtEntryIndex, _recentFeePeriodsStorage(0).startingDebtIndex);\\n    }\\n\\n    /**\\n     * @notice The Exchanger contract informs us when fees are paid.\\n     * @param amount susd amount in fees being paid.\\n     */\\n    function recordFeePaid(uint amount) external onlyInternalContracts {\\n        // Keep track off fees in sUSD in the open fee pool period.\\n        _recentFeePeriodsStorage(0).feesToDistribute = _recentFeePeriodsStorage(0).feesToDistribute.add(amount);\\n    }\\n\\n    /**\\n     * @notice The RewardsDistribution contract informs us how many SNX rewards are sent to RewardEscrow to be claimed.\\n     */\\n    function setRewardsToDistribute(uint amount) external {\\n        address rewardsAuthority = address(rewardsDistribution());\\n        require(messageSender == rewardsAuthority || msg.sender == rewardsAuthority, \\\"Caller is not rewardsAuthority\\\");\\n        // Add the amount of SNX rewards to distribute on top of any rolling unclaimed amount\\n        _recentFeePeriodsStorage(0).rewardsToDistribute = _recentFeePeriodsStorage(0).rewardsToDistribute.add(amount);\\n    }\\n\\n    /**\\n     * @notice Close the current fee period and start a new one.\\n     */\\n    function closeCurrentFeePeriod() external issuanceActive {\\n        require(getFeePeriodDuration() > 0, \\\"Fee Period Duration not set\\\");\\n        require(_recentFeePeriodsStorage(0).startTime <= (now - getFeePeriodDuration()), \\\"Too early to close fee period\\\");\\n\\n        etherWrapper().distributeFees();\\n\\n        // Note:  when FEE_PERIOD_LENGTH = 2, periodClosing is the current period & periodToRollover is the last open claimable period\\n        FeePeriod storage periodClosing = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2);\\n        FeePeriod storage periodToRollover = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 1);\\n\\n        // Any unclaimed fees from the last period in the array roll back one period.\\n        // Because of the subtraction here, they're effectively proportionally redistributed to those who\\n        // have already claimed from the old period, available in the new period.\\n        // The subtraction is important so we don't create a ticking time bomb of an ever growing\\n        // number of fees that can never decrease and will eventually overflow at the end of the fee pool.\\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).feesToDistribute = periodToRollover\\n            .feesToDistribute\\n            .sub(periodToRollover.feesClaimed)\\n            .add(periodClosing.feesToDistribute);\\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).rewardsToDistribute = periodToRollover\\n            .rewardsToDistribute\\n            .sub(periodToRollover.rewardsClaimed)\\n            .add(periodClosing.rewardsToDistribute);\\n\\n        // Shift the previous fee periods across to make room for the new one.\\n        _currentFeePeriod = _currentFeePeriod.add(FEE_PERIOD_LENGTH).sub(1).mod(FEE_PERIOD_LENGTH);\\n\\n        // Clear the first element of the array to make sure we don't have any stale values.\\n        delete _recentFeePeriods[_currentFeePeriod];\\n\\n        // Open up the new fee period.\\n        // Increment periodId from the recent closed period feePeriodId\\n        _recentFeePeriodsStorage(0).feePeriodId = uint64(uint256(_recentFeePeriodsStorage(1).feePeriodId).add(1));\\n        _recentFeePeriodsStorage(0).startingDebtIndex = uint64(synthetixState().debtLedgerLength());\\n        _recentFeePeriodsStorage(0).startTime = uint64(now);\\n\\n        emitFeePeriodClosed(_recentFeePeriodsStorage(1).feePeriodId);\\n    }\\n\\n    /**\\n     * @notice Claim fees for last period when available or not already withdrawn.\\n     */\\n    function claimFees() external issuanceActive optionalProxy returns (bool) {\\n        return _claimFees(messageSender);\\n    }\\n\\n    /**\\n     * @notice Delegated claimFees(). Call from the deletegated address\\n     * and the fees will be sent to the claimingForAddress.\\n     * approveClaimOnBehalf() must be called first to approve the deletage address\\n     * @param claimingForAddress The account you are claiming fees for\\n     */\\n    function claimOnBehalf(address claimingForAddress) external issuanceActive optionalProxy returns (bool) {\\n        require(delegateApprovals().canClaimFor(claimingForAddress, messageSender), \\\"Not approved to claim on behalf\\\");\\n\\n        return _claimFees(claimingForAddress);\\n    }\\n\\n    function _claimFees(address claimingAddress) internal returns (bool) {\\n        uint rewardsPaid = 0;\\n        uint feesPaid = 0;\\n        uint availableFees;\\n        uint availableRewards;\\n\\n        // Address won't be able to claim fees if it is too far below the target c-ratio.\\n        // It will need to burn synths then try claiming again.\\n        (bool feesClaimable, bool anyRateIsInvalid) = _isFeesClaimableAndAnyRatesInvalid(claimingAddress);\\n\\n        require(feesClaimable, \\\"C-Ratio below penalty threshold\\\");\\n\\n        require(!anyRateIsInvalid, \\\"A synth or SNX rate is invalid\\\");\\n\\n        // Get the claimingAddress available fees and rewards\\n        (availableFees, availableRewards) = feesAvailable(claimingAddress);\\n\\n        require(\\n            availableFees > 0 || availableRewards > 0,\\n            \\\"No fees or rewards available for period, or fees already claimed\\\"\\n        );\\n\\n        // Record the address has claimed for this period\\n        _setLastFeeWithdrawal(claimingAddress, _recentFeePeriodsStorage(1).feePeriodId);\\n\\n        if (availableFees > 0) {\\n            // Record the fee payment in our recentFeePeriods\\n            feesPaid = _recordFeePayment(availableFees);\\n\\n            // Send them their fees\\n            _payFees(claimingAddress, feesPaid);\\n        }\\n\\n        if (availableRewards > 0) {\\n            // Record the reward payment in our recentFeePeriods\\n            rewardsPaid = _recordRewardPayment(availableRewards);\\n\\n            // Send them their rewards\\n            _payRewards(claimingAddress, rewardsPaid);\\n        }\\n\\n        emitFeesClaimed(claimingAddress, feesPaid, rewardsPaid);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Admin function to import the FeePeriod data from the previous contract\\n     */\\n    function importFeePeriod(\\n        uint feePeriodIndex,\\n        uint feePeriodId,\\n        uint startingDebtIndex,\\n        uint startTime,\\n        uint feesToDistribute,\\n        uint feesClaimed,\\n        uint rewardsToDistribute,\\n        uint rewardsClaimed\\n    ) public optionalProxy_onlyOwner onlyDuringSetup {\\n        require(startingDebtIndex <= synthetixState().debtLedgerLength(), \\\"Cannot import bad data\\\");\\n\\n        _recentFeePeriods[_currentFeePeriod.add(feePeriodIndex).mod(FEE_PERIOD_LENGTH)] = FeePeriod({\\n            feePeriodId: uint64(feePeriodId),\\n            startingDebtIndex: uint64(startingDebtIndex),\\n            startTime: uint64(startTime),\\n            feesToDistribute: feesToDistribute,\\n            feesClaimed: feesClaimed,\\n            rewardsToDistribute: rewardsToDistribute,\\n            rewardsClaimed: rewardsClaimed\\n        });\\n    }\\n\\n    /**\\n     * @notice Record the fee payment in our recentFeePeriods.\\n     * @param sUSDAmount The amount of fees priced in sUSD.\\n     */\\n    function _recordFeePayment(uint sUSDAmount) internal returns (uint) {\\n        // Don't assign to the parameter\\n        uint remainingToAllocate = sUSDAmount;\\n\\n        uint feesPaid;\\n        // Start at the oldest period and record the amount, moving to newer periods\\n        // until we've exhausted the amount.\\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\\n            uint feesAlreadyClaimed = _recentFeePeriodsStorage(i).feesClaimed;\\n            uint delta = _recentFeePeriodsStorage(i).feesToDistribute.sub(feesAlreadyClaimed);\\n\\n            if (delta > 0) {\\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\\n                uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate;\\n\\n                _recentFeePeriodsStorage(i).feesClaimed = feesAlreadyClaimed.add(amountInPeriod);\\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\\n                feesPaid = feesPaid.add(amountInPeriod);\\n\\n                // No need to continue iterating if we've recorded the whole amount;\\n                if (remainingToAllocate == 0) return feesPaid;\\n\\n                // We've exhausted feePeriods to distribute and no fees remain in last period\\n                // User last to claim would in this scenario have their remainder slashed\\n                if (i == 0 && remainingToAllocate > 0) {\\n                    remainingToAllocate = 0;\\n                }\\n            }\\n        }\\n\\n        return feesPaid;\\n    }\\n\\n    /**\\n     * @notice Record the reward payment in our recentFeePeriods.\\n     * @param snxAmount The amount of SNX tokens.\\n     */\\n    function _recordRewardPayment(uint snxAmount) internal returns (uint) {\\n        // Don't assign to the parameter\\n        uint remainingToAllocate = snxAmount;\\n\\n        uint rewardPaid;\\n\\n        // Start at the oldest period and record the amount, moving to newer periods\\n        // until we've exhausted the amount.\\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\\n            uint toDistribute =\\n                _recentFeePeriodsStorage(i).rewardsToDistribute.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\\n\\n            if (toDistribute > 0) {\\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\\n                uint amountInPeriod = toDistribute < remainingToAllocate ? toDistribute : remainingToAllocate;\\n\\n                _recentFeePeriodsStorage(i).rewardsClaimed = _recentFeePeriodsStorage(i).rewardsClaimed.add(amountInPeriod);\\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\\n                rewardPaid = rewardPaid.add(amountInPeriod);\\n\\n                // No need to continue iterating if we've recorded the whole amount;\\n                if (remainingToAllocate == 0) return rewardPaid;\\n\\n                // We've exhausted feePeriods to distribute and no rewards remain in last period\\n                // User last to claim would in this scenario have their remainder slashed\\n                // due to rounding up of PreciseDecimal\\n                if (i == 0 && remainingToAllocate > 0) {\\n                    remainingToAllocate = 0;\\n                }\\n            }\\n        }\\n        return rewardPaid;\\n    }\\n\\n    /**\\n     * @notice Send the fees to claiming address.\\n     * @param account The address to send the fees to.\\n     * @param sUSDAmount The amount of fees priced in sUSD.\\n     */\\n    function _payFees(address account, uint sUSDAmount) internal notFeeAddress(account) {\\n        // Grab the sUSD Synth\\n        ISynth sUSDSynth = issuer().synths(sUSD);\\n\\n        // NOTE: we do not control the FEE_ADDRESS so it is not possible to do an\\n        // ERC20.approve() transaction to allow this feePool to call ERC20.transferFrom\\n        // to the accounts address\\n\\n        // Burn the source amount\\n        sUSDSynth.burn(FEE_ADDRESS, sUSDAmount);\\n\\n        // Mint their new synths\\n        sUSDSynth.issue(account, sUSDAmount);\\n    }\\n\\n    /**\\n     * @notice Send the rewards to claiming address - will be locked in rewardEscrow.\\n     * @param account The address to send the fees to.\\n     * @param snxAmount The amount of SNX.\\n     */\\n    function _payRewards(address account, uint snxAmount) internal notFeeAddress(account) {\\n        /* Escrow the tokens for 1 year. */\\n        uint escrowDuration = 52 weeks;\\n\\n        // Record vesting entry for claiming address and amount\\n        // SNX already minted to rewardEscrow balance\\n        rewardEscrowV2().appendVestingEntry(account, snxAmount, escrowDuration);\\n    }\\n\\n    /**\\n     * @notice The total fees available in the system to be withdrawnn in sUSD\\n     */\\n    function totalFeesAvailable() external view returns (uint) {\\n        uint totalFees = 0;\\n\\n        // Fees in fee period [0] are not yet available for withdrawal\\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\\n            totalFees = totalFees.add(_recentFeePeriodsStorage(i).feesToDistribute);\\n            totalFees = totalFees.sub(_recentFeePeriodsStorage(i).feesClaimed);\\n        }\\n\\n        return totalFees;\\n    }\\n\\n    /**\\n     * @notice The total SNX rewards available in the system to be withdrawn\\n     */\\n    function totalRewardsAvailable() external view returns (uint) {\\n        uint totalRewards = 0;\\n\\n        // Rewards in fee period [0] are not yet available for withdrawal\\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\\n            totalRewards = totalRewards.add(_recentFeePeriodsStorage(i).rewardsToDistribute);\\n            totalRewards = totalRewards.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\\n        }\\n\\n        return totalRewards;\\n    }\\n\\n    /**\\n     * @notice The fees available to be withdrawn by a specific account, priced in sUSD\\n     * @dev Returns two amounts, one for fees and one for SNX rewards\\n     */\\n    function feesAvailable(address account) public view returns (uint, uint) {\\n        // Add up the fees\\n        uint[2][FEE_PERIOD_LENGTH] memory userFees = feesByPeriod(account);\\n\\n        uint totalFees = 0;\\n        uint totalRewards = 0;\\n\\n        // Fees & Rewards in fee period [0] are not yet available for withdrawal\\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\\n            totalFees = totalFees.add(userFees[i][0]);\\n            totalRewards = totalRewards.add(userFees[i][1]);\\n        }\\n\\n        // And convert totalFees to sUSD\\n        // Return totalRewards as is in SNX amount\\n        return (totalFees, totalRewards);\\n    }\\n\\n    function _isFeesClaimableAndAnyRatesInvalid(address account) internal view returns (bool, bool) {\\n        // Threshold is calculated from ratio % above the target ratio (issuanceRatio).\\n        //  0  <  10%:   Claimable\\n        // 10% > above:  Unable to claim\\n        (uint ratio, bool anyRateIsInvalid) = issuer().collateralisationRatioAndAnyRatesInvalid(account);\\n        uint targetRatio = getIssuanceRatio();\\n\\n        // Claimable if collateral ratio below target ratio\\n        if (ratio < targetRatio) {\\n            return (true, anyRateIsInvalid);\\n        }\\n\\n        // Calculate the threshold for collateral ratio before fees can't be claimed.\\n        uint ratio_threshold = targetRatio.multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\\n\\n        // Not claimable if collateral ratio above threshold\\n        if (ratio > ratio_threshold) {\\n            return (false, anyRateIsInvalid);\\n        }\\n\\n        return (true, anyRateIsInvalid);\\n    }\\n\\n    function isFeesClaimable(address account) external view returns (bool feesClaimable) {\\n        (feesClaimable, ) = _isFeesClaimableAndAnyRatesInvalid(account);\\n    }\\n\\n    /**\\n     * @notice Calculates fees by period for an account, priced in sUSD\\n     * @param account The address you want to query the fees for\\n     */\\n    function feesByPeriod(address account) public view returns (uint[2][FEE_PERIOD_LENGTH] memory results) {\\n        // What's the user's debt entry index and the debt they owe to the system at current feePeriod\\n        uint userOwnershipPercentage;\\n        uint debtEntryIndex;\\n        FeePoolState _feePoolState = feePoolState();\\n\\n        (userOwnershipPercentage, debtEntryIndex) = _feePoolState.getAccountsDebtEntry(account, 0);\\n\\n        // If they don't have any debt ownership and they never minted, they don't have any fees.\\n        // User ownership can reduce to 0 if user burns all synths,\\n        // however they could have fees applicable for periods they had minted in before so we check debtEntryIndex.\\n        if (debtEntryIndex == 0 && userOwnershipPercentage == 0) {\\n            uint[2][FEE_PERIOD_LENGTH] memory nullResults;\\n            return nullResults;\\n        }\\n\\n        // The [0] fee period is not yet ready to claim, but it is a fee period that they can have\\n        // fees owing for, so we need to report on it anyway.\\n        uint feesFromPeriod;\\n        uint rewardsFromPeriod;\\n        (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(0, userOwnershipPercentage, debtEntryIndex);\\n\\n        results[0][0] = feesFromPeriod;\\n        results[0][1] = rewardsFromPeriod;\\n\\n        // Retrieve user's last fee claim by periodId\\n        uint lastFeeWithdrawal = getLastFeeWithdrawal(account);\\n\\n        // Go through our fee periods from the oldest feePeriod[FEE_PERIOD_LENGTH - 1] and figure out what we owe them.\\n        // Condition checks for periods > 0\\n        for (uint i = FEE_PERIOD_LENGTH - 1; i > 0; i--) {\\n            uint next = i - 1;\\n            uint nextPeriodStartingDebtIndex = _recentFeePeriodsStorage(next).startingDebtIndex;\\n\\n            // We can skip the period, as no debt minted during period (next period's startingDebtIndex is still 0)\\n            if (nextPeriodStartingDebtIndex > 0 && lastFeeWithdrawal < _recentFeePeriodsStorage(i).feePeriodId) {\\n                // We calculate a feePeriod's closingDebtIndex by looking at the next feePeriod's startingDebtIndex\\n                // we can use the most recent issuanceData[0] for the current feePeriod\\n                // else find the applicableIssuanceData for the feePeriod based on the StartingDebtIndex of the period\\n                uint closingDebtIndex = uint256(nextPeriodStartingDebtIndex).sub(1);\\n\\n                // Gas optimisation - to reuse debtEntryIndex if found new applicable one\\n                // if applicable is 0,0 (none found) we keep most recent one from issuanceData[0]\\n                // return if userOwnershipPercentage = 0)\\n                (userOwnershipPercentage, debtEntryIndex) = _feePoolState.applicableIssuanceData(account, closingDebtIndex);\\n\\n                (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(i, userOwnershipPercentage, debtEntryIndex);\\n\\n                results[i][0] = feesFromPeriod;\\n                results[i][1] = rewardsFromPeriod;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice ownershipPercentage is a high precision decimals uint based on\\n     * wallet's debtPercentage. Gives a precise amount of the feesToDistribute\\n     * for fees in the period. Precision factor is removed before results are\\n     * returned.\\n     * @dev The reported fees owing for the current period [0] are just a\\n     * running balance until the fee period closes\\n     */\\n    function _feesAndRewardsFromPeriod(\\n        uint period,\\n        uint ownershipPercentage,\\n        uint debtEntryIndex\\n    ) internal view returns (uint, uint) {\\n        // If it's zero, they haven't issued, and they have no fees OR rewards.\\n        if (ownershipPercentage == 0) return (0, 0);\\n\\n        uint debtOwnershipForPeriod = ownershipPercentage;\\n\\n        // If period has closed we want to calculate debtPercentage for the period\\n        if (period > 0) {\\n            uint closingDebtIndex = uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex).sub(1);\\n            debtOwnershipForPeriod = _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\\n        }\\n\\n        // Calculate their percentage of the fees / rewards in this period\\n        // This is a high precision integer.\\n        uint feesFromPeriod = _recentFeePeriodsStorage(period).feesToDistribute.multiplyDecimal(debtOwnershipForPeriod);\\n\\n        uint rewardsFromPeriod =\\n            _recentFeePeriodsStorage(period).rewardsToDistribute.multiplyDecimal(debtOwnershipForPeriod);\\n\\n        return (feesFromPeriod.preciseDecimalToDecimal(), rewardsFromPeriod.preciseDecimalToDecimal());\\n    }\\n\\n    function _effectiveDebtRatioForPeriod(\\n        uint closingDebtIndex,\\n        uint ownershipPercentage,\\n        uint debtEntryIndex\\n    ) internal view returns (uint) {\\n        // Figure out their global debt percentage delta at end of fee Period.\\n        // This is a high precision integer.\\n        ISynthetixState _synthetixState = synthetixState();\\n        uint feePeriodDebtOwnership =\\n            _synthetixState\\n                .debtLedger(closingDebtIndex)\\n                .divideDecimalRoundPrecise(_synthetixState.debtLedger(debtEntryIndex))\\n                .multiplyDecimalRoundPrecise(ownershipPercentage);\\n\\n        return feePeriodDebtOwnership;\\n    }\\n\\n    function effectiveDebtRatioForPeriod(address account, uint period) external view returns (uint) {\\n        require(period != 0, \\\"Current period is not closed yet\\\");\\n        require(period < FEE_PERIOD_LENGTH, \\\"Exceeds the FEE_PERIOD_LENGTH\\\");\\n\\n        // If the period being checked is uninitialised then return 0. This is only at the start of the system.\\n        if (_recentFeePeriodsStorage(period - 1).startingDebtIndex == 0) return 0;\\n\\n        uint closingDebtIndex = uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex).sub(1);\\n\\n        uint ownershipPercentage;\\n        uint debtEntryIndex;\\n        (ownershipPercentage, debtEntryIndex) = feePoolState().applicableIssuanceData(account, closingDebtIndex);\\n\\n        // internal function will check closingDebtIndex has corresponding debtLedger entry\\n        return _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\\n    }\\n\\n    /**\\n     * @notice Get the feePeriodID of the last claim this account made\\n     * @param _claimingAddress account to check the last fee period ID claim for\\n     * @return uint of the feePeriodID this account last claimed\\n     */\\n    function getLastFeeWithdrawal(address _claimingAddress) public view returns (uint) {\\n        return feePoolEternalStorage().getUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)));\\n    }\\n\\n    /**\\n     * @notice Calculate the collateral ratio before user is blocked from claiming.\\n     */\\n    function getPenaltyThresholdRatio() public view returns (uint) {\\n        return getIssuanceRatio().multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\\n    }\\n\\n    /**\\n     * @notice Set the feePeriodID of the last claim this account made\\n     * @param _claimingAddress account to set the last feePeriodID claim for\\n     * @param _feePeriodID the feePeriodID this account claimed fees for\\n     */\\n    function _setLastFeeWithdrawal(address _claimingAddress, uint _feePeriodID) internal {\\n        feePoolEternalStorage().setUIntValue(\\n            keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)),\\n            _feePeriodID\\n        );\\n    }\\n\\n    /* ========== Modifiers ========== */\\n    modifier onlyInternalContracts {\\n        bool isExchanger = msg.sender == address(exchanger());\\n        bool isSynth = issuer().synthsByAddress(msg.sender) != bytes32(0);\\n        bool isCollateral = collateralManager().hasCollateral(msg.sender);\\n        bool isEtherWrapper = msg.sender == address(etherWrapper());\\n\\n        require(isExchanger || isSynth || isCollateral || isEtherWrapper, \\\"Only Internal Contracts\\\");\\n        _;\\n    }\\n\\n    modifier onlyIssuerAndSynthetixState {\\n        bool isIssuer = msg.sender == address(issuer());\\n        bool isSynthetixState = msg.sender == address(synthetixState());\\n        require(isIssuer || isSynthetixState, \\\"Issuer and SynthetixState only\\\");\\n        _;\\n    }\\n\\n    modifier notFeeAddress(address account) {\\n        require(account != FEE_ADDRESS, \\\"Fee address not allowed\\\");\\n        _;\\n    }\\n\\n    modifier issuanceActive() {\\n        systemStatus().requireIssuanceActive();\\n        _;\\n    }\\n\\n    /* ========== Proxy Events ========== */\\n\\n    event IssuanceDebtRatioEntry(\\n        address indexed account,\\n        uint debtRatio,\\n        uint debtEntryIndex,\\n        uint feePeriodStartingDebtIndex\\n    );\\n    bytes32 private constant ISSUANCEDEBTRATIOENTRY_SIG =\\n        keccak256(\\\"IssuanceDebtRatioEntry(address,uint256,uint256,uint256)\\\");\\n\\n    function emitIssuanceDebtRatioEntry(\\n        address account,\\n        uint debtRatio,\\n        uint debtEntryIndex,\\n        uint feePeriodStartingDebtIndex\\n    ) internal {\\n        proxy._emit(\\n            abi.encode(debtRatio, debtEntryIndex, feePeriodStartingDebtIndex),\\n            2,\\n            ISSUANCEDEBTRATIOENTRY_SIG,\\n            bytes32(uint256(uint160(account))),\\n            0,\\n            0\\n        );\\n    }\\n\\n    event FeePeriodClosed(uint feePeriodId);\\n    bytes32 private constant FEEPERIODCLOSED_SIG = keccak256(\\\"FeePeriodClosed(uint256)\\\");\\n\\n    function emitFeePeriodClosed(uint feePeriodId) internal {\\n        proxy._emit(abi.encode(feePeriodId), 1, FEEPERIODCLOSED_SIG, 0, 0, 0);\\n    }\\n\\n    event FeesClaimed(address account, uint sUSDAmount, uint snxRewards);\\n    bytes32 private constant FEESCLAIMED_SIG = keccak256(\\\"FeesClaimed(address,uint256,uint256)\\\");\\n\\n    function emitFeesClaimed(\\n        address account,\\n        uint sUSDAmount,\\n        uint snxRewards\\n    ) internal {\\n        proxy._emit(abi.encode(account, sUSDAmount, snxRewards), 1, FEESCLAIMED_SIG, 0, 0, 0);\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/tokenstate\\ncontract TokenState is Owned, State {\\n    /* ERC20 fields. */\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice Set ERC20 allowance.\\n     * @dev Only the associated contract may call this.\\n     * @param tokenOwner The authorising party.\\n     * @param spender The authorised party.\\n     * @param value The total value the authorised party may spend on the\\n     * authorising party's behalf.\\n     */\\n    function setAllowance(\\n        address tokenOwner,\\n        address spender,\\n        uint value\\n    ) external onlyAssociatedContract {\\n        allowance[tokenOwner][spender] = value;\\n    }\\n\\n    /**\\n     * @notice Set the balance in a given account\\n     * @dev Only the associated contract may call this.\\n     * @param account The account whose value to set.\\n     * @param value The new balance of the given account.\\n     */\\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\\n        balanceOf[account] = value;\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/externstatetoken\\ncontract ExternStateToken is Owned, Proxyable {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /* Stores balances and allowances. */\\n    TokenState public tokenState;\\n\\n    /* Other ERC20 fields. */\\n    string public name;\\n    string public symbol;\\n    uint public totalSupply;\\n    uint8 public decimals;\\n\\n    constructor(\\n        address payable _proxy,\\n        TokenState _tokenState,\\n        string memory _name,\\n        string memory _symbol,\\n        uint _totalSupply,\\n        uint8 _decimals,\\n        address _owner\\n    ) public Owned(_owner) Proxyable(_proxy) {\\n        tokenState = _tokenState;\\n\\n        name = _name;\\n        symbol = _symbol;\\n        totalSupply = _totalSupply;\\n        decimals = _decimals;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\\n     * @param owner The party authorising spending of their funds.\\n     * @param spender The party spending tokenOwner's funds.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint) {\\n        return tokenState.allowance(owner, spender);\\n    }\\n\\n    /**\\n     * @notice Returns the ERC20 token balance of a given account.\\n     */\\n    function balanceOf(address account) external view returns (uint) {\\n        return tokenState.balanceOf(account);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Set the address of the TokenState contract.\\n     * @dev This can be used to \\\"pause\\\" transfer functionality, by pointing the tokenState at 0x000..\\n     * as balances would be unreachable.\\n     */\\n    function setTokenState(TokenState _tokenState) external optionalProxy_onlyOwner {\\n        tokenState = _tokenState;\\n        emitTokenStateUpdated(address(_tokenState));\\n    }\\n\\n    function _internalTransfer(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        /* Disallow transfers to irretrievable-addresses. */\\n        require(to != address(0) && to != address(this) && to != address(proxy), \\\"Cannot transfer to this address\\\");\\n\\n        // Insufficient balance will be handled by the safe subtraction.\\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\\n\\n        // Emit a standard ERC20 transfer event\\n        emitTransfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\\n     * the onlyProxy or optionalProxy modifiers.\\n     */\\n    function _transferByProxy(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        return _internalTransfer(from, to, value);\\n    }\\n\\n    /*\\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\\n     * possessing the optionalProxy or optionalProxy modifiers.\\n     */\\n    function _transferFromByProxy(\\n        address sender,\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        /* Insufficient allowance will be handled by the safe subtraction. */\\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\\n        return _internalTransfer(from, to, value);\\n    }\\n\\n    /**\\n     * @notice Approves spender to transfer on the message sender's behalf.\\n     */\\n    function approve(address spender, uint value) public optionalProxy returns (bool) {\\n        address sender = messageSender;\\n\\n        tokenState.setAllowance(sender, spender, value);\\n        emitApproval(sender, spender, value);\\n        return true;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    function addressToBytes32(address input) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(input)));\\n    }\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    bytes32 internal constant TRANSFER_SIG = keccak256(\\\"Transfer(address,address,uint256)\\\");\\n\\n    function emitTransfer(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal {\\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);\\n    }\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    bytes32 internal constant APPROVAL_SIG = keccak256(\\\"Approval(address,address,uint256)\\\");\\n\\n    function emitApproval(\\n        address owner,\\n        address spender,\\n        uint value\\n    ) internal {\\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);\\n    }\\n\\n    event TokenStateUpdated(address newTokenState);\\n    bytes32 internal constant TOKENSTATEUPDATED_SIG = keccak256(\\\"TokenStateUpdated(address)\\\");\\n\\n    function emitTokenStateUpdated(address newTokenState) internal {\\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/synth\\ncontract Synth is Owned, IERC20, ExternStateToken, MixinResolver, ISynth {\\n    bytes32 public constant CONTRACT_NAME = \\\"Synth\\\";\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // Currency key which identifies this Synth to the Synthetix system\\n    bytes32 public currencyKey;\\n\\n    uint8 public constant DECIMALS = 18;\\n\\n    // Where fees are pooled in sUSD\\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\\n\\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\\n\\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \\\"SystemStatus\\\";\\n    bytes32 private constant CONTRACT_EXCHANGER = \\\"Exchanger\\\";\\n    bytes32 private constant CONTRACT_ISSUER = \\\"Issuer\\\";\\n    bytes32 private constant CONTRACT_FEEPOOL = \\\"FeePool\\\";\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address payable _proxy,\\n        TokenState _tokenState,\\n        string memory _tokenName,\\n        string memory _tokenSymbol,\\n        address _owner,\\n        bytes32 _currencyKey,\\n        uint _totalSupply,\\n        address _resolver\\n    )\\n        public\\n        ExternStateToken(_proxy, _tokenState, _tokenName, _tokenSymbol, _totalSupply, DECIMALS, _owner)\\n        MixinResolver(_resolver)\\n    {\\n        require(_proxy != address(0), \\\"_proxy cannot be 0\\\");\\n        require(_owner != address(0), \\\"_owner cannot be 0\\\");\\n\\n        currencyKey = _currencyKey;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function transfer(address to, uint value) public optionalProxy returns (bool) {\\n        _ensureCanTransfer(messageSender, value);\\n\\n        // transfers to FEE_ADDRESS will be exchanged into sUSD and recorded as fee\\n        if (to == FEE_ADDRESS) {\\n            return _transferToFeeAddress(to, value);\\n        }\\n\\n        // transfers to 0x address will be burned\\n        if (to == address(0)) {\\n            return _internalBurn(messageSender, value);\\n        }\\n\\n        return super._internalTransfer(messageSender, to, value);\\n    }\\n\\n    function transferAndSettle(address to, uint value) public optionalProxy returns (bool) {\\n        // Exchanger.settle ensures synth is active\\n        (, , uint numEntriesSettled) = exchanger().settle(messageSender, currencyKey);\\n\\n        // Save gas instead of calling transferableSynths\\n        uint balanceAfter = value;\\n\\n        if (numEntriesSettled > 0) {\\n            balanceAfter = tokenState.balanceOf(messageSender);\\n        }\\n\\n        // Reduce the value to transfer if balance is insufficient after reclaimed\\n        value = value > balanceAfter ? balanceAfter : value;\\n\\n        return super._internalTransfer(messageSender, to, value);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) public optionalProxy returns (bool) {\\n        _ensureCanTransfer(from, value);\\n\\n        return _internalTransferFrom(from, to, value);\\n    }\\n\\n    function transferFromAndSettle(\\n        address from,\\n        address to,\\n        uint value\\n    ) public optionalProxy returns (bool) {\\n        // Exchanger.settle() ensures synth is active\\n        (, , uint numEntriesSettled) = exchanger().settle(from, currencyKey);\\n\\n        // Save gas instead of calling transferableSynths\\n        uint balanceAfter = value;\\n\\n        if (numEntriesSettled > 0) {\\n            balanceAfter = tokenState.balanceOf(from);\\n        }\\n\\n        // Reduce the value to transfer if balance is insufficient after reclaimed\\n        value = value >= balanceAfter ? balanceAfter : value;\\n\\n        return _internalTransferFrom(from, to, value);\\n    }\\n\\n    /**\\n     * @notice _transferToFeeAddress function\\n     * non-sUSD synths are exchanged into sUSD via synthInitiatedExchange\\n     * notify feePool to record amount as fee paid to feePool */\\n    function _transferToFeeAddress(address to, uint value) internal returns (bool) {\\n        uint amountInUSD;\\n\\n        // sUSD can be transferred to FEE_ADDRESS directly\\n        if (currencyKey == \\\"sUSD\\\") {\\n            amountInUSD = value;\\n            super._internalTransfer(messageSender, to, value);\\n        } else {\\n            // else exchange synth into sUSD and send to FEE_ADDRESS\\n            (amountInUSD, ) = exchanger().exchange(\\n                messageSender,\\n                messageSender,\\n                currencyKey,\\n                value,\\n                \\\"sUSD\\\",\\n                FEE_ADDRESS,\\n                false,\\n                address(0),\\n                bytes32(0)\\n            );\\n        }\\n\\n        // Notify feePool to record sUSD to distribute as fees\\n        feePool().recordFeePaid(amountInUSD);\\n\\n        return true;\\n    }\\n\\n    function issue(address account, uint amount) external onlyInternalContracts {\\n        _internalIssue(account, amount);\\n    }\\n\\n    function burn(address account, uint amount) external onlyInternalContracts {\\n        _internalBurn(account, amount);\\n    }\\n\\n    function _internalIssue(address account, uint amount) internal {\\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\\n        totalSupply = totalSupply.add(amount);\\n        emitTransfer(address(0), account, amount);\\n        emitIssued(account, amount);\\n    }\\n\\n    function _internalBurn(address account, uint amount) internal returns (bool) {\\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\\n        totalSupply = totalSupply.sub(amount);\\n        emitTransfer(account, address(0), amount);\\n        emitBurned(account, amount);\\n\\n        return true;\\n    }\\n\\n    // Allow owner to set the total supply on import.\\n    function setTotalSupply(uint amount) external optionalProxy_onlyOwner {\\n        totalSupply = amount;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    // Note: use public visibility so that it can be invoked in a subclass\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        addresses = new bytes32[](4);\\n        addresses[0] = CONTRACT_SYSTEMSTATUS;\\n        addresses[1] = CONTRACT_EXCHANGER;\\n        addresses[2] = CONTRACT_ISSUER;\\n        addresses[3] = CONTRACT_FEEPOOL;\\n    }\\n\\n    function systemStatus() internal view returns (ISystemStatus) {\\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\\n    }\\n\\n    function feePool() internal view returns (IFeePool) {\\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\\n    }\\n\\n    function exchanger() internal view returns (IExchanger) {\\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\\n    }\\n\\n    function issuer() internal view returns (IIssuer) {\\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\\n    }\\n\\n    function _ensureCanTransfer(address from, uint value) internal view {\\n        require(exchanger().maxSecsLeftInWaitingPeriod(from, currencyKey) == 0, \\\"Cannot transfer during waiting period\\\");\\n        require(transferableSynths(from) >= value, \\\"Insufficient balance after any settlement owing\\\");\\n        systemStatus().requireSynthActive(currencyKey);\\n    }\\n\\n    function transferableSynths(address account) public view returns (uint) {\\n        (uint reclaimAmount, , ) = exchanger().settlementOwing(account, currencyKey);\\n\\n        // Note: ignoring rebate amount here because a settle() is required in order to\\n        // allow the transfer to actually work\\n\\n        uint balance = tokenState.balanceOf(account);\\n\\n        if (reclaimAmount > balance) {\\n            return 0;\\n        } else {\\n            return balance.sub(reclaimAmount);\\n        }\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _internalTransferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        // Skip allowance update in case of infinite allowance\\n        if (tokenState.allowance(from, messageSender) != uint(-1)) {\\n            // Reduce the allowance by the amount we're transferring.\\n            // The safeSub call will handle an insufficient allowance.\\n            tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\\n        }\\n\\n        return super._internalTransfer(from, to, value);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyInternalContracts() {\\n        bool isFeePool = msg.sender == address(feePool());\\n        bool isExchanger = msg.sender == address(exchanger());\\n        bool isIssuer = msg.sender == address(issuer());\\n\\n        require(isFeePool || isExchanger || isIssuer, \\\"Only FeePool, Exchanger or Issuer contracts allowed\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    event Issued(address indexed account, uint value);\\n    bytes32 private constant ISSUED_SIG = keccak256(\\\"Issued(address,uint256)\\\");\\n\\n    function emitIssued(address account, uint value) internal {\\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);\\n    }\\n\\n    event Burned(address indexed account, uint value);\\n    bytes32 private constant BURNED_SIG = keccak256(\\\"Burned(address,uint256)\\\");\\n\\n    function emitBurned(address account, uint value) internal {\\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);\\n    }\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Internal references\\n\\n\\n// https://docs.synthetix.io/contracts/source/contracts/multicollateralsynth\\ncontract MultiCollateralSynth is Synth {\\n    bytes32 public constant CONTRACT_NAME = \\\"MultiCollateralSynth\\\";\\n\\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\\n\\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \\\"CollateralManager\\\";\\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \\\"EtherWrapper\\\";\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address payable _proxy,\\n        TokenState _tokenState,\\n        string memory _tokenName,\\n        string memory _tokenSymbol,\\n        address _owner,\\n        bytes32 _currencyKey,\\n        uint _totalSupply,\\n        address _resolver\\n    ) public Synth(_proxy, _tokenState, _tokenName, _tokenSymbol, _owner, _currencyKey, _totalSupply, _resolver) {}\\n\\n    /* ========== VIEWS ======================= */\\n\\n    function collateralManager() internal view returns (ICollateralManager) {\\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\\n    }\\n\\n    function etherWrapper() internal view returns (IEtherWrapper) {\\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\\n    }\\n\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();\\n        bytes32[] memory newAddresses = new bytes32[](2);\\n        newAddresses[0] = CONTRACT_COLLATERALMANAGER;\\n        newAddresses[1] = CONTRACT_ETHER_WRAPPER;\\n        addresses = combineArrays(existingAddresses, newAddresses);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Function that allows multi Collateral to issue a certain number of synths from an account.\\n     * @param account Account to issue synths to\\n     * @param amount Number of synths\\n     */\\n    function issue(address account, uint amount) external onlyInternalContracts {\\n        super._internalIssue(account, amount);\\n    }\\n\\n    /**\\n     * @notice Function that allows multi Collateral to burn a certain number of synths from an account.\\n     * @param account Account to burn synths from\\n     * @param amount Number of synths\\n     */\\n    function burn(address account, uint amount) external onlyInternalContracts {\\n        super._internalBurn(account, amount);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    // Contracts directly interacting with multiCollateralSynth to issue and burn\\n    modifier onlyInternalContracts() {\\n        bool isFeePool = msg.sender == address(feePool());\\n        bool isExchanger = msg.sender == address(exchanger());\\n        bool isIssuer = msg.sender == address(issuer());\\n        bool isEtherWrapper = msg.sender == address(etherWrapper());\\n        bool isMultiCollateral = collateralManager().hasCollateral(msg.sender);\\n\\n        require(\\n            isFeePool || isExchanger || isIssuer || isEtherWrapper || isMultiCollateral,\\n            \\\"Only FeePool, Exchanger, Issuer, MultiCollateral contracts allowed\\\"\\n        );\\n        _;\\n    }\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n    // Structs\\n    struct RateAndUpdatedTime {\\n        uint216 rate;\\n        uint40 time;\\n    }\\n\\n    struct InversePricing {\\n        uint entryPoint;\\n        uint upperLimit;\\n        uint lowerLimit;\\n        bool frozenAtUpperLimit;\\n        bool frozenAtLowerLimit;\\n    }\\n\\n    // Views\\n    function aggregators(bytes32 currencyKey) external view returns (address);\\n\\n    function aggregatorWarningFlags() external view returns (address);\\n\\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\\n\\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\\n\\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\\n\\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\\n\\n    function effectiveValue(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external view returns (uint value);\\n\\n    function effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        );\\n\\n    function effectiveValueAtRound(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external view returns (uint value);\\n\\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\\n\\n    function getLastRoundIdBeforeElapsedSecs(\\n        bytes32 currencyKey,\\n        uint startingRoundId,\\n        uint startingTimestamp,\\n        uint timediff\\n    ) external view returns (uint);\\n\\n    function inversePricing(bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint entryPoint,\\n            uint upperLimit,\\n            uint lowerLimit,\\n            bool frozenAtUpperLimit,\\n            bool frozenAtLowerLimit\\n        );\\n\\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\\n\\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\\n\\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n\\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\\n\\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateStalePeriod() external view returns (uint);\\n\\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\\n        external\\n        view\\n        returns (uint[] memory rates, uint[] memory times);\\n\\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\\n        external\\n        view\\n        returns (uint[] memory rates, bool anyRateInvalid);\\n\\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\\n\\n    // Mutative functions\\n    function freezeRate(bytes32 currencyKey) external;\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ihasbalance\\ninterface IHasBalance {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n}\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iliquidations\\ninterface ILiquidations {\\n    // Views\\n    function isOpenForLiquidation(address account) external view returns (bool);\\n\\n    function getLiquidationDeadlineForAccount(address account) external view returns (uint);\\n\\n    function isLiquidationDeadlinePassed(address account) external view returns (bool);\\n\\n    function liquidationDelay() external view returns (uint);\\n\\n    function liquidationRatio() external view returns (uint);\\n\\n    function liquidationPenalty() external view returns (uint);\\n\\n    function calculateAmountToFixCollateral(uint debtBalance, uint collateral) external view returns (uint);\\n\\n    // Mutative Functions\\n    function flagAccountForLiquidation(address account) external;\\n\\n    // Restricted: used internally to Synthetix\\n    function removeAccountInLiquidation(address account) external;\\n\\n    function checkAndRemoveAccountInLiquidation(address account) external;\\n}\\n\\n\\ninterface ISynthRedeemer {\\n    // Rate of redemption - 0 for none\\n    function redemptions(address synthProxy) external view returns (uint redeemRate);\\n\\n    // sUSD balance of deprecated token holder\\n    function balanceOf(IERC20 synthProxy, address account) external view returns (uint balanceOfInsUSD);\\n\\n    // Full sUSD supply of token\\n    function totalSupply(IERC20 synthProxy) external view returns (uint totalSupplyInsUSD);\\n\\n    function redeem(IERC20 synthProxy) external;\\n\\n    function redeemAll(IERC20[] calldata synthProxies) external;\\n\\n    function redeemPartial(IERC20 synthProxy, uint amountOfSynth) external;\\n\\n    // Restricted to Issuer\\n    function deprecate(IERC20 synthProxy, uint rateToRedeem) external;\\n}\\n\\n\\n// Inheritance\\n\\n\\n// Libraries\\n\\n\\n// Internal references\\n\\n\\ninterface IProxy {\\n    function target() external view returns (address);\\n}\\n\\ninterface IIssuerInternalDebtCache {\\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\\n\\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\\n\\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\\n\\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\\n\\n    function cacheInfo()\\n        external\\n        view\\n        returns (\\n            uint cachedDebt,\\n            uint timestamp,\\n            bool isInvalid,\\n            bool isStale\\n        );\\n}\\n\\n// https://docs.synthetix.io/contracts/source/contracts/issuer\\ncontract Issuer is Owned, MixinSystemSettings, IIssuer {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    bytes32 public constant CONTRACT_NAME = \\\"Issuer\\\";\\n\\n    // Available Synths which can be used with the system\\n    ISynth[] public availableSynths;\\n    mapping(bytes32 => ISynth) public synths;\\n    mapping(address => bytes32) public synthsByAddress;\\n\\n    /* ========== ENCODED NAMES ========== */\\n\\n    bytes32 internal constant sUSD = \\\"sUSD\\\";\\n    bytes32 internal constant sETH = \\\"sETH\\\";\\n    bytes32 internal constant SNX = \\\"SNX\\\";\\n\\n    // Flexible storage names\\n\\n    bytes32 internal constant LAST_ISSUE_EVENT = \\\"lastIssueEvent\\\";\\n\\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\\n\\n    bytes32 private constant CONTRACT_SYNTHETIX = \\\"Synthetix\\\";\\n    bytes32 private constant CONTRACT_EXCHANGER = \\\"Exchanger\\\";\\n    bytes32 private constant CONTRACT_EXRATES = \\\"ExchangeRates\\\";\\n    bytes32 private constant CONTRACT_SYNTHETIXSTATE = \\\"SynthetixState\\\";\\n    bytes32 private constant CONTRACT_FEEPOOL = \\\"FeePool\\\";\\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \\\"DelegateApprovals\\\";\\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \\\"CollateralManager\\\";\\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \\\"RewardEscrowV2\\\";\\n    bytes32 private constant CONTRACT_SYNTHETIXESCROW = \\\"SynthetixEscrow\\\";\\n    bytes32 private constant CONTRACT_LIQUIDATIONS = \\\"Liquidations\\\";\\n    bytes32 private constant CONTRACT_DEBTCACHE = \\\"DebtCache\\\";\\n    bytes32 private constant CONTRACT_SYNTHREDEEMER = \\\"SynthRedeemer\\\";\\n\\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\\n\\n    /* ========== VIEWS ========== */\\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\\n        bytes32[] memory newAddresses = new bytes32[](12);\\n        newAddresses[0] = CONTRACT_SYNTHETIX;\\n        newAddresses[1] = CONTRACT_EXCHANGER;\\n        newAddresses[2] = CONTRACT_EXRATES;\\n        newAddresses[3] = CONTRACT_SYNTHETIXSTATE;\\n        newAddresses[4] = CONTRACT_FEEPOOL;\\n        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;\\n        newAddresses[6] = CONTRACT_REWARDESCROW_V2;\\n        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;\\n        newAddresses[8] = CONTRACT_LIQUIDATIONS;\\n        newAddresses[9] = CONTRACT_DEBTCACHE;\\n        newAddresses[10] = CONTRACT_COLLATERALMANAGER;\\n        newAddresses[11] = CONTRACT_SYNTHREDEEMER;\\n        return combineArrays(existingAddresses, newAddresses);\\n    }\\n\\n    function synthetix() internal view returns (ISynthetix) {\\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\\n    }\\n\\n    function exchanger() internal view returns (IExchanger) {\\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\\n    }\\n\\n    function exchangeRates() internal view returns (IExchangeRates) {\\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\\n    }\\n\\n    function synthetixState() internal view returns (ISynthetixState) {\\n        return ISynthetixState(requireAndGetAddress(CONTRACT_SYNTHETIXSTATE));\\n    }\\n\\n    function feePool() internal view returns (IFeePool) {\\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\\n    }\\n\\n    function liquidations() internal view returns (ILiquidations) {\\n        return ILiquidations(requireAndGetAddress(CONTRACT_LIQUIDATIONS));\\n    }\\n\\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\\n    }\\n\\n    function collateralManager() internal view returns (ICollateralManager) {\\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\\n    }\\n\\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\\n    }\\n\\n    function synthetixEscrow() internal view returns (IHasBalance) {\\n        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));\\n    }\\n\\n    function debtCache() internal view returns (IIssuerInternalDebtCache) {\\n        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\\n    }\\n\\n    function synthRedeemer() internal view returns (ISynthRedeemer) {\\n        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));\\n    }\\n\\n    function issuanceRatio() external view returns (uint) {\\n        return getIssuanceRatio();\\n    }\\n\\n    function _availableCurrencyKeysWithOptionalSNX(bool withSNX) internal view returns (bytes32[] memory) {\\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length + (withSNX ? 1 : 0));\\n\\n        for (uint i = 0; i < availableSynths.length; i++) {\\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\\n        }\\n\\n        if (withSNX) {\\n            currencyKeys[availableSynths.length] = SNX;\\n        }\\n\\n        return currencyKeys;\\n    }\\n\\n    // Returns the total value of the debt pool in currency specified by `currencyKey`.\\n    // To return only the SNX-backed debt, set `excludeCollateral` to true.\\n    function _totalIssuedSynths(bytes32 currencyKey, bool excludeCollateral)\\n        internal\\n        view\\n        returns (uint totalIssued, bool anyRateIsInvalid)\\n    {\\n        (uint debt, , bool cacheIsInvalid, bool cacheIsStale) = debtCache().cacheInfo();\\n        anyRateIsInvalid = cacheIsInvalid || cacheIsStale;\\n\\n        IExchangeRates exRates = exchangeRates();\\n\\n        // Add total issued synths from non snx collateral back into the total if not excluded\\n        if (!excludeCollateral) {\\n            (uint nonSnxDebt, bool invalid) = debtCache().totalNonSnxBackedDebt();\\n            debt = debt.add(nonSnxDebt);\\n            anyRateIsInvalid = anyRateIsInvalid || invalid;\\n        }\\n\\n        if (currencyKey == sUSD) {\\n            return (debt, anyRateIsInvalid);\\n        }\\n\\n        (uint currencyRate, bool currencyRateInvalid) = exRates.rateAndInvalid(currencyKey);\\n        return (debt.divideDecimalRound(currencyRate), anyRateIsInvalid || currencyRateInvalid);\\n    }\\n\\n    function _debtBalanceOfAndTotalDebt(address _issuer, bytes32 currencyKey)\\n        internal\\n        view\\n        returns (\\n            uint debtBalance,\\n            uint totalSystemValue,\\n            bool anyRateIsInvalid\\n        )\\n    {\\n        ISynthetixState state = synthetixState();\\n\\n        // What was their initial debt ownership?\\n        (uint initialDebtOwnership, uint debtEntryIndex) = state.issuanceData(_issuer);\\n\\n        // What's the total value of the system excluding ETH backed synths in their requested currency?\\n        (totalSystemValue, anyRateIsInvalid) = _totalIssuedSynths(currencyKey, true);\\n\\n        // If it's zero, they haven't issued, and they have no debt.\\n        // Note: it's more gas intensive to put this check here rather than before _totalIssuedSynths\\n        // if they have 0 SNX, but it's a necessary trade-off\\n        if (initialDebtOwnership == 0) return (0, totalSystemValue, anyRateIsInvalid);\\n\\n        // Figure out the global debt percentage delta from when they entered the system.\\n        // This is a high precision integer of 27 (1e27) decimals.\\n        uint currentDebtOwnership =\\n            state\\n                .lastDebtLedgerEntry()\\n                .divideDecimalRoundPrecise(state.debtLedger(debtEntryIndex))\\n                .multiplyDecimalRoundPrecise(initialDebtOwnership);\\n\\n        // Their debt balance is their portion of the total system value.\\n        uint highPrecisionBalance =\\n            totalSystemValue.decimalToPreciseDecimal().multiplyDecimalRoundPrecise(currentDebtOwnership);\\n\\n        // Convert back into 18 decimals (1e18)\\n        debtBalance = highPrecisionBalance.preciseDecimalToDecimal();\\n    }\\n\\n    function _canBurnSynths(address account) internal view returns (bool) {\\n        return now >= _lastIssueEvent(account).add(getMinimumStakeTime());\\n    }\\n\\n    function _lastIssueEvent(address account) internal view returns (uint) {\\n        //  Get the timestamp of the last issue this account made\\n        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));\\n    }\\n\\n    function _remainingIssuableSynths(address _issuer)\\n        internal\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt,\\n            bool anyRateIsInvalid\\n        )\\n    {\\n        (alreadyIssued, totalSystemDebt, anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_issuer, sUSD);\\n        (uint issuable, bool isInvalid) = _maxIssuableSynths(_issuer);\\n        maxIssuable = issuable;\\n        anyRateIsInvalid = anyRateIsInvalid || isInvalid;\\n\\n        if (alreadyIssued >= maxIssuable) {\\n            maxIssuable = 0;\\n        } else {\\n            maxIssuable = maxIssuable.sub(alreadyIssued);\\n        }\\n    }\\n\\n    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {\\n        return amount.multiplyDecimalRound(snxRate);\\n    }\\n\\n    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {\\n        return amount.divideDecimalRound(snxRate);\\n    }\\n\\n    function _maxIssuableSynths(address _issuer) internal view returns (uint, bool) {\\n        // What is the value of their SNX balance in sUSD\\n        (uint snxRate, bool isInvalid) = exchangeRates().rateAndInvalid(SNX);\\n        uint destinationValue = _snxToUSD(_collateral(_issuer), snxRate);\\n\\n        // They're allowed to issue up to issuanceRatio of that value\\n        return (destinationValue.multiplyDecimal(getIssuanceRatio()), isInvalid);\\n    }\\n\\n    function _collateralisationRatio(address _issuer) internal view returns (uint, bool) {\\n        uint totalOwnedSynthetix = _collateral(_issuer);\\n\\n        (uint debtBalance, , bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_issuer, SNX);\\n\\n        // it's more gas intensive to put this check here if they have 0 SNX, but it complies with the interface\\n        if (totalOwnedSynthetix == 0) return (0, anyRateIsInvalid);\\n\\n        return (debtBalance.divideDecimalRound(totalOwnedSynthetix), anyRateIsInvalid);\\n    }\\n\\n    function _collateral(address account) internal view returns (uint) {\\n        uint balance = IERC20(address(synthetix())).balanceOf(account);\\n\\n        if (address(synthetixEscrow()) != address(0)) {\\n            balance = balance.add(synthetixEscrow().balanceOf(account));\\n        }\\n\\n        if (address(rewardEscrowV2()) != address(0)) {\\n            balance = balance.add(rewardEscrowV2().balanceOf(account));\\n        }\\n\\n        return balance;\\n    }\\n\\n    function minimumStakeTime() external view returns (uint) {\\n        return getMinimumStakeTime();\\n    }\\n\\n    function canBurnSynths(address account) external view returns (bool) {\\n        return _canBurnSynths(account);\\n    }\\n\\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\\n        return _availableCurrencyKeysWithOptionalSNX(false);\\n    }\\n\\n    function availableSynthCount() external view returns (uint) {\\n        return availableSynths.length;\\n    }\\n\\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid) {\\n        (, anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true));\\n    }\\n\\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint totalIssued) {\\n        (totalIssued, ) = _totalIssuedSynths(currencyKey, excludeOtherCollateral);\\n    }\\n\\n    function lastIssueEvent(address account) external view returns (uint) {\\n        return _lastIssueEvent(account);\\n    }\\n\\n    function collateralisationRatio(address _issuer) external view returns (uint cratio) {\\n        (cratio, ) = _collateralisationRatio(_issuer);\\n    }\\n\\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\\n        external\\n        view\\n        returns (uint cratio, bool anyRateIsInvalid)\\n    {\\n        return _collateralisationRatio(_issuer);\\n    }\\n\\n    function collateral(address account) external view returns (uint) {\\n        return _collateral(account);\\n    }\\n\\n    function debtBalanceOf(address _issuer, bytes32 currencyKey) external view returns (uint debtBalance) {\\n        ISynthetixState state = synthetixState();\\n\\n        // What was their initial debt ownership?\\n        (uint initialDebtOwnership, ) = state.issuanceData(_issuer);\\n\\n        // If it's zero, they haven't issued, and they have no debt.\\n        if (initialDebtOwnership == 0) return 0;\\n\\n        (debtBalance, , ) = _debtBalanceOfAndTotalDebt(_issuer, currencyKey);\\n    }\\n\\n    function remainingIssuableSynths(address _issuer)\\n        external\\n        view\\n        returns (\\n            uint maxIssuable,\\n            uint alreadyIssued,\\n            uint totalSystemDebt\\n        )\\n    {\\n        (maxIssuable, alreadyIssued, totalSystemDebt, ) = _remainingIssuableSynths(_issuer);\\n    }\\n\\n    function maxIssuableSynths(address _issuer) external view returns (uint) {\\n        (uint maxIssuable, ) = _maxIssuableSynths(_issuer);\\n        return maxIssuable;\\n    }\\n\\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\\n        external\\n        view\\n        returns (uint transferable, bool anyRateIsInvalid)\\n    {\\n        // How many SNX do they have, excluding escrow?\\n        // Note: We're excluding escrow here because we're interested in their transferable amount\\n        // and escrowed SNX are not transferable.\\n\\n        // How many of those will be locked by the amount they've issued?\\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\\n        // The locked synthetix value can exceed their balance.\\n        uint debtBalance;\\n        (debtBalance, , anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(account, SNX);\\n        uint lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio());\\n\\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\\n        if (lockedSynthetixValue >= balance) {\\n            transferable = 0;\\n        } else {\\n            transferable = balance.sub(lockedSynthetixValue);\\n        }\\n    }\\n\\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory) {\\n        uint numKeys = currencyKeys.length;\\n        ISynth[] memory addresses = new ISynth[](numKeys);\\n\\n        for (uint i = 0; i < numKeys; i++) {\\n            addresses[i] = synths[currencyKeys[i]];\\n        }\\n\\n        return addresses;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function _addSynth(ISynth synth) internal {\\n        bytes32 currencyKey = synth.currencyKey();\\n        require(synths[currencyKey] == ISynth(0), \\\"Synth exists\\\");\\n        require(synthsByAddress[address(synth)] == bytes32(0), \\\"Synth address already exists\\\");\\n\\n        availableSynths.push(synth);\\n        synths[currencyKey] = synth;\\n        synthsByAddress[address(synth)] = currencyKey;\\n\\n        emit SynthAdded(currencyKey, address(synth));\\n    }\\n\\n    function addSynth(ISynth synth) external onlyOwner {\\n        _addSynth(synth);\\n        // Invalidate the cache to force a snapshot to be recomputed. If a synth were to be added\\n        // back to the system and it still somehow had cached debt, this would force the value to be\\n        // updated.\\n        debtCache().updateDebtCacheValidity(true);\\n    }\\n\\n    function addSynths(ISynth[] calldata synthsToAdd) external onlyOwner {\\n        uint numSynths = synthsToAdd.length;\\n        for (uint i = 0; i < numSynths; i++) {\\n            _addSynth(synthsToAdd[i]);\\n        }\\n\\n        // Invalidate the cache to force a snapshot to be recomputed.\\n        debtCache().updateDebtCacheValidity(true);\\n    }\\n\\n    function _removeSynth(bytes32 currencyKey) internal {\\n        address synthToRemove = address(synths[currencyKey]);\\n        require(synthToRemove != address(0), \\\"Synth does not exist\\\");\\n        require(currencyKey != sUSD, \\\"Cannot remove synth\\\");\\n\\n        uint synthSupply = IERC20(synthToRemove).totalSupply();\\n\\n        if (synthSupply > 0) {\\n            (uint amountOfsUSD, uint rateToRedeem, ) =\\n                exchangeRates().effectiveValueAndRates(currencyKey, synthSupply, \\\"sUSD\\\");\\n            require(rateToRedeem > 0, \\\"Cannot remove synth to redeem without rate\\\");\\n            ISynthRedeemer _synthRedeemer = synthRedeemer();\\n            synths[sUSD].issue(address(_synthRedeemer), amountOfsUSD);\\n            // ensure the debt cache is aware of the new sUSD issued\\n            debtCache().updateCachedSynthDebtWithRate(sUSD, SafeDecimalMath.unit());\\n            _synthRedeemer.deprecate(IERC20(address(Proxyable(address(synthToRemove)).proxy())), rateToRedeem);\\n        }\\n\\n        // Remove the synth from the availableSynths array.\\n        for (uint i = 0; i < availableSynths.length; i++) {\\n            if (address(availableSynths[i]) == synthToRemove) {\\n                delete availableSynths[i];\\n\\n                // Copy the last synth into the place of the one we just deleted\\n                // If there's only one synth, this is synths[0] = synths[0].\\n                // If we're deleting the last one, it's also a NOOP in the same way.\\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\\n\\n                // Decrease the size of the array by one.\\n                availableSynths.length--;\\n\\n                break;\\n            }\\n        }\\n\\n        // And remove it from the synths mapping\\n        delete synthsByAddress[synthToRemove];\\n        delete synths[currencyKey];\\n\\n        emit SynthRemoved(currencyKey, synthToRemove);\\n    }\\n\\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\\n        // Remove its contribution from the debt pool snapshot, and\\n        // invalidate the cache to force a new snapshot.\\n        IIssuerInternalDebtCache cache = debtCache();\\n        cache.updateCachedSynthDebtWithRate(currencyKey, 0);\\n        cache.updateDebtCacheValidity(true);\\n\\n        _removeSynth(currencyKey);\\n    }\\n\\n    function removeSynths(bytes32[] calldata currencyKeys) external onlyOwner {\\n        uint numKeys = currencyKeys.length;\\n\\n        // Remove their contributions from the debt pool snapshot, and\\n        // invalidate the cache to force a new snapshot.\\n        IIssuerInternalDebtCache cache = debtCache();\\n        uint[] memory zeroRates = new uint[](numKeys);\\n        cache.updateCachedSynthDebtsWithRates(currencyKeys, zeroRates);\\n        cache.updateDebtCacheValidity(true);\\n\\n        for (uint i = 0; i < numKeys; i++) {\\n            _removeSynth(currencyKeys[i]);\\n        }\\n    }\\n\\n    function issueSynths(address from, uint amount) external onlySynthetix {\\n        _issueSynths(from, amount, false);\\n    }\\n\\n    function issueMaxSynths(address from) external onlySynthetix {\\n        _issueSynths(from, 0, true);\\n    }\\n\\n    function issueSynthsOnBehalf(\\n        address issueForAddress,\\n        address from,\\n        uint amount\\n    ) external onlySynthetix {\\n        _requireCanIssueOnBehalf(issueForAddress, from);\\n        _issueSynths(issueForAddress, amount, false);\\n    }\\n\\n    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {\\n        _requireCanIssueOnBehalf(issueForAddress, from);\\n        _issueSynths(issueForAddress, 0, true);\\n    }\\n\\n    function burnSynths(address from, uint amount) external onlySynthetix {\\n        _voluntaryBurnSynths(from, amount, false);\\n    }\\n\\n    function burnSynthsOnBehalf(\\n        address burnForAddress,\\n        address from,\\n        uint amount\\n    ) external onlySynthetix {\\n        _requireCanBurnOnBehalf(burnForAddress, from);\\n        _voluntaryBurnSynths(burnForAddress, amount, false);\\n    }\\n\\n    function burnSynthsToTarget(address from) external onlySynthetix {\\n        _voluntaryBurnSynths(from, 0, true);\\n    }\\n\\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {\\n        _requireCanBurnOnBehalf(burnForAddress, from);\\n        _voluntaryBurnSynths(burnForAddress, 0, true);\\n    }\\n\\n    function burnForRedemption(\\n        address deprecatedSynthProxy,\\n        address account,\\n        uint balance\\n    ) external onlySynthRedeemer {\\n        ISynth(IProxy(deprecatedSynthProxy).target()).burn(account, balance);\\n    }\\n\\n    function liquidateDelinquentAccount(\\n        address account,\\n        uint susdAmount,\\n        address liquidator\\n    ) external onlySynthetix returns (uint totalRedeemed, uint amountToLiquidate) {\\n        // Ensure waitingPeriod and sUSD balance is settled as burning impacts the size of debt pool\\n        require(!exchanger().hasWaitingPeriodOrSettlementOwing(liquidator, sUSD), \\\"sUSD needs to be settled\\\");\\n\\n        // Check account is liquidation open\\n        require(liquidations().isOpenForLiquidation(account), \\\"Account not open for liquidation\\\");\\n\\n        // require liquidator has enough sUSD\\n        require(IERC20(address(synths[sUSD])).balanceOf(liquidator) >= susdAmount, \\\"Not enough sUSD\\\");\\n\\n        uint liquidationPenalty = liquidations().liquidationPenalty();\\n\\n        // What is their debt in sUSD?\\n        (uint debtBalance, uint totalDebtIssued, bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(account, sUSD);\\n        (uint snxRate, bool snxRateInvalid) = exchangeRates().rateAndInvalid(SNX);\\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\\n\\n        uint collateralForAccount = _collateral(account);\\n        uint amountToFixRatio =\\n            liquidations().calculateAmountToFixCollateral(debtBalance, _snxToUSD(collateralForAccount, snxRate));\\n\\n        // Cap amount to liquidate to repair collateral ratio based on issuance ratio\\n        amountToLiquidate = amountToFixRatio < susdAmount ? amountToFixRatio : susdAmount;\\n\\n        // what's the equivalent amount of snx for the amountToLiquidate?\\n        uint snxRedeemed = _usdToSnx(amountToLiquidate, snxRate);\\n\\n        // Add penalty\\n        totalRedeemed = snxRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\\n\\n        // if total SNX to redeem is greater than account's collateral\\n        // account is under collateralised, liquidate all collateral and reduce sUSD to burn\\n        if (totalRedeemed > collateralForAccount) {\\n            // set totalRedeemed to all transferable collateral\\n            totalRedeemed = collateralForAccount;\\n\\n            // whats the equivalent sUSD to burn for all collateral less penalty\\n            amountToLiquidate = _snxToUSD(\\n                collateralForAccount.divideDecimal(SafeDecimalMath.unit().add(liquidationPenalty)),\\n                snxRate\\n            );\\n        }\\n\\n        // burn sUSD from messageSender (liquidator) and reduce account's debt\\n        _burnSynths(account, liquidator, amountToLiquidate, debtBalance, totalDebtIssued);\\n\\n        // Remove liquidation flag if amount liquidated fixes ratio\\n        if (amountToLiquidate == amountToFixRatio) {\\n            // Remove liquidation\\n            liquidations().removeAccountInLiquidation(account);\\n        }\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _requireRatesNotInvalid(bool anyRateIsInvalid) internal pure {\\n        require(!anyRateIsInvalid, \\\"A synth or SNX rate is invalid\\\");\\n    }\\n\\n    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {\\n        require(delegateApprovals().canIssueFor(issueForAddress, from), \\\"Not approved to act on behalf\\\");\\n    }\\n\\n    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {\\n        require(delegateApprovals().canBurnFor(burnForAddress, from), \\\"Not approved to act on behalf\\\");\\n    }\\n\\n    function _issueSynths(\\n        address from,\\n        uint amount,\\n        bool issueMax\\n    ) internal {\\n        (uint maxIssuable, uint existingDebt, uint totalSystemDebt, bool anyRateIsInvalid) = _remainingIssuableSynths(from);\\n        _requireRatesNotInvalid(anyRateIsInvalid);\\n\\n        if (!issueMax) {\\n            require(amount <= maxIssuable, \\\"Amount too large\\\");\\n        } else {\\n            amount = maxIssuable;\\n        }\\n\\n        // Keep track of the debt they're about to create\\n        _addToDebtRegister(from, amount, existingDebt, totalSystemDebt);\\n\\n        // record issue timestamp\\n        _setLastIssueEvent(from);\\n\\n        // Create their synths\\n        synths[sUSD].issue(from, amount);\\n\\n        // Account for the issued debt in the cache\\n        debtCache().updateCachedSynthDebtWithRate(sUSD, SafeDecimalMath.unit());\\n\\n        // Store their locked SNX amount to determine their fee % for the period\\n        _appendAccountIssuanceRecord(from);\\n    }\\n\\n    function _burnSynths(\\n        address debtAccount,\\n        address burnAccount,\\n        uint amount,\\n        uint existingDebt,\\n        uint totalDebtIssued\\n    ) internal returns (uint amountBurnt) {\\n        // liquidation requires sUSD to be already settled / not in waiting period\\n\\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\\n        // clear their debt and leave them be.\\n        amountBurnt = existingDebt < amount ? existingDebt : amount;\\n\\n        // Remove liquidated debt from the ledger\\n        _removeFromDebtRegister(debtAccount, amountBurnt, existingDebt, totalDebtIssued);\\n\\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\\n        synths[sUSD].burn(burnAccount, amountBurnt);\\n\\n        // Account for the burnt debt in the cache.\\n        debtCache().updateCachedSynthDebtWithRate(sUSD, SafeDecimalMath.unit());\\n\\n        // Store their debtRatio against a fee period to determine their fee/rewards % for the period\\n        _appendAccountIssuanceRecord(debtAccount);\\n    }\\n\\n    // If burning to target, `amount` is ignored, and the correct quantity of sUSD is burnt to reach the target\\n    // c-ratio, allowing fees to be claimed. In this case, pending settlements will be skipped as the user\\n    // will still have debt remaining after reaching their target.\\n    function _voluntaryBurnSynths(\\n        address from,\\n        uint amount,\\n        bool burnToTarget\\n    ) internal {\\n        if (!burnToTarget) {\\n            // If not burning to target, then burning requires that the minimum stake time has elapsed.\\n            require(_canBurnSynths(from), \\\"Minimum stake time not reached\\\");\\n            // First settle anything pending into sUSD as burning or issuing impacts the size of the debt pool\\n            (, uint refunded, uint numEntriesSettled) = exchanger().settle(from, sUSD);\\n            if (numEntriesSettled > 0) {\\n                amount = exchanger().calculateAmountAfterSettlement(from, sUSD, amount, refunded);\\n            }\\n        }\\n\\n        (uint existingDebt, uint totalSystemValue, bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(from, sUSD);\\n        (uint maxIssuableSynthsForAccount, bool snxRateInvalid) = _maxIssuableSynths(from);\\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\\n        require(existingDebt > 0, \\\"No debt to forgive\\\");\\n\\n        if (burnToTarget) {\\n            amount = existingDebt.sub(maxIssuableSynthsForAccount);\\n        }\\n\\n        uint amountBurnt = _burnSynths(from, from, amount, existingDebt, totalSystemValue);\\n\\n        // Check and remove liquidation if existingDebt after burning is <= maxIssuableSynths\\n        // Issuance ratio is fixed so should remove any liquidations\\n        if (existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount) {\\n            liquidations().removeAccountInLiquidation(from);\\n        }\\n    }\\n\\n    function _setLastIssueEvent(address account) internal {\\n        // Set the timestamp of the last issueSynths\\n        flexibleStorage().setUIntValue(\\n            CONTRACT_NAME,\\n            keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _appendAccountIssuanceRecord(address from) internal {\\n        uint initialDebtOwnership;\\n        uint debtEntryIndex;\\n        (initialDebtOwnership, debtEntryIndex) = synthetixState().issuanceData(from);\\n        feePool().appendAccountIssuanceRecord(from, initialDebtOwnership, debtEntryIndex);\\n    }\\n\\n    function _addToDebtRegister(\\n        address from,\\n        uint amount,\\n        uint existingDebt,\\n        uint totalDebtIssued\\n    ) internal {\\n        ISynthetixState state = synthetixState();\\n\\n        // What will the new total be including the new value?\\n        uint newTotalDebtIssued = amount.add(totalDebtIssued);\\n\\n        // What is their percentage (as a high precision int) of the total debt?\\n        uint debtPercentage = amount.divideDecimalRoundPrecise(newTotalDebtIssued);\\n\\n        // And what effect does this percentage change have on the global debt holding of other issuers?\\n        // The delta specifically needs to not take into account any existing debt as it's already\\n        // accounted for in the delta from when they issued previously.\\n        // The delta is a high precision integer.\\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\\n\\n        // And what does their debt ownership look like including this previous stake?\\n        if (existingDebt > 0) {\\n            debtPercentage = amount.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\\n        } else {\\n            // If they have no debt, they're a new issuer; record this.\\n            state.incrementTotalIssuerCount();\\n        }\\n\\n        // Save the debt entry parameters\\n        state.setCurrentIssuanceData(from, debtPercentage);\\n\\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\\n        if (state.debtLedgerLength() > 0) {\\n            state.appendDebtLedgerValue(state.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));\\n        } else {\\n            state.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());\\n        }\\n    }\\n\\n    function _removeFromDebtRegister(\\n        address from,\\n        uint debtToRemove,\\n        uint existingDebt,\\n        uint totalDebtIssued\\n    ) internal {\\n        ISynthetixState state = synthetixState();\\n\\n        // What will the new total after taking out the withdrawn amount\\n        uint newTotalDebtIssued = totalDebtIssued.sub(debtToRemove);\\n\\n        uint delta = 0;\\n\\n        // What will the debt delta be if there is any debt left?\\n        // Set delta to 0 if no more debt left in system after user\\n        if (newTotalDebtIssued > 0) {\\n            // What is the percentage of the withdrawn debt (as a high precision int) of the total debt after?\\n            uint debtPercentage = debtToRemove.divideDecimalRoundPrecise(newTotalDebtIssued);\\n\\n            // And what effect does this percentage change have on the global debt holding of other issuers?\\n            // The delta specifically needs to not take into account any existing debt as it's already\\n            // accounted for in the delta from when they issued previously.\\n            delta = SafeDecimalMath.preciseUnit().add(debtPercentage);\\n        }\\n\\n        // Are they exiting the system, or are they just decreasing their debt position?\\n        if (debtToRemove == existingDebt) {\\n            state.setCurrentIssuanceData(from, 0);\\n            state.decrementTotalIssuerCount();\\n        } else {\\n            // What percentage of the debt will they be left with?\\n            uint newDebt = existingDebt.sub(debtToRemove);\\n            uint newDebtPercentage = newDebt.divideDecimalRoundPrecise(newTotalDebtIssued);\\n\\n            // Store the debt percentage and debt ledger as high precision integers\\n            state.setCurrentIssuanceData(from, newDebtPercentage);\\n        }\\n\\n        // Update our cumulative ledger. This is also a high precision integer.\\n        state.appendDebtLedgerValue(state.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    function _onlySynthetix() internal view {\\n        require(msg.sender == address(synthetix()), \\\"Issuer: Only the synthetix contract can perform this action\\\");\\n    }\\n\\n    modifier onlySynthetix() {\\n        _onlySynthetix(); // Use an internal function to save code size.\\n        _;\\n    }\\n\\n    function _onlySynthRedeemer() internal view {\\n        require(msg.sender == address(synthRedeemer()), \\\"Issuer: Only the SynthRedeemer contract can perform this action\\\");\\n    }\\n\\n    modifier onlySynthRedeemer() {\\n        _onlySynthRedeemer();\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event SynthAdded(bytes32 currencyKey, address synth);\\n    event SynthRemoved(bytes32 currencyKey, address synth);\\n}\\n\\n\\ninterface ISynthetixNamedContract {\\n    // solhint-disable func-name-mixedcase\\n    function CONTRACT_NAME() external view returns (bytes32);\\n}\\n\\n// solhint-disable contract-name-camelcase\\ncontract Migration_Mirfak is BaseMigration {\\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\\n\\n    // ----------------------------\\n    // EXISTING SYNTHETIX CONTRACTS\\n    // ----------------------------\\n\\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\\n    // https://etherscan.io/address/0xb440DD674e1243644791a4AdfE3A2AbB0A92d309\\n    Proxy public constant proxyfeepool_i = Proxy(0xb440DD674e1243644791a4AdfE3A2AbB0A92d309);\\n    // https://etherscan.io/address/0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB\\n    FeePoolEternalStorage public constant feepooleternalstorage_i =\\n        FeePoolEternalStorage(0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB);\\n    // https://etherscan.io/address/0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02\\n    FeePoolState public constant feepoolstate_i = FeePoolState(0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02);\\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\\n    ProxyERC20 public constant proxyerc20_i = ProxyERC20(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\\n    // https://etherscan.io/address/0xC011A72400E58ecD99Ee497CF89E3775d4bd732F\\n    Proxy public constant proxysynthetix_i = Proxy(0xC011A72400E58ecD99Ee497CF89E3775d4bd732F);\\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\\n    // https://etherscan.io/address/0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E\\n    SystemStatus public constant systemstatus_i = SystemStatus(0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E);\\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\\n    // https://etherscan.io/address/0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82\\n    SynthetixState public constant synthetixstate_i = SynthetixState(0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82);\\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\\n    // https://etherscan.io/address/0x29C295B046a73Cde593f21f63091B072d407e3F2\\n    RewardsDistribution public constant rewardsdistribution_i =\\n        RewardsDistribution(0x29C295B046a73Cde593f21f63091B072d407e3F2);\\n    // https://etherscan.io/address/0x510adfDF6E7554C571b7Cd9305Ce91473610015e\\n    FeePool public constant feepool_i = FeePool(0x510adfDF6E7554C571b7Cd9305Ce91473610015e);\\n    // https://etherscan.io/address/0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b\\n    MultiCollateralSynth public constant synthsusd_i = MultiCollateralSynth(0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b);\\n    // https://etherscan.io/address/0x05a9CBe762B36632b3594DA4F082340E0e5343e8\\n    TokenState public constant tokenstatesusd_i = TokenState(0x05a9CBe762B36632b3594DA4F082340E0e5343e8);\\n    // https://etherscan.io/address/0x57Ab1E02fEE23774580C119740129eAC7081e9D3\\n    Proxy public constant proxysusd_i = Proxy(0x57Ab1E02fEE23774580C119740129eAC7081e9D3);\\n    // https://etherscan.io/address/0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\\n    ProxyERC20 public constant proxyerc20susd_i = ProxyERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\\n    // https://etherscan.io/address/0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9\\n    MultiCollateralSynth public constant synthsbtc_i = MultiCollateralSynth(0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9);\\n    // https://etherscan.io/address/0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67\\n    TokenState public constant tokenstatesbtc_i = TokenState(0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67);\\n    // https://etherscan.io/address/0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6\\n    ProxyERC20 public constant proxysbtc_i = ProxyERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\\n    // https://etherscan.io/address/0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6\\n    MultiCollateralSynth public constant synthseth_i = MultiCollateralSynth(0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6);\\n    // https://etherscan.io/address/0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c\\n    TokenState public constant tokenstateseth_i = TokenState(0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c);\\n    // https://etherscan.io/address/0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb\\n    ProxyERC20 public constant proxyseth_i = ProxyERC20(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb);\\n    // https://etherscan.io/address/0x922C84B3894298296C34842D866BfC0d36C54778\\n    Issuer public constant issuer_i = Issuer(0x922C84B3894298296C34842D866BfC0d36C54778);\\n\\n    // ----------------------------------\\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\\n    // ----------------------------------\\n\\n    // https://etherscan.io/address/0x510adfDF6E7554C571b7Cd9305Ce91473610015e\\n    address public constant new_FeePool_contract = 0x510adfDF6E7554C571b7Cd9305Ce91473610015e;\\n    // https://etherscan.io/address/0x54f25546260C7539088982bcF4b7dC8EDEF19f21\\n    address public constant new_Synthetix_contract = 0x54f25546260C7539088982bcF4b7dC8EDEF19f21;\\n    // https://etherscan.io/address/0x7634F2A1741a683ccda37Dce864c187F990D7B4b\\n    address public constant new_Exchanger_contract = 0x7634F2A1741a683ccda37Dce864c187F990D7B4b;\\n    // https://etherscan.io/address/0xe92B4c7428152052B0930c81F4c687a5F1A12292\\n    address public constant new_DebtCache_contract = 0xe92B4c7428152052B0930c81F4c687a5F1A12292;\\n    // https://etherscan.io/address/0x922C84B3894298296C34842D866BfC0d36C54778\\n    address public constant new_Issuer_contract = 0x922C84B3894298296C34842D866BfC0d36C54778;\\n    // https://etherscan.io/address/0xe533139Af961c9747356D947838c98451015e234\\n    address public constant new_SynthRedeemer_contract = 0xe533139Af961c9747356D947838c98451015e234;\\n    // https://etherscan.io/address/0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b\\n    address public constant new_SynthsUSD_contract = 0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b;\\n    // https://etherscan.io/address/0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9\\n    address public constant new_SynthsBTC_contract = 0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9;\\n    // https://etherscan.io/address/0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6\\n    address public constant new_SynthsETH_contract = 0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6;\\n\\n    constructor() public BaseMigration(OWNER) {}\\n\\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\\n        contracts = new address[](24);\\n        contracts[0] = address(addressresolver_i);\\n        contracts[1] = address(proxyfeepool_i);\\n        contracts[2] = address(feepooleternalstorage_i);\\n        contracts[3] = address(feepoolstate_i);\\n        contracts[4] = address(proxyerc20_i);\\n        contracts[5] = address(proxysynthetix_i);\\n        contracts[6] = address(exchangestate_i);\\n        contracts[7] = address(systemstatus_i);\\n        contracts[8] = address(tokenstatesynthetix_i);\\n        contracts[9] = address(synthetixstate_i);\\n        contracts[10] = address(rewardescrow_i);\\n        contracts[11] = address(rewardsdistribution_i);\\n        contracts[12] = address(feepool_i);\\n        contracts[13] = address(synthsusd_i);\\n        contracts[14] = address(tokenstatesusd_i);\\n        contracts[15] = address(proxysusd_i);\\n        contracts[16] = address(proxyerc20susd_i);\\n        contracts[17] = address(synthsbtc_i);\\n        contracts[18] = address(tokenstatesbtc_i);\\n        contracts[19] = address(proxysbtc_i);\\n        contracts[20] = address(synthseth_i);\\n        contracts[21] = address(tokenstateseth_i);\\n        contracts[22] = address(proxyseth_i);\\n        contracts[23] = address(issuer_i);\\n    }\\n\\n    function migrate(address currentOwner) external onlyDeployer {\\n        require(owner == currentOwner, \\\"Only the assigned owner can be re-assigned when complete\\\");\\n\\n        require(\\n            ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == \\\"FeePool\\\",\\n            \\\"Invalid contract supplied for FeePool\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == \\\"Synthetix\\\",\\n            \\\"Invalid contract supplied for Synthetix\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == \\\"ExchangerWithVirtualSynth\\\",\\n            \\\"Invalid contract supplied for Exchanger\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_DebtCache_contract).CONTRACT_NAME() == \\\"DebtCache\\\",\\n            \\\"Invalid contract supplied for DebtCache\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == \\\"Issuer\\\",\\n            \\\"Invalid contract supplied for Issuer\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_SynthRedeemer_contract).CONTRACT_NAME() == \\\"SynthRedeemer\\\",\\n            \\\"Invalid contract supplied for SynthRedeemer\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_SynthsUSD_contract).CONTRACT_NAME() == \\\"MultiCollateralSynth\\\",\\n            \\\"Invalid contract supplied for SynthsUSD\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_SynthsBTC_contract).CONTRACT_NAME() == \\\"MultiCollateralSynth\\\",\\n            \\\"Invalid contract supplied for SynthsBTC\\\"\\n        );\\n        require(\\n            ISynthetixNamedContract(new_SynthsETH_contract).CONTRACT_NAME() == \\\"MultiCollateralSynth\\\",\\n            \\\"Invalid contract supplied for SynthsETH\\\"\\n        );\\n\\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\\n        acceptAll();\\n\\n        // MIGRATION\\n        // Import all new contracts into the address resolver;\\n        addressresolver_importAddresses_0();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\\n        addressresolver_rebuildCaches_1();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\\n        addressresolver_rebuildCaches_2();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 3;\\n        addressresolver_rebuildCaches_3();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 4;\\n        addressresolver_rebuildCaches_4();\\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 5;\\n        addressresolver_rebuildCaches_5();\\n        // Ensure the ProxyFeePool contract has the correct FeePool target set;\\n        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));\\n        // Ensure the FeePool contract can write to its EternalStorage;\\n        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);\\n        // Ensure the FeePool contract can write to its State;\\n        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));\\n        // Ensure the SNX proxy has the correct Synthetix target set;\\n        proxyerc20_i.setTarget(Proxyable(new_Synthetix_contract));\\n        // Ensure the legacy SNX proxy has the correct Synthetix target set;\\n        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));\\n        // Ensure the Exchanger contract can write to its State;\\n        exchangestate_i.setAssociatedContract(new_Exchanger_contract);\\n        // Ensure the Exchanger contract can suspend synths - see SIP-65;\\n        systemstatus_i.updateAccessControl(\\\"Synth\\\", new_Exchanger_contract, true, false);\\n        // Ensure the Synthetix contract can write to its TokenState contract;\\n        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);\\n        // Ensure that Synthetix can write to its State contract;\\n        synthetixstate_i.setAssociatedContract(new_Issuer_contract);\\n        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;\\n        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));\\n        // Ensure the legacy RewardEscrow contract is connected to the FeePool contract;\\n        rewardescrow_i.setFeePool(IFeePool(new_FeePool_contract));\\n        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;\\n        rewardsdistribution_i.setAuthority(new_Synthetix_contract);\\n        // Import fee period from existing fee pool at index 0;\\n        importFeePeriod_0();\\n        // Import fee period from existing fee pool at index 1;\\n        importFeePeriod_1();\\n        // Ensure the new synth has the totalSupply from the previous one;\\n        copyTotalSupplyFrom_sUSD();\\n        // Ensure the sUSD synth can write to its TokenState;\\n        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);\\n        // Ensure the sUSD synth Proxy is correctly connected to the Synth;\\n        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));\\n        // Ensure the special ERC20 proxy for sUSD has its target set to the Synth;\\n        proxyerc20susd_i.setTarget(Proxyable(new_SynthsUSD_contract));\\n        // Ensure the new synth has the totalSupply from the previous one;\\n        copyTotalSupplyFrom_sBTC();\\n        // Ensure the sBTC synth can write to its TokenState;\\n        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);\\n        // Ensure the sBTC synth Proxy is correctly connected to the Synth;\\n        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));\\n        // Ensure the new synth has the totalSupply from the previous one;\\n        copyTotalSupplyFrom_sETH();\\n        // Ensure the sETH synth can write to its TokenState;\\n        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);\\n        // Ensure the sETH synth Proxy is correctly connected to the Synth;\\n        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));\\n        // Add synths to the Issuer contract - batch 1;\\n        issuer_addSynths_39();\\n        // Add synths to the Issuer contract - batch 2;\\n        issuer_addSynths_40();\\n        // Add synths to the Issuer contract - batch 3;\\n        issuer_addSynths_41();\\n        // Add synths to the Issuer contract - batch 4;\\n        issuer_addSynths_42();\\n        // Add synths to the Issuer contract - batch 5;\\n        issuer_addSynths_43();\\n\\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\\n        nominateAll();\\n    }\\n\\n    function acceptAll() internal {\\n        address[] memory contracts = contractsRequiringOwnership();\\n        for (uint i = 0; i < contracts.length; i++) {\\n            Owned(contracts[i]).acceptOwnership();\\n        }\\n    }\\n\\n    function nominateAll() internal {\\n        address[] memory contracts = contractsRequiringOwnership();\\n        for (uint i = 0; i < contracts.length; i++) {\\n            returnOwnership(contracts[i]);\\n        }\\n    }\\n\\n    function addressresolver_importAddresses_0() internal {\\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](9);\\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\\\"FeePool\\\");\\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\\\"Synthetix\\\");\\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\\\"Exchanger\\\");\\n        addressresolver_importAddresses_names_0_0[3] = bytes32(\\\"DebtCache\\\");\\n        addressresolver_importAddresses_names_0_0[4] = bytes32(\\\"Issuer\\\");\\n        addressresolver_importAddresses_names_0_0[5] = bytes32(\\\"SynthRedeemer\\\");\\n        addressresolver_importAddresses_names_0_0[6] = bytes32(\\\"SynthsUSD\\\");\\n        addressresolver_importAddresses_names_0_0[7] = bytes32(\\\"SynthsBTC\\\");\\n        addressresolver_importAddresses_names_0_0[8] = bytes32(\\\"SynthsETH\\\");\\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](9);\\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_FeePool_contract);\\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_Synthetix_contract);\\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_Exchanger_contract);\\n        addressresolver_importAddresses_destinations_0_1[3] = address(new_DebtCache_contract);\\n        addressresolver_importAddresses_destinations_0_1[4] = address(new_Issuer_contract);\\n        addressresolver_importAddresses_destinations_0_1[5] = address(new_SynthRedeemer_contract);\\n        addressresolver_importAddresses_destinations_0_1[6] = address(new_SynthsUSD_contract);\\n        addressresolver_importAddresses_destinations_0_1[7] = address(new_SynthsBTC_contract);\\n        addressresolver_importAddresses_destinations_0_1[8] = address(new_SynthsETH_contract);\\n        addressresolver_i.importAddresses(\\n            addressresolver_importAddresses_names_0_0,\\n            addressresolver_importAddresses_destinations_0_1\\n        );\\n    }\\n\\n    function addressresolver_rebuildCaches_1() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(new_Exchanger_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(new_Issuer_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(new_SynthsUSD_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0xC61b352fCc311Ae6B0301459A970150005e74b3E);\\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427);\\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0x37B648a07476F4941D3D647f81118AFd55fa8a04);\\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258);\\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01);\\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8);\\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0x5eDf7dd83fE2889D264fa9D3b93d0a6e6A45D6C6);\\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0x9745606DA6e162866DAD7bF80f2AbF145EDD7571);\\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0x2962EA4E749e54b10CFA557770D597027BA67cB3);\\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(new_SynthsBTC_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(new_SynthsETH_contract);\\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0xda3c83750b1FA31Fda838136ef3f853b41cb7a5a);\\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(0x47bD14817d7684082E04934878EE2Dd3576Ae19d);\\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0x6F927644d55E32318629198081923894FbFe5c07);\\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0xe3D5E1c1bA874C0fF3BA31b999967F24d5ca04e5);\\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0xA962208CDC8588F9238fae169d0F63306c353F4F);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\\n    }\\n\\n    function addressresolver_rebuildCaches_2() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0xcd980Fc5CcdAe62B18A52b83eC64200121A929db);\\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0xAf090d6E583C082f2011908cf95c2518BE7A53ac);\\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0x21ee4afBd6c151fD9A69c1389598170B1d45E0e3);\\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0xcb6Cb218D558ae7fF6415f95BDA6616FCFF669Cb);\\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0x7B29C9e188De18563B19d162374ce6836F31415a);\\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(0xC22e51FA362654ea453B4018B616ef6f6ab3b779);\\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270);\\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(0xAa1b12E3e5F70aBCcd1714F4260A74ca21e7B17b);\\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0x0F393ce493d8FB0b83915248a21a3104932ed97c);\\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb);\\n        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(0x4287dac1cC7434991119Eba7413189A66fFE65cF);\\n        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(0x34c76BC146b759E58886e821D62548AC1e0BA7Bc);\\n        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(0x0E8Fa2339314AB7E164818F26207897bBe29C3af);\\n        addressresolver_rebuildCaches_destinations_2_0[13] = MixinResolver(0xe615Df79AC987193561f37E77465bEC2aEfe9aDb);\\n        addressresolver_rebuildCaches_destinations_2_0[14] = MixinResolver(0x3E2dA260B4A85782A629320EB027A3B7c28eA9f1);\\n        addressresolver_rebuildCaches_destinations_2_0[15] = MixinResolver(0xc02DD182Ce029E6d7f78F37492DFd39E4FEB1f8b);\\n        addressresolver_rebuildCaches_destinations_2_0[16] = MixinResolver(0x0d1c4e5C07B071aa4E6A14A604D4F6478cAAC7B4);\\n        addressresolver_rebuildCaches_destinations_2_0[17] = MixinResolver(0x13D0F5B8630520eA04f694F17A001fb95eaFD30E);\\n        addressresolver_rebuildCaches_destinations_2_0[18] = MixinResolver(0x815CeF3b7773f35428B4353073B086ecB658f73C);\\n        addressresolver_rebuildCaches_destinations_2_0[19] = MixinResolver(0xb0e0BA880775B7F2ba813b3800b3979d719F0379);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\\n    }\\n\\n    function addressresolver_rebuildCaches_3() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_3_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_3_0[0] = MixinResolver(0x8e082925e78538955bC0e2F363FC5d1Ab3be739b);\\n        addressresolver_rebuildCaches_destinations_3_0[1] = MixinResolver(0x399BA516a6d68d6Ad4D5f3999902D0DeAcaACDdd);\\n        addressresolver_rebuildCaches_destinations_3_0[2] = MixinResolver(0x9530FA32a3059114AC20A5812870Da12D97d1174);\\n        addressresolver_rebuildCaches_destinations_3_0[3] = MixinResolver(0x249612F641111022f2f48769f3Df5D85cb3E26a2);\\n        addressresolver_rebuildCaches_destinations_3_0[4] = MixinResolver(0x04720DbBD4599aD26811545595d97fB813E84964);\\n        addressresolver_rebuildCaches_destinations_3_0[5] = MixinResolver(0x2acfe6265D358d982cB1c3B521199973CD443C71);\\n        addressresolver_rebuildCaches_destinations_3_0[6] = MixinResolver(0x46A7Af405093B27DA6DeF193C508Bd9240A255FA);\\n        addressresolver_rebuildCaches_destinations_3_0[7] = MixinResolver(0x8350d1b2d6EF5289179fe49E5b0F208165B4e32e);\\n        addressresolver_rebuildCaches_destinations_3_0[8] = MixinResolver(0x29DD4A59F4D339226867e77aF211724eaBb45c02);\\n        addressresolver_rebuildCaches_destinations_3_0[9] = MixinResolver(0xf7B8dF8b16dA302d85603B8e7F95111a768458Cc);\\n        addressresolver_rebuildCaches_destinations_3_0[10] = MixinResolver(0x0517A56da8A517e3b2D484Cc5F1Da4BDCfE68ec3);\\n        addressresolver_rebuildCaches_destinations_3_0[11] = MixinResolver(0x099CfAd1640fc7EA686ab1D83F0A285Ba0470882);\\n        addressresolver_rebuildCaches_destinations_3_0[12] = MixinResolver(0x19cC1f63e344D74A87D955E3F3E95B28DDDc61d8);\\n        addressresolver_rebuildCaches_destinations_3_0[13] = MixinResolver(0x4D50A0e5f068ACdC80A1da2dd1f0Ad48845df2F8);\\n        addressresolver_rebuildCaches_destinations_3_0[14] = MixinResolver(0xb73c665825dAa926D6ef09417FbE5654473c1b49);\\n        addressresolver_rebuildCaches_destinations_3_0[15] = MixinResolver(0x806A599d60B2FdBda379D5890287D2fba1026cC0);\\n        addressresolver_rebuildCaches_destinations_3_0[16] = MixinResolver(0xCea42504874586a718954746A564B72bc7eba3E3);\\n        addressresolver_rebuildCaches_destinations_3_0[17] = MixinResolver(0x947d5656725fB9A8f9c826A91b6082b07E2745B7);\\n        addressresolver_rebuildCaches_destinations_3_0[18] = MixinResolver(0x186E56A62E7caCE1308f1A1B0dbb27f33F80f16f);\\n        addressresolver_rebuildCaches_destinations_3_0[19] = MixinResolver(0x931c5516EE121a177bD2B60e0122Da5B27630ABc);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_3_0);\\n    }\\n\\n    function addressresolver_rebuildCaches_4() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_4_0 = new MixinResolver[](20);\\n        addressresolver_rebuildCaches_destinations_4_0[0] = MixinResolver(0x6Dc6a64724399524184C2c44a526A2cff1BaA507);\\n        addressresolver_rebuildCaches_destinations_4_0[1] = MixinResolver(0x87eb6e935e3C7E3E3A0E31a5658498bC87dE646E);\\n        addressresolver_rebuildCaches_destinations_4_0[2] = MixinResolver(0x53869BDa4b8d85aEDCC9C6cAcf015AF9447Cade7);\\n        addressresolver_rebuildCaches_destinations_4_0[3] = MixinResolver(0x1cB27Ac646afAE192dF9928A2808C0f7f586Af7d);\\n        addressresolver_rebuildCaches_destinations_4_0[4] = MixinResolver(0x3dD7b893c25025CabFBd290A5E06BaFF3DE335b8);\\n        addressresolver_rebuildCaches_destinations_4_0[5] = MixinResolver(0x1A4505543C92084bE57ED80113eaB7241171e7a8);\\n        addressresolver_rebuildCaches_destinations_4_0[6] = MixinResolver(0xF6ce55E09De0F9F97210aAf6DB88Ed6b6792Ca1f);\\n        addressresolver_rebuildCaches_destinations_4_0[7] = MixinResolver(0xacAAB69C2BA65A2DB415605F309007e18D4F5E8C);\\n        addressresolver_rebuildCaches_destinations_4_0[8] = MixinResolver(0x9A5Ea0D8786B8d17a70410A905Aed1443fae5A38);\\n        addressresolver_rebuildCaches_destinations_4_0[9] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\\n        addressresolver_rebuildCaches_destinations_4_0[10] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\\n        addressresolver_rebuildCaches_destinations_4_0[11] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\\n        addressresolver_rebuildCaches_destinations_4_0[12] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\\n        addressresolver_rebuildCaches_destinations_4_0[13] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\\n        addressresolver_rebuildCaches_destinations_4_0[14] = MixinResolver(new_FeePool_contract);\\n        addressresolver_rebuildCaches_destinations_4_0[15] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\\n        addressresolver_rebuildCaches_destinations_4_0[16] = MixinResolver(0xCd9D4988C0AE61887B075bA77f08cbFAd2b65068);\\n        addressresolver_rebuildCaches_destinations_4_0[17] = MixinResolver(0xd69b189020EF614796578AfE4d10378c5e7e1138);\\n        addressresolver_rebuildCaches_destinations_4_0[18] = MixinResolver(new_Synthetix_contract);\\n        addressresolver_rebuildCaches_destinations_4_0[19] = MixinResolver(new_DebtCache_contract);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_4_0);\\n    }\\n\\n    function addressresolver_rebuildCaches_5() internal {\\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_5_0 = new MixinResolver[](3);\\n        addressresolver_rebuildCaches_destinations_5_0[0] = MixinResolver(new_SynthRedeemer_contract);\\n        addressresolver_rebuildCaches_destinations_5_0[1] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\\n        addressresolver_rebuildCaches_destinations_5_0[2] = MixinResolver(0x7A3d898b717e50a96fd8b232E9d15F0A547A7eeb);\\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_5_0);\\n    }\\n\\n    function importFeePeriod_0() internal {\\n        // https://etherscan.io/address/0xcf9E60005C9aca983caf65d3669a24fDd0775fc0;\\n        FeePool existingFeePool = FeePool(0xcf9E60005C9aca983caf65d3669a24fDd0775fc0);\\n        // https://etherscan.io/address/0x510adfDF6E7554C571b7Cd9305Ce91473610015e;\\n        FeePool newFeePool = FeePool(0x510adfDF6E7554C571b7Cd9305Ce91473610015e);\\n        (\\n            uint64 feePeriodId_0,\\n            uint64 startingDebtIndex_0,\\n            uint64 startTime_0,\\n            uint feesToDistribute_0,\\n            uint feesClaimed_0,\\n            uint rewardsToDistribute_0,\\n            uint rewardsClaimed_0\\n        ) = existingFeePool.recentFeePeriods(0);\\n        newFeePool.importFeePeriod(\\n            0,\\n            feePeriodId_0,\\n            startingDebtIndex_0,\\n            startTime_0,\\n            feesToDistribute_0,\\n            feesClaimed_0,\\n            rewardsToDistribute_0,\\n            rewardsClaimed_0\\n        );\\n    }\\n\\n    function importFeePeriod_1() internal {\\n        // https://etherscan.io/address/0xcf9E60005C9aca983caf65d3669a24fDd0775fc0;\\n        FeePool existingFeePool = FeePool(0xcf9E60005C9aca983caf65d3669a24fDd0775fc0);\\n        // https://etherscan.io/address/0x510adfDF6E7554C571b7Cd9305Ce91473610015e;\\n        FeePool newFeePool = FeePool(0x510adfDF6E7554C571b7Cd9305Ce91473610015e);\\n        (\\n            uint64 feePeriodId_1,\\n            uint64 startingDebtIndex_1,\\n            uint64 startTime_1,\\n            uint feesToDistribute_1,\\n            uint feesClaimed_1,\\n            uint rewardsToDistribute_1,\\n            uint rewardsClaimed_1\\n        ) = existingFeePool.recentFeePeriods(1);\\n        newFeePool.importFeePeriod(\\n            1,\\n            feePeriodId_1,\\n            startingDebtIndex_1,\\n            startTime_1,\\n            feesToDistribute_1,\\n            feesClaimed_1,\\n            rewardsToDistribute_1,\\n            rewardsClaimed_1\\n        );\\n    }\\n\\n    function copyTotalSupplyFrom_sUSD() internal {\\n        // https://etherscan.io/address/0x4D8dBD193d89b7B506BE5dC9Db75B91dA00D6a1d;\\n        Synth existingSynth = Synth(0x4D8dBD193d89b7B506BE5dC9Db75B91dA00D6a1d);\\n        // https://etherscan.io/address/0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b;\\n        Synth newSynth = Synth(0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b);\\n        newSynth.setTotalSupply(existingSynth.totalSupply());\\n    }\\n\\n    function copyTotalSupplyFrom_sBTC() internal {\\n        // https://etherscan.io/address/0xDB91E4B3b6E19bF22E810C43273eae48C9037e74;\\n        Synth existingSynth = Synth(0xDB91E4B3b6E19bF22E810C43273eae48C9037e74);\\n        // https://etherscan.io/address/0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9;\\n        Synth newSynth = Synth(0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9);\\n        newSynth.setTotalSupply(existingSynth.totalSupply());\\n    }\\n\\n    function copyTotalSupplyFrom_sETH() internal {\\n        // https://etherscan.io/address/0xab4e760fEEe20C5c2509061b995e06b542D3112B;\\n        Synth existingSynth = Synth(0xab4e760fEEe20C5c2509061b995e06b542D3112B);\\n        // https://etherscan.io/address/0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6;\\n        Synth newSynth = Synth(0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6);\\n        newSynth.setTotalSupply(existingSynth.totalSupply());\\n    }\\n\\n    function issuer_addSynths_39() internal {\\n        ISynth[] memory issuer_addSynths_synthsToAdd_39_0 = new ISynth[](15);\\n        issuer_addSynths_synthsToAdd_39_0[0] = ISynth(new_SynthsUSD_contract);\\n        issuer_addSynths_synthsToAdd_39_0[1] = ISynth(0xC61b352fCc311Ae6B0301459A970150005e74b3E);\\n        issuer_addSynths_synthsToAdd_39_0[2] = ISynth(0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427);\\n        issuer_addSynths_synthsToAdd_39_0[3] = ISynth(0x37B648a07476F4941D3D647f81118AFd55fa8a04);\\n        issuer_addSynths_synthsToAdd_39_0[4] = ISynth(0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258);\\n        issuer_addSynths_synthsToAdd_39_0[5] = ISynth(0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01);\\n        issuer_addSynths_synthsToAdd_39_0[6] = ISynth(0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8);\\n        issuer_addSynths_synthsToAdd_39_0[7] = ISynth(0x5eDf7dd83fE2889D264fa9D3b93d0a6e6A45D6C6);\\n        issuer_addSynths_synthsToAdd_39_0[8] = ISynth(0x9745606DA6e162866DAD7bF80f2AbF145EDD7571);\\n        issuer_addSynths_synthsToAdd_39_0[9] = ISynth(0x2962EA4E749e54b10CFA557770D597027BA67cB3);\\n        issuer_addSynths_synthsToAdd_39_0[10] = ISynth(new_SynthsBTC_contract);\\n        issuer_addSynths_synthsToAdd_39_0[11] = ISynth(new_SynthsETH_contract);\\n        issuer_addSynths_synthsToAdd_39_0[12] = ISynth(0xda3c83750b1FA31Fda838136ef3f853b41cb7a5a);\\n        issuer_addSynths_synthsToAdd_39_0[13] = ISynth(0x47bD14817d7684082E04934878EE2Dd3576Ae19d);\\n        issuer_addSynths_synthsToAdd_39_0[14] = ISynth(0x6F927644d55E32318629198081923894FbFe5c07);\\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_39_0);\\n    }\\n\\n    function issuer_addSynths_40() internal {\\n        ISynth[] memory issuer_addSynths_synthsToAdd_40_0 = new ISynth[](15);\\n        issuer_addSynths_synthsToAdd_40_0[0] = ISynth(0xe3D5E1c1bA874C0fF3BA31b999967F24d5ca04e5);\\n        issuer_addSynths_synthsToAdd_40_0[1] = ISynth(0xA962208CDC8588F9238fae169d0F63306c353F4F);\\n        issuer_addSynths_synthsToAdd_40_0[2] = ISynth(0xcd980Fc5CcdAe62B18A52b83eC64200121A929db);\\n        issuer_addSynths_synthsToAdd_40_0[3] = ISynth(0xAf090d6E583C082f2011908cf95c2518BE7A53ac);\\n        issuer_addSynths_synthsToAdd_40_0[4] = ISynth(0x21ee4afBd6c151fD9A69c1389598170B1d45E0e3);\\n        issuer_addSynths_synthsToAdd_40_0[5] = ISynth(0xcb6Cb218D558ae7fF6415f95BDA6616FCFF669Cb);\\n        issuer_addSynths_synthsToAdd_40_0[6] = ISynth(0x7B29C9e188De18563B19d162374ce6836F31415a);\\n        issuer_addSynths_synthsToAdd_40_0[7] = ISynth(0xC22e51FA362654ea453B4018B616ef6f6ab3b779);\\n        issuer_addSynths_synthsToAdd_40_0[8] = ISynth(0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270);\\n        issuer_addSynths_synthsToAdd_40_0[9] = ISynth(0xAa1b12E3e5F70aBCcd1714F4260A74ca21e7B17b);\\n        issuer_addSynths_synthsToAdd_40_0[10] = ISynth(0x0F393ce493d8FB0b83915248a21a3104932ed97c);\\n        issuer_addSynths_synthsToAdd_40_0[11] = ISynth(0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb);\\n        issuer_addSynths_synthsToAdd_40_0[12] = ISynth(0x4287dac1cC7434991119Eba7413189A66fFE65cF);\\n        issuer_addSynths_synthsToAdd_40_0[13] = ISynth(0x34c76BC146b759E58886e821D62548AC1e0BA7Bc);\\n        issuer_addSynths_synthsToAdd_40_0[14] = ISynth(0x0E8Fa2339314AB7E164818F26207897bBe29C3af);\\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_40_0);\\n    }\\n\\n    function issuer_addSynths_41() internal {\\n        ISynth[] memory issuer_addSynths_synthsToAdd_41_0 = new ISynth[](15);\\n        issuer_addSynths_synthsToAdd_41_0[0] = ISynth(0xe615Df79AC987193561f37E77465bEC2aEfe9aDb);\\n        issuer_addSynths_synthsToAdd_41_0[1] = ISynth(0x3E2dA260B4A85782A629320EB027A3B7c28eA9f1);\\n        issuer_addSynths_synthsToAdd_41_0[2] = ISynth(0xc02DD182Ce029E6d7f78F37492DFd39E4FEB1f8b);\\n        issuer_addSynths_synthsToAdd_41_0[3] = ISynth(0x0d1c4e5C07B071aa4E6A14A604D4F6478cAAC7B4);\\n        issuer_addSynths_synthsToAdd_41_0[4] = ISynth(0x13D0F5B8630520eA04f694F17A001fb95eaFD30E);\\n        issuer_addSynths_synthsToAdd_41_0[5] = ISynth(0x815CeF3b7773f35428B4353073B086ecB658f73C);\\n        issuer_addSynths_synthsToAdd_41_0[6] = ISynth(0xb0e0BA880775B7F2ba813b3800b3979d719F0379);\\n        issuer_addSynths_synthsToAdd_41_0[7] = ISynth(0x8e082925e78538955bC0e2F363FC5d1Ab3be739b);\\n        issuer_addSynths_synthsToAdd_41_0[8] = ISynth(0x399BA516a6d68d6Ad4D5f3999902D0DeAcaACDdd);\\n        issuer_addSynths_synthsToAdd_41_0[9] = ISynth(0x9530FA32a3059114AC20A5812870Da12D97d1174);\\n        issuer_addSynths_synthsToAdd_41_0[10] = ISynth(0x249612F641111022f2f48769f3Df5D85cb3E26a2);\\n        issuer_addSynths_synthsToAdd_41_0[11] = ISynth(0x04720DbBD4599aD26811545595d97fB813E84964);\\n        issuer_addSynths_synthsToAdd_41_0[12] = ISynth(0x2acfe6265D358d982cB1c3B521199973CD443C71);\\n        issuer_addSynths_synthsToAdd_41_0[13] = ISynth(0x46A7Af405093B27DA6DeF193C508Bd9240A255FA);\\n        issuer_addSynths_synthsToAdd_41_0[14] = ISynth(0x8350d1b2d6EF5289179fe49E5b0F208165B4e32e);\\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_41_0);\\n    }\\n\\n    function issuer_addSynths_42() internal {\\n        ISynth[] memory issuer_addSynths_synthsToAdd_42_0 = new ISynth[](15);\\n        issuer_addSynths_synthsToAdd_42_0[0] = ISynth(0x29DD4A59F4D339226867e77aF211724eaBb45c02);\\n        issuer_addSynths_synthsToAdd_42_0[1] = ISynth(0xf7B8dF8b16dA302d85603B8e7F95111a768458Cc);\\n        issuer_addSynths_synthsToAdd_42_0[2] = ISynth(0x0517A56da8A517e3b2D484Cc5F1Da4BDCfE68ec3);\\n        issuer_addSynths_synthsToAdd_42_0[3] = ISynth(0x099CfAd1640fc7EA686ab1D83F0A285Ba0470882);\\n        issuer_addSynths_synthsToAdd_42_0[4] = ISynth(0x19cC1f63e344D74A87D955E3F3E95B28DDDc61d8);\\n        issuer_addSynths_synthsToAdd_42_0[5] = ISynth(0x4D50A0e5f068ACdC80A1da2dd1f0Ad48845df2F8);\\n        issuer_addSynths_synthsToAdd_42_0[6] = ISynth(0xb73c665825dAa926D6ef09417FbE5654473c1b49);\\n        issuer_addSynths_synthsToAdd_42_0[7] = ISynth(0x806A599d60B2FdBda379D5890287D2fba1026cC0);\\n        issuer_addSynths_synthsToAdd_42_0[8] = ISynth(0xCea42504874586a718954746A564B72bc7eba3E3);\\n        issuer_addSynths_synthsToAdd_42_0[9] = ISynth(0x947d5656725fB9A8f9c826A91b6082b07E2745B7);\\n        issuer_addSynths_synthsToAdd_42_0[10] = ISynth(0x186E56A62E7caCE1308f1A1B0dbb27f33F80f16f);\\n        issuer_addSynths_synthsToAdd_42_0[11] = ISynth(0x931c5516EE121a177bD2B60e0122Da5B27630ABc);\\n        issuer_addSynths_synthsToAdd_42_0[12] = ISynth(0x6Dc6a64724399524184C2c44a526A2cff1BaA507);\\n        issuer_addSynths_synthsToAdd_42_0[13] = ISynth(0x87eb6e935e3C7E3E3A0E31a5658498bC87dE646E);\\n        issuer_addSynths_synthsToAdd_42_0[14] = ISynth(0x53869BDa4b8d85aEDCC9C6cAcf015AF9447Cade7);\\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_42_0);\\n    }\\n\\n    function issuer_addSynths_43() internal {\\n        ISynth[] memory issuer_addSynths_synthsToAdd_43_0 = new ISynth[](6);\\n        issuer_addSynths_synthsToAdd_43_0[0] = ISynth(0x1cB27Ac646afAE192dF9928A2808C0f7f586Af7d);\\n        issuer_addSynths_synthsToAdd_43_0[1] = ISynth(0x3dD7b893c25025CabFBd290A5E06BaFF3DE335b8);\\n        issuer_addSynths_synthsToAdd_43_0[2] = ISynth(0x1A4505543C92084bE57ED80113eaB7241171e7a8);\\n        issuer_addSynths_synthsToAdd_43_0[3] = ISynth(0xF6ce55E09De0F9F97210aAf6DB88Ed6b6792Ca1f);\\n        issuer_addSynths_synthsToAdd_43_0[4] = ISynth(0xacAAB69C2BA65A2DB415605F309007e18D4F5E8C);\\n        issuer_addSynths_synthsToAdd_43_0[5] = ISynth(0x9A5Ea0D8786B8d17a70410A905Aed1443fae5A38);\\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_43_0);\\n    }\\n}\\n\\n    \"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangestate_i\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepool_i\",\"outputs\":[{\"internalType\":\"contract FeePool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepooleternalstorage_i\",\"outputs\":[{\"internalType\":\"contract FeePoolEternalStorage\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepoolstate_i\",\"outputs\":[{\"internalType\":\"contract FeePoolState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer_i\",\"outputs\":[{\"internalType\":\"contract Issuer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_DebtCache_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Exchanger_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_FeePool_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Issuer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthRedeemer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Synthetix_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsBTC_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsETH_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsUSD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyerc20_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyerc20susd_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyfeepool_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysbtc_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseth_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysusd_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysynthetix_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsdistribution_i\",\"outputs\":[{\"internalType\":\"contract RewardsDistribution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthetixstate_i\",\"outputs\":[{\"internalType\":\"contract SynthetixState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsbtc_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseth_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsusd_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesbtc_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseth_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesusd_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesynthetix_i\",\"outputs\":[{\"internalType\":\"contract LegacyTokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Migration_Mirfak","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}