{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DebtLockerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity =0.8.7;\\n\\ninterface IMapleGlobalsLike {\\n\\n    function governor() external view returns (address governor_);\\n\\n}\\n\\ninterface IMapleProxiedLike {\\n\\n    function implementation() external view returns (address implementation_);\\n\\n}\\n\\ninterface IProxiedLike {\\n\\n    function implementation() external view returns (address implementation_);\\n\\n    function setImplementation(address newImplementation_) external;\\n\\n    function migrate(address migrator_, bytes calldata arguments_) external;\\n\\n}\\n\\n/// @title An beacon that provides a default implementation for proxies, must implement IDefaultImplementationBeacon.\\ninterface IDefaultImplementationBeacon {\\n\\n    /// @dev The address of an implementation for proxies.\\n    function defaultImplementation() external view returns (address defaultImplementation_);\\n\\n}\\n\\n/// @title A Maple factory for Proxy contracts that proxy MapleProxied implementations.\\ninterface IMapleProxyFactory is IDefaultImplementationBeacon {\\n\\n    /**************/\\n    /*** Events ***/\\n    /**************/\\n\\n    /**\\n     *  @dev   A default version was set.\\n     *  @param version_ The default version.\\n     */\\n    event DefaultVersionSet(uint256 indexed version_);\\n\\n    /**\\n     *  @dev   A version of an implementation, at some address, was registered, with an optional initializer.\\n     *  @param version_               The version registered.\\n     *  @param implementationAddress_ The address of the implementation.\\n     *  @param initializer_           The address of the initializer, if any.\\n     */\\n    event ImplementationRegistered(uint256 indexed version_, address indexed implementationAddress_, address indexed initializer_);\\n\\n    /**\\n     *  @dev   A proxy contract was deployed with some initialization arguments.\\n     *  @param version_                 The version of the implementation being proxied by the deployed proxy contract.\\n     *  @param instance_                The address of the proxy contract deployed.\\n     *  @param initializationArguments_ The arguments used to initialize the proxy contract, if any.\\n     */\\n    event InstanceDeployed(uint256 indexed version_, address indexed instance_, bytes initializationArguments_);\\n\\n    /**\\n     *  @dev   A instance has upgraded by proxying to a new implementation, with some migration arguments.\\n     *  @param instance_           The address of the proxy contract.\\n     *  @param fromVersion_        The initial implementation version being proxied.\\n     *  @param toVersion_          The new implementation version being proxied.\\n     *  @param migrationArguments_ The arguments used to migrate, if any.\\n     */\\n    event InstanceUpgraded(address indexed instance_, uint256 indexed fromVersion_, uint256 indexed toVersion_, bytes migrationArguments_);\\n\\n    /**\\n     *  @dev   The MapleGlobals was set.\\n     *  @param mapleGlobals_ The address of a Maple Globals contract.\\n     */\\n    event MapleGlobalsSet(address indexed mapleGlobals_);\\n\\n    /**\\n     *  @dev   An upgrade path was disabled, with an optional migrator contract.\\n     *  @param fromVersion_ The starting version of the upgrade path.\\n     *  @param toVersion_   The destination version of the upgrade path.\\n     */\\n    event UpgradePathDisabled(uint256 indexed fromVersion_, uint256 indexed toVersion_);\\n\\n    /**\\n     *  @dev   An upgrade path was enabled, with an optional migrator contract.\\n     *  @param fromVersion_ The starting version of the upgrade path.\\n     *  @param toVersion_   The destination version of the upgrade path.\\n     *  @param migrator_    The address of the migrator, if any.\\n     */\\n    event UpgradePathEnabled(uint256 indexed fromVersion_, uint256 indexed toVersion_, address indexed migrator_);\\n\\n    /***********************/\\n    /*** State Variables ***/\\n    /***********************/\\n\\n    /**\\n     *  @dev The default version.\\n     */\\n    function defaultVersion() external view returns (uint256 defaultVersion_);\\n\\n    /**\\n     *  @dev The address of the MapleGlobals contract.\\n     */\\n    function mapleGlobals() external view returns (address mapleGlobals_);\\n\\n    /**\\n     *  @dev    Whether the upgrade is enabled for a path from a version to another version.\\n     *  @param  toVersion_   The initial version.\\n     *  @param  fromVersion_ The destination version.\\n     *  @return allowed_     Whether the upgrade is enabled.\\n     */\\n    function upgradeEnabledForPath(uint256 toVersion_, uint256 fromVersion_) external view returns (bool allowed_);\\n\\n    /********************************/\\n    /*** State Changing Functions ***/\\n    /********************************/\\n\\n    /**\\n     *  @dev    Deploys a new instance proxying the default implementation version, with some initialization arguments.\\n     *          Uses a nonce and `msg.sender` as a salt for the CREATE2 opcode during instantiation to produce deterministic addresses.\\n     *  @param  arguments_ The initialization arguments to use for the instance deployment, if any.\\n     *  @param  salt_      The salt to use in the contract creation process.\\n     *  @return instance_  The address of the deployed proxy contract.\\n     */\\n    function createInstance(bytes calldata arguments_, bytes32 salt_) external returns (address instance_);\\n\\n    /**\\n     *  @dev   Enables upgrading from a version to a version of an implementation, with an optional migrator.\\n     *         Only the Governor can call this function.\\n     *  @param fromVersion_ The starting version of the upgrade path.\\n     *  @param toVersion_   The destination version of the upgrade path.\\n     *  @param migrator_    The address of the migrator, if any.\\n     */\\n    function enableUpgradePath(uint256 fromVersion_, uint256 toVersion_, address migrator_) external;\\n\\n    /**\\n     *  @dev   Disables upgrading from a version to a version of a implementation.\\n     *         Only the Governor can call this function.\\n     *  @param fromVersion_ The starting version of the upgrade path.\\n     *  @param toVersion_   The destination version of the upgrade path.\\n     */\\n    function disableUpgradePath(uint256 fromVersion_, uint256 toVersion_) external;\\n\\n    /**\\n     *  @dev   Registers the address of an implementation contract as a version, with an optional initializer.\\n     *         Only the Governor can call this function.\\n     *  @param version_               The version to register.\\n     *  @param implementationAddress_ The address of the implementation.\\n     *  @param initializer_           The address of the initializer, if any.\\n     */\\n    function registerImplementation(uint256 version_, address implementationAddress_, address initializer_) external;\\n\\n    /**\\n     *  @dev   Sets the default version.\\n     *         Only the Governor can call this function.\\n     *  @param version_ The implementation version to set as the default.\\n     */\\n    function setDefaultVersion(uint256 version_) external;\\n\\n    /**\\n     *  @dev   Sets the Maple Globals contract.\\n     *         Only the Governor can call this function.\\n     *  @param mapleGlobals_ The address of a Maple Globals contract.\\n     */\\n    function setGlobals(address mapleGlobals_) external;\\n\\n    /**\\n     *  @dev   Upgrades the calling proxy contract's implementation, with some migration arguments.\\n     *  @param toVersion_ The implementation version to upgrade the proxy contract to.\\n     *  @param arguments_ The migration arguments, if any.\\n     */\\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) external;\\n\\n    /**********************/\\n    /*** View Functions ***/\\n    /**********************/\\n\\n    /**\\n     *  @dev    Returns the deterministic address of a potential proxy, given some arguments and salt.\\n     *  @param  arguments_       The initialization arguments to be used when deploying the proxy.\\n     *  @param  salt_            The salt to be used when deploying the proxy.\\n     *  @return instanceAddress_ The deterministic address of a potential proxy.\\n     */\\n    function getInstanceAddress(bytes calldata arguments_, bytes32 salt_) external view returns (address instanceAddress_);\\n\\n    /**\\n     *  @dev    Returns the address of an implementation version.\\n     *  @param  version_        The implementation version.\\n     *  @return implementation_ The address of the implementation.\\n     */\\n    function implementationOf(uint256 version_) external view returns (address implementation_);\\n\\n    /**\\n     *  @dev    Returns the address of a migrator contract for a migration path (from version, to version).\\n     *          If oldVersion_ == newVersion_, the migrator is an initializer.\\n     *  @param  oldVersion_ The old version.\\n     *  @param  newVersion_ The new version.\\n     *  @return migrator_   The address of a migrator contract.\\n     */\\n    function migratorForPath(uint256 oldVersion_, uint256 newVersion_) external view returns (address migrator_);\\n\\n    /**\\n     *  @dev    Returns the version of an implementation contract.\\n     *  @param  implementation_ The address of an implementation contract.\\n     *  @return version_        The version of the implementation contract.\\n     */\\n    function versionOf(address implementation_) external view returns (uint256 version_);\\n\\n}\\n\\n/// @title Deploys DebtLocker proxy instances.\\ninterface IDebtLockerFactory is IMapleProxyFactory {\\n\\n    /**\\n     * @dev The Maple factory type (to be deprecated).\\n     */\\n    function factoryType() external view returns (uint8 factoryType_);\\n\\n    /**\\n     * @dev    Deploys a new DebtLocker proxy instance.\\n     * @param  loan_       Loan contract that corresponds to DebtLocker.\\n     * @return debtLocker_ The address of the deployed DebtLocker proxy.\\n     */\\n    function newLocker(address loan_) external returns (address debtLocker_);\\n\\n}\\n\\nabstract contract SlotManipulatable {\\n\\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\\n        return keccak256(abi.encodePacked(key_, slot_));\\n    }\\n\\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\\n        assembly {\\n            value_ := sload(slot_)\\n        }\\n    }\\n\\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\\n        assembly {\\n            sstore(slot_, value_)\\n        }\\n    }\\n\\n}\\n\\n/// @title A completely transparent, and thus interface-less, proxy contract.\\ncontract Proxy is SlotManipulatable {\\n\\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\\n\\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\\n\\n    /**\\n     *  @dev   The constructor requires at least one of `factory_` or `implementation_`.\\n     *         If an implementation is not provided, the factory is treated as an IDefaultImplementationBeacon to fetch the default implementation.\\n     *  @param factory_        The address of a proxy factory, if any.\\n     *  @param implementation_ The address of the implementation contract being proxied, if any.\\n     */\\n    constructor(address factory_, address implementation_) {\\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\\n\\n        // If the implementation is empty, fetch it from the factory, which can act as a beacon.\\n        address implementation = implementation_ == address(0) ? IDefaultImplementationBeacon(factory_).defaultImplementation() : implementation_;\\n\\n        require(implementation != address(0));\\n\\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation))));\\n    }\\n\\n    fallback() payable external virtual {\\n        bytes32 implementation = _getSlotValue(IMPLEMENTATION_SLOT);\\n\\n        require(address(uint160(uint256(implementation))).code.length != uint256(0));\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n}\\n\\n/// @title A factory for Proxy contracts that proxy Proxied implementations.\\nabstract contract ProxyFactory {\\n\\n    mapping(uint256 => address) internal _implementationOf;\\n\\n    mapping(address => uint256) internal _versionOf;\\n\\n    mapping(uint256 => mapping(uint256 => address)) internal _migratorForPath;\\n\\n    /// @dev Returns the implementation of `proxy_`.\\n    function _getImplementationOfProxy(address proxy_) private view returns (bool success_, address implementation_) {\\n        bytes memory returnData;\\n        // Since `_getImplementationOfProxy` is a private function, no need to check `proxy_` is a contract.\\n        ( success_, returnData ) = proxy_.staticcall(abi.encodeWithSelector(IProxiedLike.implementation.selector));\\n        implementation_ = abi.decode(returnData, (address));\\n    }\\n\\n    /// @dev Initializes `proxy_` using the initializer for `version_`, given some initialization arguments.\\n    function _initializeInstance(address proxy_, uint256 version_, bytes memory arguments_) private returns (bool success_) {\\n        // The migrator, where fromVersion == toVersion, is an initializer.\\n        address initializer = _migratorForPath[version_][version_];\\n\\n        // If there is no initializer, then no initialization is necessary, so long as no initialization arguments were provided.\\n        if (initializer == address(0)) return arguments_.length == uint256(0);\\n\\n        // Call the migrate function on the proxy, passing any initialization arguments.\\n        // Since `_initializeInstance` is a private function, no need to check `proxy_` is a contract.\\n        ( success_, ) = proxy_.call(abi.encodeWithSelector(IProxiedLike.migrate.selector, initializer, arguments_));\\n    }\\n\\n    /// @dev Deploys a new proxy for some version, with some initialization arguments, using `create` (i.e. factory's nonce determines the address).\\n    function _newInstance(uint256 version_, bytes memory arguments_) internal virtual returns (bool success_, address proxy_) {\\n        address implementation = _implementationOf[version_];\\n\\n        if (implementation == address(0)) return (false, address(0));\\n\\n        proxy_   = address(new Proxy(address(this), implementation));\\n        success_ = _initializeInstance(proxy_, version_, arguments_);\\n    }\\n\\n    /// @dev Deploys a new proxy, with some initialization arguments, using `create2` (i.e. salt determines the address).\\n    ///      This factory needs to be IDefaultImplementationBeacon, since the proxy will pull its implementation from it.\\n    function _newInstance(bytes memory arguments_, bytes32 salt_) internal virtual returns (bool success_, address proxy_) {\\n        proxy_ = address(new Proxy{ salt: salt_ }(address(this), address(0)));\\n\\n        // Fetch the implementation from the proxy. Don't care about success, since the version of the implementation will be checked in the next step.\\n        ( , address implementation ) = _getImplementationOfProxy(proxy_);\\n\\n        // Get the version of the implementation.\\n        uint256 version = _versionOf[implementation];\\n\\n        // Successful if version is nonzero (i.e. implementation fetched successfully from proxy) and initializing the instance succeeds.\\n        success_ = (version != uint256(0)) && _initializeInstance(proxy_, version, arguments_);\\n    }\\n\\n    /// @dev Registers an implementation for some version.\\n    function _registerImplementation(uint256 version_, address implementation_) internal virtual returns (bool success_) {\\n        // Version 0 is not allowed since its the default value of all _versionOf[implementation_].\\n        // Implementation cannot already be registered and cannot be empty account (and thus also not address(0)).\\n        if (\\n            version_ == uint256(0) ||\\n            _implementationOf[version_] != address(0) ||\\n            _versionOf[implementation_] != uint256(0) ||\\n            !_isContract(implementation_)\\n        ) return false;\\n\\n        // Store in two-way mappings.\\n        _implementationOf[version_] = implementation_;\\n        _versionOf[implementation_] = version_;\\n\\n        return true;\\n    }\\n\\n    /// @dev Registers a migrator for between two versions. If `fromVersion_ == toVersion_`, migrator is an initializer.\\n    function _registerMigrator(uint256 fromVersion_, uint256 toVersion_, address migrator_) internal virtual returns (bool success_) {\\n        // Version 0 is invalid.\\n        if (fromVersion_ == uint256(0) || toVersion_ == uint256(0)) return false;\\n\\n        // Migrator must either be zero (clearing) or a contract (setting).\\n        if (migrator_ != address(0) && !_isContract(migrator_)) return false;\\n\\n        _migratorForPath[fromVersion_][toVersion_] = migrator_;\\n\\n        return true;\\n    }\\n\\n    /// @dev Upgrades a proxy to a new version of an implementation, with some migration arguments.\\n    ///      Inheritor should revert on `success_ = false`, since proxy can be set to new implementation, but failed to migrate.\\n    function _upgradeInstance(address proxy_, uint256 toVersion_, bytes memory arguments_) internal virtual returns (bool success_) {\\n        // Check that the proxy is currently a contract, just once, ahead of the 3 times it will be low-level-called.\\n        if (!_isContract(proxy_)) return false;\\n\\n        address toImplementation = _implementationOf[toVersion_];\\n\\n        // The implementation being migrated must have been registered (which also implies that `toVersion_` was not 0).\\n        if (toImplementation == address(0)) return false;\\n\\n        // Fetch the implementation from the proxy.\\n        address fromImplementation;\\n        ( success_, fromImplementation ) = _getImplementationOfProxy(proxy_);\\n\\n        if (!success_) return false;\\n\\n        // Set the proxy's implementation.\\n        ( success_, ) = proxy_.call(abi.encodeWithSelector(IProxiedLike.setImplementation.selector, toImplementation));\\n\\n        if (!success_) return false;\\n\\n        // Get the version of the `fromImplementation`, then get the `migrator` of the upgrade path to `toVersion_`.\\n        address migrator = _migratorForPath[_versionOf[fromImplementation]][toVersion_];\\n\\n        // If there is no migrator, then no migration is necessary, so long as no migration arguments were provided.\\n        if (migrator == address(0)) return arguments_.length == uint256(0);\\n\\n        // Call the migrate function on the proxy, passing any migration arguments.\\n        ( success_, ) = proxy_.call(abi.encodeWithSelector(IProxiedLike.migrate.selector, migrator, arguments_));\\n    }\\n\\n    /// @dev Returns the deterministic address of a proxy given some salt.\\n    function _getDeterministicProxyAddress(bytes32 salt_) internal virtual view returns (address deterministicProxyAddress_) {\\n        // See https://docs.soliditylang.org/en/v0.8.7/control-structures.html#salted-contract-creations-create2\\n        return address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            salt_,\\n                            keccak256(abi.encodePacked(type(Proxy).creationCode, abi.encode(address(this), address(0))))\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /// @dev Returns whether the account is currently a contract.\\n    function _isContract(address account_) internal view returns (bool isContract_) {\\n        return account_.code.length != uint256(0);\\n    }\\n\\n}\\n\\n/// @title A Maple factory for Proxy contracts that proxy MapleProxied implementations.\\ncontract MapleProxyFactory is IMapleProxyFactory, ProxyFactory {\\n\\n    address public override mapleGlobals;\\n\\n    uint256 public override defaultVersion;\\n\\n    mapping(uint256 => mapping(uint256 => bool)) public override upgradeEnabledForPath;\\n\\n    /// @param mapleGlobals_ The address of a Maple Globals contract.\\n    constructor(address mapleGlobals_) {\\n        require(IMapleGlobalsLike(mapleGlobals = mapleGlobals_).governor() != address(0), \\\"MPF:C:INVALID_GLOBALS\\\");\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(msg.sender == IMapleGlobalsLike(mapleGlobals).governor(), \\\"MPF:NOT_GOVERNOR\\\");\\n        _;\\n    }\\n\\n    /********************************/\\n    /*** Administrative Functions ***/\\n    /********************************/\\n\\n    function disableUpgradePath(uint256 fromVersion_, uint256 toVersion_) public override virtual onlyGovernor {\\n        require(fromVersion_ != toVersion_,                              \\\"MPF:DUP:OVERWRITING_INITIALIZER\\\");\\n        require(_registerMigrator(fromVersion_, toVersion_, address(0)), \\\"MPF:DUP:FAILED\\\");\\n\\n        emit UpgradePathDisabled(fromVersion_, toVersion_);\\n\\n        upgradeEnabledForPath[fromVersion_][toVersion_] = false;\\n    }\\n\\n    function enableUpgradePath(uint256 fromVersion_, uint256 toVersion_, address migrator_) public override virtual onlyGovernor {\\n        require(fromVersion_ != toVersion_,                             \\\"MPF:EUP:OVERWRITING_INITIALIZER\\\");\\n        require(_registerMigrator(fromVersion_, toVersion_, migrator_), \\\"MPF:EUP:FAILED\\\");\\n\\n        emit UpgradePathEnabled(fromVersion_, toVersion_, migrator_);\\n\\n        upgradeEnabledForPath[fromVersion_][toVersion_] = true;\\n    }\\n\\n    function registerImplementation(uint256 version_, address implementationAddress_, address initializer_) public override virtual onlyGovernor {\\n        // Version 0 reserved as \\\"no version\\\" since default `defaultVersion` is 0.\\n        require(version_ != uint256(0), \\\"MPF:RI:INVALID_VERSION\\\");\\n\\n        emit ImplementationRegistered(version_, implementationAddress_, initializer_);\\n\\n        require(_registerImplementation(version_, implementationAddress_), \\\"MPF:RI:FAIL_FOR_IMPLEMENTATION\\\");\\n\\n        // Set migrator for initialization, which understood as fromVersion == toVersion.\\n        require(_registerMigrator(version_, version_, initializer_), \\\"MPF:RI:FAIL_FOR_MIGRATOR\\\");\\n    }\\n\\n    function setDefaultVersion(uint256 version_) public override virtual onlyGovernor {\\n        // Version must be 0 (to disable creating new instances) or be registered.\\n        require(version_ == 0 || _implementationOf[version_] != address(0), \\\"MPF:SDV:INVALID_VERSION\\\");\\n\\n        emit DefaultVersionSet(defaultVersion = version_);\\n    }\\n\\n    function setGlobals(address mapleGlobals_) public override virtual onlyGovernor {\\n        require(IMapleGlobalsLike(mapleGlobals_).governor() != address(0), \\\"MPF:SG:INVALID_GLOBALS\\\");\\n\\n        emit MapleGlobalsSet(mapleGlobals = mapleGlobals_);\\n    }\\n\\n    /**************************/\\n    /*** Instance Functions ***/\\n    /**************************/\\n\\n    function createInstance(bytes calldata arguments_, bytes32 salt_) public override virtual returns (address instance_) {\\n        bool success;\\n        ( success, instance_ ) = _newInstance(arguments_, keccak256(abi.encodePacked(arguments_, salt_)));\\n        require(success, \\\"MPF:CI:FAILED\\\");\\n\\n        emit InstanceDeployed(defaultVersion, instance_, arguments_);\\n    }\\n\\n    // NOTE: The implementation proxied by the instance defines the access control logic for its own upgrade.\\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) public override virtual {\\n        uint256 fromVersion = _versionOf[IMapleProxiedLike(msg.sender).implementation()];\\n\\n        require(upgradeEnabledForPath[fromVersion][toVersion_], \\\"MPF:UI:NOT_ALLOWED\\\");\\n\\n        emit InstanceUpgraded(msg.sender, fromVersion, toVersion_, arguments_);\\n\\n        require(_upgradeInstance(msg.sender, toVersion_, arguments_), \\\"MPF:UI:FAILED\\\");\\n    }\\n\\n    /**********************/\\n    /*** View Functions ***/\\n    /**********************/\\n\\n    function getInstanceAddress(bytes calldata arguments_, bytes32 salt_) public view override virtual returns (address instanceAddress_) {\\n        return _getDeterministicProxyAddress(keccak256(abi.encodePacked(arguments_, salt_)));\\n    }\\n\\n    function implementationOf(uint256 version_) public view override virtual returns (address implementation_) {\\n        return _implementationOf[version_];\\n    }\\n\\n    function defaultImplementation() external view override returns (address defaultImplementation_) {\\n        return _implementationOf[defaultVersion];\\n    }\\n\\n    function migratorForPath(uint256 oldVersion_, uint256 newVersion_) public view override virtual returns (address migrator_) {\\n        return _migratorForPath[oldVersion_][newVersion_];\\n    }\\n\\n    function versionOf(address implementation_) public view override virtual returns (uint256 version_) {\\n        return _versionOf[implementation_];\\n    }\\n\\n}\\n\\n/// @title Deploys DebtLocker proxy instances.\\ncontract DebtLockerFactory is IDebtLockerFactory, MapleProxyFactory {\\n\\n    uint8 public constant override factoryType = uint8(1);\\n\\n    /// @param mapleGlobals_ The address of a Maple Globals contract.\\n    constructor(address mapleGlobals_) MapleProxyFactory(mapleGlobals_) {}\\n\\n    function newLocker(address loan_) external override returns (address debtLocker_) {\\n        bytes memory arguments = abi.encode(loan_, msg.sender);\\n\\n        bool success;\\n        ( success, debtLocker_ ) = _newInstance(defaultVersion, arguments);\\n        require(success, \\\"DLF:NL:FAILED\\\");\\n\\n        emit InstanceDeployed(defaultVersion, debtLocker_, arguments);\\n    }\\n\\n    /// @dev This function is disabled in favour of a PoolV1-compatible `newLocker` function.\\n    function createInstance(bytes calldata arguments_, bytes32 salt_)\\n        public override(IMapleProxyFactory, MapleProxyFactory) virtual returns (address instance_)\\n    {}\\n\\n    /// @dev This function is disabled in since the PoolV1-compatible `newLocker` function is used instead of `createInstance`.\\n    function getInstanceAddress(bytes calldata arguments_, bytes32 salt_)\\n        public view override(IMapleProxyFactory, MapleProxyFactory) virtual returns (address instanceAddress_)\\n    {}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mapleGlobals_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"}],\"name\":\"DefaultVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementationAddress_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initializer_\",\"type\":\"address\"}],\"name\":\"ImplementationRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instance_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"initializationArguments_\",\"type\":\"bytes\"}],\"name\":\"InstanceDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instance_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromVersion_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"migrationArguments_\",\"type\":\"bytes\"}],\"name\":\"InstanceUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mapleGlobals_\",\"type\":\"address\"}],\"name\":\"MapleGlobalsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromVersion_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"}],\"name\":\"UpgradePathDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromVersion_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"migrator_\",\"type\":\"address\"}],\"name\":\"UpgradePathEnabled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"}],\"name\":\"createInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instance_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"defaultImplementation_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromVersion_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"}],\"name\":\"disableUpgradePath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromVersion_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"migrator_\",\"type\":\"address\"}],\"name\":\"enableUpgradePath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"}],\"name\":\"getInstanceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instanceAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"}],\"name\":\"implementationOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mapleGlobals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oldVersion_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newVersion_\",\"type\":\"uint256\"}],\"name\":\"migratorForPath\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"migrator_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan_\",\"type\":\"address\"}],\"name\":\"newLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"debtLocker_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"implementationAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initializer_\",\"type\":\"address\"}],\"name\":\"registerImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"}],\"name\":\"setDefaultVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mapleGlobals_\",\"type\":\"address\"}],\"name\":\"setGlobals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeEnabledForPath\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"}],\"name\":\"upgradeInstance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"versionOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DebtLockerFactory","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c234c62c8c09687dff0d9047e40042cd166f3600","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"none"}]}