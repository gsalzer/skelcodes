{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ChainRunnersBaseRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./core/ChainRunnersTypes.sol\\\";\\n\\n/*\\n               ::::                                                                                                                                                  :::#%=\\n               @*==+-                                                                                                                                               ++==*=.\\n               #+=#=++..                                                                                                                                        ..=*=*+-#:\\n                :=+++++++=====================================:    .===============================================. .=========================================++++++++=\\n                 .%-+%##+=--==================================+=..=+-=============================================-+*+======================================---+##+=#-.\\n                   -+++@@%++++@@@%+++++++++++++++++++++++++++%#++++++%#+++#@@@#+++++++++@@%++++++++++++++++++++@#+.=+*@*+*@@@@*+++++++++++++++++++++++%@@@#+++#@@+++=\\n                    -*-#%@@%%%=*%@%*++=++=+==+=++=++=+=++=++==#@%#%#+++=+=*@%*+=+==+=+++%*++==+=++=+==+=++=+=++@%%#%#++++*@%#++=++=++=++=+=++=++=+=+*%%*==*%@@@*:%=\\n                     :@:+@@@@@@*+++%@@*+===========+*=========#@@========+#%==========*@========##*#*+=======*@##*======#@#+=======*#*============+#%++#@@%#@@#++=.\\n                      .*+=%@%*%@%##++@@%#=-==-=--==*%=========*%==--=--=-====--=--=-=##=--=-=--%%%%%+=-=--=-=*%=--=--=-=#%=--=----=#%=--=-=--=-+%#+==#%@@*#%@=++.\\n                        +%.#@@###%@@@@@%*---------#@%########@%*---------------------##---------------------##---------%%*--------@@#---------+#@=#@@#+==@@%*++-\\n                        .:*+*%@#+=*%@@@*=-------=#%#=-------=%*---------=*#*--------#+=--------===--------=#%*-------=#%*-------==@%#--------=%@@%#*+=-+#%*+*:.\\n       ====================%*.@@%#==+##%@*=----------------+@#+---------@@*-------=*@+---------@@*--------=@+--------+@=--------*@@+-------+#@@%#==---+#@.*%====================\\n     :*=--==================-:=#@@%*===+*@%+=============%%%@=========*%@*========+@+=--=====+%@+==========@+========+@========*%@@+======%%%**+=---=%@#=:-====================-#-\\n       +++**%@@@#*****************@#*=---=##%@@@@@@@@@@@@@#**@@@@****************%@@*+++@#***********#@************************************+=------=*@#*********************@#+=+:\\n        .-##=*@@%*----------------+%@%=---===+%@@@@@@@*+++---%#++----------------=*@@*+++=-----------=+#=------------------------------------------+%+--------------------+#@-=@\\n         :%:#%#####+=-=-*@@+--=-==-=*@=--=-==-=*@@#*=-==-=-+@===-==-=-=++==-=-==--=@%===-==----+-==-==--+*+-==-==---=*@@@@@@%#===-=-=+%@%-==-=-==-#@%=-==-==--+#@@@@@@@@@@@@*+++\\n        =*=#@#=----==-=-=++=--=-==-=*@=--=-==-=*@@+-=-==-==+@===-=--=-*@@*=-=-==--+@=--=-==--+#@-==-==---+%-==-==---=+++#@@@#--==-=-=++++-=--=-===#%+=-==-==---=++++++++@@@%.#*\\n        +#:@%*===================++%#=========%@%=========#%=========+#@%+=======#%==========*@#=========*%=========+*+%@@@+========+*==========+@@%+**+================*%#*=+=\\n       *++#@*+=++++++*#%*+++++=+++*%%++++=++++%%*=+++++++##*=++++=++=%@@++++=++=+#%++++=++++#%@=+++++++=*#*+++++++=#%@@@@@*++=++++=#%@*+++=++=+++@#*****=+++++++=+++++*%@@+:=+=\\n    :=*=#%#@@@@#%@@@%#@@#++++++++++%%*+++++++++++++++++**@*+++++++++*%#++++++++=*##++++++++*%@%+++++++++##+++++++++#%%%%%%++++**#@@@@@**+++++++++++++++++=*%@@@%#@@@@#%@@@%#@++*:.\\n    #*:@#=-+%#+:=*@*=-+@%#++++++++#%@@#*++++++++++++++#%@#*++++++++*@@#+++++++++@#++++++++*@@#+++++++++##*+++++++++++++++++###@@@@++*@@#+++++++++++++++++++*@@#=:+#%+--+@*=-+%*.@=\\n    ++=#%#+%@@%=#%@%#+%%#++++++*#@@@%###**************@@@++++++++**#@##*********#*********#@@#++++++***@#******%@%#*++**#@@@%##+==+++=*#**********%%*++++++++#%#=%@@%+*%@%*+%#*=*-\\n     .-*+===========*@@+++++*%%%@@@++***************+.%%*++++#%%%@@%=:=******************--@@#+++*%%@#==+***--*@%*++*%@@*===+**=--   -************++@%%#++++++#@@@*==========*+-\\n        =*******##.#%#++++*%@@@%+==+=             *#-%@%**%%###*====**-               -@:*@@##@###*==+**-.-#=+@@#*@##*==+***=                     =+=##%@*+++++*%@@#.#%******:\\n               ++++%#+++*#@@@@+++==.              **-@@@%+++++++===-                 -+++#@@+++++++==:  :+++%@@+++++++==:                          .=++++@%##++++@@%++++\\n             :%:*%%****%@@%+==*-                .%==*====**+...                      #*.#+==***....    #+=#%+==****:.                                ..-*=*%@%#++*#%@=+%.\\n            -+++#%+#%@@@#++===                  .@*++===-                            #%++===           %#+++===                                          =+++%@%##**@@*.@:\\n          .%-=%@##@@%*==++                                                                                                                                 .*==+#@@%*%@%=*=.\\n         .+++#@@@@@*++==.                                                                                                                                    -==++#@@@@@@=+%\\n       .=*=%@@%%%#=*=.                                                                                                                                          .*+=%@@@@%+-#.\\n       @=-@@@%:++++.                                                                                                                                              -+++**@@#+*=:\\n    .-+=*#%%++*::.                                                                                                                                                  :+**=#%@#==#\\n    #*:@*+++=:                                                                                                                                                          =+++@*++=:\\n  :*-=*=++..                                                                                                                                                             .=*=#*.%=\\n +#.=+++:                                                                                                                                                                   ++++:+#\\n*+=#-::                                                                                                                                                                      .::*+=*\\n\\n*/\\n\\ncontract ChainRunnersBaseRenderer is Ownable, ReentrancyGuard {\\n    struct SVGCursor {\\n        uint8 x;\\n        uint8 y;\\n        string color1;\\n        string color2;\\n        string color3;\\n        string color4;\\n    }\\n\\n    struct Buffer {\\n        string one;\\n        string two;\\n        string three;\\n        string four;\\n        string five;\\n        string six;\\n        string seven;\\n        string eight;\\n    }\\n\\n    struct Color {\\n        string hexString;\\n        uint alpha;\\n        uint red;\\n        uint green;\\n        uint blue;\\n    }\\n\\n    struct Layer {\\n        string name;\\n        bytes hexString;\\n    }\\n\\n    struct LayerInput {\\n        string name;\\n        bytes hexString;\\n        uint8 layerIndex;\\n        uint8 itemIndex;\\n    }\\n\\n    uint256 public constant NUM_LAYERS = 13;\\n    uint256 public constant NUM_COLORS = 8;\\n\\n    mapping(uint256 => Layer) [NUM_LAYERS] layers;\\n\\n    /*\\n    This indexes into a race, then a layer index, then an array capturing the frequency each layer should be selected.\\n    Shout out to Anonymice for the rarity impl inspiration.\\n    */\\n    uint16[][NUM_LAYERS][3] WEIGHTS;\\n\\n    constructor() {\\n        // Default\\n        WEIGHTS[0][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\\n        WEIGHTS[0][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\\n        WEIGHTS[0][2] = [303, 303, 303, 303, 151, 30, 0, 0, 151, 151, 151, 151, 30, 303, 151, 30, 303, 303, 303, 303, 303, 303, 30, 151, 303, 303, 303, 303, 303, 303, 303, 303, 3066];\\n        WEIGHTS[0][3] = [645, 0, 1290, 322, 645, 645, 645, 967, 322, 967, 645, 967, 967, 973];\\n        WEIGHTS[0][4] = [0, 0, 0, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250];\\n        WEIGHTS[0][5] = [121, 121, 121, 121, 121, 121, 243, 0, 0, 0, 0, 121, 121, 243, 121, 121, 243, 121, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 121, 121, 243, 121, 121, 243, 0, 0, 0, 121, 121, 243, 121, 121, 306];\\n        WEIGHTS[0][6] = [925, 555, 185, 555, 925, 925, 185, 1296, 1296, 1296, 1857];\\n        WEIGHTS[0][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\\n        WEIGHTS[0][8] = [189, 189, 47, 18, 9, 28, 37, 9483];\\n        WEIGHTS[0][9] = [340, 340, 340, 340, 340, 340, 34, 340, 340, 340, 340, 170, 170, 170, 102, 238, 238, 238, 272, 340, 340, 340, 272, 238, 238, 238, 238, 170, 34, 340, 340, 136, 340, 340, 340, 340, 344];\\n        WEIGHTS[0][10] = [159, 212, 106, 53, 26, 159, 53, 265, 53, 212, 159, 265, 53, 265, 265, 212, 53, 159, 239, 53, 106, 5, 106, 53, 212, 212, 106, 159, 212, 265, 212, 265, 5066];\\n        WEIGHTS[0][11] = [139, 278, 278, 250, 250, 194, 222, 278, 278, 194, 222, 83, 222, 278, 139, 139, 27, 278, 278, 278, 278, 27, 278, 139, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 27, 139, 139, 139, 139, 0, 278, 194, 83, 83, 278, 83, 27, 306];\\n        WEIGHTS[0][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\\n\\n        // Skull\\n        WEIGHTS[1][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\\n        WEIGHTS[1][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\\n        WEIGHTS[1][2] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\\n        WEIGHTS[1][3] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\\n        WEIGHTS[1][4] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\\n        WEIGHTS[1][5] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 7692, 1923, 0, 0, 0, 0, 0, 1];\\n        WEIGHTS[1][6] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10000];\\n        WEIGHTS[1][7] = [0, 0, 0, 0, 0, 909, 0, 9091];\\n        WEIGHTS[1][8] = [0, 0, 0, 0, 0, 0, 0, 10000];\\n        WEIGHTS[1][9] = [526, 526, 526, 0, 0, 0, 0, 0, 526, 0, 0, 0, 526, 0, 526, 0, 0, 0, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 526, 0, 0, 526, 0, 0, 0, 0, 532];\\n        WEIGHTS[1][10] = [80, 0, 400, 240, 80, 0, 240, 0, 0, 80, 80, 80, 0, 0, 0, 0, 80, 80, 0, 0, 80, 80, 0, 80, 80, 80, 80, 80, 0, 0, 0, 0, 8000];\\n        WEIGHTS[1][11] = [289, 0, 0, 0, 0, 404, 462, 578, 578, 0, 462, 173, 462, 578, 0, 0, 57, 0, 57, 0, 57, 57, 578, 289, 578, 57, 0, 57, 57, 57, 578, 578, 0, 0, 0, 0, 0, 0, 57, 289, 578, 0, 0, 0, 231, 57, 0, 0, 1745];\\n        WEIGHTS[1][12] = [714, 714, 714, 0, 714, 0, 0, 0, 7144];\\n\\n        // Bot\\n        WEIGHTS[2][0] = [36, 225, 225, 225, 360, 135, 27, 360, 315, 315, 315, 315, 225, 180, 225, 180, 360, 180, 45, 360, 360, 360, 27, 36, 360, 45, 180, 360, 225, 360, 225, 225, 360, 180, 45, 360, 18, 225, 225, 225, 225, 180, 225, 361];\\n        WEIGHTS[2][1] = [875, 1269, 779, 779, 779, 779, 779, 779, 779, 779, 779, 779, 17, 8, 41];\\n        WEIGHTS[2][2] = [303, 303, 303, 303, 151, 30, 0, 0, 151, 151, 151, 151, 30, 303, 151, 30, 303, 303, 303, 303, 303, 303, 30, 151, 303, 303, 303, 303, 303, 303, 303, 303, 3066];\\n        WEIGHTS[2][3] = [645, 0, 1290, 322, 645, 645, 645, 967, 322, 967, 645, 967, 967, 973];\\n        WEIGHTS[2][4] = [2500, 2500, 2500, 0, 0, 0, 0, 0, 0, 2500, 0];\\n        WEIGHTS[2][5] = [0, 0, 0, 0, 0, 0, 588, 588, 588, 588, 588, 0, 0, 588, 0, 0, 588, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 588, 588, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 588, 0, 0, 0, 0, 0, 0, 0, 0, 588, 0, 0, 4];\\n        WEIGHTS[2][6] = [925, 555, 185, 555, 925, 925, 185, 1296, 1296, 1296, 1857];\\n        WEIGHTS[2][7] = [88, 88, 88, 88, 88, 265, 442, 8853];\\n        WEIGHTS[2][8] = [183, 274, 274, 18, 18, 27, 36, 9170];\\n        WEIGHTS[2][9] = [340, 340, 340, 340, 340, 340, 34, 340, 340, 340, 340, 170, 170, 170, 102, 238, 238, 238, 272, 340, 340, 340, 272, 238, 238, 238, 238, 170, 34, 340, 340, 136, 340, 340, 340, 340, 344];\\n        WEIGHTS[2][10] = [217, 362, 217, 144, 72, 289, 144, 362, 72, 289, 217, 362, 72, 362, 362, 289, 0, 217, 0, 72, 144, 7, 217, 72, 217, 217, 289, 217, 289, 362, 217, 362, 3269];\\n        WEIGHTS[2][11] = [139, 278, 278, 250, 250, 194, 222, 278, 278, 194, 222, 83, 222, 278, 139, 139, 27, 278, 278, 278, 278, 27, 278, 139, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 27, 139, 139, 139, 139, 0, 278, 194, 83, 83, 278, 83, 27, 306];\\n        WEIGHTS[2][12] = [981, 2945, 654, 16, 981, 327, 654, 163, 3279];\\n    }\\n\\n    function setLayers(LayerInput[] calldata toSet) external onlyOwner {\\n        for (uint16 i = 0; i < toSet.length; i++) {\\n            layers[toSet[i].layerIndex][toSet[i].itemIndex] = Layer(toSet[i].name, toSet[i].hexString);\\n        }\\n    }\\n\\n    function getLayer(uint8 layerIndex, uint8 itemIndex) public view returns (Layer memory) {\\n        return layers[layerIndex][itemIndex];\\n    }\\n\\n    /*\\n    Get race index.  Race index represents the \\\"type\\\" of base character:\\n\\n    0 - Default, representing human and alien characters\\n    1 - Skull\\n    2 - Bot\\n\\n    This allows skull/bot characters to have distinct trait distributions.\\n    */\\n    function getRaceIndex(uint16 _dna) public view returns (uint8) {\\n        uint16 lowerBound;\\n        uint16 percentage;\\n        for (uint8 i; i < WEIGHTS[0][1].length; i++) {\\n            percentage = WEIGHTS[0][1][i];\\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\\n                if (i == 1) {\\n                    // Bot\\n                    return 2;\\n                } else if (i > 11) {\\n                    // Skull\\n                    return 1;\\n                } else {\\n                    // Default\\n                    return 0;\\n                }\\n            }\\n            lowerBound += percentage;\\n        }\\n        revert();\\n    }\\n\\n    function getLayerIndex(uint16 _dna, uint8 _index, uint16 _raceIndex) public view returns (uint) {\\n        uint16 lowerBound;\\n        uint16 percentage;\\n        for (uint8 i; i < WEIGHTS[_raceIndex][_index].length; i++) {\\n            percentage = WEIGHTS[_raceIndex][_index][i];\\n            if (_dna >= lowerBound && _dna < lowerBound + percentage) {\\n                return i;\\n            }\\n            lowerBound += percentage;\\n        }\\n        // If not found, return index higher than available layers.  Will get filtered out.\\n        return WEIGHTS[_raceIndex][_index].length;\\n    }\\n\\n    /*\\n    Generate base64 encoded tokenURI.\\n\\n    All string constants are pre-base64 encoded to save gas.\\n    Input strings are padded with spacing/etc to ensure their length is a multiple of 3.\\n    This way the resulting base64 encoded string is a multiple of 4 and will not include any '=' padding characters,\\n    which allows these base64 string snippets to be concatenated with other snippets.\\n    */\\n    function tokenURI(uint256 tokenId, ChainRunnersTypes.ChainRunner memory runnerData) public view returns (string memory) {\\n        (Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string[NUM_LAYERS] memory traitTypes) = getTokenData(runnerData.dna);\\n        string memory attributes;\\n        for (uint8 i = 0; i < numTokenLayers; i++) {\\n            attributes = string(abi.encodePacked(attributes,\\n                bytes(attributes).length == 0 ? 'eyAg' : 'LCB7',\\n                'InRyYWl0X3R5cGUiOiAi', traitTypes[i], 'IiwidmFsdWUiOiAi', tokenLayers[i].name, 'IiB9'\\n                ));\\n        }\\n        string[4] memory svgBuffers = tokenSVGBuffer(tokenLayers, tokenPalettes, numTokenLayers);\\n        return string(abi.encodePacked(\\n                'data:application/json;base64,eyAgImltYWdlX2RhdGEiOiAiPHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMjAgMzIwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHNoYXBlLXJlbmRlcmluZz0nY3Jpc3BFZGdlcyc+',\\n                svgBuffers[0], svgBuffers[1], svgBuffers[2], svgBuffers[3],\\n                'PHN0eWxlPnJlY3R7d2lkdGg6MTBweDtoZWlnaHQ6MTBweDt9PC9zdHlsZT48L3N2Zz4gIiwgImF0dHJpYnV0ZXMiOiBb',\\n                attributes,\\n                'XSwgICAibmFtZSI6IlJ1bm5lciAj',\\n                Base64.encode(uintToByteString(tokenId, 6)),\\n                'IiwgImRlc2NyaXB0aW9uIjogIkNoYWluIFJ1bm5lcnMgYXJlIE1lZ2EgQ2l0eSByZW5lZ2FkZXMgMTAwJSBnZW5lcmF0ZWQgb24gY2hhaW4uIn0g'\\n            ));\\n    }\\n\\n    function tokenSVG(uint256 _dna) public view returns (string memory) {\\n        (Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string[NUM_LAYERS] memory traitTypes) = getTokenData(_dna);\\n        string[4] memory buffer256 = tokenSVGBuffer(tokenLayers, tokenPalettes, numTokenLayers);\\n        return string(abi.encodePacked(\\n                \\\"PHN2ZyB2ZXJzaW9uPScxLjEnIHZpZXdCb3g9JzAgMCAzMiAzMicgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBzaGFwZS1yZW5kZXJpbmc9J2NyaXNwRWRnZXMnIGhlaWdodD0nMTAwJScgd2lkdGg9JzEwMCUnICA+\\\",\\n                buffer256[0], buffer256[1], buffer256[2], buffer256[3],\\n                \\\"PHN0eWxlPnJlY3R7d2lkdGg6MXB4O2hlaWdodDoxcHg7fTwvc3R5bGU+PC9zdmc+\\\"\\n            )\\n        );\\n    }\\n\\n    function getTokenData(uint256 _dna) public view returns (Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers, string [NUM_LAYERS] memory traitTypes) {\\n        uint16[NUM_LAYERS] memory dna = splitNumber(_dna);\\n        uint16 raceIndex = getRaceIndex(dna[1]);\\n\\n        bool hasFaceAcc = dna[7] < (10000 - WEIGHTS[raceIndex][7][7]);\\n        bool hasMask = dna[8] < (10000 - WEIGHTS[raceIndex][8][7]);\\n        bool hasHeadBelow = dna[9] < (10000 - WEIGHTS[raceIndex][9][36]);\\n        bool hasHeadAbove = dna[11] < (10000 - WEIGHTS[raceIndex][11][48]);\\n        bool useHeadAbove = (dna[0] % 2) > 0;\\n        for (uint8 i = 0; i < NUM_LAYERS; i ++) {\\n            Layer memory layer = layers[i][getLayerIndex(dna[i], i, raceIndex)];\\n            if (layer.hexString.length > 0) {\\n                /*\\n                These conditions help make sure layer selection meshes well visually.\\n                1. If mask, no face/eye acc/mouth acc\\n                2. If face acc, no mask/mouth acc/face\\n                3. If both head above & head below, randomly choose one\\n                */\\n                if (((i == 2 || i == 12) && !hasMask && !hasFaceAcc) || (i == 7 && !hasMask) || (i == 10 && !hasMask) || (i < 2 || (i > 2 && i < 7) || i == 8 || i == 9 || i == 11)) {\\n                    if (hasHeadBelow && hasHeadAbove && (i == 9 && useHeadAbove) || (i == 11 && !useHeadAbove)) continue;\\n                    tokenLayers[numTokenLayers] = layer;\\n                    tokenPalettes[numTokenLayers] = palette(tokenLayers[numTokenLayers].hexString);\\n                    traitTypes[numTokenLayers] = [\\\"QmFja2dyb3VuZCAg\\\",\\\"UmFjZSAg\\\",\\\"RmFjZSAg\\\",\\\"TW91dGgg\\\",\\\"Tm9zZSAg\\\",\\\"RXllcyAg\\\",\\\"RWFyIEFjY2Vzc29yeSAg\\\",\\\"RmFjZSBBY2Nlc3Nvcnkg\\\",\\\"TWFzayAg\\\",\\\"SGVhZCBCZWxvdyAg\\\",\\\"RXllIEFjY2Vzc29yeSAg\\\",\\\"SGVhZCBBYm92ZSAg\\\",\\\"TW91dGggQWNjZXNzb3J5\\\"][i];\\n                    numTokenLayers++;\\n                }\\n            }\\n        }\\n        return (tokenLayers, tokenPalettes, numTokenLayers, traitTypes);\\n    }\\n\\n    /*\\n    Generate svg rects, leaving un-concatenated to save a redundant concatenation in calling functions to reduce gas.\\n    Shout out to Blitmap for a lot of the inspiration for efficient rendering here.\\n    */\\n    function tokenSVGBuffer(Layer [NUM_LAYERS] memory tokenLayers, Color [NUM_COLORS][NUM_LAYERS] memory tokenPalettes, uint8 numTokenLayers) public pure returns (string[4] memory) {\\n        // Base64 encoded lookups into x/y position strings from 010 to 310.\\n        string[32] memory lookup = [\\\"MDAw\\\", \\\"MDEw\\\", \\\"MDIw\\\", \\\"MDMw\\\", \\\"MDQw\\\", \\\"MDUw\\\", \\\"MDYw\\\", \\\"MDcw\\\", \\\"MDgw\\\", \\\"MDkw\\\", \\\"MTAw\\\", \\\"MTEw\\\", \\\"MTIw\\\", \\\"MTMw\\\", \\\"MTQw\\\", \\\"MTUw\\\", \\\"MTYw\\\", \\\"MTcw\\\", \\\"MTgw\\\", \\\"MTkw\\\", \\\"MjAw\\\", \\\"MjEw\\\", \\\"MjIw\\\", \\\"MjMw\\\", \\\"MjQw\\\", \\\"MjUw\\\", \\\"MjYw\\\", \\\"Mjcw\\\", \\\"Mjgw\\\", \\\"Mjkw\\\", \\\"MzAw\\\", \\\"MzEw\\\"];\\n        SVGCursor memory cursor;\\n\\n        /*\\n        Rather than concatenating the result string with itself over and over (e.g. result = abi.encodePacked(result, newString)),\\n        we fill up multiple levels of buffers.  This reduces redundant intermediate concatenations, performing O(log(n)) concats\\n        instead of O(n) concats.  Buffers beyond a length of about 12 start hitting stack too deep issues, so using a length of 8\\n        because the pixel math is convenient.\\n        */\\n        Buffer memory buffer4;\\n        // 4 pixels per slot, 32 total.  Struct is ever so slightly better for gas, so using when convenient.\\n        string[8] memory buffer32;\\n        // 32 pixels per slot, 256 total\\n        string[4] memory buffer256;\\n        // 256 pixels per slot, 1024 total\\n        uint8 buffer32count;\\n        uint8 buffer256count;\\n        for (uint k = 32; k < 416;) {\\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\\n            buffer4.one = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\\n            buffer4.two = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            k += 3;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\\n            buffer4.three = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\\n            buffer4.four = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            k += 3;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\\n            buffer4.five = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\\n            buffer4.six = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            k += 3;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 0, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 1, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 2, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 3, tokenPalettes, numTokenLayers);\\n            buffer4.seven = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            cursor.color1 = colorForIndex(tokenLayers, k, 4, tokenPalettes, numTokenLayers);\\n            cursor.color2 = colorForIndex(tokenLayers, k, 5, tokenPalettes, numTokenLayers);\\n            cursor.color3 = colorForIndex(tokenLayers, k, 6, tokenPalettes, numTokenLayers);\\n            cursor.color4 = colorForIndex(tokenLayers, k, 7, tokenPalettes, numTokenLayers);\\n            buffer4.eight = pixel4(lookup, cursor);\\n            cursor.x += 4;\\n\\n            k += 3;\\n\\n            buffer32[buffer32count++] = string(abi.encodePacked(buffer4.one, buffer4.two, buffer4.three, buffer4.four, buffer4.five, buffer4.six, buffer4.seven, buffer4.eight));\\n            cursor.x = 0;\\n            cursor.y += 1;\\n            if (buffer32count >= 8) {\\n                buffer256[buffer256count++] = string(abi.encodePacked(buffer32[0], buffer32[1], buffer32[2], buffer32[3], buffer32[4], buffer32[5], buffer32[6], buffer32[7]));\\n                buffer32count = 0;\\n            }\\n        }\\n        // At this point, buffer256 contains 4 strings or 256*4=1024=32x32 pixels\\n        return buffer256;\\n    }\\n\\n    function palette(bytes memory data) internal pure returns (Color [NUM_COLORS] memory) {\\n        Color [NUM_COLORS] memory colors;\\n        for (uint16 i = 0; i < NUM_COLORS; i++) {\\n            // Even though this can be computed later from the RGBA values below, it saves gas to pre-compute it once upfront.\\n            colors[i].hexString = Base64.encode(bytes(abi.encodePacked(\\n                    byteToHexString(data[i * 4]),\\n                    byteToHexString(data[i * 4 + 1]),\\n                    byteToHexString(data[i * 4 + 2])\\n                )));\\n            colors[i].red = byteToUint(data[i * 4]);\\n            colors[i].green = byteToUint(data[i * 4 + 1]);\\n            colors[i].blue = byteToUint(data[i * 4 + 2]);\\n            colors[i].alpha = byteToUint(data[i * 4 + 3]);\\n        }\\n        return colors;\\n    }\\n\\n    function colorForIndex(Layer[NUM_LAYERS] memory tokenLayers, uint k, uint index, Color [NUM_COLORS][NUM_LAYERS] memory palettes, uint numTokenLayers) internal pure returns (string memory) {\\n        for (uint256 i = numTokenLayers - 1; i >= 0; i--) {\\n            Color memory fg = palettes[i][colorIndex(tokenLayers[i].hexString, k, index)];\\n            // Since most layer pixels are transparent, performing this check first saves gas\\n            if (fg.alpha == 0) {\\n                continue;\\n            } else if (fg.alpha == 255) {\\n                return fg.hexString;\\n            } else {\\n                for (uint256 j = i - 1; j >= 0; j--) {\\n                    Color memory bg = palettes[j][colorIndex(tokenLayers[j].hexString, k, index)];\\n                    /* As a simplification, blend with first non-transparent layer then stop.\\n                    We won't generally have overlapping semi-transparent pixels.\\n                    */\\n                    if (bg.alpha > 0) {\\n                        return Base64.encode(bytes(blendColors(fg, bg)));\\n                    }\\n                }\\n            }\\n        }\\n        return \\\"000000\\\";\\n    }\\n\\n    /*\\n    Each color index is 3 bits (there are 8 colors, so 3 bits are needed to index into them).\\n    Since 3 bits doesn't divide cleanly into 8 bits (1 byte), we look up colors 24 bits (3 bytes) at a time.\\n    \\\"k\\\" is the starting byte index, and \\\"index\\\" is the color index within the 3 bytes starting at k.\\n    */\\n    function colorIndex(bytes memory data, uint k, uint index) internal pure returns (uint8) {\\n        if (index == 0) {\\n            return uint8(data[k]) >> 5;\\n        } else if (index == 1) {\\n            return (uint8(data[k]) >> 2) % 8;\\n        } else if (index == 2) {\\n            return ((uint8(data[k]) % 4) * 2) + (uint8(data[k + 1]) >> 7);\\n        } else if (index == 3) {\\n            return (uint8(data[k + 1]) >> 4) % 8;\\n        } else if (index == 4) {\\n            return (uint8(data[k + 1]) >> 1) % 8;\\n        } else if (index == 5) {\\n            return ((uint8(data[k + 1]) % 2) * 4) + (uint8(data[k + 2]) >> 6);\\n        } else if (index == 6) {\\n            return (uint8(data[k + 2]) >> 3) % 8;\\n        } else {\\n            return uint8(data[k + 2]) % 8;\\n        }\\n    }\\n\\n    /*\\n    Create 4 svg rects, pre-base64 encoding the svg constants to save gas.\\n    */\\n    function pixel4(string[32] memory lookup, SVGCursor memory cursor) internal pure returns (string memory result) {\\n        return string(abi.encodePacked(\\n                \\\"PHJlY3QgICBmaWxsPScj\\\", cursor.color1, \\\"JyAgeD0n\\\", lookup[cursor.x], \\\"JyAgeT0n\\\", lookup[cursor.y],\\n                \\\"JyAvPjxyZWN0ICBmaWxsPScj\\\", cursor.color2, \\\"JyAgeD0n\\\", lookup[cursor.x + 1], \\\"JyAgeT0n\\\", lookup[cursor.y],\\n                \\\"JyAvPjxyZWN0ICBmaWxsPScj\\\", cursor.color3, \\\"JyAgeD0n\\\", lookup[cursor.x + 2], \\\"JyAgeT0n\\\", lookup[cursor.y],\\n                \\\"JyAvPjxyZWN0ICBmaWxsPScj\\\", cursor.color4, \\\"JyAgeD0n\\\", lookup[cursor.x + 3], \\\"JyAgeT0n\\\", lookup[cursor.y], \\\"JyAgIC8+\\\"\\n            ));\\n    }\\n\\n    /*\\n    Blend colors, inspired by https://stackoverflow.com/a/12016968\\n    */\\n    function blendColors(Color memory fg, Color memory bg) internal pure returns (string memory) {\\n        uint alpha = uint16(fg.alpha + 1);\\n        uint inv_alpha = uint16(256 - fg.alpha);\\n        return uintToHexString6(uint24((alpha * fg.blue + inv_alpha * bg.blue) >> 8) + (uint24((alpha * fg.green + inv_alpha * bg.green) >> 8) << 8) + (uint24((alpha * fg.red + inv_alpha * bg.red) >> 8) << 16));\\n    }\\n\\n    function splitNumber(uint256 _number) internal pure returns (uint16[NUM_LAYERS] memory numbers) {\\n        for (uint256 i = 0; i < numbers.length; i++) {\\n            numbers[i] = uint16(_number % 10000);\\n            _number >>= 14;\\n        }\\n        return numbers;\\n    }\\n\\n    function uintToHexDigit(uint8 d) public pure returns (bytes1) {\\n        if (0 <= d && d <= 9) {\\n            return bytes1(uint8(bytes1('0')) + d);\\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\\n            return bytes1(uint8(bytes1('a')) + d - 10);\\n        }\\n        revert();\\n    }\\n\\n    /*\\n    Convert uint to hex string, padding to 6 hex nibbles\\n    */\\n    function uintToHexString6(uint a) public pure returns (string memory) {\\n        string memory str = uintToHexString2(a);\\n        if (bytes(str).length == 2) {\\n            return string(abi.encodePacked(\\\"0000\\\", str));\\n        } else if (bytes(str).length == 3) {\\n            return string(abi.encodePacked(\\\"000\\\", str));\\n        } else if (bytes(str).length == 4) {\\n            return string(abi.encodePacked(\\\"00\\\", str));\\n        } else if (bytes(str).length == 5) {\\n            return string(abi.encodePacked(\\\"0\\\", str));\\n        }\\n        return str;\\n    }\\n\\n    /*\\n    Convert uint to hex string, padding to 2 hex nibbles\\n    */\\n    function uintToHexString2(uint a) public pure returns (string memory) {\\n        uint count = 0;\\n        uint b = a;\\n        while (b != 0) {\\n            count++;\\n            b /= 16;\\n        }\\n        bytes memory res = new bytes(count);\\n        for (uint i = 0; i < count; ++i) {\\n            b = a % 16;\\n            res[count - i - 1] = uintToHexDigit(uint8(b));\\n            a /= 16;\\n        }\\n\\n        string memory str = string(res);\\n        if (bytes(str).length == 0) {\\n            return \\\"00\\\";\\n        } else if (bytes(str).length == 1) {\\n            return string(abi.encodePacked(\\\"0\\\", str));\\n        }\\n        return str;\\n    }\\n\\n    /*\\n    Convert uint to byte string, padding number string with spaces at end.\\n    Useful to ensure result's length is a multiple of 3, and therefore base64 encoding won't\\n    result in '=' padding chars.\\n    */\\n    function uintToByteString(uint a, uint fixedLen) internal pure returns (bytes memory _uintAsString) {\\n        uint j = a;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(fixedLen);\\n        j = fixedLen;\\n        if (a == 0) {\\n            bstr[0] = \\\"0\\\";\\n            len = 1;\\n        }\\n        while (j > len) {\\n            j = j - 1;\\n            bstr[j] = bytes1(' ');\\n        }\\n        uint k = len;\\n        while (a != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(a - a / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            a /= 10;\\n        }\\n        return bstr;\\n    }\\n\\n    function byteToUint(bytes1 b) public pure returns (uint) {\\n        return uint(uint8(b));\\n    }\\n\\n    function byteToHexString(bytes1 b) public pure returns (string memory) {\\n        return uintToHexString2(byteToUint(b));\\n    }\\n}\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ChainRunnersTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\ninterface ChainRunnersTypes {\\n    struct ChainRunner {\\n        uint256 dna;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NUM_COLORS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUM_LAYERS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes1\",\"name\":\"b\",\"type\":\"bytes1\"}],\"name\":\"byteToHexString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes1\",\"name\":\"b\",\"type\":\"bytes1\"}],\"name\":\"byteToUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"layerIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"itemIndex\",\"type\":\"uint8\"}],\"name\":\"getLayer\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"hexString\",\"type\":\"bytes\"}],\"internalType\":\"struct ChainRunnersBaseRenderer.Layer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dna\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_index\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"_raceIndex\",\"type\":\"uint16\"}],\"name\":\"getLayerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dna\",\"type\":\"uint16\"}],\"name\":\"getRaceIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getTokenData\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"hexString\",\"type\":\"bytes\"}],\"internalType\":\"struct ChainRunnersBaseRenderer.Layer[13]\",\"name\":\"tokenLayers\",\"type\":\"tuple[13]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"hexString\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blue\",\"type\":\"uint256\"}],\"internalType\":\"struct ChainRunnersBaseRenderer.Color[8][13]\",\"name\":\"tokenPalettes\",\"type\":\"tuple[8][13]\"},{\"internalType\":\"uint8\",\"name\":\"numTokenLayers\",\"type\":\"uint8\"},{\"internalType\":\"string[13]\",\"name\":\"traitTypes\",\"type\":\"string[13]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"hexString\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"layerIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"itemIndex\",\"type\":\"uint8\"}],\"internalType\":\"struct ChainRunnersBaseRenderer.LayerInput[]\",\"name\":\"toSet\",\"type\":\"tuple[]\"}],\"name\":\"setLayers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"tokenSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"hexString\",\"type\":\"bytes\"}],\"internalType\":\"struct ChainRunnersBaseRenderer.Layer[13]\",\"name\":\"tokenLayers\",\"type\":\"tuple[13]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"hexString\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blue\",\"type\":\"uint256\"}],\"internalType\":\"struct ChainRunnersBaseRenderer.Color[8][13]\",\"name\":\"tokenPalettes\",\"type\":\"tuple[8][13]\"},{\"internalType\":\"uint8\",\"name\":\"numTokenLayers\",\"type\":\"uint8\"}],\"name\":\"tokenSVGBuffer\",\"outputs\":[{\"internalType\":\"string[4]\",\"name\":\"\",\"type\":\"string[4]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"}],\"internalType\":\"struct ChainRunnersTypes.ChainRunner\",\"name\":\"runnerData\",\"type\":\"tuple\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"d\",\"type\":\"uint8\"}],\"name\":\"uintToHexDigit\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"uintToHexString2\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"uintToHexString6\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ChainRunnersBaseRenderer","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}