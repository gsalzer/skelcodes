{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IValidator {\r\n    // returns rate (with 18 decimals) = Token B price / Token A price\r\n    function getRate(address tokenA, address tokenB) external returns (uint256);\r\n    // returns: user balance, native (foreign for us) encoded balance, foreign (native for us) encoded balance\r\n    function checkBalances(address factory, address[] calldata user) external returns(uint256);\r\n    // returns: user balance\r\n    function checkBalance(address factory, address user) external returns(uint256);\r\n    // returns: oracle fee\r\n    function getOracleFee(uint256 req) external returns(uint256);  //req: 1 - cancel, 2 - claim, returns: value\r\n}\r\n\r\ninterface IReimbursement {\r\n    // returns fee percentage with 2 decimals\r\n    function getLicenseeFee(address vault, address projectContract) external view returns(uint256);\r\n    // returns fee receiver address or address(0) if need to refund fee to user.\r\n    function requestReimbursement(address user, uint256 feeAmount, address vault) external returns(address);\r\n}\r\n\r\ninterface ISPImplementation {\r\n    function initialize(\r\n        address _owner,     // contract owner\r\n        address _nativeToken, // native token that will be send to SmartSwap\r\n        address _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\r\n        address _nativeTokenReceiver, // address on Binance to deposit native token\r\n        address _foreignTokenReceiver, // address on Binance to deposit foreign token\r\n        uint256 _feeAmountLimit // limit of amount that System withdraw for fee reimbursement\r\n    )   external;\r\n    function owner() external returns(address);\r\n}\r\n\r\ninterface IAuction {\r\n    function contributeFromSmartSwap(address payable user) external payable returns (bool);\r\n    function contributeFromSmartSwap(address token, uint256 amount, address user) external returns (bool);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n/*  we use proxy, so owner will be set in initialize() function\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n*/\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract SmartSwap is Ownable {\r\n\r\n    struct Cancel {\r\n        uint64 pairID; // pair ID\r\n        address sender; // user who has to receive canceled amount\r\n        uint256 amount; // amount of token user want to cancel from order\r\n        //uint128 foreignBalance; // amount of token already swapped (on other chain)\r\n    }\r\n\r\n    struct Claim {\r\n        uint64 pairID;     // pair ID\r\n        address sender;     // address who send tokens to swap\r\n        address receiver;   // address who has to receive swapped amount\r\n        uint64 claimID;     // uniq claim ID\r\n        bool isInvestment;  // is claim to contributeFromSmartSwap\r\n        uint128 amount;     // amount of foreign tokens user want to swap\r\n        uint128 currentRate;\r\n        uint256 foreignBalance;  //[0] foreignBalance, [1] foreignSpent, [2] nativeSpent, [3] nativeRate\r\n    }\r\n\r\n    struct Pair {\r\n        address tokenA;\r\n        address tokenB;        \r\n    }\r\n\r\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 1 - BNB, 2 - ETH, 3 - BTC\r\n    uint256 constant NOMINATOR = 10**18;\r\n    uint256 constant MAX_AMOUNT = 2**128;\r\n\r\n    address public foreignFactory;\r\n    address payable public validator;\r\n    uint256 public rateDiffLimit;   // allowed difference (in percent) between LP provided rate and Oracle rate.\r\n    mapping(address => bool) public isSystem;  // system address mey change fee amount\r\n    address public auction; // auction address\r\n    address public contractSmart;  // the reimbursement contract address\r\n    mapping (address => uint256) licenseeFee;  // NOT USED. the licensee may set personal fee (in percent wih 2 decimals). It have to compensate this fee with own tokens.\r\n    mapping (address => address) licenseeCompensator;    // NOT USED. licensee contract which will compensate fee with tokens\r\n \r\n    mapping(address => bool) public isExchange;         // is Exchange address\r\n    mapping(address => bool) public isExcludedSender;   // address excluded from receiving SMART token as fee compensation\r\n\r\n    // fees\r\n    uint256 public swapGasReimbursement;      // percentage of swap Gas Reimbursement by SMART tokens\r\n    uint256 public companyFeeReimbursement;   // percentage of company Fee Reimbursement by SMART tokens\r\n    uint256 public cancelGasReimbursement;    // percentage of cancel Gas Reimbursement by SMART tokens\r\n    uint256 public companyFee; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\r\n    uint256 public processingFee; // the fee in base coin, to compensate Gas when back-end call claimTokenBehalf()\r\n    address public feeReceiver; // address which receive the fee (by default is validator)\r\n    uint256 private collectedFees; // amount of collected fee (starts from 1 to avoid additional gas usage)\r\n\r\n    mapping(address => uint256) public decimals;   // token address => token decimals\r\n    uint256 public pairIDCounter;\r\n    mapping(uint256 => Pair) public getPairByID;\r\n    mapping(address => mapping(address => uint256)) public getPairID;    // tokenA => tokenB => pair ID or 0 if not exist\r\n    mapping(uint256 => uint256) public totalSupply;    // pairID => totalSupply amount of tokenA on the pair\r\n\r\n    // hashAddress = address(keccak256(tokenA, tokenB, sender, receiver))\r\n    mapping(address => uint256) private _balanceOf;       // hashAddress => amount of tokenA\r\n    mapping(address => Cancel) public cancelRequest;    // hashAddress => amount of tokenA to cancel\r\n    mapping(address => Claim) public claimRequest;      // hashAddress => amount of tokenA to swap\r\n\r\n    mapping(address => bool) public isLiquidityProvider;    // NOT USED. list of Liquidity Providers\r\n    uint256 claimIdCounter;    // counter of claim requests\r\n    address public reimbursementVault;  //company vault address in reimbursement contract\r\n    address public SPImplementation;  // address of swap provider contract implementation\r\n    uint256 public companySPFee; // the fee (in percent wih 2 decimals) that received by company from Swap provider. 30 - means 0.3%\r\n\r\n// ============================ Events ============================\r\n\r\n    event PairAdded(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\r\n    event PairRemoved(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\r\n    event SwapRequest(\r\n        address indexed tokenA,\r\n        address indexed tokenB,\r\n        address indexed sender,\r\n        address receiver,\r\n        uint256 amountA,\r\n        bool isInvestment,\r\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\r\n        uint128 limitPice   // Do not match user if token A price less this limit\r\n    );\r\n    event CancelRequest(address indexed hashAddress, uint256 amount);\r\n    event CancelApprove(address indexed hashAddress, uint256 newBalance);\r\n    event ClaimRequest(address indexed hashAddress, uint64 claimID, uint256 amount, bool isInvestment);\r\n    event ClaimApprove(address indexed hashAddress, uint64 claimID, uint256 nativeAmount, uint256 foreignAmount, bool isInvestment);\r\n    event ExchangeInvestETH(address indexed exchange, address indexed whom, uint256 value);\r\n    event SetSystem(address indexed system, bool active);\r\n    event AddSwapProvider(address swapProvider, address spContract);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the system.\r\n    */\r\n    modifier onlySystem() {\r\n        require(isSystem[msg.sender] || owner() == msg.sender, \"Caller is not the system\");\r\n        _;\r\n    }\r\n\r\n\r\n    // run only once from proxy\r\n    function initialize(address newOwner) external {\r\n        require(newOwner != address(0) && _owner == address(0)); // run only once\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n        rateDiffLimit = 5;   // allowed difference (in percent) between LP provided rate and Oracle rate.\r\n        swapGasReimbursement = 100;      // percentage of swap Gas Reimbursement by SMART tokens\r\n        companyFeeReimbursement = 100;   // percentage of company Fee Reimbursement by SMART tokens\r\n        cancelGasReimbursement = 100;    // percentage of cancel Gas Reimbursement by SMART tokens\r\n        companyFee = 0; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\r\n        collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\r\n    }\r\n\r\n    // get amount of collected fees that can be claimed\r\n    function getColletedFees() external view returns (uint256) {\r\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\r\n        return collectedFees - 1;\r\n    }\r\n\r\n    // claim fees by feeReceiver\r\n    function claimFee() external returns (uint256 feeAmount)\r\n    {\r\n        require(msg.sender == feeReceiver);\r\n        feeAmount = collectedFees - 1;\r\n        collectedFees = 1;        \r\n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\r\n    }\r\n\r\n    function balanceOf(address hashAddress) external view returns(uint256) {\r\n        return _balanceOf[hashAddress];\r\n    }\r\n\r\n    // return balance for swap\r\n    function getBalance(\r\n        address tokenA,\r\n        address tokenB, \r\n        address sender,\r\n        address receiver\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _balanceOf[_getHashAddress(tokenA, tokenB, sender, receiver)];\r\n    }\r\n\r\n    function getHashAddress(\r\n        address tokenA,\r\n        address tokenB, \r\n        address sender,\r\n        address receiver\r\n    )\r\n        external\r\n        pure\r\n        returns (address)\r\n    {\r\n        return _getHashAddress(tokenA, tokenB, sender, receiver);\r\n    }\r\n\r\n    //user should approve tokens transfer before calling this function.\r\n    //if no licensee set it to address(0)\r\n    function swap(\r\n        address tokenA, // token that user send to swap ( address(1) for BNB, address(2) for ETH)\r\n        address tokenB, // token that user want to receive ( address(1) for BNB, address(2) for ETH)\r\n        address receiver,   // address that will receive tokens on other chain (user's wallet address)\r\n        uint256 amountA,    // amount of tokens user sends to swap\r\n        address licensee,   // for now, = address(0)\r\n        bool isInvestment,  // for now, = false\r\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled. For now, = 0\r\n        uint128 limitPice   // Do not match user if token A price less this limit. For now, = 0\r\n    )\r\n        external\r\n        payable\r\n        returns (bool)\r\n    {\r\n        _transferFee(tokenA, amountA, msg.sender, licensee);\r\n        _swap(tokenA, tokenB, msg.sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\r\n        return true;\r\n    }\r\n\r\n    function cancel(\r\n        address tokenA,\r\n        address tokenB, \r\n        address receiver,\r\n        uint256 amountA    //amount of tokenA to cancel\r\n    )\r\n        external\r\n        payable\r\n        returns (bool)\r\n    {\r\n        _cancel(tokenA, tokenB, msg.sender, receiver, amountA);\r\n        return true;\r\n    }\r\n\r\n    function cancelBehalf(\r\n        address tokenA,\r\n        address tokenB,\r\n        address sender,\r\n        address receiver,\r\n        uint256 amountA    //amount of tokenA to cancel\r\n    )\r\n        external\r\n        onlySystem\r\n        returns (bool)\r\n    {\r\n        _cancel(tokenA, tokenB, sender, receiver, amountA);\r\n        return true;\r\n    }\r\n\r\n    function claimTokenBehalf(\r\n        address tokenA, // foreignToken\r\n        address tokenB, // nativeToken\r\n        address sender,\r\n        address receiver,\r\n        bool isInvestment,\r\n        uint128 amountA,    //amount of tokenA that has to be swapped\r\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\r\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\r\n    )        \r\n        external\r\n        onlySystem\r\n        returns (bool) \r\n    {\r\n        _claimTokenBehalf(tokenA, tokenB, sender, receiver, isInvestment, amountA, currentRate, foreignBalance);\r\n        return true;\r\n    }\r\n\r\n    // add swap provider who will provide liquidity for swap (using centralized exchange)\r\n    function addSwapProvider(\r\n        address _nativeToken, // native token that will be send to SmartSwap\r\n        address _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\r\n        address _nativeTokenReceiver, // address on Binance to deposit native token\r\n        address _foreignTokenReceiver, // address on Binance to deposit foreign token\r\n        uint256 _feeAmountLimit // limit of amount that System may withdraw for fee reimbursement\r\n    )\r\n        external\r\n        returns (address spContract)\r\n    {\r\n        spContract = clone(SPImplementation);\r\n        ISPImplementation(spContract).initialize(\r\n            msg.sender,\r\n            _nativeToken,\r\n            _foreignToken,\r\n            _nativeTokenReceiver,\r\n            _foreignTokenReceiver,\r\n            _feeAmountLimit\r\n        );\r\n        isSystem[spContract] = true;\r\n        emit AddSwapProvider(msg.sender, spContract);\r\n    }\r\n\r\n    function balanceCallback(address hashAddress, uint256 foreignBalance) external returns(bool) {\r\n        require (validator == msg.sender, \"Not validator\");\r\n        _cancelApprove(hashAddress, foreignBalance);\r\n        return true;\r\n    }\r\n\r\n    function balancesCallback(\r\n        address hashAddress, \r\n        uint256 foreignBalance, // total user's tokens balance on foreign chain\r\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\r\n        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)\r\n    ) \r\n        external \r\n        returns(bool) \r\n    {\r\n        require (validator == msg.sender, \"Not validator\");\r\n        _claimBehalfApprove(hashAddress, foreignBalance, foreignSpent, nativeEncoded);\r\n        return true;\r\n    }\r\n\r\n    // get system variables for debugging \r\n    function getPairVars(uint256 pairID) external view returns (uint256 native, uint256 foreign, uint256 foreignRate) {\r\n        address nativeHash = _getHashAddress(getPairByID[pairID].tokenA, getPairByID[pairID].tokenB, address(0), address(0));\r\n        address foreignHash = _getHashAddress(getPairByID[pairID].tokenB, getPairByID[pairID].tokenA, address(0), address(0));\r\n        // native - amount of native tokens that swapped from available foreign\r\n        native = _balanceOf[nativeHash];\r\n        // foreign = total foreign tokens already swapped\r\n        // foreignRate = rate (native price / foreign price) of available foreign tokens on other chain\r\n        (foreignRate, foreign) = _decode(_balanceOf[foreignHash]);\r\n        // Example: assume system vars = 0, rate of prices ETH/BNB = 2 (or BNB/ETH = 0.5)\r\n        // on ETH chain: \r\n        // 1. claim ETH for 60 BNB == 60 * 0.5 = 30 ETH, \r\n        // set: foreign = 60 BNB, foreignRate = 0.5 BNB/ETH prices (already swapped BNB)\r\n        //\r\n        // on BSC chain:\r\n        // 2. claim BNB for 20 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\r\n        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\r\n        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 0 BNB (native) = 60 BNB with rate 0.5 BNB/ETH\r\n        // claimed BNB amount = 20 ETH / 0.5 BNB/ETH = 40 BNB (we use rate of already swapped BNB)\r\n        // set: native = 40 BNB (we use BNB that was already swapped on step 1)\r\n        //\r\n        // 3. New claim BNB for 30 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\r\n        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\r\n        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 40 BNB (native) = 20 BNB with rate 0.5 BNB/ETH\r\n        // 20 BNB * 0.5 = 10 ETH (we claimed 20 BNB for 10 ETH with already swapped rate)\r\n        // set: native = 40 BNB + 20 BNB = 60 BNB (we use all BNB that was already swapped on step 1)\r\n        // claimed rest BNB amount for (30-10) ETH = 20 ETH / 0.25 BNB/ETH = 80 BNB (we use new rate)\r\n        // set: foreign = 20 ETH, foreignRate = 0.25 BNB/ETH prices (already swapped ETH)\r\n    }\r\n// ================== For Jointer Auction =========================================================================\r\n\r\n    // ETH side\r\n    // function for invest ETH from from exchange on user behalf\r\n    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\r\n        require(isExchange[msg.sender], \"Not an Exchange address\");\r\n        address tokenA = address(2);    // ETH (native coin)\r\n        address tokenB = address(1);    // BNB (foreign coin)\r\n        uint256 amount = msg.value - processingFee; // charge processing fee\r\n        amount = amount * 10000 / (10000 + companyFee); // charge company fee\r\n        emit ExchangeInvestETH(msg.sender, _whom, msg.value);\r\n        _transferFee(tokenA, amount, _whom, address(0));    // no licensee\r\n        _swap(tokenA, tokenB, _whom, auction, amount, true,0,0);\r\n        return true;\r\n    }\r\n\r\n    // BSC side\r\n    // tokenB - foreign token address or address(1) for ETH\r\n    // amountB - amount of foreign tokens or ETH\r\n    function claimInvestmentBehalf(\r\n        address tokenB, // foreignToken\r\n        address user, \r\n        uint128 amountB,    //amount of tokenB that has to be swapped\r\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / Native coin price\r\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\r\n    ) \r\n        external \r\n        onlySystem \r\n        returns (bool) \r\n    {\r\n        address tokenA = address(1);    // BNB (native coin)\r\n        _claimTokenBehalf(tokenB, tokenA, user, auction, true, amountB, currentRate, foreignBalance);\r\n        return true;\r\n    }\r\n    \r\n    // reimburse user for SP payment\r\n    function reimburse(address user, uint256 amount) external onlySystem {\r\n        address reimbursementContract = contractSmart;\r\n        if (reimbursementContract != address(0) && amount !=0) {\r\n            IReimbursement(reimbursementContract).requestReimbursement(user, amount, reimbursementVault);\r\n        }\r\n    }\r\n// ================= END For Jointer Auction ===========================================================================\r\n\r\n// ============================ Restricted functions ============================\r\n\r\n    // set processing fee - amount that have to be paid on other chain to claimTokenBehalf.\r\n    // Set in amount of native coins (BNB or ETH)\r\n    function setProcessingFee(uint256 _fee) external onlySystem returns(bool) {\r\n        processingFee = _fee;\r\n        return true;\r\n    }\r\n/*\r\n    // set licensee compensator contract address, if this address is address(0) - remove licensee.\r\n    // compensator contract has to compensate the fee by other tokens.\r\n    // licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\r\n    function setLicensee(address _licensee, address _compensator, uint256 _fee) external onlySystem returns(bool) {\r\n        licenseeCompensator[_licensee] = _compensator;\r\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\r\n        licenseeFee[_licensee] = _fee;\r\n        emit SetLicensee(_licensee, _compensator);\r\n        return true;\r\n    }\r\n\r\n    // set licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\r\n    function setLicenseeFee(uint256 _fee) external returns(bool) {\r\n        require(licenseeCompensator[msg.sender] != address(0), \"licensee is not registered\");\r\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\r\n        licenseeFee[msg.sender] = _fee;\r\n        return true;\r\n    }\r\n*/\r\n// ============================ Owner's functions ============================\r\n\r\n    //the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\r\n    function setCompanyFee(uint256 _fee) external onlyOwner returns(bool) {\r\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\r\n        companyFee = _fee;\r\n        return true;\r\n    }\r\n\r\n    //the fee (in percent wih 2 decimals) that received by company from Swap provider. 30 - means 0.3%\r\n    function setCompanySPFee(uint256 _fee) external onlyOwner returns(bool) {\r\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\r\n        companySPFee = _fee;\r\n        return true;\r\n    }\r\n\r\n    // Reimbursement Percentage without decimals: 100 = 100%\r\n    function setReimbursementPercentage (uint256 id, uint256 _fee) external onlyOwner returns(bool) {\r\n        if (id == 1) swapGasReimbursement = _fee;      // percentage of swap Gas Reimbursement by SMART tokens\r\n        else if (id == 2) cancelGasReimbursement = _fee;    // percentage of cancel Gas Reimbursement by SMART tokens\r\n        else if (id == 3) companyFeeReimbursement = _fee;   // percentage of company Fee Reimbursement by SMART tokens\r\n        return true;\r\n    }\r\n\r\n    function setSystem(address _system, bool _active) external onlyOwner returns(bool) {\r\n        isSystem[_system] = _active;\r\n        emit SetSystem(_system, _active);\r\n        return true;\r\n    }\r\n\r\n    function setValidator(address payable _validator) external onlyOwner returns(bool) {\r\n        validator = _validator;\r\n        return true;\r\n    }\r\n\r\n    function setForeignFactory(address _addr) external onlyOwner returns(bool) {\r\n        foreignFactory = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\r\n        feeReceiver = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setReimbursementContractAndVault(address reimbursement, address vault) external onlyOwner returns(bool) {\r\n        contractSmart = reimbursement;\r\n        reimbursementVault = vault;\r\n        return true;\r\n    }\r\n\r\n    function setAuction(address _addr) external onlyOwner returns(bool) {\r\n        auction = _addr;\r\n        return true;\r\n    }\r\n\r\n    // for ETH side only\r\n    function changeExchangeAddress(address _which,bool _bool) external onlyOwner returns(bool){\r\n        isExchange[_which] = _bool;\r\n        return true;\r\n    }\r\n    \r\n    function changeExcludedAddress(address _which,bool _bool) external onlyOwner returns(bool){\r\n        isExcludedSender[_which] = _bool;\r\n        return true;\r\n    }\r\n\r\n    function createPair(address tokenA, uint256 decimalsA, address tokenB, uint256 decimalsB) public onlyOwner returns (uint256) {\r\n        require(getPairID[tokenA][tokenB] == 0, \"Pair exist\");\r\n        uint256 pairID = ++pairIDCounter;\r\n        getPairID[tokenA][tokenB] = pairID;\r\n        getPairByID[pairID] = Pair(tokenA, tokenB);\r\n        if (decimals[tokenA] == 0) decimals[tokenA] = decimalsA;\r\n        if (decimals[tokenB] == 0) decimals[tokenB] = decimalsB;\r\n        return pairID;\r\n    }\r\n\r\n    function setSPImplementation(address _SPImplementation) external onlyOwner {\r\n        require(_SPImplementation != address(0));\r\n        SPImplementation = _SPImplementation;\r\n    }\r\n\r\n// ============================ Internal functions ============================\r\n    function _swap(\r\n        address tokenA, // nativeToken\r\n        address tokenB, // foreignToken\r\n        address sender,\r\n        address receiver,\r\n        uint256 amountA,\r\n        bool isInvestment,\r\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\r\n        uint128 limitPice   // Do not match user if token A price less this limit\r\n    )\r\n        internal\r\n    {\r\n        uint256 pairID = getPairID[tokenA][tokenB];\r\n        require(pairID != 0, \"Pair not exist\");\r\n        if (tokenA > NATIVE_COINS) {\r\n            TransferHelper.safeTransferFrom(tokenA, sender, address(this), amountA);\r\n        }\r\n        // (amount >= msg.value) is checking when pay fee in the function transferFee()\r\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\r\n        _balanceOf[hashAddress] += amountA;\r\n        totalSupply[pairID] += amountA;\r\n        emit SwapRequest(tokenA, tokenB, sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\r\n    }\r\n\r\n    function _cancel(\r\n        address tokenA, // nativeToken\r\n        address tokenB, // foreignToken\r\n        address sender,\r\n        address receiver,\r\n        uint256 amountA    //amount of tokenA to cancel\r\n        //uint128 foreignBalance // amount of tokenA swapped by hashAddress (get by server-side)\r\n    )\r\n        internal\r\n    {\r\n        if(!isSystem[msg.sender]) { // process fee if caller is not System\r\n            require(msg.value >= IValidator(validator).getOracleFee(1), \"Insufficient fee\");    // check oracle fee for Cancel request\r\n            collectedFees += msg.value;\r\n            if(contractSmart != address(0) && !isExcludedSender[sender]) {\r\n                uint256 feeAmount = (msg.value + 60000*tx.gasprice) * cancelGasReimbursement / 100;\r\n                if (feeAmount != 0)\r\n                    IReimbursement(contractSmart).requestReimbursement(sender, feeAmount, reimbursementVault);\r\n            }\r\n        }\r\n\r\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\r\n        uint256 pairID = getPairID[tokenA][tokenB];\r\n        require(pairID != 0, \"Pair not exist\");\r\n        if (cancelRequest[hashAddress].amount == 0) {  // new cancel request\r\n            uint256 balance = _balanceOf[hashAddress];\r\n            require(balance >= amountA && amountA != 0, \"Wrong amount\");\r\n            totalSupply[pairID] = totalSupply[pairID] - amountA;\r\n            _balanceOf[hashAddress] = balance - amountA;\r\n        } else { // repeat cancel request in case oracle issues.\r\n            amountA = cancelRequest[hashAddress].amount;\r\n        }\r\n        cancelRequest[hashAddress] = Cancel(uint64(pairID), sender, amountA);\r\n        // request Oracle for fulfilled amount from hashAddress\r\n        IValidator(validator).checkBalance(foreignFactory, hashAddress);\r\n        emit CancelRequest(hashAddress, amountA);\r\n        //emit CancelRequest(tokenA, tokenB, sender, receiver, amountA);\r\n    }\r\n\r\n    function _cancelApprove(address hashAddress, uint256 foreignBalance) internal {\r\n        Cancel memory c = cancelRequest[hashAddress];\r\n        delete cancelRequest[hashAddress];\r\n        //require(c.foreignBalance == foreignBalance, \"Oracle error\");\r\n        uint256 balance = _balanceOf[hashAddress];\r\n        uint256 amount = uint256(c.amount);\r\n        uint256 pairID = uint256(c.pairID);\r\n        if (foreignBalance <= balance) {\r\n            //approved - transfer token to its sender\r\n            _transfer(getPairByID[pairID].tokenA, c.sender, amount);\r\n        } else {\r\n            //disapproved\r\n            balance += amount;\r\n            _balanceOf[hashAddress] = balance;\r\n            totalSupply[pairID] += amount;\r\n        }\r\n        emit CancelApprove(hashAddress, balance);\r\n    }\r\n\r\n    function _claimTokenBehalf(\r\n        address tokenA, // foreignToken\r\n        address tokenB, // nativeToken\r\n        address sender,\r\n        address receiver,\r\n        bool isInvestment,\r\n        uint128 amountA,    //amount of tokenA that has to be swapped\r\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\r\n        uint256 foreignBalance  // total tokens amount sent bu user to pair on other chain\r\n        // [1] foreignSpent, [2] nativeSpent, [3] nativeRate\r\n    )\r\n        internal\r\n    {\r\n        uint256 pairID = getPairID[tokenB][tokenA]; // getPairID[nativeToken][foreignToken]\r\n        require(pairID != 0, \"Pair not exist\");\r\n        // check rate\r\n        uint256 diffRate = uint256(currentRate) * 100 / IValidator(validator).getRate(tokenB, tokenA);\r\n        uint256 diffLimit = rateDiffLimit;\r\n        require(diffRate >= 100 - diffLimit && diffRate <= 100 + diffLimit, \"Wrong rate\");\r\n\r\n        uint64 claimID;\r\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\r\n        if (claimRequest[hashAddress].amount == 0) {  // new claim request\r\n            _balanceOf[hashAddress] += uint256(amountA); // total swapped amount of foreign token\r\n            claimID = uint64(++claimIdCounter);\r\n        } else { // repeat claim request in case oracle issues.\r\n            claimID = claimRequest[hashAddress].claimID;\r\n            if (amountA == 0) {    // cancel claim request\r\n                emit ClaimApprove(hashAddress, claimID, 0, 0, claimRequest[hashAddress].isInvestment);\r\n                _balanceOf[hashAddress] = _balanceOf[hashAddress] - claimRequest[hashAddress].amount;\r\n                delete claimRequest[hashAddress];\r\n                return;\r\n            }\r\n            amountA = claimRequest[hashAddress].amount;\r\n        }\r\n        address[] memory users = new address[](3);\r\n        users[0] = hashAddress;\r\n        users[1] = _getHashAddress(tokenA, tokenB, address(0), address(0)); // Native hash address on foreign chain\r\n        users[2] = _getHashAddress(tokenB, tokenA, address(0), address(0)); // Foreign hash address on foreign chain\r\n        claimRequest[hashAddress] = Claim(uint64(pairID), sender, receiver, claimID, isInvestment, amountA, currentRate, foreignBalance);\r\n        IValidator(validator).checkBalances(foreignFactory, users);\r\n        emit ClaimRequest(hashAddress, claimID, amountA, isInvestment);\r\n        //emit ClaimRequest(tokenA, tokenB, sender, receiver, amountA);\r\n    }\r\n\r\n    // Approve or disapprove claim request.\r\n    function _claimBehalfApprove(\r\n        address hashAddress, \r\n        uint256 foreignBalance, // total user's tokens balance on foreign chain\r\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\r\n        uint256 nativeEncoded   // (nativeSpent, nativeRate) = _decode(nativeEncoded)\r\n    ) \r\n        internal \r\n    {\r\n        Claim memory c = claimRequest[hashAddress];\r\n        delete claimRequest[hashAddress];\r\n        //address hashSwap = _getHashAddress(getPairByID[c.pairID].tokenB, getPairByID[c.pairID].tokenA, c.sender, c.receiver);\r\n        uint256 balance = _balanceOf[hashAddress];   // swapped amount of foreign tokens (include current claim amount)\r\n        uint256 amount = uint256(c.amount);     // amount of foreign token to swap\r\n        require (amount != 0, \"No active claim request\");\r\n        require(foreignBalance == c.foreignBalance, \"Oracle error\");\r\n\r\n        uint256 nativeAmount;\r\n        uint256 rest;\r\n        if (foreignBalance >= balance) {\r\n            //approve, user deposited not less foreign tokens then want to swap\r\n            uint256 pairID = uint256(c.pairID);\r\n            (uint256 nativeRate, uint256 nativeSpent) = _decode(nativeEncoded);\r\n            (nativeAmount, rest) = _calculateAmount(\r\n                pairID,\r\n                amount, \r\n                uint256(c.currentRate),\r\n                foreignSpent,\r\n                nativeSpent,\r\n                nativeRate\r\n            );\r\n            if (rest != 0) {\r\n                _balanceOf[hashAddress] = balance - rest;    // not all amount swapped\r\n                amount = amount - rest;     // swapped amount\r\n            }\r\n            require(totalSupply[pairID] >= nativeAmount, \"Not enough Total Supply\");   // may be commented\r\n            totalSupply[pairID] = totalSupply[pairID] - nativeAmount;\r\n            if (c.isInvestment)\r\n                _contributeFromSmartSwap(getPairByID[pairID].tokenA, c.receiver, c.sender, nativeAmount);\r\n            else\r\n                _transfer(getPairByID[pairID].tokenA, c.receiver, nativeAmount);\r\n        } else {\r\n            //disapprove, discard claim\r\n            _balanceOf[hashAddress] = balance - amount;\r\n            amount = 0;\r\n        }\r\n        emit ClaimApprove(hashAddress, c.claimID, nativeAmount, amount, c.isInvestment);\r\n    }\r\n\r\n    // use structure to avoid stack too deep\r\n    struct CalcVariables {\r\n        // 18 decimals nominator with decimals converter: \r\n        // Foreign = Native * Rate(18) / nominatorNativeToForeign\r\n        uint256 nominatorForeignToNative; // 10**(18 + foreign decimals - native decimals)\r\n        uint256 nominatorNativeToForeign; // 10**(18 + native decimals - foreign decimals)\r\n        uint256 localNative;        // already swapped Native tokens = _balanceOf[hashNative]\r\n        uint256 localForeign;       // already swapped Foreign tokens = decoded _balanceOf[hashForeign]\r\n        uint256 localForeignRate;   // Foreign token price / Native token price = decoded _balanceOf[hashForeign]\r\n        address hashNative;         // _getHashAddress(tokenA, tokenB, address(0), address(0));\r\n        address hashForeign;        // _getHashAddress(tokenB, tokenA, address(0), address(0));\r\n    }\r\n\r\n    function _calculateAmount(\r\n        uint256 pairID,\r\n        uint256 foreignAmount,\r\n        uint256 rate,    // Foreign token price / Native token price = (Native amount / Foreign amount)\r\n        uint256 foreignSpent,   // already swapped Foreign tokens (got from foreign contract)\r\n        uint256 nativeSpent,    // already swapped Native tokens (got from foreign contract)\r\n        uint256 nativeRate  // Native token price / Foreign token price. I.e. on BSC side: BNB price / ETH price = 0.2\r\n    )\r\n        internal\r\n        returns(uint256 nativeAmount, uint256 rest)\r\n    {\r\n        CalcVariables memory vars;\r\n        {\r\n            address tokenA = getPairByID[pairID].tokenA;\r\n            address tokenB = getPairByID[pairID].tokenB;\r\n            uint256 nativeDecimals = decimals[tokenA];\r\n            uint256 foreignDecimals = decimals[tokenB];\r\n            vars.nominatorForeignToNative = 10**(18+foreignDecimals-nativeDecimals);\r\n            vars.nominatorNativeToForeign = 10**(18+nativeDecimals-foreignDecimals);\r\n            vars.hashNative = _getHashAddress(tokenA, tokenB, address(0), address(0));\r\n            vars.hashForeign = _getHashAddress(tokenB, tokenA, address(0), address(0));\r\n            vars.localNative = _balanceOf[vars.hashNative];\r\n            (vars.localForeignRate, vars.localForeign) = _decode(_balanceOf[vars.hashForeign]);\r\n        }\r\n\r\n        // step 1. Check is it enough unspent native tokens\r\n        {\r\n            require(nativeSpent >= vars.localNative, \"NativeSpent balance higher then remote\");\r\n            uint256 nativeAvailable = nativeSpent - vars.localNative;\r\n            // nativeAvailable - amount ready to spend native tokens\r\n            // nativeRate = Native token price / Foreign token price. I.e. on BSC side BNB price / ETH price = 0.2\r\n            if (nativeAvailable != 0) {\r\n                // ?\r\n                uint256 requireAmount = foreignAmount * vars.nominatorNativeToForeign / nativeRate;\r\n                if (requireAmount <= nativeAvailable) {\r\n                    nativeAmount = requireAmount;   // use already swapped tokens\r\n                    foreignAmount = 0;\r\n                }\r\n                else {\r\n                    nativeAmount = nativeAvailable;\r\n                    foreignAmount = (requireAmount - nativeAvailable) * nativeRate / vars.nominatorNativeToForeign;\r\n                }\r\n                _balanceOf[vars.hashNative] += nativeAmount;\r\n            }\r\n        }\r\n        require(totalSupply[pairID] >= nativeAmount,\"ERR: Not enough Total Supply\");\r\n        // step 2. recalculate rate for swapped tokens\r\n        if (foreignAmount != 0) {\r\n            // i.e. on BSC side: rate = ETH price / BNB price = 5\r\n            uint256 requireAmount = foreignAmount * rate / vars.nominatorForeignToNative;\r\n            if (totalSupply[pairID] < nativeAmount + requireAmount) {\r\n                requireAmount = totalSupply[pairID] - nativeAmount;\r\n                rest = foreignAmount - (requireAmount * vars.nominatorForeignToNative / rate);\r\n                foreignAmount = foreignAmount - rest;\r\n            }\r\n            nativeAmount = nativeAmount + requireAmount;\r\n            require(vars.localForeign >= foreignSpent, \"ForeignSpent balance higher then local\");\r\n            uint256 foreignAvailable = vars.localForeign - foreignSpent;\r\n            // vars.localForeignRate, foreignAvailable - rate and amount swapped foreign tokens\r\n            if (foreignAvailable != 0) { // recalculate avarage rate (native amount / foreign amount)\r\n                rate = ((foreignAvailable * vars.localForeignRate) + (requireAmount * vars.nominatorForeignToNative)) / (foreignAvailable + foreignAmount);\r\n            }\r\n            _balanceOf[vars.hashForeign] = _encode(rate, vars.localForeign + foreignAmount);\r\n        }\r\n    }\r\n\r\n    // transfer fee to receiver and request SMART token as compensation.\r\n    // tokenA - token that user send\r\n    // amount - amount of tokens that user send\r\n    // user - address of user\r\n    function _transferFee(address tokenA, uint256 amount, address user, address licensee) internal {\r\n        uint256 feeAmount = msg.value;\r\n        uint256 compFee; // company fee\r\n        uint256 _companyFee;\r\n        if (isSystem[msg.sender]) {\r\n            _companyFee = companySPFee;\r\n            user = ISPImplementation(msg.sender).owner();\r\n        } else {\r\n            _companyFee = companyFee;\r\n        }\r\n\r\n        if (tokenA < NATIVE_COINS) {\r\n            require(feeAmount >= amount, \"Insuficiant value\");   // if native coin, then feeAmount = msg.value - swap amount\r\n            feeAmount -= amount;\r\n            compFee = amount * _companyFee / 10000;    // company fee\r\n        }\r\n        require(feeAmount >= processingFee + compFee, \"Insufficient processing fee\");\r\n        if (contractSmart == address(0)) return;    // return if no reimbursement contract \r\n        uint256 txGas = gasleft();\r\n        uint256 otherFee = feeAmount - processingFee;\r\n\r\n        uint256 licenseeFeeAmount;\r\n        uint256 licenseeFeeRate = IReimbursement(contractSmart).getLicenseeFee(licensee, address(this));\r\n        if (licenseeFeeRate != 0 && otherFee != 0) {\r\n            if (tokenA < NATIVE_COINS) {\r\n                licenseeFeeAmount = amount * licenseeFeeRate / 10000;\r\n            } else {\r\n                licenseeFeeAmount = (otherFee * licenseeFeeRate)/(licenseeFeeRate + _companyFee);\r\n            }\r\n        }\r\n        require(otherFee >= compFee + licenseeFeeAmount, \"Insuficiant fee\");\r\n        feeAmount -= licenseeFeeAmount;\r\n\r\n        if (licenseeFeeAmount != 0) {\r\n            address licenseeFeeTo = IReimbursement(contractSmart).requestReimbursement(user, licenseeFeeAmount, licensee);\r\n            if (licenseeFeeTo == address(0)) {\r\n                TransferHelper.safeTransferETH(user, licenseeFeeAmount);    // refund to user\r\n            } else {\r\n                TransferHelper.safeTransferETH(licenseeFeeTo, licenseeFeeAmount); // transfer to fee receiver\r\n            }\r\n        }\r\n\r\n        collectedFees += feeAmount;\r\n        if(!isExcludedSender[user]) {\r\n            txGas -= gasleft(); // get gas amount that was spent on Licensee fee\r\n            feeAmount = ((feeAmount - processingFee) * companyFeeReimbursement + (processingFee + (txGas + 60000)*tx.gasprice) * swapGasReimbursement) / 100;\r\n            if (feeAmount != 0)\r\n                IReimbursement(contractSmart).requestReimbursement(user, feeAmount, reimbursementVault);\r\n        }\r\n    }\r\n    \r\n    // contribute from SmartSwap on user behalf\r\n    function _contributeFromSmartSwap(address token, address to, address user, uint256 value) internal {\r\n        if (token < NATIVE_COINS) {\r\n            IAuction(to).contributeFromSmartSwap{value: value}(payable(user));\r\n        } else {\r\n            IERC20(token).approve(to, value);\r\n            IAuction(to).contributeFromSmartSwap(token, value, user);\r\n        }\r\n    }\r\n\r\n    // call appropriate transfer function\r\n    function _transfer(address token, address to, uint256 value) internal {\r\n        if (token < NATIVE_COINS) \r\n            TransferHelper.safeTransferETH(to, value);\r\n        else\r\n            TransferHelper.safeTransfer(token, to, value);\r\n    }\r\n\r\n    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \r\n    // into uint256 where high 64 bits is rate and low 192 bit is amount\r\n    // rate = foreign token price / native token price\r\n    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\r\n        require(amount < MAX_AMOUNT, \"Amount overflow\");\r\n        require(rate < MAX_AMOUNT, \"Rate overflow\");\r\n        encodedBalance = rate * MAX_AMOUNT + amount;\r\n    }\r\n\r\n    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\r\n    // rate = foreign token price / native token price\r\n    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\r\n        rate = encodedBalance / MAX_AMOUNT;\r\n        amount = uint128(encodedBalance);\r\n    }\r\n    \r\n    function _getHashAddress(\r\n        address tokenA,\r\n        address tokenB, \r\n        address sender,\r\n        address receiver\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(keccak256(abi.encodePacked(tokenA, tokenB, sender, receiver)))));\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"swapProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spContract\",\"type\":\"address\"}],\"name\":\"AddSwapProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"CancelApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"claimID\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"foreignAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"ClaimApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"claimID\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"ClaimRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ExchangeInvestETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairID\",\"type\":\"uint256\"}],\"name\":\"PairAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairID\",\"type\":\"uint256\"}],\"name\":\"PairRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"system\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"SetSystem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"minimumAmountToClaim\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"limitPice\",\"type\":\"uint128\"}],\"name\":\"SwapRequest\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SPImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foreignTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmountLimit\",\"type\":\"uint256\"}],\"name\":\"addSwapProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"spContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"name\":\"balanceCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreignSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeEncoded\",\"type\":\"uint256\"}],\"name\":\"balancesCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"}],\"name\":\"cancelBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelGasReimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cancelRequest\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"pairID\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changeExchangeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changeExcludedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amountB\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"name\":\"claimInvestmentBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimRequest\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"pairID\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"claimID\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"name\":\"claimTokenBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyFeeReimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companySPFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSmart\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"contributeWithEtherBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimalsA\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimalsB\",\"type\":\"uint256\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreignFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColletedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getHashAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getPairByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPairID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairID\",\"type\":\"uint256\"}],\"name\":\"getPairVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"native\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreign\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreignRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidityProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairIDCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateDiffLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reimburse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reimbursementVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setCompanyFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setCompanySPFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setForeignFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setProcessingFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reimbursement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"setReimbursementContractAndVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setReimbursementPercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_SPImplementation\",\"type\":\"address\"}],\"name\":\"setSPImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licensee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"minimumAmountToClaim\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limitPice\",\"type\":\"uint128\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapGasReimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SmartSwap","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cdf87da5a13758ee117eebc57b1b9e517016b5fc6f88c73035144274686a42ce"}]}