{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Vesting/TokenVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../Interfaces/TokenVestingInterface.sol\\\";\\n\\n/**\\n * @title Contract for token vesting schedules\\n *\\n * @dev Contract which gives the ability to act as a pool of funds for allocating\\n *   tokens to any number of other addresses. Token grants support the ability to vest over time in\\n *   accordance a predefined vesting schedule. A given wallet can receive no more than one token grant.\\n */\\ncontract TokenVesting is TokenVestingInterface, Context, Ownable {\\n  using SafeMath for uint256;\\n\\n  // Date-related constants for sanity-checking dates to reject obvious erroneous inputs\\n  // and conversions from seconds to days and years that are more or less leap year-aware.\\n  uint32 private constant _THOUSAND_YEARS_DAYS = 365243; /* See https://www.timeanddate.com/date/durationresult.html?m1=1&d1=1&y1=2000&m2=1&d2=1&y2=3000 */\\n  uint32 private constant _TEN_YEARS_DAYS = _THOUSAND_YEARS_DAYS / 100; /* Includes leap years (though it doesn't really matter) */\\n  uint32 private constant _SECONDS_PER_DAY = 24 * 60 * 60; /* 86400 seconds in a day */\\n  uint32 private constant _JAN_1_2000_SECONDS = 946684800; /* Saturday, January 1, 2000 0:00:00 (GMT) (see https://www.epochconverter.com/) */\\n  uint32 private constant _JAN_1_2000_DAYS =\\n    _JAN_1_2000_SECONDS / _SECONDS_PER_DAY;\\n  uint32 private constant _JAN_1_3000_DAYS =\\n    _JAN_1_2000_DAYS + _THOUSAND_YEARS_DAYS;\\n\\n  modifier onlyOwnerOrSelf(address account) {\\n    require(\\n      _msgSender() == owner() || _msgSender() == account,\\n      \\\"onlyOwnerOrSelf\\\"\\n    );\\n    _;\\n  }\\n\\n  mapping(address => vestingSchedule) private _vestingSchedules;\\n  mapping(address => tokenGrant) private _tokenGrants;\\n  address[] private _allBeneficiaries;\\n  IERC20 private _token;\\n\\n  constructor(IERC20 token_) public {\\n    require(address(token_) != address(0), \\\"token must be non-zero address\\\");\\n    _token = token_;\\n  }\\n\\n  function token() public view override returns (IERC20) {\\n    return _token;\\n  }\\n\\n  function kill(address payable beneficiary) external override onlyOwner {\\n    _withdrawTokens(beneficiary, token().balanceOf(address(this)));\\n    selfdestruct(beneficiary);\\n  }\\n\\n  function withdrawTokens(address beneficiary, uint256 amount)\\n    external\\n    override\\n    onlyOwner\\n  {\\n    _withdrawTokens(beneficiary, amount);\\n  }\\n\\n  function _withdrawTokens(address beneficiary, uint256 amount) internal {\\n    require(amount > 0, \\\"amount must be > 0\\\");\\n    require(\\n      amount <= token().balanceOf(address(this)),\\n      \\\"amount must be <= current balance\\\"\\n    );\\n\\n    require(token().transfer(beneficiary, amount));\\n  }\\n\\n  // =========================================================================\\n  // === Methods for claiming tokens.\\n  // =========================================================================\\n\\n  function claimVestingTokens(address beneficiary)\\n    external\\n    override\\n    onlyOwnerOrSelf(beneficiary)\\n  {\\n    _claimVestingTokens(beneficiary);\\n  }\\n\\n  function claimVestingTokensForAll() external override onlyOwner {\\n    for (uint256 i = 0; i < _allBeneficiaries.length; i++) {\\n      _claimVestingTokens(_allBeneficiaries[i]);\\n    }\\n  }\\n\\n  function _claimVestingTokens(address beneficiary) internal {\\n    uint256 amount = _getAvailableAmount(beneficiary, 0);\\n    if (amount > 0) {\\n      _deliverTokens(beneficiary, amount);\\n      _tokenGrants[beneficiary].claimedAmount = _tokenGrants[beneficiary]\\n        .claimedAmount\\n        .add(amount);\\n      emit VestingTokensClaimed(beneficiary, amount);\\n    }\\n  }\\n\\n  function _deliverTokens(address beneficiary, uint256 amount) internal {\\n    require(amount > 0, \\\"amount must be > 0\\\");\\n    require(\\n      amount <= token().balanceOf(address(this)),\\n      \\\"amount must be <= current balance\\\"\\n    );\\n    require(\\n      _tokenGrants[beneficiary].claimedAmount.add(amount) <=\\n        _tokenGrants[beneficiary].amount,\\n      \\\"new claimed amount must be <= total grant amount\\\"\\n    );\\n\\n    require(token().transfer(beneficiary, amount));\\n  }\\n\\n  // =========================================================================\\n  // === Methods for administratively creating a vesting schedule for an account.\\n  // =========================================================================\\n\\n  /**\\n   * @dev This one-time operation permanently establishes a vesting schedule in the given account.\\n   *\\n   * @param cliffDuration = Duration of the cliff, with respect to the grant start day, in days.\\n   * @param duration = Duration of the vesting schedule, with respect to the grant start day, in days.\\n   * @param interval = Number of days between vesting increases.\\n   * @param isRevocable = True if the grant can be revoked (i.e. was a gift) or false if it cannot\\n   *   be revoked (i.e. tokens were purchased).\\n   */\\n  function setVestingSchedule(\\n    address vestingLocation,\\n    uint32 cliffDuration,\\n    uint32 duration,\\n    uint32 interval,\\n    bool isRevocable\\n  ) external override onlyOwner {\\n    _setVestingSchedule(\\n      vestingLocation,\\n      cliffDuration,\\n      duration,\\n      interval,\\n      isRevocable\\n    );\\n  }\\n\\n  function _setVestingSchedule(\\n    address vestingLocation,\\n    uint32 cliffDuration,\\n    uint32 duration,\\n    uint32 interval,\\n    bool isRevocable\\n  ) internal {\\n    // Check for a valid vesting schedule given (disallow absurd values to reject likely bad input).\\n    require(\\n      duration > 0 &&\\n        duration <= _TEN_YEARS_DAYS &&\\n        cliffDuration < duration &&\\n        interval >= 1,\\n      \\\"invalid vesting schedule\\\"\\n    );\\n\\n    // Make sure the duration values are in harmony with interval (both should be an exact multiple of interval).\\n    require(\\n      duration % interval == 0 && cliffDuration % interval == 0,\\n      \\\"invalid cliff/duration for interval\\\"\\n    );\\n\\n    // Create and populate a vesting schedule.\\n    _vestingSchedules[vestingLocation] = vestingSchedule(\\n      isRevocable,\\n      cliffDuration,\\n      duration,\\n      interval\\n    );\\n\\n    // Emit the event.\\n    emit VestingScheduleCreated(\\n      vestingLocation,\\n      cliffDuration,\\n      duration,\\n      interval,\\n      isRevocable\\n    );\\n  }\\n\\n  // =========================================================================\\n  // === Token grants (general-purpose)\\n  // === Methods to be used for administratively creating one-off token grants with vesting schedules.\\n  // =========================================================================\\n\\n  /**\\n   * @dev Grants tokens to an account.\\n   *\\n   * @param beneficiary = Address to which tokens will be granted.\\n   * @param vestingAmount = The number of tokens subject to vesting.\\n   * @param startDay = Start day of the grant's vesting schedule, in days since the UNIX epoch\\n   *   (start of day). The startDay may be given as a date in the future or in the past, going as far\\n   *   back as year 2000.\\n   * @param vestingLocation = Account where the vesting schedule is held (must already exist).\\n   */\\n  function _addGrant(\\n    address beneficiary,\\n    uint256 vestingAmount,\\n    uint32 startDay,\\n    address vestingLocation\\n  ) internal {\\n    // Make sure no prior grant is in effect.\\n    require(!_tokenGrants[beneficiary].isActive, \\\"grant already exists\\\");\\n\\n    // Check for valid vestingAmount\\n    require(\\n      vestingAmount > 0 &&\\n        startDay >= _JAN_1_2000_DAYS &&\\n        startDay < _JAN_1_3000_DAYS,\\n      \\\"invalid vesting params\\\"\\n    );\\n\\n    // Create and populate a token grant, referencing vesting schedule.\\n    _tokenGrants[beneficiary] = tokenGrant(\\n      true, // isActive\\n      false, // wasRevoked\\n      startDay,\\n      vestingAmount,\\n      vestingLocation, // The wallet address where the vesting schedule is kept.\\n      0 // claimedAmount\\n    );\\n    _allBeneficiaries.push(beneficiary);\\n\\n    // Emit the event.\\n    emit VestingTokensGranted(\\n      beneficiary,\\n      vestingAmount,\\n      startDay,\\n      vestingLocation\\n    );\\n  }\\n\\n  /**\\n   * @dev Grants tokens to an address, including a portion that will vest over time\\n   * according to a set vesting schedule. The overall duration and cliff duration of the grant must\\n   * be an even multiple of the vesting interval.\\n   *\\n   * @param beneficiary = Address to which tokens will be granted.\\n   * @param vestingAmount = The number of tokens subject to vesting.\\n   * @param startDay = Start day of the grant's vesting schedule, in days since the UNIX epoch\\n   *   (start of day). The startDay may be given as a date in the future or in the past, going as far\\n   *   back as year 2000.\\n   * @param duration = Duration of the vesting schedule, with respect to the grant start day, in days.\\n   * @param cliffDuration = Duration of the cliff, with respect to the grant start day, in days.\\n   * @param interval = Number of days between vesting increases.\\n   * @param isRevocable = True if the grant can be revoked (i.e. was a gift) or false if it cannot\\n   *   be revoked (i.e. tokens were purchased).\\n   */\\n  function addGrant(\\n    address beneficiary,\\n    uint256 vestingAmount,\\n    uint32 startDay,\\n    uint32 duration,\\n    uint32 cliffDuration,\\n    uint32 interval,\\n    bool isRevocable\\n  ) public override onlyOwner {\\n    // Make sure no prior vesting schedule has been set.\\n    require(!_tokenGrants[beneficiary].isActive, \\\"grant already exists\\\");\\n\\n    // The vesting schedule is unique to this wallet and so will be stored here,\\n    _setVestingSchedule(\\n      beneficiary,\\n      cliffDuration,\\n      duration,\\n      interval,\\n      isRevocable\\n    );\\n\\n    // Issue tokens to the beneficiary, using beneficiary's own vesting schedule.\\n    _addGrant(beneficiary, vestingAmount, startDay, beneficiary);\\n  }\\n\\n  function addGrantWithScheduleAt(\\n    address beneficiary,\\n    uint256 vestingAmount,\\n    uint32 startDay,\\n    address vestingLocation\\n  ) external override onlyOwner {\\n    // Issue tokens to the beneficiary, using custom vestingLocation.\\n    _addGrant(beneficiary, vestingAmount, startDay, vestingLocation);\\n  }\\n\\n  function addGrantFromToday(\\n    address beneficiary,\\n    uint256 vestingAmount,\\n    uint32 duration,\\n    uint32 cliffDuration,\\n    uint32 interval,\\n    bool isRevocable\\n  ) external override onlyOwner {\\n    addGrant(\\n      beneficiary,\\n      vestingAmount,\\n      today(),\\n      duration,\\n      cliffDuration,\\n      interval,\\n      isRevocable\\n    );\\n  }\\n\\n  // =========================================================================\\n  // === Check vesting.\\n  // =========================================================================\\n  function today() public view virtual override returns (uint32 dayNumber) {\\n    return uint32(block.timestamp / _SECONDS_PER_DAY);\\n  }\\n\\n  function _effectiveDay(uint32 onDayOrToday)\\n    internal\\n    view\\n    returns (uint32 dayNumber)\\n  {\\n    return onDayOrToday == 0 ? today() : onDayOrToday;\\n  }\\n\\n  /**\\n   * @dev Determines the amount of tokens that have not vested in the given account.\\n   *\\n   * The math is: not vested amount = vesting amount * (end date - on date)/(end date - start date)\\n   *\\n   * @param grantHolder = The account to check.\\n   * @param onDayOrToday = The day to check for, in days since the UNIX epoch. Can pass\\n   *   the special value 0 to indicate today.\\n   */\\n  function _getNotVestedAmount(address grantHolder, uint32 onDayOrToday)\\n    internal\\n    view\\n    returns (uint256 amountNotVested)\\n  {\\n    tokenGrant storage grant = _tokenGrants[grantHolder];\\n    vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\\n    uint32 onDay = _effectiveDay(onDayOrToday);\\n\\n    // If there's no schedule, or before the vesting cliff, then the full amount is not vested.\\n    if (!grant.isActive || onDay < grant.startDay + vesting.cliffDuration) {\\n      // None are vested (all are not vested)\\n      return grant.amount;\\n    }\\n    // If after end of vesting, then the not vested amount is zero (all are vested).\\n    else if (onDay >= grant.startDay + vesting.duration) {\\n      // All are vested (none are not vested)\\n      return uint256(0);\\n    }\\n    // Otherwise a fractional amount is vested.\\n    else {\\n      // Compute the exact number of days vested.\\n      uint32 daysVested = onDay - grant.startDay;\\n      // Adjust result rounding down to take into consideration the interval.\\n      uint32 effectiveDaysVested = (daysVested / vesting.interval) *\\n        vesting.interval;\\n\\n      // Compute the fraction vested from schedule using 224.32 fixed point math for date range ratio.\\n      // Note: This is safe in 256-bit math because max value of X billion tokens = X*10^27 wei, and\\n      // typical token amounts can fit into 90 bits. Scaling using a 32 bits value results in only 125\\n      // bits before reducing back to 90 bits by dividing. There is plenty of room left, even for token\\n      // amounts many orders of magnitude greater than mere billions.\\n      uint256 vested = grant.amount.mul(effectiveDaysVested).div(\\n        vesting.duration\\n      );\\n      uint256 result = grant.amount.sub(vested);\\n      require(result <= grant.amount && vested <= grant.amount);\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @dev Computes the amount of funds in the given account which are available for use as of\\n   * the given day, i.e. the claimable amount.\\n   *\\n   * The math is: available amount = totalGrantAmount - notVestedAmount - claimedAmount.\\n   *\\n   * @param grantHolder = The account to check.\\n   * @param onDay = The day to check for, in days since the UNIX epoch.\\n   */\\n  function _getAvailableAmount(address grantHolder, uint32 onDay)\\n    internal\\n    view\\n    returns (uint256 amountAvailable)\\n  {\\n    tokenGrant storage grant = _tokenGrants[grantHolder];\\n    return\\n      _getAvailableAmountImpl(grant, _getNotVestedAmount(grantHolder, onDay));\\n  }\\n\\n  function _getAvailableAmountImpl(\\n    tokenGrant storage grant,\\n    uint256 notVastedOnDay\\n  ) internal view returns (uint256 amountAvailable) {\\n    uint256 vested = grant.amount.sub(notVastedOnDay);\\n    if (vested < grant.claimedAmount) {\\n      // .sub below will fail, only possible when grant revoked\\n      require(vested == 0 && grant.wasRevoked);\\n      return 0;\\n    }\\n\\n    uint256 result = vested.sub(grant.claimedAmount);\\n    require(\\n      result <= grant.amount &&\\n        grant.claimedAmount.add(result) <= grant.amount &&\\n        result <= vested &&\\n        vested <= grant.amount\\n    );\\n\\n    return result;\\n  }\\n\\n  /**\\n   * @dev returns all information about the grant's vesting as of the given day\\n   * for the given account. Only callable by the account holder or a contract owner.\\n   *\\n   * @param grantHolder = The address to do this for.\\n   * @param onDayOrToday = The day to check for, in days since the UNIX epoch. Can pass\\n   *   the special value 0 to indicate today.\\n   * return = A tuple with the following values:\\n   *   amountVested = the amount that is already vested\\n   *   amountNotVested = the amount that is not yet vested (equal to vestingAmount - vestedAmount)\\n   *   amountOfGrant = the total amount of tokens subject to vesting.\\n   *   amountAvailable = the amount of funds in the given account which are available for use as of the given day\\n   *   amountClaimed = out of amountVested, the amount that has been already transferred to beneficiary\\n   *   vestStartDay = starting day of the grant (in days since the UNIX epoch).\\n   *   isActive = true if the vesting schedule is currently active.\\n   *   wasRevoked = true if the vesting schedule was revoked.\\n   */\\n  function getGrantInfo(address grantHolder, uint32 onDayOrToday)\\n    external\\n    view\\n    override\\n    onlyOwnerOrSelf(grantHolder)\\n    returns (\\n      uint256 amountVested,\\n      uint256 amountNotVested,\\n      uint256 amountOfGrant,\\n      uint256 amountAvailable,\\n      uint256 amountClaimed,\\n      uint32 vestStartDay,\\n      bool isActive,\\n      bool wasRevoked\\n    )\\n  {\\n    tokenGrant storage grant = _tokenGrants[grantHolder];\\n    uint256 notVestedAmount = _getNotVestedAmount(grantHolder, onDayOrToday);\\n\\n    return (\\n      grant.amount.sub(notVestedAmount),\\n      notVestedAmount,\\n      grant.amount,\\n      _getAvailableAmountImpl(grant, notVestedAmount),\\n      grant.claimedAmount,\\n      grant.startDay,\\n      grant.isActive,\\n      grant.wasRevoked\\n    );\\n  }\\n\\n  function getScheduleAtInfo(address vestingLocation)\\n    public\\n    view\\n    override\\n    onlyOwnerOrSelf(vestingLocation)\\n    returns (\\n      bool isRevocable,\\n      uint32 vestDuration,\\n      uint32 cliffDuration,\\n      uint32 vestIntervalDays\\n    )\\n  {\\n    vestingSchedule storage vesting = _vestingSchedules[vestingLocation];\\n\\n    return (\\n      vesting.isRevocable,\\n      vesting.duration,\\n      vesting.cliffDuration,\\n      vesting.interval\\n    );\\n  }\\n\\n  function getScheduleInfo(address grantHolder)\\n    external\\n    view\\n    override\\n    onlyOwnerOrSelf(grantHolder)\\n    returns (\\n      bool isRevocable,\\n      uint32 vestDuration,\\n      uint32 cliffDuration,\\n      uint32 vestIntervalDays\\n    )\\n  {\\n    tokenGrant storage grant = _tokenGrants[grantHolder];\\n    return getScheduleAtInfo(grant.vestingLocation);\\n  }\\n\\n  // =========================================================================\\n  // === Grant revocation\\n  // =========================================================================\\n\\n  /**\\n   * @dev If the account has a revocable grant, this forces the grant to end immediately.\\n   * After this function is called, getGrantInfo will return incomplete data\\n   * and there will be no possibility to claim non-claimed tokens\\n   *\\n   * @param grantHolder = Address to which tokens will be granted.\\n   */\\n  function revokeGrant(address grantHolder) external override onlyOwner {\\n    tokenGrant storage grant = _tokenGrants[grantHolder];\\n    vestingSchedule storage vesting = _vestingSchedules[grant.vestingLocation];\\n\\n    // Make sure a vesting schedule has previously been set.\\n    require(grant.isActive, \\\"no active grant\\\");\\n    // Make sure it's revocable.\\n    require(vesting.isRevocable, \\\"irrevocable\\\");\\n\\n    // Kill the grant by updating wasRevoked and isActive.\\n    _tokenGrants[grantHolder].wasRevoked = true;\\n    _tokenGrants[grantHolder].isActive = false;\\n\\n    // Emits the GrantRevoked event.\\n    emit GrantRevoked(grantHolder);\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/Interfaces/TokenVestingInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nabstract contract TokenVestingInterface {\\n    event VestingScheduleCreated(\\n        address indexed vestingLocation,\\n        uint32 cliffDuration, uint32 duration, uint32 interval,\\n        bool isRevocable);\\n\\n    event VestingTokensGranted(\\n        address indexed beneficiary,\\n        uint256 vestingAmount,\\n        uint32 startDay,\\n        address vestingLocation);\\n\\n    event VestingTokensClaimed(\\n        address indexed beneficiary,\\n        uint256 amount);\\n\\n    event GrantRevoked(address indexed grantHolder);\\n\\n    struct vestingSchedule {\\n        bool isRevocable;           /* true if the vesting option is revocable (a gift), false if irrevocable (purchased) */\\n        uint32 cliffDuration;       /* Duration of the cliff, with respect to the grant start day, in days. */\\n        uint32 duration;            /* Duration of the vesting schedule, with respect to the grant start day, in days. */\\n        uint32 interval;            /* Duration in days of the vesting interval. */\\n    }\\n\\n    struct tokenGrant {\\n        bool isActive;              /* true if this vesting entry is active and in-effect entry. */\\n        bool wasRevoked;            /* true if this vesting schedule was revoked. */\\n        uint32 startDay;            /* Start day of the grant, in days since the UNIX epoch (start of day). */\\n        uint256 amount;             /* Total number of tokens that vest. */\\n        address vestingLocation;    /* Address of wallet that is holding the vesting schedule. */\\n        uint256 claimedAmount;      /* Out of vested amount, the amount that has been already transferred to beneficiary */\\n    }\\n\\n    function token() public virtual view returns (IERC20);\\n\\n    function kill(address payable beneficiary) external virtual;\\n\\n    function withdrawTokens(address beneficiary, uint256 amount) external virtual;\\n\\n\\n    // =========================================================================\\n    // === Methods for claiming tokens.\\n    // =========================================================================\\n\\n    function claimVestingTokens(address beneficiary) external virtual;\\n\\n    function claimVestingTokensForAll() external virtual;\\n\\n\\n    // =========================================================================\\n    // === Methods for administratively creating a vesting schedule for an account.\\n    // =========================================================================\\n\\n    function setVestingSchedule(\\n        address vestingLocation,\\n        uint32 cliffDuration, uint32 duration, uint32 interval, bool isRevocable) external virtual;\\n\\n\\n    // =========================================================================\\n    // === Token grants (general-purpose)\\n    // === Methods to be used for administratively creating one-off token grants with vesting schedules.\\n    // =========================================================================\\n\\n    function addGrant(\\n        address beneficiary,\\n        uint256 vestingAmount,\\n        uint32 startDay,\\n        uint32 duration,\\n        uint32 cliffDuration,\\n        uint32 interval,\\n        bool isRevocable\\n    ) public virtual;\\n\\n    function addGrantWithScheduleAt(\\n        address beneficiary,\\n        uint256 vestingAmount,\\n        uint32 startDay,\\n        address vestingLocation\\n    ) external virtual;\\n\\n    function addGrantFromToday(\\n        address beneficiary,\\n        uint256 vestingAmount,\\n        uint32 duration,\\n        uint32 cliffDuration,\\n        uint32 interval,\\n        bool isRevocable\\n    ) external virtual;\\n\\n\\n    // =========================================================================\\n    // === Check vesting.\\n    // =========================================================================\\n\\n    function today() public virtual view returns (uint32 dayNumber);\\n\\n    function getGrantInfo(address grantHolder, uint32 onDayOrToday)\\n    external virtual view returns (\\n        uint256 amountVested,\\n        uint256 amountNotVested,\\n        uint256 amountOfGrant,\\n        uint256 amountAvailable,\\n        uint256 amountClaimed,\\n        uint32 vestStartDay,\\n        bool isActive,\\n        bool wasRevoked\\n    );\\n\\n    function getScheduleAtInfo(address vestingLocation)\\n    public virtual view returns (\\n        bool isRevocable,\\n        uint32 vestDuration,\\n        uint32 cliffDuration,\\n        uint32 vestIntervalDays\\n    );\\n\\n    function getScheduleInfo(address grantHolder)\\n    external virtual view returns (\\n        bool isRevocable,\\n        uint32 vestDuration,\\n        uint32 cliffDuration,\\n        uint32 vestIntervalDays\\n    );\\n\\n\\n    // =========================================================================\\n    // === Grant revocation\\n    // =========================================================================\\n\\n    function revokeGrant(address grantHolder) external virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"grantHolder\",\"type\":\"address\"}],\"name\":\"GrantRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRevocable\",\"type\":\"bool\"}],\"name\":\"VestingScheduleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingTokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"}],\"name\":\"VestingTokensGranted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isRevocable\",\"type\":\"bool\"}],\"name\":\"addGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isRevocable\",\"type\":\"bool\"}],\"name\":\"addGrantFromToday\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"}],\"name\":\"addGrantWithScheduleAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"claimVestingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimVestingTokensForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"grantHolder\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"onDayOrToday\",\"type\":\"uint32\"}],\"name\":\"getGrantInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountNotVested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfGrant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"vestStartDay\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"wasRevoked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"}],\"name\":\"getScheduleAtInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRevocable\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"vestDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vestIntervalDays\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"grantHolder\",\"type\":\"address\"}],\"name\":\"getScheduleInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRevocable\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"vestDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vestIntervalDays\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"grantHolder\",\"type\":\"address\"}],\"name\":\"revokeGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vestingLocation\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"cliffDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"interval\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isRevocable\",\"type\":\"bool\"}],\"name\":\"setVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"today\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"dayNumber\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenVesting","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d528cf2e081f72908e086f8800977df826b5a483","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}