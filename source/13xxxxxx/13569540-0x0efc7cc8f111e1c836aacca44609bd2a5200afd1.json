{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// get the owner of NFT\r\ninterface ERC721 {\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n}\r\n\r\n\r\nfunction isNftOwner(address nft, uint256 tokenid, address owner) view returns (bool) {\r\n    address addr = ERC721(nft).ownerOf(tokenid);\r\n    return addr == owner;\r\n}\r\n\r\nfunction min(uint256 a, uint256 b) pure returns (uint256) {\r\n    return a < b ? a : b;\r\n}\r\n\r\n\r\n/** \r\n * @title RedPacket\r\n * @dev put some money in NFT.\r\n * \r\n * V3: add contract fee. min(0.001 eth, value*0.001)\r\n * V4: support secret packet\r\n */\r\ncontract RedPacket {\r\n    address feeOwner;\r\n    uint256 feeValue;\r\n    \r\n    struct Packet {\r\n        bool seald;  // if true, the envelope can't modify.\r\n        bool secret; // if true, hide the value  \r\n        uint value;  // the money stored in.\r\n    }\r\n    \r\n    // nft address => token-id  => envelope\r\n    mapping(address => mapping(uint256 => Packet)) packets;\r\n    \r\n    // get owner \r\n    constructor()  {\r\n        feeOwner = msg.sender;\r\n    }\r\n\r\n    // put money in NFT\r\n    function send(address payable nft, uint256 tokenid, bool secret) public payable {\r\n        // get owner of the \r\n        address owner = msg.sender;\r\n        Packet memory env = packets[nft][tokenid];\r\n        \r\n        // validate\r\n        require(!env.seald, \"sealed envelope can't modify.\");\r\n        require(isNftOwner(nft, tokenid, owner), \"only nft owner can store money.\");\r\n        \r\n        // save state\r\n        packets[nft][tokenid] = Packet(true, secret, msg.value);\r\n    }\r\n  \r\n    // get money from NFT\r\n    function open(address payable nft, uint256 tokenid) public {\r\n        // get owner of the \r\n        address owner = msg.sender;\r\n        Packet memory env = packets[nft][tokenid];\r\n        \r\n        // validate\r\n        require(env.seald, \"it's not a valid envelope.\");\r\n        require(isNftOwner(nft, tokenid, owner), \"only nft owner can withdraw money.\");\r\n        \r\n         // get fee\r\n        uint256 fee = min(0.001 ether, env.value/1000);\r\n        uint256 value = env.value - fee;\r\n        \r\n        // unpack envelope\r\n        feeValue += fee;\r\n        packets[nft][tokenid] = Packet(false, false, 0);\r\n        \r\n        // return money to the owner\r\n        payable(owner).transfer(value);\r\n        \r\n        // assert \r\n        assert(env.value >= fee);\r\n    }\r\n    \r\n    function peep(address nft, uint256 tokenid) public view returns(Packet memory) {\r\n        Packet memory env = packets[nft][tokenid];\r\n        if (env.secret && !isNftOwner(nft, tokenid, msg.sender))  {\r\n            env.value = 0;\r\n        }\r\n        return env;\r\n    }\r\n    \r\n    // withdraw owner fee\r\n    function withdrawFee() public {\r\n        require(feeOwner == msg.sender, \"only contract owner can withdraw\");\r\n        require(feeValue > 0, \"no fee no withdraw\");\r\n        \r\n        require(address(this).balance >= feeValue);\r\n        \r\n        uint256 value = feeValue;\r\n        \r\n        // do withdraw\r\n        feeValue = 0;\r\n        payable(feeOwner).transfer(value);\r\n        \r\n        // assert\r\n        assert(feeValue == 0);\r\n    }\r\n    \r\n    // get fees \r\n    function getFeeValue() public view returns(uint256) {\r\n        require(feeOwner == msg.sender, \"only contract owner can see fee value\");\r\n        \r\n        // return fees\r\n        return feeValue;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getFeeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"peep\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"seald\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"secret\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RedPacket.Packet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"secret\",\"type\":\"bool\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RedPacket","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2c64d8ab085d55aa372126c716de279fca0d32ff7b7b5e22399f8423525ceaf0"}]}