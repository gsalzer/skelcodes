{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/allocated-editions/MirrorAllocatedEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\nimport {Ownable} from \\\"../../lib/Ownable.sol\\\";\\nimport {IMirrorAllocatedEditionsLogic} from \\\"./interface/IMirrorAllocatedEditionsLogic.sol\\\";\\nimport {IERC721, IERC721Events, IERC721Receiver, IERC721Metadata} from \\\"../../lib/ERC721/interface/IERC721.sol\\\";\\nimport {IERC165} from \\\"../../lib/ERC165/interface/IERC165.sol\\\";\\nimport {IERC2981} from \\\"../../lib/ERC2981/interface/IERC2981.sol\\\";\\nimport {IMirrorOpenSaleV0} from \\\"../../distributors/open-sale/interface/IMirrorOpenSaleV0.sol\\\";\\nimport {IERC2309} from \\\"../../lib/ERC2309/interface/IERC2309.sol\\\";\\n\\n/**\\n * @title MirrorAllocatedEditionsLogic\\n * @author MirrorXYZ\\n */\\ncontract MirrorAllocatedEditionsLogic is\\n    Ownable,\\n    IMirrorAllocatedEditionsLogic,\\n    IERC721,\\n    IERC721Events,\\n    IERC165,\\n    IERC721Metadata,\\n    IERC2309,\\n    IERC2981\\n{\\n    /// @notice Token name\\n    string public override name;\\n\\n    /// @notice Token symbol\\n    string public override symbol;\\n\\n    /// @notice Token baseURI\\n    string public baseURI;\\n\\n    /// @notice Token contentHash\\n    bytes32 public contentHash;\\n\\n    /// @notice Token supply\\n    uint256 public totalSupply;\\n\\n    /// @notice Burned tokens\\n    mapping(uint256 => bool) internal _burned;\\n\\n    /// @notice Token owners\\n    mapping(uint256 => address) internal _owners;\\n\\n    /// @notice Token balances\\n    mapping(address => uint256) internal _balances;\\n\\n    /// @notice Token approvals\\n    mapping(uint256 => address) internal _tokenApprovals;\\n\\n    /// @notice Token operator approvals\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    /// @notice Mirror open sale address\\n    address public immutable mirrorOpenSale;\\n\\n    // ============ Royalty Info (ERC2981) ============\\n\\n    /// @notice Account that will receive royalties\\n    /// @dev set address(0) to avoid royalties\\n    address public royaltyRecipient;\\n\\n    /// @notice Royalty percentage\\n    uint256 public royaltyPercentage;\\n\\n    /// @dev Sets zero address as owner since this is a logic contract\\n    /// @param mirrorOpenSale_ sale contract address\\n    constructor(address mirrorOpenSale_) Ownable(address(0)) {\\n        mirrorOpenSale = mirrorOpenSale_;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    /// @dev Initialize contract\\n    /// @param metadata ERC721Metadata parameters\\n    /// @param owner_ owner of this contract\\n    /// @param fundingRecipient_ account that will receive funds from sales\\n    /// @param royaltyRecipient_ account that will receive royalties\\n    /// @param royaltyPercentage_ royalty percentage\\n    /// @param price sale listing price\\n    /// @param list whether to list on sale contract\\n    /// @param open whether to list with a closed or open sale\\n    /// @dev Initialize parameters, mint total suppply to owner. Reverts if called\\n    /// after contract deployment. If list is true, the open sale contract gets approval\\n    /// for all tokens.\\n    function initialize(\\n        NFTMetadata memory metadata,\\n        address owner_,\\n        address payable fundingRecipient_,\\n        address payable royaltyRecipient_,\\n        uint256 royaltyPercentage_,\\n        uint256 price,\\n        bool list,\\n        bool open,\\n        uint256 feePercentage\\n    ) external override {\\n        // ensure that this function is only callable during contract construction.\\n        assembly {\\n            if extcodesize(address()) {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        // NFT Metadata\\n        name = metadata.name;\\n        symbol = metadata.symbol;\\n        baseURI = metadata.baseURI;\\n        contentHash = metadata.contentHash;\\n        totalSupply = metadata.quantity;\\n\\n        // Set owner\\n        _setOwner(address(0), owner_);\\n\\n        // Royalties\\n        royaltyRecipient = royaltyRecipient_;\\n        royaltyPercentage = royaltyPercentage_;\\n\\n        emit ConsecutiveTransfer(\\n            // fromTokenId\\n            0,\\n            // toTokenId\\n            metadata.quantity - 1,\\n            // fromAddress\\n            address(0),\\n            // toAddress\\n            owner_\\n        );\\n\\n        _balances[owner_] = totalSupply;\\n\\n        if (list) {\\n            IMirrorOpenSaleV0(mirrorOpenSale).register(\\n                IMirrorOpenSaleV0.SaleConfig({\\n                    token: address(this),\\n                    startTokenId: 0,\\n                    endTokenId: totalSupply - 1,\\n                    operator: owner_,\\n                    recipient: fundingRecipient_,\\n                    price: price,\\n                    open: open,\\n                    feePercentage: feePercentage\\n                })\\n            );\\n\\n            _operatorApprovals[owner_][mirrorOpenSale] = true;\\n\\n            emit ApprovalForAll(\\n                // owner\\n                owner_,\\n                // operator\\n                mirrorOpenSale,\\n                // approved\\n                true\\n            );\\n        }\\n    }\\n\\n    // ============ ERC721 Methods ============\\n\\n    function balanceOf(address owner_) public view override returns (uint256) {\\n        require(\\n            owner_ != address(0),\\n            \\\"ERC721: balance query for the zero address\\\"\\n        );\\n\\n        return _balances[owner_];\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        address _owner = _owners[tokenId];\\n\\n        // if there is not owner set, and the token is not burned, the operator owns it\\n        if (_owner == address(0) && !_burned[tokenId]) {\\n            return owner;\\n        }\\n\\n        require(_owner != address(0), \\\"ERC721: query for nonexistent token\\\");\\n\\n        return _owner;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public override {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public override {\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner_ = ownerOf(tokenId);\\n        require(to != owner_, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            msg.sender == owner_ || isApprovedForAll(owner_, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721: approved query for nonexistent token\\\"\\n        );\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        override\\n    {\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(\\n            // owner\\n            msg.sender,\\n            // operator\\n            operator,\\n            // approved\\n            approved\\n        );\\n    }\\n\\n    function isApprovedForAll(address owner_, address operator_)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner_][operator_];\\n    }\\n\\n    // ============ ERC721 Metadata Methods ============\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(baseURI, _toString(tokenId)));\\n    }\\n\\n    function contractURI() public view returns (string memory) {\\n        return string(abi.encodePacked(baseURI, \\\"metadata\\\"));\\n    }\\n\\n    function getContentHash(uint256) public view returns (bytes32) {\\n        return contentHash;\\n    }\\n\\n    // ============ Burn Method ============\\n\\n    function burn(uint256 tokenId) public {\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        _burn(tokenId);\\n    }\\n\\n    // ============ ERC2981 Methods ============\\n\\n    /// @notice Get royalty info\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        receiver = royaltyRecipient;\\n        royaltyAmount = (_salePrice * royaltyPercentage) / 10_000;\\n    }\\n\\n    function setRoyaltyInfo(\\n        address payable royaltyRecipient_,\\n        uint256 royaltyPercentage_\\n    ) external override onlyOwner {\\n        royaltyRecipient = royaltyRecipient_;\\n        royaltyPercentage = royaltyPercentage_;\\n\\n        emit RoyaltyChange(\\n            // oldRoyaltyRecipient\\n            royaltyRecipient,\\n            // oldRoyaltyPercentage\\n            royaltyPercentage,\\n            // newRoyaltyRecipient\\n            royaltyRecipient_,\\n            // newRoyaltyPercentage\\n            royaltyPercentage_\\n        );\\n    }\\n\\n    // ============ IERC165 Method ============\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IERC2981).interfaceId;\\n    }\\n\\n    // ============ Internal Methods ============\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(\\n            ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer of token that is not own\\\"\\n        );\\n\\n        require(\\n            to != address(0),\\n            \\\"ERC721: transfer to the zero address (use burn instead)\\\"\\n        );\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n\\n        _owners[tokenId] = to;\\n        _balances[to] += 1;\\n\\n        emit Transfer(\\n            // from\\n            from,\\n            // to\\n            to,\\n            // tokenId\\n            tokenId\\n        );\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return !_burned[tokenId];\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner_ = ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner_] -= 1;\\n\\n        delete _owners[tokenId];\\n\\n        _burned[tokenId] = true;\\n\\n        emit Transfer(\\n            // from\\n            owner_,\\n            // to\\n            address(0),\\n            // tokenId\\n            tokenId\\n        );\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(_exists(tokenId), \\\"ERC721: query for nonexistent token\\\");\\n\\n        address owner_ = ownerOf(tokenId);\\n\\n        return (spender == owner_ ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner_, spender));\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal {\\n        _tokenApprovals[tokenId] = to;\\n\\n        emit Approval(\\n            // owner\\n            ownerOf(tokenId),\\n            // approved\\n            to,\\n            // tokenId\\n            tokenId\\n        );\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (_isContract(to)) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n                    );\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\\n    function _isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n    function _toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/allocated-editions/interface/IMirrorAllocatedEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IMirrorAllocatedEditionsLogic {\\n    event RoyaltyChange(\\n        address indexed oldRoyaltyRecipient,\\n        uint256 oldRoyaltyPercentage,\\n        address indexed newRoyaltyRecipient,\\n        uint256 newRoyaltyPercentage\\n    );\\n\\n    struct NFTMetadata {\\n        string name;\\n        string symbol;\\n        string baseURI;\\n        bytes32 contentHash;\\n        uint256 quantity;\\n    }\\n\\n    function initialize(\\n        NFTMetadata memory metadata,\\n        address operator_,\\n        address payable fundingRecipient_,\\n        address payable royaltyRecipient_,\\n        uint256 royaltyPercentage_,\\n        uint256 price,\\n        bool list,\\n        bool open,\\n        uint256 feePercentage\\n    ) external;\\n\\n    function setRoyaltyInfo(\\n        address payable royaltyRecipient_,\\n        uint256 royaltyPercentage_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC721/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Burnable is IERC721 {\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC721Royalties {\\n    function getFeeRecipients(uint256 id)\\n        external\\n        view\\n        returns (address payable[] memory);\\n\\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC165/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC2981/interface/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\n/**\\n * @title IERC2981\\n * @notice Interface for the NFT Royalty Standard\\n */\\ninterface IERC2981 {\\n    // / bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n\\n    /**\\n     * @notice Called with the sale price to determine how much royalty\\n     *         is owed and to whom.\\n     * @param _tokenId - the NFT asset queried for royalty information\\n     * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n     * @return receiver - address of who should be sent the royalty payment\\n     * @return royaltyAmount - the royalty payment amount for _salePrice\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/distributors/open-sale/interface/IMirrorOpenSaleV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IMirrorOpenSaleV0Events {\\n    event RegisteredSale(\\n        bytes32 h,\\n        address indexed token,\\n        uint256 startTokenId,\\n        uint256 endTokenId,\\n        address indexed operator,\\n        address indexed recipient,\\n        uint256 price,\\n        bool open,\\n        uint256 feePercentage\\n    );\\n\\n    event Purchase(\\n        bytes32 h,\\n        address indexed token,\\n        uint256 tokenId,\\n        address indexed buyer,\\n        address indexed recipient\\n    );\\n\\n    event Withdraw(\\n        bytes32 h,\\n        uint256 amount,\\n        uint256 fee,\\n        address indexed recipient\\n    );\\n\\n    event OpenSale(bytes32 h);\\n\\n    event CloseSale(bytes32 h);\\n}\\n\\ninterface IMirrorOpenSaleV0 {\\n    struct Sale {\\n        bool registered;\\n        bool open;\\n        uint256 sold;\\n        address operator;\\n    }\\n\\n    struct SaleConfig {\\n        address token;\\n        uint256 startTokenId;\\n        uint256 endTokenId;\\n        address operator;\\n        address recipient;\\n        uint256 price;\\n        bool open;\\n        uint256 feePercentage;\\n    }\\n\\n    function treasuryConfig() external returns (address);\\n\\n    function feeRegistry() external returns (address);\\n\\n    function tributaryRegistry() external returns (address);\\n\\n    function sale(bytes32 h) external view returns (Sale memory);\\n\\n    function register(SaleConfig calldata saleConfig_) external;\\n\\n    function close(SaleConfig calldata saleConfig_) external;\\n\\n    function open(SaleConfig calldata saleConfig_) external;\\n\\n    function purchase(SaleConfig calldata saleConfig_, address recipient)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC2309/interface/IERC2309.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.10;\\n\\ninterface IERC2309 {\\n    event ConsecutiveTransfer(\\n        uint256 indexed fromTokenId,\\n        uint256 toTokenId,\\n        address indexed fromAddress,\\n        address indexed toAddress\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mirrorOpenSale_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRoyaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRoyaltyPercentage\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRoyaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoyaltyPercentage\",\"type\":\"uint256\"}],\"name\":\"RoyaltyChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getContentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct IMirrorAllocatedEditionsLogic.NFTMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"royaltyRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyPercentage_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"list\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorOpenSale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"royaltyRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyPercentage_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MirrorAllocatedEditionsLogic","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000092007459ffd58cd41a28323a4f6cdb0a2d1c6139","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}