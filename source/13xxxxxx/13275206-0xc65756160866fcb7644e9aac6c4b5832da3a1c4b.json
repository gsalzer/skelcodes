{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/adapters/ProtocolAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Protocol adapter abstract contract.\\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract ProtocolAdapter {\\n    /**\\n     * @dev MUST return amount and type of the given token\\n     * locked on the protocol by the given account.\\n     */\\n    function getBalance(address token, address account) public virtual returns (int256);\\n}\\n\"\r\n    },\r\n    \"/contracts/adapters/uniswap/UniswapExchangeAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { ERC20 } from \\\"../../interfaces/ERC20.sol\\\";\\nimport { ProtocolAdapter } from \\\"../ProtocolAdapter.sol\\\";\\n\\n/**\\n * @title Adapter for Uniswap V1/V2 protocol (exchange).\\n * @dev Implementation of ProtocolAdapter abstract contract.\\n * Base contract for Uniswap V1/V2 exchange adapter.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract UniswapExchangeAdapter is ProtocolAdapter {\\n    /**\\n     * @notice This function is unavailable for exchange adapter.\\n     * @dev Implementation of ProtocolAdapter abstract contract function.\\n     */\\n    function getBalance(address, address) public pure override returns (int256) {\\n        revert(\\\"UEA: no balance\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interactiveAdapters/InteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { ProtocolAdapter } from \\\"../adapters/ProtocolAdapter.sol\\\";\\nimport { TokenAmount, AmountType } from \\\"../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../interfaces/ERC20.sol\\\";\\n\\n/**\\n * @title Base contract for interactive protocol adapters.\\n * @dev deposit() and withdraw() functions MUST be implemented\\n * as well as all the functions from ProtocolAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract InteractiveAdapter is ProtocolAdapter {\\n    uint256 internal constant DELIMITER = 1e18;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /**\\n     * @dev The function must deposit assets to the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function deposit(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    /**\\n     * @dev The function must withdraw assets from the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function withdraw(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    function getAbsoluteAmountWithdraw(TokenAmount calldata tokenAmount)\\n        internal\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            int256 balanceSigned = getBalance(token, address(this));\\n            uint256 balance = balanceSigned > 0 ? uint256(balanceSigned) : uint256(-balanceSigned);\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul_(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function getAbsoluteAmountDeposit(TokenAmount calldata tokenAmount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            uint256 balance;\\n            if (token == ETH) {\\n                balance = address(this).balance;\\n            } else {\\n                balance = ERC20(token).balanceOf(address(this));\\n            }\\n\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul_(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"IA: mul overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interactiveAdapters/uniswap/UniswapV3ExchangeInteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport { ERC20 } from \\\"../../interfaces/ERC20.sol\\\";\\nimport { SafeERC20 } from \\\"../../shared/SafeERC20.sol\\\";\\nimport { TokenAmount, AmountType } from \\\"../../shared/Structs.sol\\\";\\nimport { UniswapExchangeAdapter } from \\\"../../adapters/uniswap/UniswapExchangeAdapter.sol\\\";\\nimport { InteractiveAdapter } from \\\"../InteractiveAdapter.sol\\\";\\nimport { ISwapRouter } from \\\"../../interfaces/ISwapRouter.sol\\\";\\n\\n/**\\n * @title Interactive adapter for Uniswap V3 protocol (exactInput).\\n * @dev Implementation of InteractiveAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract UniswapV3ExchangeInteractiveAdapter is InteractiveAdapter, UniswapExchangeAdapter {\\n    using SafeERC20 for ERC20;\\n\\n    address internal constant SWAP_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n\\n    /**\\n     * @notice Exchange tokens using Uniswap v3 SwapRouter.\\n     * @param tokenAmounts Array with one element - TokenAmount struct with\\n     * \\\"from\\\" token address, \\\"from\\\" token amount, and amount type.\\n     * @param data Uniswap v3 exchange path & out address.\\n     * @return tokensToBeWithdrawn Array with one element - token address to be exchanged to.\\n     * @dev Implementation of InteractiveAdapter function.\\n     */\\n    function deposit(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        override\\n        returns (address[] memory tokensToBeWithdrawn)\\n    {\\n        require(tokenAmounts.length == 1, \\\"Uv3EIA: should be 1 tokenAmount\\\");\\n\\n        address token = tokenAmounts[0].token;\\n        uint256 amount = getAbsoluteAmountDeposit(tokenAmounts[0]);\\n\\n        bytes memory path;\\n        tokensToBeWithdrawn = new address[](1);\\n        (path, tokensToBeWithdrawn[0]) = abi.decode(data, (bytes, address));\\n\\n        ERC20(token).safeApproveMax(SWAP_ROUTER, amount, \\\"Uv3EIA\\\");\\n\\n        try\\n            ISwapRouter(SWAP_ROUTER).exactInput(\\n                ISwapRouter.ExactInputParams({\\n                    path: path,\\n                    recipient: address(this),\\n                    // solhint-disable-next-line not-rely-on-time\\n                    deadline: block.timestamp,\\n                    amountIn: amount,\\n                    amountOutMinimum: 0\\n                })\\n            )\\n        returns (uint256) {\\n            // solhint-disable-previous-line no-empty-blocks\\n        } catch Error(string memory reason) {\\n            revert(reason);\\n        } catch {\\n            revert(\\\"Uv3EIA: swap fail\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdraw functionality is not supported, yet. However, it's possible to implement.\\n     * @dev Implementation of InteractiveAdapter function.\\n     */\\n    function withdraw(TokenAmount[] calldata, bytes calldata)\\n        external\\n        payable\\n        override\\n        returns (address[] memory)\\n    {\\n        revert(\\\"Uv3EIA: no withdraw\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address, address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter {\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"/contracts/shared/SafeERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/ERC20.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\\n * returns false). Tokens that return no value (and instead revert or throw on failure)\\n * are also supported, non-reverting calls are assumed to be successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value),\\n            \\\"transfer\\\",\\n            location\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value),\\n            \\\"transferFrom\\\",\\n            location\\n        );\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address spender,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            string(abi.encodePacked(\\\"SafeERC20: bad approve call from \\\", location))\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value),\\n            \\\"approve\\\",\\n            location\\n        );\\n    }\\n\\n    function safeApproveMax(\\n        ERC20 token,\\n        address spender,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        uint256 allowance = ERC20(token).allowance(address(this), spender);\\n        if (allowance < value) {\\n            if (allowance > 0) {\\n                safeApprove(token, spender, 0, location);\\n            }\\n            safeApprove(token, spender, type(uint256).max, location);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\\n     * relaxing the requirement on the return value: the return value is optional\\n     * (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     * @param location Location of the call (for debug).\\n     */\\n    function callOptionalReturn(\\n        ERC20 token,\\n        bytes memory data,\\n        string memory functionName,\\n        string memory location\\n    ) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\\n        // mechanism, since we're implementing it ourselves.\\n\\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\\n        //  1. The call itself is made, and success asserted\\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(\\n            success,\\n            string(abi.encodePacked(\\\"SafeERC20: \\\", functionName, \\\" failed in \\\", location))\\n        );\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(\\n                abi.decode(returndata, (bool)),\\n                string(\\n                    abi.encodePacked(\\\"SafeERC20: \\\", functionName, \\\" returned false in \\\", location)\\n                )\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/shared/Structs.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n// The struct consists of TokenBalanceMeta structs for\\n// (base) token and its underlying tokens (if any).\\nstruct FullTokenBalance {\\n    TokenBalanceMeta base;\\n    TokenBalanceMeta[] underlying;\\n}\\n\\n// The struct consists of TokenBalance struct\\n// with token address and absolute amount\\n// and ERC20Metadata struct with ERC20-style metadata.\\n// NOTE: 0xEeee...EEeE address is used for ETH.\\nstruct TokenBalanceMeta {\\n    TokenBalance tokenBalance;\\n    ERC20Metadata erc20metadata;\\n}\\n\\n// The struct consists of ERC20-style token metadata.\\nstruct ERC20Metadata {\\n    string name;\\n    string symbol;\\n    uint8 decimals;\\n}\\n\\n// The struct consists of protocol adapter's name\\n// and array of TokenBalance structs\\n// with token addresses and absolute amounts.\\nstruct AdapterBalance {\\n    bytes32 protocolAdapterName;\\n    TokenBalance[] tokenBalances;\\n}\\n\\n// The struct consists of token address\\n// and its absolute amount (may be negative).\\n// 0xEeee...EEeE is used for Ether\\nstruct TokenBalance {\\n    address token;\\n    int256 amount;\\n}\\n\\n// The struct consists of token address,\\n// and price per full share (1e18).\\n// 0xEeee...EEeE is used for Ether\\nstruct Component {\\n    address token;\\n    int256 rate;\\n}\\n\\n//=============================== Interactive Adapters Structs ====================================\\n\\n// The struct consists of name of the protocol adapter,\\n// action type, array of token amounts,\\n// and some additional data (depends on the protocol).\\nstruct Action {\\n    bytes32 protocolAdapterName;\\n    ActionType actionType;\\n    TokenAmount[] tokenAmounts;\\n    bytes data;\\n}\\n\\n// The struct consists of token address,\\n// its amount, and amount type, as well as\\n// permit type and calldata.\\nstruct Input {\\n    TokenAmount tokenAmount;\\n    Permit permit;\\n}\\n\\n// The struct consists of\\n// permit type and calldata.\\nstruct Permit {\\n    PermitType permitType;\\n    bytes permitCallData;\\n}\\n\\n// The struct consists of token address,\\n// its amount, and amount type.\\n// 0xEeee...EEeE is used for Ether\\nstruct TokenAmount {\\n    address token;\\n    uint256 amount;\\n    AmountType amountType;\\n}\\n\\n// The struct consists of fee share\\n// and beneficiary address.\\nstruct Fee {\\n    uint256 share;\\n    address beneficiary;\\n}\\n\\n// The struct consists of token address\\n// and its absolute amount.\\n// 0xEeee...EEeE is used for Ether\\nstruct AbsoluteTokenAmount {\\n    address token;\\n    uint256 absoluteAmount;\\n}\\n\\nenum ActionType {\\n    None,\\n    Deposit,\\n    Withdraw\\n}\\n\\nenum AmountType {\\n    None,\\n    Relative,\\n    Absolute\\n}\\n\\nenum PermitType {\\n    None,\\n    EIP2612,\\n    DAI,\\n    Yearn\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToBeWithdrawn\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"UniswapV3ExchangeInteractiveAdapter","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}