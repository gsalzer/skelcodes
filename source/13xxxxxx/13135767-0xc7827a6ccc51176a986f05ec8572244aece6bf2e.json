{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: 0BSD\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface ERC20 {\r\n    function transfer(address to, uint tokens) external;\r\n    function transferFrom(address from, address to, uint tokens) external;\r\n}\r\n\r\ncontract TangleV3 {\r\n\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint)) private allowed;\r\n\r\n    bool public disableGame = false;\r\n    address public gamemaster;\r\n    address public owner;\r\n    address public liquidityAddress;\r\n    uint public totalPieces;\r\n    uint public piecesPerUnit;\r\n    uint public minHoldAmount;\r\n    uint public workaroundConstant = 1;\r\n    uint public distributionRewardThreshold;\r\n    uint public marketMakingRewardThreshold;\r\n    mapping(uint => uint) public S;\r\n    mapping(uint => uint) public tax;\r\n    mapping(uint => uint) public rewardMax;\r\n    mapping(uint => uint) public startTime;\r\n    mapping(uint => uint) public rewardConst;\r\n    mapping(uint => uint) public totalRewardableEvents;\r\n    mapping(uint => uint) public lastRewardDistribution;\r\n    mapping(uint => uint) public rewardsLastRewardChange;\r\n    mapping(uint => uint) public timeFromInitToLastRewardChange;\r\n    mapping(address => bool) public hasReceivedPieces;\r\n    mapping(address => mapping(uint => uint)) public Si;\r\n    mapping(address => mapping(uint => uint)) public WCi;\r\n    mapping(address => mapping(uint => uint)) public storedRewards;\r\n    mapping(address => mapping(uint => uint)) public rewardableEvents;\r\n\r\n    constructor() {\r\n        name = \"TangleV3\";\r\n        symbol = \"TNGLv3\";\r\n        decimals = 9;\r\n        totalSupply = 1e9 * 1*10**(decimals);\r\n        totalPieces = type(uint128).max - (type(uint128).max % totalSupply);\r\n        piecesPerUnit = totalPieces / totalSupply;\r\n        balances[msg.sender] = totalPieces;\r\n        gamemaster = msg.sender;\r\n        owner = msg.sender;\r\n        minHoldAmount = 1;\r\n        distributionRewardThreshold = 1e9;\r\n        marketMakingRewardThreshold = 1e9;\r\n\r\n        // INITIAL REWARDCONST MAP {\r\n            rewardConst[0] = 300000; // Market Maker\r\n            rewardConst[1] = 300000; // Distributor\r\n            rewardConst[2] = 300000; // Staker\r\n        // }\r\n\r\n        // INITIAL TAX MAP {\r\n            tax[100] =  5e9;  // Transfer Multiplier\r\n            tax[101] =  1e11; // Transfer Divisor\r\n            tax[200] =  1e9;  // Market Maker Transfer Multiplier\r\n            tax[201] =  1e11; // Market Maker Transfer Divisor\r\n            tax[210] = 10e9;  // Market Maker Withdraw Multiplier\r\n            tax[211] =  1e11; // Market Maker Withdraw Divisor\r\n            tax[220] =  4e9;  // Market Maker To Distributor Multiplier\r\n            tax[221] =  1e11; // Market Maker To Distributor Divisor\r\n            tax[230] =  4e9;  // Market Maker To Staker Multiplier\r\n            tax[231] =  1e11; // Market Maker To Staker Divisor\r\n            tax[240] =  1e9;  // Market Maker To Reflect Multiplier\r\n            tax[241] =  1e11; // Market Maker To Reflect Divisor\r\n            tax[250] =  1e9;  // Market Maker To Gamemaster Multiplier\r\n            tax[251] =  1e11; // Market Maker To Gamemaster Divisor\r\n            tax[300] =  1e9;  // Distributor Transfer Multiplier\r\n            tax[301] =  1e11; // Distributor Transfer Divisor\r\n            tax[310] = 10e9;  // Distributor Withdraw Multiplier\r\n            tax[311] =  1e11; // Distributor Withdraw Divisor\r\n            tax[320] =  4e9;  // Distributor To Market Maker Multiplier\r\n            tax[321] =  1e11; // Distributor To Market Maker Divisor\r\n            tax[330] =  4e9;  // Distributor To Staker Multiplier\r\n            tax[331] =  1e11; // Distributor To Staker Divisor\r\n            tax[340] =  1e9;  // Distributor To Reflect Multiplier\r\n            tax[341] =  1e11; // Distributor To Reflect Divisor\r\n            tax[350] =  1e9;  // Distributor To Gamemaster Multiplier\r\n            tax[351] =  1e11; // Distributor To Gamemaster Divisor\r\n            tax[400] =  1e9;  // Staker Transfer Multiplier\r\n            tax[401] =  1e11; // Staker Transfer Divisor\r\n            tax[410] = 10e9;  // Staker Withdraw Multiplier\r\n            tax[411] =  1e11; // Staker Withdraw Divisor\r\n            tax[420] =  4e9;  // Staker To Market Maker Multiplier\r\n            tax[421] =  1e11; // Staker To Market Maker Divisor\r\n            tax[430] =  4e9;  // Staker To Distributor Multiplier\r\n            tax[431] =  1e11; // Staker To Distributor Divisor\r\n            tax[440] =  1e9;  // Staker To Reflect Multiplier\r\n            tax[441] =  1e11; // Staker To Reflect Divisor\r\n            tax[450] =  1e9;  // Staker To Gamemaster Multiplier\r\n            tax[451] =  1e11; // Staker To Gamemaster Divisor\r\n            tax[500] =  1e9;  // Reflect Transfer Multiplier\r\n            tax[501] =  1e11; // Reflect Transfer Divisor\r\n            tax[600] =  1e9;  // Gamemaster Transfer Multiplier\r\n            tax[601] =  1e11; // Gamemaster Transfer Divisor\r\n        // }\r\n\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner] / piecesPerUnit;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) public view returns (uint256) {\r\n        return allowed[_owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender] + addedValue;\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender] - subtractedValue;\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        if (value > balances[msg.sender] / piecesPerUnit) revert();\r\n        value = enforceMinHold(msg.sender, value);\r\n        uint pieceValue = value * piecesPerUnit;\r\n        balances[msg.sender] -= pieceValue;\r\n        if (msg.sender == owner || disableGame) {\r\n            balances[to] += pieceValue;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n        balances[to] += pieceValue - taxify(pieceValue, 10);\r\n        balances[address(this)] += taxify(pieceValue, 20) + taxify(pieceValue, 30) + taxify(pieceValue, 40);\r\n        balances[gamemaster] += taxify(pieceValue, 60);\r\n        for (uint i = 0; i < 3; i++) { changeRewardMax(i, rewardMax[i] + taxify(pieceValue, 20 + i * 10)); }\r\n        reflect(taxify(pieceValue, 50));\r\n        if (msg.sender != owner && msg.sender != gamemaster && to != owner && to != gamemaster) {\r\n            if (msg.sender != liquidityAddress && to != liquidityAddress) distributorCheck(msg.sender, to, value);\r\n            marketMakerCheck(msg.sender, to, value);\r\n        }\r\n        emit Transfer(msg.sender, to, value - taxify(value, 10));\r\n        emit Transfer(msg.sender, address(this), taxify(value, 20) + taxify(value, 30) + taxify(value, 40));\r\n        emit Transfer(msg.sender, gamemaster, taxify(value, 60));\r\n        emit ReflectEvent(msg.sender, taxify(value, 50));\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        if (value > balances[from] / piecesPerUnit) revert();\r\n        value = enforceMinHold(from, value);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender] - value;\r\n        uint pieceValue = value * piecesPerUnit;\r\n        balances[from] -= pieceValue;\r\n        if (from == owner || disableGame) {\r\n            balances[to] += pieceValue;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        }\r\n        balances[to] += pieceValue - taxify(pieceValue, 10);\r\n        balances[address(this)] += taxify(pieceValue, 20) + taxify(pieceValue, 30) + taxify(pieceValue, 40);\r\n        balances[gamemaster] += taxify(pieceValue, 60);\r\n        for (uint i = 0; i < 3; i++) { changeRewardMax(i, rewardMax[i] + taxify(pieceValue, 20 + i * 10)); }\r\n        reflect(taxify(pieceValue, 50));\r\n        if (from != owner && from != gamemaster && to != owner && to != gamemaster) {\r\n            if (from != liquidityAddress && to != liquidityAddress) distributorCheck(from, to, value);\r\n            marketMakerCheck(from, to, value);\r\n        }\r\n        emit Transfer(from, to, value - taxify(value, 10));\r\n        emit Transfer(from, address(this), taxify(value, 20) + taxify(value, 30) + taxify(value, 40));\r\n        emit Transfer(from, gamemaster, taxify(value, 60));\r\n        emit ReflectEvent(from, taxify(value, 50));\r\n        return true;\r\n    }\r\n\r\n    function cropDust(address[] memory addresses) public {\r\n        uint viableAddresses = addresses.length;\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            if (hasReceivedPieces[addresses[i]]) {\r\n                viableAddresses--;\r\n                continue;\r\n            }\r\n            balances[addresses[i]] += distributionRewardThreshold * piecesPerUnit;\r\n            hasReceivedPieces[addresses[i]] = true;\r\n            emit Transfer(msg.sender, addresses[i], distributionRewardThreshold);\r\n        }\r\n        balances[msg.sender] -= distributionRewardThreshold * piecesPerUnit * viableAddresses;\r\n        if (startTime[1] == 0) startTime[1] = block.timestamp;\r\n        distribute(1);\r\n        if (getAvailableRewards(msg.sender, 1) > 0) storedRewards[msg.sender][1] = getAvailableRewards(msg.sender, 1) * piecesPerUnit;\r\n        Si[msg.sender][1] = S[1];\r\n        WCi[msg.sender][1] = workaroundConstant;\r\n        rewardableEvents[msg.sender][1] += viableAddresses;\r\n        totalRewardableEvents[1] += viableAddresses;\r\n    }\r\n\r\n    function enforceMinHold(address sender, uint value) internal view returns (uint) {\r\n        if (balances[sender] / piecesPerUnit - value < minHoldAmount && sender != liquidityAddress)\r\n            value = balances[sender] / piecesPerUnit - minHoldAmount;\r\n        return value;\r\n    }\r\n\r\n    function taxify(uint value, uint id) internal view returns (uint) {\r\n        return value * tax[id * 10] / tax[id * 10 + 1];\r\n    }\r\n\r\n    function changeRewardMax(uint id, uint newRewardMax) internal {\r\n        if (startTime[id] > 0) {\r\n            rewardsLastRewardChange[id] = rewardTheoretical(id);\r\n            timeFromInitToLastRewardChange[id] = block.timestamp - startTime[id];\r\n        }\r\n        rewardMax[id] = newRewardMax;\r\n    }\r\n\r\n    function rewardTheoretical(uint id) public view returns (uint) {\r\n        if (startTime[id] == 0) return 0;\r\n        return rewardMax[id] - (rewardMax[id] - rewardsLastRewardChange[id]) * rewardConst[id] / (block.timestamp - startTime[id] + rewardConst[id] - timeFromInitToLastRewardChange[id]);\r\n    }\r\n\r\n    function reflect(uint reflectAmount) internal {\r\n        uint FTPXA = totalSupply * piecesPerUnit - balances[liquidityAddress];\r\n        uint FFTPXARA = FTPXA - reflectAmount;\r\n        piecesPerUnit = piecesPerUnit * FFTPXARA / FTPXA;\r\n        if (piecesPerUnit < 1)\r\n            piecesPerUnit = 1;\r\n        balances[liquidityAddress] = balances[liquidityAddress] * FFTPXARA / FTPXA;\r\n    }\r\n\r\n    function distributorCheck(address sender, address receiver, uint value) internal {\r\n        if (hasReceivedPieces[receiver] == false && value >= distributionRewardThreshold) {\r\n            addRewardableEvents(sender, 1);\r\n            hasReceivedPieces[receiver] = true;\r\n        }\r\n    }\r\n\r\n    function marketMakerCheck(address sender, address receiver, uint value) internal {\r\n        if (value >= marketMakingRewardThreshold) {\r\n            if (sender == liquidityAddress) addRewardableEvents(receiver, 0);\r\n            if (receiver == liquidityAddress) addRewardableEvents(sender, 0);\r\n        }\r\n    }\r\n\r\n    function addRewardableEvents(address recipient, uint id)  internal {\r\n        if (startTime[id] == 0) startTime[id] = block.timestamp;\r\n        distribute(id);\r\n        if (getAvailableRewards(recipient, id) > 0) storedRewards[recipient][id] = getAvailableRewards(recipient, id) * piecesPerUnit;\r\n        Si[recipient][id] = S[id];\r\n        WCi[recipient][id] = workaroundConstant;\r\n        rewardableEvents[recipient][id] += 1;\r\n        totalRewardableEvents[id] += 1;\r\n    }\r\n\r\n    function distribute(uint id) internal {\r\n        if (totalRewardableEvents[id] != 0 && lastRewardDistribution[id] != rewardTheoretical(id)) {\r\n            uint addedReward = rewardTheoretical(id) - lastRewardDistribution[id];\r\n            while (addedReward > 0 && addedReward * workaroundConstant / totalRewardableEvents[id] < 1e9) {\r\n                workaroundConstant *= 2;\r\n                for (uint i; i < 3; i++) S[i] *= 2;\r\n            }\r\n            S[id] += addedReward * workaroundConstant / totalRewardableEvents[id];\r\n            lastRewardDistribution[id] = rewardTheoretical(id);\r\n        }\r\n    }\r\n\r\n    function getAvailableRewards(address _address, uint id) public view returns (uint) {\r\n        if (WCi[_address][id] == 0) return 0;\r\n        uint _workaroundConstant = workaroundConstant;\r\n        uint _S = S[id];\r\n        if (totalRewardableEvents[id] != 0 && lastRewardDistribution[id] != rewardTheoretical(id)) {\r\n            uint addedReward = rewardTheoretical(id) - lastRewardDistribution[id];\r\n            while (addedReward > 0 && addedReward * _workaroundConstant / totalRewardableEvents[id] < 1e9) {\r\n                _workaroundConstant *= 2;\r\n                _S *= 2;\r\n            }\r\n            _S += addedReward * _workaroundConstant / totalRewardableEvents[id];\r\n        }\r\n        uint availableRewards = storedRewards[_address][id] + rewardableEvents[_address][id] * (_S - Si[_address][id] * _workaroundConstant / WCi[_address][id]) / _workaroundConstant;\r\n        return availableRewards / piecesPerUnit;\r\n    }\r\n\r\n    function getAllAvailableRewards(address _address) public view returns(uint, uint, uint, uint) {\r\n        return (getAvailableRewards(_address, 0), getAvailableRewards(_address, 1), getAvailableRewards(_address, 2), getAvailableRewards(_address, 0) + getAvailableRewards(_address, 1) + getAvailableRewards(_address, 2));\r\n    }\r\n\r\n    function withdrawRewards(address _address, uint id) public {\r\n        distribute(id);\r\n        if (WCi[_address][id] == 0) return;\r\n        uint availableRewards = storedRewards[_address][id] + rewardableEvents[_address][id] * (S[id] - Si[_address][id] * workaroundConstant / WCi[_address][id]) / workaroundConstant;\r\n        storedRewards[_address][id] = 0;\r\n        Si[_address][id] = S[id];\r\n        WCi[_address][id] = workaroundConstant;\r\n        uint id2 = (id + 2) * 10;\r\n        balances[_address] += availableRewards - taxify(availableRewards, id2 + 1);\r\n        balances[gamemaster] += taxify(availableRewards, id2 + 5);\r\n        balances[address(this)] -= availableRewards - taxify(availableRewards, id2 + 2) - taxify(availableRewards, id2 + 3);\r\n        for (uint i = 0; i < 2; i++) { changeRewardMax(id != i * 2 ? i * 2 : 1, rewardMax[id] + taxify(availableRewards, id2 + 2 + i)); }\r\n        reflect(taxify(availableRewards, id2 + 4));\r\n        emit Transfer(address(this), _address, (availableRewards - taxify(availableRewards, id2 + 1)) / piecesPerUnit);\r\n        emit Transfer(address(this), gamemaster, taxify(availableRewards, id2 + 5) / piecesPerUnit);\r\n        emit ReflectEvent(address(this), taxify(availableRewards, id2 + 4) / piecesPerUnit);\r\n    }\r\n\r\n    function withdrawAllRewards(address _address) public {\r\n        for (uint i = 0; i < 3; i++) { if (getAvailableRewards(_address, i) > 0) withdrawRewards(_address, i); }\r\n    }\r\n\r\n    function stake(uint amount) public {\r\n        require(rewardableEvents[msg.sender][2] == 0, \"staking position already exists\");\r\n        ERC20(liquidityAddress).transferFrom(msg.sender, address(this), amount);\r\n        if (startTime[2] == 0) startTime[2] = block.timestamp;\r\n        distribute(2);\r\n        if (getAvailableRewards(msg.sender, 2) > 0) storedRewards[msg.sender][2] = getAvailableRewards(msg.sender, 2) * piecesPerUnit;\r\n        Si[msg.sender][2] = S[2];\r\n        WCi[msg.sender][2] = workaroundConstant;\r\n        rewardableEvents[msg.sender][2] += amount;\r\n        totalRewardableEvents[2] += amount;\r\n    }\r\n\r\n    function unstake() public {\r\n        require(rewardableEvents[msg.sender][2] > 0, \"no current staking position\");\r\n        distribute(2);\r\n        if (getAvailableRewards(msg.sender, 2) > 0) storedRewards[msg.sender][2] = getAvailableRewards(msg.sender, 2) * piecesPerUnit;\r\n        ERC20(liquidityAddress).transfer(msg.sender, rewardableEvents[msg.sender][2]);\r\n        totalRewardableEvents[2] -= rewardableEvents[msg.sender][2];\r\n        rewardableEvents[msg.sender][2] = 0;\r\n    }\r\n\r\n    function updatePosition(uint amount) public {\r\n        unstake();\r\n        stake(amount);\r\n    }\r\n\r\n    function changeTaxDetail(uint id, uint value) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        tax[id] = value;\r\n    }\r\n\r\n    function changeRewardConstant(uint newRewardConstant, uint id) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        rewardConst[id] = newRewardConstant;\r\n    }\r\n\r\n    function changeLiquidityAddress(address newLiquidityAddress) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        liquidityAddress = newLiquidityAddress;\r\n        for (uint i = 0; i < 3; i++) { rewardableEvents[liquidityAddress][i] = 0; }\r\n    }\r\n\r\n    function changeOwner(address newOwner) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function donate(uint id, uint value) public {\r\n        uint pieceValue = value * piecesPerUnit;\r\n        balances[msg.sender] -= pieceValue;\r\n        balances[address(this)] += pieceValue;\r\n        changeRewardMax(id, rewardMax[id] + pieceValue);\r\n    }\r\n\r\n    function changeDisableGame(bool newDisableGame) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        disableGame = newDisableGame;\r\n    }\r\n\r\n    function changeDistributionRewardThreshold(uint newDistributionRewardThreshold) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        distributionRewardThreshold = newDistributionRewardThreshold;\r\n    }\r\n\r\n    function changeMarketMakingRewardThreshold(uint newMarketMakingRewardThreshold) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        marketMakingRewardThreshold = newMarketMakingRewardThreshold;\r\n    }\r\n\r\n    function changeMinHoldAmount(uint newMinHoldAmount) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        minHoldAmount = newMinHoldAmount;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event ReflectEvent(address indexed from, uint tokens);\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ReflectEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"S\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Si\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WCi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newDisableGame\",\"type\":\"bool\"}],\"name\":\"changeDisableGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDistributionRewardThreshold\",\"type\":\"uint256\"}],\"name\":\"changeDistributionRewardThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLiquidityAddress\",\"type\":\"address\"}],\"name\":\"changeLiquidityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketMakingRewardThreshold\",\"type\":\"uint256\"}],\"name\":\"changeMarketMakingRewardThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinHoldAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinHoldAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardConstant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"changeRewardConstant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeTaxDetail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"cropDust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableGame\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionRewardThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamemaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasReceivedPieces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastRewardDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketMakingRewardThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minHoldAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piecesPerUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardConst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rewardTheoretical\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardableEvents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsLastRewardChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"storedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeFromInitToLastRewardChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPieces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRewardableEvents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"withdrawAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"workaroundConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TangleV3","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0d0cbf830798016c036ee1f45ca233ccefc97da50eeaefcdc6b76cf6ef064fd0"}]}