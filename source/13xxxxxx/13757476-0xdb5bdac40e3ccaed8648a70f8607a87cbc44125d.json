{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/interfaces/IChickenNoodle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IChickenNoodle {\\n    // struct to store each token's traits\\n    struct ChickenNoodleTraits {\\n        bool minted;\\n        bool isChicken;\\n        uint8 backgrounds;\\n        uint8 snakeBodies;\\n        uint8 mouthAccessories;\\n        uint8 pupils;\\n        uint8 bodyAccessories;\\n        uint8 hats;\\n        uint8 tier;\\n    }\\n\\n    function MAX_TOKENS() external view returns (uint256);\\n\\n    function PAID_TOKENS() external view returns (uint256);\\n\\n    function tokenTraits(uint256 tokenId)\\n        external\\n        view\\n        returns (ChickenNoodleTraits memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function mint(address to, uint16 tokenId) external;\\n\\n    function finalize(\\n        uint16 tokenId,\\n        ChickenNoodleTraits memory traits,\\n        address thief\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ChickenNoodleLookupLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IChickenNoodle.sol';\\n\\nlibrary ChickenNoodleLookupLibrary {\\n    function totalNoodles(address chickenNoodleAddress)\\n        public\\n        view\\n        returns (uint16)\\n    {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        uint16 counter = 0;\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\\n            if (\\n                chickenNoodle.tokenTraits(tokenId).minted &&\\n                !chickenNoodle.tokenTraits(tokenId).isChicken\\n            ) {\\n                counter++;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n\\n    function getTokensForOwner(\\n        address chickenNoodleAddress,\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    ) public view returns (uint16[] memory) {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        uint256 tokensOwned = chickenNoodle.balanceOf(tokenOwner);\\n\\n        uint256 pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        uint256 tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n\\n        uint16[] memory tokens = new uint16[](tokensSize);\\n\\n        uint16 skipCounter = 0;\\n        uint16 counter = 0;\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (chickenNoodle.ownerOf(tokenId) == tokenOwner) {\\n                if (skipCounter < pageStart) {\\n                    skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counter] = tokenId;\\n                counter++;\\n            }\\n        }\\n\\n        return tokens;\\n    }\\n\\n    function getTokenTypesBalanceOf(\\n        address chickenNoodleAddress,\\n        address tokenOwner\\n    )\\n        public\\n        view\\n        returns (\\n            uint16 chickens,\\n            uint16 noodles,\\n            uint16 tier5Noodles,\\n            uint16 tier4Noodles,\\n            uint16 tier3Noodles,\\n            uint16 tier2Noodles,\\n            uint16 tier1Noodles,\\n            uint16 unminted\\n        )\\n    {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\\n            if (chickenNoodle.ownerOf(tokenId) != tokenOwner) {\\n                continue;\\n            }\\n\\n            if (!chickenNoodle.tokenTraits(tokenId).minted) {\\n                unminted++;\\n                continue;\\n            }\\n\\n            if (chickenNoodle.tokenTraits(tokenId).isChicken) {\\n                chickens++;\\n            } else {\\n                uint8 tier = chickenNoodle.tokenTraits(tokenId).tier;\\n\\n                if (tier == 5) {\\n                    tier5Noodles++;\\n                } else if (tier == 4) {\\n                    tier4Noodles++;\\n                } else if (tier == 3) {\\n                    tier3Noodles++;\\n                } else if (tier == 2) {\\n                    tier2Noodles++;\\n                } else if (tier == 1) {\\n                    tier1Noodles++;\\n                }\\n            }\\n        }\\n\\n        noodles =\\n            tier5Noodles +\\n            tier4Noodles +\\n            tier3Noodles +\\n            tier2Noodles +\\n            tier1Noodles;\\n    }\\n\\n    function getMintedForOwner(\\n        address chickenNoodleAddress,\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    ) public view returns (uint16[] memory) {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        (, , , , , , , uint16 tokensOwned) = getTokenTypesBalanceOf(\\n            chickenNoodleAddress,\\n            tokenOwner\\n        );\\n\\n        uint256 pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        uint256 tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n\\n        uint16[] memory tokens = new uint16[](tokensSize);\\n\\n        uint16 skipCounter = 0;\\n        uint16 counter = 0;\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (chickenNoodle.ownerOf(tokenId) != tokenOwner) {\\n                continue;\\n            }\\n\\n            if (chickenNoodle.tokenTraits(tokenId).minted) {\\n                if (skipCounter < pageStart) {\\n                    skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counter] = tokenId;\\n                counter++;\\n            }\\n        }\\n\\n        return tokens;\\n    }\\n\\n    function getUnmintedForOwner(\\n        address chickenNoodleAddress,\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    ) public view returns (uint16[] memory) {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        (, , , , , , , uint16 tokensOwned) = getTokenTypesBalanceOf(\\n            chickenNoodleAddress,\\n            tokenOwner\\n        );\\n\\n        uint256 pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        uint256 tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n\\n        uint16[] memory tokens = new uint16[](tokensSize);\\n\\n        uint16 skipCounter = 0;\\n        uint16 counter = 0;\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (chickenNoodle.ownerOf(tokenId) != tokenOwner) {\\n                continue;\\n            }\\n\\n            if (!chickenNoodle.tokenTraits(tokenId).minted) {\\n                if (skipCounter < pageStart) {\\n                    skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counter] = tokenId;\\n                counter++;\\n            }\\n        }\\n\\n        return tokens;\\n    }\\n\\n    function getChickensForOwner(\\n        address chickenNoodleAddress,\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    ) public view returns (uint16[] memory) {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        (uint16 tokensOwned, , , , , , , ) = getTokenTypesBalanceOf(\\n            chickenNoodleAddress,\\n            tokenOwner\\n        );\\n\\n        uint256 pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        uint256 tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n\\n        uint16[] memory tokens = new uint16[](tokensSize);\\n\\n        uint16 skipCounter = 0;\\n        uint16 counter = 0;\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (\\n                !chickenNoodle.tokenTraits(tokenId).minted ||\\n                chickenNoodle.ownerOf(tokenId) != tokenOwner\\n            ) {\\n                continue;\\n            }\\n\\n            if (chickenNoodle.tokenTraits(tokenId).isChicken) {\\n                if (skipCounter < pageStart) {\\n                    skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counter] = tokenId;\\n                counter++;\\n            }\\n        }\\n\\n        return tokens;\\n    }\\n\\n    function getNoodlesForOwner(\\n        address chickenNoodleAddress,\\n        address tokenOwner,\\n        uint16 limit,\\n        uint16 page\\n    ) public view returns (uint16[] memory) {\\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\\n\\n        (, uint16 tokensOwned, , , , , , ) = getTokenTypesBalanceOf(\\n            chickenNoodleAddress,\\n            tokenOwner\\n        );\\n\\n        uint256 pageStart = limit * page;\\n        uint256 pageEnd = limit * (page + 1);\\n        uint256 tokensSize = tokensOwned >= pageEnd\\n            ? limit\\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\\n\\n        uint16[] memory tokens = new uint16[](tokensSize);\\n\\n        uint16 skipCounter = 0;\\n        uint16 counter = 0;\\n\\n        uint16 supply = uint16(chickenNoodle.totalSupply());\\n\\n        for (\\n            uint16 tokenId = 1;\\n            tokenId <= supply && counter < tokens.length;\\n            tokenId++\\n        ) {\\n            if (\\n                !chickenNoodle.tokenTraits(tokenId).minted ||\\n                chickenNoodle.ownerOf(tokenId) != tokenOwner\\n            ) {\\n                continue;\\n            }\\n\\n            if (!chickenNoodle.tokenTraits(tokenId).isChicken) {\\n                if (skipCounter < pageStart) {\\n                    skipCounter++;\\n                    continue;\\n                }\\n\\n                tokens[counter] = tokenId;\\n                counter++;\\n            }\\n        }\\n\\n        return tokens;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getChickensForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getMintedForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getNoodlesForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"getTokenTypesBalanceOf\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"chickens\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier5Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier4Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier3Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier2Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"tier1Noodles\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"unminted\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getTokensForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"limit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"page\",\"type\":\"uint16\"}],\"name\":\"getUnmintedForOwner\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chickenNoodleAddress\",\"type\":\"address\"}],\"name\":\"totalNoodles\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChickenNoodleLookupLibrary","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}