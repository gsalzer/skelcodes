{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/governance/NXMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../../interfaces/IClaims.sol\\\";\\nimport \\\"../../interfaces/IClaimsData.sol\\\";\\nimport \\\"../../interfaces/IClaimsReward.sol\\\";\\nimport \\\"../../interfaces/IMemberRoles.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/IQuotation.sol\\\";\\nimport \\\"../../interfaces/IQuotationData.sol\\\";\\nimport \\\"../../interfaces/ITokenController.sol\\\";\\nimport \\\"../../interfaces/ITokenData.sol\\\";\\nimport \\\"./external/Governed.sol\\\";\\nimport \\\"./external/OwnedUpgradeabilityProxy.sol\\\";\\n\\ncontract NXMaster is INXMMaster, Governed {\\n  using SafeMath for uint;\\n\\n  uint public _unused0;\\n\\n  bytes2[] public contractCodes;\\n  mapping(address => bool) public contractsActive;\\n  mapping(bytes2 => address payable) public contractAddresses;\\n  mapping(bytes2 => bool) public isProxy;\\n  mapping(bytes2 => bool) public isReplaceable;\\n\\n  address public tokenAddress;\\n  bool internal reentrancyLock;\\n  bool public masterInitialized;\\n  address public owner;\\n  uint public _unused1;\\n\\n  address public emergencyAdmin;\\n  bool public paused;\\n\\n  enum ContractType { Undefined, Replaceable, Proxy }\\n\\n  event InternalContractAdded(bytes2 indexed code, address contractAddress, ContractType indexed contractType);\\n  event ContractUpgraded(bytes2 indexed code, address newAddress, address previousAddress, ContractType indexed contractType);\\n  event ContractRemoved(bytes2 indexed code, address contractAddress);\\n  event PauseConfigured(bool paused);\\n\\n\\n  function initializeEmergencyAdmin() external {\\n    if (emergencyAdmin == address(0)) {\\n      emergencyAdmin = 0x422D71fb8040aBEF53f3a05d21A9B85eebB2995D;\\n    }\\n  }\\n\\n  modifier noReentrancy() {\\n    require(!reentrancyLock, \\\"Reentrant call.\\\");\\n    reentrancyLock = true;\\n    _;\\n    reentrancyLock = false;\\n  }\\n\\n  modifier onlyEmergencyAdmin() {\\n    require(msg.sender == emergencyAdmin, \\\"NXMaster: Not emergencyAdmin\\\");\\n    _;\\n  }\\n\\n  function addNewInternalContracts(\\n    bytes2[] calldata newContractCodes,\\n    address payable[] calldata newAddresses,\\n    uint[] calldata _types\\n  )\\n  external\\n  onlyAuthorizedToGovern\\n  {\\n    require(newContractCodes.length == newAddresses.length, \\\"NXMaster: newContractCodes.length != newAddresses.length.\\\");\\n    require(newContractCodes.length == _types.length, \\\"NXMaster: newContractCodes.length != _types.length\\\");\\n    for (uint i = 0; i < newContractCodes.length; i++) {\\n      addNewInternalContract(newContractCodes[i], newAddresses[i], _types[i]);\\n    }\\n  }\\n\\n  /// @dev Adds new internal contract\\n  /// @param contractCode contract code for new contract\\n  /// @param contractAddress contract address for new contract\\n  /// @param _type pass 1 if contract is replaceable, 2 if contract is proxy\\n  function addNewInternalContract(\\n    bytes2 contractCode,\\n    address payable contractAddress,\\n    uint _type\\n  ) internal {\\n\\n    require(contractAddresses[contractCode] == address(0), \\\"NXMaster: Code already in use\\\");\\n    require(contractAddress != address(0), \\\"NXMaster: Contract address is 0\\\");\\n\\n    contractCodes.push(contractCode);\\n\\n    address newInternalContract;\\n    if (_type == uint(ContractType.Replaceable)) {\\n\\n      newInternalContract = contractAddress;\\n      isReplaceable[contractCode] = true;\\n    } else if (_type == uint(ContractType.Proxy)) {\\n\\n      newInternalContract = address(new OwnedUpgradeabilityProxy(contractAddress));\\n      isProxy[contractCode] = true;\\n    } else {\\n      revert(\\\"NXMaster: Unsupported contract type\\\");\\n    }\\n\\n    contractAddresses[contractCode] = address(uint160(newInternalContract));\\n    contractsActive[newInternalContract] = true;\\n\\n    MasterAware up = MasterAware(newInternalContract);\\n    up.changeMasterAddress(address(this));\\n    up.changeDependentContractAddress();\\n\\n    emit InternalContractAdded(contractCode, contractAddress, ContractType(_type));\\n  }\\n\\n  /// @dev upgrades multiple contracts at a time\\n  function upgradeMultipleContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses\\n  )\\n  external\\n  onlyAuthorizedToGovern\\n  {\\n    require(_contractCodes.length == newAddresses.length, \\\"NXMaster: _contractCodes.length != newAddresses.length\\\");\\n\\n    for (uint i = 0; i < _contractCodes.length; i++) {\\n      address payable newAddress = newAddresses[i];\\n      bytes2 code = _contractCodes[i];\\n      require(newAddress != address(0), \\\"NXMaster: Contract address is 0\\\");\\n\\n      if (isProxy[code]) {\\n        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(contractAddresses[code]);\\n        address previousAddress = proxy.implementation();\\n        proxy.upgradeTo(newAddress);\\n        emit ContractUpgraded(code, newAddress, previousAddress, ContractType.Proxy);\\n        continue;\\n      }\\n\\n      if (isReplaceable[code]) {\\n        address previousAddress = getLatestAddress(code);\\n        replaceContract(code, newAddress);\\n        emit ContractUpgraded(code, newAddress, previousAddress, ContractType.Replaceable);\\n        continue;\\n      }\\n\\n      revert(\\\"NXMaster: Non-existant or non-upgradeable contract code\\\");\\n    }\\n\\n    updateAllDependencies();\\n  }\\n\\n  function replaceContract(bytes2 code, address payable newAddress) internal {\\n    if (code == \\\"CR\\\") {\\n      ITokenController tc = ITokenController(getLatestAddress(\\\"TC\\\"));\\n      tc.addToWhitelist(newAddress);\\n      tc.removeFromWhitelist(contractAddresses[\\\"CR\\\"]);\\n      IClaimsReward cr = IClaimsReward(contractAddresses[\\\"CR\\\"]);\\n      cr.upgrade(newAddress);\\n\\n    } else if (code == \\\"P1\\\") {\\n      IPool p1 = IPool(contractAddresses[\\\"P1\\\"]);\\n      p1.upgradeCapitalPool(newAddress);\\n    }\\n\\n    address payable oldAddress = contractAddresses[code];\\n    contractsActive[oldAddress] = false;\\n    contractAddresses[code] = newAddress;\\n    contractsActive[newAddress] = true;\\n\\n    MasterAware up = MasterAware(contractAddresses[code]);\\n    up.changeMasterAddress(address(this));\\n  }\\n\\n  function removeContracts(bytes2[] calldata contractCodesToRemove)\\n  external\\n  onlyAuthorizedToGovern\\n  {\\n\\n    for (uint i = 0; i < contractCodesToRemove.length; i++) {\\n      bytes2 code = contractCodesToRemove[i];\\n      address contractAddress = contractAddresses[code];\\n      require(contractAddress != address(0), \\\"NXMaster: Address is 0\\\");\\n      require(isInternal(contractAddress), \\\"NXMaster: Contract not internal\\\");\\n      contractsActive[contractAddress] = false;\\n      contractAddresses[code] = address(0);\\n\\n      if (isProxy[code]) {\\n        isProxy[code] = false;\\n      }\\n\\n      if (isReplaceable[code]) {\\n        isReplaceable[code] = false;\\n      }\\n      emit ContractRemoved(code, contractAddress);\\n    }\\n\\n    // delete elements from contractCodes\\n    for (uint i = 0; i < contractCodes.length; i++) {\\n      for (uint j = 0; j < contractCodesToRemove.length; j++) {\\n        if (contractCodes[i] == contractCodesToRemove[j]) {\\n          contractCodes[i] = contractCodes[contractCodes.length - 1];\\n          contractCodes.pop();\\n          i = i == 0 ? 0 : i - 1;\\n        }\\n      }\\n    }\\n\\n    updateAllDependencies();\\n  }\\n\\n  function updateAllDependencies() internal {\\n    for (uint i = 0; i < contractCodes.length; i++) {\\n      MasterAware up = MasterAware(contractAddresses[contractCodes[i]]);\\n      up.changeDependentContractAddress();\\n    }\\n  }\\n\\n  /**\\n   * @dev set Emergency pause\\n   * @param _paused to toggle emergency pause ON/OFF\\n   */\\n  function setEmergencyPause(bool _paused) public onlyEmergencyAdmin {\\n    paused = _paused;\\n    emit PauseConfigured(_paused);\\n  }\\n\\n  /// @dev checks whether the address is an internal contract address.\\n  function isInternal(address _contractAddress) public view returns (bool) {\\n    return contractsActive[_contractAddress];\\n  }\\n\\n  /// @dev checks whether the address is the Owner or not.\\n  function isOwner(address _address) public view returns (bool) {\\n    return owner == _address;\\n  }\\n\\n  /// @dev Checks whether emergency pause is on/not.\\n  function isPause() public view returns (bool) {\\n    return paused;\\n  }\\n\\n  /// @dev checks whether the address is a member of the mutual or not.\\n  function isMember(address _add) public view returns (bool) {\\n    IMemberRoles mr = IMemberRoles(getLatestAddress(\\\"MR\\\"));\\n    return mr.checkRole(_add, uint(IMemberRoles.Role.Member));\\n  }\\n\\n  /// @dev Gets current contract codes and their addresses\\n  /// @return contractCodes\\n  /// @return contractAddresses\\n  function getInternalContracts()\\n  public\\n  view\\n  returns (\\n    bytes2[] memory _contractCodes,\\n    address[] memory _contractAddresses\\n  )\\n  {\\n    _contractCodes = contractCodes;\\n    _contractAddresses = new address[](contractCodes.length);\\n\\n    for (uint i = 0; i < _contractCodes.length; i++) {\\n      _contractAddresses[i] = contractAddresses[contractCodes[i]];\\n    }\\n  }\\n\\n  /**\\n   * @dev returns the address of token controller\\n   * @return address is returned\\n   */\\n  function dAppLocker() public view returns (address) {\\n    return getLatestAddress(\\\"TC\\\");\\n  }\\n\\n  /// @dev Gets latest contract address\\n  /// @param _contractName Contract name to fetch\\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress) {\\n    contractAddress = contractAddresses[_contractName];\\n  }\\n\\n  /**\\n   * @dev to check if the address is authorized to govern or not\\n   * @param _add is the address in concern\\n   * @return the boolean status status for the check\\n   */\\n  function checkIsAuthToGoverned(address _add) public view returns (bool) {\\n    return isAuthorizedToGovern(_add);\\n  }\\n\\n  /**\\n   * @dev to update the owner parameters\\n   * @param code is the associated code\\n   * @param val is value to be set\\n   */\\n  function updateOwnerParameters(bytes8 code, address payable val) public onlyAuthorizedToGovern {\\n    IQuotationData qd;\\n    if (code == \\\"MSWALLET\\\") {\\n\\n      ITokenData td;\\n      td = ITokenData(getLatestAddress(\\\"TD\\\"));\\n      td.changeWalletAddress(val);\\n\\n    } else if (code == \\\"OWNER\\\") {\\n\\n      IMemberRoles mr = IMemberRoles(getLatestAddress(\\\"MR\\\"));\\n      mr.swapOwner(val);\\n      owner = val;\\n\\n    } else if (code == \\\"QUOAUTH\\\") {\\n\\n      qd = IQuotationData(getLatestAddress(\\\"QD\\\"));\\n      qd.changeAuthQuoteEngine(val);\\n\\n    } else if (code == \\\"KYCAUTH\\\") {\\n\\n      qd = IQuotationData(getLatestAddress(\\\"QD\\\"));\\n      qd.setKycAuthAddress(val);\\n\\n    } else if (code == \\\"EMADMIN\\\") {\\n\\n      emergencyAdmin = val;\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/MasterAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../interfaces/INXMMaster.sol\\\";\\n\\ncontract MasterAware {\\n\\n  INXMMaster public master;\\n\\n  modifier onlyMember {\\n    require(master.isMember(msg.sender), \\\"Caller is not a member\\\");\\n    _;\\n  }\\n\\n  modifier onlyInternal {\\n    require(master.isInternal(msg.sender), \\\"Caller is not an internal contract\\\");\\n    _;\\n  }\\n\\n  modifier onlyMaster {\\n    if (address(master) != address(0)) {\\n      require(address(master) == msg.sender, \\\"Not master\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier onlyGovernance {\\n    require(\\n      master.checkIsAuthToGoverned(msg.sender),\\n      \\\"Caller is not authorized to govern\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier whenPaused {\\n    require(master.isPause(), \\\"System is not paused\\\");\\n    _;\\n  }\\n\\n  modifier whenNotPaused {\\n    require(!master.isPause(), \\\"System is paused\\\");\\n    _;\\n  }\\n\\n  function changeDependentContractAddress() external;\\n\\n  function changeMasterAddress(address masterAddress) public onlyMaster {\\n    master = INXMMaster(masterAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaims.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaims {\\n\\n  function setClaimStatus(uint claimId, uint stat) external;\\n\\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens);\\n\\n  function submitClaim(uint coverId) external;\\n\\n  function submitClaimForMember(uint coverId, address member) external;\\n\\n  function submitClaimAfterEPOff() external pure;\\n\\n  function submitCAVote(uint claimId, int8 verdict) external;\\n\\n  function submitMemberVote(uint claimId, int8 verdict) external;\\n\\n  function pauseAllPendingClaimsVoting() external pure;\\n\\n  function startAllPendingClaimsVoting() external pure;\\n\\n  function checkVoteClosing(uint claimId) external view returns (int8 close);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsData {\\n\\n  function pendingClaimStart() external view returns (uint);\\n  function claimDepositTime() external view returns (uint);\\n  function maxVotingTime() external view returns (uint);\\n  function minVotingTime() external view returns (uint);\\n  function payoutRetryTime() external view returns (uint);\\n  function claimRewardPerc() external view returns (uint);\\n  function minVoteThreshold() external view returns (uint);\\n  function maxVoteThreshold() external view returns (uint);\\n  function majorityConsensus() external view returns (uint);\\n  function pauseDaysCA() external view returns (uint);\\n\\n  function userClaimVotePausedOn(address) external view returns (uint);\\n\\n  function setpendingClaimStart(uint _start) external;\\n\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external;\\n\\n  function setUserClaimVotePausedOn(address user) external;\\n\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external;\\n\\n\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  ) external;\\n\\n  function setRewardClaimed(uint _voteid, bool claimed) external;\\n\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external;\\n\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  ) external;\\n\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  ) external;\\n\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function addClaimVotemember(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function updateState12Count(uint _claimId, uint _cnt) external;\\n\\n  function setClaimStatus(uint _claimId, uint _stat) external;\\n\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external;\\n\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  ) external;\\n\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external;\\n\\n\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  ) external;\\n\\n\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  ) external;\\n\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external;\\n\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  ) external;\\n\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  ) external;\\n\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  ) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  );\\n\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getAllVoteLength() external view returns (uint voteCount);\\n\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno);\\n\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV);\\n\\n  function getClaimState12Count(uint _claimId) external view returns (uint num);\\n\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd);\\n\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr);\\n\\n\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt);\\n\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt);\\n\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  );\\n\\n  function getVoterVote(uint _voteid) external view returns (address voter);\\n\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len);\\n\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver);\\n\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok);\\n\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter);\\n\\n  function getUserClaimCount(address _add) external view returns (uint len);\\n\\n  function getClaimLength() external view returns (uint len);\\n\\n  function actualClaimLength() external view returns (uint len);\\n\\n\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  );\\n\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  );\\n\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  );\\n\\n\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  );\\n\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  );\\n\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  );\\n\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid);\\n\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressCALength(address _voter) external view returns (uint);\\n\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint);\\n\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict);\\n\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len);\\n\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit);\\n\\n  function getLengthOfClaimVotingPause() external view returns (uint len);\\n\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  );\\n\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsReward {\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) external;\\n\\n  function getCurrencyAssetAddress(bytes4 currency) external view returns (address);\\n\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  external\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  );\\n\\n  function upgrade(address _newAdd) external;\\n\\n  function getRewardToBeDistributedByUser(address _add) external view returns (uint total);\\n\\n  function getRewardAndClaimedStatus(uint check, uint claimId) external view returns (uint reward, bool claimed);\\n\\n  function claimAllPendingReward(uint records) external;\\n\\n  function getAllPendingRewardOfUser(address _add) external view returns (uint);\\n\\n  function unlockCoverNote(uint coverId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMemberRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMemberRoles {\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\\n\\n  function payJoiningFee(address _userAddress) external payable;\\n\\n  function switchMembership(address _newAddress) external;\\n\\n  function switchMembershipOf(address member, address _newAddress) external;\\n\\n  function swapOwner(address _newOwnerAddress) external;\\n\\n  function kycVerdict(address payable _userAddress, bool verdict) external;\\n\\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable);\\n\\n  function setClaimPayoutAddress(address payable _address) external;\\n\\n  function totalRoles() external view returns (uint256);\\n\\n  function changeAuthorized(uint _roleId, address _newAuthorized) external;\\n\\n  function members(uint _memberRoleId) external view returns (uint, address[] memory memberArray);\\n\\n  function numberOfMembers(uint _memberRoleId) external view returns (uint);\\n\\n  function authorized(uint _memberRoleId) external view returns (address);\\n\\n  function roles(address _memberAddress) external view returns (uint[] memory);\\n\\n  function checkRole(address _memberAddress, uint _roleId) external view returns (bool);\\n\\n  function getMemberLengthForAllRoles() external view returns (uint[] memory totalMembers);\\n\\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool);\\n\\n  function membersLength(uint _memberRoleId) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./IPriceFeedOracle.sol\\\";\\n\\ninterface IPool {\\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\\n\\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\\n\\n  function minPoolEth() external returns (uint);\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external returns (bool success);\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external;\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external;\\n\\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\\n\\n  function getPoolValueInEth() external view returns (uint);\\n\\n\\n  function transferAssetFrom(address asset, address from, uint amount) external;\\n\\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\\n\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) external pure returns (uint);\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\\n\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\\n\\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\\n\\n  function getMCRRatio() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotation {\\n  function verifyCoverDetails(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external;\\n\\n  function createCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 currency,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotationData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotationData {\\n\\n  function authQuoteEngine() external view returns (address);\\n  function stlp() external view returns (uint);\\n  function stl() external view returns (uint);\\n  function pm() external view returns (uint);\\n  function minDays() external view returns (uint);\\n  function tokensRetained() external view returns (uint);\\n  function kycAuthAddress() external view returns (address);\\n\\n  function refundEligible(address) external view returns (bool);\\n  function holdedCoverIDStatus(uint) external view returns (uint);\\n  function timestampRepeated(uint) external view returns (bool);\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function setTimestampRepeated(uint _timestamp) external;\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  ) external;\\n\\n\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  ) external;\\n\\n  function setRefundEligible(address _add, bool status) external;\\n\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\\n\\n  function setKycAuthAddress(address _add) external;\\n\\n  function changeAuthQuoteEngine(address _add) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  );\\n\\n  function getCoverLength() external view returns (uint len);\\n\\n  function getAuthQuoteEngine() external view returns (address _add);\\n\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\\n\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\\n\\n  function getUserCoverLength(address _add) external view returns (uint len);\\n\\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\\n\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\\n\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\\n\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\\n\\n  function getValidityOfCover(uint _cid) external view returns (uint date);\\n\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\\n\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\\n\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\\n\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  );\\n\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  );\\n\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  );\\n\\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\\n\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\\n\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  );\\n\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\\n\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenController {\\n\\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\\n\\n  function claimSubmissionGracePeriod() external view returns (uint);\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external;\\n\\n  function markCoverClaimOpen(uint coverId) external;\\n\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external;\\n\\n  function changeOperator(address _newOperator) external;\\n\\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\\n\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external;\\n\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\\n\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external;\\n\\n  function extendClaimAssessmentLock(uint256 _time) external;\\n\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\\n\\n  function increaseClaimAssessmentLock(uint256 _amount) external;\\n\\n  function burnFrom(address _of, uint amount) external returns (bool);\\n\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\\n\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function addToWhitelist(address _member) external;\\n\\n  function removeFromWhitelist(address _member) external;\\n\\n  function mint(address _member, uint _amount) external;\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n  function withdrawClaimAssessmentTokens(address _of) external;\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\\n\\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\\n\\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\\n\\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  external\\n  view\\n  returns (uint256 amount, uint256 validity);\\n\\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\\n\\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenData {\\n\\n  function walletAddress() external view returns (address payable);\\n  function lockTokenTimeAfterCoverExp() external view returns (uint);\\n  function bookTime() external view returns (uint);\\n  function lockCADays() external view returns (uint);\\n  function lockMVDays() external view returns (uint);\\n  function scValidDays() external view returns (uint);\\n  function joiningFee() external view returns (uint);\\n  function stakerCommissionPer() external view returns (uint);\\n  function stakerMaxCommissionPer() external view returns (uint);\\n  function tokenExponent() external view returns (uint);\\n  function priceStep() external view returns (uint);\\n\\n  function depositedCN(uint) external view returns (uint amount, bool isDeposited);\\n\\n  function lastCompletedStakeCommission(address) external view returns (uint);\\n\\n  function changeWalletAddress(address payable _address) external;\\n\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (address stakedContractAddress);\\n\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint burnedAmount);\\n\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint unlockable);\\n\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint scIndex);\\n\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (uint sIndex);\\n\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint length);\\n\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  ) external;\\n\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionEarned);\\n\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionRedeemed);\\n\\n  function setDepositCN(uint coverId, bool flag) external;\\n\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (address stakerAddress);\\n\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  ) external view returns (uint length);\\n\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  ) external returns (uint scIndex);\\n\\n  function bookCATokens(address _of) external;\\n\\n  function isCATokensBooked(address _of) external view returns (bool res);\\n\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  ) external;\\n\\n\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setDepositCNAmount(uint coverId, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/Governed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\ninterface IMaster {\\n  function getLatestAddress(bytes2 _module) external view returns (address);\\n}\\n\\ncontract Governed {\\n\\n  address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\\n\\n  /// @dev modifier that allows only the authorized addresses to execute the function\\n  modifier onlyAuthorizedToGovern() {\\n    IMaster ms = IMaster(masterAddress);\\n    require(ms.getLatestAddress(\\\"GV\\\") == msg.sender, \\\"Not authorized\\\");\\n    _;\\n  }\\n\\n  /// @dev checks if an address is authorized to govern\\n  function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\\n    IMaster ms = IMaster(masterAddress);\\n    return (ms.getLatestAddress(\\\"GV\\\") == _toCheck);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/OwnedUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./UpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title OwnedUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\\n */\\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\\n  /**\\n  * @dev Event to show ownership has been transferred\\n  * @param previousOwner representing the address of the previous owner\\n  * @param newOwner representing the address of the new owner\\n  */\\n  event ProxyOwnershipTransferred(address previousOwner, address newOwner);\\n\\n  // Storage position of the owner of the contract\\n  bytes32 private constant PROXY_OWNER_POSITION = keccak256(\\\"org.govblocks.proxy.owner\\\");\\n\\n  /**\\n  * @dev the constructor sets the original owner of the contract to the sender account.\\n  */\\n  constructor(address _implementation) public {\\n    _setUpgradeabilityOwner(msg.sender);\\n    _upgradeTo(_implementation);\\n  }\\n\\n  /**\\n  * @dev Throws if called by any account other than the owner.\\n  */\\n  modifier onlyProxyOwner() {\\n    require(msg.sender == proxyOwner());\\n    _;\\n  }\\n\\n  /**\\n  * @dev Tells the address of the owner\\n  * @return the address of the owner\\n  */\\n  function proxyOwner() public view returns (address owner) {\\n    bytes32 position = PROXY_OWNER_POSITION;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      owner := sload(position)\\n    }\\n  }\\n\\n  /**\\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n  * @param _newOwner The address to transfer ownership to.\\n  */\\n  function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\\n    require(_newOwner != address(0));\\n    _setUpgradeabilityOwner(_newOwner);\\n    emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\\n  }\\n\\n  /**\\n  * @dev Allows the proxy owner to upgrade the current version of the proxy.\\n  * @param _implementation representing the address of the new implementation to be set.\\n  */\\n  function upgradeTo(address _implementation) public onlyProxyOwner {\\n    _upgradeTo(_implementation);\\n  }\\n\\n  /**\\n   * @dev Sets the address of the owner\\n  */\\n  function _setUpgradeabilityOwner(address _newProxyOwner) internal {\\n    bytes32 position = PROXY_OWNER_POSITION;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      sstore(position, _newProxyOwner)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n\\n  function upgradeMultipleContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses\\n  ) external;\\n\\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\\n\\n  function addNewInternalContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses,\\n    uint[] calldata _types\\n  ) external;\\n\\n  function updateOwnerParameters(bytes8 code, address payable val) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPriceFeedOracle {\\n\\n  function daiAddress() external view returns (address);\\n  function stETH() external view returns (address);\\n  function ETH() external view returns (address);\\n\\n  function getAssetToEthRate(address asset) external view returns (uint);\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/UpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"./Proxy.sol\\\";\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n  /**\\n  * @dev This event will be emitted every time the implementation gets upgraded\\n  * @param implementation representing the address of the upgraded implementation\\n  */\\n  event Upgraded(address indexed implementation);\\n\\n  // Storage position of the address of the current implementation\\n  bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\\\"org.govblocks.proxy.implementation\\\");\\n\\n  /**\\n  * @dev Constructor function\\n  */\\n  // solhint-disable-next-line no-empty-blocks\\n  constructor() public {}\\n\\n  /**\\n  * @dev Tells the address of the current implementation\\n  * @return address of the current implementation\\n  */\\n  function implementation() public view returns (address impl) {\\n    bytes32 position = IMPLEMENTATION_POSITION;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      impl := sload(position)\\n    }\\n  }\\n\\n  /**\\n  * @dev Sets the address of the current implementation\\n  * @param _newImplementation address representing the new implementation to be set\\n  */\\n  function _setImplementation(address _newImplementation) internal {\\n    bytes32 position = IMPLEMENTATION_POSITION;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      sstore(position, _newImplementation)\\n    }\\n  }\\n\\n  /**\\n  * @dev Upgrades the implementation address\\n  * @param _newImplementation representing the address of the new implementation to be set\\n  */\\n  function _upgradeTo(address _newImplementation) internal {\\n    address currentImplementation = implementation();\\n    require(currentImplementation != _newImplementation);\\n    _setImplementation(_newImplementation);\\n    emit Upgraded(_newImplementation);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/governance/external/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @title Proxy\\n * @dev Gives the possibility to delegate any call to a foreign implementation.\\n */\\ncontract Proxy {\\n\\n  /**\\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\\n  * This function will return whatever the implementation call returns\\n  */\\n  // solhint-disable-next-line no-complex-fallback\\n  function() external payable {\\n    address _impl = implementation();\\n    require(_impl != address(0));\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      let ptr := mload(0x40)\\n      calldatacopy(ptr, 0, calldatasize)\\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\\n      let size := returndatasize\\n      returndatacopy(ptr, 0, size)\\n\\n      switch result\\n      case 0 {revert(ptr, size)}\\n      default {return (ptr, size)}\\n    }\\n  }\\n\\n  /**\\n  * @dev Tells the address of the implementation where every call will be delegated.\\n  * @return address of the implementation to which it will be delegated\\n  */\\n  function implementation() public view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes2\",\"name\":\"code\",\"type\":\"bytes2\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes2\",\"name\":\"code\",\"type\":\"bytes2\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum NXMaster.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"}],\"name\":\"ContractUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes2\",\"name\":\"code\",\"type\":\"bytes2\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum NXMaster.ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"}],\"name\":\"InternalContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PauseConfigured\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_unused0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_unused1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"newContractCodes\",\"type\":\"bytes2[]\"},{\"internalType\":\"address payable[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_types\",\"type\":\"uint256[]\"}],\"name\":\"addNewInternalContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"checkIsAuthToGoverned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"contractAddresses\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractCodes\",\"outputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dAppLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalContracts\",\"outputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"_contractCodes\",\"type\":\"bytes2[]\"},{\"internalType\":\"address[]\",\"name\":\"_contractAddresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"_contractName\",\"type\":\"bytes2\"}],\"name\":\"getLatestAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeEmergencyAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"isAuthorizedToGovern\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"isInternal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"isProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"isReplaceable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"contractCodesToRemove\",\"type\":\"bytes2[]\"}],\"name\":\"removeContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setEmergencyPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"code\",\"type\":\"bytes8\"},{\"internalType\":\"address payable\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"updateOwnerParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"_contractCodes\",\"type\":\"bytes2[]\"},{\"internalType\":\"address payable[]\",\"name\":\"newAddresses\",\"type\":\"address[]\"}],\"name\":\"upgradeMultipleContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NXMaster","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}