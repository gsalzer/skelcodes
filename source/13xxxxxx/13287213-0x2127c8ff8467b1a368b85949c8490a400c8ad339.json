{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.15\r\n\r\n\"\"\"\r\n@title Unagii Vault 3.0.1\r\n@author stakewith.us\r\n@license AGPL-3.0-or-later\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface IStrategy:\r\n    def vault() -> address: view\r\n    def token() -> address: view\r\n    def totalAssets() -> uint256: view\r\n    def withdraw(amount: uint256): nonpayable\r\n\r\n\r\ninterface UnagiiToken:\r\n    def token() -> address: view\r\n    def totalSupply() -> uint256: view\r\n    def mint(receiver: address, amount: uint256): nonpayable\r\n    def burn(spender: address, amount: uint256): nonpayable\r\n    def lastBlock(owner: address) -> uint256: view\r\n\r\n\r\n# ERC20 selectors\r\nAPPROVE: constant(Bytes[4]) = method_id(\"approve(address,uint256)\")\r\nTRANSFER: constant(Bytes[4]) = method_id(\"transfer(address,uint256)\")\r\nTRANSFER_FROM: constant(Bytes[4]) = method_id(\"transferFrom(address,address,uint256)\")\r\n\r\n# maximum number of active strategies\r\nMAX_ACTIVE: constant(uint256) = 20\r\nMAX_TOTAL_DEBT_RATIO: constant(uint256) = 10000\r\nMIN_RESERVE_DENOMINATOR: constant(uint256) = 10000\r\nMAX_DEGRADATION: constant(uint256) = 10 ** 18\r\nMAX_BLOCK_DELAY: constant(uint256) = 1000\r\n\r\n\r\nstruct Strategy:\r\n    approved: bool\r\n    active: bool\r\n    debtRatio: uint256  # ratio of total assets this strategy can borrow\r\n    debt: uint256  # current amount borrowed\r\n\r\n\r\nevent SetNextTimeLock:\r\n    nextTimeLock: address\r\n\r\n\r\nevent AcceptTimeLock:\r\n    timeLock: address\r\n\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nevent SetGuardian:\r\n    guardian: address\r\n\r\n\r\nevent SetWorker:\r\n    worker: address\r\n\r\n\r\nevent SetPause:\r\n    paused: bool\r\n\r\n\r\nevent SetWhitelist:\r\n    addr: indexed(address)\r\n    approved: bool\r\n\r\n\r\nevent Deposit:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n    diff: uint256\r\n    shares: uint256\r\n\r\n\r\nevent Withdraw:\r\n    owner: indexed(address)\r\n    shares: uint256\r\n    amount: uint256\r\n\r\n\r\nevent ApproveStrategy:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent RevokeStrategy:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent ActivateStrategy:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent DeactivateStrategy:\r\n    strategy: indexed(address)\r\n\r\n\r\nevent SetActiveStrategies:\r\n    strategies: address[MAX_ACTIVE]\r\n\r\n\r\nevent SetDebtRatios:\r\n    debtRatios: uint256[MAX_ACTIVE]\r\n\r\n\r\nevent Borrow:\r\n    strategy: indexed(address)\r\n    amount: uint256\r\n\r\n\r\nevent Repay:\r\n    strategy: indexed(address)\r\n    amount: uint256\r\n\r\n\r\nevent Sync:\r\n    strategy: indexed(address)\r\n    total: uint256\r\n    debt: uint256\r\n    lockedProfit: uint256\r\n\r\n\r\npaused: public(bool)\r\n\r\ntoken: public(ERC20)\r\nuToken: public(UnagiiToken)\r\n# privileges: time lock >= admin >= guardian >= worker\r\ntimeLock: public(address)\r\nnextTimeLock: public(address)\r\nadmin: public(address)\r\nguardian: public(address)\r\nworker: public(address)\r\n\r\n# numerator to calculate the minimum amount of token to be kept in this vault\r\n# for cheap withdraw\r\nminReserve: public(uint256)\r\n\r\ntotalDebt: public(uint256)  # debt to users (total borrowed by strategies)\r\ntotalDebtRatio: public(uint256)  # sum of strategy debt ratios\r\nstrategies: public(HashMap[address, Strategy])  # all strategies\r\nactiveStrategies: public(address[MAX_ACTIVE])  # list of active strategies\r\n\r\nlastSync: public(uint256)  # timestamp of last sync\r\n# profit locked from sync, released over time at a rate set by lockedProfitDegradation\r\nlockedProfit: public(uint256)\r\n# rate at which locked profit is released\r\n# 0 = forever, MAX_DEGRADATION = 100% of profit is released 1 block after sync\r\nlockedProfitDegradation: public(uint256)\r\n\r\n# minimum number of block to wait before deposit / withdraw\r\n# used to protect agains flash attacks\r\nblockDelay: public(uint256)\r\n# whitelisted address can bypass block delay check\r\nwhitelist: public(HashMap[address, bool])\r\n\r\n\r\n@external\r\ndef __init__(token: address, uToken: address, guardian: address, worker: address):\r\n    self.timeLock = msg.sender\r\n    self.admin = msg.sender\r\n    self.guardian = guardian\r\n    self.worker = worker\r\n\r\n    self.token = ERC20(token)\r\n    self.uToken = UnagiiToken(uToken)\r\n\r\n    assert self.uToken.token() == self.token.address, \"uToken token != token\"\r\n\r\n    self.paused = True\r\n    self.blockDelay = 10\r\n    # 6 hours\r\n    self.lockedProfitDegradation = MAX_DEGRADATION / (3600 * 6)\r\n    self.lastSync = block.timestamp\r\n    # 5% of free funds\r\n    self.minReserve = 500\r\n\r\n\r\n@internal\r\ndef _safeApprove(token: address, spender: address, amount: uint256):\r\n    res: Bytes[32] = raw_call(\r\n        token,\r\n        concat(\r\n            APPROVE,\r\n            convert(spender, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(res) > 0:\r\n        assert convert(res, bool), \"approve failed\"\r\n\r\n\r\n@internal\r\ndef _safeTransfer(token: address, receiver: address, amount: uint256):\r\n    res: Bytes[32] = raw_call(\r\n        token,\r\n        concat(\r\n            TRANSFER,\r\n            convert(receiver, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(res) > 0:\r\n        assert convert(res, bool), \"transfer failed\"\r\n\r\n\r\n@internal\r\ndef _safeTransferFrom(\r\n    token: address, owner: address, receiver: address, amount: uint256\r\n):\r\n    res: Bytes[32] = raw_call(\r\n        token,\r\n        concat(\r\n            TRANSFER_FROM,\r\n            convert(owner, bytes32),\r\n            convert(receiver, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(res) > 0:\r\n        assert convert(res, bool), \"transferFrom failed\"\r\n\r\n\r\n@external\r\ndef setNextTimeLock(nextTimeLock: address):\r\n    \"\"\"\r\n    @notice Set next time lock\r\n    @param nextTimeLock Address of next time lock\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n    self.nextTimeLock = nextTimeLock\r\n    log SetNextTimeLock(nextTimeLock)\r\n\r\n\r\n@external\r\ndef acceptTimeLock():\r\n    \"\"\"\r\n    @notice Accept time lock\r\n    @dev Only `nextTimeLock` can claim time lock\r\n    \"\"\"\r\n    assert msg.sender == self.nextTimeLock, \"!next time lock\"\r\n    self.timeLock = msg.sender\r\n    self.nextTimeLock = ZERO_ADDRESS\r\n    log AcceptTimeLock(msg.sender)\r\n\r\n\r\n@external\r\ndef setAdmin(admin: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.admin = admin\r\n    log SetAdmin(admin)\r\n\r\n\r\n@external\r\ndef setGuardian(guardian: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.guardian = guardian\r\n    log SetGuardian(guardian)\r\n\r\n\r\n@external\r\ndef setWorker(worker: address):\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.worker = worker\r\n    log SetWorker(worker)\r\n\r\n\r\n@external\r\ndef setPause(paused: bool):\r\n    assert msg.sender in [self.timeLock, self.admin, self.guardian], \"!auth\"\r\n    self.paused = paused\r\n    log SetPause(paused)\r\n\r\n\r\n@external\r\ndef setMinReserve(minReserve: uint256):\r\n    \"\"\"\r\n    @notice Set minimum amount of token reserved in this vault for cheap\r\n            withdrawn by user\r\n    @param minReserve Numerator to calculate min reserve\r\n           0 - all funds can be transferred to strategies\r\n           MIN_RESERVE_DENOMINATOR - no funds can be transferred to strategies\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert minReserve <= MIN_RESERVE_DENOMINATOR, \"min reserve > max\"\r\n    self.minReserve = minReserve\r\n\r\n\r\n@external\r\ndef setLockedProfitDegradation(degradation: uint256):\r\n    \"\"\"\r\n    @notice Set locked profit degradation (rate locked profit is released)\r\n    @param degradation Rate of degradation\r\n           0 - profit is locked forever\r\n           MAX_DEGRADATION - 100% of profit is released 1 block after sync\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert degradation <= MAX_DEGRADATION, \"degradation > max\"\r\n    self.lockedProfitDegradation = degradation\r\n\r\n\r\n@external\r\ndef setBlockDelay(delay: uint256):\r\n    \"\"\"\r\n    @notice Set block delay, used to protect against flash attacks\r\n    @param delay Number of blocks to delay before user can deposit / withdraw\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert delay >= 1 and delay <= MAX_BLOCK_DELAY, \"delay out of range\"\r\n    self.blockDelay = delay\r\n\r\n\r\n@external\r\ndef setWhitelist(addr: address, approved: bool):\r\n    \"\"\"\r\n    @notice Approve or disapprove address to skip check on block delay.\r\n            Approved address can deposit, withdraw and transfer uToken in\r\n            a single transaction\r\n    @param approved Boolean\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    self.whitelist[addr] = approved\r\n    log SetWhitelist(addr, approved)\r\n\r\n\r\n@internal\r\n@view\r\ndef _totalAssets() -> uint256:\r\n    \"\"\"\r\n    @notice Total amount of token in this vault + amount in strategies\r\n    @dev Returns total amount of token locked in this contract\r\n    \"\"\"\r\n    return self.token.balanceOf(self) + self.totalDebt\r\n\r\n\r\n@external\r\n@view\r\ndef totalAssets() -> uint256:\r\n    return self._totalAssets()\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcLockedProfit() -> uint256:\r\n    \"\"\"\r\n    @notice Calculated locked profit\r\n    @dev Returns amount of profit locked from last sync. Profit is released\r\n         over time, depending on the release rate `lockedProfitDegradation`.\r\n         Profit is locked after `sync` to protect against sandwich attack.\r\n    \"\"\"\r\n    lockedFundsRatio: uint256 = (\r\n        block.timestamp - self.lastSync\r\n    ) * self.lockedProfitDegradation\r\n\r\n    if lockedFundsRatio < MAX_DEGRADATION:\r\n        lockedProfit: uint256 = self.lockedProfit\r\n        return lockedProfit - lockedFundsRatio * lockedProfit / MAX_DEGRADATION\r\n    else:\r\n        return 0\r\n\r\n\r\n@external\r\n@view\r\ndef calcLockedProfit() -> uint256:\r\n    return self._calcLockedProfit()\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcFreeFunds() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate free funds (total assets - locked profit)\r\n    @dev Returns total amount of tokens that can be withdrawn\r\n    \"\"\"\r\n    return self._totalAssets() - self._calcLockedProfit()\r\n\r\n\r\n@external\r\n@view\r\ndef calcFreeFunds() -> uint256:\r\n    return self._calcFreeFunds()\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcMinReserve(freeFunds: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculates minimum amount of token that is reserved in vault for\r\n            cheap withdraw\r\n    @param freeFunds Free funds\r\n    @dev Returns min reserve\r\n    \"\"\"\r\n    return freeFunds * self.minReserve / MIN_RESERVE_DENOMINATOR\r\n\r\n\r\n@external\r\n@view\r\ndef calcMinReserve() -> uint256:\r\n    return self._calcMinReserve(self._calcFreeFunds())\r\n\r\n\r\n@internal\r\n@pure\r\ndef _calcSharesToMint(\r\n    amount: uint256, totalSupply: uint256, freeFunds: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate uToken shares to mint\r\n    @param amount Amount of token to deposit\r\n    @param totalSupply Total amount of shares\r\n    @param freeFunds Free funds before deposit\r\n    @dev Returns amount of uToken to mint. Input must be numbers before deposit\r\n    @dev Calculated with `freeFunds`, not `totalAssets`\r\n    \"\"\"\r\n    # s = shares to mint\r\n    # T = total shares before mint\r\n    # a = deposit amount\r\n    # P = total amount of token in vault + strategies before deposit\r\n    # s / (T + s) = a / (P + a)\r\n    # sP = aT\r\n    # a = 0               | mint s = 0\r\n    # a > 0, T = 0, P = 0 | mint s = a\r\n    # a > 0, T = 0, P > 0 | mint s = a as if P = 0\r\n    # a > 0, T > 0, P = 0 | invalid, equation cannot be true for any s\r\n    # a > 0, T > 0, P > 0 | mint s = aT / P\r\n    if totalSupply > 0:\r\n        # reverts if free funds = 0\r\n        return amount * totalSupply / freeFunds\r\n    return amount\r\n\r\n\r\n@external\r\n@view\r\ndef calcSharesToMint(amount: uint256) -> uint256:\r\n    return self._calcSharesToMint(\r\n        amount, self.uToken.totalSupply(), self._calcFreeFunds()\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit(amount: uint256, _min: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit token into vault\r\n    @param amount Amount of token to deposit\r\n    @param _min Minimum amount of shares to be minted\r\n    @dev Returns actual amount of shares minted\r\n    \"\"\"\r\n    assert not self.paused, \"paused\"\r\n    assert amount > 0, \"deposit = 0\"\r\n\r\n    # check whitelisted or block delay\r\n    assert (\r\n        self.whitelist[msg.sender]\r\n        or block.number >= self.uToken.lastBlock(msg.sender) + self.blockDelay\r\n    ), \"block < delay\"\r\n\r\n    totalSupply: uint256 = self.uToken.totalSupply()\r\n    freeFunds: uint256 = self._calcFreeFunds()\r\n\r\n    bal: uint256 = self.token.balanceOf(self)\r\n    self._safeTransferFrom(self.token.address, msg.sender, self, amount)\r\n    diff: uint256 = self.token.balanceOf(self) - bal\r\n\r\n    # calculate with free funds before deposit\r\n    shares: uint256 = self._calcSharesToMint(diff, totalSupply, freeFunds)\r\n    assert shares >= _min, \"shares < min\"\r\n\r\n    self.uToken.mint(msg.sender, shares)\r\n\r\n    log Deposit(msg.sender, amount, diff, shares)\r\n\r\n    return shares\r\n\r\n\r\n@internal\r\n@pure\r\ndef _calcWithdraw(shares: uint256, totalSupply: uint256, freeFunds: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate amount of token to withdraw\r\n    @param shares Amount of uToken shares to burn\r\n    @param totalSupply Total amount of shares before burn\r\n    @param freeFunds Free funds\r\n    @dev Returns amount of token to withdraw\r\n    @dev Calculated with `freeFunds`, not `totalAssets`\r\n    \"\"\"\r\n    # s = shares\r\n    # T = total supply of shares\r\n    # a = amount to withdraw\r\n    # P = total amount of token in vault + strategies\r\n    # s / T = a / P (constraints T >= s, P >= a)\r\n    # sP = aT\r\n    # s = 0               | a = 0\r\n    # s > 0, T = 0, P = 0 | invalid (violates constraint T >= s)\r\n    # s > 0, T = 0, P > 0 | invalid (violates constraint T >= s)\r\n    # s > 0, T > 0, P = 0 | a = 0\r\n    # s > 0, T > 0, P > 0 | a = sP / T\r\n\r\n    # invalid if total supply = 0\r\n    return shares * freeFunds / totalSupply\r\n\r\n\r\n@external\r\n@view\r\ndef calcWithdraw(shares: uint256) -> uint256:\r\n    return self._calcWithdraw(shares, self.uToken.totalSupply(), self._calcFreeFunds())\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw(shares: uint256, _min: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw token from vault\r\n    @param shares Amount of uToken to burn\r\n    @param _min Minimum amount of token that msg.sender will receive\r\n    @dev Returns actual amount of token transferred to msg.sender\r\n    \"\"\"\r\n    assert shares > 0, \"shares = 0\"\r\n\r\n    # check whitelisted or block delay\r\n    assert (\r\n        self.whitelist[msg.sender]\r\n        or block.number >= self.uToken.lastBlock(msg.sender) + self.blockDelay\r\n    ), \"block < delay\"\r\n\r\n    amount: uint256 = self._calcWithdraw(\r\n        shares, self.uToken.totalSupply(), self._calcFreeFunds()\r\n    )\r\n\r\n    self.uToken.burn(msg.sender, shares)\r\n\r\n    # withdraw from strategies if amount to withdraw > balance of vault\r\n    bal: uint256 = self.token.balanceOf(self)\r\n    if amount > bal:\r\n        for strat in self.activeStrategies:\r\n            # reached end of active strategies\r\n            if strat == ZERO_ADDRESS:\r\n                break\r\n\r\n            # done withdrawing\r\n            if bal >= amount:\r\n                break\r\n\r\n            need: uint256 = min(amount - bal, self.strategies[strat].debt)\r\n            if need > 0:\r\n                IStrategy(strat).withdraw(need)\r\n                diff: uint256 = self.token.balanceOf(self) - bal\r\n                bal += diff  # = self.token.balanceOf(self)\r\n\r\n                self.strategies[strat].debt -= diff\r\n                self.totalDebt -= diff\r\n\r\n                # calculate loss\r\n                total: uint256 = IStrategy(strat).totalAssets()\r\n                debt: uint256 = self.strategies[strat].debt\r\n                if total < debt:\r\n                    loss: uint256 = debt - total\r\n                    self.strategies[strat].debt -= loss\r\n                    self.totalDebt -= loss\r\n                    amount -= loss\r\n\r\n        if amount > bal:\r\n            amount = bal\r\n\r\n    assert amount >= _min, \"amount < min\"\r\n    self._safeTransfer(self.token.address, msg.sender, amount)\r\n\r\n    log Withdraw(msg.sender, shares, amount)\r\n\r\n    return amount\r\n\r\n\r\n# array functions see test/ArrayTest.vy for tests\r\n@internal\r\ndef _pack():\r\n    \"\"\"\r\n    @dev Pack array elements to left\r\n         example\r\n         before [1, 2, 0, 0, 3]\r\n         after  [1, 2, 3, 0, 0]\r\n    \"\"\"\r\n    arr: address[MAX_ACTIVE] = empty(address[MAX_ACTIVE])\r\n    i: uint256 = 0\r\n    for strat in self.activeStrategies:\r\n        if strat != ZERO_ADDRESS:\r\n            arr[i] = strat\r\n            i += 1\r\n    self.activeStrategies = arr\r\n\r\n\r\n@internal\r\ndef _append(strategy: address):\r\n    assert self.activeStrategies[MAX_ACTIVE - 1] == ZERO_ADDRESS, \"active > max\"\r\n    self.activeStrategies[MAX_ACTIVE - 1] = strategy\r\n    self._pack()\r\n\r\n\r\n@internal\r\ndef _remove(i: uint256):\r\n    assert i < MAX_ACTIVE, \"i >= max\"\r\n    assert self.activeStrategies[i] != ZERO_ADDRESS, \"zero address\"\r\n    self.activeStrategies[i] = ZERO_ADDRESS\r\n    self._pack()\r\n\r\n\r\n@internal\r\n@view\r\ndef _find(strategy: address) -> uint256:\r\n    for i in range(MAX_ACTIVE):\r\n        if self.activeStrategies[i] == strategy:\r\n            return i\r\n    raise \"not found\"\r\n\r\n\r\n@external\r\ndef approveStrategy(strategy: address):\r\n    \"\"\"\r\n    @notice Approve strategy\r\n    @param strategy Address of strategy\r\n    \"\"\"\r\n    assert msg.sender == self.timeLock, \"!time lock\"\r\n\r\n    assert not self.strategies[strategy].approved, \"approved\"\r\n    assert IStrategy(strategy).vault() == self, \"strategy vault != vault\"\r\n    assert IStrategy(strategy).token() == self.token.address, \"strategy token != token\"\r\n\r\n    self.strategies[strategy] = Strategy(\r\n        {\r\n            approved: True,\r\n            active: False,\r\n            debtRatio: 0,\r\n            debt: 0,\r\n        }\r\n    )\r\n\r\n    log ApproveStrategy(strategy)\r\n\r\n\r\n@external\r\ndef revokeStrategy(strategy: address):\r\n    \"\"\"\r\n    @notice Disapprove strategy\r\n    @param strategy Address of strategy\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert self.strategies[strategy].approved, \"!approved\"\r\n    assert not self.strategies[strategy].active, \"active\"\r\n\r\n    self.strategies[strategy].approved = False\r\n    log RevokeStrategy(strategy)\r\n\r\n\r\n@external\r\ndef activateStrategy(strategy: address, debtRatio: uint256):\r\n    \"\"\"\r\n    @notice Activate strategy\r\n    @param strategy Address of strategy\r\n    @param debtRatio Ratio of total assets of vault that strategy can borrow\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert self.strategies[strategy].approved, \"!approved\"\r\n    assert not self.strategies[strategy].active, \"active\"\r\n\r\n    self._append(strategy)\r\n    self.strategies[strategy].active = True\r\n    self.strategies[strategy].debtRatio = debtRatio\r\n\r\n    self.totalDebtRatio += debtRatio\r\n    assert self.totalDebtRatio <= MAX_TOTAL_DEBT_RATIO, \"debt ratio > max\"\r\n\r\n    log ActivateStrategy(strategy)\r\n\r\n\r\n@external\r\ndef deactivateStrategy(strategy: address):\r\n    \"\"\"\r\n    @notice Deactivate strategy\r\n    @param strategy Addres of strategy\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin, self.guardian], \"!auth\"\r\n    assert self.strategies[strategy].active, \"!active\"\r\n\r\n    self._remove(self._find(strategy))\r\n    self.strategies[strategy].active = False\r\n    self.totalDebtRatio -= self.strategies[strategy].debtRatio\r\n    self.strategies[strategy].debtRatio = 0\r\n\r\n    log DeactivateStrategy(strategy)\r\n\r\n\r\n@external\r\ndef setActiveStrategies(strategies: address[MAX_ACTIVE]):\r\n    \"\"\"\r\n    @notice Reorder active strategies\r\n    @param strategies Array of active strategies\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n\r\n    for i in range(MAX_ACTIVE):\r\n        old: address = self.activeStrategies[i]\r\n        new: address = strategies[i]\r\n\r\n        # check old and new strategies have the same number of strategies\r\n        if old == ZERO_ADDRESS:\r\n            assert new == ZERO_ADDRESS, \"new != zero address\"\r\n        else:\r\n            assert new != ZERO_ADDRESS, \"new = zero address\"\r\n\r\n            # Check new strategy is active and no duplicate\r\n            # assert will fail if duplicate strategy in new strategies\r\n            assert self.strategies[new].active, \"!active\"\r\n            self.strategies[new].active = False\r\n\r\n    # update active strategies\r\n    for i in range(MAX_ACTIVE):\r\n        new: address = strategies[i]\r\n        if new == ZERO_ADDRESS:\r\n            break\r\n        self.strategies[new].active = True\r\n        self.activeStrategies[i] = new\r\n\r\n    log SetActiveStrategies(strategies)\r\n\r\n\r\n@external\r\ndef setDebtRatios(debtRatios: uint256[MAX_ACTIVE]):\r\n    \"\"\"\r\n    @notice Update debt ratios of active strategies\r\n    @param debtRatios Array of debt ratios\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n\r\n    # use memory to save gas\r\n    totalDebtRatio: uint256 = 0\r\n    for i in range(MAX_ACTIVE):\r\n        strat: address = self.activeStrategies[i]\r\n        if strat == ZERO_ADDRESS:\r\n            break\r\n\r\n        self.strategies[strat].debtRatio = debtRatios[i]\r\n        totalDebtRatio += debtRatios[i]\r\n\r\n    self.totalDebtRatio = totalDebtRatio\r\n    assert self.totalDebtRatio <= MAX_TOTAL_DEBT_RATIO, \"total > max\"\r\n\r\n    log SetDebtRatios(debtRatios)\r\n\r\n\r\n@internal\r\n@view\r\ndef _calcMaxBorrow(strategy: address) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate how much `token` strategy can borrow\r\n    @param strategy Address of strategy\r\n    @dev Returns amount of `token` that `strategy` can borrow\r\n    \"\"\"\r\n    if self.paused or self.totalDebtRatio == 0:\r\n        return 0\r\n\r\n    bal: uint256 = self.token.balanceOf(self)\r\n    freeFunds: uint256 = self._calcFreeFunds()\r\n    minReserve: uint256 = self._calcMinReserve(freeFunds)\r\n    if bal <= minReserve:\r\n        return 0\r\n\r\n    # min reserve <= free funds\r\n    # strategy debtRatio = 0 if strategy is not active\r\n    limit: uint256 = (\r\n        (freeFunds - minReserve)\r\n        * self.strategies[strategy].debtRatio\r\n        / self.totalDebtRatio\r\n    )\r\n    debt: uint256 = self.strategies[strategy].debt\r\n\r\n    if debt >= limit:\r\n        return 0\r\n\r\n    # minimum of debt limit and tokens available in this vault\r\n    return min(limit - debt, bal - minReserve)\r\n\r\n\r\n@external\r\n@view\r\ndef calcMaxBorrow(strategy: address) -> uint256:\r\n    return self._calcMaxBorrow(strategy)\r\n\r\n\r\n@external\r\ndef borrow(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Borrow token from vault\r\n    @param amount Amount of token to borrow\r\n    @dev Only active strategy can borrow\r\n    @dev Returns amount that was sent\r\n    \"\"\"\r\n    assert self.strategies[msg.sender].active, \"!active strategy\"\r\n\r\n    available: uint256 = self._calcMaxBorrow(msg.sender)\r\n    _amount: uint256 = min(amount, available)\r\n    assert _amount > 0, \"borrow = 0\"\r\n\r\n    self._safeTransfer(self.token.address, msg.sender, _amount)\r\n\r\n    self.totalDebt += _amount\r\n    self.strategies[msg.sender].debt += _amount\r\n\r\n    log Borrow(msg.sender, _amount)\r\n\r\n    return _amount\r\n\r\n\r\n@external\r\ndef repay(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Repay token to vault\r\n    @param amount Amount of token to repay\r\n    @dev Only approved and active strategy can repay\r\n    @dev Returns actual amount that was repaid\r\n    \"\"\"\r\n    assert self.strategies[msg.sender].approved, \"!approved strategy\"\r\n    assert amount > 0, \"repay = 0\"\r\n\r\n    bal: uint256 = self.token.balanceOf(self)\r\n    self._safeTransferFrom(self.token.address, msg.sender, self, amount)\r\n    diff: uint256 = self.token.balanceOf(self) - bal\r\n\r\n    self.totalDebt -= diff\r\n    self.strategies[msg.sender].debt -= diff\r\n\r\n    log Repay(msg.sender, diff)\r\n\r\n    return diff\r\n\r\n\r\n@external\r\ndef sync(strategy: address, minTotal: uint256, maxTotal: uint256):\r\n    \"\"\"\r\n    @notice Update debt of strategy based on total asset of strategy\r\n    @param strategy Address of active strategy\r\n    @param minTotal Minimum of total asset of strategy\r\n    @param maxTotal Maximum of total asset of strategy\r\n    @dev `minTotal` and `maxTotal` are used to make sure total asset is within\r\n          a reasonable range\r\n    \"\"\"\r\n    assert msg.sender in [self.worker, self.admin, self.timeLock], \"!auth\"\r\n    assert self.strategies[strategy].active, \"!active strategy\"\r\n\r\n    debt: uint256 = self.strategies[strategy].debt\r\n    total: uint256 = IStrategy(strategy).totalAssets()\r\n\r\n    assert total >= minTotal and total <= maxTotal, \"total out of range\"\r\n\r\n    gain: uint256 = 0\r\n    loss: uint256 = 0\r\n    locked: uint256 = self._calcLockedProfit()\r\n\r\n    if total > debt:\r\n        gain = total - debt\r\n        self.lockedProfit = locked + gain\r\n\r\n        self.strategies[strategy].debt += gain\r\n        self.totalDebt += gain\r\n    elif total < debt:\r\n        loss = debt - total\r\n        if loss > locked:\r\n            self.lockedProfit = 0\r\n        else:\r\n            self.lockedProfit -= loss\r\n\r\n        self.strategies[strategy].debt -= loss\r\n        self.totalDebt -= loss\r\n\r\n    self.lastSync = block.timestamp\r\n\r\n    # log debt before update, so gain and loss can be computed offchain\r\n    log Sync(strategy, total, debt, self.lockedProfit)\r\n\r\n\r\n@external\r\ndef sweep(token: address):\r\n    \"\"\"\r\n    @notice Transfer any token (except `token`) accidentally sent to this contract\r\n            to admin or time lock\r\n    @dev Cannot transfer `self.token`\r\n    \"\"\"\r\n    assert msg.sender in [self.timeLock, self.admin], \"!auth\"\r\n    assert token != self.token.address, \"protected\"\r\n    self._safeTransfer(token, msg.sender, ERC20(token).balanceOf(self))","ABI":"[{\"name\":\"SetNextTimeLock\",\"inputs\":[{\"name\":\"nextTimeLock\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AcceptTimeLock\",\"inputs\":[{\"name\":\"timeLock\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetGuardian\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWorker\",\"inputs\":[{\"name\":\"worker\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWhitelist\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"diff\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApproveStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RevokeStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ActivateStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DeactivateStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetActiveStrategies\",\"inputs\":[{\"name\":\"strategies\",\"type\":\"address[20]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetDebtRatios\",\"inputs\":[{\"name\":\"debtRatios\",\"type\":\"uint256[20]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Borrow\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Repay\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Sync\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"total\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lockedProfit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"uToken\",\"type\":\"address\"},{\"name\":\"guardian\",\"type\":\"address\"},{\"name\":\"worker\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setNextTimeLock\",\"inputs\":[{\"name\":\"nextTimeLock\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38921},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"acceptTimeLock\",\"inputs\":[],\"outputs\":[],\"gas\":58849},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41502},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setGuardian\",\"inputs\":[{\"name\":\"guardian\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41532},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setWorker\",\"inputs\":[{\"name\":\"worker\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41562},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":43860},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setMinReserve\",\"inputs\":[{\"name\":\"minReserve\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40293},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setLockedProfitDegradation\",\"inputs\":[{\"name\":\"degradation\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40323},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setBlockDelay\",\"inputs\":[{\"name\":\"delay\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":40377},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setWhitelist\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":42308},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalAssets\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":8038},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcLockedProfit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":8589},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcFreeFunds\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":32323},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcMinReserve\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":35622},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcSharesToMint\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":38439},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":160822},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcWithdraw\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":38404},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3536459},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approveStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[],\"gas\":108844},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revokeStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[],\"gas\":31560},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"activateStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"debtRatio\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":1665601},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deactivateStrategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[],\"gas\":1669591},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setActiveStrategies\",\"inputs\":[{\"name\":\"strategies\",\"type\":\"address[20]\"}],\"outputs\":[],\"gas\":1924344},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setDebtRatios\",\"inputs\":[{\"name\":\"debtRatios\",\"type\":\"uint256[20]\"}],\"outputs\":[],\"gas\":810198},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calcMaxBorrow\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":88778},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"borrow\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":179960},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":101492},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sync\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"minTotal\",\"type\":\"uint256\"},{\"name\":\"maxTotal\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":175649},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"outputs\":[],\"gas\":20791},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3258},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3288},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"uToken\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3318},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"timeLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3348},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nextTimeLock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"guardian\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"worker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minReserve\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalDebt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalDebtRatio\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"strategies\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"approved\",\"type\":\"bool\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"debtRatio\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"}],\"gas\":10613},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"activeStrategies\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3663},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lastSync\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lockedProfit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3678},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lockedProfitDegradation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3708},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"blockDelay\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3738},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3983}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.15","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000ffd51a24c65cc6981f3a543320fdadaf57fffd7a00000000000000000000000086d10751b18f3fe331c146546868a07224a8598b00000000000000000000000086d10751b18f3fe331c146546868a07224a8598b","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}