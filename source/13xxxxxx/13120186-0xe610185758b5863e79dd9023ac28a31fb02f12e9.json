{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/OfficialBuffDoge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.8.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./utils/IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./utils/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./utils/IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./utils/IERC20.sol\\\";\\r\\nimport \\\"./utils/TimeLock.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice ERC20 token with cost basis tracking and restricted loss-taking\\r\\n */\\r\\ncontract OfficialBuffDoge is IERC20, TimeLock {\\r\\n\\r\\n    address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    address private constant WETH           = 0xc778417E063141139Fce010982780140Aa0cD5Ab;\\r\\n\\r\\n    mapping (address => uint256) private _rOwned;\\r\\n    mapping (address => uint256) private _tOwned;\\r\\n    mapping (address => mapping (address => uint256)) private _allowances;\\r\\n\\r\\n    mapping(address => uint256) private _basisOf;\\r\\n    mapping(address => uint256) public cooldownOf;\\r\\n    mapping (address => bool) private _isAllowedTransfer;\\r\\n    mapping (address => bool) private _isExcluded;\\r\\n    mapping (address => bool) private _blackList;\\r\\n\\r\\n    address[] private _excluded;\\r\\n\\r\\n    string  private _NAME;\\r\\n    string  private _SYMBOL;\\r\\n    uint256 private _DECIMALS;\\r\\n   \\r\\n    uint256 private constant _MAX = ~uint256(0);\\r\\n    uint256 private constant _GRANULARITY = 100;\\r\\n    uint256 private constant _maxTeamMintAmount = 1e8 ether;\\r\\n   \\r\\n    uint256 private _tTotal;\\r\\n    uint256 private _rTotal;\\r\\n    \\r\\n    uint256 private _tFeeTotal;\\r\\n    uint256 private _tBurnTotal;\\r\\n    uint256 private _tMarketingFeeTotal;\\r\\n\\r\\n    uint256 public    _TAX_FEE; // 3%\\r\\n    uint256 public   _BURN_FEE; // 3%\\r\\n    uint256 public _MARKET_FEE; // 3%\\r\\n\\r\\n    // Track original fees to bypass fees for charity account\\r\\n    uint256 private mintedSupply;\\r\\n\\r\\n\\r\\n    address private _shoppingCart;\\r\\n    address private _rewardWallet;\\r\\n    address private _pair;\\r\\n    address private _owner;\\r\\n\\r\\n    bool private _paused;\\r\\n    bool private _isEnableSwapTokenforEth;\\r\\n\\r\\n    struct Minting {\\r\\n        address recipient;\\r\\n        uint amount;\\r\\n    }\\r\\n\\r\\n    struct StandardFees {\\r\\n        uint taxFee;\\r\\n        uint rewardFee;\\r\\n        uint marketFee;\\r\\n        uint taxPenaltyFee;\\r\\n        uint rewardPenaltyFee;\\r\\n        uint marketPenaltyFee;\\r\\n    }\\r\\n    StandardFees private _standardFees;\\r\\n\\r\\n    mapping(address => address) private _referralOwner;\\r\\n    mapping(address => uint256) private _referralOwnerTotalFee;\\r\\n\\r\\n    constructor (string memory _name, string memory _symbol, uint256 _decimals, uint256 _supply, address[] memory blackList) {\\r\\n        _owner = msg.sender;\\r\\n        _NAME = _name;\\r\\n        _SYMBOL = _symbol;\\r\\n        _DECIMALS = _decimals;\\r\\n        _tTotal =_supply * (10 ** uint256(_DECIMALS));\\r\\n        _rTotal = (_MAX - (_MAX % _tTotal));\\r\\n\\r\\n        // setup uniswap pair and store address\\r\\n        _pair = IUniswapV2Factory(IUniswapV2Router02(UNISWAP_ROUTER).factory())\\r\\n            .createPair(WETH, address(this));\\r\\n        _rOwned[address(this)] = _rTotal;\\r\\n        _excludeAccount(msg.sender);\\r\\n        _excludeAccount(address(this));\\r\\n        _excludeAccount(_pair);\\r\\n        _excludeAccount(UNISWAP_ROUTER);\\r\\n\\r\\n        // prepare to add liquidity\\r\\n        _approve(address(this), _owner, _rTotal);\\r\\n\\r\\n        _paused = true;\\r\\n        _isEnableSwapTokenforEth = false;\\r\\n\\r\\n        if (blackList.length > 0) {\\r\\n            for(uint k = 0; k < blackList.length; k++) {\\r\\n                _blackList[blackList[k]] = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier isNotPaused() {\\r\\n        require(_paused == false, \\\"ERR: paused already\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function name() external view returns (string memory) {\\r\\n        return _NAME;\\r\\n    }\\r\\n\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _SYMBOL;\\r\\n    }\\r\\n\\r\\n    function decimals() external view returns (uint256) {\\r\\n        return _DECIMALS;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        if (_isExcluded[account]) return _tOwned[account];\\r\\n        return tokenFromReflection(_rOwned[account]);\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function isExcluded(address account) external view returns (bool) {\\r\\n        return _isExcluded[account];\\r\\n    }\\r\\n    \\r\\n    function totalFees() external view returns (uint256) {\\r\\n        return _tFeeTotal;\\r\\n    }\\r\\n    \\r\\n    function totalBurn() external view returns (uint256) {\\r\\n        return _tBurnTotal;\\r\\n    }\\r\\n    \\r\\n    function totalMarketingFees() external view returns (uint256) {\\r\\n        return _tMarketingFeeTotal;\\r\\n    }\\r\\n\\r\\n    function checkReferralReward(address referralOwner) external view returns (uint256) {\\r\\n        return _referralOwnerTotalFee[referralOwner];\\r\\n    }\\r\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\r\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\r\\n        if (!deductTransferFee) {\\r\\n            (uint256 rAmount,,,,,,) = _getValues(tAmount);\\r\\n            return rAmount;\\r\\n        } else {\\r\\n            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\\r\\n            return rTransferAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\r\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\r\\n        return rAmount / _getRate();\\r\\n    }\\r\\n\\r\\n    function excludeAccount(address account) external onlyOwner {\\r\\n        _excludeAccount(account);\\r\\n    }\\r\\n\\r\\n    function _excludeAccount(address account) private {\\r\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\r\\n        if(_rOwned[account] > 0) {\\r\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\r\\n        }\\r\\n        _isExcluded[account] = true;\\r\\n        _excluded.push(account);\\r\\n        _isAllowedTransfer[account] = true;\\r\\n        excludeFromLock(account);\\r\\n    }\\r\\n\\r\\n    function includeAccount(address account) external onlyOwner {\\r\\n        require(_isExcluded[account], \\\"Account is already included\\\");\\r\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\r\\n            if (_excluded[i] == account) {\\r\\n                _excluded[i] = _excluded[_excluded.length - 1];\\r\\n                _tOwned[account] = 0;\\r\\n                _isExcluded[account] = false;\\r\\n                _excluded.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require(owner != address(0), \\\"TOKEN20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"TOKEN20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function basisOf(address account) public view returns (uint256) {\\r\\n        uint256 basis = _basisOf[account];\\r\\n        if (basis == 0 && balanceOf(account) > 0) {\\r\\n            basis = 0;\\r\\n        }\\r\\n        return basis;\\r\\n    }\\r\\n\\r\\n    function setBusinessWallet(address businessAddress) external onlyOwner isNotPaused returns (bool) {\\r\\n        require(businessAddress != address(0), \\\"ERR: zero address\\\");\\r\\n        _shoppingCart = businessAddress;\\r\\n        uint256 cartAmount = 5e7 ether;\\r\\n        _removeFee();\\r\\n        _transferFromExcluded(address(this), businessAddress, cartAmount);\\r\\n        _restoreAllFee();\\r\\n        _excludeAccount(businessAddress);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setRewardAddress(address rewardAddress) external onlyOwner isNotPaused returns (bool) {\\r\\n        require(rewardAddress != address(0), \\\"ERR: zero address\\\");\\r\\n        _rewardWallet = rewardAddress;\\r\\n        uint256 burnAmount = 35 * 1e7 ether;\\r\\n        _removeFee();\\r\\n        _transferFromExcluded(address(this), rewardAddress, burnAmount);\\r\\n        _restoreAllFee();\\r\\n        _excludeAccount(rewardAddress);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setTokenExchange(address exchangeAddress) external onlyOwner isNotPaused returns (bool) {\\r\\n        require(exchangeAddress != address(0), \\\"ERR: zero address\\\");\\r\\n        _approve(address(this), exchangeAddress, 1e8 ether);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setReferralOwner(address referralUser, address referralOwner) external returns (bool) {\\r\\n        require(_referralOwner[referralUser] == address(0), \\\"ERR: address registered already\\\");\\r\\n        require(referralUser != address(0), \\\"ERR: zero address\\\");\\r\\n        require(referralOwner != address(0), \\\"ERR: zero address\\\");\\r\\n        _referralOwner[referralUser] = referralOwner;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setStandardFee(StandardFees memory _standardFee) external onlyOwner isNotPaused returns (bool) {\\r\\n        require (_standardFee.taxFee < 100 && _standardFee.rewardFee < 100 && _standardFee.marketFee < 100, \\\"ERR: Fee is so high\\\");\\r\\n        require (\\r\\n            _standardFee.taxPenaltyFee < 100 && _standardFee.rewardPenaltyFee < 100 &&\\r\\n            _standardFee.marketPenaltyFee < 100, \\\"ERR: Fee is so high\\\");\\r\\n        _standardFees = _standardFee;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function addBlackList(address blackAddress) external onlyOwner returns (bool) {\\r\\n        require(blackAddress != _owner);\\r\\n        require(!_blackList[blackAddress]);\\r\\n        _blackList[blackAddress] = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeBlackList(address removeAddress) external onlyOwner returns (bool) {\\r\\n        require(_blackList[removeAddress]);\\r\\n        require(removeAddress != _owner);\\r\\n        _blackList[removeAddress] = false;\\r\\n        return true;\\r\\n    }\\r\\n   \\r\\n    function mintDev(Minting[] calldata mintings) external onlyOwner returns (bool) {\\r\\n        require(mintings.length > 0, \\\"ERR: zero address array\\\");\\r\\n        _removeFee();       \\r\\n        for(uint i = 0; i < mintings.length; i++) {\\r\\n            Minting memory m = mintings[i];\\r\\n            require(mintedSupply + m.amount <= _maxTeamMintAmount, \\\"ERR: exceed max team mint amount\\\");\\r\\n            _transferFromExcluded(address(this), m.recipient, m.amount);\\r\\n            mintedSupply += m.amount;\\r\\n            lockAddress(m.recipient, uint64(180 days));\\r\\n        }        \\r\\n        _restoreAllFee();\\r\\n        return true;\\r\\n    }    \\r\\n\\r\\n    function pausedEnable() external onlyOwner returns (bool) {\\r\\n        require(!_paused, \\\"ERR: already pause enabled\\\");\\r\\n        _paused = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function pausedNotEnable() external onlyOwner returns (bool) {\\r\\n        require(_paused, \\\"ERR: already pause disabled\\\");\\r\\n        _paused = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function swapTokenForEthEnable() external onlyOwner isNotPaused returns (bool) {\\r\\n        require(!_isEnableSwapTokenforEth, \\\"ERR: already enabled\\\");\\r\\n        _isEnableSwapTokenforEth = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function swapTokenForEthDisable() external onlyOwner isNotPaused returns (bool) {\\r\\n        require(_isEnableSwapTokenforEth, \\\"ERR: already disabled\\\");\\r\\n        _isEnableSwapTokenforEth = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkReferralOwner(address referralUser) external view returns (address) {\\r\\n        require(referralUser != address(0), \\\"ERR: zero address\\\");\\r\\n        return _referralOwner[referralUser];\\r\\n    }\\r\\n\\r\\n    function checkedTimeLock(address user) external view returns (bool) {\\r\\n        return !isUnLocked(user);\\r\\n    }\\r\\n\\r\\n    function checkAllowedTransfer(address user) external view returns (bool) {\\r\\n        return _isAllowedTransfer[user];\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        require(!_blackList[from] && !_blackList[to]);\\r\\n        // ignore minting and burning\\r\\n        if (from == address(0) || to == address(0)) return;\\r\\n        // ignore add/remove liquidity\\r\\n        if (from == address(this) || to == address(this)) return;\\r\\n        if (from == _owner || to == _owner) return;\\r\\n        if (from == UNISWAP_ROUTER || to == UNISWAP_ROUTER) return;\\r\\n\\r\\n        require(\\r\\n            msg.sender == UNISWAP_ROUTER ||\\r\\n            msg.sender == _pair || msg.sender == _owner ||\\r\\n            _isAllowedTransfer[from] || _isAllowedTransfer[to],\\r\\n            \\\"ERR: sender must be uniswap or shoppingCart\\\"\\r\\n        );\\r\\n        address[] memory path = new address[](2);\\r\\n        if (from == _pair && !_isExcluded[to]) {\\r\\n            require(isUnLocked(to), \\\"ERR: address is locked(buy)\\\");\\r\\n\\r\\n            require(\\r\\n                cooldownOf[to] < block.timestamp /* revert message not returned by Uniswap */\\r\\n            );\\r\\n            cooldownOf[to] = block.timestamp + (30 minutes);\\r\\n\\r\\n            path[0] = WETH;\\r\\n            path[1] = address(this);\\r\\n            uint256[] memory amounts =\\r\\n                IUniswapV2Router02(UNISWAP_ROUTER).getAmountsIn(amount, path);\\r\\n\\r\\n            uint256 balance = balanceOf(to);\\r\\n            uint256 fromBasis = (1 ether) * amounts[0] / amount;\\r\\n            _basisOf[to] =\\r\\n                (fromBasis * amount + basisOf(to) * balance) / (amount + balance);\\r\\n\\r\\n        } else if (to == _pair && !_isExcluded[from]) {\\r\\n            require(isUnLocked(from), \\\"ERR: address is locked(sales)\\\");            \\r\\n            require(\\r\\n                cooldownOf[from] < block.timestamp /* revert message not returned by Uniswap */\\r\\n            );\\r\\n            cooldownOf[from] = block.timestamp + (30 minutes);            \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n        _transferWithFee(sender, recipient, amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _transferWithFee(\\r\\n        address sender, address recipient, uint256 amount\\r\\n    ) private returns (bool) {\\r\\n        uint liquidityBalance = balanceOf(_pair);\\r\\n\\r\\n        if(sender == _pair && !_isAllowedTransfer[recipient]) {\\r\\n            require(amount <= liquidityBalance / 100, \\\"ERR: Exceed the 1% of current liquidity balance\\\");\\r\\n            _restoreAllFee();\\r\\n        }\\r\\n        else if(recipient == _pair && !_isAllowedTransfer[sender]) {\\r\\n            require(_isEnableSwapTokenforEth, \\\"ERR: disabled swap\\\");\\r\\n            require(amount <= liquidityBalance / 100, \\\"ERR: Exceed the 1% of current liquidity balance\\\");\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = address(this);\\r\\n            path[1] = WETH;\\r\\n            uint[] memory amounts = IUniswapV2Router02(UNISWAP_ROUTER).getAmountsOut(\\r\\n                amount,\\r\\n                path\\r\\n            );\\r\\n            if (basisOf(sender) <= (1 ether) * amounts[1] / amount) {\\r\\n                _restoreAllFee();\\r\\n            }\\r\\n            else {\\r\\n                _setPenaltyFee();\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            _removeFee();\\r\\n        }\\r\\n\\r\\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\\r\\n            _transferFromExcluded(sender, recipient, amount);\\r\\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\\r\\n            if(recipient == _pair) {\\r\\n                _transferToExcludedForSale(sender, recipient, amount);\\r\\n            }\\r\\n            else {\\r\\n                _transferToExcluded(sender, recipient, amount);\\r\\n            }\\r\\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\\r\\n            _transferStandard(sender, recipient, amount);\\r\\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\\r\\n            _transferBothExcluded(sender, recipient, amount);\\r\\n        } else {\\r\\n            _transferStandard(sender, recipient, amount);\\r\\n        }\\r\\n        _restoreAllFee();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\r\\n        uint256 rBurn =  tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;     \\r\\n        _standardTransferContent(sender, recipient, rAmount, rTransferAmount);\\r\\n        if (tMarket > 0) {\\r\\n            _sendToBusinees(tMarket, sender, recipient);\\r\\n        }\\r\\n        if (tBurn > 0) {\\r\\n            _sendToBurn(tBurn, sender);\\r\\n        }\\r\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _standardTransferContent(address sender, address recipient, uint256 rAmount, uint256 rTransferAmount) private {\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\r\\n    }\\r\\n    \\r\\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\r\\n        uint256 rBurn =  tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;\\r\\n        _excludedFromTransferContent(sender, recipient, tTransferAmount, rAmount, rTransferAmount);        \\r\\n        if (tMarket > 0) {\\r\\n            _sendToBusinees(tMarket, sender, recipient);\\r\\n        }\\r\\n        if (tBurn > 0) {\\r\\n            _sendToBurn(tBurn, sender);\\r\\n        }\\r\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _excludedFromTransferContent(address sender, address recipient, uint256 tTransferAmount, uint256 rAmount, uint256 rTransferAmount) private {\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;    \\r\\n    }\\r\\n    \\r\\n    function _transferToExcludedForSale(address sender, address recipient, uint256 tAmount) private {\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValuesForSale(tAmount);\\r\\n        uint256 rBurn =  tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;\\r\\n        _excludedFromTransferContentForSale(sender, recipient, tAmount, rAmount, rTransferAmount);        \\r\\n        if (tMarket > 0) {\\r\\n            _sendToBusinees(tMarket, sender, recipient);\\r\\n        }\\r\\n        if (tBurn > 0) {\\r\\n            _sendToBurn(tBurn, sender);\\r\\n        }\\r\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _excludedFromTransferContentForSale(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 rTransferAmount) private {\\r\\n        _rOwned[sender] = _rOwned[sender] - rTransferAmount;\\r\\n        _tOwned[recipient] = _tOwned[recipient] + tAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rAmount;    \\r\\n    }    \\r\\n\\r\\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\r\\n        uint256 rBurn =  tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;\\r\\n        _excludedToTransferContent(sender, recipient, tAmount, rAmount, rTransferAmount);\\r\\n        if (tMarket > 0) {\\r\\n            _sendToBusinees(tMarket, sender, recipient);\\r\\n        }\\r\\n        if (tBurn > 0) {\\r\\n            _sendToBurn(tBurn, sender);\\r\\n        }\\r\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _excludedToTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 rTransferAmount) private {\\r\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;  \\r\\n    }\\r\\n\\r\\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) = _getValues(tAmount);\\r\\n        uint256 rBurn =  tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;    \\r\\n        _bothTransferContent(sender, recipient, tAmount, rAmount, tTransferAmount, rTransferAmount);  \\r\\n        if (tMarket > 0) {\\r\\n            _sendToBusinees(tMarket, sender, recipient);\\r\\n        }\\r\\n        if (tBurn > 0) {\\r\\n            _sendToBurn(tBurn, sender);\\r\\n        }\\r\\n        _reflectFee(rFee, rBurn, rMarket, tFee, tBurn, tMarket);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _bothTransferContent(address sender, address recipient, uint256 tAmount, uint256 rAmount, uint256 tTransferAmount, uint256 rTransferAmount) private {\\r\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\r\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\r\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\r\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;  \\r\\n    }\\r\\n\\r\\n    function _reflectFee(uint256 rFee, uint256 rBurn, uint256 rMarket, uint256 tFee, uint256 tBurn, uint256 tMarket) private {\\r\\n        _rTotal = _rTotal - rFee - rBurn - rMarket;\\r\\n        _tFeeTotal = _tFeeTotal + tFee;\\r\\n        _tBurnTotal = _tBurnTotal + tBurn;\\r\\n        _tMarketingFeeTotal = _tMarketingFeeTotal + tMarket;\\r\\n    }\\r\\n\\r\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\r\\n        (uint256 tFee, uint256 tBurn, uint256 tMarket) = _getTBasics(tAmount, _TAX_FEE, _BURN_FEE, _MARKET_FEE);\\r\\n        uint256 tTransferAmount = getTTransferAmount(tAmount, tFee, tBurn, tMarket);\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rFee) = _getRBasics(tAmount, tFee, currentRate);\\r\\n        uint256 rTransferAmount = _getRTransferAmount(rAmount, rFee, tBurn, tMarket, currentRate);\\r\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tBurn, tMarket);\\r\\n    }\\r\\n\\r\\n    function _getValuesForSale(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\r\\n        (uint256 tFee, uint256 tBurn, uint256 tMarket) = _getTBasics(tAmount, _TAX_FEE, _BURN_FEE, _MARKET_FEE);\\r\\n        uint256 tTransferAmountForSale = getTTransferAmountForSale(tAmount, tFee, tBurn, tMarket);\\r\\n        uint256 currentRate =  _getRate();\\r\\n        (uint256 rAmount, uint256 rFee) = _getRBasics(tAmount, tFee, currentRate);\\r\\n        uint256 rTransferAmountForSale = _getRTransferAmountForSale(rAmount, rFee, tBurn, tMarket, currentRate);\\r\\n        return (rAmount, rTransferAmountForSale, rFee, tTransferAmountForSale, tFee, tBurn, tMarket);\\r\\n    }\\r\\n    \\r\\n    function _getTBasics(uint256 tAmount, uint256 taxFee, uint256 burnFee, uint256 marketFee) private pure returns (uint256, uint256, uint256) {\\r\\n        uint256 tFee = (tAmount * taxFee) / _GRANULARITY / 100;\\r\\n        uint256 tBurn = (tAmount * burnFee) / _GRANULARITY / 100;\\r\\n        uint256 tMarket = (tAmount * marketFee) / _GRANULARITY / 100;\\r\\n        return (tFee, tBurn, tMarket);\\r\\n    }\\r\\n    \\r\\n    function getTTransferAmount(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) private pure returns (uint256) {\\r\\n        return tAmount - tFee - tBurn - tMarket;\\r\\n    }\\r\\n    function getTTransferAmountForSale(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 tMarket) private pure returns (uint256) {\\r\\n        return tAmount + tFee + tBurn + tMarket;\\r\\n    }\\r\\n    \\r\\n    function _getRBasics(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256) {\\r\\n        uint256 rAmount = tAmount * currentRate;\\r\\n        uint256 rFee = tFee * currentRate;\\r\\n        return (rAmount, rFee);\\r\\n    }\\r\\n    \\r\\n    function _getRTransferAmount(uint256 rAmount, uint256 rFee, uint256 tBurn, uint256 tMarket, uint256 currentRate) private pure returns (uint256) {\\r\\n        uint256 rBurn = tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;\\r\\n        uint256 rTransferAmount = rAmount - rFee - rBurn - rMarket;\\r\\n        return rTransferAmount;\\r\\n    }\\r\\n\\r\\n    function _getRTransferAmountForSale(uint256 rAmount, uint256 rFee, uint256 tBurn, uint256 tMarket, uint256 currentRate) private pure returns (uint256) {\\r\\n        uint256 rBurn = tBurn * currentRate;\\r\\n        uint256 rMarket = tMarket * currentRate;\\r\\n        uint256 rTransferAmountForSale = rAmount + rFee + rBurn + rMarket;\\r\\n        return rTransferAmountForSale;\\r\\n    }\\r\\n\\r\\n    function _getRate() private view returns(uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply / tSupply;\\r\\n    }\\r\\n\\r\\n    function _getCurrentSupply() private view returns(uint256, uint256) {\\r\\n        uint256 rSupply = _rTotal;\\r\\n        uint256 tSupply = _tTotal;      \\r\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\r\\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\\r\\n            rSupply = rSupply - _rOwned[_excluded[i]];\\r\\n            tSupply = tSupply - _tOwned[_excluded[i]];\\r\\n        }\\r\\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n\\r\\n    function _sendToBusinees(uint256 tMarket, address sender, address recipient) private {\\r\\n        uint256 currentRate = _getRate();\\r\\n        uint256 rMarket = tMarket * currentRate;\\r\\n        if(sender == _pair && _referralOwner[recipient] != address(0)) {\\r\\n            _sendToReferralOwner(tMarket, rMarket, _referralOwner[recipient]);\\r\\n            emit Transfer(sender,  _referralOwner[recipient], tMarket);\\r\\n        }\\r\\n        else {\\r\\n            _rOwned[_shoppingCart] = _rOwned[_shoppingCart] + rMarket;\\r\\n            _tOwned[_shoppingCart] = _tOwned[_shoppingCart] + tMarket;\\r\\n            emit Transfer(sender, _shoppingCart, tMarket);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sendToBurn(uint256 tBurn, address sender) private {\\r\\n        uint256 currentRate = _getRate();\\r\\n        uint256 rBurn = tBurn * currentRate;\\r\\n        _rOwned[_rewardWallet] = _rOwned[_rewardWallet] + rBurn;\\r\\n        _tOwned[_rewardWallet] = _tOwned[_rewardWallet] + rBurn;\\r\\n        emit Transfer(sender, _rewardWallet, tBurn);\\r\\n    }\\r\\n\\r\\n    function _sendToReferralOwner(uint256 tMarket, uint256 rMarket, address owner) private {\\r\\n        if(_isExcluded[owner]) {\\r\\n            _rOwned[owner] = _rOwned[owner] + rMarket;\\r\\n            _tOwned[owner] = _tOwned[owner] + tMarket;\\r\\n        }\\r\\n        else {\\r\\n            _rOwned[owner] = _rOwned[owner] + rMarket;\\r\\n        }\\r\\n        _referralOwnerTotalFee[owner] += tMarket;\\r\\n    }\\r\\n\\r\\n    function _removeFee() private {\\r\\n        if(_TAX_FEE == 0 && _BURN_FEE == 0 && _MARKET_FEE == 0) return;\\r\\n        _TAX_FEE = 0;\\r\\n        _BURN_FEE = 0;\\r\\n        _MARKET_FEE = 0;\\r\\n    }\\r\\n\\r\\n    function _restoreAllFee() private {\\r\\n        _TAX_FEE = _standardFees.taxFee * 100;\\r\\n        _BURN_FEE = _standardFees.rewardFee * 100;\\r\\n        _MARKET_FEE = _standardFees.marketFee * 100;\\r\\n    }\\r\\n\\r\\n    function _setPenaltyFee() private {\\r\\n        _TAX_FEE = _standardFees.taxPenaltyFee * 100;\\r\\n        _BURN_FEE = _standardFees.rewardPenaltyFee * 100;\\r\\n        _MARKET_FEE = _standardFees.marketPenaltyFee * 100;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport './IUniswapV2Router01.sol';\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/TimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nabstract contract TimeLock {\\r\\n    struct LockedAddress {\\r\\n        uint64 lockedPeriod;\\r\\n        uint64 endTime;\\r\\n    }\\r\\n\\r\\n    \\r\\n    mapping(address => LockedAddress) private _lockedList;\\r\\n    mapping (address => bool) private _isExlcludeFromLock;\\r\\n    constructor () { }\\r\\n    function lockAddress(address _lockAddress, uint64 lockTime) internal virtual {\\r\\n        require(_lockAddress != address(0), \\\"ERR: zero lock address\\\");\\r\\n        require(lockTime > 0, \\\"ERR: zero lock period\\\");\\r\\n        if (!_isExlcludeFromLock[_lockAddress]) {\\r\\n            _lockedList[_lockAddress].lockedPeriod = lockTime;\\r\\n            _lockedList[_lockAddress].endTime = uint64(block.timestamp) + lockTime;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isUnLocked(address _lockAddress) internal view virtual returns (bool) {\\r\\n        require(_lockAddress != address(0), \\\"ERR: zero lock address\\\");\\r\\n        if (_isExlcludeFromLock[_lockAddress]) return true;\\r\\n        return _lockedList[_lockAddress].endTime < uint64(block.timestamp);\\r\\n    }\\r\\n\\r\\n    function excludeFromLock(address _lockAddress) internal virtual {\\r\\n        require(_lockAddress != address(0), \\\"ERR: zero lock address\\\");\\r\\n        if (_isExlcludeFromLock[_lockAddress]) return;\\r\\n        _isExlcludeFromLock[_lockAddress] = true;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"blackList\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_BURN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MARKET_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blackAddress\",\"type\":\"address\"}],\"name\":\"addBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"basisOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkAllowedTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralUser\",\"type\":\"address\"}],\"name\":\"checkReferralOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralOwner\",\"type\":\"address\"}],\"name\":\"checkReferralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkedTimeLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cooldownOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfficialBuffDoge.Minting[]\",\"name\":\"mintings\",\"type\":\"tuple[]\"}],\"name\":\"mintDev\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedNotEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"removeAddress\",\"type\":\"address\"}],\"name\":\"removeBlackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"businessAddress\",\"type\":\"address\"}],\"name\":\"setBusinessWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralUser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referralOwner\",\"type\":\"address\"}],\"name\":\"setReferralOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"}],\"name\":\"setRewardAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxPenaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPenaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketPenaltyFee\",\"type\":\"uint256\"}],\"internalType\":\"struct OfficialBuffDoge.StandardFees\",\"name\":\"_standardFee\",\"type\":\"tuple\"}],\"name\":\"setStandardFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"}],\"name\":\"setTokenExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokenForEthDisable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokenForEthEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMarketingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OfficialBuffDoge","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000114f6666696369616c2042756666446f6765000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000524427566660000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000f3207c360a7cbeb6e359e79c3f690f1730897a19000000000000000000000000aae55e8342ecbbecf836483ad54b90a32475065d0000000000000000000000008a8eff48fbd6886ff67170bd893264f338c2c5dd000000000000000000000000c505f97fea928d0820cee103eb4f9ed6e617f7a7","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}