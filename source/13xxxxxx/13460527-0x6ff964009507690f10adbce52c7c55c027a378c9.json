{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BreedingProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Upgradeable.sol\\\";\\n\\n/// @title Upgradable Registry Contract\\ncontract BreedingProxy is Upgradeable {\\n    /// @notice Contract constructor\\n    /// @dev Calls Upgradable contract constructor and sets contract name\\n    constructor() {}\\n    \\n    receive() external payable {}\\n    \\n    /// @notice Performs a delegatecall to the implementation contract.\\n    /// @dev Fallback function allows to perform a delegatecall to the given implementation.\\n    /// This function will return whatever the implementation call returns.\\n    fallback() external payable {\\n        require(msg.data.length > 0, \\\"Calldata must not be empty\\\");\\n        address _impl = getImplementation();\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize())\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Upgradeable contract\\ncontract Upgradeable is Ownable {\\n    /// @notice Storage position of the current implementation address.\\n    /// @dev The address of the current implementation is stored in a\\n    /// constant pseudorandom slot of the contract proxy contract storage\\n    /// (slot number obtained as a result of hashing a certain message),\\n    /// the probability of rewriting which is almost zero\\n    bytes32 private constant implementationPosition = keccak256(\\n        \\\"implementation\\\"\\n    );\\n\\n    /// @notice Contract constructor\\n    /// @dev Calls Ownable contract constructor\\n    constructor() {}\\n\\n    /// @notice Returns the current implementation contract address\\n    function getImplementation() public view returns (address implementation) {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            implementation := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new implementation contract address as current\\n    /// @param _newImplementation New implementation contract address\\n    function setImplementation(address _newImplementation) public onlyOwner {\\n        require(_newImplementation != address(0), \\\"New implementation must have non-zero address\\\");\\n        address currentImplementation = getImplementation();\\n        require(currentImplementation != _newImplementation, \\\"New implementation must have new address\\\");\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            sstore(position, _newImplementation)\\n        }\\n    }\\n\\n    /// @notice Sets new implementation contract address and call its initializer.\\n    /// @dev New implementation call is a low level delegatecall.\\n    /// @param _newImplementation the new implementation address.\\n    /// @param _newImplementaionCallData represents the msg.data to bet sent through the low level delegatecall.\\n    /// This parameter may include the initializer function signature with the needed payload.\\n    function setImplementationAndCall(\\n        address _newImplementation,\\n        bytes calldata _newImplementaionCallData\\n    ) external payable {\\n        setImplementation(_newImplementation);\\n        if (_newImplementaionCallData.length > 0) {\\n            (bool success, ) = address(this).call{value: msg.value}(\\n                _newImplementaionCallData\\n            );\\n            require(success, \\\"Delegatecall has failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_newImplementaionCallData\",\"type\":\"bytes\"}],\"name\":\"setImplementationAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BreedingProxy","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"1","Implementation":"0xe4f4a988eab2df5d82ad1ed38e9901e4c0b62625","SwarmSource":""}]}