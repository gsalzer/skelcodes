{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/council/vaults/VestingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../libraries/History.sol\\\";\\nimport \\\"../libraries/VestingVaultStorage.sol\\\";\\nimport \\\"../libraries/Storage.sol\\\";\\nimport \\\"../interfaces/IVotingVault.sol\\\";\\n\\ncontract VestingVault is IVotingVault {\\n    // Bring our libraries into scope\\n    using History for *;\\n    using VestingVaultStorage for *;\\n    using Storage for *;\\n\\n    // NOTE: There is no emergency withdrawal, any funds not sent via deposit() are\\n    // unrecoverable by this version of the VestingVault\\n\\n    // This contract has a privileged grant manager who can add grants or remove grants\\n    // It will not transfer in on each grant but rather check for solvency via state variables.\\n\\n    // Immutables are in bytecode so don't need special storage treatment\\n    IERC20 public immutable token;\\n\\n    // A constant which is how far back stale blocks are\\n    uint256 public immutable staleBlockLag;\\n\\n    event VoteChange(address indexed to, address indexed from, int256 amount);\\n\\n    /// @notice Constructs the contract.\\n    /// @param _token The erc20 token to grant.\\n    /// @param _stale Stale block used for voting power calculations.\\n    constructor(IERC20 _token, uint256 _stale) {\\n        token = _token;\\n        staleBlockLag = _stale;\\n    }\\n\\n    /// @notice initialization function to set initial variables.\\n    /// @dev Can only be called once after deployment.\\n    /// @param manager_ The vault manager can add and remove grants.\\n    /// @param timelock_ The timelock address can change the unvested multiplier.\\n    function initialize(address manager_, address timelock_) public {\\n        require(Storage.uint256Ptr(\\\"initialized\\\").data == 0, \\\"initialized\\\");\\n        Storage.set(Storage.uint256Ptr(\\\"initialized\\\"), 1);\\n        Storage.set(Storage.addressPtr(\\\"manager\\\"), manager_);\\n        Storage.set(Storage.addressPtr(\\\"timelock\\\"), timelock_);\\n        Storage.set(Storage.uint256Ptr(\\\"unvestedMultiplier\\\"), 100);\\n    }\\n\\n    // deposits mapping(address => Grant)\\n    /// @notice A single function endpoint for loading grant storage\\n    /// @dev Only one Grant is allowed per address. Grants SHOULD NOT\\n    /// be modified.\\n    /// @return returns a storage mapping which can be used to look up grant data\\n    function _grants()\\n        internal\\n        pure\\n        returns (mapping(address => VestingVaultStorage.Grant) storage)\\n    {\\n        // This call returns a storage mapping with a unique non overwrite-able storage location\\n        // which can be persisted through upgrades, even if they change storage layout\\n        return (VestingVaultStorage.mappingAddressToGrantPtr(\\\"grants\\\"));\\n    }\\n\\n    /// @notice A single function endpoint for loading the starting\\n    /// point of the range for each accepted grant\\n    /// @dev This is modified any time a grant is accepted\\n    /// @return returns the starting point uint\\n    function _loadBound() internal pure returns (Storage.Uint256 memory) {\\n        // This call returns a storage mapping with a unique non overwrite-able storage location\\n        // which can be persisted through upgrades, even if they change storage layout\\n        return Storage.uint256Ptr(\\\"bound\\\");\\n    }\\n\\n    /// @notice A function to access the storage of the unassigned token value\\n    /// @dev The unassigned tokens are not part of any grant and ca be used\\n    /// for a future grant or withdrawn by the manager.\\n    /// @return A struct containing the unassigned uint.\\n    function _unassigned() internal pure returns (Storage.Uint256 storage) {\\n        return Storage.uint256Ptr(\\\"unassigned\\\");\\n    }\\n\\n    /// @notice A function to access the storage of the manager address.\\n    /// @dev The manager can access all functions with the onlyManager modifier.\\n    /// @return A struct containing the manager address.\\n    function _manager() internal pure returns (Storage.Address memory) {\\n        return Storage.addressPtr(\\\"manager\\\");\\n    }\\n\\n    /// @notice A function to access the storage of the timelock address\\n    /// @dev The timelock can access all functions with the onlyTimelock modifier.\\n    /// @return A struct containing the timelock address.\\n    function _timelock() internal pure returns (Storage.Address memory) {\\n        return Storage.addressPtr(\\\"timelock\\\");\\n    }\\n\\n    /// @notice A function to access the storage of the unvestedMultiplier value\\n    /// @dev The unvested multiplier is a number that represents the voting power of each\\n    /// unvested token as a percentage of a vested token. For example if\\n    /// unvested tokens have 50% voting power compared to vested ones, this value would be 50.\\n    /// This can be changed by governance in the future.\\n    /// @return A struct containing the unvestedMultiplier uint.\\n    function _unvestedMultiplier()\\n        internal\\n        pure\\n        returns (Storage.Uint256 memory)\\n    {\\n        return Storage.uint256Ptr(\\\"unvestedMultiplier\\\");\\n    }\\n\\n    modifier onlyManager() {\\n        require(msg.sender == _manager().data, \\\"!manager\\\");\\n        _;\\n    }\\n\\n    modifier onlyTimelock() {\\n        require(msg.sender == _timelock().data, \\\"!timelock\\\");\\n        _;\\n    }\\n\\n    /// @notice Getter for the grants mapping\\n    /// @param _who The owner of the grant to query\\n    /// @return Grant of the provided address\\n    function getGrant(address _who)\\n        external\\n        view\\n        returns (VestingVaultStorage.Grant memory)\\n    {\\n        return _grants()[_who];\\n    }\\n\\n    /// @notice Accepts a grant\\n    /// @dev Sends token from the contract to the sender and back to the contract\\n    /// while assigning a numerical range to the unwithdrawn granted tokens.\\n    function acceptGrant() public {\\n        // load the grant\\n        VestingVaultStorage.Grant storage grant = _grants()[msg.sender];\\n        uint256 availableTokens = grant.allocation - grant.withdrawn;\\n\\n        // check that grant has unwithdrawn tokens\\n        require(availableTokens > 0, \\\"no grant available\\\");\\n\\n        // transfer the token to the user\\n        token.transfer(msg.sender, availableTokens);\\n        // transfer from the user back to the contract\\n        token.transferFrom(msg.sender, address(this), availableTokens);\\n\\n        uint256 bound = _loadBound().data;\\n        grant.range = [bound, bound + availableTokens];\\n        Storage.set(Storage.uint256Ptr(\\\"bound\\\"), bound + availableTokens);\\n    }\\n\\n    /// @notice Adds a new grant.\\n    /// @dev Manager can set who the voting power will be delegated to initially.\\n    /// This potentially avoids the need for a delegation transaction by the grant recipient.\\n    /// @param _who The Grant recipient.\\n    /// @param _amount The total grant value.\\n    /// @param _startTime Optionally set a non standard start time. If set to zero then the start time\\n    ///                   will be made the block this is executed in.\\n    /// @param _expiration timestamp when the grant ends (all tokens count as unlocked).\\n    /// @param _cliff Timestamp when the cliff ends. No tokens are unlocked until this\\n    /// timestamp is reached.\\n    /// @param _delegatee Optional param. The address to delegate the voting power\\n    /// associated with this grant to\\n    function addGrantAndDelegate(\\n        address _who,\\n        uint128 _amount,\\n        uint128 _startTime,\\n        uint128 _expiration,\\n        uint128 _cliff,\\n        address _delegatee\\n    ) public onlyManager {\\n        // Consistency check\\n        require(\\n            _cliff <= _expiration && _startTime <= _expiration,\\n            \\\"Invalid configuration\\\"\\n        );\\n        // If no custom start time is needed we use this block.\\n        if (_startTime == 0) {\\n            _startTime = uint128(block.number);\\n        }\\n\\n        Storage.Uint256 storage unassigned = _unassigned();\\n        Storage.Uint256 memory unvestedMultiplier = _unvestedMultiplier();\\n\\n        require(unassigned.data >= _amount, \\\"Insufficient balance\\\");\\n        // load the grant.\\n        VestingVaultStorage.Grant storage grant = _grants()[_who];\\n\\n        // If this address already has a grant, a different address must be provided\\n        // topping up or editing active grants is not supported.\\n        require(grant.allocation == 0, \\\"Has Grant\\\");\\n\\n        // load the delegate. Defaults to the grant owner\\n        _delegatee = _delegatee == address(0) ? _who : _delegatee;\\n\\n        // calculate the voting power. Assumes all voting power is initially locked.\\n        // Come back to this assumption.\\n        uint128 newVotingPower =\\n            (_amount * uint128(unvestedMultiplier.data)) / 100;\\n\\n        // set the new grant\\n        _grants()[_who] = VestingVaultStorage.Grant(\\n            _amount,\\n            0,\\n            _startTime,\\n            _expiration,\\n            _cliff,\\n            newVotingPower,\\n            _delegatee,\\n            [uint256(0), uint256(0)]\\n        );\\n\\n        // update the amount of unassigned tokens\\n        unassigned.data -= _amount;\\n\\n        // update the delegatee's voting power\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        uint256 delegateeVotes = votingPower.loadTop(grant.delegatee);\\n        votingPower.push(grant.delegatee, delegateeVotes + newVotingPower);\\n\\n        emit VoteChange(grant.delegatee, _who, int256(uint256(newVotingPower)));\\n    }\\n\\n    /// @notice Removes a grant.\\n    /// @dev The manager has the power to remove a grant at any time. Any withdrawable tokens will be\\n    /// sent to the grant owner.\\n    /// @param _who The Grant owner.\\n    function removeGrant(address _who) public onlyManager {\\n        // load the grant\\n        VestingVaultStorage.Grant storage grant = _grants()[_who];\\n        // get the amount of withdrawable tokens\\n        uint256 withdrawable = _getWithdrawableAmount(grant);\\n        // it is simpler to just transfer withdrawable tokens instead of modifying the struct storage\\n        // to allow withdrawal through claim()\\n        token.transfer(_who, withdrawable);\\n\\n        Storage.Uint256 storage unassigned = _unassigned();\\n        uint256 locked = grant.allocation - (grant.withdrawn + withdrawable);\\n\\n        // return the unused tokens so they can be used for a different grant\\n        unassigned.data += locked;\\n\\n        // update the delegatee's voting power\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        uint256 delegateeVotes = votingPower.loadTop(grant.delegatee);\\n        votingPower.push(\\n            grant.delegatee,\\n            delegateeVotes - grant.latestVotingPower\\n        );\\n\\n        // Emit the vote change event\\n        emit VoteChange(\\n            grant.delegatee,\\n            _who,\\n            -1 * int256(uint256(grant.latestVotingPower))\\n        );\\n\\n        // delete the grant\\n        delete _grants()[_who];\\n    }\\n\\n    /// @notice Claim all withdrawable value from a grant.\\n    /// @dev claiming value resets the voting power, This could either increase or reduce the\\n    /// total voting power associated with the caller's grant.\\n    function claim() public {\\n        // load the grant\\n        VestingVaultStorage.Grant storage grant = _grants()[msg.sender];\\n        // get the withdrawable amount\\n        uint256 withdrawable = _getWithdrawableAmount(grant);\\n\\n        // transfer the available amount\\n        token.transfer(msg.sender, withdrawable);\\n        grant.withdrawn += uint128(withdrawable);\\n\\n        // only move range bound if grant was accepted\\n        if (grant.range[1] > 0) {\\n            grant.range[1] -= withdrawable;\\n        }\\n\\n        // update the user's voting power\\n        _syncVotingPower(msg.sender, grant);\\n    }\\n\\n    /// @notice Changes the caller's token grant voting power delegation.\\n    /// @dev The total voting power is not guaranteed to go up because\\n    /// the unvested token multiplier can be updated at any time.\\n    /// @param _to the address to delegate to\\n    function delegate(address _to) public {\\n        VestingVaultStorage.Grant storage grant = _grants()[msg.sender];\\n        // If the delegation has already happened we don't want the tx to send\\n        require(_to != grant.delegatee, \\\"Already delegated\\\");\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n\\n        uint256 oldDelegateeVotes = votingPower.loadTop(grant.delegatee);\\n        uint256 newVotingPower = _currentVotingPower(grant);\\n\\n        // Remove old delegatee's voting power and emit event\\n        votingPower.push(\\n            grant.delegatee,\\n            oldDelegateeVotes - grant.latestVotingPower\\n        );\\n        emit VoteChange(\\n            grant.delegatee,\\n            msg.sender,\\n            -1 * int256(uint256(grant.latestVotingPower))\\n        );\\n\\n        // Note - It is important that this is loaded here and not before the previous state change because if\\n        // _to == grant.delegatee and re-delegation was allowed we could be working with out of date state.\\n        uint256 newDelegateeVotes = votingPower.loadTop(_to);\\n\\n        // add voting power to the target delegatee and emit event\\n        emit VoteChange(_to, msg.sender, int256(newVotingPower));\\n        votingPower.push(_to, newDelegateeVotes + newVotingPower);\\n\\n        // update grant info\\n        grant.latestVotingPower = uint128(newVotingPower);\\n        grant.delegatee = _to;\\n    }\\n\\n    /// @notice Manager-only token deposit function.\\n    /// @dev Deposited tokens are added to `_unassigned` and can be used to create grants.\\n    /// WARNING: This is the only way to deposit tokens into the contract. Any tokens sent\\n    /// via other means are not recoverable by this contract.\\n    /// @param _amount The amount of tokens to deposit.\\n    function deposit(uint256 _amount) public onlyManager {\\n        Storage.Uint256 storage unassigned = _unassigned();\\n        // update unassigned value\\n        unassigned.data += _amount;\\n        token.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    /// @notice Manager-only token withdrawal function.\\n    /// @dev The manager can withdraw tokens that are not being used by a grant.\\n    /// This function cannot be used to recover tokens that were sent to this contract\\n    /// by any means other than `deposit()`\\n    /// @param _amount the amount to withdraw\\n    /// @param _recipient the address to withdraw to\\n    function withdraw(uint256 _amount, address _recipient) public onlyManager {\\n        Storage.Uint256 storage unassigned = _unassigned();\\n        require(unassigned.data >= _amount, \\\"Insufficient balance\\\");\\n        // update unassigned value\\n        unassigned.data -= _amount;\\n        token.transfer(_recipient, _amount);\\n    }\\n\\n    /// @notice Update a delegatee's voting power.\\n    /// @dev Voting power is only updated for this block onward.\\n    /// see `History` for more on how voting power is tracked and queried.\\n    /// Anybody can update a grant's voting power.\\n    /// @param _who the address who's voting power this function updates\\n    function updateVotingPower(address _who) public {\\n        VestingVaultStorage.Grant storage grant = _grants()[_who];\\n        _syncVotingPower(_who, grant);\\n    }\\n\\n    /// @notice Helper to update a delegatee's voting power.\\n    /// @param _who the address who's voting power we need to sync\\n    /// @param _grant the storage pointer to the grant of that user\\n    function _syncVotingPower(\\n        address _who,\\n        VestingVaultStorage.Grant storage _grant\\n    ) internal {\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n\\n        uint256 delegateeVotes = votingPower.loadTop(_grant.delegatee);\\n\\n        uint256 newVotingPower = _currentVotingPower(_grant);\\n        // get the change in voting power. Negative if the voting power is reduced\\n        int256 change =\\n            int256(newVotingPower) - int256(uint256(_grant.latestVotingPower));\\n        // do nothing if there is no change\\n        if (change == 0) return;\\n        if (change > 0) {\\n            votingPower.push(\\n                _grant.delegatee,\\n                delegateeVotes + uint256(change)\\n            );\\n        } else {\\n            // if the change is negative, we multiply by -1 to avoid underflow when casting\\n            votingPower.push(\\n                _grant.delegatee,\\n                delegateeVotes - uint256(change * -1)\\n            );\\n        }\\n        emit VoteChange(_grant.delegatee, _who, change);\\n        _grant.latestVotingPower = uint128(newVotingPower);\\n    }\\n\\n    /// @notice Attempts to load the voting power of a user\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    // @param calldata the extra calldata is unused in this contract\\n    /// @return the number of votes\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata\\n    ) external override returns (uint256) {\\n        // Get our reference to historical data\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Find the historical data and clear everything more than 'staleBlockLag' into the past\\n        return\\n            votingPower.findAndClear(\\n                user,\\n                blockNumber,\\n                block.number - staleBlockLag\\n            );\\n    }\\n\\n    /// @notice Loads the voting power of a user without changing state\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @return the number of votes\\n    function queryVotePowerView(address user, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        // Get our reference to historical data\\n        History.HistoricalBalances memory votingPower = _votingPower();\\n        // Find the historical data\\n        return votingPower.find(user, blockNumber);\\n    }\\n\\n    /// @notice Calculates how much a grantee can withdraw\\n    /// @param _grant the memory location of the loaded grant\\n    /// @return the amount which can be withdrawn\\n    function _getWithdrawableAmount(VestingVaultStorage.Grant memory _grant)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (block.number < _grant.cliff || block.number < _grant.created) {\\n            return 0;\\n        }\\n        if (block.number >= _grant.expiration) {\\n            return (_grant.allocation - _grant.withdrawn);\\n        }\\n        uint256 unlocked =\\n            (_grant.allocation * (block.number - _grant.created)) /\\n                (_grant.expiration - _grant.created);\\n        return (unlocked - _grant.withdrawn);\\n    }\\n\\n    /// @notice Returns the historical voting power tracker.\\n    /// @return A struct which can push to and find items in block indexed storage.\\n    function _votingPower()\\n        internal\\n        pure\\n        returns (History.HistoricalBalances memory)\\n    {\\n        // This call returns a storage mapping with a unique non overwrite-able storage location\\n        // which can be persisted through upgrades, even if they change storage layout.\\n        return (History.load(\\\"votingPower\\\"));\\n    }\\n\\n    /// @notice Helper that returns the current voting power of a grant\\n    /// @dev This is not always the recorded voting power since it uses the latest\\n    /// _unvestedMultiplier.\\n    /// @param _grant The grant to check for voting power.\\n    /// @return The current voting power of the grant.\\n    function _currentVotingPower(VestingVaultStorage.Grant memory _grant)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 withdrawable = _getWithdrawableAmount(_grant);\\n        uint256 locked = _grant.allocation - (withdrawable + _grant.withdrawn);\\n        return (withdrawable + (locked * _unvestedMultiplier().data) / 100);\\n    }\\n\\n    /// @notice timelock-only unvestedMultiplier update function.\\n    /// @dev Allows the timelock to update the unvestedMultiplier.\\n    /// @param _multiplier The new multiplier.\\n    function changeUnvestedMultiplier(uint256 _multiplier) public onlyTimelock {\\n        require(_multiplier <= 100, \\\"Above 100%\\\");\\n        Storage.set(Storage.uint256Ptr(\\\"unvestedMultiplier\\\"), _multiplier);\\n    }\\n\\n    /// @notice timelock-only timelock update function.\\n    /// @dev Allows the timelock to update the timelock address.\\n    /// @param timelock_ The new timelock.\\n    function setTimelock(address timelock_) public onlyTimelock {\\n        Storage.set(Storage.addressPtr(\\\"timelock\\\"), timelock_);\\n    }\\n\\n    /// @notice timelock-only manager update function.\\n    /// @dev Allows the timelock to update the manager address.\\n    /// @param manager_ The new manager.\\n    function setManager(address manager_) public onlyTimelock {\\n        Storage.set(Storage.addressPtr(\\\"manager\\\"), manager_);\\n    }\\n\\n    /// @notice A function to access the storage of the timelock address\\n    /// @dev The timelock can access all functions with the onlyTimelock modifier.\\n    /// @return The timelock address.\\n    function timelock() public pure returns (address) {\\n        return _timelock().data;\\n    }\\n\\n    /// @notice A function to access the storage of the unvested token vote power multiplier.\\n    /// @return The unvested token multiplier\\n    function unvestedMultiplier() external pure returns (uint256) {\\n        return _unvestedMultiplier().data;\\n    }\\n\\n    /// @notice A function to access the storage of the manager address.\\n    /// @dev The manager can access all functions with the olyManager modifier.\\n    /// @return The manager address.\\n    function manager() public pure returns (address) {\\n        return _manager().data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/History.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"./Storage.sol\\\";\\n\\n// This library is an assembly optimized storage library which is designed\\n// to track timestamp history in a struct which uses hash derived pointers.\\n// WARNING - Developers using it should not access the underlying storage\\n// directly since we break some assumptions of high level solidity. Please\\n// note this library also increases the risk profile of memory manipulation\\n// please be cautious in your usage of uninitialized memory structs and other\\n// anti patterns.\\nlibrary History {\\n    // The storage layout of the historical array looks like this\\n    // [(128 bit min index)(128 bit length)] [0][0] ... [(64 bit block num)(192 bit data)] .... [(64 bit block num)(192 bit data)]\\n    // We give the option to the invoker of the search function the ability to clear\\n    // stale storage. To find data we binary search for the block number we need\\n    // This library expects the blocknumber indexed data to be pushed in ascending block number\\n    // order and if data is pushed with the same blocknumber it only retains the most recent.\\n    // This ensures each blocknumber is unique and contains the most recent data at the end\\n    // of whatever block it indexes [as long as that block is not the current one].\\n\\n    // A struct which wraps a memory pointer to a string and the pointer to storage\\n    // derived from that name string by the storage library\\n    // WARNING - For security purposes never directly construct this object always use load\\n    struct HistoricalBalances {\\n        string name;\\n        // Note - We use bytes32 to reduce how easy this is to manipulate in high level sol\\n        bytes32 cachedPointer;\\n    }\\n\\n    /// @notice The method by which inheriting contracts init the HistoricalBalances struct\\n    /// @param name The name of the variable. Note - these are globals, any invocations of this\\n    ///             with the same name work on the same storage.\\n    /// @return The memory pointer to the wrapper of the storage pointer\\n    function load(string memory name)\\n        internal\\n        pure\\n        returns (HistoricalBalances memory)\\n    {\\n        mapping(address => uint256[]) storage storageData =\\n            Storage.mappingAddressToUnit256ArrayPtr(name);\\n        bytes32 pointer;\\n        assembly {\\n            pointer := storageData.slot\\n        }\\n        return HistoricalBalances(name, pointer);\\n    }\\n\\n    /// @notice An unsafe method of attaching the cached ptr in a historical balance memory objects\\n    /// @param pointer cached pointer to storage\\n    /// @return storageData A storage array mapping pointer\\n    /// @dev PLEASE DO NOT USE THIS METHOD WITHOUT SERIOUS REVIEW. IF AN EXTERNAL ACTOR CAN CALL THIS WITH\\n    //       ARBITRARY DATA THEY MAY BE ABLE TO OVERWRITE ANY STORAGE IN THE CONTRACT.\\n    function _getMapping(bytes32 pointer)\\n        private\\n        pure\\n        returns (mapping(address => uint256[]) storage storageData)\\n    {\\n        assembly {\\n            storageData.slot := pointer\\n        }\\n    }\\n\\n    /// @notice This function adds a block stamp indexed piece of data to a historical data array\\n    ///         To prevent duplicate entries if the top of the array has the same blocknumber\\n    ///         the value is updated instead\\n    /// @param wrapper The wrapper which hold the reference to the historical data storage pointer\\n    /// @param who The address which indexes the array we need to push to\\n    /// @param data The data to append, should be at most 192 bits and will revert if not\\n    function push(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 data\\n    ) internal {\\n        // Check preconditions\\n        // OoB = Out of Bounds, short for contract bytecode size reduction\\n        require(data <= type(uint192).max, \\\"OoB\\\");\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping =\\n            _getMapping(wrapper.cachedPointer);\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // We load the block number and then shift it to be in the top 64 bits\\n        uint256 blockNumber = block.number << 192;\\n        // We combine it with the data, because of our require this will have a clean\\n        // top 64 bits\\n        uint256 packedData = blockNumber | data;\\n        // Load the array length\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // On the first push we don't try to load\\n        uint256 loadedBlockNumber = 0;\\n        if (length != 0) {\\n            (loadedBlockNumber, ) = _loadAndUnpack(storageData, length - 1);\\n        }\\n        // The index we push to, note - we use this pattern to not branch the assembly\\n        uint256 index = length;\\n        // If the caller is changing data in the same block we change the entry for this block\\n        // instead of adding a new one. This ensures each block numb is unique in the array.\\n        if (loadedBlockNumber == block.number) {\\n            index = length - 1;\\n        }\\n        // We use assembly to write our data to the index\\n        assembly {\\n            // Stores packed data in the equivalent of storageData[length]\\n            sstore(\\n                add(\\n                    // The start of the data slots\\n                    add(storageData.slot, 1),\\n                    // index where we store\\n                    index\\n                ),\\n                packedData\\n            )\\n        }\\n        // Reset the boundaries if they changed\\n        if (loadedBlockNumber != block.number) {\\n            _setBounds(storageData, minIndex, length + 1);\\n        }\\n    }\\n\\n    /// @notice Loads the most recent timestamp of delegation power\\n    /// @param wrapper The memory struct which we want to search for historical data\\n    /// @param who The user who's balance we want to load\\n    /// @return the top slot of the array\\n    function loadTop(HistoricalBalances memory wrapper, address who)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // Load the storage pointer\\n        uint256[] storage userData = _getMapping(wrapper.cachedPointer)[who];\\n        // Load the length\\n        (, uint256 length) = _loadBounds(userData);\\n        // If it's zero no data has ever been pushed so we return zero\\n        if (length == 0) {\\n            return 0;\\n        }\\n        // Load the current top\\n        (, uint256 storedData) = _loadAndUnpack(userData, length - 1);\\n        // and return it\\n        return (storedData);\\n    }\\n\\n    /// @notice Finds the data stored with the highest block number which is less than or equal to a provided\\n    ///         blocknumber.\\n    /// @param wrapper The memory struct which we want to search for historical data\\n    /// @param who The address which indexes the array to be searched\\n    /// @param blocknumber The blocknumber we want to load the historical data of\\n    /// @return The loaded unpacked data at this point in time.\\n    function find(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 blocknumber\\n    ) internal view returns (uint256) {\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping =\\n            _getMapping(wrapper.cachedPointer);\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // Pre load the bounds\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // Search for the blocknumber\\n        (, uint256 loadedData) =\\n            _find(storageData, blocknumber, 0, minIndex, length);\\n        // In this function we don't have to change the stored length data\\n        return (loadedData);\\n    }\\n\\n    /// @notice Finds the data stored with the highest blocknumber which is less than or equal to a provided block number\\n    ///         Opportunistically clears any data older than staleBlock which is possible to clear.\\n    /// @param wrapper The memory struct which points to the storage we want to search\\n    /// @param who The address which indexes the historical data we want to search\\n    /// @param blocknumber The blocknumber we want to load the historical state of\\n    /// @param staleBlock A block number which we can [but are not obligated to] delete history older than\\n    /// @return The found data\\n    function findAndClear(\\n        HistoricalBalances memory wrapper,\\n        address who,\\n        uint256 blocknumber,\\n        uint256 staleBlock\\n    ) internal returns (uint256) {\\n        // Get the storage this is referencing\\n        mapping(address => uint256[]) storage storageMapping =\\n            _getMapping(wrapper.cachedPointer);\\n        // Get the array we need to push to\\n        uint256[] storage storageData = storageMapping[who];\\n        // Pre load the bounds\\n        (uint256 minIndex, uint256 length) = _loadBounds(storageData);\\n        // Search for the blocknumber\\n        (uint256 staleIndex, uint256 loadedData) =\\n            _find(storageData, blocknumber, staleBlock, minIndex, length);\\n        // We clear any data in the stale region\\n        // Note - Since find returns 0 if no stale data is found and we use > instead of >=\\n        //        this won't trigger if no stale data is found. Plus it won't trigger on minIndex == staleIndex\\n        //        == maxIndex and clear the whole array.\\n        if (staleIndex > minIndex) {\\n            // Delete the outdated stored info\\n            _clear(minIndex, staleIndex, storageData);\\n            // Reset the array info with stale index as the new minIndex\\n            _setBounds(storageData, staleIndex, length);\\n        }\\n        return (loadedData);\\n    }\\n\\n    /// @notice Searches for the data stored at the largest blocknumber index less than a provided parameter.\\n    ///         Allows specification of a expiration stamp and returns the greatest examined index which is\\n    ///         found to be older than that stamp.\\n    /// @param data The stored data\\n    /// @param blocknumber the blocknumber we want to load the historical data for.\\n    /// @param staleBlock The oldest block that we care about the data stored for, all previous data can be deleted\\n    /// @param startingMinIndex The smallest filled index in the array\\n    /// @param length the length of the array\\n    /// @return Returns the largest stale data index seen or 0 for no seen stale data and the stored data\\n    function _find(\\n        uint256[] storage data,\\n        uint256 blocknumber,\\n        uint256 staleBlock,\\n        uint256 startingMinIndex,\\n        uint256 length\\n    ) private view returns (uint256, uint256) {\\n        // We explicitly revert on the reading of memory which is uninitialized\\n        require(length != 0, \\\"uninitialized\\\");\\n        // Do some correctness checks\\n        require(staleBlock <= blocknumber);\\n        require(startingMinIndex < length);\\n        // Load the bounds of our binary search\\n        uint256 maxIndex = length - 1;\\n        uint256 minIndex = startingMinIndex;\\n        uint256 staleIndex = 0;\\n\\n        // We run a binary search on the block number fields in the array between\\n        // the minIndex and maxIndex. If we find indexes with blocknumber < staleBlock\\n        // we set staleIndex to them and return that data for an optional clearing step\\n        // in the calling function.\\n        while (minIndex != maxIndex) {\\n            // We use the ceil instead of the floor because this guarantees that\\n            // we pick the highest blocknumber less than or equal the requested one\\n            uint256 mid = (minIndex + maxIndex + 1) / 2;\\n            // Load and unpack the data in the midpoint index\\n            (uint256 pastBlock, uint256 loadedData) = _loadAndUnpack(data, mid);\\n\\n            //  If we've found the exact block we are looking for\\n            if (pastBlock == blocknumber) {\\n                // Then we just return the data\\n                return (staleIndex, loadedData);\\n\\n                // Otherwise if the loaded block is smaller than the block number\\n            } else if (pastBlock < blocknumber) {\\n                // Then we first check if this is possibly a stale block\\n                if (pastBlock < staleBlock) {\\n                    // If it is we mark it for clearing\\n                    staleIndex = mid;\\n                }\\n                // We then repeat the search logic on the indices greater than the midpoint\\n                minIndex = mid;\\n\\n                // In this case the pastBlock > blocknumber\\n            } else {\\n                // We then repeat the search on the indices below the midpoint\\n                maxIndex = mid - 1;\\n            }\\n        }\\n\\n        // We load at the final index of the search\\n        (uint256 _pastBlock, uint256 _loadedData) =\\n            _loadAndUnpack(data, minIndex);\\n        // This will only be hit if a user has misconfigured the stale index and then\\n        // tried to load father into the past than has been preserved\\n        require(_pastBlock <= blocknumber, \\\"Search Failure\\\");\\n        return (staleIndex, _loadedData);\\n    }\\n\\n    /// @notice Clears storage between two bounds in array\\n    /// @param oldMin The first index to set to zero\\n    /// @param newMin The new minimum filled index, ie clears to index < newMin\\n    /// @param data The storage array pointer\\n    function _clear(\\n        uint256 oldMin,\\n        uint256 newMin,\\n        uint256[] storage data\\n    ) private {\\n        // Correctness checks on this call\\n        require(oldMin <= newMin);\\n        // This function is private and trusted and should be only called by functions which ensure\\n        // that oldMin < newMin < length\\n        assembly {\\n            // The layout of arrays in solidity is [length][data]....[data] so this pointer is the\\n            // slot to write to data\\n            let dataLocation := add(data.slot, 1)\\n            // Loop through each index which is below new min and clear the storage\\n            // Note - Uses strict min so if given an input like oldMin = 5 newMin = 5 will be a no op\\n            for {\\n                let i := oldMin\\n            } lt(i, newMin) {\\n                i := add(i, 1)\\n            } {\\n                // store at the starting data pointer + i 256 bits of zero\\n                sstore(add(dataLocation, i), 0)\\n            }\\n        }\\n    }\\n\\n    /// @notice Loads and unpacks the block number index and stored data from a data array\\n    /// @param data the storage array\\n    /// @param i the index to load and unpack\\n    /// @return (block number, stored data)\\n    function _loadAndUnpack(uint256[] storage data, uint256 i)\\n        private\\n        view\\n        returns (uint256, uint256)\\n    {\\n        // This function is trusted and should only be called after checking data lengths\\n        // we use assembly for the sload to avoid reloading length.\\n        uint256 loaded;\\n        assembly {\\n            loaded := sload(add(add(data.slot, 1), i))\\n        }\\n        // Unpack the packed 64 bit block number and 192 bit data field\\n        return (\\n            loaded >> 192,\\n            loaded &\\n                0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff\\n        );\\n    }\\n\\n    /// @notice This function sets our non standard bounds data field where a normal array\\n    ///         would have length\\n    /// @param data the pointer to the storage array\\n    /// @param minIndex The minimum non stale index\\n    /// @param length The length of the storage array\\n    function _setBounds(\\n        uint256[] storage data,\\n        uint256 minIndex,\\n        uint256 length\\n    ) private {\\n        // Correctness check\\n        require(minIndex < length);\\n\\n        assembly {\\n            // Ensure data cleanliness\\n            let clearedLength := and(\\n                length,\\n                0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff\\n            )\\n            // We move the min index into the top 128 bits by shifting it left by 128 bits\\n            let minInd := shl(128, minIndex)\\n            // We pack the data using binary or\\n            let packed := or(minInd, clearedLength)\\n            // We store in the packed data in the length field of this storage array\\n            sstore(data.slot, packed)\\n        }\\n    }\\n\\n    /// @notice This function loads and unpacks our packed min index and length for our custom storage array\\n    /// @param data The pointer to the storage location\\n    /// @return minInd the first filled index in the array\\n    /// @return length the length of the array\\n    function _loadBounds(uint256[] storage data)\\n        private\\n        view\\n        returns (uint256 minInd, uint256 length)\\n    {\\n        // Use assembly to manually load the length storage field\\n        uint256 packedData;\\n        assembly {\\n            packedData := sload(data.slot)\\n        }\\n        // We use a shift right to clear out the low order bits of the data field\\n        minInd = packedData >> 128;\\n        // We use a binary and to extract only the bottom 128 bits\\n        length =\\n            packedData &\\n            0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/VestingVaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\n// Copy of `Storage` with modified scope to match the VestingVault requirements\\n// This library allows for secure storage pointers across proxy implementations\\n// It will return storage pointers based on a hashed name and type string.\\nlibrary VestingVaultStorage {\\n    // This library follows a pattern which if solidity had higher level\\n    // type or macro support would condense quite a bit.\\n\\n    // Each basic type which does not support storage locations is encoded as\\n    // a struct of the same name capitalized and has functions 'load' and 'set'\\n    // which load the data and set the data respectively.\\n\\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\\n    // which will return a storage version of the type with slot which is the hash of\\n    // the variable name and type string. This pointer allows easy state management between\\n    // upgrades and overrides the default solidity storage slot system.\\n\\n    // A struct which represents 1 packed storage location (Grant)\\n    struct Grant {\\n        uint128 allocation;\\n        uint128 withdrawn;\\n        uint128 created;\\n        uint128 expiration;\\n        uint128 cliff;\\n        uint128 latestVotingPower;\\n        address delegatee;\\n        uint256[2] range;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToGrantPtr(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => Grant) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => Grant)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\n// This library allows for secure storage pointers across proxy implementations\\n// It will return storage pointers based on a hashed name and type string.\\nlibrary Storage {\\n    // This library follows a pattern which if solidity had higher level\\n    // type or macro support would condense quite a bit.\\n\\n    // Each basic type which does not support storage locations is encoded as\\n    // a struct of the same name capitalized and has functions 'load' and 'set'\\n    // which load the data and set the data respectively.\\n\\n    // All types will have a function of the form 'typename'Ptr('name') -> storage ptr\\n    // which will return a storage version of the type with slot which is the hash of\\n    // the variable name and type string. This pointer allows easy state management between\\n    // upgrades and overrides the default solidity storage slot system.\\n\\n    /// @dev The address type container\\n    struct Address {\\n        address data;\\n    }\\n\\n    /// @notice A function which turns a variable name for a storage address into a storage\\n    ///         pointer for its container.\\n    /// @param name the variable name\\n    /// @return data the storage pointer\\n    function addressPtr(string memory name)\\n        internal\\n        pure\\n        returns (Address storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"address\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice A function to load an address from the container struct\\n    /// @param input the storage pointer for the container\\n    /// @return the loaded address\\n    function load(Address storage input) internal view returns (address) {\\n        return input.data;\\n    }\\n\\n    /// @notice A function to set the internal field of an address container\\n    /// @param input the storage pointer to the container\\n    /// @param to the address to set the container to\\n    function set(Address storage input, address to) internal {\\n        input.data = to;\\n    }\\n\\n    /// @dev The uint256 type container\\n    struct Uint256 {\\n        uint256 data;\\n    }\\n\\n    /// @notice A function which turns a variable name for a storage uint256 into a storage\\n    ///         pointer for its container.\\n    /// @param name the variable name\\n    /// @return data the storage pointer\\n    function uint256Ptr(string memory name)\\n        internal\\n        pure\\n        returns (Uint256 storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"uint256\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice A function to load an uint256 from the container struct\\n    /// @param input the storage pointer for the container\\n    /// @return the loaded uint256\\n    function load(Uint256 storage input) internal view returns (uint256) {\\n        return input.data;\\n    }\\n\\n    /// @notice A function to set the internal field of a unit256 container\\n    /// @param input the storage pointer to the container\\n    /// @param to the address to set the container to\\n    function set(Uint256 storage input, uint256 to) internal {\\n        input.data = to;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToUnit256Ptr(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => uint256) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => uint256)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToUnit256ArrayPtr(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => uint256[]) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => uint256[])\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n\\n    /// @notice Allows external users to calculate the slot given by this lib\\n    /// @param typeString the string which encodes the type\\n    /// @param name the variable name\\n    /// @return the slot assigned by this lib\\n    function getPtr(string memory typeString, string memory name)\\n        external\\n        pure\\n        returns (uint256)\\n    {\\n        bytes32 typehash = keccak256(abi.encodePacked(typeString));\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        return (uint256)(offset);\\n    }\\n\\n    // A struct which represents 1 packed storage location with a compressed\\n    // address and uint96 pair\\n    struct AddressUint {\\n        address who;\\n        uint96 amount;\\n    }\\n\\n    /// @notice Returns the storage pointer for a named mapping of address to uint256[]\\n    /// @param name the variable name for the pointer\\n    /// @return data the mapping pointer\\n    function mappingAddressToPackedAddressUint(string memory name)\\n        internal\\n        pure\\n        returns (mapping(address => AddressUint) storage data)\\n    {\\n        bytes32 typehash = keccak256(\\\"mapping(address => AddressUint)\\\");\\n        bytes32 offset = keccak256(abi.encodePacked(typehash, name));\\n        assembly {\\n            data.slot := offset\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/IVotingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IVotingVault {\\n    /// @notice Attempts to load the voting power of a user\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\\n    /// @return the number of votes\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata extraData\\n    ) external returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stale\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"VoteChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_startTime\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_expiration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_cliff\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"}],\"name\":\"addGrantAndDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"changeUnvestedMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"getGrant\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"allocation\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"created\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"expiration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"cliff\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"latestVotingPower\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"range\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct VestingVaultStorage.Grant\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"queryVotePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"queryVotePowerView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"removeGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staleBlockLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unvestedMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"updateVotingPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VestingVault","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000005c6d51ecba4d8e4f20373e3ce96a62342b125d6d0000000000000000000000000000000000000000000000000000000000030d40","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}