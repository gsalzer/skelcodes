{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ReflectionsMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Base64.sol\\\";\\n\\ninterface ICorruptionsMetadata {\\n    function tokenURI(uint256 tokenId, uint256 amount)\\n        external\\n        view\\n        returns (string memory);\\n}\\n\\ninterface ICorruptionsDataMapper {\\n    function valueFor(uint256 mapIndex, uint256 key)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\\ninterface ICorruptionsDeviationWriter {\\n    function drawCanvas(uint256 tokenId, uint256 amount)\\n        external\\n        pure\\n        returns (string[32] memory);\\n}\\n\\ninterface ICorruptionsFont {\\n    function font() external view returns (string memory);\\n}\\n\\nstruct DeviationInfo {\\n    string name;\\n    address contractAddress;\\n    uint256 extraData;\\n}\\n\\ninterface ICorruptionsDeviationRegistry {\\n    function valueFor(uint256 index)\\n        external\\n        view\\n        returns (DeviationInfo memory);\\n}\\n\\nstruct InsightMap {\\n    uint256 savedXP;\\n    uint256 lastSaveBlock;\\n}\\n\\ninterface ICorruptions {\\n    function insightMap(uint256 tokenID)\\n        external\\n        view\\n        returns (InsightMap memory);\\n}\\n\\ncontract ReflectionsMetadata is Ownable, ICorruptionsMetadata {\\n    string public description;\\n    ICorruptionsFont private font =\\n        ICorruptionsFont(0xdf8A48979F33f12952Ab4cF6f960EA4071fc656b);\\n    ICorruptionsDataMapper private dataMapper =\\n        ICorruptionsDataMapper(0x7A96d95a787524a27a4df36b64a96910a2fDCF5B);\\n    ICorruptionsDeviationRegistry private deviationRegistry =\\n        ICorruptionsDeviationRegistry(\\n            0x40f7ad19c7F37AcD76958d61Cbc783c77411cd9b\\n        );\\n    ICorruptions private corruptions =\\n        ICorruptions(0x5BDf397bB2912859Dbd8011F320a222f79A28d2E);\\n\\n    struct RandParts {\\n        string border;\\n        string corruptor;\\n        string phrase;\\n        string checker;\\n        bool omitInsight;\\n        uint16 reduction;\\n        bool alternate;\\n    }\\n\\n    constructor() Ownable() {\\n        description = \\\"Unknown\\\";\\n    }\\n\\n    function setDescription(string memory desc) public onlyOwner {\\n        description = desc;\\n    }\\n\\n    function setFont(address fontAddress) public onlyOwner {\\n        font = ICorruptionsFont(fontAddress);\\n    }\\n\\n    function _blank(string[32] memory canvas)\\n        public\\n        pure\\n        returns (string[32] memory)\\n    {\\n        for (uint8 i = 0; i < 32; i++) {\\n            canvas[\\n                i\\n            ] = \\\"&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;\\\";\\n        }\\n        return canvas;\\n    }\\n\\n    function _insert(\\n        bytes memory canvasLine,\\n        uint256 offset,\\n        bytes memory str,\\n        bool singleChar\\n    ) private pure {\\n        canvasLine[offset * 9 + 0] = str[0];\\n        if (singleChar) {\\n            canvasLine[offset * 9 + 1] = \\\"<\\\";\\n            canvasLine[offset * 9 + 2] = \\\"!\\\";\\n            canvasLine[offset * 9 + 3] = \\\"-\\\";\\n            canvasLine[offset * 9 + 4] = \\\"-\\\";\\n            canvasLine[offset * 9 + 5] = \\\" \\\";\\n            canvasLine[offset * 9 + 6] = \\\"-\\\";\\n            canvasLine[offset * 9 + 7] = \\\"-\\\";\\n            canvasLine[offset * 9 + 8] = \\\">\\\";\\n        } else {\\n            canvasLine[offset * 9 + 1] = str[1];\\n            canvasLine[offset * 9 + 2] = str[2];\\n            canvasLine[offset * 9 + 3] = str[3];\\n            canvasLine[offset * 9 + 4] = str[4];\\n            canvasLine[offset * 9 + 5] = str[5];\\n            canvasLine[offset * 9 + 6] = str[6];\\n            canvasLine[offset * 9 + 7] = str[7];\\n            canvasLine[offset * 9 + 8] = str[8];\\n        }\\n    }\\n\\n    function _box(\\n        string[32] memory canvas,\\n        string memory char,\\n        uint256 x,\\n        uint256 y,\\n        uint256 w,\\n        uint256 h,\\n        bool singleChar\\n    ) public pure returns (string[32] memory) {\\n        bytes memory str = bytes(char);\\n        for (uint256 iy = 0; iy < h; iy++) {\\n            bytes memory canvasLine = bytes(canvas[iy + y]);\\n            for (uint256 ix = 0; ix < w; ix++) {\\n                _insert(canvasLine, ix + x, str, singleChar);\\n            }\\n        }\\n        return canvas;\\n    }\\n\\n    function _checkeredBox(\\n        string[32] memory canvas,\\n        string memory char,\\n        string memory char2,\\n        uint256 x,\\n        uint256 y,\\n        uint256 w,\\n        uint256 h,\\n        bool singleChar\\n    ) public pure returns (string[32] memory) {\\n        bytes memory str = bytes(char);\\n        bytes memory str2 = bytes(char2);\\n        for (uint256 iy = 0; iy < h; iy++) {\\n            bytes memory canvasLine = bytes(canvas[iy + y]);\\n            for (uint256 ix = 0; ix < w; ix++) {\\n                _insert(\\n                    canvasLine,\\n                    ix + x,\\n                    ((iy + y) + (ix + x)) % 2 == 0 ? str : str2,\\n                    singleChar\\n                );\\n            }\\n        }\\n        return canvas;\\n    }\\n\\n    function _drawCircle(\\n        string[32] memory canvas,\\n        string memory char,\\n        uint256 xc,\\n        uint256 yc,\\n        uint256 x,\\n        uint256 y,\\n        bool singleChar\\n    ) public pure returns (string[32] memory) {\\n        bytes memory str = bytes(char);\\n\\n        _insert(bytes(canvas[yc + y]), xc + x, str, singleChar);\\n        _insert(bytes(canvas[yc + y]), xc - x, str, singleChar);\\n        _insert(bytes(canvas[yc - y]), xc + x, str, singleChar);\\n        _insert(bytes(canvas[yc - y]), xc - x, str, singleChar);\\n        _insert(bytes(canvas[yc + x]), xc + y, str, singleChar);\\n        _insert(bytes(canvas[yc + x]), xc - y, str, singleChar);\\n        _insert(bytes(canvas[yc - x]), xc + y, str, singleChar);\\n        _insert(bytes(canvas[yc - x]), xc - y, str, singleChar);\\n\\n        return canvas;\\n    }\\n\\n    function _circle(\\n        string[32] memory canvas,\\n        string memory char,\\n        uint256 xc,\\n        uint256 yc,\\n        int8 r,\\n        bool singleChar\\n    ) public pure returns (string[32] memory) {\\n        // https://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/\\n\\n        int256 x = 0;\\n        int256 y = int256(r);\\n        int256 d = 3 - 2 * r;\\n        canvas = _drawCircle(\\n            canvas,\\n            char,\\n            xc,\\n            yc,\\n            uint256(x),\\n            uint256(y),\\n            singleChar\\n        );\\n        while (y >= x) {\\n            x++;\\n\\n            if (d > 0) {\\n                y--;\\n                d = d + 4 * (x - y) + 10;\\n            } else {\\n                d = d + 4 * x + 6;\\n            }\\n            canvas = _drawCircle(\\n                canvas,\\n                char,\\n                xc,\\n                yc,\\n                uint256(x),\\n                uint256(y),\\n                singleChar\\n            );\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function _middleBox(\\n        string[32] memory canvas,\\n        string memory char,\\n        string memory char2,\\n        uint256 size,\\n        bool singleChar\\n    ) public pure returns (string[32] memory) {\\n        canvas = _checkeredBox(\\n            canvas,\\n            char,\\n            char2,\\n            15 - size,\\n            15 - size,\\n            size * 2 + 1,\\n            size * 2 + 1,\\n            singleChar\\n        );\\n        return canvas;\\n    }\\n\\n    function _text(\\n        string[32] memory canvas,\\n        string memory message,\\n        uint256 messageLength,\\n        uint256 x,\\n        uint256 y\\n    ) public pure returns (string[32] memory) {\\n        bytes memory canvasLine = bytes(canvas[y]);\\n        for (uint256 i = 0; i < messageLength; i++) {\\n            _insert(\\n                canvasLine,\\n                x + i,\\n                abi.encodePacked(bytes(message)[i]),\\n                true\\n            );\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function _richText(\\n        string[32] memory canvas,\\n        string memory message,\\n        uint256 messageLength,\\n        uint256 x,\\n        uint256 y\\n    ) public pure returns (string[32] memory) {\\n        bytes memory canvasLine = bytes(canvas[y]);\\n        for (uint256 i = 0; i < messageLength / 9; i++) {\\n            bytes memory sequence = abi.encodePacked(\\n                abi.encodePacked(\\n                    bytes(message)[i * 9],\\n                    bytes(message)[i * 9 + 1],\\n                    bytes(message)[i * 9 + 2],\\n                    bytes(message)[i * 9 + 3],\\n                    bytes(message)[i * 9 + 4],\\n                    bytes(message)[i * 9 + 5]\\n                ),\\n                bytes(message)[i * 9 + 6],\\n                bytes(message)[i * 9 + 7],\\n                bytes(message)[i * 9 + 8]\\n            );\\n            _insert(canvasLine, x + i, sequence, false);\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function draw(\\n        uint256 tokenId,\\n        uint256 amount,\\n        string[32] memory oCanvas\\n    ) public view returns (string memory) {\\n        string[31] memory lookup = [\\n            \\\"20\\\",\\n            \\\"31\\\",\\n            \\\"42\\\",\\n            \\\"53\\\",\\n            \\\"64\\\",\\n            \\\"75\\\",\\n            \\\"86\\\",\\n            \\\"97\\\",\\n            \\\"108\\\",\\n            \\\"119\\\",\\n            \\\"130\\\",\\n            \\\"141\\\",\\n            \\\"152\\\",\\n            \\\"163\\\",\\n            \\\"174\\\",\\n            \\\"185\\\",\\n            \\\"196\\\",\\n            \\\"207\\\",\\n            \\\"218\\\",\\n            \\\"229\\\",\\n            \\\"240\\\",\\n            \\\"251\\\",\\n            \\\"262\\\",\\n            \\\"273\\\",\\n            \\\"284\\\",\\n            \\\"295\\\",\\n            \\\"306\\\",\\n            \\\"317\\\",\\n            \\\"328\\\",\\n            \\\"339\\\",\\n            \\\"350\\\"\\n        ];\\n\\n        string[40] memory randomStrings = [\\n            \\\"/\\\",\\n            \\\"$\\\",\\n            \\\"|\\\",\\n            \\\"8\\\",\\n            \\\"_\\\",\\n            \\\"?\\\",\\n            \\\"#\\\",\\n            \\\"%\\\",\\n            \\\"^\\\",\\n            \\\"~\\\",\\n            \\\":\\\",\\n            \\\"#0D1302\\\",\\n            \\\"#020A13\\\",\\n            \\\"#130202\\\",\\n            \\\"#1A1616\\\",\\n            \\\"#000000\\\",\\n            \\\"#040A27\\\",\\n            \\\"#022FB7\\\",\\n            \\\"#262A36\\\",\\n            \\\"#A802B7\\\",\\n            \\\"#3CB702\\\",\\n            \\\"#B76F02\\\",\\n            \\\"#B70284\\\",\\n            \\\"BLOODLINES\\\",\\n            \\\"COLLECTIVE\\\",\\n            \\\"REFLECTION\\\",\\n            \\\"COMPLETION\\\",\\n            \\\"OMNIPOTENT\\\",\\n            \\\"DREAMWORLD\\\",\\n            \\\"REDEMPTION\\\",\\n            \\\"RESOLUTION\\\",\\n            \\\"ABSOLUTION\\\",\\n            \\\"LIBERATION\\\",\\n            \\\"|\\\",\\n            \\\"-\\\",\\n            \\\"=\\\",\\n            \\\"+\\\",\\n            \\\"\\\\\\\\\\\",\\n            \\\":\\\",\\n            \\\"~\\\"\\n        ];\\n\\n        RandParts memory randParts;\\n\\n        randParts.border = randomStrings[\\n            uint256(keccak256(abi.encodePacked(\\\"BORDER\\\", tokenId))) % 11\\n        ];\\n        randParts.corruptor = randomStrings[\\n            uint256(keccak256(abi.encodePacked(\\\"CORRUPTOR\\\", tokenId))) % 11\\n        ];\\n        randParts.phrase = randomStrings[\\n            23 + (uint256(keccak256(abi.encodePacked(\\\"PHRASE\\\", tokenId))) % 10)\\n        ];\\n        randParts.checker = randomStrings[\\n            33 + (uint256(keccak256(abi.encodePacked(\\\"CHECKER\\\", tokenId))) % 7)\\n        ];\\n\\n        string[32] memory canvas;\\n\\n        if (bytes(oCanvas[0]).length > 32) {\\n            canvas = _blank(canvas);\\n\\n            randParts.omitInsight = true;\\n            randParts.reduction = 64 + uint8(bytes(oCanvas[0])[tokenId % 32]);\\n            randParts.alternate = true;\\n\\n            for (uint256 i = 0; i < 32; i++) {\\n                canvas = _richText(\\n                    canvas,\\n                    oCanvas[i],\\n                    bytes(oCanvas[i]).length,\\n                    0,\\n                    i\\n                );\\n            }\\n        } else if (bytes(oCanvas[0]).length > 0) {\\n            canvas = _blank(canvas);\\n\\n            randParts.omitInsight = true;\\n            randParts.reduction = 64;\\n\\n            for (uint256 i = 0; i < 32; i++) {\\n                canvas = _text(\\n                    canvas,\\n                    oCanvas[i],\\n                    bytes(oCanvas[i]).length,\\n                    0,\\n                    i\\n                );\\n            }\\n        } else {\\n            canvas = _blank(canvas);\\n\\n            canvas = _box(canvas, randParts.border, 0, 0, 31, 1, true);\\n            canvas = _box(canvas, randParts.border, 0, 30, 31, 1, true);\\n            canvas = _box(canvas, randParts.border, 0, 0, 1, 31, true);\\n            canvas = _box(canvas, randParts.border, 30, 0, 1, 31, true);\\n\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[0])),\\n                15,\\n                15,\\n                12,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[1])),\\n                15,\\n                15,\\n                11,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[2])),\\n                15,\\n                15,\\n                10,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[3])),\\n                15,\\n                15,\\n                9,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[4])),\\n                15,\\n                15,\\n                8,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[5])),\\n                15,\\n                15,\\n                7,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[6])),\\n                15,\\n                15,\\n                6,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[7])),\\n                15,\\n                15,\\n                5,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[8])),\\n                15,\\n                15,\\n                4,\\n                true\\n            );\\n            canvas = _circle(\\n                canvas,\\n                string(abi.encodePacked(bytes(randParts.phrase)[9])),\\n                15,\\n                15,\\n                3,\\n                true\\n            );\\n        }\\n\\n        uint256 iterations = uint256(\\n            keccak256(abi.encodePacked(\\\"CORRUPTION\\\", tokenId))\\n        ) % 1024;\\n        if (randParts.reduction > 0) {\\n            iterations = iterations % randParts.reduction;\\n        }\\n        for (uint256 i = 0; i < iterations; i++) {\\n            if (randParts.alternate && i % 2 == 0) {\\n                canvas = _box(\\n                    canvas,\\n                    randParts.border,\\n                    uint256(keccak256(abi.encodePacked(\\\"X\\\", i, tokenId))) % 30,\\n                    uint256(keccak256(abi.encodePacked(\\\"Y\\\", i, tokenId))) % 30,\\n                    1,\\n                    1,\\n                    true\\n                );\\n            } else {\\n                canvas = _box(\\n                    canvas,\\n                    randParts.corruptor,\\n                    uint256(keccak256(abi.encodePacked(\\\"X\\\", i, tokenId))) % 30,\\n                    uint256(keccak256(abi.encodePacked(\\\"Y\\\", i, tokenId))) % 30,\\n                    1,\\n                    1,\\n                    true\\n                );\\n            }\\n        }\\n\\n        if (!randParts.omitInsight) {\\n            uint256 length = 8 + bytes(toString(amount)).length;\\n            canvas = _text(\\n                canvas,\\n                string(abi.encodePacked(\\\"INSIGHT \\\", toString(amount))),\\n                length,\\n                31 - length,\\n                30\\n            );\\n\\n            for (uint256 i = 10; i > 0; i--) {\\n                if (amount >= i * 2) {\\n                    canvas = _middleBox(\\n                        canvas,\\n                        string(\\n                            abi.encodePacked(bytes(randParts.phrase)[i - 1])\\n                        ),\\n                        randParts.checker,\\n                        i,\\n                        true\\n                    );\\n                }\\n            }\\n        }\\n\\n        string memory output;\\n        for (uint8 i = 0; i < 31; i++) {\\n            output = string(\\n                abi.encodePacked(\\n                    output,\\n                    '<text x=\\\"10\\\" y=\\\"',\\n                    lookup[i],\\n                    '\\\" class=\\\"base\\\">',\\n                    canvas[i],\\n                    \\\"</text>\\\"\\n                )\\n            );\\n        }\\n\\n        string[12] memory parts;\\n        parts[\\n            0\\n        ] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 820 1460\\\" class=\\\"reflection\\\"><style>@font-face { font-family: CorruptionsFont; src: url(\\\"';\\n        parts[1] = font.font();\\n        parts[2] = '\\\") format(\\\"opentype\\\"); } .base { fill: ';\\n        parts[3] = randomStrings[\\n            11 + (uint256(keccak256(abi.encodePacked(\\\"BGCOLOR\\\", tokenId))) % 6)\\n        ];\\n        parts[\\n            4\\n        ] = '; font-family: CorruptionsFont; font-size: 10px; } .reflection g { -moz-transform: scale(-4, 4); -webkit-transform: scale(-4, 4); -o-transform: scale(-4, 4); -ms-transform: scale(-4, 4); transform: scale(-4, 4); }</style><g transform=\\\"scale(-4 4)\\\" transform-origin=\\\"164 0\\\"><rect width=\\\"205\\\" height=\\\"365\\\" fill=\\\"';\\n        parts[5] = amount >= 2\\n            ? randomStrings[\\n                17 +\\n                    (uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) %\\n                        6)\\n            ]\\n            : randomStrings[\\n                27 +\\n                    (uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) %\\n                        6)\\n            ];\\n        parts[6] = '\\\" />';\\n        parts[7] = output;\\n        parts[8] = \\\"\\\";\\n        parts[9] = \\\"\\\";\\n        parts[10] = \\\"\\\";\\n        parts[11] = \\\"</g></svg>\\\";\\n\\n        if (amount >= 2) {\\n            parts[8] = \\\"<!-- \\\";\\n            parts[9] = randomStrings[\\n                27 +\\n                    (uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) %\\n                        6)\\n            ];\\n            parts[10] = \\\" -->\\\";\\n        }\\n\\n        output = string(\\n            abi.encodePacked(\\n                parts[0],\\n                parts[1],\\n                parts[2],\\n                parts[3],\\n                parts[4],\\n                parts[5],\\n                parts[6]\\n            )\\n        );\\n        output = string(\\n            abi.encodePacked(\\n                output,\\n                parts[7],\\n                parts[8],\\n                parts[9],\\n                parts[10],\\n                parts[11]\\n            )\\n        );\\n        return Base64.encode(bytes(output));\\n    }\\n\\n    function tokenURI(uint256 tokenId, uint256 amount)\\n        external\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        InsightMap memory insightMap = corruptions.insightMap(tokenId);\\n        if (insightMap.lastSaveBlock <= 13604851 && tokenId != 3193) {\\n            amount += 1; // fix early transfer bug\\n        }\\n        string memory json;\\n        string[32] memory emptyCanvas;\\n        DeviationInfo memory info = deviationRegistry.valueFor(\\n            dataMapper.valueFor(0, tokenId)\\n        );\\n        json = Base64.encode(\\n            bytes(\\n                string(\\n                    abi.encodePacked(\\n                        '{\\\"name\\\": \\\"0x',\\n                        toHexString(tokenId),\\n                        '\\\", \\\"description\\\": \\\"',\\n                        description,\\n                        '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                        draw(tokenId, amount, emptyCanvas),\\n                        '\\\", \\\"attributes\\\": [{\\\"trait_type\\\": \\\"Deviation\\\", \\\"value\\\": \\\"',\\n                        info.name,\\n                        '\\\"}, {\\\"trait_type\\\": \\\"Insight\\\", \\\"value\\\": \\\"',\\n                        toString(amount),\\n                        '\\\"}]}'\\n                    )\\n                )\\n            )\\n        );\\n\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", json));\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 i) internal pure returns (string memory) {\\n        // https://stackoverflow.com/a/69302348/424107\\n\\n        if (i == 0) return \\\"0\\\";\\n        uint256 j = i;\\n        uint256 length;\\n        while (j != 0) {\\n            length++;\\n            j = j >> 4;\\n        }\\n        uint256 mask = 15;\\n        bytes memory bstr = new bytes(length);\\n        uint256 k = length;\\n        while (i != 0) {\\n            uint256 curr = (i & mask);\\n            bstr[--k] = curr > 9\\n                ? bytes1(uint8(55 + curr))\\n                : bytes1(uint8(48 + curr)); // 55 = 65 - 10\\n            i = i >> 4;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    },\r\n    \"Base64.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\\n                )\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"}],\"name\":\"_blank\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_box\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"char2\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_checkeredBox\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"xc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yc\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"r\",\"type\":\"int8\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_circle\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"xc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_drawCircle\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"char2\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_middleBox\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"messageLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"_richText\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"messageLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"_text\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string[32]\",\"name\":\"oCanvas\",\"type\":\"string[32]\"}],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fontAddress\",\"type\":\"address\"}],\"name\":\"setFont\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ReflectionsMetadata","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}