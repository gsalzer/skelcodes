{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CorruptionsMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Base64.sol\\\";\\n\\ninterface ICorruptionsMetadata {\\n    function tokenURI(uint256 tokenId, uint256 amount) external view returns (string memory);\\n}\\n\\nstruct InsightMap {\\n    uint256 savedXP;\\n    uint256 lastSaveBlock;\\n}\\n\\ninterface ICorruptions {\\n    function insightMap(uint256 tokenID) external view returns (InsightMap memory);\\n}\\n\\ncontract CorruptionsMetadata is Ownable, ICorruptionsMetadata {\\n    string public description;\\n\\n    struct RandParts {\\n        string border;\\n        string corruptor;\\n        string phrase;\\n        string checker;\\n    }\\n\\n    constructor() Ownable() {\\n        description = \\\"Unknown\\\";\\n    }\\n\\n    function setDescription(string memory desc) public onlyOwner {\\n        description = desc;\\n    }\\n\\n    function _blank(string[32] memory canvas) public pure returns (string[32] memory) {\\n        for (uint8 i = 0; i < 32; i++) {\\n            canvas[i] = \\\"...............................\\\";\\n        }\\n        return canvas;\\n    }\\n\\n    function _box(string[32] memory canvas, string memory char, uint256 x, uint256 y, uint256 w, uint256 h) public pure returns (string[32] memory) {\\n        bytes1 byteChar = bytes(char)[0];\\n        for (uint256 iy = 0; iy < h; iy++) {\\n            for (uint256 ix = 0; ix < w; ix++) {\\n                bytes(canvas[iy + y])[ix + x] = byteChar;\\n            }\\n        }\\n        return canvas;\\n    }\\n\\n    function _checkeredBox(string[32] memory canvas, string memory char, string memory char2, uint256 x, uint256 y, uint256 w, uint256 h) public pure returns (string[32] memory) {\\n        bytes1 byteChar = bytes(char)[0];\\n        bytes1 byteChar2 = bytes(char2)[0];\\n        for (uint256 iy = 0; iy < h; iy++) {\\n            for (uint256 ix = 0; ix < w; ix++) {\\n                bytes(canvas[iy + y])[ix + x] = ((iy + y) + (ix + x)) % 2 == 0 ? byteChar : byteChar2;\\n            }\\n        }\\n        return canvas;\\n    }\\n\\n    function _drawCircle(string[32] memory canvas, string memory char, uint256 xc, uint256 yc, uint256 x, uint256 y) public pure returns (string[32] memory) { \\n        bytes1 byteChar = bytes(char)[0];\\n        bytes(canvas[yc + y])[xc + x] = byteChar;\\n        bytes(canvas[yc + y])[xc - x] = byteChar;\\n        bytes(canvas[yc - y])[xc + x] = byteChar;\\n        bytes(canvas[yc - y])[xc - x] = byteChar;\\n        bytes(canvas[yc + x])[xc + y] = byteChar;\\n        bytes(canvas[yc + x])[xc - y] = byteChar;\\n        bytes(canvas[yc - x])[xc + y] = byteChar;\\n        bytes(canvas[yc - x])[xc - y] = byteChar;\\n\\n        return canvas;\\n    }\\n\\n    function _circle(string[32] memory canvas, string memory char, uint256 xc, uint256 yc, int8 r) public pure returns (string[32] memory) {\\n        // https://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/\\n\\n        int256 x = 0;\\n        int256 y = int256(r);\\n        int256 d = 3 - 2 * r;\\n        canvas = _drawCircle(canvas, char, xc, yc, uint256(x), uint256(y));\\n        while (y >= x) {\\n            x++;\\n\\n            if (d > 0) {\\n                y--;\\n                d = d + 4 * (x - y) + 10;\\n            } else {\\n                d = d + 4 * x + 6;\\n            }\\n            canvas = _drawCircle(canvas, char, xc, yc, uint256(x), uint256(y));\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function _middleBox(string[32] memory canvas, string memory char, string memory char2, uint256 size) public pure returns (string[32] memory) {\\n        canvas = _checkeredBox(canvas, char, char2, 15 - size, 15 - size, size * 2 + 1, size * 2 + 1);\\n        return canvas;\\n    }\\n\\n    function _text(string[32] memory canvas, string memory message, uint256 messageLength, uint256 x, uint256 y) public pure returns (string[32] memory) {\\n        for (uint256 i = 0; i < messageLength; i++) {\\n            bytes(canvas[y])[x + i] = bytes(message)[i];\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function draw(uint256 tokenId, uint256 amount) public pure returns (string memory) {\\n        string[31] memory lookup = [\\n            \\\"20\\\",\\n            \\\"30\\\",\\n            \\\"40\\\",\\n            \\\"50\\\",\\n            \\\"60\\\",\\n            \\\"70\\\",\\n            \\\"80\\\",\\n            \\\"90\\\",\\n            \\\"100\\\",\\n            \\\"110\\\",\\n            \\\"120\\\",\\n            \\\"130\\\",\\n            \\\"140\\\",\\n            \\\"150\\\",\\n            \\\"160\\\",\\n            \\\"170\\\",\\n            \\\"180\\\",\\n            \\\"190\\\",\\n            \\\"200\\\",\\n            \\\"210\\\",\\n            \\\"220\\\",\\n            \\\"230\\\",\\n            \\\"240\\\",\\n            \\\"250\\\",\\n            \\\"260\\\",\\n            \\\"270\\\",\\n            \\\"280\\\",\\n            \\\"290\\\",\\n            \\\"300\\\",\\n            \\\"310\\\",\\n            \\\"320\\\"\\n        ];\\n\\n        string[40] memory randomStrings = [\\n            \\\"/\\\",\\n            \\\"$\\\",\\n            \\\"|\\\",\\n            \\\"8\\\",\\n            \\\"_\\\",\\n            \\\"?\\\",\\n            \\\"#\\\",\\n            \\\"%\\\",\\n            \\\"^\\\",\\n            \\\"~\\\",\\n            \\\":\\\",\\n\\n            \\\"#022FB7\\\",\\n            \\\"#262A36\\\",\\n            \\\"#A802B7\\\",\\n            \\\"#3CB702\\\",\\n            \\\"#B76F02\\\",\\n            \\\"#B70284\\\",\\n\\n            \\\"#0D1302\\\",\\n            \\\"#020A13\\\",\\n            \\\"#130202\\\",\\n            \\\"#1A1616\\\",\\n            \\\"#000000\\\",\\n            \\\"#040A27\\\",\\n            \\n            \\\"GENERATION\\\",\\n            \\\"INDIVIDUAL\\\",\\n            \\\"TECHNOLOGY\\\",\\n            \\\"EVERYTHING\\\",\\n            \\\"EVERYWHERE\\\",\\n            \\\"UNDERWORLD\\\",\\n            \\\"ILLUMINATI\\\",\\n            \\\"TEMPTATION\\\",\\n            \\\"REVELATION\\\",\\n            \\\"CORRUPTION\\\",\\n\\n            \\\"|\\\",\\n            \\\"-\\\",\\n            \\\"=\\\",\\n            \\\"+\\\",\\n            \\\"\\\\\\\\\\\",\\n            \\\":\\\",\\n            \\\"~\\\"\\n        ];\\n\\n        RandParts memory randParts;\\n\\n        randParts.border = randomStrings[uint256(keccak256(abi.encodePacked(\\\"BORDER\\\", tokenId))) % 11];\\n        randParts.corruptor = randomStrings[uint256(keccak256(abi.encodePacked(\\\"CORRUPTOR\\\", tokenId))) % 11];\\n        randParts.phrase = randomStrings[23 + uint256(keccak256(abi.encodePacked(\\\"PHRASE\\\", tokenId))) % 10];\\n        randParts.checker = randomStrings[33 + uint256(keccak256(abi.encodePacked(\\\"CHECKER\\\", tokenId))) % 7];\\n\\n        string[32] memory canvas;\\n        canvas = _blank(canvas);\\n\\n        canvas = _box(canvas, randParts.border, 0, 0, 31, 1);\\n        canvas = _box(canvas, randParts.border, 0, 30, 31, 1);\\n        canvas = _box(canvas, randParts.border, 0, 0, 1, 31);\\n        canvas = _box(canvas, randParts.border, 30, 0, 1, 31);\\n\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[0])), 15, 15, 12);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[1])), 15, 15, 11);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[2])), 15, 15, 10);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[3])), 15, 15, 9);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[4])), 15, 15, 8);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[5])), 15, 15, 7);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[6])), 15, 15, 6);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[7])), 15, 15, 5);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[8])), 15, 15, 4);\\n        canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[9])), 15, 15, 3);\\n\\n        uint256 iterations = uint256(keccak256(abi.encodePacked(\\\"CORRUPTION\\\", tokenId))) % 1024;\\n        for (uint256 i = 0; i < iterations; i++) {\\n            canvas = _box(canvas, randParts.corruptor, uint256(keccak256(abi.encodePacked(\\\"X\\\", i, tokenId))) % 30, uint256(keccak256(abi.encodePacked(\\\"Y\\\", i, tokenId))) % 30, 1, 1);\\n        }\\n\\n        uint256 length = 8 + bytes(toString(amount)).length;\\n        canvas = _text(canvas, string(abi.encodePacked(\\\"INSIGHT \\\", toString(amount))), length, 31 - length, 30);\\n\\n        for (uint i = 10; i > 0; i--) { \\n            if (amount >= i * 2) {\\n                canvas = _middleBox(canvas, string(abi.encodePacked(bytes(randParts.phrase)[i - 1])), randParts.checker, i);\\n            }\\n        }\\n\\n        string memory output;\\n        for (uint8 i = 0; i < 31; i++) {\\n            output = string(abi.encodePacked(\\n                output, '<text x=\\\"10\\\" y=\\\"', lookup[i], '\\\" class=\\\"base\\\">', canvas[i], '</text>'\\n            ));\\n        }\\n\\n        string[10] memory parts;\\n        parts[0] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 820 1340\\\"><style>.base { fill: ';\\n        parts[1] = randomStrings[11 + uint256(keccak256(abi.encodePacked(\\\"BGCOLOR\\\", tokenId))) % 6];\\n        parts[2] = '; font-family: monospace; font-size: 10px; }</style><g transform=\\\\\\\"scale(4 4)\\\\\\\"><rect width=\\\"205\\\" height=\\\"335\\\" fill=\\\"';\\n        parts[3] = amount >= 2 ? randomStrings[17 + uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) % 6] : randomStrings[27 + uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) % 6];\\n        parts[4] = '\\\" />';\\n        parts[5] = output;\\n        parts[6] = \\\"\\\";\\n        parts[7] = \\\"\\\";\\n        parts[8] = \\\"\\\"; \\n        parts[9] = '</g></svg>';\\n\\n        if (amount >= 2) {\\n            parts[6] = \\\"<!-- \\\";\\n            parts[7] = randomStrings[27 + uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) % 6];\\n            parts[8] = \\\" -->\\\";\\n        }\\n\\n        output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6]));\\n        output = string(abi.encodePacked(output, parts[7], parts[8], parts[9]));\\n        return Base64.encode(bytes(output));\\n    }\\n\\n    function tokenURI(uint256 tokenId, uint256 amount) override external view returns (string memory) {\\n        ICorruptions corruptions = ICorruptions(0x5BDf397bB2912859Dbd8011F320a222f79A28d2E);\\n        InsightMap memory insightMap = corruptions.insightMap(tokenId);\\n\\n        if (insightMap.lastSaveBlock <= 13604851 && tokenId != 3193) {\\n            amount += 1; // fix early transfer bug\\n        }\\n        \\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"0x', toHexString(tokenId), '\\\", \\\"description\\\": \\\"', description, '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', draw(tokenId, amount), '\\\", \\\"attributes\\\": [{\\\"trait_type\\\": \\\"Insight\\\", \\\"value\\\": \\\"', toString(amount), '\\\"}]}'))));\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", json));\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint i) internal pure returns (string memory) {\\n        // https://stackoverflow.com/a/69302348/424107\\n        \\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j = j >> 4;\\n        }\\n        uint mask = 15;\\n        bytes memory bstr = new bytes(length);\\n        uint k = length;\\n        while (i != 0) {\\n            uint curr = (i & mask);\\n            bstr[--k] = curr > 9 ?\\n                bytes1(uint8(55 + curr)) :\\n                bytes1(uint8(48 + curr)); // 55 = 65 - 10\\n            i = i >> 4;\\n        }\\n        return string(bstr);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"}],\"name\":\"_blank\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"}],\"name\":\"_box\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"char2\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"}],\"name\":\"_checkeredBox\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"xc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yc\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"r\",\"type\":\"int8\"}],\"name\":\"_circle\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"xc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"_drawCircle\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"char2\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"_middleBox\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"messageLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"_text\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CorruptionsMetadata","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}