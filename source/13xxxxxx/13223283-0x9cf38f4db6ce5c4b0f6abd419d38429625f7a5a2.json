{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/OfficialGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nimport \\\"../lib/ERC1271.sol\\\";\\nimport \\\"../lib/OwnerManagable.sol\\\";\\nimport \\\"../lib/SignatureUtil.sol\\\";\\n\\n\\n/// @title OfficialGuardian\\n/// @author Freeman Zhong - <kongliang@loopring.org>\\ncontract OfficialGuardian is OwnerManagable, ERC1271\\n{\\n    using SignatureUtil for bytes32;\\n\\n    /// @dev init owner for proxy contract:\\n    function initOwner(address _owner)\\n        external\\n    {\\n        require(owner == address(0), \\\"INITIALIZED_ALREADY\\\");\\n        owner = _owner;\\n    }\\n\\n    function isValidSignature(\\n        bytes32        _signHash,\\n        bytes   memory _signature\\n        )\\n        public\\n        view\\n        override\\n        returns (bytes4)\\n    {\\n        return isManager(_signHash.recoverECDSASigner(_signature))?\\n            ERC1271_MAGICVALUE:\\n            bytes4(0);\\n    }\\n\\n    function transact(\\n        address  target,\\n        uint     value,\\n        bytes    calldata data\\n        )\\n        external\\n        onlyManager\\n        returns (\\n            bool success,\\n            bytes memory returnData\\n        )\\n    {\\n        // solium-disable-next-line security/no-call-value\\n        (success, returnData) = target.call{value: value}(data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function isValidSignature(\\n        bytes32      _hash,\\n        bytes memory _signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OwnerManagable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AddressSet.sol\\\";\\nimport \\\"./Claimable.sol\\\";\\n\\n\\ncontract OwnerManagable is Claimable, AddressSet\\n{\\n    bytes32 internal constant MANAGER = keccak256(\\\"__MANAGED__\\\");\\n\\n    event ManagerAdded  (address indexed manager);\\n    event ManagerRemoved(address indexed manager);\\n\\n    modifier onlyManager\\n    {\\n        require(isManager(msg.sender), \\\"NOT_MANAGER\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrManager\\n    {\\n        require(msg.sender == owner || isManager(msg.sender), \\\"NOT_OWNER_OR_MANAGER\\\");\\n        _;\\n    }\\n\\n    constructor() Claimable() {}\\n\\n    /// @dev Gets the managers.\\n    /// @return The list of managers.\\n    function managers()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return addressesInSet(MANAGER);\\n    }\\n\\n    /// @dev Gets the number of managers.\\n    /// @return The numer of managers.\\n    function numManagers()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return numAddressesInSet(MANAGER);\\n    }\\n\\n    /// @dev Checks if an address is a manger.\\n    /// @param addr The address to check.\\n    /// @return True if the address is a manager, False otherwise.\\n    function isManager(address addr)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return isAddressInSet(MANAGER, addr);\\n    }\\n\\n    /// @dev Adds a new manager.\\n    /// @param manager The new address to add.\\n    function addManager(address manager)\\n        public\\n        onlyOwner\\n    {\\n        addManagerInternal(manager);\\n    }\\n\\n    /// @dev Removes a manager.\\n    /// @param manager The manager to remove.\\n    function removeManager(address manager)\\n        public\\n        onlyOwner\\n    {\\n        removeAddressFromSet(MANAGER, manager);\\n        emit ManagerRemoved(manager);\\n    }\\n\\n    function addManagerInternal(address manager)\\n        internal\\n    {\\n        addAddressToSet(MANAGER, manager, true);\\n        emit ManagerAdded(manager);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SignatureUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../thirdparty/BytesUtil.sol\\\";\\nimport \\\"./AddressUtil.sol\\\";\\nimport \\\"./ERC1271.sol\\\";\\nimport \\\"./MathUint.sol\\\";\\n\\n\\n/// @title SignatureUtil\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @dev This method supports multihash standard. Each signature's last byte indicates\\n///      the signature's type.\\nlibrary SignatureUtil\\n{\\n    using BytesUtil     for bytes;\\n    using MathUint      for uint;\\n    using AddressUtil   for address;\\n\\n    enum SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP_712,\\n        ETH_SIGN,\\n        WALLET   // deprecated\\n    }\\n\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function verifySignatures(\\n        bytes32          signHash,\\n        address[] memory signers,\\n        bytes[]   memory signatures\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(signers.length == signatures.length, \\\"BAD_SIGNATURE_DATA\\\");\\n        address lastSigner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function verifySignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        return signer.isContract()?\\n            verifyERC1271Signature(signHash, signer, signature):\\n            verifyEOASignature(signHash, signer, signature);\\n    }\\n\\n    function recoverECDSASigner(\\n        bytes32      signHash,\\n        bytes memory signature\\n        )\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        if (signature.length != 65) {\\n            return address(0);\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8   v;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := and(mload(add(signature, 0x41)), 0xff)\\n        }\\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n        if (v == 27 || v == 28) {\\n            return ecrecover(signHash, v, r, s);\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function verifyEOASignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        uint signatureTypeOffset = signature.length.sub(1);\\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\\n\\n        // Strip off the last byte of the signature by updating the length\\n        assembly {\\n            mstore(signature, signatureTypeOffset)\\n        }\\n\\n        if (signatureType == SignatureType.EIP_712) {\\n            success = (signer == recoverECDSASigner(signHash, signature));\\n        } else if (signatureType == SignatureType.ETH_SIGN) {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", signHash)\\n            );\\n            success = (signer == recoverECDSASigner(hash, signature));\\n        } else {\\n            success = false;\\n        }\\n\\n        // Restore the signature length\\n        assembly {\\n            mstore(signature, add(signatureTypeOffset, 1))\\n        }\\n\\n        return success;\\n    }\\n\\n    function verifyERC1271Signature(\\n        bytes32 signHash,\\n        address signer,\\n        bytes   memory signature\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes memory callData = abi.encodeWithSelector(\\n            ERC1271.isValidSignature.selector,\\n            signHash,\\n            signature\\n        );\\n        (bool success, bytes memory result) = signer.staticcall(callData);\\n        return (\\n            success &&\\n            result.length == 32 &&\\n            result.toBytes4(0) == ERC1271_MAGICVALUE\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title AddressSet\\n/// @author Daniel Wang - <daniel@loopring.org>\\ncontract AddressSet\\n{\\n    struct Set\\n    {\\n        address[] addresses;\\n        mapping (address => uint) positions;\\n        uint count;\\n    }\\n    mapping (bytes32 => Set) private sets;\\n\\n    function addAddressToSet(\\n        bytes32 key,\\n        address addr,\\n        bool    maintainList\\n        ) internal\\n    {\\n        Set storage set = sets[key];\\n        require(set.positions[addr] == 0, \\\"ALREADY_IN_SET\\\");\\n\\n        if (maintainList) {\\n            require(set.addresses.length == set.count, \\\"PREVIOUSLY_NOT_MAINTAILED\\\");\\n            set.addresses.push(addr);\\n        } else {\\n            require(set.addresses.length == 0, \\\"MUST_MAINTAIN\\\");\\n        }\\n\\n        set.count += 1;\\n        set.positions[addr] = set.count;\\n    }\\n\\n    function removeAddressFromSet(\\n        bytes32 key,\\n        address addr\\n        )\\n        internal\\n    {\\n        Set storage set = sets[key];\\n        uint pos = set.positions[addr];\\n        require(pos != 0, \\\"NOT_IN_SET\\\");\\n\\n        delete set.positions[addr];\\n        set.count -= 1;\\n\\n        if (set.addresses.length > 0) {\\n            address lastAddr = set.addresses[set.count];\\n            if (lastAddr != addr) {\\n                set.addresses[pos - 1] = lastAddr;\\n                set.positions[lastAddr] = pos;\\n            }\\n            set.addresses.pop();\\n        }\\n    }\\n\\n    function removeSet(bytes32 key)\\n        internal\\n    {\\n        delete sets[key];\\n    }\\n\\n    function isAddressInSet(\\n        bytes32 key,\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return sets[key].positions[addr] != 0;\\n    }\\n\\n    function numAddressesInSet(bytes32 key)\\n        internal\\n        view\\n        returns (uint)\\n    {\\n        Set storage set = sets[key];\\n        return set.count;\\n    }\\n\\n    function addressesInSet(bytes32 key)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        Set storage set = sets[key];\\n        require(set.count == set.addresses.length, \\\"NOT_MAINTAINED\\\");\\n        return sets[key].addresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/// @title Claimable\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @dev Extension for the Ownable contract, where the ownership needs\\n///      to be claimed. This allows the new owner to accept the transfer.\\ncontract Claimable is Ownable\\n{\\n    address public pendingOwner;\\n\\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\\n    modifier onlyPendingOwner() {\\n        require(msg.sender == pendingOwner, \\\"UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    /// @dev Allows the current owner to set the pendingOwner address.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership(\\n        address newOwner\\n        )\\n        public\\n        override\\n        onlyOwner\\n    {\\n        require(newOwner != address(0) && newOwner != owner, \\\"INVALID_ADDRESS\\\");\\n        pendingOwner = newOwner;\\n    }\\n\\n    /// @dev Allows the pendingOwner address to finalize the transfer.\\n    function claimOwnership()\\n        public\\n        onlyPendingOwner\\n    {\\n        emit OwnershipTransferred(owner, pendingOwner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Ownable\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @dev The Ownable contract has an owner address, and provides basic\\n///      authorization control functions, this simplifies the implementation of\\n///      \\\"user permissions\\\".\\ncontract Ownable\\n{\\n    address public owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @dev The Ownable constructor sets the original `owner` of the contract\\n    ///      to the sender.\\n    constructor()\\n    {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner()\\n    {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    /// @dev Allows the current owner to transfer control of the contract to a\\n    ///      new owner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership(\\n        address newOwner\\n        )\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        require(newOwner != address(0), \\\"ZERO_ADDRESS\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function renounceOwnership()\\n        public\\n        onlyOwner\\n    {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/BytesUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\npragma solidity ^0.7.0;\\n\\nlibrary BytesUtil {\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\\n        require(_bytes.length >= (_start + 3));\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8));\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12));\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16));\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\\n        require(_bytes.length >= (_start + 4));\\n        bytes4 tempBytes4;\\n\\n        assembly {\\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes4;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function fastSHA256(\\n        bytes memory data\\n        )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32[] memory result = new bytes32[](1);\\n        bool success;\\n        assembly {\\n             let ptr := add(data, 32)\\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\\n        }\\n        require(success, \\\"SHA256_FAILED\\\");\\n        return result[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for addresses\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary AddressUtil\\n{\\n    using AddressUtil for *;\\n\\n    function isContract(\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(addr) }\\n        return (codehash != 0x0 &&\\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\n    }\\n\\n    function toPayable(\\n        address addr\\n        )\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return payable(addr);\\n    }\\n\\n    // Works like address.send but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETH(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        if (amount == 0) {\\n            return true;\\n        }\\n        address payable recipient = to.toPayable();\\n        /* solium-disable-next-line */\\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\\\"\\\");\\n    }\\n\\n    // Works like address.transfer but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETHAndVerify(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        success = to.sendETH(amount, gasLimit);\\n        require(success, \\\"TRANSFER_FAILURE\\\");\\n    }\\n\\n    // Works like call but is slightly more efficient when data\\n    // needs to be copied from memory to do the call.\\n    function fastCall(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bool success, bytes memory returnData)\\n    {\\n        if (to != address(0)) {\\n            assembly {\\n                // Do the call\\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\\n                // Copy the return data\\n                let size := returndatasize()\\n                returnData := mload(0x40)\\n                mstore(returnData, size)\\n                returndatacopy(add(returnData, 32), 0, size)\\n                // Update free memory pointer\\n                mstore(0x40, add(returnData, add(32, size)))\\n            }\\n        }\\n    }\\n\\n    // Like fastCall, but throws when the call is unsuccessful.\\n    function fastCallAndVerify(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bytes memory returnData)\\n    {\\n        bool success;\\n        (success, returnData) = fastCall(to, gasLimit, value, data);\\n        if (!success) {\\n            assembly {\\n                revert(add(returnData, 32), mload(returnData))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MathUint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for uint\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary MathUint\\n{\\n    function mul(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a * b;\\n        require(a == 0 || c / a == b, \\\"MUL_OVERFLOW\\\");\\n    }\\n\\n    function sub(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        require(b <= a, \\\"SUB_UNDERFLOW\\\");\\n        return a - b;\\n    }\\n\\n    function add(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_signHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numManagers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transact\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OfficialGuardian","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}