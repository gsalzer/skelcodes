{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Traits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"./interface/ITraits.sol\\\";\\r\\nimport \\\"./interface/IDefpunk.sol\\\";\\r\\n\\r\\ncontract Traits is Ownable, ITraits {\\r\\n\\r\\n  using Strings for uint256;\\r\\n\\r\\n  // struct to store each trait's data for metadata and rendering\\r\\n  struct Trait {\\r\\n    string name;\\r\\n  }\\r\\n\\r\\n  // mapping from trait type (index) to its name\\r\\n  string[9] _traitTypes = [\\r\\n    \\\"Background\\\", // 0\\r\\n    \\\"Skin\\\", // 1\\r\\n    \\\"Nose\\\", // 2\\r\\n    \\\"Eyes\\\", // 3\\r\\n    \\\"Neck\\\", // 4\\r\\n    \\\"Mouth\\\", // 5\\r\\n    \\\"Ears\\\", // 6\\r\\n    \\\"Hair\\\", // 7\\r\\n    \\\"Mouth Accessory\\\" // 8\\r\\n  ];\\r\\n  // storage of each traits name and base64 PNG data\\r\\n  mapping(uint8 => mapping(uint8 => Trait)) public traitData;\\r\\n  \\r\\n  IDefpunk public defpunkNFT;\\r\\n\\r\\n  constructor() {}\\r\\n\\r\\n  /** ADMIN */\\r\\n\\r\\n  function setDefpunk(address _defpunk) external onlyOwner {\\r\\n    defpunkNFT = IDefpunk(_defpunk);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * administrative to upload the names and images associated with each trait\\r\\n   * @param traitType the trait type to upload the traits for (see traitTypes for a mapping)\\r\\n   * @param traits the names and base64 encoded PNGs for each trait\\r\\n   */\\r\\n  function uploadTraits(uint8 traitType, uint8[] calldata traitIds, Trait[] calldata traits) external onlyOwner {\\r\\n    require(traitIds.length == traits.length, \\\"Mismatched inputs\\\");\\r\\n    for (uint i = 0; i < traits.length; i++) {\\r\\n      traitData[traitType][traitIds[i]] = Trait(\\r\\n        traits[i].name\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * generates an attribute for the attributes array in the ERC721 metadata standard\\r\\n   * @param traitType the trait type to reference as the metadata key\\r\\n   * @param value the token's trait associated with the key\\r\\n   * @return a JSON dictionary for the single attribute\\r\\n   */\\r\\n  function attributeForTypeAndValue(string memory traitType, string memory value, bool aged) internal pure returns (string memory) {\\r\\n    if (aged) {\\r\\n      return string(abi.encodePacked(\\r\\n        '{\\\"trait_type\\\":\\\"',\\r\\n        traitType,\\r\\n        '\\\",\\\"value\\\":\\\"',\\r\\n        value, ' (Aged)',\\r\\n        '\\\"}'\\r\\n      ));\\r\\n    } else {\\r\\n      return string(abi.encodePacked(\\r\\n        '{\\\"trait_type\\\":\\\"',\\r\\n        traitType,\\r\\n        '\\\",\\\"value\\\":\\\"',\\r\\n        value,\\r\\n        '\\\"}'\\r\\n      ));\\r\\n    }\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev gets the base URI\\r\\n  */\\r\\n  function getBaseURI() external view returns (string memory) {\\r\\n    return defpunkNFT.getBaseURI();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * generates an array composed of all the individual traits and values\\r\\n   * @param tokenId the ID of the token to compose the metadata for\\r\\n   * @return a JSON array of all of the attributes for given token ID\\r\\n   */\\r\\n  function compileAttributes(uint256 tokenId) public view returns (string memory) {\\r\\n    IDefpunk.Defpunk memory d = defpunkNFT.getTokenTraits(tokenId);\\r\\n    string memory traits;\\r\\n    if (d.isMale) {\\r\\n      traits = string(abi.encodePacked(\\r\\n        attributeForTypeAndValue(_traitTypes[0], traitData[1][d.background].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[1], traitData[2][d.skin].name, d.aged[0] == 2),',',\\r\\n        attributeForTypeAndValue(_traitTypes[2], traitData[3][d.nose].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[3], traitData[4][d.eyes].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[4], traitData[5][d.neck].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[5], traitData[6][d.mouth].name, d.aged[1] == 6), ',',\\r\\n        attributeForTypeAndValue(_traitTypes[6], traitData[7][d.ears].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[7], traitData[8][d.hair].name, d.aged[2] == 8), ',',\\r\\n        attributeForTypeAndValue(_traitTypes[8], traitData[9][d.mouthAccessory].name, false),',',\\r\\n        attributeForTypeAndValue(\\\"Fusion Index\\\", uint2str(d.fusionIndex), false),','\\r\\n      ));\\r\\n    } else {\\r\\n      traits = string(abi.encodePacked(\\r\\n        attributeForTypeAndValue(_traitTypes[0], traitData[10][d.background].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[1], traitData[11][d.skin].name, d.aged[0] == 11),',',\\r\\n        attributeForTypeAndValue(_traitTypes[2], traitData[12][d.nose].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[3], traitData[13][d.eyes].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[4], traitData[14][d.neck].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[5], traitData[15][d.mouth].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[6], traitData[16][d.ears].name, false),',',\\r\\n        attributeForTypeAndValue(_traitTypes[7], traitData[17][d.hair].name, d.aged[2] == 17),',',\\r\\n        attributeForTypeAndValue(_traitTypes[8], traitData[18][d.mouthAccessory].name, false),',',\\r\\n        attributeForTypeAndValue(\\\"Fusion Index\\\", uint2str(d.fusionIndex), false),','\\r\\n      ));\\r\\n    }\\r\\n\\r\\n    return string(abi.encodePacked(\\r\\n      '[',\\r\\n      traits,\\r\\n      '{\\\"trait_type\\\":\\\"Gender\\\",\\\"value\\\":',\\r\\n      d.isMale ? '\\\"Male\\\"' : '\\\"Female\\\"',\\r\\n      '}]'\\r\\n    ));\\r\\n  }\\r\\n\\r\\n  function traitHasAged(uint8[3] memory aged, uint8 traitIndex) internal pure returns (bool) {\\r\\n    for (uint i = 0; i < aged.length; i++) {\\r\\n      if (aged[i] == traitIndex) return true;\\r\\n    }\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * generates a base64 encoded metadata response without referencing off-chain content\\r\\n   * @param tokenId the ID of the token to generate the metadata for\\r\\n   * @return a base64 encoded JSON dictionary of the token's metadata and SVG\\r\\n   */\\r\\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n    string memory metadata = string(abi.encodePacked(\\r\\n      '{\\\"name\\\": \\\"',\\r\\n      'Defpunk #',\\r\\n      tokenId.toString(),\\r\\n      '\\\", \\\"description\\\": \\\"This is the Defpunk description. All the metadata and are generated and stored 100% on-chain.\\\", \\\"image\\\": \\\"',\\r\\n      defpunkNFT.getBaseURI(),\\r\\n      tokenId.toString(),\\r\\n      '\\\", \\\"attributes\\\":',\\r\\n      compileAttributes(tokenId),\\r\\n      \\\"}\\\"\\r\\n    ));\\r\\n\\r\\n    return string(abi.encodePacked(\\r\\n      \\\"data:application/json;base64,\\\",\\r\\n      base64(bytes(metadata))\\r\\n    ));\\r\\n  }\\r\\n\\r\\n  /** BASE 64 - Written by Brech Devos */\\r\\n  \\r\\n  string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\r\\n\\r\\n  function base64(bytes memory data) internal pure returns (string memory) {\\r\\n    if (data.length == 0) return '';\\r\\n    \\r\\n    // load the table into memory\\r\\n    string memory table = TABLE;\\r\\n\\r\\n    // multiply by 4/3 rounded up\\r\\n    uint256 encodedLen = 4 * ((data.length + 2) / 3);\\r\\n\\r\\n    // add some extra buffer at the end required for the writing\\r\\n    string memory result = new string(encodedLen + 32);\\r\\n\\r\\n    assembly {\\r\\n      // set the actual output length\\r\\n      mstore(result, encodedLen)\\r\\n      \\r\\n      // prepare the lookup table\\r\\n      let tablePtr := add(table, 1)\\r\\n      \\r\\n      // input ptr\\r\\n      let dataPtr := data\\r\\n      let endPtr := add(dataPtr, mload(data))\\r\\n      \\r\\n      // result ptr, jump over length\\r\\n      let resultPtr := add(result, 32)\\r\\n      \\r\\n      // run over the input, 3 bytes at a time\\r\\n      for {} lt(dataPtr, endPtr) {}\\r\\n      {\\r\\n          dataPtr := add(dataPtr, 3)\\r\\n          \\r\\n          // read 3 bytes\\r\\n          let input := mload(dataPtr)\\r\\n          \\r\\n          // write 4 characters\\r\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\r\\n          resultPtr := add(resultPtr, 1)\\r\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\r\\n          resultPtr := add(resultPtr, 1)\\r\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\r\\n          resultPtr := add(resultPtr, 1)\\r\\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\r\\n          resultPtr := add(resultPtr, 1)\\r\\n      }\\r\\n      \\r\\n      // padding with '='\\r\\n      switch mod(mload(data), 3)\\r\\n      case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\r\\n      case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\r\\n    }\\r\\n    \\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\r\\n        if (_i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint j = _i;\\r\\n        uint len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint k = len;\\r\\n        while (_i != 0) {\\r\\n            k = k-1;\\r\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\r\\n            bytes1 b1 = bytes1(temp);\\r\\n            bstr[k] = b1;\\r\\n            _i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITraits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE \\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITraits {\\r\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\"\r\n    },\r\n    \"contracts/interface/IDefpunk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\r\\n\\r\\ninterface IDefpunk is IERC721Enumerable {\\r\\n\\r\\n  // struct to store each token's traits\\r\\n  struct Defpunk {\\r\\n    bool isMale;\\r\\n    uint8 background;\\r\\n    uint8 skin;\\r\\n    uint8 nose;\\r\\n    uint8 eyes;\\r\\n    uint8 neck;\\r\\n    uint8 mouth;\\r\\n    uint8 ears;\\r\\n    uint8 hair;\\r\\n    uint8 mouthAccessory;\\r\\n    uint8 fusionIndex;\\r\\n    uint8[3] aged;\\r\\n  }\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n    function updateOriginAccess(uint16[] memory tokenIds) external;\\r\\n    function setBaseURI(string memory _baseURI) external;\\r\\n    function mint(address recipient, uint256 seed) external;\\r\\n    function burn(uint256 tokenId) external;\\r\\n    function fuseTokens(uint256 fuseTokenId, uint256 burnTokenId, uint256 seed) external;\\r\\n    function setPaused(bool _paused) external;\\r\\n    function getBaseURI() external view returns (string memory);\\r\\n    function getMaxTokens() external view returns (uint256);\\r\\n    function getTokenTraits(uint256 tokenId) external view returns (Defpunk memory);\\r\\n    function getTokenWriteBlock(uint256 tokenId) external view returns(uint64);\\r\\n    function isMale(uint256 tokenId) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"compileAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defpunkNFT\",\"outputs\":[{\"internalType\":\"contract IDefpunk\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defpunk\",\"type\":\"address\"}],\"name\":\"setDefpunk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"traitType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"traitIds\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct Traits.Trait[]\",\"name\":\"traits\",\"type\":\"tuple[]\"}],\"name\":\"uploadTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Traits","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}