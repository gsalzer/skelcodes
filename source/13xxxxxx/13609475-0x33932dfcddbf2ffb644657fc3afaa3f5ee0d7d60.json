{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/viralswap/ViralswapVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\n/*\\r\\nBEGIN KEYBASE SALTPACK SIGNED MESSAGE. kXR7VktZdyH7rvq v5weRa0zkYfegFM 5cM6gB7cyPatQvp 6KyygX8PsvQVo4n Ugo6Il5bm6R9KJH KEkg77qc0o0lY6W yvqrtLgZxgKJVAH FTy5ayHJfkisnFM Shi7gaWAfQezYkC M1U9mZfY9OhthMn VhuwjWDrIqu8IaO mBL830YhemOeyZ9 0sNJhblIzLSskfq ii978jFlUJwCtMI 3dKs4NZuJkhW86Q F0ZdHRWO9lUnhvJ Uge2AAymBbtvrmx Z6QE88Wuj10K5wV 96BePfhF27S. END KEYBASE SALTPACK SIGNED MESSAGE.\\r\\n*/\\r\\n\\r\\nimport './libraries/Math.sol';\\r\\nimport './libraries/SafeMath.sol';\\r\\nimport './interfaces/IViralswapPair.sol';\\r\\nimport './interfaces/IViralswapFactory.sol';\\r\\nimport './interfaces/IViralswapRouter02.sol';\\r\\nimport './interfaces/IERC20Mintable.sol';\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the VIRAL Vault.\\r\\n *\\r\\n * ViralSwap Vault supports a fixed price buying of tokenOut when sent tokenIn.\\r\\n *\\r\\n * The tokenIn recieved are then used to add liquidity to the corresponding ViralSwap Pair.\\r\\n * The Vault does not hold tokenOut, they're minted each time a buy is made (the Vault MUST have the ability to mint tokens).\\r\\n */\\r\\ncontract ViralswapVault {\\r\\n    using SafeMathViralswap for uint256;\\r\\n\\r\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n\\r\\n    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\r\\n    address public factory;\\r\\n    address public tokenIn;\\r\\n    address public tokenOut;\\r\\n    address public pair;\\r\\n    address public viralswapRouter02;\\r\\n\\r\\n    uint256 public availableQuota;\\r\\n    uint256 public feeOnTokenOutTransferBIPS;\\r\\n    uint256 public tokenOutPerInflatedTokenIn; // inflated by 1e18\\r\\n\\r\\n    uint112 private reserveIn;           // uses single storage slot, accessible via getReserves\\r\\n    uint112 private reserveOut;          // uses single storage slot, accessible via getReserves\\r\\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\\r\\n\\r\\n    uint256 private unlocked = 1;\\r\\n\\r\\n    modifier lock() {\\r\\n        require(unlocked == 1, 'Viralswap: LOCKED');\\r\\n        unlocked = 0;\\r\\n        _;\\r\\n        unlocked = 1;\\r\\n    }\\r\\n\\r\\n    function getReserves() public view returns (uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast) {\\r\\n        _reserveIn = reserveIn;\\r\\n        _reserveOut = reserveOut;\\r\\n        _blockTimestampLast = blockTimestampLast;\\r\\n    }\\r\\n\\r\\n    function getQuoteOut(address _tokenIn, uint256 _amountIn) external view returns (uint256 amountOut) {\\r\\n        if(_tokenIn != tokenIn) {\\r\\n            return 0;\\r\\n        }\\r\\n        amountOut = _amountIn.mul(tokenOutPerInflatedTokenIn) / 1e18;\\r\\n        if(amountOut > availableQuota) {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getQuoteIn(address _tokenOut, uint256 _amountOut) external view returns (uint256 amountIn) {\\r\\n        if(_tokenOut != tokenOut) {\\r\\n            return 0;\\r\\n        }\\r\\n        if(_amountOut > availableQuota) {\\r\\n            return 0;\\r\\n        }\\r\\n        amountIn = _amountOut.mul(1e18) / tokenOutPerInflatedTokenIn;\\r\\n    }\\r\\n\\r\\n    function _safeTransfer(address token, address to, uint256 value) private {\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Viralswap: TRANSFER_FAILED');\\r\\n    }\\r\\n\\r\\n    event Buy(address indexed sender, uint256 amountOut, address indexed to);\\r\\n    event Sync(uint112 reserveIn, uint112 reserveOut);\\r\\n    event AddQuota(uint256 quota);\\r\\n\\r\\n    constructor() public {\\r\\n        factory = msg.sender;\\r\\n    }\\r\\n\\r\\n    // called once by the factory at the time of deployment\\r\\n    function initialize(uint256 _tokenOutPerInflatedTokenIn, address _tokenIn, address _tokenOut, address _viralswapRouter02, uint256 _feeOnTokenOutTransferBIPS) external {\\r\\n        require(msg.sender == factory, 'Viralswap: FORBIDDEN'); // sufficient check\\r\\n        require(_tokenOutPerInflatedTokenIn != 0, \\\"Viralswap: INVALID_TOKENOUT_QUANTITY\\\");\\r\\n        require(feeOnTokenOutTransferBIPS < 10000, \\\"Viralswap: INVALID_FEE_ON_TOKENOUT\\\");\\r\\n        tokenOutPerInflatedTokenIn = _tokenOutPerInflatedTokenIn;\\r\\n        tokenIn = _tokenIn;\\r\\n        tokenOut = _tokenOut;\\r\\n        viralswapRouter02 = _viralswapRouter02;\\r\\n        feeOnTokenOutTransferBIPS = _feeOnTokenOutTransferBIPS;\\r\\n\\r\\n        pair = IViralswapFactory(factory).getPair(_tokenIn, _tokenOut);\\r\\n        require(pair != address(0), \\\"Viralswap: PAIR_DOES_NOT_EXIST\\\");\\r\\n        (uint256 swapReserveIn, uint256 swapReserveOut) = _getSwapReserves(_tokenIn, _tokenOut);\\r\\n        require(swapReserveIn > 0 && swapReserveOut > 0, \\\"Viralswap: NO_LIQUIDITY_IN_POOL\\\");\\r\\n    }\\r\\n\\r\\n    // called by factory to update the ViralRouter address\\r\\n    function updateRouter(address _viralswapRouter02) external {\\r\\n        require(msg.sender == factory, 'Viralswap: FORBIDDEN'); // sufficient check\\r\\n        viralswapRouter02 = _viralswapRouter02;\\r\\n    }\\r\\n\\r\\n    // called by factory to add minting quota for tokenOut\\r\\n    function addQuota(uint256 quota) external {\\r\\n        require(msg.sender == factory, 'Viralswap: FORBIDDEN'); // sufficient check\\r\\n        availableQuota = availableQuota.add(quota);\\r\\n        emit AddQuota(quota);\\r\\n    }\\r\\n\\r\\n    function withdrawERC20(address _token, address _to) external {\\r\\n        require(msg.sender == factory, 'Viralswap: FORBIDDEN'); // sufficient check\\r\\n        uint256 balance = IERC20Viralswap(_token).balanceOf(address(this));\\r\\n        IERC20Viralswap(_token).transfer(_to, balance);\\r\\n        _update();\\r\\n    }\\r\\n\\r\\n    // called by self to mint tokenOut\\r\\n    function _mint(address _account, uint256 _amount) private {\\r\\n        require(availableQuota >= _amount, 'Viralswap: INSUFFICIENT_QUOTA');\\r\\n        availableQuota = availableQuota.sub(_amount);\\r\\n        IERC20ViralswapMintable(tokenOut).mint(_account, _amount);\\r\\n    }\\r\\n\\r\\n    // update reserves to match current balances\\r\\n    function _update() private {\\r\\n        uint256 balanceIn = IERC20Viralswap(tokenIn).balanceOf(address(this));\\r\\n        uint256 balanceOut = IERC20Viralswap(tokenOut).balanceOf(address(this));\\r\\n        require(balanceIn <= uint112(-1) && balanceOut <= uint112(-1), 'Viralswap: OVERFLOW');\\r\\n        reserveIn = uint112(balanceIn);\\r\\n        reserveOut = uint112(balanceOut);\\r\\n        blockTimestampLast = uint32(block.timestamp % 2**32);\\r\\n        emit Sync(reserveIn, reserveOut);\\r\\n    }\\r\\n\\r\\n    function _addLiquidity(uint256 _amountInDesired, uint256 _amountOutDesired) private {\\r\\n\\r\\n        IERC20Viralswap(tokenIn).transfer(pair, _amountInDesired);\\r\\n        IERC20Viralswap(tokenOut).transfer(pair, _amountOutDesired);\\r\\n\\r\\n        IViralswapPair(pair).mint(address(this));\\r\\n    }\\r\\n\\r\\n    function _getSwapReserves(address _tokenIn, address _tokenOut) internal view returns (uint256 _reserveIn, uint256 _reserveOut){\\r\\n\\r\\n        (uint256 reserve0, uint256 reserve1,) = IViralswapPair(pair).getReserves();\\r\\n        (_reserveIn, _reserveOut) = _tokenIn < _tokenOut ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    function _quotePair(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {\\r\\n        amountB = amountA.mul(reserveB) / reserveA;\\r\\n    }\\r\\n\\r\\n    // this low-level function should be called from a contract which performs important safety checks\\r\\n    // What actually is happening in the function:\\r\\n    //  - calculate amount of tokenIn sent to the vault, check if it is atleast the expected amount, refund excess\\r\\n    //  - calculate the tokenOut needed to add to liquidity\\r\\n    //  - mint the required amount of tokenOut (buy + liquidity)\\r\\n    //  - transfer tokenOut to the `to` address\\r\\n    //  - add liquidity to the corresponding pair\\r\\n    //  - update reserves\\r\\n    function buy(uint256 amountOut, address to) external lock {\\r\\n        require(msg.sender == viralswapRouter02, \\\"Viralswap: FORBIDDEN\\\");\\r\\n        require(amountOut > 0, 'Viralswap: INSUFFICIENT_OUT_AMT');\\r\\n\\r\\n        address _tokenIn = tokenIn;\\r\\n        (uint112 _reserveIn,,) = getReserves();\\r\\n\\r\\n        uint256 balanceIn = IERC20Viralswap(_tokenIn).balanceOf(address(this));\\r\\n        uint256 amountIn = balanceIn.sub(_reserveIn);\\r\\n        uint256 amountInExpected = amountOut.mul(1e18) / tokenOutPerInflatedTokenIn;\\r\\n        require(amountIn >= amountInExpected, 'Viralswap: INSUFFICIENT_IN_AMT');\\r\\n\\r\\n        _mint(address(this), amountOut); // important to have this before _tryBalancePool, as availableQuota changes\\r\\n        IERC20Viralswap(tokenOut).transfer(to, amountOut);\\r\\n\\r\\n        _tryBalancePool(_reserveIn, amountIn, availableQuota);\\r\\n\\r\\n        emit Buy(msg.sender, amountOut, to);\\r\\n    }\\r\\n\\r\\n    function _tryBalancePool(uint256 _reserveIn, uint256 _maxSpendTokenIn, uint256 _maxSpendTokenOut) internal {\\r\\n        require(_maxSpendTokenIn != 0 || _maxSpendTokenOut != 0, \\\"Viralswap: ZERO_SPEND\\\");\\r\\n\\r\\n        address _tokenIn = tokenIn;\\r\\n        address _tokenOut = tokenOut;\\r\\n        bool buyTokenOut;\\r\\n        uint256 swapAmountIn;\\r\\n        {\\r\\n            (uint256 swapReserveIn, uint256 swapReserveOut) = _getSwapReserves(_tokenIn, _tokenOut);\\r\\n            (buyTokenOut, swapAmountIn) = IViralswapFactory(factory).computeProfitMaximizingTrade(\\r\\n                1e18, tokenOutPerInflatedTokenIn, swapReserveIn, swapReserveOut\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 maxSpend = buyTokenOut ? _maxSpendTokenIn : _maxSpendTokenOut;\\r\\n        if (swapAmountIn > maxSpend) {\\r\\n            swapAmountIn = maxSpend;\\r\\n        }\\r\\n\\r\\n        if(swapAmountIn != 0) {\\r\\n             if(buyTokenOut) {\\r\\n                // spend swapAmountIn worth of _tokenIn\\r\\n                _swap(BURN_ADDRESS, _tokenIn, _tokenOut, swapAmountIn);\\r\\n\\r\\n            } else {\\r\\n                // mint and spend swapAmountIn worth of _tokenOut\\r\\n                _mint(address(this), swapAmountIn);\\r\\n                _swap(address(this), _tokenOut, _tokenIn, swapAmountIn);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 tokenInForLiquidity = IERC20Viralswap(_tokenIn).balanceOf(address(this)).sub(_reserveIn);\\r\\n\\r\\n        if(tokenInForLiquidity > 0) {\\r\\n            // the pool is balanced or quota insufficient\\r\\n            uint256 tokenInForLiquidityFeeAdjusted = tokenInForLiquidity.sub(tokenInForLiquidity.mul(feeOnTokenOutTransferBIPS) / 10000 );\\r\\n            uint256 tokenOutForLiquidity = tokenInForLiquidity.mul(tokenOutPerInflatedTokenIn) / 1e18;\\r\\n\\r\\n            _mint(address(this), tokenOutForLiquidity);\\r\\n            _addLiquidity(tokenInForLiquidityFeeAdjusted, tokenOutForLiquidity);\\r\\n        }\\r\\n        _update();\\r\\n    }\\r\\n\\r\\n    function _swap(address _to, address _tokenToSell, address _tokenToBuy, uint256 _amountIn) private {\\r\\n        IERC20Viralswap(_tokenToSell).approve(viralswapRouter02, _amountIn);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _tokenToSell;\\r\\n        path[1] = _tokenToBuy;\\r\\n\\r\\n        IViralswapRouter02(viralswapRouter02).swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            _amountIn,\\r\\n            0, // we can skip computing this number because the math is tested\\r\\n            path,\\r\\n            _to,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // force reserves to match balances\\r\\n    function sync() external lock {\\r\\n        _update();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/viralswap/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\n// a library for performing various math operations\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x < y ? x : y;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/viralswap/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity =0.6.12;\\r\\n\\r\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\r\\n\\r\\nlibrary SafeMathViralswap {\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\r\\n    }\\r\\n\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\r\\n    }\\r\\n\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IViralswapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IViralswapPair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IViralswapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IViralswapFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n    function migrator() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function getVault(address tokenA, address tokenB) external view returns (address vault);\\r\\n    function allVaults(uint) external view returns (address vault);\\r\\n    function allVaultsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function createVault(uint tokenOutPerTokenIn, address tokenIn, address tokenOut, address router, uint feeOnTokenOutTransferBIPS) external returns (address vault);\\r\\n\\r\\n    function addQuota(address tokenA, address tokenB, uint quota) external;\\r\\n    function updateRouterInVault(address tokenA, address tokenB, address _viralswapRouter02) external;\\r\\n    function withdrawERC20FromVault(address tokenA, address tokenB, address tokenToWithdraw, address to) external;\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n    function setMigrator(address) external;\\r\\n\\r\\n    function pairCodeHash() external pure returns (bytes32);\\r\\n    function vaultCodeHash() external pure returns (bytes32);\\r\\n\\r\\n    function computeProfitMaximizingTrade(\\r\\n        uint256 truePriceTokenA,\\r\\n        uint256 truePriceTokenB,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (bool, uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IViralswapRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\nimport './IUniswapRouter02.sol';\\r\\n\\r\\ninterface IViralswapRouter02 is IUniswapV2Router02 {\\r\\n\\r\\n    function swapExactViralForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactViralForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactTokensForViralSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function buyTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function buyViralForExactTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function buyViralForExactETHSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function getVaultAmountOut(address tokenIn, address tokenOut, uint amountIn) external view returns (uint amountOut);\\r\\n    function getVaultAmountIn(address tokenIn, address tokenOut, uint amountOut) external view returns (uint amountIn);\\r\\n}\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IERC20Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport './IERC20.sol';\\r\\n\\r\\ninterface IERC20ViralswapMintable is IERC20Viralswap {\\r\\n    function mint(address account, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IUniswapRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\nimport './IUniswapRouter01.sol';\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IUniswapRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function VIRAL() external pure returns (address);\\r\\n    function altRouter() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    },\r\n    \"contracts/viralswap/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IERC20Viralswap {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"}],\"name\":\"AddQuota\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserveIn\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserveOut\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"}],\"name\":\"addQuota\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableQuota\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeOnTokenOutTransferBIPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"getQuoteIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"getQuoteOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserveIn\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserveOut\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenOutPerInflatedTokenIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_viralswapRouter02\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeOnTokenOutTransferBIPS\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOut\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOutPerInflatedTokenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_viralswapRouter02\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viralswapRouter02\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ViralswapVault","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}