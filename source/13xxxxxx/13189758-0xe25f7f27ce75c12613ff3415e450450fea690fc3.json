{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: 0BSD\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, address token, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ncontract Meta {\r\n\r\n    uint public totalSupply;\r\n    uint public taxConstant = 100;\r\n    uint public totalValueTransferred;\r\n    uint public totalTokensBought;\r\n    uint public minTangleToTaxEvade = 5000000 * 1e9;\r\n    string public name = \"Meta\";\r\n    string public symbol = \"META\";\r\n    string public baseURI = \"https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/\";\r\n    address public feeTo;\r\n    address public administrator;\r\n    address public TangleAddress;\r\n    address[] public mintedTokens;\r\n    mapping(address => address) public ownerOf;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => address) public tokenApprovals;\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n    mapping(address => address[]) public tokensOfOwner;\r\n    mapping(address => mapping(address => uint)) public indexOfTokenInTokensOfOwner;\r\n\r\n    struct Offer {\r\n        bool isForSale;\r\n        address token;\r\n        address seller;\r\n        uint minValue;\r\n        address onlySellTo;\r\n    }\r\n\r\n    struct Bid {\r\n        bool hasBid;\r\n        address token;\r\n        address bidder;\r\n        uint value;\r\n    }\r\n\r\n    mapping (address => Offer) public tokensOfferedForSale;\r\n    mapping (address => Bid) public tokenBids;\r\n\r\n    constructor() {\r\n        feeTo = msg.sender;\r\n        administrator = msg.sender;\r\n        mint(msg.sender, address(this));\r\n    }\r\n    \r\n    function changeFeeTo(address newFeeTo) public {\r\n        require(msg.sender == administrator, \"not administrator\");\r\n        feeTo = newFeeTo;\r\n    }\r\n    \r\n    function changeTangleAddress(address newTangleAddress) public {\r\n        require(msg.sender == administrator, \"not administrator\");\r\n        TangleAddress = newTangleAddress; \r\n    }\r\n    \r\n    function changeAdministrator(address newAdministrator) public {\r\n        require(msg.sender == administrator, \"not administrator\");\r\n        administrator = newAdministrator;\r\n    }\r\n    \r\n    function changeMinTangleToTaxEvade(uint newMinTangleToTaxEvade) public {\r\n        require(msg.sender == administrator, \"not administrator\");\r\n        minTangleToTaxEvade = newMinTangleToTaxEvade;\r\n    }\r\n\r\n    function increaseTaxConstant(uint newTaxConstant) public { // this decreases the total tax rate on accepted bids or buys\r\n        require(msg.sender == feeTo, \"only feeTo can change taxConstant\");\r\n        require(newTaxConstant > taxConstant, \"taxConstant must increase\");\r\n        taxConstant = newTaxConstant;\r\n    }\r\n\r\n    function mint(address to, address token) public {\r\n        require(ownerOf[token] == address(0), \"cannot mint already owned token\");\r\n        ownerOf[token] = to;\r\n        tokensOfOwner[to].push(token);\r\n        indexOfTokenInTokensOfOwner[to][token] = balanceOf[to];\r\n        balanceOf[to]++;\r\n        emit Transfer(address(0), to, token);\r\n        totalSupply++;\r\n        mintedTokens.push(token);\r\n    }\r\n\r\n    function tokenLogo(address token) public view returns (string memory) {\r\n        return string(abi.encodePacked(baseURI, \"0x\", _toChecksumString(token), \"/logo.png\"));\r\n    }\r\n\r\n    function tokenInfo(address token) public view returns (string memory) {\r\n        return string(abi.encodePacked(baseURI, \"0x\", _toChecksumString(token), \"/info.json\"));\r\n    }\r\n\r\n    function approve(address to, address token) public {\r\n        require(msg.sender == ownerOf[token] || isApprovedForAll[ownerOf[token]][msg.sender], \"ERC721: approve caller is not owner nor approved for all\");\r\n        tokenApprovals[token] = to;\r\n        emit Approval(ownerOf[token], to, token);\r\n    }\r\n\r\n    function getApproved(address token) public view returns (address) {\r\n        return tokenApprovals[token];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public {\r\n        require(operator != msg.sender, \"ERC721: approve to caller\");\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function transferFrom(address from, address to, address token) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"ERC721: transfer caller is not owner nor approved\");\r\n        _transfer(from, to, token);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, address token) internal view returns (bool) {\r\n        return (spender == ownerOf[token] || getApproved(token) == spender || isApprovedForAll[ownerOf[token]][spender]);\r\n    }\r\n\r\n    function _transfer(address from, address to, address token) internal {\r\n        require(ownerOf[token] == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"cannot transfer to zero address\");\r\n        if (tokensOfferedForSale[token].isForSale)\r\n            tokenNoLongerForSale(token);\r\n        if (balanceOf[from] > 1) {\r\n            if (indexOfTokenInTokensOfOwner[from][token] != balanceOf[from] - 1) {\r\n                tokensOfOwner[from][indexOfTokenInTokensOfOwner[from][token]] = tokensOfOwner[from][balanceOf[from] - 1];\r\n                indexOfTokenInTokensOfOwner[from][tokensOfOwner[from][balanceOf[from] - 1]] = indexOfTokenInTokensOfOwner[from][token];\r\n            }\r\n            tokensOfOwner[from].pop();\r\n        }\r\n        if (balanceOf[from] == 1) {\r\n            delete tokensOfOwner[from];\r\n        }\r\n        indexOfTokenInTokensOfOwner[from][token] = 0;\r\n        balanceOf[from]--;\r\n        tokensOfOwner[to].push(token);\r\n        indexOfTokenInTokensOfOwner[to][token] = balanceOf[to];\r\n        balanceOf[to]++;\r\n        ownerOf[token] = to;\r\n        Bid memory bid = tokenBids[token];\r\n        if (bid.bidder == to) {\r\n            payable(bid.bidder).transfer(bid.value);\r\n            tokenBids[token] = Bid(false, token, address(0), 0);\r\n        }\r\n        emit Transfer(from, to, token);\r\n    }\r\n\r\n    function tokenNoLongerForSale(address token) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"not owner or approved\");\r\n        tokensOfferedForSale[token] = Offer(false, token, msg.sender, 0, address(0));\r\n        emit TokenNoLongerForSale(token);\r\n    }\r\n\r\n    function offerTokenForSale(address token, uint minSalePriceInWei, address toAddress) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"not owner or approved\");\r\n        tokensOfferedForSale[token] = Offer(true, token, msg.sender, minSalePriceInWei, toAddress);\r\n        emit TokenOffered(token, minSalePriceInWei, toAddress);\r\n    }\r\n\r\n    function offerTokenForSale(address token, uint minSalePriceInWei) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"not owner or approved\");\r\n        tokensOfferedForSale[token] = Offer(true, token, msg.sender, minSalePriceInWei, address(0));\r\n        emit TokenOffered(token, minSalePriceInWei, address(0));\r\n    }\r\n    \r\n    function transferModifier(uint toType, uint value, address seller) internal view returns (uint) {\r\n        if (toType == 0)\r\n            return ERC20(TangleAddress).balanceOf(seller) >= minTangleToTaxEvade ? value : value * (taxConstant - 1) / taxConstant;\r\n        return ERC20(TangleAddress).balanceOf(seller) >= minTangleToTaxEvade ? 0 : value / taxConstant;\r\n    }\r\n\r\n    function buyToken(address token) payable public {\r\n        Offer memory offer = tokensOfferedForSale[token];\r\n        require(offer.isForSale, \"token not for sale\");\r\n        require(offer.onlySellTo == address(0) || offer.onlySellTo == msg.sender, \"cannot buy restricted token sale\");\r\n        require(msg.value >= offer.minValue, \"offer too low\");\r\n        require(offer.seller == ownerOf[token], \"token owner changed since offer was made\");\r\n        tokenApprovals[token] = address(0);\r\n        if (balanceOf[offer.seller] > 1) {\r\n            if (indexOfTokenInTokensOfOwner[offer.seller][token] != balanceOf[offer.seller] - 1) {\r\n                tokensOfOwner[offer.seller][indexOfTokenInTokensOfOwner[offer.seller][token]] = tokensOfOwner[offer.seller][balanceOf[offer.seller] - 1];\r\n                indexOfTokenInTokensOfOwner[offer.seller][tokensOfOwner[offer.seller][balanceOf[offer.seller] - 1]] = indexOfTokenInTokensOfOwner[offer.seller][token];\r\n            }\r\n            tokensOfOwner[offer.seller].pop();\r\n        }\r\n        if (balanceOf[offer.seller] == 1) {\r\n            delete tokensOfOwner[offer.seller];\r\n        }\r\n        indexOfTokenInTokensOfOwner[offer.seller][token] = 0;\r\n        balanceOf[offer.seller]--;\r\n        tokensOfOwner[msg.sender].push(token);\r\n        indexOfTokenInTokensOfOwner[msg.sender][token] = balanceOf[msg.sender];\r\n        balanceOf[msg.sender]++;\r\n        ownerOf[token] = msg.sender;\r\n        tokenNoLongerForSale(token);\r\n        emit Transfer(offer.seller, msg.sender, token);\r\n        payable(offer.seller).transfer(transferModifier(0, msg.value, offer.seller));\r\n        payable(feeTo).transfer(transferModifier(1, msg.value, offer.seller));\r\n        totalValueTransferred += msg.value;\r\n        totalTokensBought++;\r\n        emit TokenBought(token, msg.value, offer.seller, ownerOf[token]);\r\n        Bid memory bid = tokenBids[token];\r\n        if (bid.bidder == msg.sender) {\r\n            payable(msg.sender).transfer(bid.value);\r\n            tokenBids[token] = Bid(false, token, address(0), 0);\r\n        }\r\n    }\r\n\r\n    function enterBidForToken(address token) payable public {\r\n        require(ownerOf[token] != address(0), \"token not owned\");\r\n        require(ownerOf[token] != msg.sender, \"cannot bid on your own token\");\r\n        require(msg.value > 0, \"invalid bid amount\");\r\n        Bid memory existing = tokenBids[token];\r\n        require(msg.value > existing.value, \"bid not greater than highest existing bid\");\r\n        if (existing.value > 0) payable(existing.bidder).transfer(existing.value);\r\n        tokenBids[token] = Bid(true, token, msg.sender, msg.value);\r\n        emit TokenBidEntered(token, msg.value, msg.sender);\r\n    }\r\n\r\n    function acceptBidForToken(address token, uint minPrice) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"not owner or approved\");\r\n        Bid memory bid = tokenBids[token];\r\n        address seller = ownerOf[token];\r\n        require(bid.value > 0, \"highest bid value must be greater than zero\");\r\n        require(bid.value >= minPrice, \"bid must be greater than minimum price\");\r\n        tokenBids[token] = Bid(false, token, address(0), 0);\r\n        _transfer(ownerOf[token], bid.bidder, token);\r\n        tokensOfferedForSale[token] = Offer(false, token, bid.bidder, 0, address(0));\r\n        payable(seller).transfer(transferModifier(0, bid.value, seller));\r\n        payable(feeTo).transfer(transferModifier(1, bid.value, seller));\r\n        totalValueTransferred += bid.value;\r\n        totalTokensBought++;\r\n        emit TokenBought(token, bid.value, ownerOf[token], bid.bidder);\r\n    }\r\n\r\n    function withdrawBidForToken(address token) public {\r\n        Bid memory bid = tokenBids[token];\r\n        require(bid.bidder == msg.sender, \"not bidder\");\r\n        emit TokenBidWithdrawn(token, bid.value, msg.sender);\r\n        tokenBids[token] = Bid(false, token, address(0), 0);\r\n        payable(msg.sender).transfer(bid.value);\r\n    }\r\n\r\n    function _getAsciiOffset(uint8 nibble, bool caps) internal pure returns (uint8 offset) {\r\n        if (nibble < 10) {\r\n            offset = 48;\r\n        } else if (caps) {\r\n            offset = 55;\r\n        } else {\r\n            offset = 87;\r\n        }\r\n    }\r\n\r\n    function _toAsciiString(bytes20 data) internal pure returns (string memory asciiString) {\r\n        bytes memory asciiBytes = new bytes(40);\r\n        uint8 b;\r\n        uint8 leftNibble;\r\n        uint8 rightNibble;\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            b = uint8(uint160(data) / (2 ** (8 * (19 - i))));\r\n            leftNibble = b / 16;\r\n            rightNibble = b - 16 * leftNibble;\r\n            asciiBytes[2 * i] = bytes1(leftNibble + (leftNibble < 10 ? 48 : 87));\r\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + (rightNibble < 10 ? 48 : 87));\r\n        }\r\n        return string(asciiBytes);\r\n    }\r\n\r\n    function _toChecksumCapsFlags(address account) internal pure returns (bool[40] memory characterCapitalized) {\r\n        bytes20 a = bytes20(account);\r\n        bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));\r\n        uint8 leftNibbleAddress;\r\n        uint8 rightNibbleAddress;\r\n        uint8 leftNibbleHash;\r\n        uint8 rightNibbleHash;\r\n        for (uint256 i; i < a.length; i++) {\r\n            rightNibbleAddress = uint8(a[i]) % 16;\r\n            leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;\r\n            rightNibbleHash = uint8(b[i]) % 16;\r\n            leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;\r\n            characterCapitalized[2 * i] = (leftNibbleAddress > 9 && leftNibbleHash > 7);\r\n            characterCapitalized[2 * i + 1] = (rightNibbleAddress > 9 && rightNibbleHash > 7);\r\n        }\r\n    }\r\n\r\n    function _toChecksumString(address account) internal pure returns (string memory asciiString) {\r\n        bytes20 data = bytes20(account);\r\n        bytes memory asciiBytes = new bytes(40);\r\n        uint8 b;\r\n        uint8 leftNibble;\r\n        uint8 rightNibble;\r\n        bool leftCaps;\r\n        bool rightCaps;\r\n        uint8 asciiOffset;\r\n        bool[40] memory caps = _toChecksumCapsFlags(account);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            b = uint8(uint160(data) / (2**(8*(19 - i))));\r\n            leftNibble = b / 16;\r\n            rightNibble = b - 16 * leftNibble;\r\n            leftCaps = caps[2*i];\r\n            rightCaps = caps[2*i + 1];\r\n            asciiOffset = _getAsciiOffset(leftNibble, leftCaps);\r\n            asciiBytes[2 * i] = bytes1(leftNibble + asciiOffset);\r\n            asciiOffset = _getAsciiOffset(rightNibble, rightCaps);\r\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + asciiOffset);\r\n        }\r\n        return string(asciiBytes);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, address token) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, token, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, address token, bytes memory data) public {\r\n        require(_isApprovedOrOwner(msg.sender, token), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, token, data);\r\n    }\r\n\r\n    function _safeTransfer(address from, address to, address token, bytes memory _data) internal virtual {\r\n        _transfer(from, to, token);\r\n        require(_checkOnERC721Received(from, to, token, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _checkOnERC721Received(address from, address to, address token, bytes memory data) private returns (bool) {\r\n        if (isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, token, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function tokenByIndex(uint index) public view returns (address) {\r\n        return mintedTokens[index];\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint index) public view returns (address) {\r\n        require(index < balanceOf[owner], \"index out of bounds\");\r\n        return tokensOfOwner[owner][index];\r\n    }\r\n\r\n    function getIndexOfTokenInTokensOfOwner(address owner, address token) public view returns (uint) {\r\n        require (ownerOf[token] == owner, \"owner does not own this token\");\r\n        return indexOfTokenInTokensOfOwner[owner][token];\r\n    }\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    event Approval(address indexed owner, address indexed approved, address indexed token);\r\n    event Transfer(address indexed from, address indexed to, address indexed token);\r\n    event TokenOffered(address indexed token, uint minValue, address indexed toAddress);\r\n    event TokenBidEntered(address indexed token, uint value, address indexed fromAddress);\r\n    event TokenBidWithdrawn(address indexed token, uint value, address indexed fromAddress);\r\n    event TokenBought(address indexed token, uint value, address indexed fromAddress, address indexed toAddress);\r\n    event TokenNoLongerForSale(address indexed token);\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"}],\"name\":\"TokenBidEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"}],\"name\":\"TokenBidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenNoLongerForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"TokenOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TangleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"}],\"name\":\"acceptBidForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdministrator\",\"type\":\"address\"}],\"name\":\"changeAdministrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"changeFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinTangleToTaxEvade\",\"type\":\"uint256\"}],\"name\":\"changeMinTangleToTaxEvade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTangleAddress\",\"type\":\"address\"}],\"name\":\"changeTangleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enterBidForToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getIndexOfTokenInTokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTaxConstant\",\"type\":\"uint256\"}],\"name\":\"increaseTaxConstant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexOfTokenInTokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTangleToTaxEvade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"offerTokenForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"}],\"name\":\"offerTokenForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenApprovals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBids\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasBid\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenLogo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenNoLongerForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensOfferedForSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isForSale\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onlySellTo\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensBought\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValueTransferred\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawBidForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Meta","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://446d71b06b3efec6ebd84f6e91b0c5c807f995f459aae3056325459d8231213f"}]}