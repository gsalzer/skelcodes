{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/products/UniswapV3Product.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"../interface/UniswapV3/IUniswapV3Pool.sol\\\";\\nimport \\\"../interface/UniswapV3/IUniswapV3Factory.sol\\\";\\n\\nimport \\\"./BaseProduct.sol\\\";\\n\\n\\n/**\\n * @title UniswapV3Product\\n * @author solace.fi\\n * @notice The **UniswapV3Product** can be used to purchase coverage for **UniswapV3 LP** positions.\\n */\\ncontract UniswapV3Product is BaseProduct {\\n\\n    IUniswapV3Factory internal _uniV3Factory;\\n\\n    /**\\n      * @notice Constructs the UniswapV3Product.\\n      * @param governance_ The address of the [governor](/docs/protocol/governance).\\n      * @param policyManager_ The [`PolicyManager`](../PolicyManager) contract.\\n      * @param registry_ The [`Registry`](../Registry) contract.\\n      * @param uniV3Factory_ The UniswapV3Product Factory.\\n      * @param minPeriod_ The minimum policy period in blocks to purchase a **policy**.\\n      * @param maxPeriod_ The maximum policy period in blocks to purchase a **policy**.\\n     */\\n    constructor (\\n        address governance_,\\n        IPolicyManager policyManager_,\\n        IRegistry registry_,\\n        address uniV3Factory_,\\n        uint40 minPeriod_,\\n        uint40 maxPeriod_\\n    ) BaseProduct(\\n        governance_,\\n        policyManager_,\\n        registry_,\\n        uniV3Factory_,\\n        minPeriod_,\\n        maxPeriod_,\\n        \\\"Solace.fi-UniswapV3Product\\\",\\n        \\\"1\\\"\\n    ) {\\n        _uniV3Factory = IUniswapV3Factory(uniV3Factory_);\\n        _SUBMIT_CLAIM_TYPEHASH = keccak256(\\\"UniswapV3ProductSubmitClaim(uint256 policyID,address claimant,uint256 amountOut,uint256 deadline)\\\");\\n        _productName = \\\"UniswapV3\\\";\\n    }\\n\\n    /**\\n     * @notice Uniswap V2 Factory.\\n     * @return uniV3Factory_ The factory.\\n     */\\n    function uniV2Factory() external view returns (address uniV3Factory_) {\\n        return address(_uniV3Factory);\\n    }\\n\\n    /**\\n     * @notice Determines if the byte encoded description of a position(s) is valid.\\n     * The description will only make sense in context of the product.\\n     * @dev This function should be overwritten in inheriting Product contracts.\\n     * If invalid, return false if possible. Reverting is also acceptable.\\n     * @param positionDescription The description to validate.\\n     * @return isValid True if is valid.\\n     */\\n    function isValidPositionDescription(bytes memory positionDescription) public view virtual override returns (bool isValid) {\\n        // check length\\n        // solhint-disable-next-line var-name-mixedcase\\n        uint256 ADDRESS_SIZE = 20;\\n        // must be concatenation of one or more addresses\\n        if(positionDescription.length == 0 || positionDescription.length % ADDRESS_SIZE != 0) return false;\\n        // check all addresses in list\\n        for(uint256 offset = 0; offset < positionDescription.length; offset += ADDRESS_SIZE) {\\n            // get next address\\n            address positionContract;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                positionContract := div(mload(add(add(positionDescription, 0x20), offset)), 0x1000000000000000000000000)\\n            }\\n            // must be UniswapV3 Pool\\n            IUniswapV3Pool uniswapV3Pool = IUniswapV3Pool(positionContract);\\n            address pool = _uniV3Factory.getPool(uniswapV3Pool.token0(), uniswapV3Pool.token1(), uniswapV3Pool.fee());\\n            if (pool != address(uniswapV3Pool)) return false;\\n        }\\n        return true;\\n    }\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Changes the covered platform.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @dev Use this if the the protocol changes their registry but keeps the children contracts.\\n     * A new version of the protocol will likely require a new Product.\\n     * @param uniV3Factory_ The new Address Provider.\\n     */\\n    function setCoveredPlatform(address uniV3Factory_) public override {\\n        super.setCoveredPlatform(uniV3Factory_);\\n        _uniV3Factory = IUniswapV3Factory(uniV3Factory_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/UniswapV3/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// code borrowed from @uniswap/v3-core\\npragma solidity 0.8.6;\\n\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// feeGrowthOutsideX128 values can only be used if the tick is initialized,\\n    /// i.e. if liquidityGross is greater than 0. In addition, these values are only relative and are used to\\n    /// compute snapshots.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns 8 packed tick seconds outside values. See SecondsOutside for more information\\n    function secondsOutside(int24 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the current tick multiplied by seconds elapsed for the life of the pool as of the\\n    /// observation,\\n    /// Returns liquidityCumulative the current liquidity multiplied by seconds elapsed for the life of the pool as of\\n    /// the observation,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 liquidityCumulative,\\n            bool initialized\\n        );\\n}\\n\\n/// @title Pool state that is not stored\\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n/// blockchain. The functions here may have variable gas costs.\\ninterface IUniswapV3PoolDerivedState {\\n    /// @notice Returns a relative timestamp value representing how long, in seconds, the pool has spent between\\n    /// tickLower and tickUpper\\n    /// @dev This timestamp is strictly relative. To get a useful elapsed time (i.e., duration) value, the value returned\\n    /// by this method should be checkpointed externally after a position is minted, and again before a position is\\n    /// burned. Thus the external contract must control the lifecycle of the position.\\n    /// @param tickLower The lower tick of the range for which to get the seconds inside\\n    /// @param tickUpper The upper tick of the range for which to get the seconds inside\\n    /// @return A relative timestamp for how long the pool spent in the tick range\\n    function secondsInside(int24 tickLower, int24 tickUpper) external view returns (uint32);\\n\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n    /// you must call it with secondsAgos = [3600, 0].\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n    /// @return liquidityCumulatives Cumulative liquidity-in-range value as of each `secondsAgos` from the current block\\n    /// timestamp\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (int56[] memory tickCumulatives, uint160[] memory liquidityCumulatives);\\n}\\n\\n/// @title Permissionless pool actions\\n/// @notice Contains pool methods that can be called by anyone\\ninterface IUniswapV3PoolActions {\\n    /// @notice Sets the initial price for the pool\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    /// @param data Any data that should be passed through to the callback\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount,\\n        bytes calldata data\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n    /// @param recipient The address which should receive the fees collected\\n    /// @param tickLower The lower tick of the position for which to collect fees\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n    /// @dev Fees must be collected separately via a call to #collect\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\n    /// @param amount How much liquidity to burn\\n    /// @return amount0 The amount of token0 sent to the recipient\\n    /// @return amount1 The amount of token1 sent to the recipient\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\\n/// @title Permissioned pool actions\\n/// @notice Contains pool methods that may only be called by the factory owner\\ninterface IUniswapV3PoolOwnerActions {\\n    /// @notice Set the denominator of the protocol's % share of the fees\\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\\n\\n    /// @notice Collect the protocol fee accrued to the pool\\n    /// @param recipient The address to which collected protocol fees should be sent\\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\\n    /// @return amount0 The protocol fee collected in token0\\n    /// @return amount1 The protocol fee collected in token1\\n    function collectProtocol(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\\n/// @title Events emitted by a pool\\n/// @notice Contains all events emitted by the pool\\ninterface IUniswapV3PoolEvents {\\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\\n\\n    /// @notice Emitted when liquidity is minted for a given position\\n    /// @param sender The address that minted the liquidity\\n    /// @param owner The owner of the position and recipient of any minted liquidity\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity minted to the position range\\n    /// @param amount0 How much token0 was required for the minted liquidity\\n    /// @param amount1 How much token1 was required for the minted liquidity\\n    event Mint(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when fees are collected by the owner of a position\\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n    /// @param owner The owner of the position for which fees are collected\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount0 The amount of token0 fees collected\\n    /// @param amount1 The amount of token1 fees collected\\n    event Collect(\\n        address indexed owner,\\n        address recipient,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount0,\\n        uint128 amount1\\n    );\\n\\n    /// @notice Emitted when a position's liquidity is removed\\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n    /// @param owner The owner of the position for which liquidity is removed\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity to remove\\n    /// @param amount0 The amount of token0 withdrawn\\n    /// @param amount1 The amount of token1 withdrawn\\n    event Burn(\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted by the pool for any swaps between token0 and token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the output of the swap\\n    /// @param amount0 The delta of the token0 balance of the pool\\n    /// @param amount1 The delta of the token1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param tick The log base 1.0001 of price of the pool after the swap\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        int256 amount0,\\n        int256 amount1,\\n        uint160 sqrtPriceX96,\\n        int24 tick\\n    );\\n\\n    /// @notice Emitted by the pool for any flashes of token0/token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the tokens from flash\\n    /// @param amount0 The amount of token0 that was flashed\\n    /// @param amount1 The amount of token1 that was flashed\\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n    event Flash(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 paid0,\\n        uint256 paid1\\n    );\\n\\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n    /// just before a mint/swap/burn.\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaseObservationCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    /// @notice Emitted when the protocol fee is changed by the pool\\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\\n\\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\\n    /// @param sender The address that collects the protocol fees\\n    /// @param recipient The address that receives the collected protocol fees\\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\\n}\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\n// solhint-disable-next-line no-empty-blocks\\ninterface IUniswapV3Pool is\\n    IUniswapV3PoolImmutables,\\n    IUniswapV3PoolState,\\n    IUniswapV3PoolDerivedState,\\n    IUniswapV3PoolActions,\\n    IUniswapV3PoolOwnerActions,\\n    IUniswapV3PoolEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interface/UniswapV3/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// code borrowed from @uniswap/v3-core\\npragma solidity 0.8.6;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"contracts/products/BaseProduct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"../Governable.sol\\\";\\nimport \\\"../interface/IPolicyManager.sol\\\";\\nimport \\\"../interface/IRiskManager.sol\\\";\\nimport \\\"../interface/ITreasury.sol\\\";\\nimport \\\"../interface/IClaimsEscrow.sol\\\";\\nimport \\\"../interface/IRegistry.sol\\\";\\nimport \\\"../interface/IProduct.sol\\\";\\n\\n\\n/**\\n * @title BaseProduct\\n * @author solace.fi\\n * @notice The abstract smart contract that is inherited by every concrete individual **Product** contract.\\n *\\n * It is required to extend [`IProduct`](../interface/IProduct) and recommended to extend `BaseProduct`. `BaseProduct` extends [`IProduct`](../interface/IProduct) and takes care of the heavy lifting; new products simply need to set some variables in the constructor. It has some helpful functionality not included in [`IProduct`](../interface/IProduct) including claim signers.\\n */\\nabstract contract BaseProduct is IProduct, EIP712, ReentrancyGuard, Governable {\\n    using Address for address;\\n\\n    /***************************************\\n    GLOBAL VARIABLES\\n    ***************************************/\\n\\n    /// @notice Policy Manager.\\n    IPolicyManager internal _policyManager; // Policy manager ERC721 contract\\n\\n    // Registry.\\n    IRegistry internal _registry;\\n\\n    /// @notice The minimum policy period in blocks.\\n    uint40 internal _minPeriod;\\n    /// @notice The maximum policy period in blocks.\\n    uint40 internal _maxPeriod;\\n    /// @notice Covered platform.\\n    /// A platform contract which locates contracts that are covered by this product.\\n    /// (e.g., UniswapProduct will have Factory as coveredPlatform contract, because every Pair address can be located through getPool() function).\\n    address internal _coveredPlatform;\\n    /// @notice Cannot buy new policies while paused. (Default is False)\\n    bool internal _paused;\\n\\n    /****\\n        Book-Keeping Variables\\n    ****/\\n    /// @notice The current amount covered (in wei).\\n    uint256 internal _activeCoverAmount;\\n    /// @notice The authorized signers.\\n    mapping(address => bool) internal _isAuthorizedSigner;\\n\\n    // Typehash for claim submissions.\\n    // Must be unique for all products.\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 internal _SUBMIT_CLAIM_TYPEHASH;\\n\\n    // The name of the product.\\n    string internal _productName;\\n\\n    // used in our floating point price math\\n    // price is measured in wei per block per wei of coverage * Q12\\n    // divide by Q12 to get premium\\n    uint256 internal constant Q12 = 1e12;\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a claim signer is added.\\n    event SignerAdded(address indexed signer);\\n    /// @notice Emitted when a claim signer is removed.\\n    event SignerRemoved(address indexed signer);\\n\\n    modifier whileUnpaused() {\\n        require(!_paused, \\\"cannot buy when paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Constructs the product. `BaseProduct` by itself is not deployable, only its subclasses.\\n     * @param governance_ The governor.\\n     * @param policyManager_ The IPolicyManager contract.\\n     * @param registry_ The IRegistry contract.\\n     * @param coveredPlatform_ A platform contract which locates contracts that are covered by this product.\\n     * @param minPeriod_ The minimum policy period in blocks to purchase a **policy**.\\n     * @param maxPeriod_ The maximum policy period in blocks to purchase a **policy**.\\n     * @param domain_ The user readable name of the EIP712 signing domain.\\n     * @param version_ The current major version of the signing domain.\\n     */\\n    constructor (\\n        address governance_,\\n        IPolicyManager policyManager_,\\n        IRegistry registry_,\\n        address coveredPlatform_,\\n        uint40 minPeriod_,\\n        uint40 maxPeriod_,\\n        string memory domain_,\\n        string memory version_\\n    ) EIP712(domain_, version_) Governable(governance_) {\\n        require(address(registry_) != address(0x0), \\\"zero address registry\\\");\\n        _registry = registry_;\\n        require(address(policyManager_) != address(0x0), \\\"zero address policymanager\\\");\\n        _policyManager = policyManager_;\\n        require(coveredPlatform_ != address(0x0), \\\"zero address coveredplatform\\\");\\n        _coveredPlatform = coveredPlatform_;\\n        require(minPeriod_ <= maxPeriod_, \\\"invalid period\\\");\\n        _minPeriod = minPeriod_;\\n        _maxPeriod = maxPeriod_;\\n    }\\n\\n    /***************************************\\n    POLICYHOLDER FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Purchases and mints a policy on the behalf of the policyholder.\\n     * User will need to pay **ETH**.\\n     * @param policyholder Holder of the position(s) to cover.\\n     * @param coverAmount The value to cover in **ETH**.\\n     * @param blocks The length (in blocks) for policy.\\n     * @param positionDescription A byte encoded description of the position(s) to cover.\\n     * @return policyID The ID of newly created policy.\\n     */\\n    function buyPolicy(address policyholder, uint256 coverAmount, uint40 blocks, bytes memory positionDescription) external payable override nonReentrant whileUnpaused returns (uint256 policyID) {\\n        require(policyholder != address(0x0), \\\"zero address\\\");\\n        require(coverAmount > 0, \\\"zero cover value\\\");\\n        require(isValidPositionDescription(positionDescription), \\\"invalid position description\\\");\\n        // check that the product can provide coverage for this policy\\n        (bool acceptable, uint24 price) = IRiskManager(_registry.riskManager()).assessRisk(address(this), 0, coverAmount);\\n        require(acceptable, \\\"cannot accept that risk\\\");\\n        // check that the buyer has paid the correct premium\\n        uint256 premium = coverAmount * blocks * price / Q12;\\n        require(msg.value >= premium && premium != 0, \\\"insufficient payment\\\");\\n        // check that the buyer provided valid period\\n        require(blocks >= _minPeriod && blocks <= _maxPeriod, \\\"invalid period\\\");\\n        // create the policy\\n        uint40 expirationBlock = uint40(block.number + blocks);\\n        policyID = _policyManager.createPolicy(policyholder, coverAmount, expirationBlock, price, positionDescription);\\n        // update local book-keeping variables\\n        _activeCoverAmount += coverAmount;\\n        // return excess payment\\n        if(msg.value > premium) Address.sendValue(payable(msg.sender), msg.value - premium);\\n        // transfer premium to the treasury\\n        ITreasury(payable(_registry.treasury())).routePremiums{value: premium}();\\n        emit PolicyCreated(policyID);\\n        return policyID;\\n    }\\n\\n    /**\\n     * @notice Increase or decrease the cover amount of the policy.\\n     * User may need to pay **ETH** for increased cover amount or receive a refund for decreased cover amount.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     * @param coverAmount The new value to cover in **ETH**.\\n     */\\n    function updateCoverAmount(uint256 policyID, uint256 coverAmount) external payable override nonReentrant whileUnpaused {\\n        require(coverAmount > 0, \\\"zero cover value\\\");\\n        (address policyholder, address product, uint256 previousCoverAmount, uint40 expirationBlock, uint24 purchasePrice, bytes memory positionDescription) = _policyManager.getPolicyInfo(policyID);\\n        // check msg.sender is policyholder\\n        require(policyholder == msg.sender, \\\"!policyholder\\\");\\n        // check for correct product\\n        require(product == address(this), \\\"wrong product\\\");\\n        // check for policy expiration\\n        require(expirationBlock >= block.number, \\\"policy is expired\\\");\\n        // check that the product can provide coverage for this policy\\n        (bool acceptable, uint24 price) = IRiskManager(_registry.riskManager()).assessRisk(address(this), previousCoverAmount, coverAmount);\\n        require(acceptable, \\\"cannot accept that risk\\\");\\n        // update local book-keeping variables\\n        _activeCoverAmount = _activeCoverAmount + coverAmount - previousCoverAmount;\\n        // calculate premium needed for new cover amount as if policy is bought now\\n        uint256 remainingBlocks = expirationBlock - block.number;\\n        uint256 newPremium = coverAmount * remainingBlocks * price / Q12;\\n        // calculate premium already paid based on current policy\\n        uint256 paidPremium = previousCoverAmount * remainingBlocks * purchasePrice / Q12;\\n        if (newPremium >= paidPremium) {\\n            uint256 premium = newPremium - paidPremium;\\n            // check that the buyer has paid the correct premium\\n            require(msg.value >= premium, \\\"insufficient payment\\\");\\n            if(msg.value > premium) Address.sendValue(payable(msg.sender), msg.value - premium);\\n            // transfer premium to the treasury\\n            ITreasury(payable(_registry.treasury())).routePremiums{value: premium}();\\n        } else {\\n            if(msg.value > 0) Address.sendValue(payable(msg.sender), msg.value);\\n            uint256 refundAmount = paidPremium - newPremium;\\n            ITreasury(payable(_registry.treasury())).refund(msg.sender, refundAmount);\\n        }\\n        // update policy's URI and emit event\\n        _policyManager.setPolicyInfo(policyID, coverAmount, expirationBlock, price, positionDescription);\\n        emit PolicyUpdated(policyID);\\n    }\\n\\n    /**\\n     * @notice Extend a policy.\\n     * User will need to pay **ETH**.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     * @param extension The length of extension in blocks.\\n     */\\n    function extendPolicy(uint256 policyID, uint40 extension) external payable override nonReentrant whileUnpaused {\\n        // check that the msg.sender is the policyholder\\n        (address policyholder, address product, uint256 coverAmount, uint40 expirationBlock, uint24 purchasePrice, bytes memory positionDescription) = _policyManager.getPolicyInfo(policyID);\\n        require(policyholder == msg.sender,\\\"!policyholder\\\");\\n        require(product == address(this), \\\"wrong product\\\");\\n        require(expirationBlock >= block.number, \\\"policy is expired\\\");\\n        // compute the premium\\n        uint256 premium = coverAmount * extension * purchasePrice / Q12;\\n        // check that the buyer has paid the correct premium\\n        require(msg.value >= premium, \\\"insufficient payment\\\");\\n        if(msg.value > premium) Address.sendValue(payable(msg.sender), msg.value - premium);\\n        // transfer premium to the treasury\\n        ITreasury(payable(_registry.treasury())).routePremiums{value: premium}();\\n        // check that the buyer provided valid period\\n        uint40 newExpirationBlock = expirationBlock + extension;\\n        uint40 duration = newExpirationBlock - uint40(block.number);\\n        require(duration >= _minPeriod && duration <= _maxPeriod, \\\"invalid period\\\");\\n        // update the policy's URI\\n        _policyManager.setPolicyInfo(policyID, coverAmount, newExpirationBlock, purchasePrice, positionDescription);\\n        emit PolicyExtended(policyID);\\n    }\\n\\n    /**\\n     * @notice Extend a policy and update its cover amount.\\n     * User may need to pay **ETH** for increased cover amount or receive a refund for decreased cover amount.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     * @param coverAmount The new value to cover in **ETH**.\\n     * @param extension The length of extension in blocks.\\n     */\\n    function updatePolicy(uint256 policyID, uint256 coverAmount, uint40 extension) external payable override nonReentrant whileUnpaused {\\n        require(coverAmount > 0, \\\"zero cover value\\\");\\n        (address policyholder, address product, uint256 previousCoverAmount, uint40 previousExpirationBlock, uint24 purchasePrice, bytes memory positionDescription) = _policyManager.getPolicyInfo(policyID);\\n        require(policyholder == msg.sender,\\\"!policyholder\\\");\\n        require(product == address(this), \\\"wrong product\\\");\\n        require(previousExpirationBlock >= block.number, \\\"policy is expired\\\");\\n        // check that the product can provide coverage for this policy\\n        (bool acceptable, uint24 price) = IRiskManager(_registry.riskManager()).assessRisk(address(this), previousCoverAmount, coverAmount);\\n        require(acceptable, \\\"cannot accept that risk\\\");\\n        // add new block extension\\n        uint40 newExpirationBlock = previousExpirationBlock + extension;\\n        // check if duration is valid\\n        uint40 duration = newExpirationBlock - uint40(block.number);\\n        require(duration >= _minPeriod && duration <= _maxPeriod, \\\"invalid period\\\");\\n        // update local book-keeping variables\\n        _activeCoverAmount = _activeCoverAmount + coverAmount - previousCoverAmount;\\n        // update policy info\\n        _policyManager.setPolicyInfo(policyID, coverAmount, newExpirationBlock, price, positionDescription);\\n        // calculate premium needed for new cover amount as if policy is bought now\\n        uint256 newPremium = coverAmount * duration * price / Q12;\\n        // calculate premium already paid based on current policy\\n        uint256 paidPremium = previousCoverAmount * (previousExpirationBlock - uint40(block.number)) * purchasePrice / Q12;\\n        if (newPremium >= paidPremium) {\\n            uint256 premium = newPremium - paidPremium;\\n            require(msg.value >= premium, \\\"insufficient payment\\\");\\n            if(msg.value > premium) Address.sendValue(payable(msg.sender), msg.value - premium);\\n            ITreasury(payable(_registry.treasury())).routePremiums{value: premium}();\\n        } else {\\n            if(msg.value > 0) Address.sendValue(payable(msg.sender), msg.value);\\n            uint256 refund = paidPremium - newPremium;\\n            ITreasury(payable(_registry.treasury())).refund(msg.sender, refund);\\n        }\\n        emit PolicyUpdated(policyID);\\n    }\\n\\n    /**\\n     * @notice Cancel and burn a policy.\\n     * User will receive a refund for the remaining blocks.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     */\\n    function cancelPolicy(uint256 policyID) external override nonReentrant {\\n        (address policyholder, address product, uint256 coverAmount, uint40 expirationBlock, uint24 purchasePrice, ) = _policyManager.getPolicyInfo(policyID);\\n        require(policyholder == msg.sender,\\\"!policyholder\\\");\\n        require(product == address(this), \\\"wrong product\\\");\\n        uint40 blocksLeft = expirationBlock - uint40(block.number);\\n        uint256 refundAmount = blocksLeft * coverAmount * purchasePrice / Q12;\\n        _policyManager.burn(policyID);\\n        ITreasury(payable(_registry.treasury())).refund(msg.sender, refundAmount);\\n        _activeCoverAmount -= coverAmount;\\n        emit PolicyCanceled(policyID);\\n    }\\n\\n    /**\\n     * @notice Submit a claim.\\n     * The user can only submit one claim per policy and the claim must be signed by an authorized signer.\\n     * If successful the policy is burnt and a new claim is created.\\n     * The new claim will be in [`ClaimsEscrow`](../ClaimsEscrow) and have the same ID as the policy.\\n     * Can only be called by the policyholder.\\n     * @param policyID The policy that suffered a loss.\\n     * @param amountOut The amount the user will receive.\\n     * @param deadline Transaction must execute before this timestamp.\\n     * @param signature Signature from the signer.\\n     */\\n    function submitClaim(\\n        uint256 policyID,\\n        uint256 amountOut,\\n        uint256 deadline,\\n        bytes calldata signature\\n    ) external nonReentrant {\\n        // validate inputs\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp <= deadline, \\\"expired deadline\\\");\\n        (address policyholder, address product, uint256 coverAmount, , , ) = _policyManager.getPolicyInfo(policyID);\\n        require(policyholder == msg.sender, \\\"!policyholder\\\");\\n        require(product == address(this), \\\"wrong product\\\");\\n        require(amountOut <= coverAmount, \\\"excessive amount out\\\");\\n        // verify signature\\n        {\\n        bytes32 structHash = keccak256(abi.encode(_SUBMIT_CLAIM_TYPEHASH, policyID, msg.sender, amountOut, deadline));\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n        address signer = ECDSA.recover(hash, signature);\\n        require(_isAuthorizedSigner[signer], \\\"invalid signature\\\");\\n        }\\n        // update local book-keeping variables\\n        _activeCoverAmount -= coverAmount;\\n        // burn policy\\n        _policyManager.burn(policyID);\\n        // submit claim to ClaimsEscrow\\n        IClaimsEscrow(payable(_registry.claimsEscrow())).receiveClaim(policyID, policyholder, amountOut);\\n        emit ClaimSubmitted(policyID);\\n    }\\n\\n    /***************************************\\n    QUOTE VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Calculate a premium quote for a policy.\\n     * @param coverAmount The value to cover in **ETH**.\\n     * @param blocks The duration of the policy in blocks.\\n     * @return premium The quote for their policy in **ETH**.\\n     */\\n    function getQuote(uint256 coverAmount, uint40 blocks) external view override returns (uint256 premium) {\\n        (, uint24 price, ) = IRiskManager(_registry.riskManager()).productRiskParams(address(this));\\n        return coverAmount * blocks * price / Q12;\\n    }\\n\\n    /***************************************\\n    GLOBAL VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice The minimum policy period in blocks.\\n    function minPeriod() external view override returns (uint40) {\\n        return _minPeriod;\\n    }\\n\\n    /// @notice The maximum policy period in blocks.\\n    function maxPeriod() external view override returns (uint40) {\\n        return _maxPeriod;\\n    }\\n\\n    /// @notice Covered platform.\\n    /// A platform contract which locates contracts that are covered by this product.\\n    /// (e.g., `UniswapProduct` will have `Factory` as `coveredPlatform` contract, because every `Pair` address can be located through `getPool()` function).\\n    function coveredPlatform() external view override returns (address) {\\n        return _coveredPlatform;\\n    }\\n    /// @notice The current amount covered (in wei).\\n    function activeCoverAmount() external view override returns (uint256) {\\n        return _activeCoverAmount;\\n    }\\n\\n    /**\\n     * @notice Returns the name of the product.\\n     * @return productName The name of the product.\\n     */\\n    function name() external view virtual override returns (string memory productName) {\\n        return _productName;\\n    }\\n\\n    /// @notice Returns whether or not product is currently in paused state.\\n    function paused() external view override returns (bool) {\\n        return _paused;\\n    }\\n\\n    /// @notice Address of the [`PolicyManager`](../PolicyManager).\\n    function policyManager() external view override returns (address) {\\n        return address(_policyManager);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given account is authorized to sign claims.\\n     * @param account Potential signer to query.\\n     * @return status True if is authorized signer.\\n     */\\n     function isAuthorizedSigner(address account) external view override returns (bool status) {\\n        return _isAuthorizedSigner[account];\\n     }\\n\\n     /**\\n      * @notice Determines if the byte encoded description of a position(s) is valid.\\n      * The description will only make sense in context of the product.\\n      * @dev This function should be overwritten in inheriting Product contracts.\\n      * If invalid, return false if possible. Reverting is also acceptable.\\n      * @param positionDescription The description to validate.\\n      * @return isValid True if is valid.\\n      */\\n     function isValidPositionDescription(bytes memory positionDescription) public view virtual returns (bool isValid);\\n\\n    /***************************************\\n    MUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Updates the product's book-keeping variables.\\n     * Can only be called by the [`PolicyManager`](../PolicyManager).\\n     * @param coverDiff The change in active cover amount.\\n     */\\n    function updateActiveCoverAmount(int256 coverDiff) external override {\\n        require(msg.sender == address(_policyManager), \\\"!policymanager\\\");\\n        _activeCoverAmount = add(_activeCoverAmount, coverDiff);\\n    }\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets the minimum number of blocks a policy can be purchased for.\\n     * @param minPeriod_ The minimum number of blocks.\\n     */\\n    function setMinPeriod(uint40 minPeriod_) external override onlyGovernance {\\n        require(minPeriod_ <= _maxPeriod, \\\"invalid period\\\");\\n        _minPeriod = minPeriod_;\\n        emit MinPeriodSet(minPeriod_);\\n    }\\n\\n    /**\\n     * @notice Sets the maximum number of blocks a policy can be purchased for.\\n     * @param maxPeriod_ The maximum number of blocks\\n     */\\n    function setMaxPeriod(uint40 maxPeriod_) external override onlyGovernance {\\n        require(_minPeriod <= maxPeriod_, \\\"invalid period\\\");\\n        _maxPeriod = maxPeriod_;\\n        emit MaxPeriodSet(maxPeriod_);\\n    }\\n\\n    /**\\n     * @notice Adds a new signer that can authorize claims.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param signer The signer to add.\\n     */\\n    function addSigner(address signer) external onlyGovernance {\\n        require(signer != address(0x0), \\\"zero address signer\\\");\\n        _isAuthorizedSigner[signer] = true;\\n        emit SignerAdded(signer);\\n    }\\n\\n    /**\\n     * @notice Removes a signer.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param signer The signer to remove.\\n     */\\n    function removeSigner(address signer) external onlyGovernance {\\n        _isAuthorizedSigner[signer] = false;\\n        emit SignerRemoved(signer);\\n    }\\n\\n    /**\\n     * @notice Pauses or unpauses buying and extending policies.\\n     * Cancelling policies and submitting claims are unaffected by pause.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @dev Used for security and to gracefully phase out old products.\\n     * @param paused_ True to pause, false to unpause.\\n     */\\n    function setPaused(bool paused_) external onlyGovernance {\\n        _paused = paused_;\\n        emit PauseSet(paused_);\\n    }\\n\\n    /**\\n     * @notice Changes the covered platform.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @dev Use this if the the protocol changes their registry but keeps the children contracts.\\n     * A new version of the protocol will likely require a new Product.\\n     * @param coveredPlatform_ The platform to cover.\\n     */\\n    function setCoveredPlatform(address coveredPlatform_) public virtual override onlyGovernance {\\n        require(coveredPlatform_ != address(0x0), \\\"zero address coveredplatform\\\");\\n        _coveredPlatform = coveredPlatform_;\\n        emit CoveredPlatformSet(coveredPlatform_);\\n    }\\n\\n    /**\\n     * @notice Changes the policy manager.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param policyManager_ The new policy manager.\\n     */\\n    function setPolicyManager(address policyManager_) external override onlyGovernance {\\n        require(policyManager_ != address(0x0), \\\"zero address policymanager\\\");\\n        _policyManager = IPolicyManager(policyManager_);\\n        emit PolicyManagerSet(policyManager_);\\n    }\\n\\n    /***************************************\\n    HELPER FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adds two numbers.\\n     * @param a The first number as a uint256.\\n     * @param b The second number as an int256.\\n     * @return c The sum as a uint256.\\n     */\\n    function add(uint256 a, int256 b) internal pure returns (uint256 c) {\\n        return (b > 0)\\n            ? a + uint256(b)\\n            : a - uint256(-b);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./interface/IGovernable.sol\\\";\\n\\n/**\\n * @title Governable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n   * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setPendingGovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./interface/ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ncontract Governable is IGovernable {\\n\\n    /***************************************\\n    GLOBAL VARIABLES\\n    ***************************************/\\n\\n    // Governor.\\n    address private _governance;\\n\\n    // governance to take over.\\n    address private _pendingGovernance;\\n\\n    bool private _locked;\\n\\n    /**\\n     * @notice Constructs the governable contract.\\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\\n     */\\n    constructor(address governance_) {\\n        require(governance_ != address(0x0), \\\"zero address governance\\\");\\n        _governance = governance_;\\n        _pendingGovernance = address(0x0);\\n        _locked = false;\\n    }\\n\\n    /***************************************\\n    MODIFIERS\\n    ***************************************/\\n\\n    // can only be called by governor\\n    // can only be called while unlocked\\n    modifier onlyGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _governance, \\\"!governance\\\");\\n        _;\\n    }\\n\\n    // can only be called by pending governor\\n    // can only be called while unlocked\\n    modifier onlyPendingGovernance() {\\n        require(!_locked, \\\"governance locked\\\");\\n        require(msg.sender == _pendingGovernance, \\\"!pending governance\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() external view override returns (address) {\\n        return _governance;\\n    }\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view override returns (address) {\\n        return _pendingGovernance;\\n    }\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view override returns (bool) {\\n        return _locked;\\n    }\\n\\n    /***************************************\\n    MUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external override onlyGovernance {\\n        _pendingGovernance = pendingGovernance_;\\n        emit GovernancePending(pendingGovernance_);\\n    }\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the pending governor.\\n     */\\n    function acceptGovernance() external override onlyPendingGovernance {\\n        // sanity check against transferring governance to the zero address\\n        // if someone figures out how to sign transactions from the zero address\\n        // consider the entirety of ethereum to be rekt\\n        require(_pendingGovernance != address(0x0), \\\"zero governance\\\");\\n        address oldGovernance = _governance;\\n        _governance = _pendingGovernance;\\n        _pendingGovernance = address(0x0);\\n        emit GovernanceTransferred(oldGovernance, _governance);\\n    }\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external override onlyGovernance {\\n        _locked = true;\\n        // intentionally not using address(0x0), see re-initialization exploit\\n        _governance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        _pendingGovernance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n        emit GovernanceTransferred(msg.sender, address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n        emit GovernanceLocked();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./IERC721Enhanced.sol\\\";\\n\\n/**\\n * @title IPolicyManager\\n * @author solace.fi\\n * @notice The **PolicyManager** manages the creation of new policies and modification of existing policies.\\n *\\n * Most users will not interact with **PolicyManager** directly. To buy, modify, or cancel policies, users should use the respective [**product**](../products/BaseProduct) for the position they would like to cover. Use **PolicyManager** to view policies.\\n *\\n * Policies are [**ERC721s**](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721).\\n */\\ninterface IPolicyManager is IERC721Enhanced {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a policy is created.\\n    event PolicyCreated(uint256 policyID);\\n    /// @notice Emitted when a policy is updated.\\n    event PolicyUpdated(uint256 indexed policyID);\\n    /// @notice Emitted when a policy is burned.\\n    event PolicyBurned(uint256 policyID);\\n    /// @notice Emitted when the policy descriptor is set.\\n    event PolicyDescriptorSet(address policyDescriptor);\\n    /// @notice Emitted when a new product is added.\\n    event ProductAdded(address product);\\n    /// @notice Emitted when a new product is removed.\\n    event ProductRemoved(address product);\\n\\n    /***************************************\\n    POLICY VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice PolicyInfo struct.\\n    struct PolicyInfo {\\n        uint256 coverAmount;\\n        address product;\\n        uint40 expirationBlock;\\n        uint24 price;\\n        bytes positionDescription;\\n    }\\n\\n    /**\\n     * @notice Information about a policy.\\n     * @param policyID The policy ID to return info.\\n     * @return info info in a struct.\\n     */\\n    function policyInfo(uint256 policyID) external view returns (PolicyInfo memory info);\\n\\n    /**\\n     * @notice Information about a policy.\\n     * @param policyID The policy ID to return info.\\n     * @return policyholder The address of the policy holder.\\n     * @return product The product of the policy.\\n     * @return coverAmount The amount covered for the policy.\\n     * @return expirationBlock The expiration block of the policy.\\n     * @return price The price of the policy.\\n     * @return positionDescription The description of the covered position(s).\\n     */\\n    function getPolicyInfo(uint256 policyID) external view returns (address policyholder, address product, uint256 coverAmount, uint40 expirationBlock, uint24 price, bytes calldata positionDescription);\\n\\n    /**\\n     * @notice The holder of the policy.\\n     * @param policyID The policy ID.\\n     * @return policyholder The address of the policy holder.\\n     */\\n    function getPolicyholder(uint256 policyID) external view returns (address policyholder);\\n\\n    /**\\n     * @notice The product used to purchase the policy.\\n     * @param policyID The policy ID.\\n     * @return product The product of the policy.\\n     */\\n    function getPolicyProduct(uint256 policyID) external view returns (address product);\\n\\n    /**\\n     * @notice The expiration block of the policy.\\n     * @param policyID The policy ID.\\n     * @return expirationBlock The expiration block of the policy.\\n     */\\n    function getPolicyExpirationBlock(uint256 policyID) external view returns (uint40 expirationBlock);\\n\\n    /**\\n     * @notice The cover amount of the policy.\\n     * @param policyID The policy ID.\\n     * @return coverAmount The cover amount of the policy.\\n     */\\n    function getPolicyCoverAmount(uint256 policyID) external view returns (uint256 coverAmount);\\n\\n    /**\\n     * @notice The cover price in wei per block per wei multiplied by 1e12.\\n     * @param policyID The policy ID.\\n     * @return price The price of the policy.\\n     */\\n    function getPolicyPrice(uint256 policyID) external view returns (uint24 price);\\n\\n    /**\\n     * @notice The byte encoded description of the covered position(s).\\n     * Only makes sense in context of the product.\\n     * @param policyID The policy ID.\\n     * @return positionDescription The description of the covered position(s).\\n     */\\n    function getPositionDescription(uint256 policyID) external view returns (bytes calldata positionDescription);\\n\\n    /*\\n     * @notice These functions can be used to check a policys stage in the lifecycle.\\n     * There are three major lifecycle events:\\n     *   1 - policy is bought (aka minted)\\n     *   2 - policy expires\\n     *   3 - policy is burnt (aka deleted)\\n     * There are four stages:\\n     *   A - pre-mint\\n     *   B - pre-expiration\\n     *   C - post-expiration\\n     *   D - post-burn\\n     * Truth table:\\n     *               A B C D\\n     *   exists      0 1 1 0\\n     *   isActive    0 1 0 0\\n     *   hasExpired  0 0 1 0\\n\\n    /**\\n     * @notice Checks if a policy is active.\\n     * @param policyID The policy ID.\\n     * @return status True if the policy is active.\\n     */\\n    function policyIsActive(uint256 policyID) external view returns (bool);\\n\\n    /**\\n     * @notice Checks whether a given policy is expired.\\n     * @param policyID The policy ID.\\n     * @return status True if the policy is expired.\\n     */\\n    function policyHasExpired(uint256 policyID) external view returns (bool);\\n\\n    /// @notice The total number of policies ever created.\\n    function totalPolicyCount() external view returns (uint256 count);\\n\\n    /// @notice The address of the [`PolicyDescriptor`](./PolicyDescriptor) contract.\\n    function policyDescriptor() external view returns (address);\\n\\n    /***************************************\\n    POLICY MUTATIVE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Creates a new policy.\\n     * Can only be called by **products**.\\n     * @param policyholder The receiver of new policy token.\\n     * @param coverAmount The policy coverage amount (in wei).\\n     * @param expirationBlock The policy expiration block number.\\n     * @param price The coverage price.\\n     * @param positionDescription The description of the covered position(s).\\n     * @return policyID The policy ID.\\n     */\\n    function createPolicy(\\n        address policyholder,\\n        uint256 coverAmount,\\n        uint40 expirationBlock,\\n        uint24 price,\\n        bytes calldata positionDescription\\n    ) external returns (uint256 policyID);\\n\\n    /**\\n     * @notice Modifies a policy.\\n     * Can only be called by **products**.\\n     * @param policyID The policy ID.\\n     * @param coverAmount The policy coverage amount (in wei).\\n     * @param expirationBlock The policy expiration block number.\\n     * @param price The coverage price.\\n     * @param positionDescription The description of the covered position(s).\\n     */\\n    function setPolicyInfo(uint256 policyID, uint256 coverAmount, uint40 expirationBlock, uint24 price, bytes calldata positionDescription) external;\\n\\n    /**\\n     * @notice Burns expired or cancelled policies.\\n     * Can only be called by **products**.\\n     * @param policyID The ID of the policy to burn.\\n     */\\n    function burn(uint256 policyID) external;\\n\\n    /**\\n     * @notice Burns expired policies.\\n     * @param policyIDs The list of expired policies.\\n     */\\n    function updateActivePolicies(uint256[] calldata policyIDs) external;\\n\\n    /***************************************\\n    PRODUCT VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Checks is an address is an active product.\\n     * @param product The product to check.\\n     * @return status True if the product is active.\\n     */\\n    function productIsActive(address product) external view returns (bool status);\\n\\n    /**\\n     * @notice Returns the number of products.\\n     * @return count The number of products.\\n     */\\n    function numProducts() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Returns the product at the given index.\\n     * @param productNum The index to query.\\n     * @return product The address of the product.\\n     */\\n    function getProduct(uint256 productNum) external view returns (address product);\\n\\n    /***************************************\\n    OTHER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    function activeCoverAmount() external view returns (uint256);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adds a new product.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param product the new product\\n     */\\n    function addProduct(address product) external;\\n\\n    /**\\n     * @notice Removes a product.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param product the product to remove\\n     */\\n    function removeProduct(address product) external;\\n\\n\\n    /**\\n     * @notice Set the token descriptor.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param policyDescriptor The new token descriptor address.\\n     */\\n    function setPolicyDescriptor(address policyDescriptor) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @title IRiskManager\\n * @author solace.fi\\n * @notice Calculates the acceptable risk, sellable cover, and capital requirements of Solace products and capital pool.\\n *\\n * The total amount of sellable coverage is proportional to the assets in the [**risk backing capital pool**](../Vault). The max cover is split amongst products in a weighting system. [**Governance**](/docs/protocol/governance). can change these weights and with it each product's sellable cover.\\n *\\n * The minimum capital requirement is proportional to the amount of cover sold to [active policies](../PolicyManager).\\n *\\n * Solace can use leverage to sell more cover than the available capital. The amount of leverage is stored as [`partialReservesFactor`](#partialreservesfactor) and is settable by [**governance**](/docs/protocol/governance).\\n */\\ninterface IRiskManager {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a product's risk parameters are set.\\n    /// Includes adding and removing products.\\n    event ProductParamsSet(address product, uint32 weight, uint24 price, uint16 divisor);\\n    /// @notice Emitted when the partial reserves factor is set.\\n    event PartialReservesFactorSet(uint16 partialReservesFactor);\\n\\n    /***************************************\\n    MAX COVER VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Struct for a product's risk parameters.\\n    struct ProductRiskParams {\\n        uint32 weight;  // The weighted allocation of this product vs other products.\\n        uint24 price;   // The price in wei per 1e12 wei of coverage per block.\\n        uint16 divisor; // The max cover per policy divisor. (maxCoverPerProduct / divisor = maxCoverPerPolicy)\\n    }\\n\\n    /**\\n     * @notice Given a request for coverage, determines if that risk is acceptable and if so at what price.\\n     * @param product The product that wants to sell coverage.\\n     * @param currentCover If updating an existing policy's cover amount, the current cover amount, otherwise 0.\\n     * @param newCover The cover amount requested.\\n     * @return acceptable True if risk of the new cover is acceptable, false otherwise.\\n     * @return price The price in wei per 1e12 wei of coverage per block.\\n     */\\n    function assessRisk(address product, uint256 currentCover, uint256 newCover) external view returns (bool acceptable, uint24 price);\\n\\n    /**\\n     * @notice The maximum amount of cover that Solace as a whole can sell.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCover() external view returns (uint256 cover);\\n\\n    /**\\n     * @notice The maximum amount of cover that a product can sell in total.\\n     * @param prod The product that wants to sell cover.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCoverPerProduct(address prod) external view returns (uint256 cover);\\n\\n    /**\\n     * @notice The amount of cover that a product can still sell.\\n     * @param prod The product that wants to sell cover.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function sellableCoverPerProduct(address prod) external view returns (uint256 cover);\\n\\n    /**\\n     * @notice The maximum amount of cover that a product can sell in a single policy.\\n     * @param prod The product that wants to sell cover.\\n     * @return cover The max amount of cover in wei.\\n     */\\n    function maxCoverPerPolicy(address prod) external view returns (uint256 cover);\\n\\n    /**\\n     * @notice Checks is an address is an active product.\\n     * @param prod The product to check.\\n     * @return status True if the product is active.\\n     */\\n    function productIsActive(address prod) external view returns (bool status);\\n\\n    /**\\n     * @notice Return the number of registered products.\\n     * @return count Number of products.\\n     */\\n    function numProducts() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Return the product at an index.\\n     * @dev Enumerable `[1, numProducts]`.\\n     * @param index Index to query.\\n     * @return prod The product address.\\n     */\\n    function product(uint256 index) external view returns (address prod);\\n\\n    /**\\n     * @notice Returns a product's risk parameters.\\n     * The product must be active.\\n     * @param prod The product to get parameters for.\\n     * @return weight The weighted allocation of this product vs other products.\\n     * @return price The price in wei per 1e12 wei of coverage per block.\\n     * @return divisor The max cover per policy divisor.\\n     */\\n    function productRiskParams(address prod) external view returns (uint32 weight, uint24 price, uint16 divisor);\\n\\n    /**\\n     * @notice Returns the sum of weights.\\n     * @return sum WeightSum.\\n     */\\n    function weightSum() external view returns (uint32 sum);\\n\\n    /***************************************\\n    MIN CAPITAL VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice The minimum amount of capital required to safely cover all policies.\\n     * @return mcr The minimum capital requirement.\\n     */\\n    function minCapitalRequirement() external view returns (uint256 mcr);\\n\\n    /**\\n     * @notice Multiplier for minimum capital requirement.\\n     * @return factor Partial reserves factor in BPS.\\n     */\\n    function partialReservesFactor() external view returns (uint16 factor);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adds a product.\\n     * If the product is already added, sets its parameters.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param product_ Address of the product.\\n     * @param weight_ The products weight.\\n     * @param price_ The products price in wei per 1e12 wei of coverage per block.\\n     * @param divisor_ The max cover per policy divisor.\\n     */\\n    function addProduct(address product_, uint32 weight_, uint24 price_, uint16 divisor_) external;\\n\\n    /**\\n     * @notice Removes a product.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param product_ Address of the product to remove.\\n     */\\n    function removeProduct(address product_) external;\\n\\n    /**\\n     * @notice Sets the products and their parameters.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param products_ The products.\\n     * @param weights_ The product weights.\\n     * @param prices_ The product prices.\\n     * @param divisors_ The max cover per policy divisors.\\n     */\\n    function setProductParams(address[] calldata products_, uint32[] calldata weights_, uint24[] calldata prices_, uint16[] calldata divisors_) external;\\n\\n    /**\\n     * @notice Sets the partial reserves factor.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param partialReservesFactor_ New partial reserves factor in BPS.\\n     */\\n    function setPartialReservesFactor(uint16 partialReservesFactor_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @title ITreasury\\n * @author solace.fi\\n * @notice The war chest of Castle Solace.\\n *\\n * As policies are purchased, premiums will flow from [**policyholders**](/docs/protocol/policy-holder) to the `Treasury`. By default `Treasury` reroutes 100% of the premiums into the [`Vault`](../Vault) where it is split amongst the [**capital providers**](/docs/user-guides/capital-provider/cp-role-guide).\\n *\\n * If a [**policyholder**](/docs/protocol/policy-holder) updates or cancels a policy they may receive a refund. Refunds will be paid out from the [`Vault`](../Vault). If there are not enough funds to pay out the refund in whole, the [`unpaidRefunds()`](#unpaidrefunds) will be tracked and can be retrieved later via [`withdraw()`](#withdraw).\\n *\\n * [**Governance**](/docs/protocol/governance) can change the premium recipients via [`setPremiumRecipients()`](#setpremiumrecipients). This can be used to add new building blocks to Castle Solace or enact a protocol fee. Premiums can be stored in the `Treasury` and managed with a number of functions.\\n */\\ninterface ITreasury {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a token is spent.\\n    event FundsSpent(address token, uint256 amount, address recipient);\\n    /// @notice Emitted when premium recipients are set.\\n    event RecipientsSet();\\n    /// @notice Emitted when premiums are routed.\\n    event PremiumsRouted(uint256 amount);\\n    /// @notice Emitted when ETH is refunded to a user.\\n    event EthRefunded(address user, uint256 amount);\\n\\n    /***************************************\\n    FUNDS IN\\n    ***************************************/\\n\\n    /**\\n     * @notice Routes the **premiums** to the `recipients`.\\n     * Each recipient will receive a `recipientWeight / weightSum` portion of the premiums.\\n     * Will be called by products with `msg.value = premium`.\\n     */\\n    function routePremiums() external payable;\\n\\n    /**\\n     * @notice Number of premium recipients.\\n     * @return count The number of premium recipients.\\n     */\\n    function numPremiumRecipients() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Gets the premium recipient at `index`.\\n     * @param index Index to query, enumerable `[0, numPremiumRecipients()-1]`.\\n     * @return recipient The receipient address.\\n     */\\n    function premiumRecipient(uint256 index) external view returns (address recipient);\\n\\n    /**\\n     * @notice Gets the weight of the recipient.\\n     * @param index Index to query, enumerable `[0, numPremiumRecipients()]`.\\n     * @return weight The recipient weight.\\n     */\\n    function recipientWeight(uint256 index) external view returns (uint32 weight);\\n\\n    /**\\n     * @notice Gets the sum of all premium recipient weights.\\n     * @return weight The sum of weights.\\n     */\\n    function weightSum() external view returns (uint32 weight);\\n\\n    /***************************************\\n    FUNDS OUT\\n    ***************************************/\\n\\n    /**\\n     * @notice Refunds some **ETH** to the user.\\n     * Will attempt to send the entire `amount` to the `user`.\\n     * If there is not enough available at the moment, it is recorded and can be pulled later via [`withdraw()`](#withdraw).\\n     * Can only be called by active products.\\n     * @param user The user address to send refund amount.\\n     * @param amount The amount to send the user.\\n     */\\n    function refund(address user, uint256 amount) external;\\n\\n    /**\\n     * @notice The amount of **ETH** that a user is owed if any.\\n     * @param user The user.\\n     * @return amount The amount.\\n     */\\n    function unpaidRefunds(address user) external view returns (uint256 amount);\\n\\n    /**\\n     * @notice Transfers the unpaid refunds to the user.\\n     */\\n    function withdraw() external;\\n\\n    /***************************************\\n    FUND MANAGEMENT\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets the premium recipients and their weights.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param recipients The premium recipients, plus an implicit `address(this)` at the end.\\n     * @param weights The recipient weights.\\n     */\\n    function setPremiumRecipients(address payable[] calldata recipients, uint32[] calldata weights) external;\\n\\n    /**\\n     * @notice Spends an **ERC20** token or **ETH**.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param token The address of the token to spend.\\n     * @param amount The amount of the token to spend.\\n     * @param recipient The address of the token receiver.\\n     */\\n    function spend(address token, uint256 amount, address recipient) external;\\n\\n    /**\\n     * @notice Wraps some **ETH** into **WETH**.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param amount The amount to wrap.\\n     */\\n    function wrap(uint256 amount) external;\\n\\n    /**\\n     * @notice Unwraps some **WETH** into **ETH**.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param amount The amount to unwrap.\\n     */\\n    function unwrap(uint256 amount) external;\\n\\n    /***************************************\\n    FALLBACK FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Fallback function to allow contract to receive **ETH**.\\n     */\\n    receive() external payable;\\n\\n    /**\\n     * @notice Fallback function to allow contract to receive **ETH**.\\n     */\\n    fallback () external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IClaimsEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./IERC721Enhanced.sol\\\";\\n\\n/**\\n * @title IClaimsEscrow\\n * @author solace.fi\\n * @notice The payer of claims.\\n *\\n * [**Policyholders**](/docs/protocol/policy-holder) can submit claims through their policy's product contract, in the process burning the policy and converting it to a claim.\\n *\\n * The [**policyholder**](/docs/protocol/policy-holder) will then need to wait for a [`cooldownPeriod()`](#cooldownperiod) after which they can [`withdrawClaimsPayout()`](#withdrawclaimspayout).\\n *\\n * To pay the claims funds are taken from the [`Vault`](../Vault) and deducted from [**capital provider**](/docs/user-guides/capital-provider/cp-role-guide) earnings.\\n *\\n * Claims are **ERC721**s and abbreviated as **SCT**.\\n */\\ninterface IClaimsEscrow is IERC721Enhanced {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a new claim is received.\\n    event ClaimReceived(uint256 indexed claimID, address indexed claimant, uint256 amount);\\n    /// @notice Emitted when a claim is paid out.\\n    event ClaimWithdrawn(uint256 indexed claimID, address indexed claimant, uint256 amount);\\n    /// @notice Emitted when a claim is adjusted.\\n    event ClaimAdjusted(uint256 indexed claimID, address indexed claimant, uint256 oldAmount, uint256 newAmount);\\n    /// @notice Emitted when ETH is returned to the Vault.\\n    event EthReturned(uint256 amount);\\n    /// @notice Emitted when the cooldown period is set.\\n    event CooldownPeriodSet(uint256 cooldownPeriod);\\n\\n    /***************************************\\n    CLAIM CREATION\\n    ***************************************/\\n\\n    /**\\n     * @notice Receives a claim.\\n     * The new claim will have the same ID that the policy had and will be withdrawable after a cooldown period.\\n     * Only callable by active products.\\n     * @param policyID ID of policy to claim.\\n     * @param claimant Address of the claimant.\\n     * @param amount Amount of ETH to claim.\\n     */\\n    function receiveClaim(uint256 policyID, address claimant, uint256 amount) external payable;\\n\\n    /***************************************\\n    CLAIM PAYOUT\\n    ***************************************/\\n\\n    /**\\n     * @notice Allows claimants to withdraw their claims payout.\\n     * Will attempt to withdraw the full amount then burn the claim if successful.\\n     * Only callable by the claimant.\\n     * Only callable after the cooldown period has elapsed (from the time the claim was approved and processed).\\n     * @param claimID The ID of the claim to withdraw payout for.\\n     */\\n    function withdrawClaimsPayout(uint256 claimID) external;\\n\\n    /***************************************\\n    CLAIM VIEW\\n    ***************************************/\\n\\n    /// @notice Claim struct.\\n    struct Claim {\\n        uint256 amount;\\n        uint256 receivedAt; // used to determine withdrawability after cooldown period\\n    }\\n\\n    /**\\n     * @notice Gets information about a claim.\\n     * @param claimID Claim to query.\\n     * @return info Claim info as struct.\\n     */\\n    function claim(uint256 claimID) external view returns (Claim memory info);\\n\\n    /**\\n     * @notice Gets information about a claim.\\n     * @param claimID Claim to query.\\n     * @return amount Claim amount in ETH.\\n     * @return receivedAt Time claim was received at.\\n     */\\n    function getClaim(uint256 claimID) external view returns (uint256 amount, uint256 receivedAt);\\n\\n    /**\\n     * @notice Returns true if the payout of the claim can be withdrawn.\\n     * @param claimID The ID to check.\\n     * @return status True if it is withdrawable, false if not.\\n     */\\n    function isWithdrawable(uint256 claimID) external view returns (bool status);\\n\\n    /**\\n     * @notice The amount of time left until the payout is withdrawable.\\n     * @param claimID The ID to check.\\n     * @return time The duration in seconds.\\n     */\\n    function timeLeft(uint256 claimID) external view returns (uint256 time);\\n\\n    /***************************************\\n    GLOBAL VIEWS\\n    ***************************************/\\n\\n    /// @notice Tracks how much **ETH** is required to payout all claims.\\n    function totalClaimsOutstanding() external view returns (uint256);\\n\\n    /// @notice The duration of time in seconds the user must wait between submitting a claim and withdrawing the payout.\\n    function cooldownPeriod() external view returns (uint256);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Adjusts the value of a claim.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param claimID The claim to adjust.\\n     * @param value The new payout of the claim.\\n     */\\n    function adjustClaim(uint256 claimID, uint256 value) external;\\n\\n    /**\\n     * @notice Returns **ETH** to the [`Vault`](../Vault).\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param amount Amount to pull.\\n     */\\n    function returnEth(uint256 amount) external;\\n\\n    /**\\n     * @notice Set the cooldown duration.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param cooldownPeriod_ New cooldown duration in seconds\\n     */\\n    function setCooldownPeriod(uint256 cooldownPeriod_) external;\\n\\n    /***************************************\\n    FALLBACK FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * Receive function. Deposits eth.\\n     */\\n    receive() external payable;\\n\\n    /**\\n     * Fallback function. Deposits eth.\\n     */\\n    fallback () external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title IRegistry\\n * @author solace.fi\\n * @notice Tracks the contracts of the Solaverse.\\n *\\n * [**Governance**](/docs/protocol/governance) can set the contract addresses and anyone can look them up.\\n *\\n * Note that `Registry` doesn't track all Solace contracts. FarmController is tracked in [`OptionsFarming`](../OptionsFarming), farms are tracked in FarmController, Products are tracked in [`PolicyManager`](../PolicyManager), and the `Registry` is untracked.\\n */\\ninterface IRegistry {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    // Emitted when WETH is set.\\n    event WethSet(address weth);\\n    // Emitted when Vault is set.\\n    event VaultSet(address vault);\\n    // Emitted when ClaimsEscrow is set.\\n    event ClaimsEscrowSet(address claimsEscrow);\\n    // Emitted when Treasury is set.\\n    event TreasurySet(address treasury);\\n    // Emitted when PolicyManager is set.\\n    event PolicyManagerSet(address policyManager);\\n    // Emitted when RiskManager is set.\\n    event RiskManagerSet(address riskManager);\\n    // Emitted when Solace Token is set.\\n    event SolaceSet(address solace);\\n    // Emitted when OptionsFarming is set.\\n    event OptionsFarmingSet(address optionsFarming);\\n    // Emitted when FarmController is set.\\n    event FarmControllerSet(address farmController);\\n    // Emitted when Locker is set.\\n    event LockerSet(address locker);\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Gets the [**WETH**](../WETH9) contract.\\n     * @return weth_ The address of the [**WETH**](../WETH9) contract.\\n     */\\n    function weth() external view returns (address weth_);\\n\\n    /**\\n     * @notice Gets the [`Vault`](../Vault) contract.\\n     * @return vault_ The address of the [`Vault`](../Vault) contract.\\n     */\\n    function vault() external view returns (address vault_);\\n\\n    /**\\n     * @notice Gets the [`ClaimsEscrow`](../ClaimsEscrow) contract.\\n     * @return claimsEscrow_ The address of the [`ClaimsEscrow`](../ClaimsEscrow) contract.\\n     */\\n    function claimsEscrow() external view returns (address claimsEscrow_);\\n\\n    /**\\n     * @notice Gets the [`Treasury`](../Treasury) contract.\\n     * @return treasury_ The address of the [`Treasury`](../Treasury) contract.\\n     */\\n    function treasury() external view returns (address treasury_);\\n\\n    /**\\n     * @notice Gets the [`PolicyManager`](../PolicyManager) contract.\\n     * @return policyManager_ The address of the [`PolicyManager`](../PolicyManager) contract.\\n     */\\n    function policyManager() external view returns (address policyManager_);\\n\\n    /**\\n     * @notice Gets the [`RiskManager`](../RiskManager) contract.\\n     * @return riskManager_ The address of the [`RiskManager`](../RiskManager) contract.\\n     */\\n    function riskManager() external view returns (address riskManager_);\\n\\n    /**\\n     * @notice Gets the [**SOLACE**](../SOLACE) contract.\\n     * @return solace_ The address of the [**SOLACE**](../SOLACE) contract.\\n     */\\n    function solace() external view returns (address solace_);\\n\\n    /**\\n     * @notice Gets the [`OptionsFarming`](../OptionsFarming) contract.\\n     * @return optionsFarming_ The address of the [`OptionsFarming`](../OptionsFarming) contract.\\n     */\\n    function optionsFarming() external view returns (address optionsFarming_);\\n\\n    /**\\n     * @notice Gets the [`FarmController`](../FarmController) contract.\\n     * @return farmController_ The address of the [`FarmController`](../FarmController) contract.\\n     */\\n    function farmController() external view returns (address farmController_);\\n\\n    /**\\n     * @notice Gets the [`Locker`](../Locker) contract.\\n     * @return locker_ The address of the [`Locker`](../Locker) contract.\\n     */\\n    function locker() external view returns (address locker_);\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets the [**WETH**](../WETH9) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param weth_ The address of the [**WETH**](../WETH9) contract.\\n     */\\n    function setWeth(address weth_) external;\\n\\n    /**\\n     * @notice Sets the [`Vault`](../Vault) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param vault_ The address of the [`Vault`](../Vault) contract.\\n     */\\n    function setVault(address vault_) external;\\n\\n    /**\\n     * @notice Sets the [`Claims Escrow`](../ClaimsEscrow) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param claimsEscrow_ The address of the [`Claims Escrow`](../ClaimsEscrow) contract.\\n     */\\n    function setClaimsEscrow(address claimsEscrow_) external;\\n\\n    /**\\n     * @notice Sets the [`Treasury`](../Treasury) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param treasury_ The address of the [`Treasury`](../Treasury) contract.\\n     */\\n    function setTreasury(address treasury_) external;\\n\\n    /**\\n     * @notice Sets the [`Policy Manager`](../PolicyManager) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param policyManager_ The address of the [`Policy Manager`](../PolicyManager) contract.\\n     */\\n    function setPolicyManager(address policyManager_) external;\\n\\n    /**\\n     * @notice Sets the [`Risk Manager`](../RiskManager) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param riskManager_ The address of the [`Risk Manager`](../RiskManager) contract.\\n     */\\n    function setRiskManager(address riskManager_) external;\\n\\n    /**\\n     * @notice Sets the [**SOLACE**](../SOLACE) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param solace_ The address of the [**SOLACE**](../SOLACE) contract.\\n     */\\n    function setSolace(address solace_) external;\\n\\n    /**\\n     * @notice Sets the [`OptionsFarming`](../OptionsFarming) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param optionsFarming_ The address of the [`OptionsFarming`](../OptionsFarming) contract.\\n     */\\n    function setOptionsFarming(address optionsFarming_) external;\\n\\n    /**\\n     * @notice Sets the [`FarmController`](../FarmController) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param farmController_ The address of the [`FarmController`](../FarmController) contract.\\n     */\\n    function setFarmController(address farmController_) external;\\n\\n    /**\\n     * @notice Sets the [`Locker`](../Locker) contract.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param locker_ The address of the [`Locker`](../Locker) contract.\\n     */\\n    function setLocker(address locker_) external;\\n\\n    /**\\n     * @notice Sets multiple contracts in one call.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param weth_ The address of the [**WETH**](../WETH9) contract.\\n     * @param vault_ The address of the [`Vault`](../Vault) contract.\\n     * @param claimsEscrow_ The address of the [`Claims Escrow`](../ClaimsEscrow) contract.\\n     * @param treasury_ The address of the [`Treasury`](../Treasury) contract.\\n     * @param policyManager_ The address of the [`Policy Manager`](../PolicyManager) contract.\\n     * @param riskManager_ The address of the [`Risk Manager`](../RiskManager) contract.\\n     * @param solace_ The address of the [**SOLACE**](../SOLACE) contract.\\n     * @param optionsFarming_ The address of the [`OptionsFarming`](./OptionsFarming) contract.\\n     * @param farmController_ The address of the [`FarmController`](./FarmController) contract.\\n     * @param locker_ The address of the [`Locker`](../Locker) contract.\\n     */\\n    function setMultiple(\\n        address weth_,\\n        address vault_,\\n        address claimsEscrow_,\\n        address treasury_,\\n        address policyManager_,\\n        address riskManager_,\\n        address solace_,\\n        address optionsFarming_,\\n        address farmController_,\\n        address locker_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IProduct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title IProduct\\n * @author solace.fi\\n * @notice Interface for product contracts\\n */\\ninterface IProduct {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when a policy is created.\\n    event PolicyCreated(uint256 indexed policyID);\\n    /// @notice Emitted when a policy is extended.\\n    event PolicyExtended(uint256 indexed policyID);\\n    /// @notice Emitted when a policy is canceled.\\n    event PolicyCanceled(uint256 indexed policyID);\\n    /// @notice Emitted when a policy is updated.\\n    event PolicyUpdated(uint256 indexed policyID);\\n    /// @notice Emitted when a claim is submitted.\\n    event ClaimSubmitted(uint256 indexed policyID);\\n    /// @notice Emitted when min period is set.\\n    event MinPeriodSet(uint40 minPeriod);\\n    /// @notice Emitted when max period is set.\\n    event MaxPeriodSet(uint40 maxPeriod);\\n    /// @notice Emitted when buying is paused or unpaused.\\n    event PauseSet(bool paused);\\n    /// @notice Emitted when covered platform is set.\\n    event CoveredPlatformSet(address coveredPlatform);\\n    /// @notice Emitted when PolicyManager is set.\\n    event PolicyManagerSet(address policyManager);\\n\\n    /***************************************\\n    POLICYHOLDER FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Purchases and mints a policy on the behalf of the policyholder.\\n     * User will need to pay **ETH**.\\n     * @param policyholder Holder of the position(s) to cover.\\n     * @param coverAmount The value to cover in **ETH**.\\n     * @param blocks The length (in blocks) for policy.\\n     * @param positionDescription A byte encoded description of the position(s) to cover.\\n     * @return policyID The ID of newly created policy.\\n     */\\n    function buyPolicy(address policyholder, uint256 coverAmount, uint40 blocks, bytes memory positionDescription) external payable returns (uint256 policyID);\\n\\n    /**\\n     * @notice Increase or decrease the cover amount of the policy.\\n     * User may need to pay **ETH** for increased cover amount or receive a refund for decreased cover amount.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     * @param newCoverAmount The new value to cover in **ETH**.\\n     */\\n    function updateCoverAmount(uint256 policyID, uint256 newCoverAmount) external payable;\\n\\n    /**\\n     * @notice Extend a policy.\\n     * User will need to pay **ETH**.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     * @param extension The length of extension in blocks.\\n     */\\n    function extendPolicy(uint256 policyID, uint40 extension) external payable;\\n\\n    /**\\n     * @notice Extend a policy and update its cover amount.\\n     * User may need to pay **ETH** for increased cover amount or receive a refund for decreased cover amount.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     * @param newCoverAmount The new value to cover in **ETH**.\\n     * @param extension The length of extension in blocks.\\n     */\\n    function updatePolicy(uint256 policyID, uint256 newCoverAmount, uint40 extension) external payable;\\n\\n    /**\\n     * @notice Cancel and burn a policy.\\n     * User will receive a refund for the remaining blocks.\\n     * Can only be called by the policyholder.\\n     * @param policyID The ID of the policy.\\n     */\\n    function cancelPolicy(uint256 policyID) external;\\n\\n    /***************************************\\n    QUOTE VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Calculate a premium quote for a policy.\\n     * @param coverAmount The value to cover in **ETH**.\\n     * @param blocks The duration of the policy in blocks.\\n     * @return premium The quote for their policy in **ETH**.\\n     */\\n    function getQuote(uint256 coverAmount, uint40 blocks) external view returns (uint256 premium);\\n\\n    /***************************************\\n    GLOBAL VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice The minimum policy period in blocks.\\n    function minPeriod() external view returns (uint40);\\n    /// @notice The maximum policy period in blocks.\\n    function maxPeriod() external view returns (uint40);\\n    /// @notice Covered platform.\\n    /// A platform contract which locates contracts that are covered by this product.\\n    /// (e.g., `UniswapProduct` will have `Factory` as `coveredPlatform` contract, because every `Pair` address can be located through `getPool()` function).\\n    function coveredPlatform() external view returns (address);\\n    /// @notice The current amount covered (in wei).\\n    function activeCoverAmount() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the name of the product.\\n     * Must be implemented by child contracts.\\n     * @return productName The name of the product.\\n     */\\n    function name() external view returns (string memory productName);\\n\\n    /// @notice Cannot buy new policies while paused. (Default is False)\\n    function paused() external view returns (bool);\\n\\n    /// @notice Address of the [`PolicyManager`](../PolicyManager).\\n    function policyManager() external view returns (address);\\n\\n    /**\\n     * @notice Returns true if the given account is authorized to sign claims.\\n     * @param account Potential signer to query.\\n     * @return status True if is authorized signer.\\n     */\\n     function isAuthorizedSigner(address account) external view returns (bool status);\\n\\n    /***************************************\\n    MUTATOR FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Updates the product's book-keeping variables.\\n     * Can only be called by the [`PolicyManager`](../PolicyManager).\\n     * @param coverDiff The change in active cover amount.\\n     */\\n    function updateActiveCoverAmount(int256 coverDiff) external;\\n\\n    /***************************************\\n    GOVERNANCE FUNCTIONS\\n    ***************************************/\\n\\n    /**\\n     * @notice Sets the minimum number of blocks a policy can be purchased for.\\n     * @param minPeriod_ The minimum number of blocks.\\n     */\\n    function setMinPeriod(uint40 minPeriod_) external;\\n\\n    /**\\n     * @notice Sets the maximum number of blocks a policy can be purchased for.\\n     * @param maxPeriod_ The maximum number of blocks\\n     */\\n    function setMaxPeriod(uint40 maxPeriod_) external;\\n\\n    /**\\n     * @notice Changes the covered platform.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @dev Use this if the the protocol changes their registry but keeps the children contracts.\\n     * A new version of the protocol will likely require a new Product.\\n     * @param coveredPlatform_ The platform to cover.\\n     */\\n    function setCoveredPlatform(address coveredPlatform_) external;\\n\\n    /**\\n     * @notice Changes the policy manager.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param policyManager_ The new policy manager.\\n     */\\n    function setPolicyManager(address policyManager_) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return recover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return recover(hash, r, vs);\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(\\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid signature 's' value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title IGovernable\\n * @author solace.fi\\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\\n *\\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\\n * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setPendingGovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./ISingletonFactory).\\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\\n */\\ninterface IGovernable {\\n\\n    /***************************************\\n    EVENTS\\n    ***************************************/\\n\\n    /// @notice Emitted when pending Governance is set.\\n    event GovernancePending(address pendingGovernance);\\n    /// @notice Emitted when Governance is set.\\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\\n    /// @notice Emitted when Governance is locked.\\n    event GovernanceLocked();\\n\\n    /***************************************\\n    VIEW FUNCTIONS\\n    ***************************************/\\n\\n    /// @notice Address of the current governor.\\n    function governance() external view returns (address);\\n\\n    /// @notice Address of the governor to take over.\\n    function pendingGovernance() external view returns (address);\\n\\n    /// @notice Returns true if governance is locked.\\n    function governanceIsLocked() external view returns (bool);\\n\\n    /***************************************\\n    MUTATORS\\n    ***************************************/\\n\\n    /**\\n     * @notice Initiates transfer of the governance role to a new governor.\\n     * Transfer is not complete until the new governor accepts the role.\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     * @param pendingGovernance_ The new governor.\\n     */\\n    function setPendingGovernance(address pendingGovernance_) external;\\n\\n    /**\\n     * @notice Accepts the governance role.\\n     * Can only be called by the new governor.\\n     */\\n    function acceptGovernance() external;\\n\\n    /**\\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\\n     * This action cannot be reversed.\\n     * Before you call it, ask yourself:\\n     *   - Is the contract self-sustaining?\\n     *   - Is there a chance you will need governance privileges in the future?\\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\\n     */\\n    function lockGovernance() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC721Enhanced.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// code borrowed from OpenZeppelin and @uniswap/v3-periphery\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\n/**\\n * @title ERC721Enhanced\\n * @author solace.fi\\n * @notice An extension of `ERC721`.\\n *\\n * The base is OpenZeppelin's `ERC721Enumerable` which also includes the `Metadata` extension. This extension includes simpler transfers, gasless approvals, and better enumeration.\\n */\\ninterface IERC721Enhanced is IERC721Enumerable {\\n\\n    /***************************************\\n    SIMPLER TRANSFERS\\n    ***************************************/\\n\\n    /**\\n     * @notice Transfers `tokenID` from `msg.sender` to `to`.\\n     * @dev This was excluded from the official `ERC721` standard in favor of `transferFrom(address from, address to, uint256 tokenID)`. We elect to include it.\\n     * @param to The receipient of the token.\\n     * @param tokenID The token to transfer.\\n     */\\n    function transfer(address to, uint256 tokenID) external;\\n\\n    /**\\n     * @notice Safely transfers `tokenID` from `msg.sender` to `to`.\\n     * @dev This was excluded from the official `ERC721` standard in favor of `safeTransferFrom(address from, address to, uint256 tokenID)`. We elect to include it.\\n     * @param to The receipient of the token.\\n     * @param tokenID The token to transfer.\\n     */\\n    function safeTransfer(address to, uint256 tokenID) external;\\n\\n    /***************************************\\n    GASLESS APPROVALS\\n    ***************************************/\\n\\n    /**\\n     * @notice Approve of a specific `tokenID` for spending by `spender` via signature.\\n     * @param spender The account that is being approved.\\n     * @param tokenID The ID of the token that is being approved for spending.\\n     * @param deadline The deadline timestamp by which the call must be mined for the approve to work.\\n     * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`.\\n     * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`.\\n     * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`.\\n     */\\n    function permit(\\n        address spender,\\n        uint256 tokenID,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Returns the current nonce for `tokenID`. This value must be\\n     * included whenever a signature is generated for `permit`.\\n     * Every successful call to `permit` increases ``tokenID``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     * @param tokenID ID of the token to request nonce.\\n     * @return nonce Nonce of the token.\\n     */\\n    function nonces(uint256 tokenID) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice The permit typehash used in the `permit` signature.\\n     * @return typehash The typehash for the `permit`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function PERMIT_TYPEHASH() external view returns (bytes32 typehash);\\n\\n    /**\\n     * @notice The domain separator used in the encoding of the signature for `permit`, as defined by `EIP712`.\\n     * @return seperator The domain seperator for `permit`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32 seperator);\\n\\n    /***************************************\\n    BETTER ENUMERATION\\n    ***************************************/\\n\\n    /**\\n     * @notice Lists all tokens.\\n     * Order not specified.\\n     * @dev This function is more useful off chain than on chain.\\n     * @return tokenIDs The list of token IDs.\\n     */\\n    function listTokens() external view returns (uint256[] memory tokenIDs);\\n\\n    /**\\n     * @notice Lists the tokens owned by `owner`.\\n     * Order not specified.\\n     * @dev This function is more useful off chain than on chain.\\n     * @return tokenIDs The list of token IDs.\\n     */\\n    function listTokensOfOwner(address owner) external view returns (uint256[] memory tokenIDs);\\n\\n    /**\\n     * @notice Determines if a token exists or not.\\n     * @param tokenID The ID of the token to query.\\n     * @return status True if the token exists, false if it doesn't.\\n     */\\n    function exists(uint256 tokenID) external view returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"contract IPolicyManager\",\"name\":\"policyManager_\",\"type\":\"address\"},{\"internalType\":\"contract IRegistry\",\"name\":\"registry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniV3Factory_\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"minPeriod_\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maxPeriod_\",\"type\":\"uint40\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"ClaimSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coveredPlatform\",\"type\":\"address\"}],\"name\":\"CoveredPlatformSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GovernanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernancePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"maxPeriod\",\"type\":\"uint40\"}],\"name\":\"MaxPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"minPeriod\",\"type\":\"uint40\"}],\"name\":\"MinPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"PauseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"policyManager\",\"type\":\"address\"}],\"name\":\"PolicyManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"PolicyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeCoverAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"addSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"blocks\",\"type\":\"uint40\"},{\"internalType\":\"bytes\",\"name\":\"positionDescription\",\"type\":\"bytes\"}],\"name\":\"buyPolicy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"}],\"name\":\"cancelPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coveredPlatform\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"extension\",\"type\":\"uint40\"}],\"name\":\"extendPolicy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"blocks\",\"type\":\"uint40\"}],\"name\":\"getQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAuthorizedSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"positionDescription\",\"type\":\"bytes\"}],\"name\":\"isValidPositionDescription\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPeriod\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPeriod\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"productName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniV3Factory_\",\"type\":\"address\"}],\"name\":\"setCoveredPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"maxPeriod_\",\"type\":\"uint40\"}],\"name\":\"setMaxPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"minPeriod_\",\"type\":\"uint40\"}],\"name\":\"setMinPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGovernance_\",\"type\":\"address\"}],\"name\":\"setPendingGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"policyManager_\",\"type\":\"address\"}],\"name\":\"setPolicyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"submitClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"uniV3Factory_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"coverDiff\",\"type\":\"int256\"}],\"name\":\"updateActiveCoverAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"}],\"name\":\"updateCoverAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"policyID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"extension\",\"type\":\"uint40\"}],\"name\":\"updatePolicy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"UniswapV3Product","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"000000000000000000000000501ace0e8d16b92236763e2ded7ae3bc2dffa276000000000000000000000000501ace5e9f058bb2e851675bb3fa104da6e3a22c000000000000000000000000501acee3310d98881c827d4357c970f23a30ad290000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f9840000000000000000000000000000000000000000000000000000000000001932000000000000000000000000000000000000000000000000000000000023ec4a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}