{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant LENDINGPOOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\\naddress constant LENDINGPOOL_ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\\naddress constant PROTOCOL_DATA_PROVIDER = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;\\n\"\r\n    },\r\n    \"contracts/constants/CAaveServices.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant GELATO = 0x3CACa7b48D0573D793d3b0279b5F0029180E83b6;\\nstring constant OK = \\\"OK\\\";\\n\"\r\n    },\r\n    \"contracts/constants/CProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nuint256 constant DISCREPANCY_BPS_CAP = 500; // 5%\\nuint256 constant SLIPPAGE_BPS_CAP = 500; // 5%\\nuint256 constant TEN_THOUSAND_BPS = 1e4; // 100%\\n\"\r\n    },\r\n    \"contracts/constants/CTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\"\r\n    },\r\n    \"contracts/functions/FProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {ILendingPool} from \\\"../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    IProtocolDataProvider\\n} from \\\"../interfaces/aave/IProtocolDataProvider.sol\\\";\\nimport {IPriceOracle} from \\\"../interfaces/aave/IPriceOracle.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {PROTOCOL_DATA_PROVIDER} from \\\"../constants/CAave.sol\\\";\\nimport {TEN_THOUSAND_BPS} from \\\"../constants/CProtectionAction.sol\\\";\\nimport {\\n    ProtectionDataCompute,\\n    RepayAndFlashBorrowData,\\n    RepayAndFlashBorrowResult\\n} from \\\"../structs/SProtection.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {_qmul, _wdiv, _wmul} from \\\"../vendor/DSMath.sol\\\";\\n\\nfunction _getRepayAndFlashBorrowAmt(\\n    RepayAndFlashBorrowData memory _rAndWAmtData,\\n    ILendingPool _lendingPool,\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider\\n) view returns (RepayAndFlashBorrowResult memory) {\\n    ProtectionDataCompute memory protectionDataCompute;\\n\\n    protectionDataCompute.onBehalfOf = _rAndWAmtData.user;\\n    protectionDataCompute.colToken = _rAndWAmtData.colToken;\\n    protectionDataCompute.debtToken = _rAndWAmtData.debtToken;\\n    protectionDataCompute.wantedHealthFactor = _rAndWAmtData.wantedHealthFactor;\\n\\n    (\\n        protectionDataCompute.totalCollateralETH,\\n        protectionDataCompute.totalBorrowsETH,\\n        ,\\n        protectionDataCompute.currentLiquidationThreshold,\\n        ,\\n\\n    ) = _lendingPool.getUserAccountData(_rAndWAmtData.user);\\n\\n    uint256[] memory pricesInETH;\\n    {\\n        address[] memory assets = new address[](2);\\n        assets[0] = _rAndWAmtData.colToken;\\n        assets[1] = _rAndWAmtData.debtToken;\\n        // index 0 is colToken to Eth price, and index 1 is debtToken to Eth price\\n        pricesInETH = IPriceOracle(\\n            _lendingPoolAddressesProvider.getPriceOracle()\\n        ).getAssetsPrices(assets);\\n\\n        protectionDataCompute.colPrice = pricesInETH[0];\\n        protectionDataCompute.debtPrice = pricesInETH[1];\\n    }\\n\\n    (\\n        ,\\n        ,\\n        protectionDataCompute.colLiquidationThreshold,\\n        ,\\n        ,\\n        ,\\n        ,\\n        ,\\n        ,\\n\\n    ) = IProtocolDataProvider(PROTOCOL_DATA_PROVIDER)\\n        .getReserveConfigurationData(_rAndWAmtData.colToken);\\n\\n    protectionDataCompute.protectionFeeInETH = _rAndWAmtData.protectionFeeInETH;\\n    protectionDataCompute.flashloanPremiumBps = _lendingPool\\n        .FLASHLOAN_PREMIUM_TOTAL();\\n\\n    return\\n        _amountToPaybackAndFlashBorrow(_rAndWAmtData.id, protectionDataCompute);\\n}\\n\\nfunction _amountToPaybackAndFlashBorrow(\\n    bytes32 _id,\\n    ProtectionDataCompute memory _protectionDataCompute\\n) view returns (RepayAndFlashBorrowResult memory) {\\n    uint256 intermediateValue = _wdiv(\\n        ((_wmul(\\n            _protectionDataCompute.wantedHealthFactor,\\n            _protectionDataCompute.totalBorrowsETH\\n        ) -\\n            (\\n                _qmul(\\n                    _protectionDataCompute.totalCollateralETH,\\n                    _protectionDataCompute.currentLiquidationThreshold\\n                )\\n            )) +\\n            _qmul(\\n                _protectionDataCompute.protectionFeeInETH,\\n                _protectionDataCompute.colLiquidationThreshold\\n            )),\\n        _protectionDataCompute.wantedHealthFactor -\\n            _qmul(\\n                _protectionDataCompute.colLiquidationThreshold,\\n                (TEN_THOUSAND_BPS + _protectionDataCompute.flashloanPremiumBps)\\n            ) *\\n            1e14\\n    );\\n\\n    uint256 colTokenDecimals = ERC20(_protectionDataCompute.colToken)\\n        .decimals();\\n    uint256 debtTokenDecimals = ERC20(_protectionDataCompute.debtToken)\\n        .decimals();\\n\\n    return\\n        RepayAndFlashBorrowResult(\\n            _id,\\n            _tokenToTokenPrecision(\\n                _wdiv(intermediateValue, _protectionDataCompute.colPrice),\\n                18,\\n                colTokenDecimals\\n            ),\\n            _tokenToTokenPrecision(\\n                _wdiv(intermediateValue, _protectionDataCompute.debtPrice),\\n                18,\\n                debtTokenDecimals\\n            ),\\n            \\\"OK\\\"\\n        );\\n}\\n\\nfunction _tokenToTokenPrecision(\\n    uint256 _amount,\\n    uint256 _oldPrecision,\\n    uint256 _newPrecision\\n) pure returns (uint256) {\\n    return\\n        _oldPrecision > _newPrecision\\n            ? _amount / (10**(_oldPrecision - _newPrecision))\\n            : _amount * (10**(_newPrecision - _oldPrecision));\\n}\\n\\nfunction _convertEthToToken(\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider,\\n    address _token,\\n    uint256 _amount\\n) view returns (uint256) {\\n    address[] memory assets = new address[](1);\\n    assets[0] = _token;\\n    return\\n        _tokenToTokenPrecision(\\n            _wdiv(\\n                _amount,\\n                (\\n                    IPriceOracle(_lendingPoolAddressesProvider.getPriceOracle())\\n                        .getAssetsPrices(assets)\\n                )[0]\\n            ),\\n            18,\\n            ERC20(_token).decimals()\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/FProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {ILendingPool} from \\\"../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {ISwapModule} from \\\"../interfaces/services/module/ISwapModule.sol\\\";\\nimport {\\n    IERC20,\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {DataTypes} from \\\"../structs/SAave.sol\\\";\\nimport {GELATO} from \\\"../constants/CAaveServices.sol\\\";\\nimport {TEN_THOUSAND_BPS} from \\\"../constants/CProtectionAction.sol\\\";\\nimport {\\n    RepayAndFlashBorrowResult,\\n    RepayAndFlashBorrowData,\\n    ProtectionPayload,\\n    FlashLoanParamsData\\n} from \\\"../structs/SProtection.sol\\\";\\nimport {_getRepayAndFlashBorrowAmt} from \\\"./FProtection.sol\\\";\\n\\nfunction _checkRepayAndFlashBorrowAmt(\\n    ProtectionPayload memory _protectionPayload,\\n    ILendingPool _lendingPool,\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider,\\n    IProtectionAction _protectionAction\\n) view {\\n    RepayAndFlashBorrowData memory rAndFAmtData;\\n\\n    rAndFAmtData.user = _protectionPayload.onBehalfOf;\\n    rAndFAmtData.colToken = _protectionPayload.colToken;\\n    rAndFAmtData.debtToken = _protectionPayload.debtToken;\\n    rAndFAmtData.wantedHealthFactor = _protectionPayload.wantedHealthFactor;\\n    rAndFAmtData.protectionFeeInETH = _protectionPayload.protectionFeeInETH;\\n\\n    RepayAndFlashBorrowResult\\n        memory rAndFAmtResult = _getRepayAndFlashBorrowAmt(\\n            rAndFAmtData,\\n            _lendingPool,\\n            _lendingPoolAddressesProvider\\n        );\\n\\n    uint256 slippage = _slippage(\\n        rAndFAmtResult.amtOfDebtToRepay,\\n        _protectionAction.slippageInBps()\\n    );\\n    // Due to accrued aToken, we have some discrepancy we cap it to 1 BPS maximum.\\n    uint256 oneBpsDiscrepancy = _oneBpsDiscrepancy(\\n        rAndFAmtResult.amtToFlashBorrow\\n    );\\n\\n    bool isFlashBorrowAmtOk = _protectionPayload.amtToFlashBorrow <=\\n        rAndFAmtResult.amtToFlashBorrow + oneBpsDiscrepancy;\\n    bool isAmtOfDebtToRepayOk = _protectionPayload.amtOfDebtToRepay >=\\n        rAndFAmtResult.amtOfDebtToRepay - slippage;\\n\\n    if (isFlashBorrowAmtOk && isAmtOfDebtToRepayOk) return;\\n    if (isFlashBorrowAmtOk && !isAmtOfDebtToRepayOk)\\n        revert(\\n            \\\"_checkRepayAndFlashBorrowAmt: OffChain amtOfDebtToRepay != onchain amtOfDebtToRepay, out of slippage range.\\\"\\n        );\\n    if (!isFlashBorrowAmtOk && isAmtOfDebtToRepayOk)\\n        revert(\\n            \\\"_checkRepayAndFlashBorrowAmt: OffChain amtToFlashBorrow != onchain amtToFlashBorrow.\\\"\\n        );\\n    revert(\\n        \\\"_checkRepayAndFlashBorrowAmt: OffChain amtOfDebtToRepay != onchain amtOfDebtToRepay, out of slippage range. OffChain amtToFlashBorrow != onchain amtToFlashBorrow.\\\"\\n    );\\n}\\n\\nfunction _getProtectionPayload(\\n    bytes32 _taskHash,\\n    bytes memory _data,\\n    bytes memory _offChainData\\n) pure returns (ProtectionPayload memory) {\\n    ProtectionPayload memory protectionPayload;\\n\\n    protectionPayload.taskHash = _taskHash;\\n\\n    (\\n        protectionPayload.colToken,\\n        protectionPayload.debtToken,\\n        protectionPayload.rateMode,\\n        protectionPayload.wantedHealthFactor,\\n        protectionPayload.minimumHealthFactor,\\n        protectionPayload.onBehalfOf\\n    ) = abi.decode(\\n        _data,\\n        (address, address, uint256, uint256, uint256, address)\\n    );\\n\\n    (\\n        protectionPayload.amtToFlashBorrow,\\n        protectionPayload.amtOfDebtToRepay,\\n        protectionPayload.protectionFeeInETH,\\n        protectionPayload.swapActions,\\n        protectionPayload.swapDatas,\\n        protectionPayload.subBlockNumber,\\n        protectionPayload.isPermanent\\n    ) = abi.decode(\\n        _offChainData,\\n        (uint256, uint256, uint256, address[], bytes[], uint256, bool)\\n    );\\n\\n    return protectionPayload;\\n}\\n\\nfunction _flashLoan(\\n    ILendingPool _lendingPool,\\n    address receiverAddress,\\n    ProtectionPayload memory _protectionPayload\\n) {\\n    address[] memory flashBorrowTokens = new address[](1);\\n    flashBorrowTokens[0] = _protectionPayload.colToken;\\n\\n    uint256[] memory amtToFlashBorrows = new uint256[](1);\\n    amtToFlashBorrows[0] = _protectionPayload.amtToFlashBorrow;\\n\\n    _lendingPool.flashLoan(\\n        receiverAddress,\\n        flashBorrowTokens,\\n        amtToFlashBorrows,\\n        new uint256[](1),\\n        _protectionPayload.onBehalfOf,\\n        abi.encode(\\n            FlashLoanParamsData(\\n                _protectionPayload.minimumHealthFactor,\\n                _protectionPayload.taskHash,\\n                _protectionPayload.debtToken,\\n                _protectionPayload.amtOfDebtToRepay,\\n                _protectionPayload.rateMode,\\n                _protectionPayload.onBehalfOf,\\n                _protectionPayload.protectionFeeInETH,\\n                _protectionPayload.swapActions,\\n                _protectionPayload.swapDatas\\n            )\\n        ),\\n        0\\n    );\\n}\\n\\nfunction _approveERC20Token(\\n    address _asset,\\n    address _spender,\\n    uint256 _amount\\n) {\\n    // Approves 0 first to comply with tokens that implement the anti frontrunning approval fix\\n    SafeERC20.safeApprove(IERC20(_asset), _spender, 0);\\n    SafeERC20.safeApprove(IERC20(_asset), _spender, _amount);\\n}\\n\\nfunction _paybackToLendingPool(\\n    ILendingPool _lendingPool,\\n    address _asset,\\n    uint256 _amount,\\n    uint256 _rateMode,\\n    address _onBehalf\\n) {\\n    _approveERC20Token(_asset, address(_lendingPool), _amount);\\n    _lendingPool.repay(_asset, _amount, _rateMode, _onBehalf);\\n}\\n\\nfunction _withdrawCollateral(\\n    ILendingPool _lendingPool,\\n    address _to,\\n    address _asset,\\n    uint256 _amount,\\n    address _onBehalf\\n) {\\n    DataTypes.ReserveData memory reserve = _lendingPool.getReserveData(_asset);\\n\\n    SafeERC20.safeTransferFrom(\\n        IERC20(reserve.aTokenAddress),\\n        _onBehalf,\\n        _to,\\n        _amount\\n    );\\n\\n    _lendingPool.withdraw(_asset, _amount, _to);\\n}\\n\\nfunction _transferFees(address _asset, uint256 _amount) {\\n    SafeERC20.safeTransfer(IERC20(_asset), GELATO, _amount);\\n}\\n\\nfunction _requirePositionSafe(\\n    uint256 _healthFactor,\\n    uint256 _discrepancyBps,\\n    uint256 _wantedHealthFactor\\n) pure {\\n    uint256 discrepancy = (_wantedHealthFactor * _discrepancyBps) /\\n        TEN_THOUSAND_BPS;\\n\\n    require(\\n        _healthFactor < _wantedHealthFactor + discrepancy &&\\n            _healthFactor > _wantedHealthFactor - discrepancy &&\\n            _healthFactor > 1e18,\\n        \\\"The user position isn't safe after the protection of the debt.\\\"\\n    );\\n}\\n\\nfunction _requirePositionUnSafe(\\n    uint256 _currentHealthFactor,\\n    uint256 _minimumHealthFactor\\n) pure {\\n    require(\\n        _currentHealthFactor < _minimumHealthFactor,\\n        \\\"The user position's health factor is above the minimum trigger health factor.\\\"\\n    );\\n}\\n\\nfunction _transferDust(\\n    address _sender,\\n    address _asset,\\n    address _user\\n) {\\n    uint256 serviceBalance = IERC20(_asset).balanceOf(_sender);\\n\\n    if (serviceBalance > 0) {\\n        SafeERC20.safeTransfer(IERC20(_asset), _user, serviceBalance);\\n    }\\n}\\n\\nfunction _swap(\\n    address _this,\\n    ISwapModule _swapModule,\\n    address[] memory _swapActions,\\n    bytes[] memory _swapDatas,\\n    IERC20 _outputToken,\\n    IERC20 _inputToken,\\n    uint256 _inputAmt,\\n    uint256 _minReturn\\n) returns (uint256 receivedAmt) {\\n    uint256 outputTokenbalanceBSwap = _outputToken.balanceOf(_this);\\n\\n    SafeERC20.safeTransfer(_inputToken, address(_swapModule), _inputAmt);\\n    _swapModule.swap(_swapActions, _swapDatas);\\n\\n    receivedAmt = _outputToken.balanceOf(_this) - outputTokenbalanceBSwap;\\n\\n    require(\\n        receivedAmt > _minReturn,\\n        \\\"ProtectionAction.swap: received amount < minReturn.\\\"\\n    );\\n}\\n\\nfunction _slippage(uint256 _amount, uint256 _slippageInBps)\\n    pure\\n    returns (uint256)\\n{\\n    return (_amount * _slippageInBps) / TEN_THOUSAND_BPS;\\n}\\n\\n// Due to accrued aToken, we have some discrepancy.\\nfunction _oneBpsDiscrepancy(uint256 _amount) pure returns (uint256) {\\n    return _amount / TEN_THOUSAND_BPS;\\n}\\n\\nfunction _checkSubmitterIsUser(\\n    ProtectionPayload memory _protectionPayload,\\n    bytes memory _payload\\n) pure {\\n    require(\\n        _protectionPayload.taskHash ==\\n            keccak256(\\n                abi.encode(\\n                    _protectionPayload.onBehalfOf,\\n                    _protectionPayload.subBlockNumber,\\n                    _payload,\\n                    _protectionPayload.isPermanent\\n                )\\n            ),\\n        \\\"ProtectionAction._checkSubmitterIsUser: Task submitter != user\\\"\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"./ILendingPoolAddressesProvider.sol\\\";\\nimport {ILendingPool} from \\\"./ILendingPool.sol\\\";\\n\\n/**\\n * @title IFlashLoanReceiver interface\\n * @notice Interface for the Aave fee IFlashLoanReceiver.\\n * @author Aave\\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n **/\\ninterface IFlashLoanReceiver {\\n    function executeOperation(\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata premiums,\\n        address initiator,\\n        bytes calldata params\\n    ) external returns (bool);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function ADDRESSES_PROVIDER()\\n        external\\n        view\\n        returns (ILendingPoolAddressesProvider);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function LENDING_POOL() external view returns (ILendingPool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"./ILendingPoolAddressesProvider.sol\\\";\\nimport {DataTypes} from \\\"../../structs/SAave.sol\\\";\\n\\ninterface ILendingPool {\\n    /**\\n     * @dev Emitted on deposit()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the deposit\\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\n     * @param amount The amount deposited\\n     * @param referral The referral code used\\n     **/\\n    event Deposit(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referral\\n    );\\n\\n    /**\\n     * @dev Emitted on withdraw()\\n     * @param reserve The address of the underlyng asset being withdrawn\\n     * @param user The address initiating the withdrawal, owner of aTokens\\n     * @param to Address that will receive the underlying\\n     * @param amount The amount to be withdrawn\\n     **/\\n    event Withdraw(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n     * @param reserve The address of the underlying asset being borrowed\\n     * @param user The address of the user initiating the borrow(),\\n     * receiving the funds on borrow() or just\\n     * initiator of the transaction on flashLoan()\\n     * @param onBehalfOf The address that will be getting the debt\\n     * @param amount The amount borrowed out\\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\n     * @param borrowRate The numeric rate at which the user has borrowed\\n     * @param referral The referral code used\\n     **/\\n    event Borrow(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 borrowRateMode,\\n        uint256 borrowRate,\\n        uint16 indexed referral\\n    );\\n\\n    /**\\n     * @dev Emitted on repay()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The beneficiary of the repayment, getting his debt reduced\\n     * @param repayer The address of the user initiating the repay(), providing the funds\\n     * @param amount The amount repaid\\n     **/\\n    event Repay(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed repayer,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on swapBorrowRateMode()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user swapping his rate mode\\n     * @param rateMode The rate mode that the user wants to swap to\\n     **/\\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     **/\\n    event ReserveUsedAsCollateralEnabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     **/\\n    event ReserveUsedAsCollateralDisabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on rebalanceStableBorrowRate()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user for which the rebalance has been executed\\n     **/\\n    event RebalanceStableBorrowRate(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on flashLoan()\\n     * @param target The address of the flash loan receiver contract\\n     * @param initiator The address initiating the flash loan\\n     * @param asset The address of the asset being flash borrowed\\n     * @param amount The amount flash borrowed\\n     * @param premium The fee flash borrowed\\n     * @param referralCode The referral code used\\n     **/\\n    event FlashLoan(\\n        address indexed target,\\n        address indexed initiator,\\n        address indexed asset,\\n        uint256 amount,\\n        uint256 premium,\\n        uint16 referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted when the pause is triggered.\\n     */\\n    event Paused();\\n\\n    /**\\n     * @dev Emitted when the pause is lifted.\\n     */\\n    event Unpaused();\\n\\n    /**\\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\n     * LendingPoolCollateral manager using a DELEGATECALL\\n     * This allows to have the events in the generated ABI for LendingPool.\\n     * @param collateralAsset The address of the underlying asset used as collateral,\\n     * to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the\\n     * liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\n     * @param liquidator The address of the liquidator\\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens,\\n     * `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     **/\\n    event LiquidationCall(\\n        address indexed collateralAsset,\\n        address indexed debtAsset,\\n        address indexed user,\\n        uint256 debtToCover,\\n        uint256 liquidatedCollateralAmount,\\n        address liquidator,\\n        bool receiveAToken\\n    );\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n     * in the ReserveLogic library and emitted in the updateInterestRates() function.\\n     * Since the function is internal, the event will actually be fired by the LendingPool contract.\\n     * The event is therefore replicated here so it\\n     * gets added to the LendingPool ABI\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param liquidityRate The new liquidity rate\\n     * @param stableBorrowRate The new stable borrow rate\\n     * @param variableBorrowRate The new variable borrow rate\\n     * @param liquidityIndex The new liquidity index\\n     * @param variableBorrowIndex The new variable borrow index\\n     **/\\n    event ReserveDataUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve,\\n     * receiving in return overlying aTokens.\\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to deposit\\n     * @param amount The amount to be deposited\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     * wants to receive them on his own wallet,\\n     * or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws an `amount` of underlying asset from the reserve,\\n     * burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     **/\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset,\\n     * provided that the borrower\\n     * already deposited enough collateral, or he was given enough allowance by a credit\\n     * delegator on the\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address,\\n     * receiving the 100 USDC in his wallet\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n     * @param asset The address of the underlying asset to borrow\\n     * @param amount The amount to be borrowed\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow:\\n     * - 1 for Stable,\\n     * - 2 for Variable\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param onBehalfOf Address of the user who will receive the debt.\\n     * Should be the address of the borrower itself\\n     * calling the function if he wants to borrow against his own collateral,\\n     * or the address of the credit delegator\\n     * if he has been given credit delegation allowance\\n     **/\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve,\\n     * burning the equivalent debt tokens owned\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt\\n     * tokens of the `onBehalfOf` address\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt\\n     * for `asset` on the specific `debtMode`\\n     * @param rateMode The interest rate mode at of the debt the user wants to repay:\\n     * - 1 for Stable,\\n     * - 2 for Variable\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed.\\n     * Should be the address of the user calling the function\\n     * if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @return The final amount repaid\\n     **/\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\n     * @param asset The address of the underlying asset borrowed\\n     * @param rateMode The rate mode that the user wants to swap to\\n     **/\\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\\n\\n    /**\\n     * @dev Rebalances the stable interest rate of a user to\\n     * the current stable rate defined on the reserve.\\n     * - Users can be rebalanced if the following conditions are satisfied:\\n     *     1. Usage ratio is above 95%\\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate,\\n     *        which means that too much has been\\n     *        borrowed at a stable rate and depositors are not earning enough\\n     * @param asset The address of the underlying asset borrowed\\n     * @param user The address of the user to be rebalanced\\n     **/\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n    /**\\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n     * @param asset The address of the underlying asset deposited\\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral,\\n     * `false` otherwise\\n     **/\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\\n        external;\\n\\n    /**\\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n     * - The caller (liquidator) covers `debtToCover` amount of debt\\n     * of the user getting liquidated, and receives\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n     * @param collateralAsset The address of the underlying asset used as collateral,\\n     * to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset\\n     * to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens,\\n     * `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     **/\\n    function liquidationCall(\\n        address collateralAsset,\\n        address debtAsset,\\n        address user,\\n        uint256 debtToCover,\\n        bool receiveAToken\\n    ) external;\\n\\n    /**\\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * IMPORTANT There are security concerns for developers\\n     * of flashloan receiver contracts that must be kept into consideration.\\n     * For further details please visit https://developers.aave.com\\n     * @param receiverAddress The address of the contract receiving the funds,\\n     * implementing the IFlashLoanReceiver interface\\n     * @param assets The addresses of the assets being flash-borrowed\\n     * @param amounts The amounts amounts being flash-borrowed\\n     * @param modes Types of the debt to open if the flash loan is not returned:\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n     *   1 -> Open debt at stable rate for the value of the amount\\n     *        flash-borrowed to the `onBehalfOf` address\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed\\n     *        to the `onBehalfOf` address\\n     * @param onBehalfOf The address  that will receive the debt in\\n     * the case of using on `modes` 1 or 2\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata modes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Returns the user account data across all the reserves\\n     * @param user The address of the user\\n     * @return totalCollateralETH the total collateral in ETH of the user\\n     * @return totalDebtETH the total debt in ETH of the user\\n     * @return availableBorrowsETH the borrowing power left of the user\\n     * @return currentLiquidationThreshold the liquidation threshold of the user\\n     * @return ltv the loan to value of the user\\n     * @return healthFactor the current health factor of the user\\n     **/\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralETH,\\n            uint256 totalDebtETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    function initReserve(\\n        address reserve,\\n        address aTokenAddress,\\n        address stableDebtAddress,\\n        address variableDebtAddress,\\n        address interestRateStrategyAddress\\n    ) external;\\n\\n    function setReserveInterestRateStrategyAddress(\\n        address reserve,\\n        address rateStrategyAddress\\n    ) external;\\n\\n    function setConfiguration(address reserve, uint256 configuration) external;\\n\\n    /**\\n     * @dev Returns the configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The configuration of the reserve\\n     **/\\n    function getConfiguration(address asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory);\\n\\n    /**\\n     * @dev Returns the configuration of the user across all the reserves\\n     * @param user The user address\\n     * @return The configuration of the user\\n     **/\\n    function getUserConfiguration(address user)\\n        external\\n        view\\n        returns (DataTypes.UserConfigurationMap memory);\\n\\n    /**\\n     * @dev Returns the normalized income normalized income of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve's normalized income\\n     */\\n    function getReserveNormalizedIncome(address asset)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized variable debt per unit of asset\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve normalized variable debt\\n     */\\n    function getReserveNormalizedVariableDebt(address asset)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns the state and configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The state of the reserve\\n     **/\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory);\\n\\n    function finalizeTransfer(\\n        address asset,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 balanceFromAfter,\\n        uint256 balanceToBefore\\n    ) external;\\n\\n    function getReservesList() external view returns (address[] memory);\\n\\n    function getAddressesProvider()\\n        external\\n        view\\n        returns (ILendingPoolAddressesProvider);\\n\\n    function setPause(bool val) external;\\n\\n    function paused() external view returns (bool);\\n\\n    /// solhint-disable-next-line func-name-mixedcase\\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol,\\n * including permissioned roles\\n * - Acting also as factory of proxies and admin of those,\\n *   so with right to change its implementations\\n * - Owned by the Aave Governance\\n * @author Aave\\n **/\\ninterface ILendingPoolAddressesProvider {\\n    event MarketIdSet(string newMarketId);\\n    event LendingPoolUpdated(address indexed newAddress);\\n    event ConfigurationAdminUpdated(address indexed newAddress);\\n    event EmergencyAdminUpdated(address indexed newAddress);\\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n    event PriceOracleUpdated(address indexed newAddress);\\n    event LendingRateOracleUpdated(address indexed newAddress);\\n    event ProxyCreated(bytes32 id, address indexed newAddress);\\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n    function getMarketId() external view returns (string memory);\\n\\n    function setMarketId(string calldata marketId) external;\\n\\n    function setAddress(bytes32 id, address newAddress) external;\\n\\n    function setAddressAsProxy(bytes32 id, address impl) external;\\n\\n    function getAddress(bytes32 id) external view returns (address);\\n\\n    function getLendingPool() external view returns (address);\\n\\n    function setLendingPoolImpl(address pool) external;\\n\\n    function getLendingPoolConfigurator() external view returns (address);\\n\\n    function setLendingPoolConfiguratorImpl(address configurator) external;\\n\\n    function getLendingPoolCollateralManager() external view returns (address);\\n\\n    function setLendingPoolCollateralManager(address manager) external;\\n\\n    function getPoolAdmin() external view returns (address);\\n\\n    function setPoolAdmin(address admin) external;\\n\\n    function getEmergencyAdmin() external view returns (address);\\n\\n    function setEmergencyAdmin(address admin) external;\\n\\n    function getPriceOracle() external view returns (address);\\n\\n    function setPriceOracle(address priceOracle) external;\\n\\n    function getLendingRateOracle() external view returns (address);\\n\\n    function setLendingRateOracle(address lendingRateOracle) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IPriceOracle {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n\\n    function getAssetsPrices(address[] calldata _assets)\\n        external\\n        view\\n        returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IProtocolDataProvider {\\n    function getReserveConfigurationData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256 decimals,\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            uint256 reserveFactor,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive,\\n            bool isFrozen\\n        );\\n\\n    function getUserReserveData(address asset, address user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentStableDebt,\\n            uint256 currentVariableDebt,\\n            uint256 principalStableDebt,\\n            uint256 scaledVariableDebt,\\n            uint256 stableBorrowRate,\\n            uint256 liquidityRate,\\n            uint40 stableRateLastUpdated,\\n            bool usageAsCollateralEnabled\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IAction {\\n    function exec(\\n        bytes32 _taskHash,\\n        bytes memory _data,\\n        bytes memory _offChainData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {IAction} from \\\"./IAction.sol\\\";\\n\\ninterface IProtectionAction is IAction {\\n    /// sohint-disable-next-line func-name-mixedcase\\n    function slippageInBps() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/module/ISwapModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface ISwapModule {\\n    function swap(address[] memory _swapActions, bytes[] memory _swapDatas)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/services/aave/FlashLoanReceiverBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nimport {IFlashLoanReceiver} from \\\"../../interfaces/aave/IFlashLoanReceiver.sol\\\";\\nimport {ILendingPool} from \\\"../../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\n\\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\\n    // solhint-disable-next-line var-name-mixedcase\\n    ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\\n    // solhint-disable-next-line var-name-mixedcase\\n    ILendingPool public immutable override LENDING_POOL;\\n\\n    constructor(ILendingPoolAddressesProvider provider) {\\n        ADDRESSES_PROVIDER = provider;\\n        LENDING_POOL = ILendingPool(provider.getLendingPool());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/services/aave/actions/ProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {\\n    IProtectionAction\\n} from \\\"../../../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {\\n    Initializable\\n} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport {Proxied} from \\\"../../../vendor/hardhat-deploy/Proxied.sol\\\";\\nimport {FlashLoanReceiverBase} from \\\"../FlashLoanReceiverBase.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    ProtectionPayload,\\n    FlashLoanData,\\n    FlashLoanParamsData\\n} from \\\"../../../structs/SProtection.sol\\\";\\nimport {\\n    _checkRepayAndFlashBorrowAmt,\\n    _getProtectionPayload,\\n    _flashLoan,\\n    _requirePositionSafe,\\n    _requirePositionUnSafe,\\n    _paybackToLendingPool,\\n    _withdrawCollateral,\\n    _swap,\\n    _approveERC20Token,\\n    _transferFees,\\n    _transferDust,\\n    _checkSubmitterIsUser\\n} from \\\"../../../functions/FProtectionAction.sol\\\";\\nimport {_convertEthToToken} from \\\"../../../functions/FProtection.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ETH} from \\\"../../../constants/CTokens.sol\\\";\\nimport {\\n    DISCREPANCY_BPS_CAP,\\n    TEN_THOUSAND_BPS,\\n    SLIPPAGE_BPS_CAP\\n} from \\\"../../../constants/CProtectionAction.sol\\\";\\nimport {ISwapModule} from \\\"../../../interfaces/services/module/ISwapModule.sol\\\";\\n\\n/// @author Gelato Digital\\n/// @title Protection Action Contract.\\n/// @dev Perform protection by repaying the debt with collateral token.\\ncontract ProtectionAction is\\n    IProtectionAction,\\n    Initializable,\\n    Proxied,\\n    FlashLoanReceiverBase\\n{\\n    uint256 public discrepancyBps;\\n    uint256 public override slippageInBps;\\n\\n    address internal immutable _aaveServices;\\n    ISwapModule internal immutable _swapModule;\\n\\n    event LogProtectionAction(\\n        bytes32 taskHash,\\n        uint256 healthFactorBefore,\\n        uint256 protectionFee, // In Collateral Token\\n        uint256 flashloanFee, // In Collateral Token\\n        uint256 colNeededForProtection,\\n        uint256 debtRepaid,\\n        address onBehalfOf\\n    );\\n\\n    modifier onlyLendingPool() {\\n        require(\\n            msg.sender == address(LENDING_POOL),\\n            \\\"Only Lending Pool can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyAaveServices() {\\n        require(\\n            msg.sender == _aaveServices,\\n            \\\"Only Aave Services can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        ILendingPoolAddressesProvider _addressProvider,\\n        address __aaveServices,\\n        ISwapModule __swapModule\\n    ) FlashLoanReceiverBase(_addressProvider) {\\n        _aaveServices = __aaveServices;\\n        _swapModule = __swapModule;\\n    }\\n\\n    function initialize() external initializer {\\n        discrepancyBps = 200;\\n        slippageInBps = 200;\\n    }\\n\\n    /// @dev Set discrepancyBps of how far the final HF can be to the one wanted, capped to 5%.\\n    function setDiscrepancyBps(uint256 _discrepancyBps)\\n        external\\n        onlyProxyAdmin\\n    {\\n        require(\\n            _discrepancyBps <= DISCREPANCY_BPS_CAP,\\n            \\\"ProtectionAction.setDiscrepancyBps: _discrepancyBps > 5%\\\"\\n        );\\n        discrepancyBps = _discrepancyBps;\\n    }\\n\\n    ///@dev Set slippageInBps, capped to 5%\\n    function setSlippageInBps(uint256 _slippageInBps) external onlyProxyAdmin {\\n        require(\\n            _slippageInBps <= SLIPPAGE_BPS_CAP,\\n            \\\"ProtectionAction.setSlippageInBps: slippageInBps > 5%\\\"\\n        );\\n        slippageInBps = _slippageInBps;\\n    }\\n\\n    /// @dev Safety function for testing.\\n    function retrieveFunds(address _token, address _to)\\n        external\\n        onlyProxyAdmin\\n    {\\n        if (_token == ETH) payable(_to).transfer(address(this).balance);\\n        else\\n            IERC20(_token).transfer(\\n                _to,\\n                IERC20(_token).balanceOf(address(this))\\n            );\\n    }\\n\\n    /// Execution of Protection.\\n    /// @param _taskHash Task identifier.\\n    /// @param _data Data needed to perform Protection.\\n    /// @dev _data is on-chain data, one of the input to produce Task hash of Aave services.\\n    /// @param _offChainData Data computed off-chain and needed to perform Protection.\\n    /// @dev _offChainData include the amount of collateral to withdraw\\n    /// and the amount of debt token to repay, cannot be computed on-chain.\\n    // solhint-disable function-max-lines\\n    function exec(\\n        bytes32 _taskHash,\\n        bytes memory _data,\\n        bytes memory _offChainData\\n    ) external virtual override onlyAaveServices {\\n        ProtectionPayload memory protectionPayload = _getProtectionPayload(\\n            _taskHash,\\n            _data,\\n            _offChainData\\n        );\\n\\n        // Check if the task submitter is the aave user.\\n        _checkSubmitterIsUser(protectionPayload, _data);\\n\\n        // Check if AmtToFlashBorrow and AmtOfDebtToRepay are the one given by the formula.\\n        _checkRepayAndFlashBorrowAmt(\\n            protectionPayload,\\n            LENDING_POOL,\\n            ADDRESSES_PROVIDER,\\n            this\\n        );\\n        // Cannot give to executeOperation the path array through params bytes\\n        // => Stack too Deep error.\\n\\n        _flashLoan(LENDING_POOL, address(this), protectionPayload);\\n\\n        // Fetch User Data After Refinancing\\n\\n        (, , , , , uint256 healthFactor) = LENDING_POOL.getUserAccountData(\\n            protectionPayload.onBehalfOf\\n        );\\n\\n        // Check if the service didn't keep any dust amt.\\n        _transferDust(\\n            address(this),\\n            protectionPayload.debtToken,\\n            protectionPayload.onBehalfOf\\n        );\\n\\n        // Check if position is safe.\\n        _requirePositionSafe(\\n            healthFactor,\\n            discrepancyBps,\\n            protectionPayload.wantedHealthFactor\\n        );\\n    }\\n\\n    /// @dev function called by LendingPool after flash borrow.\\n    /// @param _assets borrowed tokens.\\n    /// @param _amounts borrowed amounts associated to borrowed tokens.\\n    /// @param _premiums premiums to repay.\\n    /// @param _params custom parameters.\\n    /// @dev _params contains collateral token, amount of Collateral to\\n    /// wiithdraw, borrow rate mode, the user who need protection and\\n    /// swap module used to swap collateral token into debt token.\\n    function executeOperation(\\n        address[] calldata _assets,\\n        uint256[] calldata _amounts,\\n        uint256[] calldata _premiums,\\n        address _initiator,\\n        bytes calldata _params\\n    ) external override onlyLendingPool returns (bool) {\\n        require(\\n            _initiator == address(this),\\n            \\\"Only ProtectionAction can do flashloan\\\"\\n        );\\n        FlashLoanData memory flashloanData = FlashLoanData(\\n            _assets,\\n            _amounts,\\n            _premiums,\\n            _params\\n        );\\n        return _executeOperation(flashloanData);\\n    }\\n\\n    // solhint-disable function-max-lines\\n    // repay logic should be here.\\n    function _executeOperation(FlashLoanData memory _flashloanData)\\n        internal\\n        returns (bool)\\n    {\\n        FlashLoanParamsData memory paramsData = abi.decode(\\n            _flashloanData.params,\\n            (FlashLoanParamsData)\\n        );\\n\\n        /// @notice Check if current health factor is below minimum health factor.\\n        (, , , , , uint256 healthFactorBefore) = LENDING_POOL\\n            .getUserAccountData(paramsData.onBehalfOf);\\n        _requirePositionUnSafe(\\n            healthFactorBefore,\\n            paramsData.minimumHealthFactor\\n        );\\n\\n        /// @notice Swap Collateral token to debt token.\\n\\n        uint256 debtRepaid = _swap(\\n            address(this),\\n            _swapModule,\\n            paramsData.swapActions,\\n            paramsData.swapDatas,\\n            IERC20(paramsData.debtToken),\\n            IERC20(_flashloanData.assets[0]),\\n            _flashloanData.amounts[0],\\n            paramsData.amtOfDebtToRepay\\n        );\\n\\n        /// @notice Payback debt.\\n\\n        _paybackToLendingPool(\\n            LENDING_POOL,\\n            paramsData.debtToken,\\n            debtRepaid,\\n            paramsData.rateMode,\\n            paramsData.onBehalfOf\\n        );\\n\\n        /// @notice Withdraw collateral (including fees) and flashloan premium.\\n\\n        uint256 fees = _convertEthToToken(\\n            ADDRESSES_PROVIDER,\\n            _flashloanData.assets[0],\\n            paramsData.protectionFeeInETH\\n        );\\n\\n        uint256 amtOfColToWithdraw = _flashloanData.amounts[0] +\\n            fees +\\n            _flashloanData.premiums[0];\\n\\n        _withdrawCollateral(\\n            LENDING_POOL,\\n            address(this),\\n            _flashloanData.assets[0],\\n            amtOfColToWithdraw,\\n            paramsData.onBehalfOf\\n        );\\n\\n        /// @notice Transfer Fees\\n\\n        _transferFees(_flashloanData.assets[0], fees);\\n\\n        /// @notice Approve to retrieve.\\n\\n        _approveERC20Token(\\n            _flashloanData.assets[0],\\n            address(LENDING_POOL),\\n            _flashloanData.amounts[0] + _flashloanData.premiums[0]\\n        );\\n\\n        emit LogProtectionAction(\\n            paramsData.taskHash,\\n            healthFactorBefore,\\n            fees,\\n            _flashloanData.premiums[0],\\n            amtOfColToWithdraw,\\n            debtRepaid,\\n            paramsData.onBehalfOf\\n        );\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nlibrary DataTypes {\\n    // refer to the whitepaper,\\n    // section 1.1 basic concepts for a formal description of these properties.\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        //tokens addresses\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint8 id;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: Reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60-63: reserved\\n        //bit 64-79: reserve factor\\n        uint256 data;\\n    }\\n\\n    struct UserConfigurationMap {\\n        uint256 data;\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nstruct ProtectionPayload {\\n    bytes32 taskHash;\\n    address colToken;\\n    address debtToken;\\n    uint256 rateMode;\\n    uint256 amtToFlashBorrow;\\n    uint256 amtOfDebtToRepay;\\n    uint256 minimumHealthFactor;\\n    uint256 wantedHealthFactor;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    address[] swapActions;\\n    bytes[] swapDatas;\\n    uint256 subBlockNumber;\\n    bool isPermanent;\\n}\\n\\nstruct ExecutionData {\\n    address user;\\n    address action;\\n    uint256 subBlockNumber;\\n    bytes data;\\n    bytes offChainData;\\n    bool isPermanent;\\n}\\n\\nstruct ProtectionDataCompute {\\n    address colToken;\\n    address debtToken;\\n    uint256 totalCollateralETH;\\n    uint256 totalBorrowsETH;\\n    uint256 currentLiquidationThreshold;\\n    uint256 colLiquidationThreshold;\\n    uint256 wantedHealthFactor;\\n    uint256 colPrice;\\n    uint256 debtPrice;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    uint256 flashloanPremiumBps;\\n}\\n\\nstruct FlashLoanData {\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] premiums;\\n    bytes params;\\n}\\n\\nstruct FlashLoanParamsData {\\n    uint256 minimumHealthFactor;\\n    bytes32 taskHash;\\n    address debtToken;\\n    uint256 amtOfDebtToRepay;\\n    uint256 rateMode;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    address[] swapActions;\\n    bytes[] swapDatas;\\n}\\n\\nstruct RepayAndFlashBorrowData {\\n    bytes32 id;\\n    address user;\\n    address colToken;\\n    address debtToken;\\n    uint256 wantedHealthFactor;\\n    uint256 protectionFeeInETH;\\n}\\n\\nstruct RepayAndFlashBorrowResult {\\n    bytes32 id;\\n    uint256 amtToFlashBorrow;\\n    uint256 amtOfDebtToRepay;\\n    string message;\\n}\\n\\nstruct CanExecData {\\n    bytes32 id;\\n    address user;\\n    uint256 minimumHF;\\n    address colToken;\\n    address spender;\\n}\\n\\nstruct CanExecResult {\\n    bytes32 id;\\n    bool isPositionUnSafe;\\n    bool isATokenAllowed;\\n    string message;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n// solhint-disable\\nfunction _add(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\n\\nfunction _sub(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\n\\nfunction _mul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction _min(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction _max(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nfunction _imin(int256 x, int256 y) pure returns (int256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction _imax(int256 x, int256 y) pure returns (int256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint256 constant WAD = 10**18;\\nuint256 constant RAY = 10**27;\\nuint256 constant QUA = 10**4;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _wmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), WAD / 2) / WAD;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _rmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), RAY / 2) / RAY;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, WAD), y / 2) / y;\\n}\\n\\n//rounds to zero if x*y < RAY / 2\\nfunction _rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction _rpow(uint256 x, uint256 n) pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = _rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = _rmul(z, x);\\n        }\\n    }\\n}\\n\\n//rounds to zero if x*y < QUA / 2\\nfunction _qmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), QUA / 2) / QUA;\\n}\\n\\n//rounds to zero if x*y < QUA / 2\\nfunction _qdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, QUA), y / 2) / y;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/hardhat-deploy/Proxied.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"_addressProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__aaveServices\",\"type\":\"address\"},{\"internalType\":\"contract ISwapModule\",\"name\":\"__swapModule\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"healthFactorBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flashloanFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"colNeededForProtection\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtRepaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"LogProtectionAction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LENDING_POOL\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discrepancyBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_offChainData\",\"type\":\"bytes\"}],\"name\":\"exec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"retrieveFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_discrepancyBps\",\"type\":\"uint256\"}],\"name\":\"setDiscrepancyBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippageInBps\",\"type\":\"uint256\"}],\"name\":\"setSlippageInBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippageInBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProtectionAction","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000b53c1a33016b2dc2ff3653530bff1848a515c8c5000000000000000000000000e3d373c78803c1d22ce96bdc43d47542835bbf42000000000000000000000000177bd89a1d8643c9525d2df131c1a6c513869299","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}