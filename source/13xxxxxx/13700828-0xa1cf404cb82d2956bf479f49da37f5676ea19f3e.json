{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/registry/connectors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title StakeAllConnectorsV2\\n * @dev Registry for Connectors.\\n */\\n\\ninterface IndexInterface {\\n    function master() external view returns (address);\\n}\\n\\ninterface ConnectorInterface {\\n    function name() external view returns (string memory);\\n}\\n\\ncontract Controllers {\\n    event LogController(address indexed addr, bool indexed isChief);\\n\\n    // StakeAllIndex Address.\\n    address public immutable stakeAllIndex;\\n\\n    constructor(address _stakeAllIndex) {\\n        stakeAllIndex = _stakeAllIndex;\\n    }\\n\\n    // Enabled Chief(Address of Chief => bool).\\n    mapping(address => bool) public chief;\\n    // Enabled Connectors(Connector name => address).\\n    mapping(string => address) public connectors;\\n\\n    /**\\n     * @dev Throws if the sender not is Master Address from StakeAllIndex\\n     * or Enabled Chief.\\n     */\\n    modifier isChief() {\\n        require(\\n            chief[msg.sender] ||\\n                msg.sender == IndexInterface(stakeAllIndex).master(),\\n            \\\"not-an-chief\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Toggle a Chief. Enable if disable & vice versa\\n     * @param _chiefAddress Chief Address.\\n     */\\n    function toggleChief(address _chiefAddress) external {\\n        require(\\n            msg.sender == IndexInterface(stakeAllIndex).master(),\\n            \\\"toggleChief: not-master\\\"\\n        );\\n        chief[_chiefAddress] = !chief[_chiefAddress];\\n        emit LogController(_chiefAddress, chief[_chiefAddress]);\\n    }\\n}\\n\\ncontract StakeAllConnectorsV2 is Controllers {\\n    event LogConnectorAdded(\\n        bytes32 indexed connectorNameHash,\\n        string connectorName,\\n        address indexed connector\\n    );\\n    event LogConnectorUpdated(\\n        bytes32 indexed connectorNameHash,\\n        string connectorName,\\n        address indexed oldConnector,\\n        address indexed newConnector\\n    );\\n    event LogConnectorRemoved(\\n        bytes32 indexed connectorNameHash,\\n        string connectorName,\\n        address indexed connector\\n    );\\n\\n    constructor(address _stakeAllIndex) public Controllers(_stakeAllIndex) {}\\n\\n    /**\\n     * @dev Add Connectors\\n     * @param _connectorNames Array of Connector Names.\\n     * @param _connectors Array of Connector Address.\\n     */\\n    function addConnectors(\\n        string[] calldata _connectorNames,\\n        address[] calldata _connectors\\n    ) external isChief {\\n        require(\\n            _connectors.length == _connectors.length,\\n            \\\"addConnectors: not same length\\\"\\n        );\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\n            require(\\n                connectors[_connectorNames[i]] == address(0),\\n                \\\"addConnectors: _connectorName added already\\\"\\n            );\\n            require(\\n                _connectors[i] != address(0),\\n                \\\"addConnectors: _connectors address not vaild\\\"\\n            );\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\n            connectors[_connectorNames[i]] = _connectors[i];\\n            emit LogConnectorAdded(\\n                keccak256(abi.encodePacked(_connectorNames[i])),\\n                _connectorNames[i],\\n                _connectors[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Update Connectors\\n     * @param _connectorNames Array of Connector Names.\\n     * @param _connectors Array of Connector Address.\\n     */\\n    function updateConnectors(\\n        string[] calldata _connectorNames,\\n        address[] calldata _connectors\\n    ) external isChief {\\n        require(\\n            _connectorNames.length == _connectors.length,\\n            \\\"updateConnectors: not same length\\\"\\n        );\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\n            require(\\n                connectors[_connectorNames[i]] != address(0),\\n                \\\"updateConnectors: _connectorName not added to update\\\"\\n            );\\n            require(\\n                _connectors[i] != address(0),\\n                \\\"updateConnectors: _connector address is not vaild\\\"\\n            );\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\n            emit LogConnectorUpdated(\\n                keccak256(abi.encodePacked(_connectorNames[i])),\\n                _connectorNames[i],\\n                connectors[_connectorNames[i]],\\n                _connectors[i]\\n            );\\n            connectors[_connectorNames[i]] = _connectors[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev Remove Connectors\\n     * @param _connectorNames Array of Connector Names.\\n     */\\n    function removeConnectors(string[] calldata _connectorNames)\\n        external\\n        isChief\\n    {\\n        for (uint256 i = 0; i < _connectorNames.length; i++) {\\n            require(\\n                connectors[_connectorNames[i]] != address(0),\\n                \\\"removeConnectors: _connectorName not added to remove\\\"\\n            );\\n            emit LogConnectorRemoved(\\n                keccak256(abi.encodePacked(_connectorNames[i])),\\n                _connectorNames[i],\\n                connectors[_connectorNames[i]]\\n            );\\n            delete connectors[_connectorNames[i]];\\n        }\\n    }\\n\\n    /**\\n     * @dev Check if Connector addresses are enabled.\\n     * @param _connectors Array of Connector Names.\\n     */\\n    function isConnectors(string[] calldata _connectorNames)\\n        external\\n        view\\n        returns (bool isOk, address[] memory _connectors)\\n    {\\n        isOk = true;\\n        uint256 len = _connectorNames.length;\\n        _connectors = new address[](len);\\n        for (uint256 i = 0; i < _connectors.length; i++) {\\n            _connectors[i] = connectors[_connectorNames[i]];\\n            if (_connectors[i] == address(0)) {\\n                isOk = false;\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAllIndex\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"connectorNameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"LogConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"connectorNameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"LogConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"connectorNameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldConnector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newConnector\",\"type\":\"address\"}],\"name\":\"LogConnectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isChief\",\"type\":\"bool\"}],\"name\":\"LogController\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"addConnectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chief\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"}],\"name\":\"isConnectors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOk\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"}],\"name\":\"removeConnectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAllIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chiefAddress\",\"type\":\"address\"}],\"name\":\"toggleChief\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"updateConnectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakeAllConnectorsV2","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000086d9b80cf2907843b4030c8aa60f1bc8d92a226c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}