{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.7;\r\n\r\n/** @title BetHorde: decentralised bets.\r\n  * @author u/bethorde\r\n  * @notice Truly decentralised bets. No trust. No oracles. Provably random.\r\n  *\r\n  *  Anyone can be a player or a house. Randomness through RSA signatures.\r\n  *\r\n  *  Takes:\r\n  *    If player loses, they lose amount that they bet.\r\n  *    If player wins, they receive:\r\n  *      odds * bet price * (1 - (house take + contract take)).\r\n  *    House take: 0% <= house take <= 10% (0.01% increments, set by house).\r\n  *    Contract take (where pot = odds * bet price):\r\n  *      Pot < 0.1 ETH:         1.0% take\r\n  *      0.1 ETH < Pot < 1 ETH: 0.5% take\r\n  *      1 ETH < Pot < 5 ETH:   0.2% take\r\n  *      Pot > 5 ETH:           0.1% take\r\n  *\r\n  *  Play:\r\n  *    Players call 'CreatePlayer' to create an account and play with 'PlaceBet'.\r\n  *      Funds can be added during calls to 'PlaceBet'.\r\n  *      Withdrawals can be made using 'PlayerWithdraw'.\r\n  *      If house takes over 24 hours to decide a bet, 'ForceBet' can be called.\r\n  *    Houses call 'OpenOrAdjustHouse' to set up a house.\r\n  *      Set min_bet and max_loss parameters to limit incoming bets.\r\n  *      Call 'DecideBet' on incoming bets within 24 hours (or a house loss can be forced).\r\n  *      Call 'FundHouse' to add funds to a house,\r\n  *      Call 'TogglePauseHouse' to pause/unpause a house. While a house is\r\n  *      paused, and if all bets have been decided, house can call\r\n  *      'HouseWithdraw' and 'OpenOrAdjustHouse'. No new bets can be placed while a house is paused.\r\n  *    Anyone can call `ForceBet` if a house has not decided a bet within 24 hours.\r\n  *      Results in player winning.\r\n  *      House take goes to house address that called `ForceBet`.\r\n  *      Funds can only be withdrawn if house exists.\r\n  *      House can be set up after funds arrive without losing funds.\r\n  * \r\n  *  Randomness:\r\n  *    House provides public part of an RSA key in advance.\r\n  *    Player provides randomness when placing a bet.\r\n  *    Randomness is combined with a nonce and hashed.\r\n  *    House signs hash in bet with house private key.\r\n  *    Unless player knows the key, there is no way to cheat.\r\n  *\r\n  *  This scheme works on four facts/assumptions:\r\n  *    1. House uses a secure 2048 bit RSA key.\r\n  *    2. House cannot control random input from player.\r\n  *    3. Player cannot predict how private key will sign random value.\r\n  *    4. An RSA key can only sign a given message in one way.\r\n  *\r\n  *  A few ways to cheat are dealt with:\r\n  *    1. Players can replay winning 'random' values to keep winning.\r\n  *      - Randomness combined with other data, including a nonce, and hashed.\r\n  *    2. Changing house parameters or withdrawing funds to avoid incoming bets.\r\n  *      - Houses must be paused and have no unresolved bets to take these actions.\r\n  *      - Pauses start 250 blocks after being requested.\r\n  *      - 'PlaceBet' function has a bet_placed_timestamp parameter, preventing\r\n  *        bets from being placed after house parameters have changed.\r\n  *    3. House bets against itself to run out of funds for upcoming losing bets.\r\n  *      - Last_low_balance_timestamp marks recent low funds.\r\n  *    4. Private keys could be insecure/leaked.\r\n  *      - House can change keys and is incentivised not to pick insecure keys.\r\n  *      - 2048 bit RSA keys.\r\n  * \r\n  *  Signing:\r\n  *    (EMSA-PKCS1-v1_5 in RFC 3447)\r\n  *    1. Generate 2048 bit RSA key.\r\n  *      - d: private exponent.\r\n  *      - n: modulus (public, 2048 bits).\r\n  *      - e: public exponent (must be 17).\r\n  *    2. When creating (or adjusting) a house, supply n as bytes32[8].\r\n  *    3. When signing a bet, pad the 32 byte bet.randomness value:\r\n  *      [0x0001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\r\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\r\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\r\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\r\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\r\n  *       0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\r\n  *       0x0001fffffffffffffffffff0013031300d060960864801650304020105000420,\r\n  *       <32 byte bet.randomness>]\r\n  *    5. Sign array (treat it as a large hexadecimal integer):\r\n  *      - (padded ^ d) % n.\r\n  *    6. Supply signed value as bytes32[8] to 'DecideBet'.\r\n  */\r\n\r\ncontract BetHorde {\r\n\r\n  /* --- PLAYER ACTIONS --- */\r\n  /** @notice Create a new player for msg.sender (required before placing bets). */\r\n  function CreatePlayer() external {\r\n    require(players[msg.sender].creation_block == 0, \"Player exists\");\r\n    players[msg.sender].nonce = 1;\r\n    players[msg.sender].creation_block = block.number;\r\n  }\r\n\r\n  /** @notice Place bet. Adds msg.value to player account before deducting bet.\r\n    * @param house House to bet against.\r\n    * @param odds Bet odds: 1 / odds chance of winning odds * amount_gwei.\r\n    *  Winnings are subject to house and contract takes. 2 <= odds <= 1 million.\r\n    * @param amount_gwei GWEI to bet.\r\n    * @param randomness Random 32 byte value.\r\n    * @param nonce A value larger than current nonce, but not by more than 10.\r\n    * @param bet_placed_timestamp When player created the bet (protects against\r\n    *  house changing parameters after bet is sent).\r\n    */\r\n  function PlaceBet(address house, uint256 odds, uint256 amount_gwei,\r\n                    bytes32 randomness, uint256 nonce,\r\n                    uint256 bet_placed_timestamp) payable external {\r\n    uint256 amount = amount_gwei * 1 gwei;\r\n    require(state.bet_counter < type(uint32).max);\r\n    require(houses[house].pause_block > block.number,\r\n            \"House unavailable\");\r\n    require(players[msg.sender].creation_block > 0,\r\n            \"Create player\");\r\n    require(odds > 1 && odds <= 1e6, \"Invalid odds\");\r\n    // House updated after bet was placed.\r\n    require(bet_placed_timestamp > houses[house].last_update_timestamp,\r\n            \"House updated\");\r\n    require(amount <= players[msg.sender].balance + msg.value,\r\n            \"Insufficient funds\");\r\n    players[msg.sender].balance = players[msg.sender].balance + msg.value - amount;\r\n    require(nonce > players[msg.sender].nonce\r\n            && nonce <= players[msg.sender].nonce + 10,\r\n            \"Nonce\");\r\n    require(amount >= houses[house].min_bet, \"Bet too low\");\r\n    require(amount * odds <= houses[house].max_loss, \"Exceeds max loss\");\r\n    // Subtract 1 from odds (player pays for bet).\r\n    require(amount * (odds - 1) <= houses[house].balance, \"Exceeds house balance\");\r\n    state.bet_counter++;\r\n    bets[state.bet_counter] = Bet({\r\n      house: house,\r\n      price_gwei: uint56(amount_gwei),\r\n      timestamp: uint32(block.timestamp),\r\n      player: msg.sender,\r\n      previous_house_bet: houses[house].last_bet,\r\n      next_house_bet: 0,\r\n      odds: uint32(odds),\r\n      randomness: keccak256(abi.encode(players[msg.sender].creation_block, nonce,\r\n                            msg.sender, randomness))\r\n    });\r\n    if(houses[house].first_bet == 0) {\r\n      houses[house].first_bet = state.bet_counter;\r\n    } else {\r\n      bets[houses[house].last_bet].next_house_bet = state.bet_counter;\r\n    }\r\n    houses[house].last_bet = state.bet_counter;\r\n    houses[house].bet_balance += amount * odds;\r\n    houses[house].balance -= (amount * odds) - amount;\r\n    houses[house].active_bets++;\r\n    if(houses[house].balance < houses[house].max_loss) {\r\n      houses[house].last_low_balance_timestamp = block.timestamp;\r\n    }\r\n    \r\n    state.reserved_eth += msg.value;\r\n    state.last_bet_time = block.timestamp;\r\n    players[msg.sender].active_bets++;\r\n    players[msg.sender].nonce = nonce;\r\n\r\n    emit BetPlaced(house, state.bet_counter);\r\n  }\r\n  \r\n  /** @notice Withdraw funds from player account.\r\n    * @param amount How much to withdraw (WEI)\r\n    */\r\n  function PlayerWithdraw(uint256 amount) external {\r\n    require(players[msg.sender].balance >= amount, \"Insufficient funds\");\r\n    state.reserved_eth -= amount;\r\n    players[msg.sender].balance -= amount;\r\n    _VerifiedTransfer(msg.sender, amount);\r\n  }\r\n\r\n  /** @notice If house has not decided bet within 24 hours, force player win.\r\n    *  Address calling this function receives house take (into house balance).\r\n    */\r\n  function ForceBet(uint256 bet_id) external {\r\n    require(bets[bet_id].timestamp + 1 days < block.timestamp, \"< 24h old\");\r\n    _PlayerWin(bet_id);\r\n    _DeleteBet(bet_id);\r\n  }\r\n  /* --- END PLAYER ACTIONS --- */\r\n\r\n  /* --- HOUSE ACTIONS --- */\r\n  /** @notice Open a new house for players to bet against or adjust house parameters.\r\n    *  Note on adjusting parameters: house must be paused and this will\r\n    *  update last_update_timestamp.\r\n    * @param modulus bytes32[8] representing modulus of a 2048 bit RSA key.\r\n    * @param max_loss Maximum WEI that house will tolerate losing on a single bet.\r\n    *  Applies to pot value, so small bets with high odds or large bets with smaller odds\r\n    *  can both exceed this value.\r\n    * @param min_bet Minimum bet price that house is willing to accept.\r\n    *  Setting this too low can result in gas prices exceeding earnings.\r\n    * @param take House take. Can be from 0 to 1000 and goes up in 0.01% increments.\r\n    *  Applied only for player wins (except if 'ForceBet' is called).\r\n    */\r\n  function OpenOrAdjustHouse(bytes32[8] calldata modulus, uint256 max_loss,\r\n                             uint256 min_bet, uint256 take)\r\n           PausedOnly payable external {\r\n    // Open house\r\n    if(houses[msg.sender].pause_block == 0) {\r\n      require(msg.value > 1e8 gwei, \"Insufficient funds\");\r\n      require(msg.sender != address(0), \"Invalid address\");\r\n      houses[msg.sender].pause_block = type(uint256).max;\r\n      houses[msg.sender].house_address_index = uint128(state.num_houses);\r\n      house_addresses.push(msg.sender);\r\n      state.num_houses++;\r\n    }\r\n    houses[msg.sender].balance += msg.value;\r\n    houses[msg.sender].modulus = modulus;\r\n    houses[msg.sender].max_loss = max_loss;\r\n    houses[msg.sender].min_bet = min_bet;\r\n    houses[msg.sender].take = take;\r\n    houses[msg.sender].last_update_timestamp = block.timestamp;\r\n    // Reserve funds owned by house\r\n    state.reserved_eth += msg.value;\r\n    _ValidateHouseParameters(msg.sender);\r\n  }\r\n\r\n  /** @notice Decide outcome of a bet by providing a signature for bet randomness.\r\n    * @param bet_id Identifier of bet to be decided.\r\n    * @param signed_randomness RSA signature (see top of file) for bet.randomness.\r\n    */ \r\n  function DecideBet(uint256 bet_id, bytes32[8] memory signed_randomness) external {\r\n    require(bets[bet_id].house == msg.sender, \"Must be called by house\");\r\n    require(bets[bet_id].randomness ==\r\n            _ExtractSigned(signed_randomness, houses[bets[bet_id].house].modulus),\r\n            \"Signature mismatch\");\r\n    uint256 pot = uint256(bets[bet_id].price_gwei) * bets[bet_id].odds * 1 gwei;\r\n    // 1 / odds chance of winning.\r\n    if(uint256(keccak256(abi.encode(signed_randomness))) % bets[bet_id].odds == 0) {\r\n      _PlayerWin(bet_id);\r\n    } else {\r\n      // If player loses, no house or contract takes are applicable.\r\n      houses[msg.sender].bet_balance -= pot;\r\n      houses[msg.sender].balance += pot;\r\n      emit BetResolved(msg.sender, false, uint88(bets[bet_id].odds),\r\n                       bets[bet_id].player, uint96(pot));\r\n    }\r\n    _DeleteBet(bet_id);\r\n    // Completed bets incremented here to only count decided bets.\r\n    houses[msg.sender].completed_bets++;\r\n    // Neverending bubble sort keeps active houses near top of array.\r\n    uint128 house_idx = houses[msg.sender].house_address_index;\r\n    if(house_idx > 0) {\r\n      // Swap addresses.\r\n      house_addresses[house_idx] = house_addresses[house_idx - 1];\r\n      house_addresses[house_idx - 1] = msg.sender;\r\n      // Update indices.\r\n      houses[msg.sender].house_address_index--;\r\n      houses[house_addresses[house_idx]].house_address_index++;\r\n    }\r\n  }\r\n\r\n  /** @notice Withdraw funds from house. House must be paused.\r\n    * @param amount Amount to withdraw (WEI).\r\n    **/\r\n  function HouseWithdraw(uint256 amount) external PausedOnly {\r\n    require(amount <= houses[msg.sender].balance, \"Insufficient funds\");\r\n    houses[msg.sender].balance -= amount;\r\n    state.reserved_eth -= amount;\r\n    _VerifiedTransfer(msg.sender, amount);\r\n  }\r\n  \r\n  /** @notice Add funds to house. */\r\n  function FundHouse() external payable HouseExists {\r\n    houses[msg.sender].balance += msg.value;\r\n    state.reserved_eth += msg.value;\r\n  }\r\n  \r\n  /** @notice Pause/unpause house.\r\n   *   Pause takes 250 blocks to start and cannot be changed before that.\r\n   *   Unpause takes effect immediately.\r\n   */\r\n  function TogglePauseHouse() external HouseExists {\r\n    // House must either be paused or or have no pending pauses.\r\n    require(houses[msg.sender].pause_block <= block.number ||\r\n            houses[msg.sender].pause_block == type(uint256).max,\r\n            \"Pause pending\");\r\n    // Pause in future to prevent reactions to an incoming losing bet.\r\n    if(houses[msg.sender].pause_block == type(uint256).max) {\r\n      houses[msg.sender].pause_block = block.number + PAUSE_DELAY_BLOCKS;\r\n    // Unpause.\r\n    } else {\r\n      houses[msg.sender].pause_block = type(uint256).max;\r\n    }\r\n  }\r\n  /* --- END HOUSE ACTIONS --- */\r\n\r\n  /* --- CONTRACT ACTIONS --- */\r\n   constructor() {\r\n    state.owner = msg.sender;\r\n    state.sale_price = type(uint256).max;\r\n    // Prevent dismantling right after deployment\r\n    state.last_bet_time = block.timestamp;\r\n  }\r\n\r\n  // Allow any address to send money to owner so owner wallet can be kept cold.\r\n  function OwnerWithdraw() external {\r\n    _VerifiedTransfer(state.owner, address(this).balance - state.reserved_eth);\r\n  }\r\n  \r\n  function ChangeOwner(address new_owner) external OnlyOwner {\r\n    state.owner = new_owner;\r\n  }\r\n  \r\n  /** @notice Contract can be bought by anyone if owner lowers price. */\r\n  function BuyContract(uint256 new_price) external payable {\r\n    require(msg.value >= state.sale_price, \"Price\");\r\n    address owner = state.owner;\r\n    state.owner = msg.sender;\r\n    state.sale_price = new_price;\r\n    // Old owner receives payment and earnings up to now.\r\n    _VerifiedTransfer(owner, address(this).balance - state.reserved_eth);\r\n  }\r\n  \r\n  function SetPrice(uint256 sale_price) external OnlyOwner {\r\n    state.sale_price = sale_price;\r\n  }\r\n\r\n  function Dismantle() external OnlyOwner {\r\n    require(state.last_bet_time + 90 days < block.timestamp, \"90 days\");\r\n    selfdestruct(payable(state.owner));\r\n  }\r\n  /* --- END CONTRACT ACTIONS --- */\r\n\r\n  /* --- DATA & EVENTS --- */\r\n  /** @notice A bet struct is created for each bet, so it is optimised for data size\r\n    *  Bets are stored as a doubly linked list per house, so previous_house_bet\r\n    *  and next_house_bet are pointers within global bets mapping.\r\n    *  Resolved bets are deleted and removed from relevant house list.\r\n    */\r\n  struct Bet {\r\n    address house;              // House.\r\n    uint56 price_gwei;          // Price of bet in GWEI.\r\n    uint40 timestamp;           // Bet creation time.\r\n\r\n    address player;             // Player.\r\n    uint32 previous_house_bet;  // Previous undecided bet for same house.\r\n    uint32 next_house_bet;      // Next undecided bet for same house.\r\n\r\n    uint32 odds;                // Odds of winning (odds to 1).\r\n\r\n    bytes32 randomness;         // Random value provided by player.\r\n  }\r\n\r\n  /** @dev Event for creation of bets. */\r\n  event BetPlaced(address house, uint32 bet_id);\r\n  /** @dev Event for bet resolution (not emitted if 'ForceBet' was used). */\r\n  event BetResolved(address house, bool player_win, uint88 odds,\r\n                    address player, uint96 pot);\r\n  \r\n  struct House {\r\n    uint256 balance;                     // Available balance (excludes bet_balance).\r\n    uint256 bet_balance;                 // Balance blocked by bets.\r\n    uint256 max_loss;                    // Maximum loss house accepts on one bet.\r\n    uint256 min_bet;                     // Minimum bet price house will accept.\r\n    uint256 take;                        // House take in units of 0.01% (<= 10%).\r\n    bytes32[8] modulus;                  // RSA key modulus.\r\n    uint256 pause_block;                 // Block number for pausing house.\r\n\r\n    // Next four values optimised to interact with entries in Bet structs.\r\n    // First bet and last bet are pointers to a doubly linked list of unresolved bets.\r\n    uint32 first_bet;                    // First undecided bet.\r\n    uint32 last_bet;                     // Last undecided bet.\r\n    uint32 active_bets;                  // Number of active bets.\r\n    uint32 completed_bets;               // Number of decided bets.\r\n    uint128 house_address_index;         // Index in house_addresses.\r\n\r\n    uint256 last_update_timestamp;       // Timestamp of last update to house parameters.\r\n    uint256 last_low_balance_timestamp;  // Last time that house balance was below max loss.\r\n  }\r\n  struct Player {\r\n    uint256 balance;         // Available balance (excludes money in active bets).\r\n    uint256 nonce;           // Current nonce (increase by 1 to 10 for each bet).\r\n    uint256 active_bets;     // Number of undecided bets.\r\n    uint256 creation_block;  // Block number of player creation.\r\n    uint256 winnings;        // Total player winnings.\r\n  }\r\n  struct State {\r\n    address owner;          // Contract owner address.\r\n    uint32 bet_counter;     // Total number of bets placed.\r\n    uint64 winnings_micro;  // Total player winnings in micro ETH.\r\n    uint256 reserved_eth;   // ETH reserved in WEI (owner cannot withdraw).\r\n    uint256 sale_price;     // Price to buy contract.\r\n    uint256 last_bet_time;  // Last time that a bet was placed.\r\n    uint256 num_houses;     // Number of houses that have been opened.\r\n  }\r\n  \r\n  // Houses mapping (private, use `ViewHouse` function).\r\n  mapping(address => House) private houses;\r\n  /** @notice House struct holds state for a house. */\r\n  function ViewHouse(address house) external view returns (House memory) {\r\n    return houses[house];\r\n  }\r\n\r\n  /** @notice Player struct holds state for player */\r\n  mapping(address => Player) public players;\r\n\r\n  /** @notice A bet struct is created for each bet, so it is optimised for data size\r\n    *  Bets are stored as a doubly linked list per house, so previous_house_bet\r\n    *  and next_house_bet are pointers within global bets mapping.\r\n    *  Resolved bets are deleted and removed from relevant house list.\r\n    */\r\n  mapping(uint256 => Bet) public bets;\r\n\r\n  /** @dev List of house addresses (which can be used to access houses mapping).\r\n    *  Continuously reordered to bring more active houses to top of list (see 'DecideBet').\r\n    */\r\n  address[] public house_addresses;\r\n  /** @dev State struct contains overall contract state. */\r\n  State public state;\r\n  /* --- END DATA & EVENTS --- */\r\n\r\n  /* --- INTERNAL FUNCTIONS --- */\r\n  function _ValidateHouseParameters(address house_id) internal view {\r\n    require(houses[house_id].min_bet >= 1e4 gwei, \"Min bet too low\");\r\n    require(houses[house_id].max_loss >= 1e7 gwei, \"Max loss too low\");  // At least 0.01 ETH\r\n    require(houses[house_id].take <= 1e3, \"Take too high\");  // Max 10%.\r\n    // Too expensive to check modulus, but it should at least be big and odd.\r\n    require(uint256(houses[house_id].modulus[7]) & 1 == 1, \"Use prime modulus\");\r\n    require(uint256(houses[house_id].modulus[0]) > MIN_MOD, \"Use 2048 bit key\");\r\n  }\r\n  \r\n  function _VerifiedTransfer(address recipient, uint256 amount) internal {\r\n    (bool success, ) = payable(recipient).call{value: amount}('');\r\n    require(success, \"Transfer failed\");\r\n  }\r\n\r\n  function _GetContractTake(uint256 pot_amount_gwei) internal pure returns (uint256 take_wei) {\r\n    if(pot_amount_gwei < 1e8) {         // < 0.1 ETH: 1% take.\r\n      take_wei = pot_amount_gwei * 1e7;\r\n    } else if(pot_amount_gwei < 1e9) {  // < 1 ETH: 0.5% take.\r\n      take_wei = pot_amount_gwei * 5e6;\r\n    } else if(pot_amount_gwei < 5e9) {  // < 5 ETH: 0.2% take.\r\n      take_wei = pot_amount_gwei * 2e6;\r\n    } else {                            // > 5 ETH: 0.1% take.\r\n      take_wei = pot_amount_gwei * 1e6;\r\n    }\r\n  }\r\n  \r\n  function _PlayerWin(uint256 bet_id) internal {\r\n    uint256 pot = uint256(bets[bet_id].price_gwei) * bets[bet_id].odds;\r\n    // Pot value in GWEI is used here to avoid division.\r\n    uint256 contract_take_wei = _GetContractTake(pot);\r\n    // Multiplying GWEI value by 1e5 gives 1/10000 WEI value.\r\n    // Since take <= 1000, this means up to 10% house take.\r\n    uint256 house_take_wei = pot * houses[bets[bet_id].house].take * 1e5;\r\n\r\n    state.winnings_micro += uint64(pot / 1e3);  // Micro ETH to fit in 1e64.\r\n    pot *= 1 gwei;  // Convert to WEI.\r\n    uint256 winnings = pot - contract_take_wei - house_take_wei;\r\n    players[bets[bet_id].player].winnings += winnings;\r\n    players[bets[bet_id].player].balance += winnings;\r\n    houses[bets[bet_id].house].bet_balance -= pot;\r\n    // msg.sender different to bets[bet_id].house iff bet is forced.\r\n    houses[msg.sender].balance += house_take_wei;\r\n    state.reserved_eth -= contract_take_wei;\r\n    \r\n    emit BetResolved(bets[bet_id].house, true, uint88(bets[bet_id].odds),\r\n                     bets[bet_id].player, uint96(pot));\r\n  }\r\n  \r\n  function _DeleteBet(uint256 bet_id) internal {\r\n    uint32 previous = bets[bet_id].previous_house_bet;\r\n    uint32 next = bets[bet_id].next_house_bet;\r\n    if(previous == 0) {\r\n      houses[bets[bet_id].house].first_bet = next;\r\n    } else {\r\n      bets[previous].next_house_bet = next;\r\n    }\r\n    if(next == 0) {\r\n      houses[bets[bet_id].house].last_bet = previous;\r\n    } else {\r\n      bets[next].previous_house_bet = previous;\r\n    }\r\n    houses[bets[bet_id].house].active_bets--;\r\n    players[bets[bet_id].player].active_bets--;\r\n    delete bets[bet_id];\r\n  }\r\n\r\n  function _ExtractSigned(bytes32[8] memory signature,\r\n      bytes32[8] memory modulus) internal view returns (bytes32) {\r\n    // Assembly for modular exponentiation (check RSA signature).\r\n    assembly {\r\n      let ptr:= mload(0x40)\r\n      mstore(ptr, 0x100)             // Signature length (2048 bits).\r\n      mstore(add(ptr, 0x20), 0x20)   // Public exponent length (256 bits).\r\n      mstore(add(ptr, 0x40), 0x100)  // Modulus length (2048 bits).\r\n      mstore(add(ptr, 0x160), 17)    // Public exponent always 17.\r\n      // Signature and modulus are too long for simple assignment.\r\n      let sigptr := add(ptr, 0x60)   // Signature pointer.\r\n      let modptr := add(ptr, 0x180)  // Modulus pointer.\r\n      // Loop through both (same lengths).\r\n      for { let i:= 0} lt(i, 0x100) { i := add(i, 0x20) } {\r\n        mstore(add(modptr, i), mload(add(modulus, i)))\r\n        mstore(add(sigptr, i), mload(add(signature, i)))\r\n      }\r\n      // Overwrite modulus with message.\r\n      if iszero(staticcall(sub(gas(), 2000), 0x05, ptr, 0x280, modulus, 0x100)) {\r\n        revert(0, 0)\r\n      }\r\n    }\r\n    // End assembly.\r\n    // Verify message prefix.\r\n    require(\r\n      modulus[0] == SIGNATURE_START &&\r\n      modulus[1] == PADDING_BLOCK &&\r\n      modulus[2] == PADDING_BLOCK &&\r\n      modulus[3] == PADDING_BLOCK &&\r\n      modulus[4] == PADDING_BLOCK &&\r\n      modulus[5] == PADDING_BLOCK &&\r\n      modulus[6] == MESSAGE_PREFIX,\r\n      \"Padding\");\r\n    // Last entry in modulus is the recovered message (should be bet randomness).\r\n    return modulus[7];\r\n  }\r\n  /* --- END INTERNAL FUNCTIONS --- */\r\n\r\n  /* --- ACCESS MODIFIERS --- */\r\n   // Revert if house does not exist.\r\n   modifier HouseExists() {\r\n    require(houses[msg.sender].pause_block > 0, \"House does not exist\");\r\n    _;\r\n  }\r\n\r\n  // Revert if an existing house is not paused or has unresolved bets.\r\n  modifier PausedOnly() {\r\n    require(houses[msg.sender].pause_block < block.number, \"Pause house\");\r\n    require(houses[msg.sender].active_bets == 0, \"Resolve bets\");\r\n    _;\r\n  }\r\n\r\n  modifier OnlyOwner() {\r\n    require(msg.sender == state.owner, \"Owner\");\r\n    _;\r\n  }\r\n  /* --- END ACCESS MODIFIERS --- */\r\n\r\n  /* --- CONSTANTS --- */\r\n  // Ensure signature is large enough to sign messages.\r\n  uint256 private constant MIN_MOD =\r\n    0x8000000000000000000000000000000000000000000000000000000000000000;\r\n  uint256 private constant PAUSE_DELAY_BLOCKS = 250;\r\n  // Following 3 constants are used for signature padding.\r\n  bytes32 private constant SIGNATURE_START = \r\n    0x0001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n  bytes32 private constant PADDING_BLOCK =\r\n    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n  // Uses encoding for SHA-256.\r\n  bytes32 private constant MESSAGE_PREFIX =\r\n    0xffffffffffffffffffffffff003031300d060960864801650304020105000420;\r\n  /* --- END CONSTANTS --- */\r\n  receive() external payable { }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"house\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"bet_id\",\"type\":\"uint32\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"house\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"player_win\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint88\",\"name\":\"odds\",\"type\":\"uint88\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"pot\",\"type\":\"uint96\"}],\"name\":\"BetResolved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_price\",\"type\":\"uint256\"}],\"name\":\"BuyContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CreatePlayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bet_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[8]\",\"name\":\"signed_randomness\",\"type\":\"bytes32[8]\"}],\"name\":\"DecideBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Dismantle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bet_id\",\"type\":\"uint256\"}],\"name\":\"ForceBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FundHouse\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"HouseWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[8]\",\"name\":\"modulus\",\"type\":\"bytes32[8]\"},{\"internalType\":\"uint256\",\"name\":\"max_loss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"take\",\"type\":\"uint256\"}],\"name\":\"OpenOrAdjustHouse\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OwnerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"house\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"odds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_gwei\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"randomness\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bet_placed_timestamp\",\"type\":\"uint256\"}],\"name\":\"PlaceBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sale_price\",\"type\":\"uint256\"}],\"name\":\"SetPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TogglePauseHouse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"house\",\"type\":\"address\"}],\"name\":\"ViewHouse\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bet_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_loss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"take\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[8]\",\"name\":\"modulus\",\"type\":\"bytes32[8]\"},{\"internalType\":\"uint256\",\"name\":\"pause_block\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"first_bet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"last_bet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"active_bets\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"completed_bets\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"house_address_index\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"last_update_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_low_balance_timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct BetHorde.House\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"house\",\"type\":\"address\"},{\"internalType\":\"uint56\",\"name\":\"price_gwei\",\"type\":\"uint56\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"previous_house_bet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"next_house_bet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"odds\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"randomness\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"house_addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"active_bets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creation_block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"bet_counter\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"winnings_micro\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"reserved_eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sale_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_bet_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_houses\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BetHorde","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c08338d4dfc9c063de496f537847e1905468f98f8acacf44129d4e5d262d168c"}]}