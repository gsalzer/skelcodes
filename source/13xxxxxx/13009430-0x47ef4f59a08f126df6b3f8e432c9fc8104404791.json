{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: Obbvrevis Ware\r\n\r\n/** \r\n * This code/file/software is owned by Obbrevis and Obrevis only.\r\n * All rights belong to Obbrevis.\r\n * Only Obbrevis authorizes the use of this code.\r\n * \r\n**/\r\n\r\npragma solidity 0.8.4;\r\n\r\n/** \r\n * @title Obbrevis Core \r\n * @dev Maps an address to username\r\n * \r\n**/\r\n \r\ncontract Obbrevis {\r\n    \r\n    struct State {\r\n        bool isInitialized; // If Contract is initialized and used to power on or off the app\r\n        address ownerAddress; // owner\r\n        address selfAddress; // address of contract\r\n        uint256 verificationFees; // Verification Fees in WEI\r\n        uint256 maxArrayBuffer; // Max length of an array\r\n        uint256 maxPageBuffer;\r\n        string version;\r\n    }\r\n    \r\n    struct AddressUsernamePair {\r\n        address useraddress;\r\n        bytes32 username;\r\n        bool isVerified;\r\n    }\r\n    \r\n    struct User {\r\n        bool init;\r\n        address useraddress; // User Address\r\n        bytes32 username;  // Username\r\n        bool isVerified; // If user is verified\r\n    }\r\n    \r\n    address ownerAddress;\r\n    address selfAddress;\r\n    mapping(address => User) addressToUser;\r\n    mapping(bytes32 => address) usernameToAddress;\r\n    mapping(address => bool) authorizedUsers;\r\n    address[] mappedAddresses;\r\n    mapping(bytes32 => bool) blockedUsernames;\r\n    State contractState;\r\n    \r\n    \r\n    \r\n    constructor(uint256 _verificationFees) {\r\n        ownerAddress = msg.sender;\r\n        authorizedUsers[msg.sender] = true;\r\n        contractState =  State({\r\n            isInitialized: false,\r\n            ownerAddress: ownerAddress,\r\n            selfAddress: address(0),\r\n            verificationFees: _verificationFees,\r\n            maxArrayBuffer: 1000,\r\n            maxPageBuffer: 1000,\r\n            version: \"1.0.0\"\r\n        });\r\n    }\r\n    \r\n    // Utils\r\n    \r\n    function _validateUsername(bytes32 _username) private pure returns(bool) {\r\n        uint8 stringLength = 1;\r\n        uint8 i = 1;\r\n        \r\n        // Checking is the first character is a letter [a-z]\r\n        if(_username[0] >= 0x61 && _username[0] <= 0x7a) {\r\n            \r\n            // Starting form the second character.\r\n            for(i = 1; i < 32; i++) {\r\n                \r\n                // Check the length of the string.\r\n                if(_username[i] == 0x00) {\r\n                    if(stringLength < 3) return false;\r\n                    else return true;\r\n                }\r\n                \r\n                // Check if the second+ characters are [a-z][0-9][_]\r\n                if(!(_username[i] >= 0x61 && _username[i] <= 0x7a)) {\r\n                   if(!(_username[i] >= 0x30 && _username[i] <= 0x39)) {\r\n                       if(_username[i] != 0x5f) return false;\r\n                   }\r\n                }\r\n                \r\n                // Increment counter.\r\n                stringLength++;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    function _withdrawETHToOwner(uint256 _amount) private returns(bool) {\r\n         payable(ownerAddress).transfer(_amount);\r\n         return true;\r\n    }\r\n    \r\n    function _checkExistingPairFromAddress(address _address) private view returns(bool) {\r\n        bytes32 savedUsername = addressToUser[_address].username;\r\n        address savedAddress = usernameToAddress[savedUsername];\r\n        \r\n        if(_address == savedAddress) return true;\r\n        return false;\r\n    }\r\n    \r\n    function _checkExistingPairFromUsername(bytes32 _username) private view returns(bool) {\r\n        address savedAddress = usernameToAddress[_username];\r\n        bytes32 savedUsername = addressToUser[savedAddress].username;\r\n        \r\n        if(savedUsername == _username) return true;\r\n        return false;\r\n    }\r\n    \r\n    function _checkExistingPair(address _address, bytes32 _username) private view returns(bool) {\r\n        if(_checkExistingPairFromAddress(_address) && _checkExistingPairFromUsername(_username)) {\r\n            bytes32 savedUsername = addressToUser[_address].username;\r\n            address savedAddress = usernameToAddress[_username];\r\n            return ((savedUsername == _username) && (savedAddress == _address));\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    function _checkUsername(bytes32 _username) private view returns(bool) {\r\n        \r\n        // Check if username is blocked.\r\n        if(blockedUsernames[_username]) return false;\r\n        \r\n        // Check if the username is used.\r\n        if(usernameToAddress[_username] == address(0)) return true;\r\n        return false;\r\n    }\r\n    \r\n    function _mapAddress(address _address, bytes32 _username, bool _verified) private returns(User memory) {\r\n        require(_validateUsername(_username), \"Error 400: Invalid Username.\");\r\n        require(_checkUsername(_username), \"Error 500: Username is taken.\");\r\n        \r\n        // Check if address has an old user object.\r\n        User memory oldUser = addressToUser[_address];\r\n        \r\n        /**\r\n         *  If User object is initialised?\r\n         *  TRUE: Free the old username to Address mapping.\r\n         *  FALSE: Meaning the user is fresh so increament address Counter\r\n         **/\r\n        if(oldUser.init == true) {\r\n            usernameToAddress[oldUser.username] = address(0);\r\n            addressToUser[_address].username = _username;\r\n            usernameToAddress[_username] = _address;\r\n        } else {\r\n            addressToUser[_address] = User({\r\n                init: true,\r\n                useraddress: _address,\r\n                username: _username,\r\n                isVerified: _verified\r\n            });\r\n            usernameToAddress[_username] = _address;\r\n            mappedAddresses.push(_address);\r\n        }\r\n        \r\n        return addressToUser[_address];\r\n    }\r\n    \r\n    \r\n    // External Functions\r\n    \r\n    function mapAddress(bytes32 _username) external returns(User memory) {\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(contractState.isInitialized, \"Error 503: Contract not Initialized.\");\r\n        \r\n        return _mapAddress(msg.sender, _username, false);\r\n    }\r\n    \r\n    function verify(bytes32 _username) external payable returns(User memory) {\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(msg.value >= contractState.verificationFees, \"Error 400: Insufficient Verification Fees.\");\r\n        require(contractState.isInitialized, \"Error 503: Contract not Initialized.\");\r\n        require(_checkExistingPair(msg.sender, _username), \"Error 500: Invalid Address-Username Pair.\");\r\n        require(!addressToUser[msg.sender].isVerified, \"Error 500: User is already verified.\");\r\n        \r\n        _withdrawETHToOwner(msg.value);\r\n        addressToUser[msg.sender].isVerified = true;\r\n        return addressToUser[msg.sender];\r\n    }\r\n    \r\n    \r\n    // Getters and Setters\r\n    \r\n    function getAddress(bytes32 _username) external view returns(address) {\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(_checkExistingPairFromUsername(_username), \"Error 500: Username! Invalid Address-Username Pair.\");\r\n        \r\n        return usernameToAddress[_username];\r\n    }\r\n    \r\n    function getUser(address _address) external view returns(User memory) {\r\n        require(_address != address(0), \"Error 400: Invalid Address\");\r\n        require(_checkExistingPairFromAddress(_address), \"Error 500: Address! Invalid Address-Username Pair.\");\r\n        \r\n        return addressToUser[_address];\r\n    }\r\n    \r\n    function getUserByUsername(bytes32 _username) external view returns(User memory) {\r\n        require(_username != bytes32(0), \"Error 400! Invalid Username\");\r\n        require(_checkExistingPairFromUsername(_username), \"Error 500: Username! Invalid Address-Username Pair.\");\r\n        \r\n        return addressToUser[usernameToAddress[_username]];\r\n    }\r\n    \r\n    function getUsernamesByAddresses(address[] calldata _addresses) external view returns(AddressUsernamePair[] memory) {\r\n        require(_addresses.length <= contractState.maxArrayBuffer, \"Error 400: Too many input\");\r\n        \r\n        uint256 i;\r\n        AddressUsernamePair[] memory res = new AddressUsernamePair[](_addresses.length);\r\n        for(i=0; i<_addresses.length; i++) {\r\n            res[i].useraddress = _addresses[i];\r\n            \r\n            User memory tempUser = addressToUser[_addresses[i]];\r\n            \r\n            if(tempUser.init) {\r\n                res[i].username = tempUser.username;\r\n                 res[i].isVerified = tempUser.isVerified;\r\n            } else  res[i].username = bytes32(0);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n    \r\n    function getAddressesByUsernames(bytes32[] calldata _usernames) external view returns(AddressUsernamePair[] memory) {\r\n        require(_usernames.length <= contractState.maxArrayBuffer, \"Error 400: Too many input\");\r\n        \r\n        uint256 i;\r\n        AddressUsernamePair[] memory res = new AddressUsernamePair[](_usernames.length);\r\n        for(i = 0; i < _usernames.length; i++) {\r\n            res[i].username = _usernames[i];\r\n            \r\n            address tempAddress = usernameToAddress[_usernames[i]];\r\n            \r\n            if(tempAddress != address(0)) {\r\n                User memory tempUser = addressToUser[tempAddress];\r\n                \r\n                if(tempUser.init) {\r\n                    res[i].useraddress = tempUser.useraddress;\r\n                    res[i].username = tempUser.username;\r\n                    res[i].isVerified = tempUser.isVerified;\r\n                } else  res[i].username = bytes32(0);\r\n            } else res[i].useraddress = address(0);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n    \r\n    function getNumberOfAddress() external view returns(uint256) {\r\n\r\n        return mappedAddresses.length;\r\n    }\r\n    \r\n    function validateUsername(bytes32 _username) external pure returns(bool) {\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        \r\n        return _validateUsername(_username);\r\n    }\r\n    \r\n    function checkUsername(bytes32 _username) external view returns(bool) {\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(contractState.isInitialized, \"Error 503: Contract not Initialized.\");\r\n        \r\n        return _checkUsername(_username);\r\n    }\r\n    \r\n    function getCurrentState() external view returns(State memory) {\r\n        \r\n        return contractState;\r\n    }\r\n    \r\n    function isAuthorizedUser(address _address) external view returns(bool) {\r\n        require(_address != address(0), \"Error 400: Invalid Address\");\r\n        \r\n        return authorizedUsers[_address];\r\n    }\r\n    \r\n    // Owner and Authorized Methods\r\n    \r\n    /** \r\n    * Initialize method to initialize the contract.\r\n    * \r\n    **/\r\n    function power(bool _power) external returns(State memory) {\r\n        require(msg.sender == ownerAddress, \"Error 401: Unauthorized Access.\");\r\n        \r\n        contractState.isInitialized = _power;\r\n        return contractState;\r\n    }\r\n    \r\n    function initialize(bytes32 _ownerUsername, address _selfAddress, bytes32 _selfUsername) external returns(bool) {\r\n        require(msg.sender == ownerAddress, \"Error 401: Unauthorized Access.\");\r\n        require(_ownerUsername != bytes32(0), \"Error 400: Invalid Owner Username\");\r\n        require(_selfAddress != address(0), \"Error 400: Invalid Self Address\");\r\n        require(_selfUsername != bytes32(0), \"Error 400: Invalid Self Username\");\r\n        \r\n        selfAddress = _selfAddress;\r\n        contractState.selfAddress = selfAddress;\r\n        \r\n        // Manually map owner address\r\n        _mapAddress(ownerAddress, _ownerUsername, true);\r\n        _mapAddress(_selfAddress, _selfUsername, true);\r\n        \r\n        contractState.isInitialized = true;\r\n        return true;\r\n    }\r\n    \r\n    function authoriseUser(address _address, bool _state) external returns(bool) {\r\n        require(msg.sender == ownerAddress, \"Error 401: Unauthorized Access.\");\r\n        require(contractState.isInitialized, \"Error 503: Contract not Initialized.\");\r\n        \r\n        authorizedUsers[_address] = _state;\r\n        return authorizedUsers[_address];\r\n    }\r\n    \r\n    function withdrawETHToOwner(uint256 _amount) external returns(bool) {\r\n        require(msg.sender == ownerAddress, \"Error 401: Unauthorized Access.\");\r\n        require(_amount > 0, \"Error 400: Invalid Amount! Amount must be greater than 0.\");\r\n        \r\n        return _withdrawETHToOwner(_amount);\r\n    }\r\n    \r\n    // Before Blocking a Username, first check with _checkUsername() if the username is used, blocked or not.\r\n    function blockUsername(bytes32 _blockUsername, bytes32 _newUsername) external returns(bool) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_blockUsername != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(_newUsername != bytes32(0) && _newUsername != _blockUsername, \"Error 400: Invalid Username\");\r\n        \r\n        // Check if the username is free else map the current holder to another username\r\n        if(!_checkUsername(_blockUsername)) {\r\n            \r\n            // Check if address has an old user object.\r\n            address currentAddress = usernameToAddress[_blockUsername];\r\n            _mapAddress(currentAddress, _newUsername, false);\r\n        }\r\n        \r\n        blockedUsernames[_blockUsername] = true;\r\n        return true;\r\n    }\r\n    \r\n    function unblockUsername(bytes32 _blockedUsername) external returns(bool) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_blockedUsername != bytes32(0), \"Error 400: Invalid Username\");\r\n        \r\n        blockedUsernames[_blockedUsername] = false;\r\n        return true;\r\n    }\r\n    \r\n    function usernameSwap(address _fromAddress, bytes32 _fromUsername, address _toAddress, bytes32 _toUsername)\r\n    external returns(User memory, User memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_fromAddress != address(0), \"Error 400: Invalid Address\");\r\n        require(_toAddress != address(0), \"Error 400: Invalid Address\");\r\n        require(_fromUsername != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(_toUsername != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(contractState.isInitialized, \"Error 503: Contract not Initialized.\");\r\n        require(_checkExistingPair(_fromAddress, _fromUsername), \"Error 500: Invalid From Address-Username Pair.\");\r\n        require(_checkExistingPair(_toAddress, _toUsername), \"Error 500: Invalid To Address-Username Pair.\");\r\n        \r\n        addressToUser[_fromAddress].username = _toUsername;\r\n        addressToUser[_toAddress].username = _fromUsername;\r\n        \r\n        usernameToAddress[_fromUsername] = _toAddress;\r\n        usernameToAddress[_toUsername] = _fromAddress;\r\n        \r\n        return(addressToUser[_fromAddress], addressToUser[_toAddress]);\r\n    }\r\n    \r\n    function getMappedAddresses(uint256 _page) external view returns(address[] memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_page >= 1, \"Error 400: Invalid Page Number.\");\r\n        \r\n        uint256 i;\r\n        uint256 j = 0;\r\n        address[] memory res;\r\n        uint256 lowerLimit;\r\n        uint256 upperLimit;\r\n        uint256 tempUpperLimit = _page * contractState.maxPageBuffer;\r\n        \r\n        if(mappedAddresses.length < tempUpperLimit) {\r\n            if(mappedAddresses.length < contractState.maxPageBuffer) lowerLimit = 0;\r\n            else lowerLimit = (_page - 1) * contractState.maxPageBuffer;\r\n            \r\n            upperLimit = mappedAddresses.length;\r\n            \r\n            // If an unvailable page is requested lowerLimit will be greater than upperLimit\r\n            if(lowerLimit > upperLimit) return res;\r\n            \r\n            // If lowerLimit == 0, then you should requesting for only page 1\r\n            if(lowerLimit == 0 && _page > 1) return res;\r\n        } else {\r\n            lowerLimit = (_page - 1) * contractState.maxPageBuffer;\r\n            upperLimit = tempUpperLimit;\r\n        }\r\n        \r\n        uint256 resLength = upperLimit - lowerLimit;\r\n        res = new address[](resLength);\r\n\r\n        for(i = lowerLimit; i < upperLimit; i++) {\r\n            res[j] = mappedAddresses[i];\r\n            j++;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n    \r\n    function authorizedMapAddress(address _address, bytes32 _username, bool _isVerified) external returns(User memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(contractState.isInitialized, \"Error 503: Contract not Initialized.\");\r\n        \r\n        return _mapAddress(_address, _username, _isVerified);\r\n    }\r\n    \r\n    function authorizedVerify(address _address, bytes32 _username) external returns(User memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_address != address(0), \"Error 400: Invalid Address\");\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(_checkExistingPair(_address, _username), \"Error 500: Invalid Address-Username Pair.\");\r\n        \r\n        addressToUser[_address].isVerified = true;\r\n        return addressToUser[_address];\r\n    }\r\n    \r\n    function unVerify(address _address, bytes32 _username) external returns(User memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        require(_address != address(0), \"Error 400: Invalid Address\");\r\n        require(_username != bytes32(0), \"Error 400: Invalid Username\");\r\n        require(_checkExistingPair(_address, _username), \"Error 500: Invalid Address-Username Pair.\");\r\n        \r\n        addressToUser[_address].isVerified = false;\r\n        return addressToUser[_address];\r\n    }\r\n    \r\n    function setVerificationFees(uint256 _verificationFees) external returns(State memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        \r\n        contractState.verificationFees = _verificationFees;\r\n        return contractState;\r\n    }\r\n    \r\n    function setMaxBuffer(uint256 _maxArrayBuffer, uint256 _maxPageBuffer) external returns(State memory) {\r\n        require(authorizedUsers[msg.sender], \"Error 401: Unauthorized Access.\");\r\n        \r\n        if(_maxArrayBuffer > 0) contractState.maxArrayBuffer = _maxArrayBuffer;\r\n        if(_maxPageBuffer > 0) contractState.maxPageBuffer = _maxPageBuffer;\r\n        \r\n        return contractState;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationFees\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"authoriseUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_isVerified\",\"type\":\"bool\"}],\"name\":\"authorizedMapAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"authorizedVerify\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blockUsername\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newUsername\",\"type\":\"bytes32\"}],\"name\":\"blockUsername\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"checkUsername\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_usernames\",\"type\":\"bytes32[]\"}],\"name\":\"getAddressesByUsernames\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.AddressUsernamePair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentState\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"verificationFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxArrayBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPageBuffer\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"internalType\":\"struct Obbrevis.State\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_page\",\"type\":\"uint256\"}],\"name\":\"getMappedAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"getUserByUsername\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"getUsernamesByAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.AddressUsernamePair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ownerUsername\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_selfAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_selfUsername\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAuthorizedUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"mapAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_power\",\"type\":\"bool\"}],\"name\":\"power\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"verificationFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxArrayBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPageBuffer\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"internalType\":\"struct Obbrevis.State\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxArrayBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPageBuffer\",\"type\":\"uint256\"}],\"name\":\"setMaxBuffer\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"verificationFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxArrayBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPageBuffer\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"internalType\":\"struct Obbrevis.State\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_verificationFees\",\"type\":\"uint256\"}],\"name\":\"setVerificationFees\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"selfAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"verificationFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxArrayBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPageBuffer\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"internalType\":\"struct Obbrevis.State\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"unVerify\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blockedUsername\",\"type\":\"bytes32\"}],\"name\":\"unblockUsername\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_fromUsername\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_toUsername\",\"type\":\"bytes32\"}],\"name\":\"usernameSwap\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"validateUsername\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_username\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"init\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"useraddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"username\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"internalType\":\"struct Obbrevis.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETHToOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Obbrevis","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000058d15e17628000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://78f5568b582a03a6f9d1016cf696bfa9655e6c47f5fadc840d32a15ba6435949"}]}