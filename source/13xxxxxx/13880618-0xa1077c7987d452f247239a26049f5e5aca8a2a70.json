{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/infrastructure/authentication/IAuthenticator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\npragma solidity ^0.8.0 <0.9.0;\\r\\n\\r\\n\\r\\n/// @title IAuthenticator\\r\\n/// @dev Authenticator interface\\r\\n/// @author Frank Bonnet - <frankbonnet@outlook.com>\\r\\ninterface IAuthenticator {\\r\\n    \\r\\n\\r\\n    /// @dev Authenticate \\r\\n    /// Returns whether `_account` is authenticated\\r\\n    /// @param _account The account to authenticate\\r\\n    /// @return whether `_account` is successfully authenticated\\r\\n    function authenticate(address _account) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"/contracts/source/tokens/ERC20/retriever/ITokenRetriever.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\npragma solidity ^0.8.0 <0.9.0;\\r\\n\\r\\n/**\\r\\n * ITokenRetriever\\r\\n *\\r\\n * Allows tokens to be retrieved from a contract\\r\\n *\\r\\n * #created 29/09/2017\\r\\n * #author Frank Bonnet\\r\\n */\\r\\ninterface ITokenRetriever {\\r\\n\\r\\n    /**\\r\\n     * Extracts tokens from the contract\\r\\n     *\\r\\n     * @param _tokenContract The address of ERC20 compatible token\\r\\n     */\\r\\n    function retrieveTokens(address _tokenContract) external;\\r\\n}\"\r\n    },\r\n    \"/contracts/source/tokens/ERC20/retriever/TokenRetriever.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\npragma solidity ^0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./ITokenRetriever.sol\\\";\\r\\n\\r\\n/**\\r\\n * TokenRetriever\\r\\n *\\r\\n * Allows tokens to be retrieved from a contract\\r\\n *\\r\\n * #created 31/12/2021\\r\\n * #author Frank Bonnet\\r\\n */\\r\\ncontract TokenRetriever is ITokenRetriever {\\r\\n\\r\\n    /**\\r\\n     * Extracts tokens from the contract\\r\\n     *\\r\\n     * @param _tokenContract The address of ERC20 compatible token\\r\\n     */\\r\\n    function retrieveTokens(address _tokenContract) override virtual public {\\r\\n        IERC20 tokenInstance = IERC20(_tokenContract);\\r\\n        uint tokenBalance = tokenInstance.balanceOf(address(this));\\r\\n        if (tokenBalance > 0) {\\r\\n            tokenInstance.transfer(msg.sender, tokenBalance);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/source/tokens/ERC721/BoxingBoyz/BoxingBoyzTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\r\\n\\r\\nimport \\\"../../../../infrastructure/authentication/IAuthenticator.sol\\\";\\r\\nimport \\\"../../ERC20/retriever/TokenRetriever.sol\\\";\\r\\nimport \\\"./IBoxingBoyzToken.sol\\\";\\r\\n\\r\\n\\r\\n/// @title BoxingBoyz Token Factory \\r\\n/// @dev Non-fungible token (ERC721) factory that mints BoxingBoyz tokens\\r\\n/// @author Frank Bonnet - <frankbonnet@outlook.com>\\r\\ncontract BoxingBoyzTokenFactory is Ownable, TokenRetriever {\\r\\n\\r\\n    enum Stages {\\r\\n        Initializing,\\r\\n        Deploying,\\r\\n        Deployed\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  Storage\\r\\n     */\\r\\n    uint constant MAX_SUPPLY = 10_000;\\r\\n    uint constant MAX_MINT_PER_CALL = 3;\\r\\n    uint constant MAX_MINT_PER_ADDRESS = 3;\\r\\n    uint constant MINT_FEE_PRIVATE = 0.2 ether;\\r\\n    uint constant MINT_FEE_PUBLIC = 0.25 ether;\\r\\n    uint constant PERCENTAGE_DENOMINATOR = 10_000;\\r\\n\\r\\n    // Authentication\\r\\n    address private whitelist;\\r\\n\\r\\n    // Beneficiary\\r\\n    address payable public beneficiary; \\r\\n\\r\\n    // Stakeholders\\r\\n    mapping (address => uint) public stakeholders;\\r\\n    address[] private stakeholdersIndex;\\r\\n\\r\\n     // State\\r\\n    uint public start;\\r\\n    Stages public stage;\\r\\n    address public token;\\r\\n    bool public isPublic;\\r\\n\\r\\n    /**\\r\\n     * Modifiers\\r\\n     */\\r\\n    /// @dev Throw if at stage other than current stage\\r\\n    /// @param _stage expected stage to test for\\r\\n    modifier atStage(Stages _stage) {\\r\\n        require(stage == _stage, \\\"In wrong stage\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n\\r\\n    /// @dev Throw sender isn't a stakeholders\\r\\n    modifier onlyStakeholders() {\\r\\n        require(stakeholders[msg.sender] > 0, \\\"Only stakeholders\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * Public Functions\\r\\n     */\\r\\n    /// @dev Start in the Initializing stage\\r\\n    constructor() {\\r\\n        stage = Stages.Initializing;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Setup stakeholders\\r\\n    /// @param _stakeholders The addresses of the stakeholders (first stakeholder is the beneficiary)\\r\\n    /// @param _percentages The percentages of the stakeholders \\r\\n    function setupStakeholders(address payable[] calldata _stakeholders, uint[] calldata _percentages) public onlyOwner atStage(Stages.Initializing) {\\r\\n        require(stakeholdersIndex.length == 0, \\\"Stakeholders already setup\\\");\\r\\n        \\r\\n        // First stakeholder is expected to be the beneficiary\\r\\n        beneficiary = _stakeholders[0]; \\r\\n\\r\\n        uint total = 0;\\r\\n        for (uint i = 0; i < _stakeholders.length; i++) {\\r\\n            stakeholdersIndex.push(_stakeholders[i]);\\r\\n            stakeholders[_stakeholders[i]] = _percentages[i];\\r\\n            total += _percentages[i];\\r\\n        }\\r\\n\\r\\n        require(total == PERCENTAGE_DENOMINATOR, \\\"Stakes should add up to 100%\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Initialize the factory\\r\\n    /// @param _start The timestamp of the start date\\r\\n    /// @param _token The token that is minted\\r\\n    /// @param _whitelist The address of the whitelist authenticator\\r\\n    function initialize(uint _start, address _token, address _whitelist) public onlyOwner atStage(Stages.Initializing) {\\r\\n        require(stakeholdersIndex.length > 0, \\\"Setup stakeholders first\\\");\\r\\n        token = _token;\\r\\n        start = _start;\\r\\n        whitelist = _whitelist;\\r\\n        isPublic = false;\\r\\n        stage = Stages.Deploying;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Premint for givaways etc\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @param _toAddress Receiving address\\r\\n    function premint(uint _numberOfItemsToMint, address _toAddress) public onlyOwner atStage(Stages.Deploying) {\\r\\n        for (uint i = 0; i < _numberOfItemsToMint; i++) {\\r\\n            IBoxingBoyzToken(token).mintTo(_toAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Deploy the contract (setup is final)\\r\\n    function deploy() public onlyOwner atStage(Stages.Deploying) {\\r\\n        stage = Stages.Deployed;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Set contract URI\\r\\n    /// @param _uri Location to contract info\\r\\n    function setContractURI(string memory _uri) public onlyOwner {\\r\\n        IBoxingBoyzToken(token).setContractURI(_uri);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Set base token URI \\r\\n    /// @param _uri Base of location where token data is stored. To be postfixed with tokenId\\r\\n    function setBaseTokenURI(string memory _uri) public onlyOwner {\\r\\n        IBoxingBoyzToken(token).setBaseTokenURI(_uri);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Starts the public sale - In the public sale the whitelist check is ommited and the public mint fee is used\\r\\n    function makePublic() public onlyOwner {\\r\\n        isPublic = true;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Mint `_numberOfItemsToMint` items to to `_toAddress`\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @param _toAddress Address to mint to\\r\\n    function mint(uint _numberOfItemsToMint, address _toAddress) public payable atStage(Stages.Deployed) {\\r\\n        require(canMint(_numberOfItemsToMint), \\\"Unable to mint items\\\");\\r\\n        require(_canPayMintFee(_numberOfItemsToMint, msg.value), \\\"Unable to pay\\\");\\r\\n\\r\\n        if (_numberOfItemsToMint == 1) {\\r\\n            IBoxingBoyzToken(token).mintTo(_toAddress);\\r\\n        } else if (_numberOfItemsToMint > 1 && _numberOfItemsToMint <= MAX_MINT_PER_CALL) {\\r\\n            for (uint i = 0; i < _numberOfItemsToMint; i++) {\\r\\n                IBoxingBoyzToken(token).mintTo(_toAddress);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Returns if it's still possible to mint `_numberOfItemsToMint`\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @return If the items can be minted\\r\\n    function canMint(uint _numberOfItemsToMint) public view returns (bool) {\\r\\n        \\r\\n        // Enforce started rule\\r\\n        if (block.timestamp < start){\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Enforce max per call rule\\r\\n        if (_numberOfItemsToMint > MAX_MINT_PER_CALL) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Authenticate\\r\\n        if (!isPublic && !IAuthenticator(whitelist).authenticate(msg.sender))\\r\\n        {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Enforce max per address rule\\r\\n        if ((IERC721Enumerable(token).balanceOf(msg.sender) + _numberOfItemsToMint) > MAX_MINT_PER_ADDRESS) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Enforce max token rule\\r\\n        return IERC721Enumerable(token).totalSupply() <= (MAX_SUPPLY - _numberOfItemsToMint);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Returns true if the call has enough ether to pay the minting fee\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @return If the minting fee can be payed\\r\\n    function canPayMintFee(uint _numberOfItemsToMint) public view returns (bool) {\\r\\n        return _canPayMintFee(_numberOfItemsToMint, address(msg.sender).balance);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Returns the ether amount needed to pay the minting fee\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @return Ether amount needed to pay the minting fee\\r\\n    function getMintFee(uint _numberOfItemsToMint) public view returns (uint) {\\r\\n        return _getMintFee(_numberOfItemsToMint);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Allows the beneficiary to withdraw \\r\\n    function withdraw() public onlyStakeholders {\\r\\n        uint balance = address(this).balance;\\r\\n        for (uint i = 0; i < stakeholdersIndex.length; i++)\\r\\n        {\\r\\n            payable(stakeholdersIndex[i]).transfer(\\r\\n                balance * stakeholders[stakeholdersIndex[i]] / PERCENTAGE_DENOMINATOR);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Failsafe mechanism\\r\\n    /// Allows the owner to retrieve tokens from the contract that \\r\\n    /// might have been send there by accident\\r\\n    /// @param _tokenContract The address of ERC20 compatible token\\r\\n    function retrieveTokens(address _tokenContract) override public onlyOwner {\\r\\n        super.retrieveTokens(_tokenContract);\\r\\n\\r\\n        // Retrieve tokens from our token contract\\r\\n        ITokenRetriever(address(token)).retrieveTokens(_tokenContract);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Failsafe and clean-up mechanism\\r\\n    /// Makes the token URI's perminant since the factory is it's only owner\\r\\n    function destroy() public onlyOwner {\\r\\n        selfdestruct(beneficiary);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * Internal Functions\\r\\n     */\\r\\n    /// @dev Returns if the call has enough ether to pay the minting fee\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @param _received The amount that was received\\r\\n    /// @return If the minting fee can be payed\\r\\n    function _canPayMintFee(uint _numberOfItemsToMint, uint _received) internal view returns (bool) {\\r\\n        return _received >= _getMintFee(_numberOfItemsToMint);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev Returns the ether amount needed to pay the minting fee\\r\\n    /// @param _numberOfItemsToMint Number of items to mint\\r\\n    /// @return Ether amount needed to pay the minting fee\\r\\n    function _getMintFee(uint _numberOfItemsToMint) internal view returns (uint) {\\r\\n        return (isPublic ? MINT_FEE_PUBLIC : MINT_FEE_PRIVATE) * _numberOfItemsToMint;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/source/tokens/ERC721/BoxingBoyz/IBoxingBoyzToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\npragma solidity ^0.8.0 <0.9.0;\\r\\n\\r\\n\\r\\n/// @title BoxingBoyz Token\\r\\n/// @dev Non-fungible token (ERC721) \\r\\n/// @author Frank Bonnet - <frankbonnet@outlook.com>\\r\\ninterface IBoxingBoyzToken {\\r\\n\\r\\n\\r\\n    /**\\r\\n     * Public functions\\r\\n     */\\r\\n    /// @dev Initializes the token contract\\r\\n    /// @param _proxyRegistry Whitelist for easy trading\\r\\n    /// @param _initialContractURI Location to contract info\\r\\n    /// @param _initialBaseTokenURI Base of location where token data is stored. To be postfixed with tokenId\\r\\n    function initialize(\\r\\n        address _proxyRegistry, \\r\\n        string calldata _initialContractURI, \\r\\n        string calldata _initialBaseTokenURI) external;\\r\\n\\r\\n\\r\\n    /// @dev Get contract URI\\r\\n    /// @return Location to contract info\\r\\n    function getContractURI() external view returns (string memory);\\r\\n\\r\\n\\r\\n    /// @dev Set contract URI\\r\\n    /// @param _uri Location to contract info\\r\\n    function setContractURI(string memory _uri) external;\\r\\n\\r\\n\\r\\n    /// @dev Get base token URI \\r\\n    /// @return Base of location where token data is stored. To be postfixed with tokenId\\r\\n    function getBaseTokenURI() external view returns (string memory);\\r\\n\\r\\n\\r\\n    /// @dev Set base token URI \\r\\n    /// @param _uri Base of location where token data is stored. To be postfixed with tokenId\\r\\n    function setBaseTokenURI(string memory _uri) external;\\r\\n\\r\\n\\r\\n    /// @dev getTokenURI() postfixed with the token ID baseTokenURI(){tokenID}\\r\\n    /// @param _tokenId Token ID\\r\\n    /// @return Location where token data is stored\\r\\n    function getTokenURI(uint _tokenId) external view returns (string memory);\\r\\n\\r\\n    /// @dev Mints a token to an address with a tokenURI.\\r\\n    /// @param _to address of the future owner of the token\\r\\n    function mintTo(address _to) external;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfItemsToMint\",\"type\":\"uint256\"}],\"name\":\"canMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfItemsToMint\",\"type\":\"uint256\"}],\"name\":\"canPayMintFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfItemsToMint\",\"type\":\"uint256\"}],\"name\":\"getMintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makePublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfItemsToMint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfItemsToMint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"premint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_stakeholders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percentages\",\"type\":\"uint256[]\"}],\"name\":\"setupStakeholders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"enum BoxingBoyzTokenFactory.Stages\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeholders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BoxingBoyzTokenFactory","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}