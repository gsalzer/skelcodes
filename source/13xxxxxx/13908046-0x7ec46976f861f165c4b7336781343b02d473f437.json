{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Fodl/core/FoldingAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport '../modules/FoldingAccount/FoldingAccountStorage.sol';\\nimport './interfaces/IFoldingConnectorProvider.sol';\\n\\ncontract FoldingAccount is FoldingAccountStorage {\\n    constructor(address foldingRegistry) public {\\n        aStore().foldingRegistry = foldingRegistry;\\n    }\\n\\n    /// @notice Find the connector for `msg.sig` and delegate call it with `msg.data`\\n    function delegate() private {\\n        bool firstCall = false; // We need to delete the entryCaller on exit\\n\\n        AccountStore storage accountStorage = aStore();\\n        if (accountStorage.entryCaller == address(0)) {\\n            accountStorage.entryCaller = msg.sender;\\n            firstCall = true;\\n        }\\n        // Check if a connector expects a callback or find connector\\n        address impl = accountStorage.callbackTarget;\\n        if (impl != address(0)) {\\n            require(accountStorage.expectedCallbackSig == msg.sig, 'FA1');\\n        } else {\\n            impl = IFoldingConnectorProvider(accountStorage.foldingRegistry).getImplementation(msg.sig);\\n        }\\n\\n        /// @dev This assembly code returns directly to caller\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(0, 0, size)\\n            switch result\\n            case 0 {\\n                revert(0, size)\\n            }\\n            default {\\n                /// @dev if this is the first call, set the entryCaller to 0\\n                if firstCall {\\n                    sstore(accountStorage_slot, 0)\\n                }\\n                return(0, size)\\n            }\\n        }\\n    }\\n\\n    fallback() external payable {\\n        if (msg.sig != bytes4(0)) delegate();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Fodl/modules/FoldingAccount/FoldingAccountStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ncontract FoldingAccountStorage {\\n    bytes32 constant ACCOUNT_STORAGE_POSITION = keccak256('folding.account.storage');\\n\\n    /**\\n     * entryCaller:         address of the caller of the account, during a transaction\\n     *\\n     * callbackTarget:      address of logic to be run when expecting a callback\\n     *\\n     * expectedCallbackSig: signature of function to be run when expecting a callback\\n     *\\n     * foldingRegistry      address of factory creating FoldingAccount\\n     *\\n     * nft:                 address of the nft contract.\\n     *\\n     * owner:               address of the owner of this FoldingAccount.\\n     */\\n    struct AccountStore {\\n        address entryCaller;\\n        address callbackTarget;\\n        bytes4 expectedCallbackSig;\\n        address foldingRegistry;\\n        address nft;\\n        address owner;\\n    }\\n\\n    modifier onlyAccountOwner() {\\n        AccountStore storage s = aStore();\\n        require(s.entryCaller == s.owner, 'FA2');\\n        _;\\n    }\\n\\n    modifier onlyNFTContract() {\\n        AccountStore storage s = aStore();\\n        require(s.entryCaller == s.nft, 'FA3');\\n        _;\\n    }\\n\\n    modifier onlyAccountOwnerOrRegistry() {\\n        AccountStore storage s = aStore();\\n        require(s.entryCaller == s.owner || s.entryCaller == s.foldingRegistry, 'FA4');\\n        _;\\n    }\\n\\n    function aStore() internal pure returns (AccountStore storage s) {\\n        bytes32 position = ACCOUNT_STORAGE_POSITION;\\n        assembly {\\n            s_slot := position\\n        }\\n    }\\n\\n    function accountOwner() internal view returns (address) {\\n        return aStore().owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Fodl/core/interfaces/IFoldingConnectorProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IFoldingConnectorProvider {\\n    function getImplementation(bytes4 functionSignature) external view returns (address implementation);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"foldingRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"FoldingAccount","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"9999","ConstructorArguments":"000000000000000000000000ec6b351778aaa2349a8726b4837e05232ef20d03","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}