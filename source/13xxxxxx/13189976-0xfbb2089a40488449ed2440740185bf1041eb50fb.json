{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"HashBridge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\n\\r\\ncontract HashBridge is Ownable {\\r\\n\\taddress public signer;\\r\\n\\tuint public reservationTime;\\r\\n\\tuint public constant RATE_DECIMALS = 18;\\r\\n\\t\\r\\n\\tstruct Offer {\\r\\n\\t\\taddress token;\\r\\n\\t\\tuint amount;\\r\\n\\t\\taddress payToken;\\r\\n\\t\\tuint rate;\\r\\n\\t\\taddress ownerAddress;\\r\\n\\t\\taddress payAddress;\\r\\n\\t\\tuint minPurchase;\\r\\n\\t\\tbool active;\\r\\n\\t}\\r\\n\\tstruct Order {\\r\\n\\t\\tuint offerId;\\r\\n\\t\\tuint rate;\\r\\n\\t\\taddress ownerAddress;\\r\\n\\t\\taddress withdrawAddress;\\r\\n\\t\\tuint amount;\\r\\n\\t\\tuint payAmount;\\r\\n\\t\\taddress payAddress;\\r\\n\\t\\tuint reservedUntil;\\r\\n\\t\\tbool complete;\\r\\n\\t}\\r\\n\\tstruct Payment {\\r\\n\\t\\tuint orderId;\\r\\n\\t\\tuint payAmount;\\r\\n\\t\\taddress payToken;\\r\\n\\t\\taddress payAddress;\\r\\n\\t}\\r\\n\\t\\r\\n\\tOffer[] offers;\\r\\n\\tOrder[] orders;\\r\\n\\tPayment[] payments;\\r\\n\\t\\r\\n\\tevent OfferAdd(uint indexed offerId, address indexed token, address indexed payToken, address ownerAddress, address payAddress, uint amount, uint rate, uint minPurchase, bool active);\\r\\n\\tevent OfferUpdate(uint indexed offerId, address payAddress, uint amount, uint rate, uint minPurchase, bool active);\\r\\n\\tevent OrderAdd(uint indexed orderId, uint indexed offerId, address indexed ownerAddress, uint rate, address withdrawAddress, uint amount, uint payAmount, address payAddress, uint reservedUntil);\\r\\n\\tevent OrderPay(uint indexed paymentId, uint indexed orderId, uint payAmount, address payToken, address payAddress);\\r\\n\\tevent OrderComplete(uint indexed orderId, uint offerAmount);\\r\\n\\t\\r\\n\\tconstructor(address _signer, uint _reservationTime) {\\r\\n        signer = _signer;\\r\\n\\t\\treservationTime = _reservationTime;\\r\\n    }\\r\\n\\t\\r\\n\\tfunction changeSigner(address _signer) public onlyOwner {\\r\\n        signer = _signer;\\r\\n    }\\r\\n\\t\\r\\n\\tfunction changeReservationTime(uint _reservationTime) public onlyOwner {\\r\\n\\t\\treservationTime = _reservationTime;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction addOffer(address _token, uint _amount, address _payToken, uint _rate, address _payAddress, uint _minPurchase) public {\\r\\n\\t\\trequire(_amount \\u003e 0, \\\"Amount must be greater than 0\\\");\\r\\n\\t\\trequire(_amount \\u003e= _minPurchase, \\\"Amount must not be less than the minimum purchase\\\");\\r\\n\\t\\trequire(_rate \\u003e 0, \\\"Rate must be greater than 0\\\");\\r\\n\\t\\tTransferHelper.safeTransferFrom(_token, msg.sender, address(this), _amount);\\r\\n\\t\\tuint offerId = offers.length;\\r\\n\\t\\toffers.push(Offer(_token, _amount, _payToken, _rate, msg.sender, _payAddress, _minPurchase, true));\\r\\n\\t\\temit OfferAdd(offerId, _token, _payToken, msg.sender, _payAddress, _amount, _rate, _minPurchase, true);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction updateOffer(uint _offerId, uint _amount, uint _rate, address _payAddress, uint _minPurchase) public {\\r\\n\\t\\t_checkOfferAccess(_offerId);\\r\\n\\t\\trequire(_rate \\u003e 0, \\\"Rate must be greater than 0\\\");\\r\\n\\t\\tuint blockedAmount = _getBlockedAmount(_offerId);\\r\\n\\t\\trequire(_amount \\u003e= blockedAmount, \\\"You can not withdraw tokens ordered by customers\\\");\\r\\n\\t\\tif (_amount \\u003e offers[_offerId].amount) {\\r\\n\\t\\t\\tTransferHelper.safeTransferFrom(offers[_offerId].token, msg.sender, address(this), _amount - offers[_offerId].amount);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tTransferHelper.safeTransfer(offers[_offerId].token, msg.sender, offers[_offerId].amount - _amount);\\r\\n\\t\\t}\\r\\n\\t\\toffers[_offerId].amount = _amount;\\r\\n\\t\\toffers[_offerId].rate = _rate;\\r\\n\\t\\toffers[_offerId].payAddress = _payAddress;\\r\\n\\t\\toffers[_offerId].minPurchase = _minPurchase;\\r\\n\\t\\temit OfferUpdate(_offerId, _payAddress, _amount, _rate, _minPurchase, offers[_offerId].active);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction activateOffer(uint _offerId) public {\\r\\n\\t\\t_checkOfferAccess(_offerId);\\r\\n\\t\\trequire(offers[_offerId].active == false, \\\"Offer is already active\\\");\\r\\n\\t\\toffers[_offerId].active = true;\\r\\n\\t\\temit OfferUpdate(_offerId, offers[_offerId].payAddress, offers[_offerId].amount, offers[_offerId].rate, offers[_offerId].minPurchase, true);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction deactivateOffer(uint _offerId) public {\\r\\n\\t\\t_checkOfferAccess(_offerId);\\r\\n\\t\\trequire(offers[_offerId].active == true, \\\"Offer is already inactive\\\");\\r\\n\\t\\toffers[_offerId].active = false;\\r\\n\\t\\temit OfferUpdate(_offerId, offers[_offerId].payAddress, offers[_offerId].amount, offers[_offerId].rate, offers[_offerId].minPurchase, false);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction addOrder(uint _offerId, address _withdrawAddress, uint _amount, uint _payAmount) public {\\r\\n\\t\\trequire(_offerId \\u003c offers.length, \\\"Incorrect offerId\\\");\\r\\n\\t\\trequire(offers[_offerId].active == true, \\\"Offer is inactive\\\");\\r\\n\\t\\trequire(_amount \\u003e 0 || _payAmount \\u003e 0, \\\"Amount must be greater than 0\\\");\\r\\n\\t\\tuint rate = offers[_offerId].rate;\\r\\n\\t\\tif (_amount \\u003e 0) {\\r\\n\\t\\t\\t_payAmount = _amount * rate / (10 ** RATE_DECIMALS);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t_amount = _payAmount * (10 ** RATE_DECIMALS) / rate;\\r\\n\\t\\t}\\r\\n\\t\\trequire(_amount \\u003e= offers[_offerId].minPurchase, \\\"Amount is less than the minimum purchase\\\");\\r\\n\\t\\tuint blockedAmount = _getBlockedAmount(_offerId);\\r\\n\\t\\trequire(_amount \\u003c= offers[_offerId].amount - blockedAmount, \\\"Not enough tokens in the offer\\\");\\r\\n\\t\\taddress _payAddress = offers[_offerId].payAddress;\\r\\n\\t\\tuint reservedUntil = block.timestamp + reservationTime;\\r\\n\\t\\tuint orderId = orders.length;\\r\\n\\t\\torders.push(Order(_offerId, rate, msg.sender, _withdrawAddress, _amount, _payAmount, _payAddress, reservedUntil, false));\\r\\n\\t\\temit OrderAdd(orderId, _offerId, msg.sender, rate, _withdrawAddress, _amount, _payAmount, _payAddress, reservedUntil);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction payOrder(uint _orderId, uint _payAmount, address _payToken, address _payAddress) public {\\r\\n\\t\\trequire(_payAmount \\u003e 0, \\\"Amount must be greater than 0\\\");\\r\\n\\t\\tTransferHelper.safeTransferFrom(_payToken, msg.sender, _payAddress, _payAmount);\\r\\n\\t\\tuint paymentId = payments.length;\\r\\n\\t\\tpayments.push(Payment(_orderId, _payAmount, _payToken, _payAddress));\\r\\n\\t\\temit OrderPay(paymentId, _orderId, _payAmount, _payToken, _payAddress);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction withdrawTokens(uint _orderId, bytes calldata _sign) public {\\r\\n\\t\\trequire(_orderId \\u003c orders.length, \\\"Incorrect orderId\\\");\\r\\n\\t\\trequire(orders[_orderId].complete == false, \\\"Tokens already withdrawn\\\");\\r\\n\\t\\tuint offerId = orders[_orderId].offerId;\\r\\n\\t\\tuint amount = orders[_orderId].amount;\\r\\n\\t\\tuint payAmount = orders[_orderId].payAmount;\\r\\n\\t\\taddress payToken = offers[offerId].payToken;\\r\\n\\t\\taddress payAddress = orders[_orderId].payAddress;\\r\\n\\t\\trequire(orders[_orderId].reservedUntil \\u003e= block.timestamp || offers[offerId].amount - _getBlockedAmount(offerId) \\u003e= amount, \\\"Not enough tokens in the offer\\\");\\r\\n\\t\\tbytes32 data = keccak256(abi.encodePacked(_orderId, payAmount, payToken, payAddress));\\r\\n\\t\\trequire(_verifySign(data, _sign), \\\"Incorrect signature\\\");\\r\\n\\t\\tTransferHelper.safeTransfer(offers[offerId].token, orders[_orderId].withdrawAddress, amount);\\r\\n\\t\\torders[_orderId].complete = true;\\r\\n\\t\\toffers[offerId].amount -= amount;\\r\\n\\t\\temit OrderComplete(_orderId, offers[offerId].amount);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _checkOfferAccess(uint _offerId) private view {\\r\\n\\t\\trequire(_offerId \\u003c offers.length, \\\"Incorrect offerId\\\");\\r\\n\\t\\trequire(offers[_offerId].ownerAddress == msg.sender, \\\"Forbidden\\\");\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _getBlockedAmount(uint _offerId) private view returns(uint blockedAmount) {\\r\\n\\t\\tblockedAmount = 0;\\r\\n\\t\\tfor (uint i = 0; i \\u003c orders.length; i++) {\\r\\n\\t\\t\\tif (orders[i].offerId == _offerId \\u0026\\u0026 orders[i].complete == false \\u0026\\u0026 orders[i].reservedUntil \\u003e= block.timestamp) {\\r\\n\\t\\t\\t\\tblockedAmount += orders[i].amount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _verifySign(bytes32 _data, bytes memory _sign) private view returns (bool) {\\r\\n        bytes32 hash = _toEthBytes32SignedMessageHash(_data);\\r\\n        address[] memory signList = _recoverAddresses(hash, _sign);\\r\\n        return signList[0] == signer;\\r\\n    }\\r\\n\\t\\r\\n\\tfunction _toEthBytes32SignedMessageHash (bytes32 _data) pure private returns (bytes32 signHash) {\\r\\n        signHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _data));\\r\\n    }\\r\\n\\t\\r\\n\\tfunction _recoverAddresses(bytes32 _hash, bytes memory _signatures) pure private returns (address[] memory addresses) {\\r\\n        uint8 v;\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint count = _countSignatures(_signatures);\\r\\n        addresses = new address[](count);\\r\\n        for (uint i = 0; i \\u003c count; i++) {\\r\\n            (v, r, s) = _parseSignature(_signatures, i);\\r\\n            addresses[i] = ecrecover(_hash, v, r, s);\\r\\n        }\\r\\n    }\\r\\n\\t\\r\\n\\tfunction _parseSignature(bytes memory _signatures, uint _pos) pure private returns (uint8 v, bytes32 r, bytes32 s) {\\r\\n        uint offset = _pos * 65;\\r\\n        assembly {\\r\\n            r := mload(add(_signatures, add(32, offset)))\\r\\n            s := mload(add(_signatures, add(64, offset)))\\r\\n            v := and(mload(add(_signatures, add(65, offset))), 0xff)\\r\\n        }\\r\\n        if (v \\u003c 27) v += 27;\\r\\n        require(v == 27 || v == 28);\\r\\n    }\\r\\n    \\r\\n    function _countSignatures(bytes memory _signatures) pure private returns (uint) {\\r\\n        return _signatures.length % 65 == 0 ? _signatures.length / 65 : 0;\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity \\u003e=0.6.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reservationTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPurchase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"OfferAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPurchase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"OfferUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservedUntil\",\"type\":\"uint256\"}],\"name\":\"OrderAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"}],\"name\":\"OrderComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payAddress\",\"type\":\"address\"}],\"name\":\"OrderPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RATE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"activateOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minPurchase\",\"type\":\"uint256\"}],\"name\":\"addOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payAmount\",\"type\":\"uint256\"}],\"name\":\"addOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reservationTime\",\"type\":\"uint256\"}],\"name\":\"changeReservationTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"deactivateOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payAddress\",\"type\":\"address\"}],\"name\":\"payOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minPurchase\",\"type\":\"uint256\"}],\"name\":\"updateOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sign\",\"type\":\"bytes\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HashBridge","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c534d992277418b2fbfe6183e8c4796ad2565bcc000000000000000000000000000000000000000000000000000000000000a8c0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0bc382c0cee06df0dfbadb18cde0719add0beaf863057709d3640f346101f45b"}]}