{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/amm/OptionAMMPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./AMM.sol\\\";\\nimport \\\"../lib/CappedPool.sol\\\";\\nimport \\\"../lib/CombinedActionsGuard.sol\\\";\\nimport \\\"../interfaces/IPriceProvider.sol\\\";\\nimport \\\"../interfaces/IIVProvider.sol\\\";\\nimport \\\"../interfaces/IBlackScholes.sol\\\";\\nimport \\\"../interfaces/IIVGuesser.sol\\\";\\nimport \\\"../interfaces/IPodOption.sol\\\";\\nimport \\\"../interfaces/IOptionAMMPool.sol\\\";\\nimport \\\"../interfaces/IFeePool.sol\\\";\\nimport \\\"../interfaces/IConfigurationManager.sol\\\";\\nimport \\\"../interfaces/IEmergencyStop.sol\\\";\\nimport \\\"../interfaces/IFeePoolBuilder.sol\\\";\\nimport \\\"../options/rewards/AaveIncentives.sol\\\";\\n\\n/**\\n * Represents an Option specific single-sided AMM.\\n *\\n * The tokenA MUST be an PodOption contract implementation.\\n * The tokenB is preferable to be an stable asset such as DAI or USDC.\\n *\\n * There are 4 external contracts used by this contract:\\n *\\n * - priceProvider: responsible for the the spot price of the option's underlying asset.\\n * - priceMethod: responsible for the current price of the option itself.\\n * - impliedVolatility: responsible for one of the priceMethod inputs:\\n *     implied Volatility\\n * - feePoolA and feePoolB: responsible for handling Liquidity providers fees.\\n */\\n\\ncontract OptionAMMPool is AMM, IOptionAMMPool, CappedPool, CombinedActionsGuard, ReentrancyGuard, AaveIncentives {\\n    using SafeMath for uint256;\\n    uint256 public constant PRICING_DECIMALS = 18;\\n    uint256 private constant _SECONDS_IN_A_YEAR = 31536000;\\n    uint256 private constant _ORACLE_IV_WEIGHT = 3;\\n    uint256 private constant _POOL_IV_WEIGHT = 1;\\n\\n    // External Contracts\\n    /**\\n     * @notice store globally accessed configurations\\n     */\\n    IConfigurationManager public immutable configurationManager;\\n\\n    /**\\n     * @notice responsible for handling Liquidity providers fees of the token A\\n     */\\n    IFeePool public immutable feePoolA;\\n\\n    /**\\n     * @notice responsible for handling Liquidity providers fees of the token B\\n     */\\n    IFeePool public immutable feePoolB;\\n\\n    // Option Info\\n    struct PriceProperties {\\n        uint256 expiration;\\n        uint256 startOfExerciseWindow;\\n        uint256 strikePrice;\\n        address underlyingAsset;\\n        IPodOption.OptionType optionType;\\n        uint256 currentIV;\\n        int256 riskFree;\\n        uint256 initialIVGuess;\\n    }\\n\\n    /**\\n     * @notice priceProperties are all information needed to handle the price discovery method\\n     * most of the properties will be used by getABPrice\\n     */\\n    PriceProperties public priceProperties;\\n\\n    event TradeInfo(uint256 spotPrice, uint256 newIV);\\n\\n    constructor(\\n        address _optionAddress,\\n        address _stableAsset,\\n        uint256 _initialIV,\\n        IConfigurationManager _configurationManager,\\n        IFeePoolBuilder _feePoolBuilder\\n    ) public AMM(_optionAddress, _stableAsset) CappedPool(_configurationManager) AaveIncentives(_configurationManager) {\\n        require(\\n            IPodOption(_optionAddress).exerciseType() == IPodOption.ExerciseType.EUROPEAN,\\n            \\\"Pool: invalid exercise type\\\"\\n        );\\n\\n        feePoolA = _feePoolBuilder.buildFeePool(_stableAsset, 10, 3, address(this));\\n        feePoolB = _feePoolBuilder.buildFeePool(_stableAsset, 10, 3, address(this));\\n\\n        priceProperties.currentIV = _initialIV;\\n        priceProperties.initialIVGuess = _initialIV;\\n        priceProperties.underlyingAsset = IPodOption(_optionAddress).underlyingAsset();\\n        priceProperties.expiration = IPodOption(_optionAddress).expiration();\\n        priceProperties.startOfExerciseWindow = IPodOption(_optionAddress).startOfExerciseWindow();\\n        priceProperties.optionType = IPodOption(_optionAddress).optionType();\\n\\n        uint256 strikePrice = IPodOption(_optionAddress).strikePrice();\\n        uint256 strikePriceDecimals = IPodOption(_optionAddress).strikePriceDecimals();\\n\\n        require(strikePriceDecimals <= PRICING_DECIMALS, \\\"Pool: invalid strikePrice unit\\\");\\n        require(tokenBDecimals() <= PRICING_DECIMALS, \\\"Pool: invalid tokenB unit\\\");\\n        uint256 strikePriceWithRightDecimals = strikePrice.mul(10**(PRICING_DECIMALS - strikePriceDecimals));\\n\\n        priceProperties.strikePrice = strikePriceWithRightDecimals;\\n        configurationManager = IConfigurationManager(_configurationManager);\\n    }\\n\\n    /**\\n     * @notice addLiquidity in any proportion of tokenA or tokenB\\n     *\\n     * @dev This function can only be called before option expiration\\n     *\\n     * @param amountOfA amount of TokenA to add\\n     * @param amountOfB amount of TokenB to add\\n     * @param owner address of the account that will have ownership of the liquidity\\n     */\\n    function addLiquidity(\\n        uint256 amountOfA,\\n        uint256 amountOfB,\\n        address owner\\n    ) external override capped(tokenB(), amountOfB) {\\n        require(msg.sender == configurationManager.getOptionHelper() || msg.sender == owner, \\\"AMM: invalid sender\\\");\\n        _nonCombinedActions();\\n        _beforeStartOfExerciseWindow();\\n        _emergencyStopCheck();\\n        _addLiquidity(amountOfA, amountOfB, owner);\\n        _emitTradeInfo();\\n    }\\n\\n    /**\\n     * @notice removeLiquidity in any proportion of tokenA or tokenB\\n     *\\n     * @param amountOfA amount of TokenA to add\\n     * @param amountOfB amount of TokenB to add\\n     */\\n    function removeLiquidity(uint256 amountOfA, uint256 amountOfB) external override nonReentrant {\\n        _nonCombinedActions();\\n        _emergencyStopCheck();\\n        _removeLiquidity(amountOfA, amountOfB);\\n        _emitTradeInfo();\\n    }\\n\\n    /**\\n     * @notice withdrawRewards claims reward from Aave and send to admin\\n     * @dev should only be called by the admin power\\n     *\\n     */\\n    function withdrawRewards() external override {\\n        require(msg.sender == configurationManager.owner(), \\\"not owner\\\");\\n        address[] memory assets = new address[](1);\\n        assets[0] = this.tokenB();\\n\\n        _claimRewards(assets);\\n\\n        address rewardAsset = _parseAddressFromUint(configurationManager.getParameter(\\\"REWARD_ASSET\\\"));\\n        uint256 rewardsToSend = _rewardBalance();\\n\\n        IERC20(rewardAsset).safeTransfer(msg.sender, rewardsToSend);\\n    }\\n\\n    /**\\n     * @notice tradeExactAInput msg.sender is able to trade exact amount of token A in exchange for minimum\\n     * amount of token B and send the tokens B to the owner. After that, this function also updates the\\n     * priceProperties.* currentIV\\n     *\\n     * @dev initialIVGuess is a parameter for gas saving costs purpose. Instead of calculating the new implied volatility\\n     * out of thin ar, caller can help the Numeric Method achieve the result in less iterations with this parameter.\\n     * In order to know which guess the caller should use, call the getOptionTradeDetailsExactAInput first.\\n     *\\n     * @param exactAmountAIn exact amount of A token that will be transfer from msg.sender\\n     * @param minAmountBOut minimum acceptable amount of token B to transfer to owner\\n     * @param owner the destination address that will receive the token B\\n     * @param initialIVGuess The first guess that the Numeric Method (getPutIV / getCallIV) should use\\n     */\\n    function tradeExactAInput(\\n        uint256 exactAmountAIn,\\n        uint256 minAmountBOut,\\n        address owner,\\n        uint256 initialIVGuess\\n    ) external override nonReentrant returns (uint256) {\\n        _nonCombinedActions();\\n        _beforeStartOfExerciseWindow();\\n        _emergencyStopCheck();\\n        priceProperties.initialIVGuess = initialIVGuess;\\n\\n        uint256 amountBOut = _tradeExactAInput(exactAmountAIn, minAmountBOut, owner);\\n\\n        _emitTradeInfo();\\n        return amountBOut;\\n    }\\n\\n    /**\\n     * @notice _tradeExactAOutput owner is able to receive exact amount of token A in exchange of a max\\n     * acceptable amount of token B transfer from the msg.sender. After that, this function also updates\\n     * the priceProperties.currentIV\\n     *\\n     * @dev initialIVGuess is a parameter for gas saving costs purpose. Instead of calculating the new implied volatility\\n     * out of thin ar, caller can help the Numeric Method achieve the result in less iterations with this parameter.\\n     * In order to know which guess the caller should use, call the getOptionTradeDetailsExactAOutput first.\\n     *\\n     * @param exactAmountAOut exact amount of token A that will be transfer to owner\\n     * @param maxAmountBIn maximum acceptable amount of token B to transfer from msg.sender\\n     * @param owner the destination address that will receive the token A\\n     * @param initialIVGuess The first guess that the Numeric Method (getPutIV / getCallIV) should use\\n     */\\n    function tradeExactAOutput(\\n        uint256 exactAmountAOut,\\n        uint256 maxAmountBIn,\\n        address owner,\\n        uint256 initialIVGuess\\n    ) external override nonReentrant returns (uint256) {\\n        _nonCombinedActions();\\n        _beforeStartOfExerciseWindow();\\n        _emergencyStopCheck();\\n        priceProperties.initialIVGuess = initialIVGuess;\\n\\n        uint256 amountBIn = _tradeExactAOutput(exactAmountAOut, maxAmountBIn, owner);\\n\\n        _emitTradeInfo();\\n        return amountBIn;\\n    }\\n\\n    /**\\n     * @notice _tradeExactBInput msg.sender is able to trade exact amount of token B in exchange for minimum\\n     * amount of token A sent to the owner. After that, this function also updates the priceProperties.currentIV\\n     *\\n     * @dev initialIVGuess is a parameter for gas saving costs purpose. Instead of calculating the new implied volatility\\n     * out of thin ar, caller can help the Numeric Method achieve the result ini less iterations with this parameter.\\n     * In order to know which guess the caller should use, call the getOptionTradeDetailsExactBInput first.\\n     *\\n     * @param exactAmountBIn exact amount of token B that will be transfer from msg.sender\\n     * @param minAmountAOut minimum acceptable amount of token A to transfer to owner\\n     * @param owner the destination address that will receive the token A\\n     * @param initialIVGuess The first guess that the Numeric Method (getPutIV / getCallIV) should use\\n     */\\n    function tradeExactBInput(\\n        uint256 exactAmountBIn,\\n        uint256 minAmountAOut,\\n        address owner,\\n        uint256 initialIVGuess\\n    ) external override nonReentrant returns (uint256) {\\n        _nonCombinedActions();\\n        _beforeStartOfExerciseWindow();\\n        _emergencyStopCheck();\\n        priceProperties.initialIVGuess = initialIVGuess;\\n\\n        uint256 amountAOut = _tradeExactBInput(exactAmountBIn, minAmountAOut, owner);\\n\\n        _emitTradeInfo();\\n        return amountAOut;\\n    }\\n\\n    /**\\n     * @notice _tradeExactBOutput owner is able to receive exact amount of token B in exchange of a max\\n     * acceptable amount of token A transfer from msg.sender. After that, this function also updates the\\n     * priceProperties.currentIV\\n     *\\n     * @dev initialIVGuess is a parameter for gas saving costs purpose. Instead of calculating the new implied volatility\\n     * out of thin ar, caller can help the Numeric Method achieve the result ini less iterations with this parameter.\\n     * In order to know which guess the caller should use, call the getOptionTradeDetailsExactBOutput first.\\n     *\\n     * @param exactAmountBOut exact amount of token B that will be transfer to owner\\n     * @param maxAmountAIn maximum acceptable amount of token A to transfer from msg.sender\\n     * @param owner the destination address that will receive the token B\\n     * @param initialIVGuess The first guess that the Numeric Method (getPutIV / getCallIV) should use\\n     */\\n    function tradeExactBOutput(\\n        uint256 exactAmountBOut,\\n        uint256 maxAmountAIn,\\n        address owner,\\n        uint256 initialIVGuess\\n    ) external override nonReentrant returns (uint256) {\\n        _nonCombinedActions();\\n        _beforeStartOfExerciseWindow();\\n        _emergencyStopCheck();\\n        priceProperties.initialIVGuess = initialIVGuess;\\n\\n        uint256 amountAIn = _tradeExactBOutput(exactAmountBOut, maxAmountAIn, owner);\\n\\n        _emitTradeInfo();\\n        return amountAIn;\\n    }\\n\\n    /**\\n     * @notice getRemoveLiquidityAmounts external function that returns the available for rescue\\n     * amounts of token A, and token B based on the original position\\n     *\\n     * @param percentA percent of exposition of Token A to be removed\\n     * @param percentB percent of exposition of Token B to be removed\\n     * @param user Opening Value Factor by the moment of the deposit\\n     *\\n     * @return withdrawAmountA the total amount of token A that will be rescued\\n     * @return withdrawAmountB the total amount of token B that will be rescued plus fees\\n     */\\n    function getRemoveLiquidityAmounts(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address user\\n    ) external override view returns (uint256 withdrawAmountA, uint256 withdrawAmountB) {\\n        (uint256 poolWithdrawAmountA, uint256 poolWithdrawAmountB) = _getRemoveLiquidityAmounts(\\n            percentA,\\n            percentB,\\n            user\\n        );\\n        (uint256 feeSharesA, uint256 feeSharesB) = _getAmountOfFeeShares(percentA, percentB, user);\\n        uint256 feesWithdrawAmountA = 0;\\n        uint256 feesWithdrawAmountB = 0;\\n\\n        if (feeSharesA > 0) {\\n            (, feesWithdrawAmountA) = feePoolA.getWithdrawAmount(user, feeSharesA);\\n        }\\n\\n        if (feeSharesB > 0) {\\n            (, feesWithdrawAmountB) = feePoolB.getWithdrawAmount(user, feeSharesB);\\n        }\\n\\n        withdrawAmountA = poolWithdrawAmountA;\\n        withdrawAmountB = poolWithdrawAmountB.add(feesWithdrawAmountA).add(feesWithdrawAmountB);\\n        return (withdrawAmountA, withdrawAmountB);\\n    }\\n\\n    /**\\n     * @notice getABPrice This function wll call internal function _getABPrice that will calculate the\\n     * calculate the ABPrice based on current market conditions. It calculates only the unit price AB, not taking in\\n     * consideration the slippage.\\n     *\\n     * @return ABPrice ABPrice is the unit price AB. Meaning how many units of B, buys 1 unit of A\\n     */\\n    function getABPrice() external override view returns (uint256 ABPrice) {\\n        return _getABPrice();\\n    }\\n\\n    /**\\n     * @notice getAdjustedIV This function will return the adjustedIV, which is an average\\n     * between the pool IV and an external oracle IV\\n     *\\n     * @return adjustedIV The average between pool's IV and external oracle IV\\n     */\\n    function getAdjustedIV() external override view returns (uint256 adjustedIV) {\\n        return _getAdjustedIV(tokenA(), priceProperties.currentIV);\\n    }\\n\\n    /**\\n     * @notice getOptionTradeDetailsExactAInput view function that simulates a trade, in order the preview\\n     * the amountBOut, the new implied volatility, that will be used as the initialIVGuess if caller wants to perform\\n     * a trade in sequence. Also returns the amount of Fees that will be payed to liquidity pools A and B.\\n     *\\n     * @param exactAmountAIn amount of token A that will by transfer from msg.sender to the pool\\n     *\\n     * @return amountBOut amount of B in exchange of the exactAmountAIn\\n     * @return newIV the new implied volatility that this trade will result\\n     * @return feesTokenA amount of fees of collected by token A\\n     * @return feesTokenB amount of fees of collected by token B\\n     */\\n    function getOptionTradeDetailsExactAInput(uint256 exactAmountAIn)\\n        external\\n        override\\n        view\\n        returns (\\n            uint256 amountBOut,\\n            uint256 newIV,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        )\\n    {\\n        return _getOptionTradeDetailsExactAInput(exactAmountAIn);\\n    }\\n\\n    /**\\n     * @notice getOptionTradeDetailsExactAOutput view function that simulates a trade, in order the preview\\n     * the amountBIn, the new implied volatility, that will be used as the initialIVGuess if caller wants to perform\\n     * a trade in sequence. Also returns the amount of Fees that will be payed to liquidity pools A and B.\\n     *\\n     * @param exactAmountAOut amount of token A that will by transfer from pool to the msg.sender/owner\\n     *\\n     * @return amountBIn amount of B that will be transfer from msg.sender to the pool\\n     * @return newIV the new implied volatility that this trade will result\\n     * @return feesTokenA amount of fees of collected by token A\\n     * @return feesTokenB amount of fees of collected by token B\\n     */\\n    function getOptionTradeDetailsExactAOutput(uint256 exactAmountAOut)\\n        external\\n        override\\n        view\\n        returns (\\n            uint256 amountBIn,\\n            uint256 newIV,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        )\\n    {\\n        return _getOptionTradeDetailsExactAOutput(exactAmountAOut);\\n    }\\n\\n    /**\\n     * @notice getOptionTradeDetailsExactBInput view function that simulates a trade, in order the preview\\n     * the amountAOut, the new implied volatility, that will be used as the initialIVGuess if caller wants to perform\\n     * a trade in sequence. Also returns the amount of Fees that will be payed to liquidity pools A and B.\\n     *\\n     * @param exactAmountBIn amount of token B that will by transfer from msg.sender to the pool\\n     *\\n     * @return amountAOut amount of A that will be transfer from contract to owner\\n     * @return newIV the new implied volatility that this trade will result\\n     * @return feesTokenA amount of fees of collected by token A\\n     * @return feesTokenB amount of fees of collected by token B\\n     */\\n    function getOptionTradeDetailsExactBInput(uint256 exactAmountBIn)\\n        external\\n        override\\n        view\\n        returns (\\n            uint256 amountAOut,\\n            uint256 newIV,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        )\\n    {\\n        return _getOptionTradeDetailsExactBInput(exactAmountBIn);\\n    }\\n\\n    /**\\n     * @notice getOptionTradeDetailsExactBOutput view function that simulates a trade, in order the preview\\n     * the amountAIn, the new implied volatility, that will be used as the initialIVGuess if caller wants to perform\\n     * a trade in sequence. Also returns the amount of Fees that will be payed to liquidity pools A and B.\\n     *\\n     * @param exactAmountBOut amount of token B that will by transfer from pool to the msg.sender/owner\\n     *\\n     * @return amountAIn amount of A that will be transfer from msg.sender to the pool\\n     * @return newIV the new implied volatility that this trade will result\\n     * @return feesTokenA amount of fees of collected by token A\\n     * @return feesTokenB amount of fees of collected by token B\\n     */\\n    function getOptionTradeDetailsExactBOutput(uint256 exactAmountBOut)\\n        external\\n        override\\n        view\\n        returns (\\n            uint256 amountAIn,\\n            uint256 newIV,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        )\\n    {\\n        return _getOptionTradeDetailsExactBOutput(exactAmountBOut);\\n    }\\n\\n    function _getOptionTradeDetailsExactAInput(uint256 exactAmountAIn)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (uint256 newABPrice, uint256 spotPrice, uint256 timeToMaturity) = _getPriceDetails();\\n        if (newABPrice == 0) {\\n            return (0, 0, 0, 0);\\n        }\\n\\n        (uint256 poolAmountA, uint256 poolAmountB) = _getPoolAmounts(newABPrice);\\n\\n        uint256 amountBOutPool = _getAmountBOutPool(exactAmountAIn, poolAmountA, poolAmountB);\\n        uint256 newTargetABPrice = _getNewTargetPrice(newABPrice, exactAmountAIn, amountBOutPool, TradeDirection.AB);\\n\\n        // Prevents the pool to sell an option under the minimum target price,\\n        // because it causes an infinite loop when trying to calculate newIV\\n        if (!_isValidTargetPrice(newTargetABPrice, spotPrice)) {\\n            return (0, 0, 0, 0);\\n        }\\n\\n        uint256 newIV = _getNewIV(newTargetABPrice, spotPrice, timeToMaturity);\\n\\n        uint256 feesTokenA = feePoolA.getCollectable(amountBOutPool, poolAmountB);\\n        uint256 feesTokenB = feePoolB.getCollectable(amountBOutPool, poolAmountB);\\n\\n        uint256 amountBOutUser = amountBOutPool.sub(feesTokenA).sub(feesTokenB);\\n\\n        return (amountBOutUser, newIV, feesTokenA, feesTokenB);\\n    }\\n\\n    function _getOptionTradeDetailsExactAOutput(uint256 exactAmountAOut)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (uint256 newABPrice, uint256 spotPrice, uint256 timeToMaturity) = _getPriceDetails();\\n        if (newABPrice == 0) {\\n            return (0, 0, 0, 0);\\n        }\\n        (uint256 poolAmountA, uint256 poolAmountB) = _getPoolAmounts(newABPrice);\\n\\n        uint256 amountBInPool = _getAmountBInPool(exactAmountAOut, poolAmountA, poolAmountB);\\n        uint256 newTargetABPrice = _getNewTargetPrice(newABPrice, exactAmountAOut, amountBInPool, TradeDirection.BA);\\n\\n        uint256 feesTokenA = feePoolA.getCollectable(amountBInPool, poolAmountB);\\n        uint256 feesTokenB = feePoolB.getCollectable(amountBInPool, poolAmountB);\\n\\n        uint256 amountBInUser = amountBInPool.add(feesTokenA).add(feesTokenB);\\n\\n        uint256 newIV = _getNewIV(newTargetABPrice, spotPrice, timeToMaturity);\\n\\n        return (amountBInUser, newIV, feesTokenA, feesTokenB);\\n    }\\n\\n    function _getOptionTradeDetailsExactBInput(uint256 exactAmountBIn)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (uint256 newABPrice, uint256 spotPrice, uint256 timeToMaturity) = _getPriceDetails();\\n        if (newABPrice == 0) {\\n            return (0, 0, 0, 0);\\n        }\\n        (uint256 poolAmountA, uint256 poolAmountB) = _getPoolAmounts(newABPrice);\\n\\n        uint256 feesTokenA = feePoolA.getCollectable(exactAmountBIn, poolAmountB);\\n        uint256 feesTokenB = feePoolB.getCollectable(exactAmountBIn, poolAmountB);\\n        uint256 totalFees = feesTokenA.add(feesTokenB);\\n\\n        uint256 poolBIn = exactAmountBIn.sub(totalFees);\\n\\n        uint256 amountAOutPool = _getAmountAOutPool(poolBIn, poolAmountA, poolAmountB);\\n        uint256 newTargetABPrice = _getNewTargetPrice(newABPrice, amountAOutPool, poolBIn, TradeDirection.BA);\\n\\n        uint256 newIV = _getNewIV(newTargetABPrice, spotPrice, timeToMaturity);\\n\\n        return (amountAOutPool, newIV, feesTokenA, feesTokenB);\\n    }\\n\\n    function _getOptionTradeDetailsExactBOutput(uint256 exactAmountBOut)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (uint256 newABPrice, uint256 spotPrice, uint256 timeToMaturity) = _getPriceDetails();\\n        if (newABPrice == 0) {\\n            return (0, 0, 0, 0);\\n        }\\n        (uint256 poolAmountA, uint256 poolAmountB) = _getPoolAmounts(newABPrice);\\n\\n        uint256 feesTokenA = feePoolA.getCollectable(exactAmountBOut, poolAmountB);\\n        uint256 feesTokenB = feePoolB.getCollectable(exactAmountBOut, poolAmountB);\\n        uint256 totalFees = feesTokenA.add(feesTokenB);\\n\\n        uint256 poolBOut = exactAmountBOut.add(totalFees);\\n\\n        uint256 amountAInPool = _getAmountAInPool(poolBOut, poolAmountA, poolAmountB);\\n        uint256 newTargetABPrice = _getNewTargetPrice(newABPrice, amountAInPool, poolBOut, TradeDirection.AB);\\n\\n        // Prevents the pool to sell an option under the minimum target price,\\n        // because it causes an infinite loop when trying to calculate newIV\\n        if (!_isValidTargetPrice(newTargetABPrice, spotPrice)) {\\n            return (0, 0, 0, 0);\\n        }\\n\\n        uint256 newIV = _getNewIV(newTargetABPrice, spotPrice, timeToMaturity);\\n\\n        return (amountAInPool, newIV, feesTokenA, feesTokenB);\\n    }\\n\\n    function _getPriceDetails()\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 timeToMaturity = _getTimeToMaturityInYears();\\n\\n        if (timeToMaturity == 0) {\\n            return (0, 0, 0);\\n        }\\n\\n        uint256 spotPrice = _getSpotPrice(priceProperties.underlyingAsset, PRICING_DECIMALS);\\n        uint256 adjustedIV = _getAdjustedIV(tokenA(), priceProperties.currentIV);\\n\\n        IBlackScholes pricingMethod = IBlackScholes(configurationManager.getPricingMethod());\\n        uint256 newABPrice;\\n\\n        if (priceProperties.optionType == IPodOption.OptionType.PUT) {\\n            newABPrice = pricingMethod.getPutPrice(\\n                spotPrice,\\n                priceProperties.strikePrice,\\n                adjustedIV,\\n                timeToMaturity,\\n                priceProperties.riskFree\\n            );\\n        } else {\\n            newABPrice = pricingMethod.getCallPrice(\\n                spotPrice,\\n                priceProperties.strikePrice,\\n                adjustedIV,\\n                timeToMaturity,\\n                priceProperties.riskFree\\n            );\\n        }\\n        if (newABPrice == 0) {\\n            return (0, spotPrice, timeToMaturity);\\n        }\\n        uint256 newABPriceWithDecimals = newABPrice.div(10**(PRICING_DECIMALS.sub(tokenBDecimals())));\\n        return (newABPriceWithDecimals, spotPrice, timeToMaturity);\\n    }\\n\\n    /**\\n     * @dev returns maturity in years with 18 decimals\\n     */\\n    function _getTimeToMaturityInYears() internal view returns (uint256) {\\n        if (block.timestamp >= priceProperties.expiration) {\\n            return 0;\\n        }\\n        return priceProperties.expiration.sub(block.timestamp).mul(10**PRICING_DECIMALS).div(_SECONDS_IN_A_YEAR);\\n    }\\n\\n    function _getPoolAmounts(uint256 newABPrice) internal view returns (uint256 poolAmountA, uint256 poolAmountB) {\\n        (uint256 totalAmountA, uint256 totalAmountB) = _getPoolBalances();\\n        if (newABPrice != 0) {\\n            poolAmountA = _min(totalAmountA, totalAmountB.mul(10**uint256(tokenADecimals())).div(newABPrice));\\n            poolAmountB = _min(totalAmountB, totalAmountA.mul(newABPrice).div(10**uint256(tokenADecimals())));\\n        }\\n        return (poolAmountA, poolAmountB);\\n    }\\n\\n    function _getABPrice() internal override view returns (uint256) {\\n        (uint256 newABPrice, , ) = _getPriceDetails();\\n        return newABPrice;\\n    }\\n\\n    function _getSpotPrice(address asset, uint256 decimalsOutput) internal view returns (uint256) {\\n        IPriceProvider priceProvider = IPriceProvider(configurationManager.getPriceProvider());\\n        uint256 spotPrice = priceProvider.getAssetPrice(asset);\\n        uint256 spotPriceDecimals = priceProvider.getAssetDecimals(asset);\\n        uint256 diffDecimals;\\n        uint256 spotPriceWithRightPrecision;\\n\\n        if (decimalsOutput <= spotPriceDecimals) {\\n            diffDecimals = spotPriceDecimals.sub(decimalsOutput);\\n            spotPriceWithRightPrecision = spotPrice.div(10**diffDecimals);\\n        } else {\\n            diffDecimals = decimalsOutput.sub(spotPriceDecimals);\\n            spotPriceWithRightPrecision = spotPrice.mul(10**diffDecimals);\\n        }\\n        return spotPriceWithRightPrecision;\\n    }\\n\\n    function _getOracleIV(address optionAddress) internal view returns (uint256 normalizedOracleIV) {\\n        IIVProvider ivProvider = IIVProvider(configurationManager.getIVProvider());\\n        (, , uint256 oracleIV, uint256 ivDecimals) = ivProvider.getIV(optionAddress);\\n        uint256 diffDecimals;\\n\\n        if (ivDecimals <= PRICING_DECIMALS) {\\n            diffDecimals = PRICING_DECIMALS.sub(ivDecimals);\\n        } else {\\n            diffDecimals = ivDecimals.sub(PRICING_DECIMALS);\\n        }\\n        return oracleIV.div(10**diffDecimals);\\n    }\\n\\n    function _getAdjustedIV(address optionAddress, uint256 currentIV) internal view returns (uint256 adjustedIV) {\\n        uint256 oracleIV = _getOracleIV(optionAddress);\\n\\n        adjustedIV = _ORACLE_IV_WEIGHT.mul(oracleIV).add(_POOL_IV_WEIGHT.mul(currentIV)).div(\\n            _POOL_IV_WEIGHT + _ORACLE_IV_WEIGHT\\n        );\\n    }\\n\\n    function _getNewIV(\\n        uint256 newTargetABPrice,\\n        uint256 spotPrice,\\n        uint256 timeToMaturity\\n    ) internal view returns (uint256) {\\n        uint256 newTargetABPriceWithDecimals = newTargetABPrice.mul(10**(PRICING_DECIMALS.sub(tokenBDecimals())));\\n        uint256 newIV;\\n        IIVGuesser ivGuesser = IIVGuesser(configurationManager.getIVGuesser());\\n        if (priceProperties.optionType == IPodOption.OptionType.PUT) {\\n            (newIV, ) = ivGuesser.getPutIV(\\n                newTargetABPriceWithDecimals,\\n                priceProperties.initialIVGuess,\\n                spotPrice,\\n                priceProperties.strikePrice,\\n                timeToMaturity,\\n                priceProperties.riskFree\\n            );\\n        } else {\\n            (newIV, ) = ivGuesser.getCallIV(\\n                newTargetABPriceWithDecimals,\\n                priceProperties.initialIVGuess,\\n                spotPrice,\\n                priceProperties.strikePrice,\\n                timeToMaturity,\\n                priceProperties.riskFree\\n            );\\n        }\\n        return newIV;\\n    }\\n\\n    /**\\n     * @dev After it gets the unit BlackScholes price, it applies slippage based on the minimum available in the pool\\n     * (returned by the _getPoolAmounts()) and the product constant curve.\\n     * @param amountBOutPool The exact amount of tokenB will leave the pool\\n     * @param poolAmountA The amount of A available for trade\\n     * @param poolAmountB The amount of B available for trade\\n     * @return amountAInPool The amount of tokenA(options) will enter the pool\\n     */\\n    function _getAmountAInPool(\\n        uint256 amountBOutPool,\\n        uint256 poolAmountA,\\n        uint256 poolAmountB\\n    ) internal pure returns (uint256 amountAInPool) {\\n        uint256 productConstant = poolAmountA.mul(poolAmountB);\\n        require(amountBOutPool < poolAmountB, \\\"AMM: insufficient liquidity\\\");\\n        amountAInPool = productConstant.div(poolAmountB.sub(amountBOutPool)).sub(poolAmountA);\\n    }\\n\\n    /**\\n     * @dev After it gets the unit BlackScholes price, it applies slippage based on the minimum available in the pool\\n     * (returned by the _getPoolAmounts()) and the product constant curve.\\n     * @param amountBInPool The exact amount of tokenB will enter the pool\\n     * @param poolAmountA The amount of A available for trade\\n     * @param poolAmountB The amount of B available for trade\\n     * @return amountAOutPool The amount of tokenA(options) will leave the pool\\n     */\\n    function _getAmountAOutPool(\\n        uint256 amountBInPool,\\n        uint256 poolAmountA,\\n        uint256 poolAmountB\\n    ) internal pure returns (uint256 amountAOutPool) {\\n        uint256 productConstant = poolAmountA.mul(poolAmountB);\\n        amountAOutPool = poolAmountA.sub(productConstant.div(poolAmountB.add(amountBInPool)));\\n    }\\n\\n    /**\\n     * @dev After it gets the unit BlackScholes price, it applies slippage based on the minimum available in the pool\\n     * (returned by the _getPoolAmounts()) and the product constant curve.\\n     * @param amountAOutPool The amount of tokenA(options) will leave the pool\\n     * @param poolAmountA The amount of A available for trade\\n     * @param poolAmountB The amount of B available for trade\\n     * @return amountBInPool The amount of tokenB will enter the pool\\n     */\\n    function _getAmountBInPool(\\n        uint256 amountAOutPool,\\n        uint256 poolAmountA,\\n        uint256 poolAmountB\\n    ) internal pure returns (uint256 amountBInPool) {\\n        uint256 productConstant = poolAmountA.mul(poolAmountB);\\n        require(amountAOutPool < poolAmountA, \\\"AMM: insufficient liquidity\\\");\\n        amountBInPool = productConstant.div(poolAmountA.sub(amountAOutPool)).sub(poolAmountB);\\n    }\\n\\n    /**\\n     * @dev After it gets the unit BlackScholes price, it applies slippage based on the minimum available in the pool\\n     * (returned by the _getPoolAmounts()) and the product constant curve.\\n     * @param amountAInPool The exact amount of tokenA(options) will enter the pool\\n     * @param poolAmountA The amount of A available for trade\\n     * @param poolAmountB The amount of B available for trade\\n     * @return amountBOutPool The amount of tokenB will leave the pool\\n     */\\n    function _getAmountBOutPool(\\n        uint256 amountAInPool,\\n        uint256 poolAmountA,\\n        uint256 poolAmountB\\n    ) internal pure returns (uint256 amountBOutPool) {\\n        uint256 productConstant = poolAmountA.mul(poolAmountB);\\n        amountBOutPool = poolAmountB.sub(productConstant.div(poolAmountA.add(amountAInPool)));\\n    }\\n\\n    /**\\n     * @dev Based on the tokensA and tokensB leaving or entering the pool, it is possible to calculate the new option\\n     * target price. That price will be used later to update the currentIV.\\n     * @param newABPrice calculated Black Scholes unit price (how many units of tokenB, to buy 1 tokenA(option))\\n     * @param amountA The amount of tokenA that will leave or enter the pool\\n     * @param amountB TThe amount of tokenB that will leave or enter the pool\\n     * @param tradeDirection The trade direction, if it is AB, means that tokenA will enter, and tokenB will leave.\\n     * @return newTargetPrice The new unit target price (how many units of tokenB, to buy 1 tokenA(option))\\n     */\\n    function _getNewTargetPrice(\\n        uint256 newABPrice,\\n        uint256 amountA,\\n        uint256 amountB,\\n        TradeDirection tradeDirection\\n    ) internal view returns (uint256 newTargetPrice) {\\n        (uint256 poolAmountA, uint256 poolAmountB) = _getPoolAmounts(newABPrice);\\n        if (tradeDirection == TradeDirection.AB) {\\n            newTargetPrice = poolAmountB.sub(amountB).mul(10**uint256(tokenADecimals())).div(poolAmountA.add(amountA));\\n        } else {\\n            newTargetPrice = poolAmountB.add(amountB).mul(10**uint256(tokenADecimals())).div(poolAmountA.sub(amountA));\\n        }\\n    }\\n\\n    function _getTradeDetailsExactAInput(uint256 exactAmountAIn) internal override returns (TradeDetails memory) {\\n        (uint256 amountBOut, uint256 newIV, uint256 feesTokenA, uint256 feesTokenB) = _getOptionTradeDetailsExactAInput(\\n            exactAmountAIn\\n        );\\n\\n        TradeDetails memory tradeDetails = TradeDetails(amountBOut, feesTokenA, feesTokenB, abi.encodePacked(newIV));\\n        return tradeDetails;\\n    }\\n\\n    function _getTradeDetailsExactAOutput(uint256 exactAmountAOut) internal override returns (TradeDetails memory) {\\n        (uint256 amountBIn, uint256 newIV, uint256 feesTokenA, uint256 feesTokenB) = _getOptionTradeDetailsExactAOutput(\\n            exactAmountAOut\\n        );\\n\\n        TradeDetails memory tradeDetails = TradeDetails(amountBIn, feesTokenA, feesTokenB, abi.encodePacked(newIV));\\n        return tradeDetails;\\n    }\\n\\n    function _getTradeDetailsExactBInput(uint256 exactAmountBIn) internal override returns (TradeDetails memory) {\\n        (uint256 amountAOut, uint256 newIV, uint256 feesTokenA, uint256 feesTokenB) = _getOptionTradeDetailsExactBInput(\\n            exactAmountBIn\\n        );\\n\\n        TradeDetails memory tradeDetails = TradeDetails(amountAOut, feesTokenA, feesTokenB, abi.encodePacked(newIV));\\n        return tradeDetails;\\n    }\\n\\n    function _getTradeDetailsExactBOutput(uint256 exactAmountBOut) internal override returns (TradeDetails memory) {\\n        (uint256 amountAIn, uint256 newIV, uint256 feesTokenA, uint256 feesTokenB) = _getOptionTradeDetailsExactBOutput(\\n            exactAmountBOut\\n        );\\n\\n        TradeDetails memory tradeDetails = TradeDetails(amountAIn, feesTokenA, feesTokenB, abi.encodePacked(newIV));\\n        return tradeDetails;\\n    }\\n\\n    /**\\n     * @dev If a option is ITM, either PUTs or CALLs, the minimum price that it would cost is the difference between\\n     * the spot price and strike price. If the target price after applying slippage is above this minimum, the function\\n     * returns true.\\n     * @param newTargetPrice the new ABPrice after slippage (how many units of tokenB, to buy 1 option)\\n     * @param spotPrice current underlying asset spot price during this transaction\\n     * @return true if is a valid target price (above the minimum)\\n     */\\n    function _isValidTargetPrice(uint256 newTargetPrice, uint256 spotPrice) internal view returns (bool) {\\n        if (priceProperties.optionType == IPodOption.OptionType.PUT) {\\n            if (spotPrice < priceProperties.strikePrice) {\\n                return\\n                    newTargetPrice >\\n                    priceProperties.strikePrice.sub(spotPrice).div(10**PRICING_DECIMALS.sub(tokenBDecimals()));\\n            }\\n        } else {\\n            if (spotPrice > priceProperties.strikePrice) {\\n                return\\n                    newTargetPrice >\\n                    spotPrice.sub(priceProperties.strikePrice).div(10**PRICING_DECIMALS.sub(tokenBDecimals()));\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function _onAddLiquidity(UserDepositSnapshot memory _userDepositSnapshot, address owner) internal override {\\n        uint256 currentQuotesA = feePoolA.sharesOf(owner);\\n        uint256 currentQuotesB = feePoolB.sharesOf(owner);\\n        uint256 amountOfQuotesAToAdd = 0;\\n        uint256 amountOfQuotesBToAdd = 0;\\n\\n        uint256 totalQuotesA = _userDepositSnapshot.tokenABalance.mul(10**FIMP_DECIMALS).div(_userDepositSnapshot.fImp);\\n\\n        if (totalQuotesA > currentQuotesA) {\\n            amountOfQuotesAToAdd = totalQuotesA.sub(currentQuotesA);\\n        }\\n\\n        uint256 totalQuotesB = _userDepositSnapshot.tokenBBalance.mul(10**FIMP_DECIMALS).div(_userDepositSnapshot.fImp);\\n\\n        if (totalQuotesB > currentQuotesB) {\\n            amountOfQuotesBToAdd = totalQuotesB.sub(currentQuotesB);\\n        }\\n\\n        feePoolA.mint(owner, amountOfQuotesAToAdd);\\n        feePoolB.mint(owner, amountOfQuotesBToAdd);\\n    }\\n\\n    function _onRemoveLiquidity(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address owner\\n    ) internal override {\\n        (uint256 amountOfSharesAToRemove, uint256 amountOfSharesBToRemove) = _getAmountOfFeeShares(\\n            percentA,\\n            percentB,\\n            owner\\n        );\\n\\n        if (amountOfSharesAToRemove > 0) {\\n            feePoolA.withdraw(owner, amountOfSharesAToRemove);\\n        }\\n        if (amountOfSharesBToRemove > 0) {\\n            feePoolB.withdraw(owner, amountOfSharesBToRemove);\\n        }\\n    }\\n\\n    function _getAmountOfFeeShares(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address owner\\n    ) internal view returns (uint256, uint256) {\\n        uint256 currentSharesA = feePoolA.sharesOf(owner);\\n        uint256 currentSharesB = feePoolB.sharesOf(owner);\\n\\n        uint256 amountOfSharesAToRemove = currentSharesA.mul(percentA).div(PERCENT_PRECISION);\\n        uint256 amountOfSharesBToRemove = currentSharesB.mul(percentB).div(PERCENT_PRECISION);\\n\\n        return (amountOfSharesAToRemove, amountOfSharesBToRemove);\\n    }\\n\\n    function _onTrade(TradeDetails memory tradeDetails) internal override {\\n        uint256 newIV = abi.decode(tradeDetails.params, (uint256));\\n        priceProperties.currentIV = newIV;\\n\\n        IERC20(tokenB()).safeTransfer(address(feePoolA), tradeDetails.feesTokenA);\\n        IERC20(tokenB()).safeTransfer(address(feePoolB), tradeDetails.feesTokenB);\\n    }\\n\\n    /**\\n     * @dev Check for functions which are only allowed to be executed\\n     * BEFORE start of exercise window.\\n     */\\n    function _beforeStartOfExerciseWindow() internal view {\\n        require(block.timestamp < priceProperties.startOfExerciseWindow, \\\"Pool: exercise window has started\\\");\\n    }\\n\\n    function _emergencyStopCheck() private view {\\n        IEmergencyStop emergencyStop = IEmergencyStop(configurationManager.getEmergencyStop());\\n        require(\\n            !emergencyStop.isStopped(address(this)) &&\\n                !emergencyStop.isStopped(configurationManager.getPriceProvider()) &&\\n                !emergencyStop.isStopped(configurationManager.getPricingMethod()),\\n            \\\"Pool: Pool is stopped\\\"\\n        );\\n    }\\n\\n    function _emitTradeInfo() private {\\n        uint256 spotPrice = _getSpotPrice(priceProperties.underlyingAsset, PRICING_DECIMALS);\\n        emit TradeInfo(spotPrice, priceProperties.currentIV);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/amm/AMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../lib/RequiredDecimals.sol\\\";\\nimport \\\"../interfaces/IAMM.sol\\\";\\n\\n/**\\n * Represents a generalized contract for a single-sided AMM pair.\\n *\\n * That means is possible to add and remove liquidity in any proportion\\n * at any time, even 0 in one of the sides.\\n *\\n * The AMM is constituted by 3 core functions: Add Liquidity, Remove liquidity and Trade.\\n *\\n * There are 4 possible trade types between the token pair (tokenA and tokenB):\\n *\\n * - ExactAInput:\\n *     tokenA as an exact Input, meaning that the output tokenB is variable.\\n *     it is important to have a slippage control of the minimum acceptable amount of tokenB in return\\n * - ExactAOutput:\\n *     tokenA as an exact Output, meaning that the input tokenB is variable.\\n *     it is important to have a slippage control of the maximum acceptable amount of tokenB sent\\n * - ExactBInput:\\n *     tokenB as an exact Input, meaning that the output tokenA is variable.\\n *     it is important to have a slippage control of the minimum acceptable amount of tokenA in return\\n * - ExactBOutput:\\n *     tokenB as an exact Output, meaning that the input tokenA is variable.\\n *     it is important to have a slippage control of the maximum acceptable amount of tokenA sent\\n *\\n * Several functions are provided as virtual and must be overridden by the inheritor.\\n *\\n * - _getABPrice:\\n *     function that will return the tokenA:tokenB price relation.\\n *     How many units of tokenB in order to traded for 1 unit of tokenA.\\n *     This price is represented in the same tokenB number of decimals.\\n * - _onAddLiquidity:\\n *     Executed after adding liquidity. Usually used for handling fees\\n * - _onRemoveLiquidity:\\n *     Executed after removing liquidity. Usually used for handling fees\\n *\\n *  Also, for which TradeType (E.g: ExactAInput) there are more two functions to override:\\n\\n * _getTradeDetails[$TradeType]:\\n *   This function is responsible to return the TradeDetails struct, that contains basically the amount\\n *   of the other token depending on the trade type. (E.g: ExactAInput => The TradeDetails will return the\\n *   amount of B output).\\n * _onTrade[$TradeType]:\\n *    function that will be executed after UserDepositSnapshot updates and before\\n *    token transfers. Usually used for handling fees and updating state at the inheritor.\\n *\\n */\\n\\nabstract contract AMM is IAMM, RequiredDecimals {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev The initial value for deposit factor (Fimp)\\n     */\\n    uint256 public constant INITIAL_FIMP = 10**27;\\n\\n    /**\\n     * @notice The Fimp's precision (aka number of decimals)\\n     */\\n    uint256 public constant FIMP_DECIMALS = 27;\\n\\n    /**\\n     * @notice The percent's precision\\n     */\\n    uint256 public constant PERCENT_PRECISION = 100;\\n\\n    /**\\n     * @dev Address of the token A\\n     */\\n    address private _tokenA;\\n\\n    /**\\n     * @dev Address of the token B\\n     */\\n    address private _tokenB;\\n\\n    /**\\n     * @dev Token A number of decimals\\n     */\\n    uint8 private _tokenADecimals;\\n\\n    /**\\n     * @dev Token B number of decimals\\n     */\\n    uint8 private _tokenBDecimals;\\n\\n    /**\\n     * @notice The total balance of token A in the pool not counting the amortization\\n     */\\n    uint256 public deamortizedTokenABalance;\\n\\n    /**\\n     * @notice The total balance of token B in the pool not counting the amortization\\n     */\\n    uint256 public deamortizedTokenBBalance;\\n\\n    /**\\n     * @notice It contains the token A original balance, token B original balance,\\n     * and the Open Value Factor (Fimp) at the time of the deposit.\\n     */\\n    struct UserDepositSnapshot {\\n        uint256 tokenABalance;\\n        uint256 tokenBBalance;\\n        uint256 fImp;\\n    }\\n\\n    struct Mult {\\n        uint256 AA; // How much A Im getting for rescuing one A that i've deposited\\n        uint256 AB; // How much B Im getting for rescuing one A that i've deposited\\n        uint256 BA; // How much A Im getting for rescuing one B that i've deposited\\n        uint256 BB; // How much B Im getting for rescuing one B that i've deposited\\n    }\\n\\n    struct TradeDetails {\\n        uint256 amount;\\n        uint256 feesTokenA;\\n        uint256 feesTokenB;\\n        bytes params;\\n    }\\n    /**\\n     * @dev Tracks the UserDepositSnapshot struct of each user.\\n     * It contains the token A original balance, token B original balance,\\n     * and the Open Value Factor (Fimp) at the time of the deposit.\\n     */\\n    mapping(address => UserDepositSnapshot) private _userSnapshots;\\n\\n    /** Events */\\n    event AddLiquidity(address indexed caller, address indexed owner, uint256 amountA, uint256 amountB);\\n    event RemoveLiquidity(address indexed caller, uint256 amountA, uint256 amountB);\\n    event TradeExactAInput(address indexed caller, address indexed owner, uint256 exactAmountAIn, uint256 amountBOut);\\n    event TradeExactBInput(address indexed caller, address indexed owner, uint256 exactAmountBIn, uint256 amountAOut);\\n    event TradeExactAOutput(address indexed caller, address indexed owner, uint256 amountBIn, uint256 exactAmountAOut);\\n    event TradeExactBOutput(address indexed caller, address indexed owner, uint256 amountAIn, uint256 exactAmountBOut);\\n\\n    constructor(address tokenA, address tokenB) public {\\n        require(Address.isContract(tokenA), \\\"AMM: token a is not a contract\\\");\\n        require(Address.isContract(tokenB), \\\"AMM: token b is not a contract\\\");\\n        require(tokenA != tokenB, \\\"AMM: tokens must differ\\\");\\n\\n        _tokenA = tokenA;\\n        _tokenB = tokenB;\\n\\n        _tokenADecimals = tryDecimals(IERC20(tokenA));\\n        _tokenBDecimals = tryDecimals(IERC20(tokenB));\\n    }\\n\\n    /**\\n     * @dev Returns the address for tokenA\\n     */\\n    function tokenA() public override view returns (address) {\\n        return _tokenA;\\n    }\\n\\n    /**\\n     * @dev Returns the address for tokenB\\n     */\\n    function tokenB() public override view returns (address) {\\n        return _tokenB;\\n    }\\n\\n    /**\\n     * @dev Returns the decimals for tokenA\\n     */\\n    function tokenADecimals() public override view returns (uint8) {\\n        return _tokenADecimals;\\n    }\\n\\n    /**\\n     * @dev Returns the decimals for tokenB\\n     */\\n    function tokenBDecimals() public override view returns (uint8) {\\n        return _tokenBDecimals;\\n    }\\n\\n    /**\\n     * @notice getPoolBalances external function that returns the current pool balance of token A and token B\\n     *\\n     * @return totalTokenA balanceOf this contract of token A\\n     * @return totalTokenB balanceOf this contract of token B\\n     */\\n    function getPoolBalances() external view returns (uint256 totalTokenA, uint256 totalTokenB) {\\n        return _getPoolBalances();\\n    }\\n\\n    /**\\n     * @notice getUserDepositSnapshot external function that User original balance of token A,\\n     * token B and the Opening Value * * Factor (Fimp) at the moment of the liquidity added\\n     *\\n     * @param user address to check the balance info\\n     *\\n     * @return tokenAOriginalBalance balance of token A by the moment of deposit\\n     * @return tokenBOriginalBalance balance of token B by the moment of deposit\\n     * @return fImpUser value of the Opening Value Factor by the moment of the deposit\\n     */\\n    function getUserDepositSnapshot(address user)\\n        external\\n        view\\n        returns (\\n            uint256 tokenAOriginalBalance,\\n            uint256 tokenBOriginalBalance,\\n            uint256 fImpUser\\n        )\\n    {\\n        return _getUserDepositSnapshot(user);\\n    }\\n\\n    /**\\n     * @notice _addLiquidity in any proportion of tokenA or tokenB\\n     *\\n     * @dev The inheritor contract should implement _getABPrice and _onAddLiquidity functions\\n     *\\n     * @param amountOfA amount of TokenA to add\\n     * @param amountOfB amount of TokenB to add\\n     * @param owner address of the account that will have ownership of the liquidity\\n     */\\n    function _addLiquidity(\\n        uint256 amountOfA,\\n        uint256 amountOfB,\\n        address owner\\n    ) internal {\\n        _isValidAddress(owner);\\n        // Get Pool Balances\\n        (uint256 totalTokenA, uint256 totalTokenB) = _getPoolBalances();\\n\\n        bool hasNoLiquidity = deamortizedTokenABalance == 0 && deamortizedTokenBBalance == 0;\\n        uint256 fImpOpening;\\n        uint256 userAmountToStoreTokenA = amountOfA;\\n        uint256 userAmountToStoreTokenB = amountOfB;\\n\\n        if (hasNoLiquidity) {\\n            // In the first liquidity, is necessary add both tokens\\n            bool bothTokensHigherThanZero = amountOfA > 0 && amountOfB > 0;\\n            require(bothTokensHigherThanZero, \\\"AMM: invalid first liquidity\\\");\\n\\n            fImpOpening = INITIAL_FIMP;\\n\\n            deamortizedTokenABalance = amountOfA;\\n            deamortizedTokenBBalance = amountOfB;\\n        } else {\\n            // Get ABPrice\\n            uint256 ABPrice = _getABPrice();\\n            require(ABPrice > 0, \\\"AMM: option price zero\\\");\\n\\n            // Calculate the Pool's Value Factor (Fimp)\\n            fImpOpening = _getFImpOpening(\\n                totalTokenA,\\n                totalTokenB,\\n                ABPrice,\\n                deamortizedTokenABalance,\\n                deamortizedTokenBBalance\\n            );\\n\\n            (userAmountToStoreTokenA, userAmountToStoreTokenB) = _getUserBalanceToStore(\\n                amountOfA,\\n                amountOfB,\\n                fImpOpening,\\n                _userSnapshots[owner]\\n            );\\n\\n            // Update Deamortized Balance of the pool for each token;\\n            deamortizedTokenABalance = deamortizedTokenABalance.add(amountOfA.mul(10**FIMP_DECIMALS).div(fImpOpening));\\n            deamortizedTokenBBalance = deamortizedTokenBBalance.add(amountOfB.mul(10**FIMP_DECIMALS).div(fImpOpening));\\n        }\\n\\n        // Update the User Balances for each token and with the Pool Factor previously calculated\\n        UserDepositSnapshot memory userDepositSnapshot = UserDepositSnapshot(\\n            userAmountToStoreTokenA,\\n            userAmountToStoreTokenB,\\n            fImpOpening\\n        );\\n        _userSnapshots[owner] = userDepositSnapshot;\\n\\n        _onAddLiquidity(_userSnapshots[owner], owner);\\n\\n        // Update Total Balance of the pool for each token\\n        if (amountOfA > 0) {\\n            IERC20(_tokenA).safeTransferFrom(msg.sender, address(this), amountOfA);\\n        }\\n\\n        if (amountOfB > 0) {\\n            IERC20(_tokenB).safeTransferFrom(msg.sender, address(this), amountOfB);\\n        }\\n\\n        emit AddLiquidity(msg.sender, owner, amountOfA, amountOfB);\\n    }\\n\\n    /**\\n     * @notice _removeLiquidity in any proportion of tokenA or tokenB\\n     * @dev The inheritor contract should implement _getABPrice and _onRemoveLiquidity functions\\n     *\\n     * @param percentA proportion of the exposition of the original tokenA that want to be removed\\n     * @param percentB proportion of the exposition of the original tokenB that want to be removed\\n     */\\n    function _removeLiquidity(uint256 percentA, uint256 percentB) internal {\\n        (uint256 userTokenABalance, uint256 userTokenBBalance, uint256 userFImp) = _getUserDepositSnapshot(msg.sender);\\n        require(percentA <= 100 && percentB <= 100, \\\"AMM: forbidden percent\\\");\\n\\n        uint256 originalBalanceAToReduce = percentA.mul(userTokenABalance).div(PERCENT_PRECISION);\\n        uint256 originalBalanceBToReduce = percentB.mul(userTokenBBalance).div(PERCENT_PRECISION);\\n\\n        // Get Pool Balances\\n        (uint256 totalTokenA, uint256 totalTokenB) = _getPoolBalances();\\n\\n        // Get ABPrice\\n        uint256 ABPrice = _getABPrice();\\n\\n        // Calculate the Pool's Value Factor (Fimp)\\n        uint256 fImpOpening = _getFImpOpening(\\n            totalTokenA,\\n            totalTokenB,\\n            ABPrice,\\n            deamortizedTokenABalance,\\n            deamortizedTokenBBalance\\n        );\\n\\n        // Calculate Multipliers\\n        Mult memory multipliers = _getMultipliers(totalTokenA, totalTokenB, fImpOpening);\\n\\n        // Update User balance\\n        _userSnapshots[msg.sender].tokenABalance = userTokenABalance.sub(originalBalanceAToReduce);\\n        _userSnapshots[msg.sender].tokenBBalance = userTokenBBalance.sub(originalBalanceBToReduce);\\n\\n        // Update deamortized balance\\n        deamortizedTokenABalance = deamortizedTokenABalance.sub(\\n            originalBalanceAToReduce.mul(10**FIMP_DECIMALS).div(userFImp)\\n        );\\n        deamortizedTokenBBalance = deamortizedTokenBBalance.sub(\\n            originalBalanceBToReduce.mul(10**FIMP_DECIMALS).div(userFImp)\\n        );\\n\\n        // Calculate amount to send\\n        (uint256 withdrawAmountA, uint256 withdrawAmountB) = _getWithdrawAmounts(\\n            originalBalanceAToReduce,\\n            originalBalanceBToReduce,\\n            userFImp,\\n            multipliers\\n        );\\n\\n        if (withdrawAmountA > totalTokenA) {\\n            withdrawAmountA = totalTokenA;\\n        }\\n\\n        if (withdrawAmountB > totalTokenB) {\\n            withdrawAmountB = totalTokenB;\\n        }\\n\\n        _onRemoveLiquidity(percentA, percentB, msg.sender);\\n\\n        // Transfers / Update\\n        if (withdrawAmountA > 0) {\\n            IERC20(_tokenA).safeTransfer(msg.sender, withdrawAmountA);\\n        }\\n\\n        if (withdrawAmountB > 0) {\\n            IERC20(_tokenB).safeTransfer(msg.sender, withdrawAmountB);\\n        }\\n\\n        emit RemoveLiquidity(msg.sender, withdrawAmountA, withdrawAmountB);\\n    }\\n\\n    /**\\n     * @notice _tradeExactAInput msg.sender is able to trade exact amount of token A in exchange for minimum\\n     * amount of token B sent by the contract to the owner\\n     * @dev The inheritor contract should implement _getTradeDetailsExactAInput and _onTradeExactAInput functions\\n     * _getTradeDetailsExactAInput should return tradeDetails struct format\\n     *\\n     * @param exactAmountAIn exact amount of A token that will be transfer from msg.sender\\n     * @param minAmountBOut minimum acceptable amount of token B to transfer to owner\\n     * @param owner the destination address that will receive the token B\\n     */\\n    function _tradeExactAInput(\\n        uint256 exactAmountAIn,\\n        uint256 minAmountBOut,\\n        address owner\\n    ) internal returns (uint256) {\\n        _isValidInput(exactAmountAIn);\\n        _isValidAddress(owner);\\n        TradeDetails memory tradeDetails = _getTradeDetailsExactAInput(exactAmountAIn);\\n        uint256 amountBOut = tradeDetails.amount;\\n        require(amountBOut > 0, \\\"AMM: invalid amountBOut\\\");\\n        require(amountBOut >= minAmountBOut, \\\"AMM: slippage not acceptable\\\");\\n\\n        _onTrade(tradeDetails);\\n\\n        IERC20(_tokenA).safeTransferFrom(msg.sender, address(this), exactAmountAIn);\\n        IERC20(_tokenB).safeTransfer(owner, amountBOut);\\n\\n        emit TradeExactAInput(msg.sender, owner, exactAmountAIn, amountBOut);\\n        return amountBOut;\\n    }\\n\\n    /**\\n     * @notice _tradeExactAOutput owner is able to receive exact amount of token A in exchange of a max\\n     * acceptable amount of token B sent by the msg.sender to the contract\\n     *\\n     * @dev The inheritor contract should implement _getTradeDetailsExactAOutput and _onTradeExactAOutput functions\\n     * _getTradeDetailsExactAOutput should return tradeDetails struct format\\n     *\\n     * @param exactAmountAOut exact amount of token A that will be transfer to owner\\n     * @param maxAmountBIn maximum acceptable amount of token B to transfer from msg.sender\\n     * @param owner the destination address that will receive the token A\\n     */\\n    function _tradeExactAOutput(\\n        uint256 exactAmountAOut,\\n        uint256 maxAmountBIn,\\n        address owner\\n    ) internal returns (uint256) {\\n        _isValidInput(maxAmountBIn);\\n        _isValidAddress(owner);\\n        TradeDetails memory tradeDetails = _getTradeDetailsExactAOutput(exactAmountAOut);\\n        uint256 amountBIn = tradeDetails.amount;\\n        require(amountBIn > 0, \\\"AMM: invalid amountBIn\\\");\\n        require(amountBIn <= maxAmountBIn, \\\"AMM: slippage not acceptable\\\");\\n        _onTrade(tradeDetails);\\n\\n        IERC20(_tokenB).safeTransferFrom(msg.sender, address(this), amountBIn);\\n        IERC20(_tokenA).safeTransfer(owner, exactAmountAOut);\\n\\n        emit TradeExactAOutput(msg.sender, owner, amountBIn, exactAmountAOut);\\n        return amountBIn;\\n    }\\n\\n    /**\\n     * @notice _tradeExactBInput msg.sender is able to trade exact amount of token B in exchange for minimum\\n     * amount of token A sent by the contract to the owner\\n     *\\n     * @dev The inheritor contract should implement _getTradeDetailsExactBInput and _onTradeExactBInput functions\\n     * _getTradeDetailsExactBInput should return tradeDetails struct format\\n     *\\n     * @param exactAmountBIn exact amount of token B that will be transfer from msg.sender\\n     * @param minAmountAOut minimum acceptable amount of token A to transfer to owner\\n     * @param owner the destination address that will receive the token A\\n     */\\n    function _tradeExactBInput(\\n        uint256 exactAmountBIn,\\n        uint256 minAmountAOut,\\n        address owner\\n    ) internal returns (uint256) {\\n        _isValidInput(exactAmountBIn);\\n        _isValidAddress(owner);\\n        TradeDetails memory tradeDetails = _getTradeDetailsExactBInput(exactAmountBIn);\\n        uint256 amountAOut = tradeDetails.amount;\\n        require(amountAOut > 0, \\\"AMM: invalid amountAOut\\\");\\n        require(amountAOut >= minAmountAOut, \\\"AMM: slippage not acceptable\\\");\\n\\n        _onTrade(tradeDetails);\\n\\n        IERC20(_tokenB).safeTransferFrom(msg.sender, address(this), exactAmountBIn);\\n        IERC20(_tokenA).safeTransfer(owner, amountAOut);\\n\\n        emit TradeExactBInput(msg.sender, owner, exactAmountBIn, amountAOut);\\n        return amountAOut;\\n    }\\n\\n    /**\\n     * @notice _tradeExactBOutput owner is able to receive exact amount of token B from the contract in exchange of a\\n     * max acceptable amount of token A sent by the msg.sender to the contract.\\n     *\\n     * @dev The inheritor contract should implement _getTradeDetailsExactBOutput and _onTradeExactBOutput functions\\n     * _getTradeDetailsExactBOutput should return tradeDetails struct format\\n     *\\n     * @param exactAmountBOut exact amount of token B that will be transfer to owner\\n     * @param maxAmountAIn maximum acceptable amount of token A to transfer from msg.sender\\n     * @param owner the destination address that will receive the token B\\n     */\\n    function _tradeExactBOutput(\\n        uint256 exactAmountBOut,\\n        uint256 maxAmountAIn,\\n        address owner\\n    ) internal returns (uint256) {\\n        _isValidInput(maxAmountAIn);\\n        _isValidAddress(owner);\\n        TradeDetails memory tradeDetails = _getTradeDetailsExactBOutput(exactAmountBOut);\\n        uint256 amountAIn = tradeDetails.amount;\\n        require(amountAIn > 0, \\\"AMM: invalid amountAIn\\\");\\n        require(amountAIn <= maxAmountAIn, \\\"AMM: slippage not acceptable\\\");\\n\\n        _onTrade(tradeDetails);\\n\\n        IERC20(_tokenA).safeTransferFrom(msg.sender, address(this), amountAIn);\\n        IERC20(_tokenB).safeTransfer(owner, exactAmountBOut);\\n\\n        emit TradeExactBOutput(msg.sender, owner, amountAIn, exactAmountBOut);\\n        return amountAIn;\\n    }\\n\\n    /**\\n     * @notice _getFImpOpening Auxiliary function that calculate the Opening Value Factor Fimp\\n     *\\n     * @param _totalTokenA total contract balance of token A\\n     * @param _totalTokenB total contract balance of token B\\n     * @param _ABPrice Unit price AB, meaning, how many units of token B could buy 1 unit of token A\\n     * @param _deamortizedTokenABalance contract deamortized balance of token A\\n     * @param _deamortizedTokenBBalance contract deamortized balance of token B\\n     * @return fImpOpening Opening Value Factor Fimp\\n     */\\n    function _getFImpOpening(\\n        uint256 _totalTokenA,\\n        uint256 _totalTokenB,\\n        uint256 _ABPrice,\\n        uint256 _deamortizedTokenABalance,\\n        uint256 _deamortizedTokenBBalance\\n    ) internal view returns (uint256) {\\n        uint256 numerator;\\n        uint256 denominator;\\n        {\\n            numerator = _totalTokenA.mul(_ABPrice).div(10**uint256(_tokenADecimals)).add(_totalTokenB).mul(\\n                10**FIMP_DECIMALS\\n            );\\n        }\\n        {\\n            denominator = _deamortizedTokenABalance.mul(_ABPrice).div(10**uint256(_tokenADecimals)).add(\\n                _deamortizedTokenBBalance\\n            );\\n        }\\n\\n        return numerator.div(denominator);\\n    }\\n\\n    /**\\n     * @notice _getPoolBalances external function that returns the current pool balance of token A and token B\\n     *\\n     * @return totalTokenA balanceOf this contract of token A\\n     * @return totalTokenB balanceOf this contract of token B\\n     */\\n    function _getPoolBalances() internal view returns (uint256 totalTokenA, uint256 totalTokenB) {\\n        totalTokenA = IERC20(_tokenA).balanceOf(address(this));\\n        totalTokenB = IERC20(_tokenB).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @notice _getUserDepositSnapshot internal function that User original balance of token A,\\n     * token B and the Opening Value * * Factor (Fimp) at the moment of the liquidity added\\n     *\\n     * @param user address of the user that want to check the balance\\n     *\\n     * @return tokenAOriginalBalance balance of token A by the moment of deposit\\n     * @return tokenBOriginalBalance balance of token B by the moment of deposit\\n     * @return fImpOriginal value of the Opening Value Factor by the moment of the deposit\\n     */\\n    function _getUserDepositSnapshot(address user)\\n        internal\\n        view\\n        returns (\\n            uint256 tokenAOriginalBalance,\\n            uint256 tokenBOriginalBalance,\\n            uint256 fImpOriginal\\n        )\\n    {\\n        tokenAOriginalBalance = _userSnapshots[user].tokenABalance;\\n        tokenBOriginalBalance = _userSnapshots[user].tokenBBalance;\\n        fImpOriginal = _userSnapshots[user].fImp;\\n    }\\n\\n    /**\\n     * @notice _getMultipliers internal function that calculate new multipliers based on the current pool position\\n     *\\n     * mAA => How much A the users can rescue for each A they deposited\\n     * mBA => How much A the users can rescue for each B they deposited\\n     * mBB => How much B the users can rescue for each B they deposited\\n     * mAB => How much B the users can rescue for each A they deposited\\n     *\\n     * @param totalTokenA balanceOf this contract of token A\\n     * @param totalTokenB balanceOf this contract of token B\\n     * @param fImpOpening current Open Value Factor\\n     * @return multipliers multiplier struct containing the 4 multipliers: mAA, mBA, mBB, mAB\\n     */\\n    function _getMultipliers(\\n        uint256 totalTokenA,\\n        uint256 totalTokenB,\\n        uint256 fImpOpening\\n    ) internal view returns (Mult memory multipliers) {\\n        uint256 totalTokenAWithPrecision = totalTokenA.mul(10**FIMP_DECIMALS);\\n        uint256 totalTokenBWithPrecision = totalTokenB.mul(10**FIMP_DECIMALS);\\n        uint256 mAA = 0;\\n        uint256 mBB = 0;\\n        uint256 mAB = 0;\\n        uint256 mBA = 0;\\n\\n        if (deamortizedTokenABalance > 0) {\\n            mAA = (_min(deamortizedTokenABalance.mul(fImpOpening), totalTokenAWithPrecision)).div(\\n                deamortizedTokenABalance\\n            );\\n        }\\n\\n        if (deamortizedTokenBBalance > 0) {\\n            mBB = (_min(deamortizedTokenBBalance.mul(fImpOpening), totalTokenBWithPrecision)).div(\\n                deamortizedTokenBBalance\\n            );\\n        }\\n        if (mAA > 0) {\\n            mAB = totalTokenBWithPrecision.sub(mBB.mul(deamortizedTokenBBalance)).div(deamortizedTokenABalance);\\n        }\\n\\n        if (mBB > 0) {\\n            mBA = totalTokenAWithPrecision.sub(mAA.mul(deamortizedTokenABalance)).div(deamortizedTokenBBalance);\\n        }\\n\\n        multipliers = Mult(mAA, mAB, mBA, mBB);\\n    }\\n\\n    /**\\n     * @notice _getRemoveLiquidityAmounts internal function of getRemoveLiquidityAmounts\\n     *\\n     * @param percentA percent of exposition A to be removed\\n     * @param percentB percent of exposition B to be removed\\n     * @param user address of the account that will be removed\\n     *\\n     * @return withdrawAmountA amount of token A that will be rescued\\n     * @return withdrawAmountB amount of token B that will be rescued\\n     */\\n    function _getRemoveLiquidityAmounts(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address user\\n    ) internal view returns (uint256 withdrawAmountA, uint256 withdrawAmountB) {\\n        (uint256 totalTokenA, uint256 totalTokenB) = _getPoolBalances();\\n        (uint256 originalBalanceTokenA, uint256 originalBalanceTokenB, uint256 fImpOriginal) = _getUserDepositSnapshot(\\n            user\\n        );\\n\\n        uint256 originalBalanceAToReduce = percentA.mul(originalBalanceTokenA).div(PERCENT_PRECISION);\\n        uint256 originalBalanceBToReduce = percentB.mul(originalBalanceTokenB).div(PERCENT_PRECISION);\\n\\n        bool hasNoLiquidity = totalTokenA == 0 && totalTokenB == 0;\\n        if (hasNoLiquidity) {\\n            return (0, 0);\\n        }\\n\\n        uint256 ABPrice = _getABPrice();\\n        uint256 fImpOpening = _getFImpOpening(\\n            totalTokenA,\\n            totalTokenB,\\n            ABPrice,\\n            deamortizedTokenABalance,\\n            deamortizedTokenBBalance\\n        );\\n\\n        Mult memory multipliers = _getMultipliers(totalTokenA, totalTokenB, fImpOpening);\\n\\n        (withdrawAmountA, withdrawAmountB) = _getWithdrawAmounts(\\n            originalBalanceAToReduce,\\n            originalBalanceBToReduce,\\n            fImpOriginal,\\n            multipliers\\n        );\\n    }\\n\\n    /**\\n     * @notice _getWithdrawAmounts internal function of getRemoveLiquidityAmounts\\n     *\\n     * @param _originalBalanceAToReduce amount of original deposit of the token A\\n     * @param _originalBalanceBToReduce amount of original deposit of the token B\\n     * @param _userFImp Opening Value Factor by the moment of the deposit\\n     *\\n     * @return withdrawAmountA amount of token A that will be rescued\\n     * @return withdrawAmountB amount of token B that will be rescued\\n     */\\n    function _getWithdrawAmounts(\\n        uint256 _originalBalanceAToReduce,\\n        uint256 _originalBalanceBToReduce,\\n        uint256 _userFImp,\\n        Mult memory multipliers\\n    ) internal pure returns (uint256 withdrawAmountA, uint256 withdrawAmountB) {\\n        if (_userFImp > 0) {\\n            withdrawAmountA = _originalBalanceAToReduce\\n                .mul(multipliers.AA)\\n                .add(_originalBalanceBToReduce.mul(multipliers.BA))\\n                .div(_userFImp);\\n            withdrawAmountB = _originalBalanceBToReduce\\n                .mul(multipliers.BB)\\n                .add(_originalBalanceAToReduce.mul(multipliers.AB))\\n                .div(_userFImp);\\n        }\\n        return (withdrawAmountA, withdrawAmountB);\\n    }\\n\\n    /**\\n     * @notice _getUserBalanceToStore internal auxiliary function to help calculation the\\n     * tokenA and tokenB value that should be stored in UserDepositSnapshot struct\\n     *\\n     * @param amountOfA current deposit of the token A\\n     * @param amountOfB current deposit of the token B\\n     * @param fImpOpening Opening Value Factor by the moment of the deposit\\n     *\\n     * @return userToStoreTokenA amount of token A that will be stored\\n     * @return userToStoreTokenB amount of token B that will be stored\\n     */\\n    function _getUserBalanceToStore(\\n        uint256 amountOfA,\\n        uint256 amountOfB,\\n        uint256 fImpOpening,\\n        UserDepositSnapshot memory userDepositSnapshot\\n    ) internal pure returns (uint256 userToStoreTokenA, uint256 userToStoreTokenB) {\\n        userToStoreTokenA = amountOfA;\\n        userToStoreTokenB = amountOfB;\\n\\n        //Re-add Liquidity case\\n        if (userDepositSnapshot.fImp != 0) {\\n            userToStoreTokenA = userDepositSnapshot.tokenABalance.mul(fImpOpening).div(userDepositSnapshot.fImp).add(\\n                amountOfA\\n            );\\n            userToStoreTokenB = userDepositSnapshot.tokenBBalance.mul(fImpOpening).div(userDepositSnapshot.fImp).add(\\n                amountOfB\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function _getABPrice() internal virtual view returns (uint256 ABPrice);\\n\\n    function _getTradeDetailsExactAInput(uint256 amountAIn) internal virtual returns (TradeDetails memory);\\n\\n    function _getTradeDetailsExactAOutput(uint256 amountAOut) internal virtual returns (TradeDetails memory);\\n\\n    function _getTradeDetailsExactBInput(uint256 amountBIn) internal virtual returns (TradeDetails memory);\\n\\n    function _getTradeDetailsExactBOutput(uint256 amountBOut) internal virtual returns (TradeDetails memory);\\n\\n    function _onTrade(TradeDetails memory tradeDetails) internal virtual;\\n\\n    function _onRemoveLiquidity(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address owner\\n    ) internal virtual;\\n\\n    function _onAddLiquidity(UserDepositSnapshot memory userDepositSnapshot, address owner) internal virtual;\\n\\n    function _isValidAddress(address recipient) private pure {\\n        require(recipient != address(0), \\\"AMM: transfer to zero address\\\");\\n    }\\n\\n    function _isValidInput(uint256 input) private pure {\\n        require(input > 0, \\\"AMM: input should be greater than zero\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CappedPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IConfigurationManager.sol\\\";\\nimport \\\"../interfaces/ICapProvider.sol\\\";\\n\\n/**\\n * @title CappedPool\\n * @author Pods Finance\\n *\\n * @notice Controls a maximum cap for a guarded release\\n */\\nabstract contract CappedPool {\\n    using SafeMath for uint256;\\n\\n    IConfigurationManager private immutable _configurationManager;\\n\\n    constructor(IConfigurationManager configurationManager) public {\\n        _configurationManager = configurationManager;\\n    }\\n\\n    /**\\n     * @dev Modifier to stop transactions that exceed the cap\\n     */\\n    modifier capped(address token, uint256 amountOfLiquidity) {\\n        uint256 cap = capSize();\\n\\n        if (cap > 0) {\\n            uint256 poolBalance = IERC20(token).balanceOf(address(this));\\n            require(poolBalance.add(amountOfLiquidity) <= cap, \\\"CappedPool: amount exceed cap\\\");\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Get the cap size\\n     */\\n    function capSize() public view returns (uint256) {\\n        ICapProvider capProvider = ICapProvider(_configurationManager.getCapProvider());\\n        return capProvider.getCap(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CombinedActionsGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ncontract CombinedActionsGuard {\\n    mapping(address => uint256) sessions;\\n\\n    /**\\n     * @dev Prevents an address from calling more than one function that contains this\\n     * function in the same block\\n     */\\n    function _nonCombinedActions() internal {\\n        require(sessions[tx.origin] != block.number, \\\"CombinedActionsGuard: reentrant call\\\");\\n        sessions[tx.origin] = block.number;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IPriceProvider {\\n    function setAssetFeeds(address[] memory _assets, address[] memory _feeds) external;\\n\\n    function updateAssetFeeds(address[] memory _assets, address[] memory _feeds) external;\\n\\n    function removeAssetFeeds(address[] memory _assets) external;\\n\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n\\n    function getAssetDecimals(address _asset) external view returns (uint8);\\n\\n    function latestRoundData(address _asset)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function getPriceFeed(address _asset) external view returns (address);\\n\\n    function updateMinUpdateInterval() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIVProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IIVProvider {\\n    struct IVData {\\n        uint256 roundId;\\n        uint256 updatedAt;\\n        uint256 answer;\\n        uint8 decimals;\\n    }\\n\\n    event UpdatedIV(address indexed option, uint256 roundId, uint256 updatedAt, uint256 answer, uint8 decimals);\\n    event UpdaterSet(address indexed admin, address indexed updater);\\n\\n    function getIV(address option)\\n        external\\n        view\\n        returns (\\n            uint256 roundId,\\n            uint256 updatedAt,\\n            uint256 answer,\\n            uint8 decimals\\n        );\\n\\n    function updateIV(\\n        address option,\\n        uint256 answer,\\n        uint8 decimals\\n    ) external;\\n\\n    function setUpdater(address updater) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBlackScholes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity >=0.6.12;\\n\\ninterface IBlackScholes {\\n    function getCallPrice(\\n        uint256 spotPrice,\\n        uint256 strikePrice,\\n        uint256 sigma,\\n        uint256 time,\\n        int256 riskFree\\n    ) external view returns (uint256);\\n\\n    function getPutPrice(\\n        uint256 spotPrice,\\n        uint256 strikePrice,\\n        uint256 sigma,\\n        uint256 time,\\n        int256 riskFree\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIVGuesser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IIVGuesser {\\n    function blackScholes() external view returns (address);\\n\\n    function getPutIV(\\n        uint256 _targetPrice,\\n        uint256 _initialIVGuess,\\n        uint256 _spotPrice,\\n        uint256 _strikePrice,\\n        uint256 _timeToMaturity,\\n        int256 _riskFree\\n    ) external view returns (uint256, uint256);\\n\\n    function getCallIV(\\n        uint256 _targetPrice,\\n        uint256 _initialIVGuess,\\n        uint256 _spotPrice,\\n        uint256 _strikePrice,\\n        uint256 _timeToMaturity,\\n        int256 _riskFree\\n    ) external view returns (uint256, uint256);\\n\\n    function updateAcceptableRange() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPodOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPodOption is IERC20 {\\n    /** Enums */\\n    // @dev 0 for Put, 1 for Call\\n    enum OptionType { PUT, CALL }\\n    // @dev 0 for European, 1 for American\\n    enum ExerciseType { EUROPEAN, AMERICAN }\\n\\n    /** Events */\\n    event Mint(address indexed minter, uint256 amount);\\n    event Unmint(address indexed minter, uint256 optionAmount, uint256 strikeAmount, uint256 underlyingAmount);\\n    event Exercise(address indexed exerciser, uint256 amount);\\n    event Withdraw(address indexed minter, uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    /** Functions */\\n\\n    /**\\n     * @notice Locks collateral and write option tokens.\\n     *\\n     * @dev The issued amount ratio is 1:1, i.e., 1 option token for 1 underlying token.\\n     *\\n     * The collateral could be the strike or the underlying asset depending on the option type: Put or Call,\\n     * respectively\\n     *\\n     * It presumes the caller has already called IERC20.approve() on the\\n     * strike/underlying token contract to move caller funds.\\n     *\\n     * Options can only be minted while the series is NOT expired.\\n     *\\n     * It is also important to notice that options will be sent back\\n     * to `msg.sender` and not the `owner`. This behavior is designed to allow\\n     * proxy contracts to mint on others behalf. The `owner` will be able to remove\\n     * the deposited collateral after series expiration or by calling unmint(), even\\n     * if a third-party minted options on its behalf.\\n     *\\n     * @param amountOfOptions The amount option tokens to be issued\\n     * @param owner Which address will be the owner of the options\\n     */\\n    function mint(uint256 amountOfOptions, address owner) external;\\n\\n    /**\\n     * @notice Allow option token holders to use them to exercise the amount of units\\n     * of the locked tokens for the equivalent amount of the exercisable assets.\\n     *\\n     * @dev It presumes the caller has already called IERC20.approve() exercisable asset\\n     * to move caller funds.\\n     *\\n     * On American options, this function can only called anytime before expiration.\\n     * For European options, this function can only be called during the exerciseWindow.\\n     * Meaning, after expiration and before the end of exercise window.\\n     *\\n     * @param amountOfOptions The amount option tokens to be exercised\\n     */\\n    function exercise(uint256 amountOfOptions) external;\\n\\n    /**\\n     * @notice After series expiration in case of American or after exercise window for European,\\n     * allow minters who have locked their collateral to withdraw them proportionally\\n     * to their minted options.\\n     *\\n     * @dev If assets had been exercised during the option series the minter may withdraw\\n     * the exercised assets or a combination of exercised and collateral.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Unlocks collateral by burning option tokens.\\n     *\\n     * Options can only be burned while the series is NOT expired.\\n     *\\n     * @param amountOfOptions The amount option tokens to be burned\\n     */\\n    function unmint(uint256 amountOfOptions) external;\\n\\n    function optionType() external view returns (OptionType);\\n\\n    function exerciseType() external view returns (ExerciseType);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function underlyingAssetDecimals() external view returns (uint8);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function strikeAssetDecimals() external view returns (uint8);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function strikePriceDecimals() external view returns (uint8);\\n\\n    function expiration() external view returns (uint256);\\n\\n    function startOfExerciseWindow() external view returns (uint256);\\n\\n    function hasExpired() external view returns (bool);\\n\\n    function isTradeWindow() external view returns (bool);\\n\\n    function isExerciseWindow() external view returns (bool);\\n\\n    function isWithdrawWindow() external view returns (bool);\\n\\n    function strikeToTransfer(uint256 amountOfOptions) external view returns (uint256);\\n\\n    function getSellerWithdrawAmounts(address owner)\\n        external\\n        view\\n        returns (uint256 strikeAmount, uint256 underlyingAmount);\\n\\n    function underlyingReserves() external view returns (uint256);\\n\\n    function strikeReserves() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptionAMMPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IAMM.sol\\\";\\n\\ninterface IOptionAMMPool is IAMM {\\n    // @dev 0 for when tokenA enter the pool and B leaving (A -> B)\\n    // and 1 for the opposite direction\\n    enum TradeDirection { AB, BA }\\n\\n    function tradeExactAInput(\\n        uint256 exactAmountAIn,\\n        uint256 minAmountBOut,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function tradeExactAOutput(\\n        uint256 exactAmountAOut,\\n        uint256 maxAmountBIn,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function tradeExactBInput(\\n        uint256 exactAmountBIn,\\n        uint256 minAmountAOut,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function tradeExactBOutput(\\n        uint256 exactAmountBOut,\\n        uint256 maxAmountAIn,\\n        address owner,\\n        uint256 sigmaInitialGuess\\n    ) external returns (uint256);\\n\\n    function getOptionTradeDetailsExactAInput(uint256 exactAmountAIn)\\n        external\\n        view\\n        returns (\\n            uint256 amountBOutput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getOptionTradeDetailsExactAOutput(uint256 exactAmountAOut)\\n        external\\n        view\\n        returns (\\n            uint256 amountBInput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getOptionTradeDetailsExactBInput(uint256 exactAmountBIn)\\n        external\\n        view\\n        returns (\\n            uint256 amountAOutput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getOptionTradeDetailsExactBOutput(uint256 exactAmountBOut)\\n        external\\n        view\\n        returns (\\n            uint256 amountAInput,\\n            uint256 newSigma,\\n            uint256 feesTokenA,\\n            uint256 feesTokenB\\n        );\\n\\n    function getRemoveLiquidityAmounts(\\n        uint256 percentA,\\n        uint256 percentB,\\n        address user\\n    ) external view returns (uint256 withdrawAmountA, uint256 withdrawAmountB);\\n\\n    function getABPrice() external view returns (uint256);\\n\\n    function getAdjustedIV() external view returns (uint256);\\n\\n    function withdrawRewards() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IFeePool {\\n    struct Balance {\\n        uint256 shares;\\n        uint256 liability;\\n    }\\n\\n    function setFee(uint256 feeBaseValue, uint8 decimals) external;\\n\\n    function withdraw(address to, uint256 amount) external;\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function feeToken() external view returns (address);\\n\\n    function feeValue() external view returns (uint256);\\n\\n    function feeDecimals() external view returns (uint8);\\n\\n    function getCollectable(uint256 amount, uint256 poolAmount) external view returns (uint256);\\n\\n    function sharesOf(address owner) external view returns (uint256);\\n\\n    function getWithdrawAmount(address owner, uint256 amountOfShares) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConfigurationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity >=0.6.12;\\n\\ninterface IConfigurationManager {\\n    function setParameter(bytes32 name, uint256 value) external;\\n\\n    function setEmergencyStop(address emergencyStop) external;\\n\\n    function setPricingMethod(address pricingMethod) external;\\n\\n    function setIVGuesser(address ivGuesser) external;\\n\\n    function setIVProvider(address ivProvider) external;\\n\\n    function setPriceProvider(address priceProvider) external;\\n\\n    function setCapProvider(address capProvider) external;\\n\\n    function setAMMFactory(address ammFactory) external;\\n\\n    function setOptionFactory(address optionFactory) external;\\n\\n    function setOptionHelper(address optionHelper) external;\\n\\n    function setOptionPoolRegistry(address optionPoolRegistry) external;\\n\\n    function getParameter(bytes32 name) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function getEmergencyStop() external view returns (address);\\n\\n    function getPricingMethod() external view returns (address);\\n\\n    function getIVGuesser() external view returns (address);\\n\\n    function getIVProvider() external view returns (address);\\n\\n    function getPriceProvider() external view returns (address);\\n\\n    function getCapProvider() external view returns (address);\\n\\n    function getAMMFactory() external view returns (address);\\n\\n    function getOptionFactory() external view returns (address);\\n\\n    function getOptionHelper() external view returns (address);\\n\\n    function getOptionPoolRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEmergencyStop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IEmergencyStop {\\n    function stop(address target) external;\\n\\n    function resume(address target) external;\\n\\n    function isStopped(address target) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeePoolBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IFeePool.sol\\\";\\n\\ninterface IFeePoolBuilder {\\n    function buildFeePool(\\n        address asset,\\n        uint256 feeBaseValue,\\n        uint8 feeDecimals,\\n        address owner\\n    ) external returns (IFeePool);\\n}\\n\"\r\n    },\r\n    \"contracts/options/rewards/AaveIncentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../interfaces/IAaveIncentivesController.sol\\\";\\nimport \\\"../../interfaces/IConfigurationManager.sol\\\";\\nimport \\\"../../lib/Conversion.sol\\\";\\n\\nabstract contract AaveIncentives is Conversion {\\n    address public immutable rewardAsset;\\n    address public immutable rewardContract;\\n\\n    event RewardsClaimed(address indexed claimer, uint256 rewardAmount);\\n\\n    constructor(IConfigurationManager configurationManager) public {\\n        rewardAsset = _parseAddressFromUint(configurationManager.getParameter(\\\"REWARD_ASSET\\\"));\\n        rewardContract = _parseAddressFromUint(configurationManager.getParameter(\\\"REWARD_CONTRACT\\\"));\\n    }\\n\\n    /**\\n     * @notice Gets the current reward claimed\\n     */\\n    function _rewardBalance() internal view returns (uint256) {\\n        return IERC20(rewardAsset).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @notice Claim pending rewards\\n     */\\n    function _claimRewards(address[] memory assets) internal {\\n        IAaveIncentivesController distributor = IAaveIncentivesController(rewardContract);\\n        uint256 amountToClaim = distributor.getRewardsBalance(assets, address(this));\\n        distributor.claimRewards(assets, amountToClaim, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RequiredDecimals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract RequiredDecimals {\\n    uint256 private constant _MAX_TOKEN_DECIMALS = 38;\\n\\n    /**\\n     * Tries to fetch the decimals of a token, if not existent, fails with a require statement\\n     *\\n     * @param token An instance of IERC20\\n     * @return The decimals of a token\\n     */\\n    function tryDecimals(IERC20 token) internal view returns (uint8) {\\n        // solhint-disable-line private-vars-leading-underscore\\n        bytes memory payload = abi.encodeWithSignature(\\\"decimals()\\\");\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory returnData) = address(token).staticcall(payload);\\n\\n        require(success, \\\"RequiredDecimals: required decimals\\\");\\n        uint8 decimals = abi.decode(returnData, (uint8));\\n        require(decimals < _MAX_TOKEN_DECIMALS, \\\"RequiredDecimals: token decimals should be lower than 38\\\");\\n\\n        return decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IAMM {\\n    function addLiquidity(\\n        uint256 amountOfA,\\n        uint256 amountOfB,\\n        address owner\\n    ) external;\\n\\n    function removeLiquidity(uint256 amountOfA, uint256 amountOfB) external;\\n\\n    function tokenA() external view returns (address);\\n\\n    function tokenB() external view returns (address);\\n\\n    function tokenADecimals() external view returns (uint8);\\n\\n    function tokenBDecimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICapProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface ICapProvider {\\n    function setCap(address target, uint256 value) external;\\n\\n    function getCap(address target) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ninterface IAaveIncentivesController {\\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\\n\\n    function claimRewards(\\n        address[] calldata assets,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Conversion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.6.12;\\n\\ncontract Conversion {\\n    /**\\n     * @notice Parses the address represented by an uint\\n     */\\n    function _parseAddressFromUint(uint256 x) internal pure returns (address) {\\n        bytes memory data = new bytes(32);\\n        assembly {\\n            mstore(add(data, 32), x)\\n        }\\n        return abi.decode(data, (address));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_optionAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stableAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialIV\",\"type\":\"uint256\"},{\"internalType\":\"contract IConfigurationManager\",\"name\":\"_configurationManager\",\"type\":\"address\"},{\"internalType\":\"contract IFeePoolBuilder\",\"name\":\"_feePoolBuilder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exactAmountAIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOut\",\"type\":\"uint256\"}],\"name\":\"TradeExactAInput\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exactAmountAOut\",\"type\":\"uint256\"}],\"name\":\"TradeExactAOutput\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exactAmountBIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAOut\",\"type\":\"uint256\"}],\"name\":\"TradeExactBInput\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exactAmountBOut\",\"type\":\"uint256\"}],\"name\":\"TradeExactBOutput\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newIV\",\"type\":\"uint256\"}],\"name\":\"TradeInfo\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FIMP_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_FIMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICING_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfB\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configurationManager\",\"outputs\":[{\"internalType\":\"contract IConfigurationManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deamortizedTokenABalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deamortizedTokenBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePoolA\",\"outputs\":[{\"internalType\":\"contract IFeePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePoolB\",\"outputs\":[{\"internalType\":\"contract IFeePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getABPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ABPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdjustedIV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustedIV\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountAIn\",\"type\":\"uint256\"}],\"name\":\"getOptionTradeDetailsExactAInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newIV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountAOut\",\"type\":\"uint256\"}],\"name\":\"getOptionTradeDetailsExactAOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newIV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountBIn\",\"type\":\"uint256\"}],\"name\":\"getOptionTradeDetailsExactBInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newIV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountBOut\",\"type\":\"uint256\"}],\"name\":\"getOptionTradeDetailsExactBOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newIV\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesTokenB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTokenA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokenB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentB\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRemoveLiquidityAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDepositSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAOriginalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBOriginalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fImpUser\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceProperties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startOfExerciseWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"enum IPodOption.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"currentIV\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"riskFree\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfB\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenADecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountAIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountBOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"tradeExactAInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountAOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountBIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"tradeExactAOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountBIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountAOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"tradeExactBInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exactAmountBOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountAIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialIVGuess\",\"type\":\"uint256\"}],\"name\":\"tradeExactBOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OptionAMMPool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008b905a68e6cd53ec0af1bb27c9b4df5b192ba778000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000001bc16d674ec80000000000000000000000000000e4da64757b2b29db43429a52caf7ad884c76f8b0000000000000000000000000e7c94d68c5f7656a6f7373f588aaf6483cc9e497","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}