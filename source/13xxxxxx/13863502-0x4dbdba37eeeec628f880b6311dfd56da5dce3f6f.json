{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/pirate/Fleet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\n\\r\\n\\r\\nimport \\\"./interfaces/IPnG.sol\\\";\\r\\nimport \\\"./interfaces/ICACAO.sol\\\";\\r\\nimport \\\"./interfaces/IFleet.sol\\\";\\r\\nimport \\\"./interfaces/IRandomizer.sol\\\";\\r\\n\\r\\nimport \\\"./utils/Accessable.sol\\\";\\r\\n\\r\\n\\r\\ncontract Fleet is IFleet, Accessable, ReentrancyGuard, IERC721Receiver, Pausable {\\r\\n    uint8[4] private _ranks = [5,6,7,8];\\r\\n    \\r\\n    // struct to store a stake's token, owner, and earning values\\r\\n    struct Stake {\\r\\n        uint16 tokenId;\\r\\n        uint80 value;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    uint256 private totalRankStaked;\\r\\n    uint256 private numGalleonsStaked;\\r\\n\\r\\n    event TokenStaked(address indexed owner, uint256 indexed tokenId, bool indexed isGalleon, uint256 value);\\r\\n    event GalleonClaimed(uint256 indexed tokenId, bool indexed unstaked, uint256 earned);\\r\\n    event PirateClaimed(uint256 indexed tokenId, bool indexed unstaked, uint256 earned);\\r\\n\\r\\n    IPnG public nftContract;\\r\\n    // reference to the WnD NFT contract\\r\\n    address public pirateGame;\\r\\n    // reference to the $CACAO contract for minting $CACAO earnings\\r\\n    ICACAO public cacao;\\r\\n    // reference to Randomer \\r\\n    IRandomizer public randomizer;\\r\\n\\r\\n    // maps tokenId to stake\\r\\n    mapping(uint256 => Stake) private fleet; \\r\\n    // maps rank to all Pirate staked with that rank\\r\\n    mapping(uint256 => Stake[]) private sea; \\r\\n    // tracks location of each Pirate in Sea\\r\\n    mapping(uint256 => uint256) private seaIndices; \\r\\n    // any rewards distributed when no pirates are staked\\r\\n    uint256 private unaccountedRewards = 0; \\r\\n    // amount of $CACAO due for each rank point staked\\r\\n    uint256 private cacaoPerRank = 0; \\r\\n\\r\\n\\r\\n    // galleons earn 10000 $CACAO per day\\r\\n    uint256 public constant DAILY_CACAO_RATE = 10000 ether;\\r\\n    // pirates take a 20% tax on all $CACAO claimed\\r\\n    uint256 public constant CACAO_CLAIM_TAX_PERCENTAGE = 20;\\r\\n    // there will only ever be (roughly) 2.4 billion $CACAO earned through staking\\r\\n    uint256 public constant MAXIMUM_GLOBAL_CACAO = 2400000000 ether;\\r\\n\\r\\n    // // galleons must have 2 days worth of $CACAO to unstake or else they're still in the sea\\r\\n    uint256 public minimumToExit = 2 days;\\r\\n    uint256 public minimumToClaim = 2 days;\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n    // amount of $CACAO earned so far\\r\\n    uint256 public totalCacaoEarned;\\r\\n    // the last time $CACAO was claimed\\r\\n    uint256 private lastClaimTimestamp;\\r\\n\\r\\n    // emergency rescue to allow unstaking without any checks but without $CACAO\\r\\n    bool public rescueEnabled = false;\\r\\n\\r\\n    /**\\r\\n     */\\r\\n    constructor() {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    /** CRITICAL TO SETUP */\\r\\n\\r\\n    modifier requireContractsSet() {\\r\\n            require(address(nftContract) != address(0) && address(cacao) != address(0) \\r\\n                && address(pirateGame) != address(0) && address(randomizer) != address(0), \\\"Contracts not set\\\");\\r\\n            _;\\r\\n    }\\r\\n\\r\\n    function setContracts(address _cacao, address _nft, address _pirateGame, address _rand) external onlyAdmin {\\r\\n        nftContract = IPnG(_nft);\\r\\n        cacao = ICACAO(_cacao);\\r\\n        pirateGame = _pirateGame;\\r\\n        randomizer = IRandomizer(_rand);\\r\\n    }\\r\\n\\r\\n\\r\\n    /** STAKING */\\r\\n\\r\\n    /**\\r\\n     * adds Galleons and Pirates to the Fleet and Sea\\r\\n     * @param account the address of the staker\\r\\n     * @param tokenIds the IDs of the Galleons and Pirates to stake\\r\\n     */\\r\\n    function addManyToFleet(address account, uint16[] calldata tokenIds) external override \\r\\n        nonReentrant \\r\\n        onlyEOA\\r\\n    {\\r\\n        require(account == tx.origin, \\\"account to sender mismatch\\\");\\r\\n        for (uint i = 0; i < tokenIds.length; i++) {\\r\\n            if (_msgSender() != address(pirateGame)) { // dont do this step if its a mint + stake\\r\\n                require(nftContract.ownerOf(tokenIds[i]) == _msgSender(), \\\"You don't own this token\\\");\\r\\n                nftContract.transferFrom(_msgSender(), address(this), tokenIds[i]);\\r\\n            } else if (tokenIds[i] == 0) {\\r\\n                continue; // there may be gaps in the array for stolen tokens\\r\\n            }\\r\\n\\r\\n            if (nftContract.isGalleon(tokenIds[i])) \\r\\n                _addGalleonToFleet(account, tokenIds[i]);\\r\\n            else \\r\\n                _addPirateToSea(account, tokenIds[i]);\\r\\n        } \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * adds a single Galleon to the Fleet\\r\\n     * @param account the address of the staker\\r\\n     * @param tokenId the ID of the Galleon to add to the Fleet\\r\\n     */\\r\\n    function _addGalleonToFleet(address account, uint256 tokenId) internal whenNotPaused _updateEarnings {\\r\\n        fleet[tokenId] = Stake({\\r\\n            owner: account,\\r\\n            tokenId: uint16(tokenId),\\r\\n            value: uint80(block.timestamp)\\r\\n        });\\r\\n        numGalleonsStaked += 1;\\r\\n        emit TokenStaked(account, tokenId, true, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * adds a single Pirate to the Sea\\r\\n     * @param account the address of the staker\\r\\n     * @param tokenId the ID of the Pirate to add to the Sea\\r\\n     */\\r\\n    function _addPirateToSea(address account, uint256 tokenId) internal {\\r\\n        uint8 rank = _rankForPirate(tokenId);\\r\\n        totalRankStaked += rank; // Portion of earnings ranges from 8 to 5\\r\\n        seaIndices[tokenId] = sea[rank].length; // Store the location of the pirate in the Sea\\r\\n        sea[rank].push(Stake({\\r\\n            owner: account,\\r\\n            tokenId: uint16(tokenId),\\r\\n            value: uint80(cacaoPerRank)\\r\\n        })); // Add the pirate to the Sea\\r\\n        emit TokenStaked(account, tokenId, false, cacaoPerRank);\\r\\n    }\\r\\n\\r\\n    /** CLAIMING / UNSTAKING */\\r\\n\\r\\n    /**\\r\\n     * realize $CACAO earnings and optionally unstake tokens from the Fleet / Sea\\r\\n     * to unstake a Galleon it will require it has 2 days worth of $CACAO unclaimed\\r\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\r\\n     * @param unstake whether or not to unstake ALL of the tokens listed in tokenIds\\r\\n     */\\r\\n    function claimManyFromFleetAndSea(uint16[] calldata tokenIds, bool unstake) external \\r\\n        whenNotPaused \\r\\n        _updateEarnings \\r\\n        nonReentrant \\r\\n        onlyEOA\\r\\n    {\\r\\n        uint256 owed = 0;\\r\\n        for (uint i = 0; i < tokenIds.length; i++) {\\r\\n            if (nftContract.isGalleon(tokenIds[i])) {\\r\\n                owed += _claimGalleonFromFleet(tokenIds[i], unstake);\\r\\n            }\\r\\n            else {\\r\\n                owed += _claimPirateFromSea(tokenIds[i], unstake);\\r\\n            }\\r\\n        }\\r\\n        cacao.updateInblockGuard();\\r\\n        if (owed == 0) {\\r\\n            return;\\r\\n        }\\r\\n        cacao.mint(_msgSender(), owed);\\r\\n    }\\r\\n\\r\\n    function calculateRewards(uint256 tokenId) external view returns (uint256 owed) {\\r\\n        uint64 lastTokenWrite = nftContract.getTokenWriteBlock(tokenId);\\r\\n        // Must check this, as getTokenTraits will be allowed since this contract is an admin\\r\\n        require(lastTokenWrite < block.number, \\\"hmmmm what doing?\\\");\\r\\n\\r\\n        Stake memory stake = fleet[tokenId];\\r\\n        if (stake.owner == address(0) && stake.value == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        if(nftContract.isGalleon(tokenId)) {\\r\\n            if (totalCacaoEarned < MAXIMUM_GLOBAL_CACAO) {\\r\\n                owed = (block.timestamp - stake.value) * DAILY_CACAO_RATE / 1 days;\\r\\n            } else if (stake.value > lastClaimTimestamp) {\\r\\n                owed = 0; // $CACAO production stopped already\\r\\n            } else {\\r\\n                owed = (lastClaimTimestamp - stake.value) * DAILY_CACAO_RATE / 1 days; // stop earning additional $CACAO if it's all been earned\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            uint8 rank = _rankForPirate(tokenId);\\r\\n            owed = (rank) * (cacaoPerRank - stake.value); // Calculate portion of tokens based on Rank\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculatePirateReward(uint256 tokenId) external view returns (uint256 owed) {\\r\\n        require(!nftContract.isGalleon(tokenId), \\\"Not Pirate\\\");\\r\\n        uint8 rank = _rankForPirate(tokenId);\\r\\n        Stake memory stake = sea[rank][seaIndices[tokenId]];\\r\\n        if (stake.owner == address(0) && stake.value == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        owed = (rank) * (cacaoPerRank - stake.value);            // Calculate portion of tokens based on Rank\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * realize $CACAO earnings for a single Galleon and optionally unstake it\\r\\n     * if not unstaking, pay a 20% tax to the staked Pirates\\r\\n     * if unstaking, there is a 50% chance all $CACAO is stolen\\r\\n     * @param tokenId the ID of the Galleons to claim earnings from\\r\\n     * @param unstake whether or not to unstake the Galleons\\r\\n     * @return owed - the amount of $CACAO earned\\r\\n     */\\r\\n    function _claimGalleonFromFleet(uint256 tokenId, bool unstake) internal returns (uint256 owed) {\\r\\n        Stake memory stake = fleet[tokenId];\\r\\n        require(stake.owner == _msgSender(), \\\"Don't own the given token\\\");\\r\\n        require(block.timestamp - stake.value > minimumToClaim, \\\"Claiming: Still in the sea\\\");\\r\\n        require(!(unstake && block.timestamp - stake.value < minimumToExit), \\\"Witdraw: Still in the sea\\\");\\r\\n\\r\\n        if (unstake) {\\r\\n            require(randomizer.canOperate(_msgSender(), tokenId), \\\"Randomizer: cannot operate\\\");\\r\\n        }\\r\\n\\r\\n        if (totalCacaoEarned < MAXIMUM_GLOBAL_CACAO) {\\r\\n            owed = (block.timestamp - stake.value) * DAILY_CACAO_RATE / 1 days;\\r\\n        } else if (stake.value > lastClaimTimestamp) {\\r\\n            owed = 0; // $CACAO production stopped already\\r\\n        } else {\\r\\n            owed = (lastClaimTimestamp - stake.value) * DAILY_CACAO_RATE / 1 days; // stop earning additional $CACAO if it's all been earned\\r\\n        }\\r\\n        if (unstake) {\\r\\n            if (randomizer.random(tokenId) & 1 == 1) { // 50% chance of all $CACAO stolen\\r\\n                _payPirateTax(owed);\\r\\n                owed = 0;\\r\\n            }\\r\\n            delete fleet[tokenId];\\r\\n            numGalleonsStaked -= 1;\\r\\n            // Always transfer last to guard against reentrance\\r\\n            nftContract.safeTransferFrom(address(this), _msgSender(), tokenId, \\\"\\\"); // send back Galleon\\r\\n        } else {\\r\\n            _payPirateTax(owed * CACAO_CLAIM_TAX_PERCENTAGE / 100); // percentage tax to staked pirates\\r\\n            owed = owed * (100 - CACAO_CLAIM_TAX_PERCENTAGE) / 100; // remainder goes to Galleon owner\\r\\n            fleet[tokenId] = Stake({\\r\\n                owner: _msgSender(),\\r\\n                tokenId: uint16(tokenId),\\r\\n                value: uint80(block.timestamp)\\r\\n            }); // reset stake\\r\\n        }\\r\\n        emit GalleonClaimed(tokenId, unstake, owed);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * realize $CACAO earnings for a single Pirate and optionally unstake it\\r\\n     * Pirates earn $CACAO proportional to their rank\\r\\n     * @param tokenId the ID of the Pirate to claim earnings from\\r\\n     * @param unstake whether or not to unstake the Pirate\\r\\n     * @return owed - the amount of $CACAO earned\\r\\n     */\\r\\n    function _claimPirateFromSea(uint256 tokenId, bool unstake) internal returns (uint256 owed) {\\r\\n        require(nftContract.ownerOf(tokenId) == address(this), \\\"Doesn't own token\\\");\\r\\n        uint8 rank = _rankForPirate(tokenId);\\r\\n        Stake memory stake = sea[rank][seaIndices[tokenId]];\\r\\n        require(stake.owner == _msgSender(), \\\"Doesn't own token\\\");\\r\\n        owed = (rank) * (cacaoPerRank - stake.value); // Calculate portion of tokens based on Rank\\r\\n        if (unstake) {\\r\\n            totalRankStaked -= rank; // Remove rank from total staked\\r\\n            Stake memory lastStake = sea[rank][sea[rank].length - 1];\\r\\n            sea[rank][seaIndices[tokenId]] = lastStake; // Shuffle last Pirate to current position\\r\\n            seaIndices[lastStake.tokenId] = seaIndices[tokenId];\\r\\n            sea[rank].pop(); // Remove duplicate\\r\\n            delete seaIndices[tokenId]; // Delete old mapping\\r\\n            // Always remove last to guard against reentrance\\r\\n            nftContract.safeTransferFrom(address(this), _msgSender(), tokenId, \\\"\\\"); // Send back Pirate\\r\\n        } else {\\r\\n            sea[rank][seaIndices[tokenId]] = Stake({\\r\\n                owner: _msgSender(),\\r\\n                tokenId: uint16(tokenId),\\r\\n                value: uint80(cacaoPerRank)\\r\\n            }); // reset stake\\r\\n        }\\r\\n        emit PirateClaimed(tokenId, unstake, owed);\\r\\n    }\\r\\n    /**\\r\\n     * emergency unstake tokens\\r\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\r\\n     */\\r\\n    function rescue(uint256[] calldata tokenIds) external nonReentrant {\\r\\n        require(rescueEnabled, \\\"RESCUE DISABLED\\\");\\r\\n        uint256 tokenId;\\r\\n        Stake memory stake;\\r\\n        Stake memory lastStake;\\r\\n        uint8 rank;\\r\\n        for (uint i = 0; i < tokenIds.length; i++) {\\r\\n            tokenId = tokenIds[i];\\r\\n            if (nftContract.isGalleon(tokenId)) {\\r\\n                stake = fleet[tokenId];\\r\\n                require(stake.owner == _msgSender(), \\\"SWIPER, NO SWIPING\\\");\\r\\n                delete fleet[tokenId];\\r\\n                numGalleonsStaked -= 1;\\r\\n                nftContract.safeTransferFrom(address(this), _msgSender(), tokenId, \\\"\\\"); // send back Galleons\\r\\n                emit GalleonClaimed(tokenId, true, 0);\\r\\n            } else {\\r\\n                rank = _rankForPirate(tokenId);\\r\\n                stake = sea[rank][seaIndices[tokenId]];\\r\\n                require(stake.owner == _msgSender(), \\\"SWIPER, NO SWIPING\\\");\\r\\n                totalRankStaked -= rank; // Remove Rank from total staked\\r\\n                lastStake = sea[rank][sea[rank].length - 1];\\r\\n                sea[rank][seaIndices[tokenId]] = lastStake; // Shuffle last Pirate to current position\\r\\n                seaIndices[lastStake.tokenId] = seaIndices[tokenId];\\r\\n                sea[rank].pop(); // Remove duplicate\\r\\n                delete seaIndices[tokenId]; // Delete old mapping\\r\\n                nftContract.safeTransferFrom(address(this), _msgSender(), tokenId, \\\"\\\"); // Send back Pirate\\r\\n                emit PirateClaimed(tokenId, true, 0);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** ACCOUNTING */\\r\\n\\r\\n    /** \\r\\n     * add $CACAO to claimable pot for the Sea\\r\\n     * @param amount $CACAO to add to the pot\\r\\n     */\\r\\n    function _payPirateTax(uint256 amount) internal {\\r\\n        if (totalRankStaked == 0) { // if there's no staked pirates\\r\\n            unaccountedRewards += amount; // keep track of $CACAO due to pirates\\r\\n            return;\\r\\n        }\\r\\n        // makes sure to include any unaccounted $CACAO \\r\\n        cacaoPerRank += (amount + unaccountedRewards) / totalRankStaked;\\r\\n        unaccountedRewards = 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * tracks $CACAO earnings to ensure it stops once 2.4 billion is eclipsed\\r\\n     */\\r\\n    modifier _updateEarnings() {\\r\\n        if (totalCacaoEarned < MAXIMUM_GLOBAL_CACAO) {\\r\\n            totalCacaoEarned += \\r\\n                (block.timestamp - lastClaimTimestamp)\\r\\n                * numGalleonsStaked\\r\\n                * DAILY_CACAO_RATE / 1 days; \\r\\n            lastClaimTimestamp = block.timestamp;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /** ADMIN */\\r\\n\\r\\n    /**\\r\\n     * allows owner to enable \\\"rescue mode\\\"\\r\\n     * simplifies accounting, prioritizes tokens out in emergency\\r\\n     */\\r\\n    function _setRescueEnabled(bool _enabled) external onlyAdmin {\\r\\n        rescueEnabled = _enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables owner to pause / unpause contract\\r\\n     */\\r\\n    function setPaused(bool _paused) external requireContractsSet onlyAdmin {\\r\\n        if (_paused) _pause();\\r\\n        else _unpause();\\r\\n    }\\r\\n\\r\\n    function _setRanks(uint8[4] memory ranks) external onlyAdmin {\\r\\n        _ranks = ranks;\\r\\n    }\\r\\n\\r\\n    function _setTimeRestrictions(uint256 _toClaim, uint256 _toExit) external onlyAdmin {\\r\\n        minimumToClaim = _toClaim;\\r\\n        minimumToExit = _toExit;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /** READ ONLY */\\r\\n\\r\\n    /**\\r\\n     * gets the rank score for a Pirate\\r\\n     * @param tokenId the ID of the Pirate to get the rank score for\\r\\n     * @return the rank score of the Pirate (5-8)\\r\\n     */\\r\\n    function _rankForPirate(uint256 tokenId) internal view returns (uint8) {\\r\\n        IPnG.GalleonPirate memory s = nftContract.getTokenTraits(tokenId);\\r\\n        return _ranks[s.alphaIndex]; // rank index is 0-3\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * chooses a random Pirate thief when a newly minted token is stolen\\r\\n     * @param seed a random value to choose a Pirate from\\r\\n     * @return the owner of the randomly selected Pirate thief\\r\\n     */\\r\\n    function randomPirateOwner(uint256 seed) external view override returns (address) {\\r\\n        if (totalRankStaked == 0) {\\r\\n            return address(0x0);\\r\\n        }\\r\\n        uint256 bucket = (seed & 0xFFFFFFFF) % totalRankStaked; // choose a value from 0 to total rank staked\\r\\n        uint256 cumulative;\\r\\n        seed >>= 32;\\r\\n        uint8 rank;\\r\\n        // loop through each bucket of Pirates with the same rank score\\r\\n        for (uint8 j = 0; j < _ranks.length; j++) {\\r\\n            rank = _ranks[j];\\r\\n            cumulative += sea[rank].length * rank;\\r\\n            // if the value is not inside of that bucket, keep going\\r\\n            if (bucket >= cumulative) continue;\\r\\n            // get the address of a random Pirate with that rank score\\r\\n            return sea[rank][seed % sea[rank].length].owner;\\r\\n        }\\r\\n        return address(0x0);\\r\\n    }\\r\\n\\r\\n    function onERC721Received(address,address from,uint256,bytes calldata) \\r\\n        external pure override \\r\\n        returns (bytes4) \\r\\n    {\\r\\n        require(from == address(0x0), \\\"Cannot send to Fleet directly\\\");\\r\\n        return IERC721Receiver.onERC721Received.selector;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * allows owner to withdraw funds\\r\\n     */\\r\\n    function _withdraw() external onlyTokenClaimer {\\r\\n        payable(_msgSender()).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier onlyEOA {\\r\\n        require(tx.origin == _msgSender() || _msgSender() == address(pirateGame), \\\"Only EOA\\\");\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/pirate/utils/Accessable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\n\\r\\ncontract Owned is Context {\\r\\n    address private _contractOwner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() { \\r\\n        _contractOwner = payable(_msgSender()); \\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns(address) {\\r\\n        return _contractOwner;\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) external virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Owned: Address can not be 0x0\\\");\\r\\n        __transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _renounceOwnership() external virtual onlyOwner {\\r\\n        __transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function __transferOwnership(address _to) internal {\\r\\n        emit OwnershipTransferred(owner(), _to);\\r\\n        _contractOwner = _to;\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_msgSender() == _contractOwner, \\\"Owned: Only owner can operate\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract Accessable is Owned {\\r\\n    mapping(address => bool) private _admins;\\r\\n    mapping(address => bool) private _tokenClaimers;\\r\\n\\r\\n    constructor() {\\r\\n        _admins[_msgSender()] = true;\\r\\n        _tokenClaimers[_msgSender()] = true;\\r\\n    }\\r\\n\\r\\n    function isAdmin(address user) public view returns(bool) {\\r\\n        return _admins[user];\\r\\n    }\\r\\n\\r\\n    function isTokenClaimer(address user) public view returns(bool) {\\r\\n        return _tokenClaimers[user];\\r\\n    }\\r\\n\\r\\n\\r\\n    function _setAdmin(address _user, bool _isAdmin) external onlyOwner {\\r\\n        _admins[_user] = _isAdmin;\\r\\n        require( _admins[owner()], \\\"Accessable: Contract owner must be an admin\\\" );\\r\\n    }\\r\\n\\r\\n    function _setTokenClaimer(address _user, bool _isTokenCalimer) external onlyOwner {\\r\\n        _tokenClaimers[_user] = _isTokenCalimer;\\r\\n        require( _tokenClaimers[owner()], \\\"Accessable: Contract owner must be an token claimer\\\" );\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(_admins[_msgSender()], \\\"Accessable: Only admin can operate\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTokenClaimer() {\\r\\n        require(_tokenClaimers[_msgSender()], \\\"Accessable: Only Token Claimer can operate\\\");\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/pirate/interfaces/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRandomizer {\\r\\n    function random(uint256) external returns (uint256);\\r\\n\\r\\n    function canOperate(address addr, uint256 tokenId) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"/contracts/pirate/interfaces/IPnG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\n\\r\\ninterface IPnG is IERC721 {\\r\\n\\r\\n    struct GalleonPirate {\\r\\n        bool isGalleon;\\r\\n\\r\\n        // Galleon traits\\r\\n        uint8 base;\\r\\n        uint8 deck;\\r\\n        uint8 sails;\\r\\n        uint8 crowsNest;\\r\\n        uint8 decor;\\r\\n        uint8 flags;\\r\\n        uint8 bowsprit;\\r\\n\\r\\n        // Pirate traits\\r\\n        uint8 skin;\\r\\n        uint8 clothes;\\r\\n        uint8 hair;\\r\\n        uint8 earrings;\\r\\n        uint8 mouth;\\r\\n        uint8 eyes;\\r\\n        uint8 weapon;\\r\\n        uint8 hat;\\r\\n        uint8 alphaIndex;\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateOriginAccess(uint16[] memory tokenIds) external;\\r\\n\\r\\n    function totalSupply() external view returns(uint256);\\r\\n\\r\\n    function mint(address recipient, uint256 seed) external;\\r\\n    function burn(uint256 tokenId) external;\\r\\n    function minted() external view returns (uint16);\\r\\n\\r\\n    function getMaxTokens() external view returns (uint256);\\r\\n    function getPaidTokens() external view returns (uint256);\\r\\n    function getTokenTraits(uint256 tokenId) external view returns (GalleonPirate memory);\\r\\n    function getTokenWriteBlock(uint256 tokenId) external view returns(uint64);\\r\\n    function isGalleon(uint256 tokenId) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"/contracts/pirate/interfaces/IInblockGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IInblockGuard {\\r\\n    function updateInblockGuard() external;\\r\\n}\"\r\n    },\r\n    \"/contracts/pirate/interfaces/IFleet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE \\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IFleet {\\r\\n    function addManyToFleet(address account, uint16[] calldata tokenIds) external;\\r\\n    function randomPirateOwner(uint256 seed) external view returns (address);\\r\\n}\"\r\n    },\r\n    \"/contracts/pirate/interfaces/ICACAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IInblockGuard.sol\\\";\\r\\n\\r\\n\\r\\ninterface ICACAO is IInblockGuard {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n    function burn(address from, uint256 amount) external;\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"name\":\"GalleonClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"name\":\"PirateClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isGalleon\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CACAO_CLAIM_TAX_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAILY_CACAO_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_GLOBAL_CACAO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAdmin\",\"type\":\"bool\"}],\"name\":\"_setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[4]\",\"name\":\"ranks\",\"type\":\"uint8[4]\"}],\"name\":\"_setRanks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"_setRescueEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toExit\",\"type\":\"uint256\"}],\"name\":\"_setTimeRestrictions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isTokenCalimer\",\"type\":\"bool\"}],\"name\":\"_setTokenClaimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"_transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"addManyToFleet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cacao\",\"outputs\":[{\"internalType\":\"contract ICACAO\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"calculatePirateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claimManyFromFleetAndSea\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isTokenClaimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumToExit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"contract IPnG\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirateGame\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"randomPirateOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomizer\",\"outputs\":[{\"internalType\":\"contract IRandomizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cacao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pirateGame\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rand\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCacaoEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Fleet","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}