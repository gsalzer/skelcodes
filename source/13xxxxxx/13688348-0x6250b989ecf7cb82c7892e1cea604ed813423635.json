{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract AccessControl {\\r\\n  address internal _admin;\\r\\n  address internal _owner;\\r\\n\\r\\n  modifier onlyAdmin() {\\r\\n    require(msg.sender == _admin, \\\"unauthorized\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == _owner, \\\"unauthorized\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function changeAdmin(address newAdmin) external onlyOwner {\\r\\n    _admin = newAdmin;\\r\\n  }\\r\\n\\r\\n  function changeOwner(address newOwner) external onlyOwner {\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n\\r\\n  function owner() external view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/NFTCollectionV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./AccessControl.sol\\\";\\r\\nimport \\\"./interfaces/IERC165.sol\\\";\\r\\nimport \\\"./interfaces/IERC721.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Metadata.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Receiver.sol\\\";\\r\\n\\r\\nabstract contract NFTCollectionV1 is AccessControl, IERC165, IERC721, IERC721Metadata {\\r\\n  /** @dev IERC721 Fields */\\r\\n\\r\\n  mapping(address => uint256) internal _balances;\\r\\n  mapping(address => mapping(address => bool)) internal _operatorApprovals;\\r\\n  mapping(uint256 => address) internal _owners;\\r\\n  mapping(uint256 => address) internal _tokenApprovals;\\r\\n\\r\\n  /** @dev IERC721Enumerable */\\r\\n\\r\\n  uint256 internal _totalSupply;\\r\\n  uint256 internal _totalSupplyLimit;\\r\\n\\r\\n  string internal _baseURI;\\r\\n\\r\\n  /** @dev IERC165 Views */\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC165-supportsInterface}.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\\r\\n    return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId;\\r\\n  }\\r\\n\\r\\n  /** @dev IERC721 Views */\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of tokens in ``owner``'s account.\\r\\n   */\\r\\n  function balanceOf(address owner_) external view override returns (uint256 balance) {\\r\\n    return _balances[owner_];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the account approved for `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function getApproved(uint256 tokenId) external view override returns (address operator) {\\r\\n    return _tokenApprovals[tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n   *\\r\\n   * See {setApprovalForAll}\\r\\n   */\\r\\n  function isApprovedForAll(address owner_, address operator) external view override returns (bool) {\\r\\n    return _operatorApprovals[owner_][operator];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the owner of the `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function ownerOf(uint256 tokenId) external view override returns (address) {\\r\\n    return _owners[tokenId];\\r\\n  }\\r\\n\\r\\n  /** @dev IERC721 Mutators */\\r\\n\\r\\n  /**\\r\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n   * The approval is cleared when the token is transferred.\\r\\n   *\\r\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The caller must own the token or be an approved operator.\\r\\n   * - `tokenId` must exist.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address to, uint256 tokenId) external override {\\r\\n    address owner_ = _owners[tokenId];\\r\\n\\r\\n    require(to != owner_, \\\"caller may not approve themself\\\");\\r\\n    require(msg.sender == owner_ || _operatorApprovals[owner_][msg.sender], \\\"unauthorized\\\");\\r\\n\\r\\n    _approve(to, tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external override {\\r\\n    _ensureApprovedOrOwner(msg.sender, tokenId);\\r\\n    _transfer(from, to, tokenId);\\r\\n\\r\\n    if (_isContract(to)) {\\r\\n      IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, \\\"\\\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external override {\\r\\n    _ensureApprovedOrOwner(msg.sender, tokenId);\\r\\n    _transfer(from, to, tokenId);\\r\\n\\r\\n    if (_isContract(to)) {\\r\\n      IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approve or remove `operator` as an operator for the caller.\\r\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The `operator` cannot be the caller.\\r\\n   *\\r\\n   * Emits an {ApprovalForAll} event.\\r\\n   */\\r\\n  function setApprovalForAll(address operator, bool approved) external override {\\r\\n    require(operator != msg.sender, \\\"caller may not approve themself\\\");\\r\\n\\r\\n    _operatorApprovals[msg.sender][operator] = approved;\\r\\n\\r\\n    emit ApprovalForAll(msg.sender, operator, approved);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external override {\\r\\n    _ensureApprovedOrOwner(msg.sender, tokenId);\\r\\n    _transfer(from, to, tokenId);\\r\\n  }\\r\\n\\r\\n  /** IERC721Metadata Views */\\r\\n\\r\\n  function tokenURI(uint256 tokenId) external view override returns (string memory) {\\r\\n    return string(abi.encodePacked(_baseURI, _toString(tokenId), \\\".json\\\"));\\r\\n  }\\r\\n\\r\\n  /** Useful Methods */\\r\\n\\r\\n  function changeBaseURI(string memory newURI) external onlyAdmin {\\r\\n    _baseURI = newURI;\\r\\n  }\\r\\n\\r\\n  function totalSupply() external view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  /** Helpers */\\r\\n\\r\\n  /**\\r\\n   * @dev Approve `to` to operate on `tokenId`\\r\\n   *\\r\\n   * Emits a {Approval} event.\\r\\n   */\\r\\n  function _approve(address to, uint256 tokenId) private {\\r\\n    _tokenApprovals[tokenId] = to;\\r\\n\\r\\n    emit Approval(_owners[tokenId], to, tokenId);\\r\\n  }\\r\\n\\r\\n  function _ensureApprovedOrOwner(address spender, uint256 tokenId) private view {\\r\\n    address owner_ = _owners[tokenId];\\r\\n\\r\\n    require(\\r\\n      spender == owner_ || spender == _tokenApprovals[tokenId] || _operatorApprovals[owner_][spender],\\r\\n      \\\"unauthorized\\\"\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n   */\\r\\n  function _toString(uint256 value) internal pure returns (string memory) {\\r\\n    if (value == 0) {\\r\\n      return \\\"0\\\";\\r\\n    }\\r\\n    uint256 temp = value;\\r\\n    uint256 digits;\\r\\n    while (temp != 0) {\\r\\n      digits++;\\r\\n      temp /= 10;\\r\\n    }\\r\\n    bytes memory buffer = new bytes(digits);\\r\\n    while (value != 0) {\\r\\n      digits -= 1;\\r\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n      value /= 10;\\r\\n    }\\r\\n    return string(buffer);\\r\\n  }\\r\\n\\r\\n  function _isContract(address account) internal view returns (bool) {\\r\\n    // This method relies on extcodesize, which returns 0 for contracts in\\r\\n    // construction, since the code is only stored at the end of the\\r\\n    // constructor execution.\\r\\n\\r\\n    uint256 size;\\r\\n\\r\\n    assembly {\\r\\n      size := extcodesize(account)\\r\\n    }\\r\\n\\r\\n    return size > 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers `tokenId` from `from` to `to`.\\r\\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must be owned by `from`.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function _transfer(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) private {\\r\\n    require(_owners[tokenId] == from, \\\"transfer of token that is not own\\\");\\r\\n    require(to != address(0), \\\"transfer to the zero address\\\");\\r\\n\\r\\n    // Clear approvals from the previous owner\\r\\n    _approve(address(0), tokenId);\\r\\n\\r\\n    _balances[from] -= 1;\\r\\n    _balances[to] += 1;\\r\\n    _owners[tokenId] = to;\\r\\n\\r\\n    emit Transfer(from, to, tokenId);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n  /**\\r\\n   * @dev Returns true if this contract implements the interface defined by\\r\\n   * `interfaceId`. See the corresponding\\r\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n   * to learn more about how these ids are created.\\r\\n   *\\r\\n   * This function call must use less than 30 000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 {\\r\\n  /** Events */\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n   */\\r\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n  /** Views */\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of tokens in ``owner``'s account.\\r\\n   */\\r\\n  function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the account approved for `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n   *\\r\\n   * See {setApprovalForAll}\\r\\n   */\\r\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the owner of the `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n  /** Mutators */\\r\\n\\r\\n  /**\\r\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n   * The approval is cleared when the token is transferred.\\r\\n   *\\r\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The caller must own the token or be an approved operator.\\r\\n   * - `tokenId` must exist.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Approve or remove `operator` as an operator for the caller.\\r\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The `operator` cannot be the caller.\\r\\n   *\\r\\n   * Emits an {ApprovalForAll} event.\\r\\n   */\\r\\n  function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata {\\r\\n  /**\\r\\n   * @dev Returns the token collection name.\\r\\n   */\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token collection symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n   */\\r\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n  /**\\r\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n   * by `operator` from `from`, this function is called.\\r\\n   *\\r\\n   * It must return its Solidity selector to confirm the token transfer.\\r\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n   *\\r\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\r\\n   */\\r\\n  function onERC721Received(\\r\\n    address operator,\\r\\n    address from,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MetafansCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"./Authorized.sol\\\";\\r\\nimport \\\"./NFTCollectionV1.sol\\\";\\r\\n\\r\\ncontract MetafansCollection is NFTCollectionV1, Authorized {\\r\\n  /** @dev Immutable */\\r\\n  uint256 private constant _launchLimit = 10;\\r\\n  uint256 private constant _mintCooldown = 10 minutes;\\r\\n  uint256 private constant _presaleLimit = 3;\\r\\n\\r\\n  address private immutable _partnerA;\\r\\n  address private immutable _partnerB;\\r\\n  uint256 private immutable _promoQuantity;\\r\\n\\r\\n  /** @dev Fields */\\r\\n\\r\\n  uint256 private _launchAt;\\r\\n  mapping(address => uint256) private _lastMintAt;\\r\\n  uint256 private _partnerARevenue;\\r\\n  uint256 private _partnerBRevenue;\\r\\n  uint256 private _presaleAt;\\r\\n  mapping(address => uint256) private _presaleClaimed;\\r\\n  uint256 private _price;\\r\\n\\r\\n  constructor(\\r\\n    string memory baseURI_,\\r\\n    uint256 launchAt_,\\r\\n    address partnerA,\\r\\n    address partnerB,\\r\\n    uint256 presaleAt_,\\r\\n    uint256 price,\\r\\n    uint256 promoQuantity_,\\r\\n    uint256 totalSupplyLimit_\\r\\n  ) {\\r\\n    _admin = msg.sender;\\r\\n    _authority = msg.sender;\\r\\n    _owner = msg.sender;\\r\\n\\r\\n    _baseURI = baseURI_;\\r\\n    _launchAt = launchAt_;\\r\\n    _partnerA = partnerA;\\r\\n    _partnerB = partnerB;\\r\\n    _presaleAt = presaleAt_;\\r\\n    _price = price;\\r\\n    _promoQuantity = promoQuantity_;\\r\\n    _totalSupplyLimit = totalSupplyLimit_;\\r\\n\\r\\n    _totalSupply = _promoQuantity;\\r\\n  }\\r\\n\\r\\n  /** @dev IERC721Metadata Views */\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token collection name.\\r\\n   */\\r\\n  function name() external pure override returns (string memory) {\\r\\n    return \\\"Metafans Collection\\\";\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token collection symbol.\\r\\n   */\\r\\n  function symbol() external pure override returns (string memory) {\\r\\n    return \\\"MFC\\\";\\r\\n  }\\r\\n\\r\\n  /** @dev General Views */\\r\\n\\r\\n  function lastMintAt(address wallet) external view returns (uint256) {\\r\\n    return _lastMintAt[wallet];\\r\\n  }\\r\\n\\r\\n  function launchAt() external view returns (uint256) {\\r\\n    return _launchAt;\\r\\n  }\\r\\n\\r\\n  function presaleAt() external view returns (uint256) {\\r\\n    return _presaleAt;\\r\\n  }\\r\\n\\r\\n  function presaleClaimed(address wallet) external view returns (uint256) {\\r\\n    return _presaleClaimed[wallet];\\r\\n  }\\r\\n\\r\\n  /** @dev Admin Mutators */\\r\\n\\r\\n  function changeLaunchAt(uint256 value) external onlyAdmin {\\r\\n    _launchAt = value;\\r\\n  }\\r\\n\\r\\n  function changePresaleAt(uint256 value) external onlyAdmin {\\r\\n    _presaleAt = value;\\r\\n  }\\r\\n\\r\\n  function changePrice(uint256 value) external onlyAdmin {\\r\\n    _price = value;\\r\\n  }\\r\\n\\r\\n  /** @dev Mint Mutators */\\r\\n\\r\\n  function launchMint(uint256 quantity) external payable {\\r\\n    require(_launchAt < block.timestamp, \\\"launch has not begun\\\");\\r\\n    require(msg.value == _price * quantity, \\\"incorrect ETH\\\");\\r\\n    require(quantity <= _launchLimit, \\\"over limit\\\");\\r\\n    require(block.timestamp - _lastMintAt[msg.sender] > _mintCooldown, \\\"cooling down\\\");\\r\\n\\r\\n    _partnerShare();\\r\\n    _mint(quantity);\\r\\n  }\\r\\n\\r\\n  function presaleMint(\\r\\n    uint256 quantity,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external payable authorized(msg.sender, deadline, v, r, s) {\\r\\n    require(_presaleAt < block.timestamp, \\\"presale has not begun\\\");\\r\\n    require(block.timestamp < _launchAt, \\\"presale has ended\\\");\\r\\n    require(block.timestamp < deadline, \\\"past deadline\\\");\\r\\n    require(msg.value == _price * quantity, \\\"incorrect ETH\\\");\\r\\n    require((_presaleClaimed[msg.sender] += quantity) <= _presaleLimit, \\\"over limit\\\");\\r\\n\\r\\n    _partnerShare();\\r\\n    _mint(quantity);\\r\\n  }\\r\\n\\r\\n  function promoMint(uint256 tokenId, address to) external onlyAdmin {\\r\\n    require(tokenId < _promoQuantity, \\\"over promo limit\\\");\\r\\n    require(_owners[tokenId] == address(0), \\\"already minted\\\");\\r\\n\\r\\n    _balances[to] += 1;\\r\\n    _owners[tokenId] = to;\\r\\n\\r\\n    emit Transfer(address(0), to, tokenId);\\r\\n  }\\r\\n\\r\\n  /** @dev Partner Views */\\r\\n\\r\\n  function partnerRevenue(address wallet) external view returns (uint256) {\\r\\n    if (wallet == _partnerA) {\\r\\n      return _partnerARevenue;\\r\\n    }\\r\\n\\r\\n    if (wallet == _partnerB) {\\r\\n      return _partnerBRevenue;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n  /** @dev Partner Mutators */\\r\\n\\r\\n  function claimRevenue() external {\\r\\n    uint256 amount;\\r\\n\\r\\n    if (msg.sender == _partnerA) {\\r\\n      amount = _partnerARevenue;\\r\\n      _partnerARevenue = 0;\\r\\n    } else if (msg.sender == _partnerB) {\\r\\n      amount = _partnerBRevenue;\\r\\n      _partnerBRevenue = 0;\\r\\n    } else {\\r\\n      revert(\\\"unauthorized\\\");\\r\\n    }\\r\\n\\r\\n    (bool send, ) = msg.sender.call{value: amount}(\\\"\\\");\\r\\n\\r\\n    require(send, \\\"failed to send partner funds\\\");\\r\\n  }\\r\\n\\r\\n  /** @dev Helpers */\\r\\n\\r\\n  function _mint(uint256 quantity) private {\\r\\n    require(_totalSupply + quantity <= _totalSupplyLimit, \\\"over total supply limit\\\");\\r\\n\\r\\n    for (uint256 i = 0; i < quantity; i++) {\\r\\n      _owners[_totalSupply + i] = msg.sender;\\r\\n\\r\\n      emit Transfer(address(0), msg.sender, _totalSupply + i);\\r\\n    }\\r\\n\\r\\n    _balances[msg.sender] += quantity;\\r\\n    _totalSupply += quantity;\\r\\n    _lastMintAt[msg.sender] = block.timestamp;\\r\\n  }\\r\\n\\r\\n  function _partnerShare() private {\\r\\n    uint256 shareB = msg.value / 10;\\r\\n    uint256 shareA = msg.value - shareB;\\r\\n\\r\\n    _partnerARevenue += shareA;\\r\\n    _partnerBRevenue += shareB;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Authorized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Authorized {\\r\\n  bytes32 internal immutable _domainSeparator;\\r\\n\\r\\n  address internal _authority;\\r\\n\\r\\n  constructor() {\\r\\n    bytes32 typeHash = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n    _domainSeparator = keccak256(\\r\\n      abi.encode(typeHash, keccak256(bytes(\\\"MetaFans\\\")), keccak256(bytes(\\\"1.0.0\\\")), block.chainid, address(this))\\r\\n    );\\r\\n  }\\r\\n\\r\\n  modifier authorized(\\r\\n    address account,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) {\\r\\n    bytes32 hash = keccak256(abi.encode(keccak256(\\\"Presale(address to,uint256 deadline)\\\"), account, deadline));\\r\\n\\r\\n    require(verify(hash, v, r, s), \\\"unauthorized\\\");\\r\\n\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function verify(\\r\\n    bytes32 hash,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal view returns (bool) {\\r\\n    return _authority == ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparator, hash)), v, r, s);\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"launchAt_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"partnerA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"partnerB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"presaleAt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"promoQuantity_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyLimit_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"changeBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeLaunchAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changePresaleAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"lastMintAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"launchMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"partnerRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"presaleClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"presaleMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"promoMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MetafansCollection","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000061a53f500000000000000000000000004bf75497fa89681637a3c4da9ec5d44b10585b65000000000000000000000000d68547f4b566a54dfb9f320c995a2841e03f64a20000000000000000000000000000000000000000000000000000000061a14ad0000000000000000000000000000000000000000000000000011c37937e08000000000000000000000000000000000000000000000000000000000000000000fa0000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000000002e68747470733a2f2f7777772e6d65746166616e732e636f6d2f636f6c6c656374696f6e732f6d65746166616e732f000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fffe759d52f0d04878a025870c7ec36367281de4af98aef99247b1cf84339c31"}]}