{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/NFTDisplay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {Base64} from \\\"base64-sol/base64.sol\\\";\\n\\nimport {NFTSVG} from \\\"./NFTSVG.sol\\\";\\n\\nlibrary NFTDisplay {\\n    using Strings for uint256;\\n    using Strings for uint256;\\n    using ABDKMath64x64 for int128;\\n\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    struct BuildTokenURIParams {\\n        uint256 tokenId;\\n        address pool;\\n        address base;\\n        address underlying;\\n        uint64 maturity;\\n        int128 strikePrice;\\n        bool isCall;\\n        bool isLong;\\n        string baseSymbol;\\n        string underlyingSymbol;\\n    }\\n\\n    function buildTokenURI(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory base64image;\\n\\n        {\\n            string memory svgImage = buildSVGImage(_params);\\n            base64image = Base64.encode(bytes(svgImage));\\n        }\\n\\n        string memory description = buildDescription(_params);\\n        string memory name = buildName(_params);\\n        string memory attributes = buildAttributes(_params);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            abi.encodePacked(\\n                                \\\"{\\\",\\n                                '\\\"image\\\":\\\"',\\n                                \\\"data:image/svg+xml;base64,\\\",\\n                                base64image,\\n                                '\\\",',\\n                                '\\\"description\\\":\\\"',\\n                                description,\\n                                '\\\",',\\n                                '\\\"name\\\":\\\"',\\n                                name,\\n                                '\\\",',\\n                                attributes,\\n                                \\\"}\\\"\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function buildSVGImage(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory maturityString = maturityToString(_params.maturity);\\n        string memory strikePriceString = fixedToDecimalString(\\n            _params.strikePrice\\n        );\\n\\n        return\\n            NFTSVG.buildSVG(\\n                NFTSVG.CreateSVGParams({\\n                    isCall: _params.isCall,\\n                    isLong: _params.isLong,\\n                    baseSymbol: _params.baseSymbol,\\n                    underlyingSymbol: _params.underlyingSymbol,\\n                    strikePriceString: strikePriceString,\\n                    maturityString: maturityString\\n                })\\n            );\\n    }\\n\\n    function buildDescription(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory descriptionPartA = buildDescriptionPartA(\\n            _params.pool,\\n            _params.base,\\n            _params.underlying,\\n            _params.baseSymbol,\\n            _params.underlyingSymbol,\\n            _params.isLong\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    descriptionPartA,\\n                    _params.baseSymbol,\\n                    \\\"\\\\\\\\n\\\\\\\\nMaturity: \\\",\\n                    maturityToString(_params.maturity),\\n                    \\\"\\\\\\\\n\\\\\\\\nStrike Price: \\\",\\n                    strikePriceToString(\\n                        _params.strikePrice,\\n                        _params.baseSymbol\\n                    ),\\n                    \\\"\\\\\\\\n\\\\\\\\nType: \\\",\\n                    optionTypeToString(_params.isCall, _params.isLong),\\n                    \\\"\\\\\\\\n\\\\\\\\nToken ID: \\\",\\n                    _params.tokenId.toString(),\\n                    \\\"\\\\\\\\n\\\\\\\\n\\\",\\n                    unicode\\\"⚠️ DISCLAIMER: Due diligence is imperative when assessing this NFT. Double check the option details and make sure token addresses match the expected tokens, as token symbols may be imitated.\\\"\\n                )\\n            );\\n    }\\n\\n    function buildDescriptionPartA(\\n        address pool,\\n        address base,\\n        address underlying,\\n        string memory baseSymbol,\\n        string memory underlyingSymbol,\\n        bool isLong\\n    ) public pure returns (string memory) {\\n        string memory pairName = getPairName(baseSymbol, underlyingSymbol);\\n        bytes memory bufferA = abi.encodePacked(\\n            \\\"This NFT represents a \\\",\\n            longShortToString(isLong),\\n            \\\" option position in a Premia V2 \\\",\\n            pairName,\\n            \\\" pool. The owner of the NFT can transfer or \\\",\\n            isLong ? \\\"exercise\\\" : \\\"sell\\\",\\n            \\\" the position.\\\",\\n            \\\"\\\\\\\\n\\\\\\\\nPool Address: \\\"\\n        );\\n\\n        bytes memory bufferB = abi.encodePacked(\\n            addressToString(pool),\\n            \\\"\\\\\\\\n\\\\\\\\n\\\",\\n            underlyingSymbol,\\n            \\\" Address: \\\",\\n            addressToString(underlying),\\n            \\\"\\\\\\\\n\\\\\\\\n\\\",\\n            \\\" Address: \\\",\\n            addressToString(base)\\n        );\\n\\n        return string(abi.encodePacked(bufferA, bufferB));\\n    }\\n\\n    function buildName(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory pairName = getPairName(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"Premia - \\\",\\n                    pairName,\\n                    \\\" - \\\",\\n                    maturityToString(_params.maturity),\\n                    \\\" - \\\",\\n                    strikePriceToString(\\n                        _params.strikePrice,\\n                        _params.baseSymbol\\n                    ),\\n                    \\\" - \\\",\\n                    optionTypeToString(_params.isCall, _params.isLong)\\n                )\\n            );\\n    }\\n\\n    function buildAttributes(BuildTokenURIParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory pairName = getPairName(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol\\n        );\\n\\n        bytes memory buffer = abi.encodePacked(\\n            '\\\"attributes\\\":[',\\n            '{\\\"trait_type\\\":\\\"Market\\\",\\\"value\\\":\\\"Premia V2\\\"},',\\n            '{\\\"trait_type\\\":\\\"Pair\\\",\\\"value\\\":\\\"',\\n            pairName,\\n            '\\\"},',\\n            '{\\\"trait_type\\\":\\\"Underlying Token\\\",\\\"value\\\":\\\"',\\n            addressToString(_params.underlying),\\n            '\\\"},'\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    buffer,\\n                    '{\\\"trait_type\\\":\\\"Base Token\\\",\\\"value\\\":\\\"',\\n                    addressToString(_params.base),\\n                    '\\\"},',\\n                    '{\\\"trait_type\\\":\\\"Maturity\\\",\\\"value\\\":\\\"',\\n                    maturityToString(_params.maturity),\\n                    '\\\"},',\\n                    '{\\\"trait_type\\\":\\\"Strike Price\\\",\\\"value\\\":\\\"',\\n                    strikePriceToString(\\n                        _params.strikePrice,\\n                        _params.baseSymbol\\n                    ),\\n                    '\\\"},',\\n                    '{\\\"trait_type\\\":\\\"Type\\\",\\\"value\\\":\\\"',\\n                    optionTypeToString(_params.isCall, _params.isLong),\\n                    '\\\"}',\\n                    \\\"]\\\"\\n                )\\n            );\\n    }\\n\\n    function getPairName(\\n        string memory baseSymbol,\\n        string memory underlyingSymbol\\n    ) public pure returns (string memory) {\\n        return string(abi.encodePacked(underlyingSymbol, \\\"/\\\", baseSymbol));\\n    }\\n\\n    function maturityToString(uint64 maturity)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        (uint256 year, uint256 month, uint256 date) = timestampToDate(maturity);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    date.toString(),\\n                    \\\"-\\\",\\n                    monthToString(month),\\n                    \\\"-\\\",\\n                    year.toString()\\n                )\\n            );\\n    }\\n\\n    function strikePriceToString(int128 strikePrice, string memory baseSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    fixedToDecimalString(strikePrice),\\n                    \\\" \\\",\\n                    baseSymbol\\n                )\\n            );\\n    }\\n\\n    function optionTypeToString(bool isCall, bool isLong)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    isLong ? \\\"LONG \\\" : \\\"SHORT \\\",\\n                    isCall ? \\\"CALL\\\" : \\\"PUT\\\"\\n                )\\n            );\\n    }\\n\\n    function longShortToString(bool isLong)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return isLong ? \\\"LONG\\\" : \\\"SHORT\\\";\\n    }\\n\\n    function monthToString(uint256 month)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (month == 1) {\\n            return \\\"JAN\\\";\\n        } else if (month == 2) {\\n            return \\\"FEB\\\";\\n        } else if (month == 3) {\\n            return \\\"MAR\\\";\\n        } else if (month == 4) {\\n            return \\\"APR\\\";\\n        } else if (month == 5) {\\n            return \\\"MAY\\\";\\n        } else if (month == 6) {\\n            return \\\"JUN\\\";\\n        } else if (month == 7) {\\n            return \\\"JUL\\\";\\n        } else if (month == 8) {\\n            return \\\"AUG\\\";\\n        } else if (month == 9) {\\n            return \\\"SEP\\\";\\n        } else if (month == 10) {\\n            return \\\"OCT\\\";\\n        } else if (month == 11) {\\n            return \\\"NOV\\\";\\n        }\\n\\n        return \\\"DEC\\\";\\n    }\\n\\n    function addressToString(address addr) public pure returns (string memory) {\\n        bytes memory data = abi.encodePacked(addr);\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(2 + data.length * 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < data.length; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n\\n    function fixedToDecimalString(int128 value64x64)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        bool negative = value64x64 < 0;\\n        uint256 integer = uint256(value64x64.abs().toUInt());\\n        int128 decimal64x64 = value64x64 - int128(int256(integer << 64));\\n        uint256 decimal = (decimal64x64 * 1000).toUInt();\\n        string memory decimalString = \\\"\\\";\\n\\n        if (decimal > 0) {\\n            decimalString = string(\\n                abi.encodePacked(\\\".\\\", onlySignificant(decimal))\\n            );\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    negative ? \\\"-\\\" : \\\"\\\",\\n                    commaSeparateInteger(integer),\\n                    decimalString\\n                )\\n            );\\n    }\\n\\n    function onlySignificant(uint256 decimal)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory b = bytes(decimal.toString());\\n        bytes memory buffer;\\n        bool foundSignificant;\\n\\n        for (uint256 i; i < b.length; i++) {\\n            if (!foundSignificant && b[b.length - i - 1] != bytes1(\\\"0\\\"))\\n                foundSignificant = true;\\n\\n            if (foundSignificant) {\\n                buffer = abi.encodePacked(b[b.length - i - 1], buffer);\\n            }\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function commaSeparateInteger(uint256 integer)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory b = bytes(integer.toString());\\n        bytes memory buffer;\\n\\n        for (uint256 i; i < b.length; i++) {\\n            if (i > 0 && i % 3 == 0) {\\n                buffer = abi.encodePacked(b[b.length - i - 1], \\\",\\\", buffer);\\n            } else {\\n                buffer = abi.encodePacked(b[b.length - i - 1], buffer);\\n            }\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    /*\\n     * Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\\n     */\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n}\\n\"\r\n    },\r\n    \"abdk-libraries-solidity/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (x << 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    unchecked {\\n      return int64 (x >> 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (int256 (x << 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    unchecked {\\n      require (x >= 0);\\n      return uint64 (uint128 (x >> 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = x >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    unchecked {\\n      return int256 (x) << 64;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) + y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) - y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) * y >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    unchecked {\\n      if (x == MIN_64x64) {\\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n          y <= 0x1000000000000000000000000000000000000000000000000);\\n        return -y << 63;\\n      } else {\\n        bool negativeResult = false;\\n        if (x < 0) {\\n          x = -x;\\n          negativeResult = true;\\n        }\\n        if (y < 0) {\\n          y = -y; // We rely on overflow behavior here\\n          negativeResult = !negativeResult;\\n        }\\n        uint256 absoluteResult = mulu (x, uint256 (y));\\n        if (negativeResult) {\\n          require (absoluteResult <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000);\\n          return -int256 (absoluteResult); // We rely on overflow behavior here\\n        } else {\\n          require (absoluteResult <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n          return int256 (absoluteResult);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    unchecked {\\n      if (y == 0) return 0;\\n\\n      require (x >= 0);\\n\\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\\n\\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      hi <<= 64;\\n\\n      require (hi <=\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n      return hi + lo;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      int256 result = (int256 (x) << 64) / y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x; // We rely on overflow behavior here\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <= 0x80000000000000000000000000000000);\\n        return -int128 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (absoluteResult); // We rely on overflow behavior here\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      uint128 result = divuu (x, y);\\n      require (result <= uint128 (MAX_64x64));\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return -x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return x < 0 ? -x : x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != 0);\\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      return int128 ((int256 (x) + int256 (y)) >> 1);\\n    }\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 m = int256 (x) * int256 (y);\\n      require (m >= 0);\\n      require (m <\\n          0x4000000000000000000000000000000000000000000000000000000000000000);\\n      return int128 (sqrtu (uint256 (m)));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      bool negative = x < 0 && y & 1 == 1;\\n\\n      uint256 absX = uint128 (x < 0 ? -x : x);\\n      uint256 absResult;\\n      absResult = 0x100000000000000000000000000000000;\\n\\n      if (absX <= 0x10000000000000000) {\\n        absX <<= 63;\\n        while (y != 0) {\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x2 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x4 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x8 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          y >>= 4;\\n        }\\n\\n        absResult >>= 64;\\n      } else {\\n        uint256 absXShift = 63;\\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n        uint256 resultShift = 0;\\n        while (y != 0) {\\n          require (absXShift < 64);\\n\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n            resultShift += absXShift;\\n            if (absResult > 0x100000000000000000000000000000000) {\\n              absResult >>= 1;\\n              resultShift += 1;\\n            }\\n          }\\n          absX = absX * absX >> 127;\\n          absXShift <<= 1;\\n          if (absX >= 0x100000000000000000000000000000000) {\\n              absX >>= 1;\\n              absXShift += 1;\\n          }\\n\\n          y >>= 1;\\n        }\\n\\n        require (resultShift < 64);\\n        absResult >>= 64 - resultShift;\\n      }\\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= 0);\\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      int256 msb = 0;\\n      int256 xc = x;\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 result = msb - 64 << 64;\\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n        ux *= ux;\\n        uint256 b = ux >> 255;\\n        ux >>= 127 + b;\\n        result += bit * int256 (b);\\n      }\\n\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      return int128 (int256 (\\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n\\n      if (x & 0x8000000000000000 > 0)\\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n      if (x & 0x4000000000000000 > 0)\\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n      if (x & 0x2000000000000000 > 0)\\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n      if (x & 0x1000000000000000 > 0)\\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n      if (x & 0x800000000000000 > 0)\\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n      if (x & 0x400000000000000 > 0)\\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n      if (x & 0x200000000000000 > 0)\\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n      if (x & 0x100000000000000 > 0)\\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n      if (x & 0x80000000000000 > 0)\\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n      if (x & 0x40000000000000 > 0)\\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n      if (x & 0x20000000000000 > 0)\\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n      if (x & 0x10000000000000 > 0)\\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n      if (x & 0x8000000000000 > 0)\\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n      if (x & 0x4000000000000 > 0)\\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n      if (x & 0x2000000000000 > 0)\\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n      if (x & 0x1000000000000 > 0)\\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n      if (x & 0x800000000000 > 0)\\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n      if (x & 0x400000000000 > 0)\\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n      if (x & 0x200000000000 > 0)\\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n      if (x & 0x100000000000 > 0)\\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n      if (x & 0x80000000000 > 0)\\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n      if (x & 0x40000000000 > 0)\\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n      if (x & 0x20000000000 > 0)\\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n      if (x & 0x10000000000 > 0)\\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n      if (x & 0x8000000000 > 0)\\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n      if (x & 0x4000000000 > 0)\\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n      if (x & 0x2000000000 > 0)\\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n      if (x & 0x1000000000 > 0)\\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n      if (x & 0x800000000 > 0)\\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n      if (x & 0x400000000 > 0)\\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n      if (x & 0x200000000 > 0)\\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n      if (x & 0x100000000 > 0)\\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n      if (x & 0x80000000 > 0)\\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n      if (x & 0x40000000 > 0)\\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n      if (x & 0x20000000 > 0)\\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n      if (x & 0x10000000 > 0)\\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n      if (x & 0x8000000 > 0)\\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n      if (x & 0x4000000 > 0)\\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n      if (x & 0x2000000 > 0)\\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n      if (x & 0x1000000 > 0)\\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n      if (x & 0x800000 > 0)\\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n      if (x & 0x400000 > 0)\\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n      if (x & 0x200000 > 0)\\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n      if (x & 0x100000 > 0)\\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n      if (x & 0x80000 > 0)\\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n      if (x & 0x40000 > 0)\\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n      if (x & 0x20000 > 0)\\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n      if (x & 0x10000 > 0)\\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n      if (x & 0x8000 > 0)\\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n      if (x & 0x4000 > 0)\\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n      if (x & 0x2000 > 0)\\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n      if (x & 0x1000 > 0)\\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n      if (x & 0x800 > 0)\\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n      if (x & 0x400 > 0)\\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n      if (x & 0x200 > 0)\\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n      if (x & 0x100 > 0)\\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n      if (x & 0x80 > 0)\\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n      if (x & 0x40 > 0)\\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n      if (x & 0x20 > 0)\\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n      if (x & 0x10 > 0)\\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n      if (x & 0x8 > 0)\\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n      if (x & 0x4 > 0)\\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n      if (x & 0x2 > 0)\\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n      if (x & 0x1 > 0)\\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n      result >>= uint256 (int256 (63 - (x >> 64)));\\n      require (result <= uint256 (int256 (MAX_64x64)));\\n\\n      return int128 (int256 (result));\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      return exp_2 (\\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      uint256 result;\\n\\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        result = (x << 64) / y;\\n      else {\\n        uint256 msb = 192;\\n        uint256 xc = x >> 192;\\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 hi = result * (y >> 128);\\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 xh = x >> 192;\\n        uint256 xl = x << 64;\\n\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n        lo = hi << 128;\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n\\n        assert (xh == hi >> 128);\\n\\n        result += xl / y;\\n      }\\n\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return uint128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    unchecked {\\n      if (x == 0) return 0;\\n      else {\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n        if (xx >= 0x8) { r <<= 1; }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return uint128 (r < r1 ? r : r1);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NFTSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary NFTSVG {\\n    using Strings for uint256;\\n\\n    string constant ETH_COLOR_A = \\\"#FFFFFF\\\";\\n    string constant WBTC_COLOR_A = \\\"#E2753B\\\";\\n    string constant LINK_COLOR_A = \\\"#376AFF\\\";\\n    string constant DAI_COLOR_A = \\\"#D1A663\\\";\\n    string constant UNKNOWN_COLOR_A = \\\"#52FFB2\\\";\\n\\n    string constant ETH_COLOR_B = \\\"#FFFFFF\\\";\\n    string constant WBTC_COLOR_B = \\\"#E2923B\\\";\\n    string constant LINK_COLOR_B = \\\"#438BFF\\\";\\n    string constant DAI_COLOR_B = \\\"#D8A75B\\\";\\n    string constant UNKNOWN_COLOR_B = \\\"#52B4FF\\\";\\n\\n    string constant ETH_UNDERLYING_LOGO =\\n        '<path d=\\\"m68.86 132.9-7.7-13.4-7.73 13.4 7.72-3.66 7.71 3.65Zm-7.7 7.17-8.66-4.11 8.65 15.12 8.66-15.12-8.66 4.11Zm0-2.09-7.06-3.34 7.05-3.34 7.06 3.34-7.06 3.34Z\\\" fill=\\\"#BBBBBB\\\"/>';\\n    string constant WBTC_UNDERLYING_LOGO =\\n        '<path d=\\\"M52.79 153.08a16.29 16.29 0 1 1 0-32.58 16.29 16.29 0 0 1 0 32.58Zm0-31.31a15.01 15.01 0 1 0 .02 30.02 15.01 15.01 0 0 0-.02-30.02Zm8.55 5.65a12.66 12.66 0 0 0-17.09 0l-.91-.9a13.94 13.94 0 0 1 18.9 0l-.9.9Zm.83.81.9-.9v-.01a13.94 13.94 0 0 1 0 18.9l-.9-.9a12.66 12.66 0 0 0 0-17.09Zm-18.75 17.1a12.66 12.66 0 0 1 0-17.08l-.9-.9a13.94 13.94 0 0 0 0 18.9l.9-.92Zm.82.83a12.67 12.67 0 0 0 17.1 0l.9.9a13.94 13.94 0 0 1-18.9 0l.9-.9Zm14.2-12.35c-.18-1.87-1.8-2.5-3.83-2.69v-2.57h-1.57v2.52h-1.26v-2.52h-1.56v2.59h-3.2v1.68s1.17-.02 1.15 0c.43-.04.83.26.9.7v7.08c-.02.15-.09.29-.2.39a.55.55 0 0 1-.4.13c.02.02-1.15 0-1.15 0l-.3 1.88h3.17v2.63h1.57v-2.59h1.26v2.58h1.58v-2.6c2.66-.16 4.51-.81 4.74-3.3.2-2-.75-2.9-2.26-3.26.92-.45 1.49-1.29 1.36-2.66Zm-2.2 5.6c0 1.8-2.83 1.75-4.12 1.73h-.3v-3.47h.39c1.32-.04 4.02-.1 4.02 1.74Zm-4.16-3.32c1.08.02 3.42.06 3.42-1.58 0-1.67-2.26-1.61-3.37-1.58h-.32v3.16h.27Z\\\" fill=\\\"#E2923B\\\"/>';\\n    string constant LINK_UNDERLYING_LOGO =\\n        '<path d=\\\"m62.4 122 2.7-1.6L68 122l7.5 4.4 2.8 1.6v15l-2.8 1.6L68 149l-2.8 1.6-2.8-1.6-7.6-4.4-2.7-1.6v-15l2.7-1.6 7.6-4.4Zm-4.8 9.1v8.8l7.5 4.3 7.6-4.3V131l-7.6-4.3-7.5 4.3Z\\\" fill=\\\"#3159CC\\\"/>';\\n    string constant UNKNOWN_UNDERLYING_LOGO =\\n        '<path d=\\\"M46.8 119.5a16.3 16.3 0 1 1 0 32.6 16.3 16.3 0 0 1 0-32.6Zm0 20.6c-.5 0-.9.2-1.2.5a1.5 1.5 0 0 0 0 2.2 1.8 1.8 0 0 0 1.2.5c.4 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.1 0-.4-.2-.8-.5-1.1-.3-.3-.7-.5-1.1-.5Zm.2-11.8c-.6 0-1.2 0-1.8.3-.5.2-1 .4-1.4.8-.4.3-.8.8-1 1.3a5 5 0 0 0-.5 1.5v.2l2.4.3.2-.8a2 2 0 0 1 2-1.4c.5 0 1 .2 1.4.6.3.3.5.8.5 1.3 0 .4-.1.8-.3 1l-.5.7-.2.1-1 1-.6.6a3.2 3.2 0 0 0-.6 1.4v1.7H48v-1.3l.2-.6.4-.5.7-.6a16.5 16.5 0 0 0 1.5-1.6l.4-1 .2-1a4 4 0 0 0-.4-1.8c-.2-.4-.5-.9-1-1.2l-1.3-.8-1.7-.2Z\\\" fill=\\\"#383838\\\"/>';\\n\\n    string constant DAI_BASE_LOGO =\\n        '<path d=\\\"M254 135.7a16.3 16.3 0 1 0-32.6 0 16.3 16.3 0 0 0 32.6 0Zm-24 9V139l-.2-.1h-2.2c-.1 0-.2 0-.2-.2v-2h2.4l.2-.1v-2H227.6c-.1 0-.2 0-.2-.2v-1.8c0-.1 0-.2.2-.2h2.2c.1 0 .2 0 .2-.2V127c0-.2 0-.2.2-.2h7.6l1.6.1a10 10 0 0 1 5 2.6l1.1 1.4.8 1.5c0 .2.2.2.3.2h1.8c.3 0 .3 0 .3.3v1.6c0 .2 0 .2-.3.2H247l-.1.2v1.9c0 .1 0 .2.2.2h1.6v1.8c0 .2 0 .3-.2.3h-2l-.3.1a8.1 8.1 0 0 1-3.2 4l-.2.2-1 .5a11 11 0 0 1-4.8 1h-7Zm14-12.2v-.1a4 4 0 0 0-.4-.7l-.7-1-.5-.4a7.3 7.3 0 0 0-4.8-1.7h-5.4c-.2 0-.2 0-.2.2v3.6c0 .1 0 .2.2.2H244Zm-5.7 4.4h6.2c.1 0 .2 0 .2-.2v-2h-12.5l-.2.1v2h6.3Zm5.2 2h.5v.3a6.6 6.6 0 0 1-2.8 2.8 7.7 7.7 0 0 1-3 .8l-.8.1h-5.2c-.2 0-.2 0-.2-.2v-3.5c0-.2 0-.2.2-.2h11.3Z\\\" fill=\\\"#E3A94D\\\"/>';\\n    string constant UNKNOWN_BASE_LOGO =\\n        '<path d=\\\"M253.79 119.5a16.29 16.29 0 1 1 0 32.58 16.29 16.29 0 0 1 0-32.58Zm-.02 20.63c-.45 0-.84.16-1.16.48a1.52 1.52 0 0 0 .01 2.23 1.78 1.78 0 0 0 1.15.45c.45 0 .84-.16 1.16-.47.32-.31.48-.7.48-1.13 0-.44-.16-.8-.5-1.1-.32-.3-.7-.46-1.14-.46Zm.22-11.84c-.62 0-1.21.1-1.76.28a4.2 4.2 0 0 0-2.49 2.11 5 5 0 0 0-.48 1.47l-.04.28 2.52.22c.01-.27.07-.53.16-.8a2.02 2.02 0 0 1 1.93-1.33c.62 0 1.09.19 1.43.55.33.36.5.8.5 1.34 0 .4-.1.76-.28 1.04-.14.22-.3.42-.48.6l-.19.18-.92.88c-.26.25-.47.48-.64.7a3.18 3.18 0 0 0-.64 1.41c-.03.2-.06.41-.07.65v1.01h2.42v-.53c0-.3.02-.55.06-.76.04-.2.11-.4.21-.57.1-.18.24-.36.41-.53.18-.18.4-.39.67-.62.31-.27.6-.53.85-.79.25-.25.47-.51.65-.79.17-.27.31-.57.4-.9.1-.32.15-.7.15-1.14 0-.65-.12-1.21-.35-1.7-.23-.5-.55-.91-.95-1.25-.4-.33-.87-.58-1.4-.75a5.4 5.4 0 0 0-1.66-.26Z\\\" fill=\\\"#383838\\\"/>';\\n\\n    string constant DAI_BASE_LOGO_SMALL =\\n        '<path d=\\\"M125 260a7 7 0 1 0-14 0 7 7 0 0 0 14 0Zm-10.3 3.9v-2.4l-.1-.1h-1v-.9h1v-.9h-1v-.9h1v-2.5H118.8a4.3 4.3 0 0 1 2.2 1l.5.7.3.6.1.1h.9V259.5h-.7v1h.7v.8h-.9l-.1.2a3.5 3.5 0 0 1-1.4 1.7h-.1l-.4.3a4.7 4.7 0 0 1-2.1.4h-3Zm6-5.3c0-.1 0-.2-.2-.3 0-.2-.2-.3-.3-.4l-.2-.2a3.1 3.1 0 0 0-2-.8h-2.4V258.6h5.1Zm-2.4 1.9h2.7v-.9h-5.4v.9h2.7Zm2.2.9h.2c-.3.6-.7 1-1.2 1.3l-.4.2-1 .2h-2.5V261.3h4.9Z\\\" fill=\\\"#646464\\\"/>';\\n    string constant UNKNOWN_BASE_LOGO_SMALL =\\n        '<path d=\\\"M118 253a7 7 0 1 1 0 14 7 7 0 0 1 0-14Zm0 8.87c-.2 0-.37.06-.5.2a.65.65 0 0 0 0 .96.76.76 0 0 0 .5.2c.18 0 .35-.07.49-.21.14-.13.2-.3.2-.48a.62.62 0 0 0-.2-.48.7.7 0 0 0-.5-.2Zm.09-5.1c-.27 0-.52.05-.76.13a1.8 1.8 0 0 0-1.07.9c-.1.2-.17.4-.2.64l-.02.12 1.08.1c0-.12.03-.24.07-.35a.87.87 0 0 1 .83-.57c.26 0 .47.07.61.23s.22.35.22.58c0 .17-.04.32-.12.45l-.2.25-.09.08-.4.38c-.1.1-.2.2-.27.3a1.37 1.37 0 0 0-.28.6l-.03.28V261.33h1.04v-.23c0-.13.01-.24.03-.32a.8.8 0 0 1 .1-.25c.03-.08.1-.15.17-.23a7.09 7.09 0 0 0 .65-.6l.28-.34c.07-.12.13-.25.17-.39.04-.14.06-.3.06-.5 0-.27-.05-.51-.15-.72-.1-.22-.23-.4-.4-.54a1.8 1.8 0 0 0-.6-.32 2.32 2.32 0 0 0-.72-.11Z\\\" fill=\\\"#646464\\\"/>';\\n\\n    struct CreateSVGParams {\\n        string baseSymbol;\\n        string underlyingSymbol;\\n        bool isCall;\\n        bool isLong;\\n        string maturityString;\\n        string strikePriceString;\\n    }\\n\\n    function buildSVG(CreateSVGParams memory _params)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        string memory tokens = buildTokens(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol\\n        );\\n        string memory svgText = buildText(\\n            _params.baseSymbol,\\n            _params.underlyingSymbol,\\n            _params.strikePriceString,\\n            _params.maturityString\\n        );\\n        string memory svgDefs = buildDefs(\\n            _params.underlyingSymbol,\\n            _params.baseSymbol,\\n            _params.isLong\\n        );\\n        string memory shortLongTag = buildShortLongTag(_params.isLong);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<svg width=\\\"300\\\" height=\\\"378\\\" viewBox=\\\"0 0 300 378\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">',\\n                    svgDefs,\\n                    '<g transform=\\\"translate(.5 .5)\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\">',\\n                    tokens,\\n                    _params.isCall ? buildCallRectangle() : buildPutRectangle(),\\n                    shortLongTag,\\n                    svgText,\\n                    \\\"</g>\\\",\\n                    \\\"</svg>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildTokens(\\n        string memory baseSymbol,\\n        string memory underlyingSymbol\\n    ) internal pure returns (string memory) {\\n        string memory baseLogoSmall = getBaseLogoSmall(baseSymbol);\\n        string memory baseLogo = getBaseLogo(baseSymbol);\\n        string memory underlyingLogo = getUnderlyingLogo(underlyingSymbol);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<path d=\\\"M103 0a25 25 0 0 1 17.7 7.3l24 24.1c8.1 8 19 12.6 30.5 12.6h95.2A30 30 0 0 1 300 69.4V348a30 30 0 0 1-30 30H30a30 30 0 0 1-30-30V30A30 30 0 0 1 30 0h73Z\\\" fill=\\\"#000\\\" fill-rule=\\\"nonzero\\\"/>',\\n                    '<path d=\\\"M19.9 150 1.1 163H16l16.8-13h.5l-16.7 13h14.9l14.7-13h.5l-14.6 13H47l12.6-13h.5l-12.5 13h14.9L73 150h.5l-10.4 13H78l8.4-13h.5l-8.3 13h14.9l6.3-13h.5l-6.2 13H109l4.2-13h.5l-4.1 13h14.9l2.1-13h.5l-2 13H140v-13h.5v13h15l-2-13h.4l2.2 13H171l-4.2-13h.5l4.3 13h14.9l-6.3-13h.5l6.4 13H202l-8.4-13h.5l8.5 13h14.9L207 150h.5l10.5 13h15l-12.6-13h.5l12.6 13h15l-14.7-13h.5l14.7 13h15l-16.8-13h.5l16.8 13h15l-18.9-13h.5l19 13h14.8L274 150h.5l21 13h4.5v.3h-4l4 2.4v.3l-4.5-2.8h-15l14 9.7h5.5v.3h-5l5 3.4v.4l-5.6-3.8h-16.5l12.5 9.6h9.6v.3h-9.2l9.2 7v.7l-9.9-7.7h-18l10.9 9.6h17v.4h-16.6l11.3 9.9h-.9l-11.2-10H263l9.7 10h-.9l-9.6-10h-19.6l8 10h-.8l-8-10h-19.6l6.5 10h-.9l-6.4-10h-19.6l4.9 10h-.9l-4.8-10h-19.6l3.3 10h-.9l-3.2-10H161l1.7 10h-.9l-1.5-10h-19.6v10h-.9v-10h-19.5l-1.6 10h-.9l1.7-10H99.9l-3.2 10h-.9l3.3-10H79.5l-4.8 10h-.9l5-10H59l-6.4 10h-.9l6.5-10H38.7l-8 10h-.9l8.1-10H18.3l-9.6 10h-.8l9.7-10H0v-.3h17.9l9.4-9.6H9.2L0 191.3v-.7l8.5-7.5H0v-.3h8.9l10.9-9.6H3.3L0 175.7v-.5l2.6-2H0v-.3h3l12.6-9.7H.6l-.6.5v-.8h.5L19.4 150h.5Zm138.8 33.1h-18v9.6h19.5l-1.5-9.6Zm-18.8 0h-18l-1.6 9.6H140v-9.6Zm-93.9 0H28l-9.3 9.6h19.5l7.8-9.6Zm18.8 0h-18l-7.8 9.6h19.5l6.3-9.6Zm18.8 0h-18l-6.3 9.6H79l4.7-9.6Zm18.8 0H84.3l-4.6 9.6h19.5l3.2-9.6Zm18.7 0h-18l-3.1 9.6h19.5l1.6-9.6Zm56.3 0h-18l1.6 9.6h19.5l-3-9.6Zm18.8 0h-18l3.1 9.6H201l-4.7-9.6Zm18.8 0h-18l4.7 9.6h19.5l-6.2-9.6Zm18.8 0h-18l6.2 9.6h19.5l-7.7-9.6Zm18.7 0h-18l7.8 9.6H262l-9.4-9.6Zm18.8 0h-18l9.3 9.6h19.6l-10.9-9.6Zm6-10h-16.6l11 9.7h18l-12.5-9.6Zm-17.2 0h-16.5l9.3 9.7h18l-10.8-9.6Zm-17.2 0h-16.5l7.8 9.7h18l-9.3-9.6Zm-17.2 0h-16.5l6.3 9.7h18l-7.8-9.6Zm-17.1 0H192l4.7 9.7h18l-6.2-9.6Zm-17.2 0H175l3.2 9.7h18l-4.7-9.6Zm-17.1 0h-16.5l1.5 9.7h18l-3-9.6Zm-17.2 0h-16.5v9.7h18l-1.5-9.6Zm-17.2 0h-16.5l-1.5 9.7h18v-9.6Zm-17.1 0h-16.5l-3.1 9.7h18l1.6-9.6Zm-17.2 0H89.1l-4.6 9.7h18l3.1-9.6Zm-17.2 0H72l-6.2 9.7h18l4.7-9.6Zm-17.1 0H54.8l-7.8 9.7h18l6.3-9.6Zm-17.2 0H37.6l-9.3 9.7h18l7.8-9.6Zm-17.1 0H20.5l-11 9.7h18l9.5-9.6Zm243-9.8h-15l12.5 9.6h16.4l-14-9.7Zm-15.6 0h-15l11 9.6h16.4l-12.4-9.7Zm-15.6 0h-15l9.4 9.6h16.5l-10.9-9.7Zm-15.5 0h-15l7.8 9.6h16.5l-9.3-9.7Zm-15.6 0h-15l6.3 9.6h16.5l-7.8-9.7Zm-15.5 0h-15l4.7 9.6h16.5l-6.2-9.7Zm-15.6 0h-15l3.2 9.6h16.5l-4.7-9.7Zm-15.5 0h-15l1.6 9.6h16.5l-3.1-9.7Zm-15.6 0h-15v9.6H157l-1.5-9.7Zm-15.5 0h-15l-1.5 9.6h16.4v-9.7Zm-15.6 0h-15l-3 9.6h16.4l1.6-9.7Zm-15.5 0h-15l-4.6 9.6h16.4l3.2-9.7Zm-15.6 0h-15l-6.1 9.6h16.4l4.7-9.7Zm-15.5 0h-15l-7.8 9.6h16.5l6.3-9.7Zm-15.6 0h-15l-9.3 9.6h16.5l7.8-9.7Zm-15.5 0h-15l-10.9 9.6h16.5l9.4-9.7Zm-15.6 0h-15l-12.4 9.6h16.5l10.9-9.7ZM287.9 150l12.1 6.7v.4l-12.6-7.1h.5ZM6.5 150 0 154v-.3l6-3.7h.5Z\\\" fill=\\\"url(#a)\\\" opacity=\\\".3\\\"/>',\\n                    '<rect stroke=\\\"#2C2C2C\\\" fill=\\\"#000\\\" fill-rule=\\\"nonzero\\\" x=\\\"18\\\" y=\\\"208.5\\\" width=\\\"264\\\" height=\\\"99\\\" rx=\\\"14\\\"/>',\\n                    baseLogoSmall,\\n                    baseLogo,\\n                    '<path d=\\\"M53.1 26.6c2.5 0 4.4 1.9 4.4 4.7 0 3-2 4.8-4.4 4.8a3.6 3.6 0 0 1-2.8-1.3h-.1v4.5h-1.9V26.8h1.9v1.1a3.8 3.8 0 0 1 3-1.3Zm16.4 0c2.6 0 4.7 2 4.7 4.7v.7h-7.5c.3 1.5 1.4 2.4 2.8 2.4 1 0 1.6-.3 2-.6l.6-.7h2a4.9 4.9 0 0 1-4.6 3c-2.6 0-4.7-2-4.7-4.8 0-2.6 2-4.7 4.7-4.7Zm29.6 0c1 0 1.7.3 2.2.7l.7.6h.1v-1.1h1.9v9.1h-1.9v-1.2l-.8.7c-.5.4-1.2.7-2.2.7-2.4 0-4.3-1.9-4.3-4.8 0-2.8 2-4.7 4.3-4.7Zm-34.7 0v1.9h-1.1c-1.5 0-2.5 1-2.5 2.5v5h-2v-9.2h2V28l.6-.7c.4-.4 1-.7 2-.7h1Zm22 0c2 0 3.4 1.3 3.4 3.8V36h-1.9v-5.4c0-1.5-.7-2.2-2-2.2-1.2 0-2.3 1-2.3 2.6v5h-1.9v-5.4c0-1.5-.7-2.2-2-2.2-1.2 0-2.3 1-2.3 2.6v5h-1.9v-9.1h1.9V28l.7-.7c.4-.4 1-.7 2-.7 1.3 0 2 .4 2.4.8l.7.9.7-.9c.5-.4 1.3-.8 2.5-.8Zm7.1.2v9.1h-1.9v-9.1h1.9Zm-40.7 1.5c-1.5 0-2.6 1-2.6 3s1 3.1 2.6 3.1 2.7-1 2.7-3-1-3.1-2.7-3.1Zm46.7 0c-1.6 0-2.7 1-2.7 3s1 3.1 2.7 3.1c1.5 0 2.6-1 2.6-3s-1-3.1-2.6-3.1Zm-30 0c-1.3 0-2.4.8-2.7 2.1h5.4c-.2-1-1-2.1-2.7-2.1Zm23-5.1c.7 0 1.2.5 1.2 1.1 0 .6-.5 1.1-1.1 1.1-.7 0-1.2-.5-1.2-1.1 0-.6.5-1.1 1.2-1.1Z\\\" fill=\\\"#FFF\\\"/>',\\n                    '<path d=\\\"M29.6 26.7h7.8c.5 0 .7.5.5.9l-3.7 5c-.3.5 0 1 .4 1H38c.2 0 .3-.1.4-.3l3.7-5v-.7l-3.2-4.4a.5.5 0 0 0-.5-.2h-9.5c-.2 0-.4 0-.5.2l-3.2 4.4v.7l8 11c.2.3.7.3.9 0l1.6-2.3c.2-.1.2-.4 0-.6l-6.4-8.8c-.3-.4 0-.9.4-.9Z\\\" fill=\\\"#5294FF\\\"/>',\\n                    underlyingLogo,\\n                    '<path stroke=\\\"#4D4343\\\" d=\\\"m154 148.5 6.5-26\\\"/>',\\n                    '<path d=\\\"M139.5 36c8 8 19.7 14.6 31 14.6h95.6c14.5 0 26.3 7.6 28.4 21.3v271.7c0 16-12.9 28.9-28.7 28.9H34.2c-15.8 0-28.7-13-28.7-28.9V33.4A28 28 0 0 1 34.2 5.5h67c6.3 0 12.4 3.5 16.9 8l21.4 22.6Z\\\" stroke=\\\"#FFF\\\" opacity=\\\".1\\\"/>',\\n                    '<path d=\\\"M289.26 66.05c-57.44 0-104 46.56-104 104s46.56 104 104 104c3.63 0 7.2-.18 10.74-.55V66.6c-3.53-.36-7.11-.55-10.74-.55Z\\\" fill=\\\"url(#b)\\\" opacity=\\\".31\\\" />',\\n                    '<path d=\\\"M10.7 66A104 104 0 1 1 0 273.6V66.6c3.5-.4 7.1-.5 10.7-.5Z\\\" fill=\\\"url(#c)\\\" opacity=\\\".3\\\"/>'\\n                )\\n            );\\n    }\\n\\n    function buildText(\\n        string memory baseSymbol,\\n        string memory underlyingSymbol,\\n        string memory strikePriceString,\\n        string memory maturityString\\n    ) internal pure returns (string memory) {\\n        bytes memory bufferA = abi.encodePacked(\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"gray\\\">',\\n            '<tspan x=\\\"32.1\\\" y=\\\"237\\\">Type</tspan>',\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"gray\\\">',\\n            '<tspan x=\\\"32.1\\\" y=\\\"263\\\">Strike price</tspan>',\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"gray\\\">',\\n            '<tspan x=\\\"32.1\\\" y=\\\"289\\\">Maturity</tspan>',\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Bold, DM Sans\\\" font-size=\\\"24\\\" font-weight=\\\"bold\\\" fill=\\\"#FFF\\\">',\\n            '<tspan style=\\\"direction:rtl\\\" x=\\\"143\\\" y=\\\"144\\\">',\\n            underlyingSymbol,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\"\\n        );\\n\\n        bytes memory bufferB = abi.encodePacked(\\n            '<text font-family=\\\"DMSans-Bold, DM Sans\\\" font-size=\\\"24\\\" font-weight=\\\"bold\\\" fill=\\\"#FFF\\\">',\\n            '<tspan x=\\\"173.1\\\" y=\\\"144\\\">',\\n            baseSymbol,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#FFF\\\">',\\n            '<tspan style=\\\"direction:rtl\\\" x=\\\"265\\\" y=\\\"263\\\">',\\n            strikePriceString,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\",\\n            '<text font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#FFF\\\">',\\n            '<tspan style=\\\"direction:rtl\\\" x=\\\"265\\\" y=\\\"289\\\">',\\n            maturityString,\\n            \\\"</tspan>\\\",\\n            \\\"</text>\\\"\\n        );\\n\\n        return string(abi.encodePacked(bufferA, bufferB));\\n    }\\n\\n    function buildDefs(\\n        string memory underlyingSymbol,\\n        string memory baseSymbol,\\n        bool isLong\\n    ) internal pure returns (string memory) {\\n        string memory baseGradient = buildBaseGradient(baseSymbol);\\n        string memory underlyingGradient = buildUnderlyingGradient(\\n            underlyingSymbol\\n        );\\n        string memory shortDefs = isLong ? \\\"\\\" : buildShortDefs();\\n        bytes memory whiteGradient = abi.encodePacked(\\n            '<linearGradient x1=\\\"50%\\\" y1=\\\"0%\\\" x2=\\\"50%\\\" y2=\\\"90%\\\" id=\\\"a\\\">',\\n            '<stop stop-color=\\\"#FFF\\\" stop-opacity=\\\"0\\\" offset=\\\"0%\\\"/>',\\n            '<stop stop-color=\\\"#FFF\\\" offset=\\\"80%\\\"/>',\\n            '<stop stop-color=\\\"#FFF\\\" stop-opacity=\\\"0\\\" offset=\\\"100%\\\"/>',\\n            \\\"</linearGradient>\\\"\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"<defs>\\\",\\n                    '<style type=\\\"text/css\\\">@import url(https://fonts.googleapis.com/css?family=DM+Sans);',\\n                    \\\"</style>\\\",\\n                    whiteGradient,\\n                    underlyingGradient,\\n                    baseGradient,\\n                    shortDefs,\\n                    \\\"</defs>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildUnderlyingGradient(string memory underlyingSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        (\\n            string memory underlyingColorA,\\n            string memory underlyingColorB\\n        ) = getTokenColors(underlyingSymbol);\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<radialGradient cx=\\\"8%\\\" cy=\\\"50%\\\" fx=\\\"8%\\\" fy=\\\"50%\\\" r=\\\"90.6%\\\" gradientTransform=\\\"matrix(0 .55164 -1 0 .6 .5)\\\" id=\\\"c\\\">',\\n                    '<stop stop-color=\\\"',\\n                    underlyingColorA,\\n                    '\\\" offset=\\\"0%\\\"/>',\\n                    '<stop stop-color=\\\"',\\n                    underlyingColorB,\\n                    '\\\" stop-opacity=\\\"0\\\" offset=\\\"100%\\\"/>',\\n                    \\\"</radialGradient>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildBaseGradient(string memory baseSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        (string memory baseColorA, string memory baseColorB) = getTokenColors(\\n            baseSymbol\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<radialGradient cx=\\\"100%\\\" cy=\\\"50%\\\" fx=\\\"100%\\\" fy=\\\"50%\\\" r=\\\"90.64%\\\" gradientTransform=\\\"matrix(0 .55164 -1 0 1.5 -.05)\\\" id=\\\"b\\\">',\\n                    '<stop stop-color=\\\"',\\n                    baseColorA,\\n                    '\\\" offset=\\\"0%\\\"/>',\\n                    '<stop stop-color=\\\"',\\n                    baseColorB,\\n                    '\\\" stop-opacity=\\\"0\\\" offset=\\\"99.67%\\\"/>',\\n                    \\\"</radialGradient>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildShortDefs() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<linearGradient x1=\\\"62.1%\\\" y1=\\\"20.8%\\\" x2=\\\"-29.2%\\\" y2=\\\"25.7%\\\" id=\\\"d\\\">',\\n                    '<stop stop-color=\\\"#3E1808\\\" offset=\\\"3%\\\" />',\\n                    '<stop stop-color=\\\"#300427\\\" offset=\\\"100%\\\" />',\\n                    \\\"</linearGradient>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildCallRectangle() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect stroke=\\\"#2CE49A\\\" fill=\\\"#051A12\\\" fill-rule=\\\"nonzero\\\" x=\\\"18\\\" y=\\\"319.5\\\" width=\\\"264\\\" height=\\\"39\\\" rx=\\\"14\\\"/>',\\n                    '<path d=\\\"m111.6 332.2 5.2 5a.7.7 0 0 1 0 1.2l-.5.4c-.2.2-.3.2-.6.2-.2 0-.4 0-.5-.2l-3-3v9.4c0 .5-.4.8-.8.8h-.7c-.5 0-.8-.3-.8-.8v-9.4l-3 3c-.2.2-.4.2-.6.2-.3 0-.5 0-.6-.2l-.5-.4a.7.7 0 0 1 0-1.1l5.2-5 .6-.3c.2 0 .4 0 .6.2Z\\\" fill=\\\"#2CE49A\\\" fill-rule=\\\"nonzero\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#2CE49A\\\">',\\n                    '<tspan x=\\\"121\\\" y=\\\"344\\\">Call Option</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildPutRectangle() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect stroke=\\\"#EB4A97\\\" fill=\\\"#2D0719\\\" fill-rule=\\\"nonzero\\\" x=\\\"18\\\" y=\\\"319.5\\\" width=\\\"264\\\" height=\\\"39\\\" rx=\\\"14\\\"/>',\\n                    '<path d=\\\"m111.6 345.8 5.2-5a.7.7 0 0 0 0-1.2l-.5-.4a.8.8 0 0 0-.6-.2c-.2 0-.4 0-.5.2l-3 3v-9.4c0-.5-.4-.8-.8-.8h-.7c-.5 0-.8.3-.8.8v9.4l-3-3a.8.8 0 0 0-1.1 0l-.6.4a.7.7 0 0 0 0 1.1l5.2 5 .6.3c.2 0 .4 0 .6-.2Z\\\" fill=\\\"#EB4A97\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#EB4A97\\\">',\\n                    '<tspan x=\\\"122.7\\\" y=\\\"344\\\">Put Option</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildShortLongTag(bool _isLong)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return _isLong ? buildLongTag() : buildShortTag();\\n    }\\n\\n    function buildLongTag() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect fill=\\\"#0C1E3C\\\" fill-rule=\\\"nonzero\\\" x=\\\"208\\\" y=\\\"222\\\" width=\\\"57\\\" height=\\\"23\\\" rx=\\\"6\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#5294FF\\\">',\\n                    '<tspan x=\\\"221.1\\\" y=\\\"238.5\\\">Long</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function buildShortTag() internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<rect fill=\\\"url(#d)\\\" fill-rule=\\\"nonzero\\\" x=\\\"208\\\" y=\\\"222\\\" width=\\\"57\\\" height=\\\"23\\\" rx=\\\"6\\\"/>',\\n                    '<text fill-rule=\\\"nonzero\\\" font-family=\\\"DMSans-Medium, DM Sans\\\" font-size=\\\"14\\\" font-weight=\\\"400\\\" fill=\\\"#ED6F64\\\">',\\n                    '<tspan x=\\\"219.1\\\" y=\\\"238.5\\\">Short</tspan>',\\n                    \\\"</text>\\\"\\n                )\\n            );\\n    }\\n\\n    function getUnderlyingLogo(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (\\n            hash == keccak256(abi.encodePacked(\\\"ETH\\\")) ||\\n            hash == keccak256(abi.encodePacked(\\\"WETH\\\"))\\n        ) {\\n            return ETH_UNDERLYING_LOGO;\\n        } else if (hash == keccak256(abi.encodePacked(\\\"LINK\\\"))) {\\n            return LINK_UNDERLYING_LOGO;\\n        } else if (hash == keccak256(abi.encodePacked(\\\"WBTC\\\"))) {\\n            return WBTC_UNDERLYING_LOGO;\\n        } else {\\n            return UNKNOWN_UNDERLYING_LOGO;\\n        }\\n    }\\n\\n    function getBaseLogo(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (hash == keccak256(abi.encodePacked(\\\"DAI\\\"))) {\\n            return DAI_BASE_LOGO;\\n        } else {\\n            return UNKNOWN_BASE_LOGO;\\n        }\\n    }\\n\\n    function getBaseLogoSmall(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (hash == keccak256(abi.encodePacked(\\\"DAI\\\"))) {\\n            return DAI_BASE_LOGO_SMALL;\\n        } else {\\n            return UNKNOWN_BASE_LOGO_SMALL;\\n        }\\n    }\\n\\n    function getTokenColors(string memory tokenSymbol)\\n        internal\\n        pure\\n        returns (string memory, string memory)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(tokenSymbol));\\n\\n        if (\\n            hash == keccak256(abi.encodePacked(\\\"ETH\\\")) ||\\n            hash == keccak256(abi.encodePacked(\\\"WETH\\\"))\\n        ) {\\n            return (ETH_COLOR_A, ETH_COLOR_B);\\n        } else if (hash == keccak256(abi.encodePacked(\\\"LINK\\\"))) {\\n            return (LINK_COLOR_A, LINK_COLOR_B);\\n        } else if (hash == keccak256(abi.encodePacked(\\\"WBTC\\\"))) {\\n            return (WBTC_COLOR_A, WBTC_COLOR_B);\\n        } else if (hash == keccak256(abi.encodePacked(\\\"DAI\\\"))) {\\n            return (DAI_COLOR_A, DAI_COLOR_B);\\n        } else {\\n            return (UNKNOWN_COLOR_A, UNKNOWN_COLOR_B);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/NFTSVG.sol\": {\r\n        \"NFTSVG\": \"0xfaedc9496a76597002d42aa3ef12b47ebd9bd8c4\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"int128\",\"name\":\"strikePrice\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"internalType\":\"struct NFTDisplay.BuildTokenURIParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"buildAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"int128\",\"name\":\"strikePrice\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"internalType\":\"struct NFTDisplay.BuildTokenURIParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"buildDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"}],\"name\":\"buildDescriptionPartA\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"int128\",\"name\":\"strikePrice\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"internalType\":\"struct NFTDisplay.BuildTokenURIParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"buildName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"int128\",\"name\":\"strikePrice\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"internalType\":\"struct NFTDisplay.BuildTokenURIParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"buildSVGImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"int128\",\"name\":\"strikePrice\",\"type\":\"int128\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"internalType\":\"struct NFTDisplay.BuildTokenURIParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"buildTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"integer\",\"type\":\"uint256\"}],\"name\":\"commaSeparateInteger\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int128\",\"name\":\"value64x64\",\"type\":\"int128\"}],\"name\":\"fixedToDecimalString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingSymbol\",\"type\":\"string\"}],\"name\":\"getPairName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"decimal\",\"type\":\"uint256\"}],\"name\":\"onlySignificant\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"NFTDisplay","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}