{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PremiaMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {SafeERC20} from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\r\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport {OwnableInternal} from \\\"@solidstate/contracts/access/OwnableInternal.sol\\\";\\r\\nimport {EnumerableSet} from \\\"@solidstate/contracts/utils/EnumerableSet.sol\\\";\\r\\nimport {IWETH} from \\\"@solidstate/contracts/utils/IWETH.sol\\\";\\r\\n\\r\\nimport {IUniswapV2Router02} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\nimport {PremiaMakerStorage} from \\\"./PremiaMakerStorage.sol\\\";\\r\\nimport {IPoolIO} from \\\"./pool/IPoolIO.sol\\\";\\r\\n\\r\\nimport {IPremiaMaker} from \\\"./interface/IPremiaMaker.sol\\\";\\r\\n\\r\\n/// @author Premia\\r\\n/// @title A contract receiving all protocol fees, swapping them for premia\\r\\ncontract PremiaMaker is IPremiaMaker, OwnableInternal {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n\\r\\n    // The premia token\\r\\n    address private immutable PREMIA;\\r\\n    // The premia staking contract (xPremia)\\r\\n    address private immutable PREMIA_STAKING;\\r\\n\\r\\n    // The treasury address which will receive a portion of the protocol fees\\r\\n    address private immutable TREASURY;\\r\\n    // The percentage of protocol fees the treasury will get (in basis points)\\r\\n    uint256 private constant TREASURY_FEE = 2e3; // 20%\\r\\n\\r\\n    uint256 private constant INVERSE_BASIS_POINT = 1e4;\\r\\n\\r\\n    ////////////\\r\\n    // Events //\\r\\n    ////////////\\r\\n\\r\\n    event Converted(\\r\\n        address indexed account,\\r\\n        address indexed router,\\r\\n        address indexed token,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 premiaAmount\\r\\n    );\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    // @param _premia The premia token\\r\\n    // @param _premiaStaking The premia staking contract (xPremia)\\r\\n    // @param _treasury The treasury address which will receive a portion of the protocol fees\\r\\n    constructor(\\r\\n        address _premia,\\r\\n        address _premiaStaking,\\r\\n        address _treasury\\r\\n    ) {\\r\\n        PREMIA = _premia;\\r\\n        PREMIA_STAKING = _premiaStaking;\\r\\n        TREASURY = _treasury;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    ///////////\\r\\n    // Admin //\\r\\n    ///////////\\r\\n\\r\\n    /// @notice Set a custom swap path for a token\\r\\n    /// @param _token The token\\r\\n    /// @param _path The swap path\\r\\n    function setCustomPath(address _token, address[] memory _path)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        PremiaMakerStorage.layout().customPath[_token] = _path;\\r\\n    }\\r\\n\\r\\n    /// @notice Add UniswapRouters to the whitelist so that they can be used to swap tokens.\\r\\n    /// @param _addr The addresses to add to the whitelist\\r\\n    function addWhitelistedRouter(address[] memory _addr) external onlyOwner {\\r\\n        PremiaMakerStorage.Layout storage l = PremiaMakerStorage.layout();\\r\\n\\r\\n        for (uint256 i = 0; i < _addr.length; i++) {\\r\\n            l.whitelistedRouters.add(_addr[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Remove UniswapRouters from the whitelist so that they cannot be used to swap tokens.\\r\\n    /// @param _addr The addresses to remove the whitelist\\r\\n    function removeWhitelistedRouter(address[] memory _addr)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        PremiaMakerStorage.Layout storage l = PremiaMakerStorage.layout();\\r\\n\\r\\n        for (uint256 i = 0; i < _addr.length; i++) {\\r\\n            l.whitelistedRouters.remove(_addr[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //////////////////////////\\r\\n\\r\\n    /// @notice Get a custom swap path for a token\\r\\n    /// @param _token The token\\r\\n    /// @return The swap path\\r\\n    function getCustomPath(address _token)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        return PremiaMakerStorage.layout().customPath[_token];\\r\\n    }\\r\\n\\r\\n    /// @notice Get the list of whitelisted routers\\r\\n    /// @return The list of whitelisted routers\\r\\n    function getWhitelistedRouters()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        PremiaMakerStorage.Layout storage l = PremiaMakerStorage.layout();\\r\\n\\r\\n        uint256 length = l.whitelistedRouters.length();\\r\\n        address[] memory result = new address[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            result[i] = l.whitelistedRouters.at(i);\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw fees from pools, convert tokens into Premia, and send Premia to PremiaStaking contract\\r\\n    /// @param _pool from which to withdraw fees\\r\\n    /// @param _router The UniswapRouter contract to use to perform the swap (Must be whitelisted)\\r\\n    /// @param _tokens The list of tokens to swap to premia\\r\\n    function withdrawFeesAndConvert(\\r\\n        address _pool,\\r\\n        address _router,\\r\\n        address[] memory _tokens\\r\\n    ) external override {\\r\\n        IPoolIO(_pool).withdrawFees();\\r\\n\\r\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\r\\n            convert(_router, _tokens[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Convert tokens into Premia, and send Premia to PremiaStaking contract\\r\\n    /// @param _router The UniswapRouter contract to use to perform the swap (Must be whitelisted)\\r\\n    /// @param _token The token to swap to premia\\r\\n    function convert(address _router, address _token) public override {\\r\\n        PremiaMakerStorage.Layout storage l = PremiaMakerStorage.layout();\\r\\n\\r\\n        require(\\r\\n            l.whitelistedRouters.contains(address(_router)),\\r\\n            \\\"Router not whitelisted\\\"\\r\\n        );\\r\\n\\r\\n        IERC20 token = IERC20(_token);\\r\\n\\r\\n        uint256 amount = token.balanceOf(address(this));\\r\\n        uint256 fee = (amount * TREASURY_FEE) / INVERSE_BASIS_POINT;\\r\\n        uint256 amountMinusFee = amount - fee;\\r\\n\\r\\n        token.safeTransfer(TREASURY, fee);\\r\\n\\r\\n        if (amountMinusFee == 0) return;\\r\\n\\r\\n        token.safeIncreaseAllowance(_router, amountMinusFee);\\r\\n\\r\\n        address weth = IUniswapV2Router02(_router).WETH();\\r\\n        uint256 premiaAmount;\\r\\n\\r\\n        if (_token != address(PREMIA)) {\\r\\n            address[] memory path;\\r\\n\\r\\n            if (_token != weth) {\\r\\n                path = l.customPath[_token];\\r\\n                if (path.length == 0) {\\r\\n                    path = new address[](3);\\r\\n                    path[0] = _token;\\r\\n                    path[1] = weth;\\r\\n                    path[2] = address(PREMIA);\\r\\n                }\\r\\n            } else {\\r\\n                path = new address[](2);\\r\\n                path[0] = _token;\\r\\n                path[1] = address(PREMIA);\\r\\n            }\\r\\n\\r\\n            IUniswapV2Router02(_router).swapExactTokensForTokens(\\r\\n                amountMinusFee,\\r\\n                0,\\r\\n                path,\\r\\n                PREMIA_STAKING,\\r\\n                block.timestamp\\r\\n            );\\r\\n        } else {\\r\\n            premiaAmount = amountMinusFee;\\r\\n            IERC20(PREMIA).safeTransfer(PREMIA_STAKING, premiaAmount);\\r\\n            // Just for the event\\r\\n            _router = address(0);\\r\\n        }\\r\\n\\r\\n        emit Converted(\\r\\n            msg.sender,\\r\\n            _router,\\r\\n            _token,\\r\\n            amountMinusFee,\\r\\n            premiaAmount\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../token/ERC20/IERC20.sol';\\nimport { AddressUtils } from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            'SafeERC20: approve from non-zero to non-zero allowance'\\n        );\\n\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(\\n                oldAllowance >= value,\\n                'SafeERC20: decreased allowance below zero'\\n            );\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeWithSelector(\\n                    token.approve.selector,\\n                    spender,\\n                    newAllowance\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n\\n        if (returndata.length > 0) {\\n            require(\\n                abi.decode(returndata, (bool)),\\n                'SafeERC20: ERC20 operation did not succeed'\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        require(\\n            set._values.length > index,\\n            'EnumerableSet: index out of bounds'\\n        );\\n        return set._values[index];\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 index = valueIndex - 1;\\n            bytes32 last = set._values[set._values.length - 1];\\n\\n            // move last value to now-vacant index\\n\\n            set._values[index] = last;\\n            set._indexes[last] = index + 1;\\n\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../token/ERC20/IERC20.sol';\\nimport { IERC20Metadata } from '../token/ERC20/metadata/IERC20Metadata.sol';\\n\\n/**\\n * @title WETH (Wrapped ETH) interface\\n */\\ninterface IWETH is IERC20, IERC20Metadata {\\n    /**\\n     * @notice convert ETH to WETH\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice convert WETH to ETH\\n     * @dev if caller is a contract, it should have a fallback or receive function\\n     * @param amount quantity of WETH to convert, denominated in wei\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/PremiaMakerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {EnumerableSet} from \\\"@solidstate/contracts/utils/EnumerableSet.sol\\\";\\r\\n\\r\\nlibrary PremiaMakerStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.storage.PremiaMaker\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        // UniswapRouter contracts which can be used to swap tokens\\r\\n        EnumerableSet.AddressSet whitelistedRouters;\\r\\n        // Set a custom swap path for a token\\r\\n        mapping(address => address[]) customPath;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/pool/IPoolIO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @notice Pool interface for LP position and platform fee management functions\\r\\n */\\r\\ninterface IPoolIO {\\r\\n    /**\\r\\n     * @notice set timestamp after which reinvestment is disabled\\r\\n     * @param timestamp timestamp to begin divestment\\r\\n     * @param isCallPool whether we set divestment timestamp for the call pool or put pool\\r\\n     */\\r\\n    function setDivestmentTimestamp(uint64 timestamp, bool isCallPool) external;\\r\\n\\r\\n    /**\\r\\n     * @notice deposit underlying currency, underwriting calls of that currency with respect to base currency\\r\\n     * @param amount quantity of underlying currency to deposit\\r\\n     * @param isCallPool whether to deposit underlying in the call pool or base in the put pool\\r\\n     */\\r\\n    function deposit(uint256 amount, bool isCallPool) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice deposit underlying currency, underwriting calls of that currency with respect to base currency\\r\\n     * @param amount quantity of underlying currency to deposit\\r\\n     * @param isCallPool whether to deposit underlying in the call pool or base in the put pool\\r\\n\\r\\n     * @param amountOut amount out of tokens requested. If 0, we will swap exact amount necessary to pay the quote\\r\\n     * @param amountInMax amount in max of tokens\\r\\n     * @param path swap path\\r\\n     * @param isSushi whether we use sushi or uniV2 for the swap\\r\\n     */\\r\\n    function swapAndDeposit(\\r\\n        uint256 amount,\\r\\n        bool isCallPool,\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        bool isSushi\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice redeem pool share tokens for underlying asset\\r\\n     * @param amount quantity of share tokens to redeem\\r\\n     * @param isCallPool whether to deposit underlying in the call pool or base in the put pool\\r\\n     */\\r\\n    function withdraw(uint256 amount, bool isCallPool) external;\\r\\n\\r\\n    /**\\r\\n     * @notice reassign short position to new underwriter\\r\\n     * @param tokenId ERC1155 token id (long or short)\\r\\n     * @param contractSize quantity of option contract tokens to reassign\\r\\n     * @return baseCost quantity of tokens required to reassign short position\\r\\n     * @return feeCost quantity of tokens required to pay fees\\r\\n     * @return amountOut quantity of liquidity freed and transferred to owner\\r\\n     */\\r\\n    function reassign(uint256 tokenId, uint256 contractSize)\\r\\n        external\\r\\n        returns (\\r\\n            uint256 baseCost,\\r\\n            uint256 feeCost,\\r\\n            uint256 amountOut\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice reassign set of short position to new underwriter\\r\\n     * @param tokenIds array of ERC1155 token ids (long or short)\\r\\n     * @param contractSizes array of quantities of option contract tokens to reassign\\r\\n     * @return baseCosts quantities of tokens required to reassign each short position\\r\\n     * @return feeCosts quantities of tokens required to pay fees\\r\\n     * @return amountOutCall quantity of call pool liquidity freed and transferred to owner\\r\\n     * @return amountOutPut quantity of put pool liquidity freed and transferred to owner\\r\\n     */\\r\\n    function reassignBatch(\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata contractSizes\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256[] memory baseCosts,\\r\\n            uint256[] memory feeCosts,\\r\\n            uint256 amountOutCall,\\r\\n            uint256 amountOutPut\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice withdraw all free liquidity and reassign set of short position to new underwriter\\r\\n     * @param isCallPool true for call, false for put\\r\\n     * @param tokenIds array of ERC1155 token ids (long or short)\\r\\n     * @param contractSizes array of quantities of option contract tokens to reassign\\r\\n     * @return baseCosts quantities of tokens required to reassign each short position\\r\\n     * @return feeCosts quantities of tokens required to pay fees\\r\\n     * @return amountOutCall quantity of call pool liquidity freed and transferred to owner\\r\\n     * @return amountOutPut quantity of put pool liquidity freed and transferred to owner\\r\\n     */\\r\\n    function withdrawAllAndReassignBatch(\\r\\n        bool isCallPool,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata contractSizes\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256[] memory baseCosts,\\r\\n            uint256[] memory feeCosts,\\r\\n            uint256 amountOutCall,\\r\\n            uint256 amountOutPut\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice transfer accumulated fees to the fee receiver\\r\\n     * @return amountOutCall quantity of underlying tokens transferred\\r\\n     * @return amountOutPut quantity of base tokens transferred\\r\\n     */\\r\\n    function withdrawFees()\\r\\n        external\\r\\n        returns (uint256 amountOutCall, uint256 amountOutPut);\\r\\n\\r\\n    /**\\r\\n     * @notice burn corresponding long and short option tokens and withdraw collateral\\r\\n     * @param tokenId ERC1155 token id (long or short)\\r\\n     * @param contractSize quantity of option contract tokens to annihilate\\r\\n     */\\r\\n    function annihilate(uint256 tokenId, uint256 contractSize) external;\\r\\n\\r\\n    /**\\r\\n     * @notice claim earned PREMIA emissions\\r\\n     * @param isCallPool true for call, false for put\\r\\n     */\\r\\n    function claimRewards(bool isCallPool) external;\\r\\n\\r\\n    /**\\r\\n     * @notice claim earned PREMIA emissions on behalf of given account\\r\\n     * @param account account on whose behalf to claim rewards\\r\\n     * @param isCallPool true for call, false for put\\r\\n     */\\r\\n    function claimRewards(address account, bool isCallPool) external;\\r\\n\\r\\n    /**\\r\\n     * @notice TODO\\r\\n     */\\r\\n    function updateMiningPools() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IPremiaMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPremiaMaker {\\r\\n    function getCustomPath(address _token)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory);\\r\\n\\r\\n    function getWhitelistedRouters() external view returns (address[] memory);\\r\\n\\r\\n    function convert(address _router, address _token) external;\\r\\n\\r\\n    function withdrawFeesAndConvert(\\r\\n        address _pool,\\r\\n        address _router,\\r\\n        address[] memory _tokens\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata {\\n    /**\\n     * @notice return token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice return token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice return token decimals, generally used only for display purposes\\n     * @return token decimals\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_premiaStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premiaAmount\",\"type\":\"uint256\"}],\"name\":\"Converted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addr\",\"type\":\"address[]\"}],\"name\":\"addWhitelistedRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"convert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getCustomPath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistedRouters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addr\",\"type\":\"address[]\"}],\"name\":\"removeWhitelistedRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"setCustomPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawFeesAndConvert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PremiaMaker","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000f1bb87563a122211d40d393ebf1c633c330377f9000000000000000000000000c22fae86443aeed038a4ed887bba8f5035fd12f0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}