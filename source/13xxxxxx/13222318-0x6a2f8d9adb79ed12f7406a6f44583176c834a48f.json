{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Blob.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n//Custom utils for Blob\\r\\nimport \\\"./BlobGenerator.sol\\\";\\r\\n\\r\\ncontract Blob is ERC721Enumerable, Ownable, BlobGenerator {\\r\\n  // price per blob 0.08\\r\\n  uint256 public constant NFT_PRICE = 80000000000000000;\\r\\n  // discount price per. discount when minting >= 8;\\r\\n  uint256 public constant NFT_DISCOUNT_PRICE = 50000000000000000;\\r\\n  uint256 public constant NFT_DISCOUNT_THRESHOLD = 8;\\r\\n\\r\\n  // max supply\\r\\n  uint256 public constant MAX_SUPPLY = 8108;\\r\\n\\r\\n  constructor(string memory name, string memory symbol)\\r\\n    ERC721(name, symbol)\\r\\n    BlobGenerator()\\r\\n  {\\r\\n    //owner gets first 10\\r\\n    for (uint256 i = 0; i < 10; i++) {\\r\\n      _safeMint(_msgSender(), totalSupply());\\r\\n    }\\r\\n  }\\r\\n\\r\\n  //smart minting: \\\"try\\\" to mint up to a number requested then return change\\r\\n  function mint(uint256 numberToMint) public payable {\\r\\n    require(totalSupply() < MAX_SUPPLY, \\\"Blobs are sold out!!\\\");\\r\\n    require(numberToMint > 0, \\\"At least 1 should be minted\\\");\\r\\n\\r\\n    uint256 _msgValue = msg.value;\\r\\n    uint256 _unitPrice = NFT_PRICE;\\r\\n\\r\\n    //check if discount applies\\r\\n    if (numberToMint >= NFT_DISCOUNT_THRESHOLD) {\\r\\n      _unitPrice = NFT_DISCOUNT_PRICE;\\r\\n    }\\r\\n\\r\\n    require(_msgValue >= numberToMint * _unitPrice, \\\"Requires more funding\\\");\\r\\n\\r\\n    uint256 numberMinted = 0;\\r\\n    do {\\r\\n      _safeMint(_msgSender(), totalSupply());\\r\\n      numberMinted++;\\r\\n    } while (numberMinted < numberToMint && totalSupply() < MAX_SUPPLY);\\r\\n\\r\\n    uint256 payment = numberMinted * _unitPrice;\\r\\n    uint256 remainder = _msgValue - payment;\\r\\n    if (remainder > 0) {\\r\\n      //return any change\\r\\n      payable(_msgSender()).transfer(remainder);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function withdraw() public onlyOwner {\\r\\n    uint256 balance = address(this).balance;\\r\\n    payable(_msgSender()).transfer(balance);\\r\\n  }\\r\\n\\r\\n  function tokenURI(uint256 tokenId)\\r\\n    public\\r\\n    view\\r\\n    override\\r\\n    returns (string memory)\\r\\n  {\\r\\n    require(\\r\\n      _exists(tokenId),\\r\\n      \\\"ERC721Metadata: URI query for nonexistent token\\\"\\r\\n    );\\r\\n    return generateTokenURI(tokenId);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BlobGenerator.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./Color.sol\\\";\\r\\nimport \\\"./Base64.sol\\\";\\r\\nimport \\\"./PRBMathSD59x18.sol\\\";\\r\\n\\r\\ncontract BlobGenerator {\\r\\n  constructor() {}\\r\\n\\r\\n  using PRBMathSD59x18 for int256;\\r\\n\\r\\n  struct Points {\\r\\n    int256 x;\\r\\n    int256 y;\\r\\n  }\\r\\n\\r\\n  function uintToStr(uint256 v) private pure returns (string memory) {\\r\\n    uint256 maxlength = 100;\\r\\n    bytes memory reversed = new bytes(maxlength);\\r\\n    uint256 i = 0;\\r\\n\\r\\n    if (v == 0) {\\r\\n      return \\\"0\\\";\\r\\n    }\\r\\n\\r\\n    while (v != 0) {\\r\\n      uint256 remainder = v % 10;\\r\\n      v = v / 10;\\r\\n      reversed[i % maxlength] = bytes1(uint8(48 + remainder));\\r\\n      i++;\\r\\n    }\\r\\n    bytes memory s = new bytes(i);\\r\\n    for (uint256 j = 1; j <= i % maxlength; j++) {\\r\\n      s[j - 1] = reversed[i - j];\\r\\n    }\\r\\n    return string(s);\\r\\n  }\\r\\n\\r\\n  function intToStr(int256 v) private pure returns (string memory) {\\r\\n    uint256 maxlength = 100;\\r\\n    bytes memory reversed = new bytes(maxlength);\\r\\n    uint256 i = 0;\\r\\n    uint256 x;\\r\\n\\r\\n    if (v == 0) {\\r\\n      return \\\"0\\\";\\r\\n    }\\r\\n\\r\\n    if (v < 0) x = uint256(-v);\\r\\n    else x = uint256(v);\\r\\n    while (x != 0) {\\r\\n      uint256 remainder = uint256(x % 10);\\r\\n      x = x / 10;\\r\\n      reversed[i % maxlength] = bytes1(uint8(48 + remainder));\\r\\n      i++;\\r\\n    }\\r\\n    if (v < 0) reversed[(i++) % maxlength] = \\\"-\\\";\\r\\n    bytes memory s = new bytes(i);\\r\\n    for (uint256 j = 1; j <= i % maxlength; j++) {\\r\\n      s[j - 1] = reversed[i - j];\\r\\n    }\\r\\n    return string(s);\\r\\n  }\\r\\n\\r\\n  function fromInt(int256 original) private pure returns (int256) {\\r\\n    return PRBMathSD59x18.fromInt(original);\\r\\n  }\\r\\n\\r\\n  function fromUInt(uint256 original) private pure returns (int256) {\\r\\n    return fromInt(int256(original));\\r\\n  }\\r\\n\\r\\n  function pi() internal pure returns (int256) {\\r\\n    return PRBMathSD59x18.pi();\\r\\n  }\\r\\n\\r\\n  function generateZeroPad(uint256 size) private pure returns (string memory) {\\r\\n    bytes memory padding = new bytes(size);\\r\\n\\r\\n    for (uint256 i = 0; i < size; i++) {\\r\\n      padding[i] = \\\"0\\\";\\r\\n    }\\r\\n\\r\\n    return string(padding);\\r\\n  }\\r\\n\\r\\n  function padFraction(int256 fraction) private pure returns (string memory) {\\r\\n    bytes memory fractionString = bytes(abi.encodePacked(intToStr(fraction)));\\r\\n\\r\\n    uint256 padSize = 18 - fractionString.length;\\r\\n    string memory paddedFraction = concatToString(\\r\\n      generateZeroPad(padSize),\\r\\n      string(fractionString)\\r\\n    );\\r\\n\\r\\n    return paddedFraction;\\r\\n  }\\r\\n\\r\\n  function toPrecision(string memory fraction, uint256 precision)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    bytes memory fractionBytes = bytes(fraction);\\r\\n    bytes memory result = new bytes(precision);\\r\\n    for (uint256 i = 0; i < precision; i++) {\\r\\n      result[i] = fractionBytes[0];\\r\\n    }\\r\\n\\r\\n    return string(abi.encodePacked(\\\".\\\", string(result)));\\r\\n  }\\r\\n\\r\\n  function toDecimalString(int256 fixedInt, uint256 precision)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    int256 fraction = fixedInt.frac();\\r\\n    int256 exponent = fixedInt.toInt();\\r\\n    string memory expStr = intToStr(exponent);\\r\\n    if (fixedInt < 0) {\\r\\n      fraction = fraction.mul(fromInt(-1));\\r\\n      if (exponent == 0) {\\r\\n        expStr = \\\"-\\\";\\r\\n      }\\r\\n    }\\r\\n\\r\\n    string memory paddedFraction = padFraction(fraction);\\r\\n    return\\r\\n      string(abi.encodePacked(expStr, toPrecision(paddedFraction, precision)));\\r\\n  }\\r\\n\\r\\n  function toDecimalString(int256 exponent)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return toDecimalString(exponent, 3);\\r\\n  }\\r\\n\\r\\n  function getSeed(string memory feature, uint256 tokenId)\\r\\n    private\\r\\n    pure\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return uint256(keccak256(abi.encodePacked(feature, tokenId)));\\r\\n  }\\r\\n\\r\\n  function random(\\r\\n    uint256 seed,\\r\\n    uint256 start,\\r\\n    uint256 end\\r\\n  ) private pure returns (uint256) {\\r\\n    return (seed % (end - start + 1)) + start;\\r\\n  }\\r\\n\\r\\n  function concatToString(string memory A, string memory B)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return string(abi.encodePacked(A, B));\\r\\n  }\\r\\n\\r\\n  function sin(int256 degrees) private pure returns (int256) {\\r\\n    int256 x = degrees % fromInt(180);\\r\\n    int256 dividend = fromInt(4).mul(x).mul(fromInt(180) - x);\\r\\n    int256 divisor = fromInt(40500) - x.mul(fromInt(180) - x);\\r\\n\\r\\n    int256 result = dividend.div(divisor);\\r\\n    return degrees > fromInt(180) ? result.mul(fromInt(-1)) : result;\\r\\n  }\\r\\n\\r\\n  function cos(int256 degrees) private pure returns (int256) {\\r\\n    return sin(degrees - fromInt(90));\\r\\n  }\\r\\n\\r\\n  function addToIArray(int256[] memory original, int256 newItem)\\r\\n    private\\r\\n    pure\\r\\n    returns (int256[] memory)\\r\\n  {\\r\\n    int256[] memory newArray = new int256[](original.length + 1);\\r\\n\\r\\n    for (uint256 i = 0; i < original.length; i++) {\\r\\n      newArray[i] = original[i];\\r\\n    }\\r\\n\\r\\n    newArray[original.length] = newItem;\\r\\n\\r\\n    return newArray;\\r\\n  }\\r\\n\\r\\n  //pull should be in 59.18 int\\r\\n  function createPoints(\\r\\n    string memory prefix,\\r\\n    uint256 tokenId,\\r\\n    uint256 numPoints,\\r\\n    uint256 radius\\r\\n  ) private pure returns (Points[] memory) {\\r\\n    Points[] memory pointsArr = new Points[](numPoints);\\r\\n\\r\\n    int256 angleStep = fromInt(360).div(fromUInt(numPoints));\\r\\n    // console.log(\\\"rad step\\\",toDecimalString(angleStep));\\r\\n    for (uint256 i = 1; i <= numPoints; i++) {\\r\\n      //random pull;\\r\\n      int256 pull = fromUInt(\\r\\n        random(\\r\\n          getSeed(\\r\\n            string(abi.encodePacked(prefix, \\\"PULL\\\", uintToStr(i))),\\r\\n            tokenId\\r\\n          ),\\r\\n          5,\\r\\n          15\\r\\n        )\\r\\n      ).div(fromInt(10));\\r\\n\\r\\n      int256 x = fromInt(200) +\\r\\n        cos(fromUInt(i).mul(angleStep)).mul(fromUInt(radius).mul(pull));\\r\\n      int256 y = fromInt(200) +\\r\\n        sin(fromUInt(i).mul(angleStep)).mul(fromUInt(radius).mul(pull));\\r\\n\\r\\n      pointsArr[i - 1] = Points(x, y);\\r\\n    }\\r\\n\\r\\n    return pointsArr;\\r\\n  }\\r\\n\\r\\n  function loopPoints(Points[] memory pointsArr)\\r\\n    private\\r\\n    pure\\r\\n    returns (Points[] memory)\\r\\n  {\\r\\n    Points memory lastPoint = pointsArr[pointsArr.length - 1];\\r\\n    Points memory secondToLastPoint = pointsArr[pointsArr.length - 2];\\r\\n\\r\\n    Points memory firstPoint = pointsArr[0];\\r\\n    Points memory secondPoint = pointsArr[1];\\r\\n\\r\\n    Points[] memory loopedPoints = new Points[](pointsArr.length + 4);\\r\\n\\r\\n    // console.log(\\\"loopedPoints\\\");\\r\\n    loopedPoints[0] = secondToLastPoint;\\r\\n    loopedPoints[1] = lastPoint;\\r\\n    // console.log(toDecimalString(loopedPoints[0].x),toDecimalString(loopedPoints[0].y));\\r\\n    // onsole.log(toDecimalString(loopedPoints[1].x),toDecimalString(loopedPoints[1].y));\\r\\n\\r\\n    //TODO missing points\\r\\n    for (uint256 i = 0; i < pointsArr.length; i++) {\\r\\n      loopedPoints[i + 2] = pointsArr[i];\\r\\n      // console.log(toDecimalString(loopedPoints[i+2].x),toDecimalString(loopedPoints[i+2].y));\\r\\n    }\\r\\n\\r\\n    loopedPoints[loopedPoints.length - 2] = firstPoint;\\r\\n    loopedPoints[loopedPoints.length - 1] = secondPoint;\\r\\n    // console.log(toDecimalString(loopedPoints[loopedPoints.length - 2].x),toDecimalString(loopedPoints[loopedPoints.length - 2].y));\\r\\n    // console.log(toDecimalString(loopedPoints[loopedPoints.length - 1].x),toDecimalString(loopedPoints[loopedPoints.length - 1].y));\\r\\n\\r\\n    return loopedPoints;\\r\\n  }\\r\\n\\r\\n  function concatStringArray(string[] memory stringArr)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    string memory result = stringArr[0];\\r\\n\\r\\n    for (uint256 i = 1; i < stringArr.length; i++) {\\r\\n      result = string(abi.encodePacked(result, stringArr[i]));\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  function generateCPath(\\r\\n    Points[] memory pointsArr,\\r\\n    uint256 startIteration,\\r\\n    uint256 maxIteration,\\r\\n    uint256 tension\\r\\n  ) private pure returns (string memory) {\\r\\n    Points[] memory cPathPoints = new Points[](2);\\r\\n    string[] memory pathParts = new string[](12);\\r\\n    string memory cPathString = \\\"\\\";\\r\\n\\r\\n    for (uint256 i = startIteration; i < maxIteration; i++) {\\r\\n      //TODO BUGGED\\r\\n      Points memory p0 = i > 0 ? pointsArr[i - startIteration] : pointsArr[0];\\r\\n      Points memory p1 = pointsArr[i];\\r\\n      Points memory p2 = pointsArr[i + 1];\\r\\n      Points memory p3 = i != maxIteration ? pointsArr[i + 2] : p2;\\r\\n\\r\\n      cPathPoints[0].x =\\r\\n        p1.x +\\r\\n        (p2.x - p0.x).div(fromInt(6)).mul(fromUInt(tension));\\r\\n      cPathPoints[0].y =\\r\\n        p1.y +\\r\\n        (p2.y - p0.y).div(fromInt(6)).mul(fromUInt(tension));\\r\\n\\r\\n      cPathPoints[1].x =\\r\\n        p2.x -\\r\\n        (p3.x - p1.x).div(fromInt(6)).mul(fromUInt(tension));\\r\\n      cPathPoints[1].y =\\r\\n        p2.y -\\r\\n        (p3.y - p1.y).div(fromInt(6)).mul(fromUInt(tension));\\r\\n\\r\\n      pathParts[0] = \\\"C\\\";\\r\\n      pathParts[1] = toDecimalString(cPathPoints[0].x);\\r\\n      pathParts[2] = \\\",\\\";\\r\\n      pathParts[3] = toDecimalString(cPathPoints[0].y);\\r\\n      pathParts[4] = \\\",\\\";\\r\\n      pathParts[5] = toDecimalString(cPathPoints[1].x);\\r\\n      pathParts[6] = \\\",\\\";\\r\\n      pathParts[7] = toDecimalString(cPathPoints[1].y);\\r\\n      pathParts[8] = \\\",\\\";\\r\\n      pathParts[9] = toDecimalString(p2.x);\\r\\n      pathParts[10] = \\\",\\\";\\r\\n      pathParts[11] = toDecimalString(p2.y);\\r\\n      cPathString = concatToString(cPathString, concatStringArray(pathParts));\\r\\n    }\\r\\n\\r\\n    return cPathString;\\r\\n  }\\r\\n\\r\\n  function closedSpline(Points[] memory pointsArr, uint256 tension)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    Points[] memory loopedPoints = loopPoints(pointsArr);\\r\\n\\r\\n    //start with M path\\r\\n    string memory path = string(\\r\\n      abi.encodePacked(\\r\\n        \\\"M\\\",\\r\\n        toDecimalString(loopedPoints[1].x),\\r\\n        \\\",\\\",\\r\\n        toDecimalString(loopedPoints[1].y)\\r\\n      )\\r\\n    );\\r\\n\\r\\n    //issueswith pointsArr arithmetic\\r\\n    path = concatToString(\\r\\n      path,\\r\\n      generateCPath(loopedPoints, 1, loopedPoints.length - 2, tension)\\r\\n    );\\r\\n    return path;\\r\\n  }\\r\\n\\r\\n  function generateFilter(string memory spread)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '<filter id=\\\"lightSource\\\">',\\r\\n          '<feTurbulence type=\\\"turbulence\\\" baseFrequency=\\\"0.05\\\" numOctaves=\\\"10\\\" result=\\\"turbulence\\\"/>',\\r\\n          '<feDisplacementMap in2=\\\"turbulence\\\" in=\\\"SourceGraphic\\\" scale=\\\"',\\r\\n          spread,\\r\\n          '\\\" result=\\\"turbResult\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"G\\\"/>',\\r\\n          \\\"</filter>\\\"\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateStopColor(string memory color1, string memory color2)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '<stop offset=\\\"0%\\\" stop-opacity=\\\"1\\\" stop-color=\\\"',\\r\\n          color1,\\r\\n          '\\\" />',\\r\\n          '<stop offset=\\\"100%\\\" stop-opacity=\\\"1\\\" stop-color=\\\"',\\r\\n          color2,\\r\\n          '\\\" />'\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateGradients(\\r\\n    string memory speed,\\r\\n    string memory color1,\\r\\n    string memory color2,\\r\\n    string memory color3,\\r\\n    string memory color4\\r\\n  ) private pure returns (string memory) {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '<linearGradient id=\\\"grad0\\\">'\\r\\n          '<animateTransform attributeName=\\\"gradientTransform\\\" attributeType=\\\"XML\\\" type=\\\"rotate\\\" from=\\\"0 0.5 0.5\\\" to=\\\"-360 0.5 0.5\\\" dur=\\\"',\\r\\n          speed,\\r\\n          's\\\" repeatCount=\\\"indefinite\\\"/>',\\r\\n          generateStopColor(color1, color2),\\r\\n          \\\"</linearGradient>\\\",\\r\\n          '<linearGradient id=\\\"grad1\\\">',\\r\\n          '<animateTransform attributeName=\\\"gradientTransform\\\" attributeType=\\\"XML\\\" type=\\\"rotate\\\" from=\\\"0 0.5 0.5\\\" to=\\\"360 0.5 0.5\\\" dur=\\\"',\\r\\n          speed,\\r\\n          's\\\" repeatCount=\\\"indefinite\\\"/>',\\r\\n          generateStopColor(color3, color4),\\r\\n          \\\"</linearGradient>\\\"\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateBackground() private pure returns (string memory) {\\r\\n    return '<rect width=\\\"400\\\" height=\\\"400\\\" fill=\\\"url(#grad0)\\\"/>';\\r\\n  }\\r\\n\\r\\n  function generatePath(\\r\\n    string memory path,\\r\\n    string memory objectSpeed,\\r\\n    string memory objectRotation\\r\\n  ) private pure returns (string memory) {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          \\\"<g>\\\",\\r\\n          '<animateTransform attributeName=\\\"transform\\\" attributeType=\\\"XML\\\" type=\\\"rotate\\\" from=\\\"0 200 200\\\" to=\\\"360 200 200\\\" dur=\\\"',\\r\\n          objectRotation,\\r\\n          's\\\" repeatCount=\\\"indefinite\\\"/>',\\r\\n          '<path id=\\\"path\\\" fill=\\\"url(#grad1)\\\" filter=\\\"url(#lightSource)\\\">',\\r\\n          '<animate repeatCount=\\\"indefinite\\\" attributeName=\\\"d\\\" values=\\\"',\\r\\n          path,\\r\\n          '\\\" dur=\\\"',\\r\\n          objectSpeed,\\r\\n          's\\\"/>',\\r\\n          \\\"</path></g>\\\"\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateSVG(string memory dPath, Features memory features)\\r\\n    private\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 400 400\\\">',\\r\\n          generateFilter(features.colorFeatures[0]),\\r\\n          generateGradients(\\r\\n            features.colorFeatures[1],\\r\\n            features.colors[0],\\r\\n            features.colors[1],\\r\\n            features.colors[2],\\r\\n            features.colors[3]\\r\\n          ),\\r\\n          generateBackground(),\\r\\n          generatePath(\\r\\n            dPath,\\r\\n            features.colorFeatures[2],\\r\\n            features.colorFeatures[3]\\r\\n          ),\\r\\n          \\\"</svg>\\\"\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateColors(uint256 tokenId)\\r\\n    private\\r\\n    pure\\r\\n    returns (string[] memory)\\r\\n  {\\r\\n    string[] memory colors = new string[](4);\\r\\n    colors[0] = Color.generateColorHexCode(\\\"COLOR1\\\", tokenId);\\r\\n    colors[1] = Color.generateColorHexCode(\\\"COLOR2\\\", tokenId);\\r\\n    colors[2] = Color.generateColorHexCode(\\\"COLOR3\\\", tokenId);\\r\\n    colors[3] = Color.generateColorHexCode(\\\"COLOR4\\\", tokenId);\\r\\n    return colors;\\r\\n  }\\r\\n\\r\\n  function generateColorFeatures(uint256 tokenId)\\r\\n    private\\r\\n    pure\\r\\n    returns (string[] memory)\\r\\n  {\\r\\n    string[] memory colorFeatures = new string[](4);\\r\\n\\r\\n    uint256 speed2 = random(getSeed(\\\"SPEED2\\\", tokenId), 1, 20);\\r\\n    colorFeatures[0] = uintToStr(random(getSeed(\\\"SPREAD\\\", tokenId), 0, 20));\\r\\n    colorFeatures[1] = uintToStr(random(getSeed(\\\"SPEED1\\\", tokenId), 5, 20));\\r\\n    colorFeatures[2] = uintToStr(speed2);\\r\\n    colorFeatures[3] = uintToStr(speed2 * 5);\\r\\n\\r\\n    return colorFeatures;\\r\\n  }\\r\\n\\r\\n  function generateDPath(\\r\\n    uint256 tokenId,\\r\\n    uint256 numPoints,\\r\\n    uint256 numFrames,\\r\\n    uint256 radius\\r\\n  ) private pure returns (string memory) {\\r\\n    string memory firstFrame;\\r\\n    string memory dPath;\\r\\n\\r\\n    for (uint256 i = 0; i < numFrames; i++) {\\r\\n      Points[] memory pointsArr = createPoints(\\r\\n        uintToStr(i),\\r\\n        tokenId,\\r\\n        numPoints,\\r\\n        radius\\r\\n      );\\r\\n      dPath = concatToString(dPath, closedSpline(pointsArr, 1));\\r\\n      if (i == 0) firstFrame = dPath;\\r\\n      dPath = concatToString(dPath, \\\";\\\");\\r\\n    }\\r\\n    //add back first frame\\r\\n    dPath = concatToString(dPath, firstFrame);\\r\\n    return dPath;\\r\\n  }\\r\\n\\r\\n  function generateBlobFeatures(uint256 tokenId)\\r\\n    private\\r\\n    pure\\r\\n    returns (uint256[] memory)\\r\\n  {\\r\\n    uint256[] memory blobFeatures = new uint256[](3);\\r\\n\\r\\n    uint256 maxPoints = 11;\\r\\n    uint256 minPoints = 3;\\r\\n    uint256 numPoints = random(\\r\\n      getSeed(\\\"NUMPOINTS\\\", tokenId),\\r\\n      minPoints,\\r\\n      maxPoints\\r\\n    );\\r\\n    uint256 numFrames = 5;\\r\\n    uint256 radius = random(getSeed(\\\"RADIUS\\\", tokenId), 25, 100);\\r\\n\\r\\n    blobFeatures[0] = numPoints;\\r\\n    blobFeatures[1] = numFrames;\\r\\n    blobFeatures[2] = radius;\\r\\n    return blobFeatures;\\r\\n  }\\r\\n\\r\\n  struct Features {\\r\\n    string[] colors;\\r\\n    string[] colorFeatures;\\r\\n    uint256[] blobFeatures;\\r\\n  }\\r\\n\\r\\n  struct JSONMeta {\\r\\n    string texture;\\r\\n    string energy;\\r\\n    string blob_color_1;\\r\\n    string blob_color_2;\\r\\n    string back_color_1;\\r\\n    string back_color_2;\\r\\n    string close;\\r\\n  }\\r\\n\\r\\n  function generateColorFeatures(Features memory features)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '{\\\"trait_type\\\":\\\"Blob color #1\\\",\\\"value\\\":\\\"',\\r\\n          features.colors[2],\\r\\n          '\\\"},',\\r\\n          '{\\\"trait_type\\\":\\\"Blob color #2\\\",\\\"value\\\":\\\"',\\r\\n          features.colors[3],\\r\\n          '\\\"},',\\r\\n          '{\\\"trait_type\\\":\\\"Background color #1\\\",\\\"value\\\":\\\"',\\r\\n          features.colors[0],\\r\\n          '\\\"},',\\r\\n          '{\\\"trait_type\\\":\\\"Background color #2\\\",\\\"value\\\":\\\"',\\r\\n          features.colors[1]\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateColorAttributes(Features memory features)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '{\\\"trait_type\\\":\\\"Texture\\\",\\\"value\\\":',\\r\\n          features.colorFeatures[0],\\r\\n          \\\"},\\\",\\r\\n          '{\\\"trait_type\\\":\\\"Energy\\\",\\\"value\\\":',\\r\\n          features.colorFeatures[2],\\r\\n          \\\"},\\\",\\r\\n          generateColorFeatures(features),\\r\\n          '\\\"}'\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateAttributes(Features memory features)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          '\\\"attributes\\\": [',\\r\\n          '{\\\"trait_type\\\":\\\"Entropy\\\",\\\"value\\\":',\\r\\n          uintToStr(features.blobFeatures[0]),\\r\\n          \\\"},\\\",\\r\\n          '{\\\"trait_type\\\":\\\"Girth\\\",\\\"value\\\":',\\r\\n          uintToStr(features.blobFeatures[2]),\\r\\n          \\\"},\\\",\\r\\n          generateColorAttributes(features),\\r\\n          \\\"]\\\"\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function generateJSONMeta(\\r\\n    Features memory features,\\r\\n    string memory svgData,\\r\\n    uint256 tokenId\\r\\n  ) internal pure returns (string memory) {\\r\\n    string memory jsonMeta = string(\\r\\n      abi.encodePacked(\\r\\n        '{\\\"name\\\": \\\"BLOB #',\\r\\n        uintToStr(tokenId),\\r\\n        '\\\",',\\r\\n        '\\\"description\\\": \\\"8108 (BLOB) is the first on-chain generative animated NFT\\\",',\\r\\n        generateAttributes(features),\\r\\n        \\\",\\\",\\r\\n        '\\\"image\\\": \\\"',\\r\\n        svgData,\\r\\n        '\\\"',\\r\\n        \\\"}\\\"\\r\\n      )\\r\\n    );\\r\\n\\r\\n    return jsonMeta;\\r\\n  }\\r\\n\\r\\n  function generateTokenURI(uint256 tokenId)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    Features memory features;\\r\\n    features.colors = generateColors(tokenId);\\r\\n    features.colorFeatures = generateColorFeatures(tokenId);\\r\\n    features.blobFeatures = generateBlobFeatures(tokenId);\\r\\n\\r\\n    //59.18 int\\r\\n    string memory dPath = generateDPath(\\r\\n      tokenId,\\r\\n      features.blobFeatures[0],\\r\\n      features.blobFeatures[1],\\r\\n      features.blobFeatures[2]\\r\\n    );\\r\\n\\r\\n    string memory svgData = concatToString(\\r\\n      \\\"data:image/svg+xml;base64,\\\",\\r\\n      Base64.encode(bytes(generateSVG(dPath, features)))\\r\\n    );\\r\\n\\r\\n    return\\r\\n      string(\\r\\n        abi.encodePacked(\\r\\n          \\\"data:application/json;base64,\\\",\\r\\n          Base64.encode(bytes(generateJSONMeta(features, svgData, tokenId)))\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Color.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nlibrary Color {\\r\\n  bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n  function generateColorValue(string memory prefix, uint256 tokenId)\\r\\n    private\\r\\n    pure\\r\\n    returns (uint256)\\r\\n  {\\r\\n    return uint256(keccak256(abi.encodePacked(prefix, tokenId))) % 4096;\\r\\n  }\\r\\n\\r\\n  function getColorHexCode(uint256 value)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    uint16 red = uint16((value >> 8) & 0xf);\\r\\n    uint16 green = uint16((value >> 4) & 0xf);\\r\\n    uint16 blue = uint16(value & 0xf);\\r\\n\\r\\n    bytes memory buffer = new bytes(7);\\r\\n\\r\\n    buffer[0] = \\\"#\\\";\\r\\n    buffer[1] = _HEX_SYMBOLS[red];\\r\\n    buffer[2] = _HEX_SYMBOLS[red];\\r\\n    buffer[3] = _HEX_SYMBOLS[green];\\r\\n    buffer[4] = _HEX_SYMBOLS[green];\\r\\n    buffer[5] = _HEX_SYMBOLS[blue];\\r\\n    buffer[6] = _HEX_SYMBOLS[blue];\\r\\n\\r\\n    return string(buffer);\\r\\n  }\\r\\n\\r\\n  function generateColorHexCode(string memory prefix, uint256 tokenId)\\r\\n    internal\\r\\n    pure\\r\\n    returns (string memory)\\r\\n  {\\r\\n    uint256 colorValue = generateColorValue(prefix, tokenId);\\r\\n    return getColorHexCode(colorValue);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n/// @title Base64\\r\\n/// @author Brecht Devos - <brecht@loopring.org>\\r\\n/// @notice Provides a function for encoding some bytes in base64\\r\\nlibrary Base64 {\\r\\n  string internal constant TABLE =\\r\\n    \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\r\\n\\r\\n  function encode(bytes memory data) internal pure returns (string memory) {\\r\\n    if (data.length == 0) return \\\"\\\";\\r\\n\\r\\n    // load the table into memory\\r\\n    string memory table = TABLE;\\r\\n\\r\\n    // multiply by 4/3 rounded up\\r\\n    uint256 encodedLen = 4 * ((data.length + 2) / 3);\\r\\n\\r\\n    // add some extra buffer at the end required for the writing\\r\\n    string memory result = new string(encodedLen + 32);\\r\\n\\r\\n    assembly {\\r\\n      // set the actual output length\\r\\n      mstore(result, encodedLen)\\r\\n\\r\\n      // prepare the lookup table\\r\\n      let tablePtr := add(table, 1)\\r\\n\\r\\n      // input ptr\\r\\n      let dataPtr := data\\r\\n      let endPtr := add(dataPtr, mload(data))\\r\\n\\r\\n      // result ptr, jump over length\\r\\n      let resultPtr := add(result, 32)\\r\\n\\r\\n      // run over the input, 3 bytes at a time\\r\\n      for {\\r\\n\\r\\n      } lt(dataPtr, endPtr) {\\r\\n\\r\\n      } {\\r\\n        dataPtr := add(dataPtr, 3)\\r\\n\\r\\n        // read 3 bytes\\r\\n        let input := mload(dataPtr)\\r\\n\\r\\n        // write 4 characters\\r\\n        mstore(\\r\\n          resultPtr,\\r\\n          shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\r\\n        )\\r\\n        resultPtr := add(resultPtr, 1)\\r\\n        mstore(\\r\\n          resultPtr,\\r\\n          shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\r\\n        )\\r\\n        resultPtr := add(resultPtr, 1)\\r\\n        mstore(\\r\\n          resultPtr,\\r\\n          shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\r\\n        )\\r\\n        resultPtr := add(resultPtr, 1)\\r\\n        mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\\r\\n        resultPtr := add(resultPtr, 1)\\r\\n      }\\r\\n\\r\\n      // padding with '='\\r\\n      switch mod(mload(data), 3)\\r\\n      case 1 {\\r\\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\r\\n      }\\r\\n      case 2 {\\r\\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PRBMathSD59x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\nimport \\\"./PRBMath.sol\\\";\\r\\n\\r\\n/// @title PRBMathSD59x18\\r\\n/// @author Paul Razvan Berg\\r\\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\\r\\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\\r\\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\\r\\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\\r\\nlibrary PRBMathSD59x18 {\\r\\n  /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\\r\\n  int256 internal constant LOG2_E = 1442695040888963407;\\r\\n\\r\\n  /// @dev Half the SCALE number.\\r\\n  int256 internal constant HALF_SCALE = 5e17;\\r\\n\\r\\n  /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\\r\\n  int256 internal constant MAX_SD59x18 =\\r\\n    57896044618658097711785492504343953926634992332820282019728792003956564819967;\\r\\n\\r\\n  /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\\r\\n  int256 internal constant MAX_WHOLE_SD59x18 =\\r\\n    57896044618658097711785492504343953926634992332820282019728000000000000000000;\\r\\n\\r\\n  /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\\r\\n  int256 internal constant MIN_SD59x18 =\\r\\n    -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\r\\n\\r\\n  /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\\r\\n  int256 internal constant MIN_WHOLE_SD59x18 =\\r\\n    -57896044618658097711785492504343953926634992332820282019728000000000000000000;\\r\\n\\r\\n  /// @dev How many trailing decimals can be represented.\\r\\n  int256 internal constant SCALE = 1e18;\\r\\n\\r\\n  /// INTERNAL FUNCTIONS ///\\r\\n\\r\\n  /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\\r\\n  ///\\r\\n  /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers. Works by computing the signs and the absolute values separately.\\r\\n  ///\\r\\n  /// Requirements:\\r\\n  /// - All from \\\"PRBMath.mulDiv\\\".\\r\\n  /// - None of the inputs can be MIN_SD59x18.\\r\\n  /// - The denominator cannot be zero.\\r\\n  /// - The result must fit within int256.\\r\\n  ///\\r\\n  /// Caveats:\\r\\n  /// - All from \\\"PRBMath.mulDiv\\\".\\r\\n  ///\\r\\n  /// @param x The numerator as a signed 59.18-decimal fixed-point number.\\r\\n  /// @param y The denominator as a signed 59.18-decimal fixed-point number.\\r\\n  /// @param result The quotient as a signed 59.18-decimal fixed-point number.\\r\\n  function div(int256 x, int256 y) internal pure returns (int256 result) {\\r\\n    require(\\r\\n      !(x == MIN_SD59x18 || y == MIN_SD59x18),\\r\\n      \\\"PRBMathSD59x18__DivInputTooSmall\\\"\\r\\n    );\\r\\n\\r\\n    // Get hold of the absolute values of x and y.\\r\\n    uint256 ax;\\r\\n    uint256 ay;\\r\\n    unchecked {\\r\\n      ax = x < 0 ? uint256(-x) : uint256(x);\\r\\n      ay = y < 0 ? uint256(-y) : uint256(y);\\r\\n    }\\r\\n\\r\\n    // Compute the absolute value of (x*SCALE)÷y. The result must fit within int256.\\r\\n    uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\\r\\n    require(!(rAbs > uint256(MAX_SD59x18)), \\\"PRBMathSD59x18__DivOverflow\\\");\\r\\n\\r\\n    // Get the signs of x and y.\\r\\n    uint256 sx;\\r\\n    uint256 sy;\\r\\n    assembly {\\r\\n      sx := sgt(x, sub(0, 1))\\r\\n      sy := sgt(y, sub(0, 1))\\r\\n    }\\r\\n\\r\\n    // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\\r\\n    // should be positive. Otherwise, it should be negative.\\r\\n    result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\r\\n  }\\r\\n\\r\\n  /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\\r\\n  /// of the radix point for negative numbers.\\r\\n  /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\r\\n  /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\\r\\n  /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\\r\\n  function frac(int256 x) internal pure returns (int256 result) {\\r\\n    unchecked {\\r\\n      result = x % SCALE;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\\r\\n  ///\\r\\n  /// @dev Requirements:\\r\\n  /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\\r\\n  /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\\r\\n  ///\\r\\n  /// @param x The basic integer to convert.\\r\\n  /// @param result The same number in signed 59.18-decimal fixed-point representation.\\r\\n  function fromInt(int256 x) internal pure returns (int256 result) {\\r\\n    unchecked {\\r\\n      require(!(x < MIN_SD59x18 / SCALE), \\\"PRBMathSD59x18__FromIntUnderflow\\\");\\r\\n      require(!(x > MAX_SD59x18 / SCALE), \\\"PRBMathSD59x18__FromIntOverflow\\\");\\r\\n      result = x * SCALE;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\\r\\n  /// fixed-point number.\\r\\n  ///\\r\\n  /// @dev Variant of \\\"mulDiv\\\" that works with signed numbers and employs constant folding, i.e. the denominator is\\r\\n  /// always 1e18.\\r\\n  ///\\r\\n  /// Requirements:\\r\\n  /// - All from \\\"PRBMath.mulDivFixedPoint\\\".\\r\\n  /// - None of the inputs can be MIN_SD59x18\\r\\n  /// - The result must fit within MAX_SD59x18.\\r\\n  ///\\r\\n  /// Caveats:\\r\\n  /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\r\\n  ///\\r\\n  /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\\r\\n  /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\\r\\n  /// @return result The product as a signed 59.18-decimal fixed-point number.\\r\\n  function mul(int256 x, int256 y) internal pure returns (int256 result) {\\r\\n    require(\\r\\n      !(x == MIN_SD59x18 || y == MIN_SD59x18),\\r\\n      \\\"PRBMathSD59x18__MulInputTooSmall\\\"\\r\\n    );\\r\\n\\r\\n    unchecked {\\r\\n      uint256 ax;\\r\\n      uint256 ay;\\r\\n      ax = x < 0 ? uint256(-x) : uint256(x);\\r\\n      ay = y < 0 ? uint256(-y) : uint256(y);\\r\\n\\r\\n      uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\\r\\n      require(!(rAbs > uint256(MAX_SD59x18)), \\\"PRBMathSD59x18__MulOverflow\\\");\\r\\n\\r\\n      uint256 sx;\\r\\n      uint256 sy;\\r\\n      assembly {\\r\\n        sx := sgt(x, sub(0, 1))\\r\\n        sy := sgt(y, sub(0, 1))\\r\\n      }\\r\\n      result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\\r\\n  function pi() internal pure returns (int256 result) {\\r\\n    result = 3141592653589793238;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\\r\\n  function scale() internal pure returns (int256 result) {\\r\\n    result = SCALE;\\r\\n  }\\r\\n\\r\\n  /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\\r\\n  /// @param x The signed 59.18-decimal fixed-point number to convert.\\r\\n  /// @return result The same number in basic integer form.\\r\\n  function toInt(int256 x) internal pure returns (int256 result) {\\r\\n    unchecked {\\r\\n      result = x / SCALE;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/PRBMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\n/// @notice Emitted when the result overflows uint256.\\r\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\r\\n\\r\\n/// @notice Emitted when the result overflows uint256.\\r\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\r\\n\\r\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\r\\nerror PRBMathSD59x18__DivInputTooSmall();\\r\\n\\r\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\r\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\r\\n\\r\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\r\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\r\\n\\r\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\r\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\r\\n\\r\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\r\\nerror PRBMathSD59x18__MulInputTooSmall();\\r\\n\\r\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\r\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\r\\n\\r\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\r\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\r\\n/// representation. When it does not, it is explictly mentioned in the NatSpec documentation.\\r\\nlibrary PRBMath {\\r\\n  /// STRUCTS ///\\r\\n\\r\\n  struct SD59x18 {\\r\\n    int256 value;\\r\\n  }\\r\\n\\r\\n  struct UD60x18 {\\r\\n    uint256 value;\\r\\n  }\\r\\n\\r\\n  /// STORAGE ///\\r\\n\\r\\n  /// @dev How many trailing decimals can be represented.\\r\\n  uint256 internal constant SCALE = 1e18;\\r\\n\\r\\n  /// @dev Largest power of two divisor of SCALE.\\r\\n  uint256 internal constant SCALE_LPOTD = 262144;\\r\\n\\r\\n  /// @dev SCALE inverted mod 2^256.\\r\\n  uint256 internal constant SCALE_INVERSE =\\r\\n    78156646155174841979727994598816262306175212592076161876661508869554232690281;\\r\\n\\r\\n  /// FUNCTIONS ///\\r\\n\\r\\n  /// @notice Calculates floor(x*y÷denominator) with full precision.\\r\\n  ///\\r\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\r\\n  ///\\r\\n  /// Requirements:\\r\\n  /// - The denominator cannot be zero.\\r\\n  /// - The result must fit within uint256.\\r\\n  ///\\r\\n  /// Caveats:\\r\\n  /// - This function does not work with fixed-point numbers.\\r\\n  ///\\r\\n  /// @param x The multiplicand as an uint256.\\r\\n  /// @param y The multiplier as an uint256.\\r\\n  /// @param denominator The divisor as an uint256.\\r\\n  /// @return result The result as an uint256.\\r\\n  function mulDiv(\\r\\n    uint256 x,\\r\\n    uint256 y,\\r\\n    uint256 denominator\\r\\n  ) internal pure returns (uint256 result) {\\r\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n    // variables such that product = prod1 * 2^256 + prod0.\\r\\n    uint256 prod0; // Least significant 256 bits of the product\\r\\n    uint256 prod1; // Most significant 256 bits of the product\\r\\n    assembly {\\r\\n      let mm := mulmod(x, y, not(0))\\r\\n      prod0 := mul(x, y)\\r\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    // Handle non-overflow cases, 256 by 256 division.\\r\\n    if (prod1 == 0) {\\r\\n      unchecked {\\r\\n        result = prod0 / denominator;\\r\\n      }\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n    require(!(prod1 >= denominator), \\\"PRBMath__MulDivOverflow\\\");\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    // 512 by 256 division.\\r\\n    ///////////////////////////////////////////////\\r\\n\\r\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n    uint256 remainder;\\r\\n    assembly {\\r\\n      // Compute remainder using mulmod.\\r\\n      remainder := mulmod(x, y, denominator)\\r\\n\\r\\n      // Subtract 256 bit number from 512 bit number.\\r\\n      prod1 := sub(prod1, gt(remainder, prod0))\\r\\n      prod0 := sub(prod0, remainder)\\r\\n    }\\r\\n\\r\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n    // See https://cs.stackexchange.com/q/138556/92363.\\r\\n    unchecked {\\r\\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n      uint256 lpotdod = denominator & (~denominator + 1);\\r\\n      assembly {\\r\\n        // Divide denominator by lpotdod.\\r\\n        denominator := div(denominator, lpotdod)\\r\\n\\r\\n        // Divide [prod1 prod0] by lpotdod.\\r\\n        prod0 := div(prod0, lpotdod)\\r\\n\\r\\n        // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\r\\n        lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\r\\n      }\\r\\n\\r\\n      // Shift in bits from prod1 into prod0.\\r\\n      prod0 |= prod1 * lpotdod;\\r\\n\\r\\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n      // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n      uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n      // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n      // in modular arithmetic, doubling the correct bits in each step.\\r\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n      // is no longer required.\\r\\n      result = prod0 * inverse;\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates floor(x*y÷1e18) with full precision.\\r\\n  ///\\r\\n  /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\r\\n  /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\r\\n  /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\r\\n  ///\\r\\n  /// Requirements:\\r\\n  /// - The result must fit within uint256.\\r\\n  ///\\r\\n  /// Caveats:\\r\\n  /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\r\\n  /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\r\\n  ///     1. x * y = type(uint256).max * SCALE\\r\\n  ///     2. (x * y) % SCALE >= SCALE / 2\\r\\n  ///\\r\\n  /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\r\\n  /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\r\\n  /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\r\\n  function mulDivFixedPoint(uint256 x, uint256 y)\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256 result)\\r\\n  {\\r\\n    uint256 prod0;\\r\\n    uint256 prod1;\\r\\n    assembly {\\r\\n      let mm := mulmod(x, y, not(0))\\r\\n      prod0 := mul(x, y)\\r\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    require(!(prod1 >= SCALE), \\\"PRBMath__MulDivFixedPointOverflow\\\");\\r\\n\\r\\n    uint256 remainder;\\r\\n    uint256 roundUpUnit;\\r\\n    assembly {\\r\\n      remainder := mulmod(x, y, SCALE)\\r\\n      roundUpUnit := gt(remainder, 499999999999999999)\\r\\n    }\\r\\n\\r\\n    if (prod1 == 0) {\\r\\n      unchecked {\\r\\n        result = (prod0 / SCALE) + roundUpUnit;\\r\\n        return result;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    assembly {\\r\\n      result := add(\\r\\n        mul(\\r\\n          or(\\r\\n            div(sub(prod0, remainder), SCALE_LPOTD),\\r\\n            mul(\\r\\n              sub(prod1, gt(remainder, prod0)),\\r\\n              add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1)\\r\\n            )\\r\\n          ),\\r\\n          SCALE_INVERSE\\r\\n        ),\\r\\n        roundUpUnit\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_DISCOUNT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_DISCOUNT_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberToMint\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Blob","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000005424c4f42530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004424c4f4200000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}