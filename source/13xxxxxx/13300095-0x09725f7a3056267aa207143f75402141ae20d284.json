{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/0xerc1155/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\ninterface IERC1155 {\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _id,\\n    uint256 _amount\\n  );\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256[] _ids,\\n    uint256[] _amounts\\n  );\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\\n   * @dev MUST emit TransferSingle event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @dev MUST emit TransferBatch event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeBatchTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner's balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    external\\n    view\\n    returns (bool isOperator);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(\\n    address _operator,\\n    address _from,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(\\n    address _operator,\\n    address _from,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/tokens/ERC1155/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport '../../interfaces/IERC1155TokenReceiver.sol';\\nimport '../../utils/ERC165.sol';\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC165, IERC1155TokenReceiver {\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address,\\n    address,\\n    uint256[] memory,\\n    uint256[] memory,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  function supportsInterface(bytes4 _interfaceID)\\n    public\\n    pure\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    if (_interfaceID == type(IERC1155TokenReceiver).interfaceId) {\\n      return true;\\n    }\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\nabstract contract ERC165 {\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID)\\n    public\\n    pure\\n    virtual\\n    returns (bool)\\n  {\\n    return _interfaceID == this.supportsInterface.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath#mul: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, 'SafeMath#div: DIVISION_BY_ZERO');\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, 'SafeMath#sub: UNDERFLOW');\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two unsigned integers, reverts on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath#add: OVERFLOW');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n   * reverts when dividing by zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'SafeMath#mod: DIVISION_BY_ZERO');\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/polygonFx/lib/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nlibrary Merkle {\\n  function checkMembership(\\n    bytes32 leaf,\\n    uint256 index,\\n    bytes32 rootHash,\\n    bytes memory proof\\n  ) internal pure returns (bool) {\\n    require(proof.length % 32 == 0, 'Invalid proof length');\\n    uint256 proofHeight = proof.length / 32;\\n    // Proof of size n means, height of the tree is n+1.\\n    // In a tree of height n+1, max #leafs possible is 2 ^ n\\n    require(index < 2**proofHeight, 'Leaf index is too big');\\n\\n    bytes32 proofElement;\\n    bytes32 computedHash = leaf;\\n    for (uint256 i = 32; i <= proof.length; i += 32) {\\n      assembly {\\n        proofElement := mload(add(proof, i))\\n      }\\n\\n      if (index % 2 == 0) {\\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n      } else {\\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n      }\\n\\n      index = index / 2;\\n    }\\n    return computedHash == rootHash;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/polygonFx/lib/MerklePatriciaProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport { RLPReader } from './RLPReader.sol';\\n\\nlibrary MerklePatriciaProof {\\n  /*\\n   * @dev Verifies a merkle patricia proof.\\n   * @param value The terminating value in the trie.\\n   * @param encodedPath The path in the trie leading to value.\\n   * @param rlpParentNodes The rlp encoded stack of nodes.\\n   * @param root The root hash of the trie.\\n   * @return The boolean validity of the proof.\\n   */\\n  function verify(\\n    bytes memory value,\\n    bytes memory encodedPath,\\n    bytes memory rlpParentNodes,\\n    bytes32 root\\n  ) internal pure returns (bool) {\\n    RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n    RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n    bytes memory currentNode;\\n    RLPReader.RLPItem[] memory currentNodeList;\\n\\n    bytes32 nodeKey = root;\\n    uint256 pathPtr = 0;\\n\\n    bytes memory path = _getNibbleArray(encodedPath);\\n    if (path.length == 0) {\\n      return false;\\n    }\\n\\n    for (uint256 i = 0; i < parentNodes.length; i++) {\\n      if (pathPtr > path.length) {\\n        return false;\\n      }\\n\\n      currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n      if (nodeKey != keccak256(currentNode)) {\\n        return false;\\n      }\\n      currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n      if (currentNodeList.length == 17) {\\n        if (pathPtr == path.length) {\\n          if (\\n            keccak256(RLPReader.toBytes(currentNodeList[16])) ==\\n            keccak256(value)\\n          ) {\\n            return true;\\n          } else {\\n            return false;\\n          }\\n        }\\n\\n        uint8 nextPathNibble = uint8(path[pathPtr]);\\n        if (nextPathNibble > 16) {\\n          return false;\\n        }\\n        nodeKey = bytes32(\\n          RLPReader.toUintStrict(currentNodeList[nextPathNibble])\\n        );\\n        pathPtr += 1;\\n      } else if (currentNodeList.length == 2) {\\n        uint256 traversed = _nibblesToTraverse(\\n          RLPReader.toBytes(currentNodeList[0]),\\n          path,\\n          pathPtr\\n        );\\n        if (pathPtr + traversed == path.length) {\\n          //leaf node\\n          if (\\n            keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)\\n          ) {\\n            return true;\\n          } else {\\n            return false;\\n          }\\n        }\\n\\n        //extension node\\n        if (traversed == 0) {\\n          return false;\\n        }\\n\\n        pathPtr += traversed;\\n        nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n      } else {\\n        return false;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function _nibblesToTraverse(\\n    bytes memory encodedPartialPath,\\n    bytes memory path,\\n    uint256 pathPtr\\n  ) private pure returns (uint256) {\\n    uint256 len = 0;\\n    // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n    // and slicedPath have elements that are each one hex character (1 nibble)\\n    bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n    bytes memory slicedPath = new bytes(partialPath.length);\\n\\n    // pathPtr counts nibbles in path\\n    // partialPath.length is a number of nibbles\\n    for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n      bytes1 pathNibble = path[i];\\n      slicedPath[i - pathPtr] = pathNibble;\\n    }\\n\\n    if (keccak256(partialPath) == keccak256(slicedPath)) {\\n      len = partialPath.length;\\n    } else {\\n      len = 0;\\n    }\\n    return len;\\n  }\\n\\n  // bytes b must be hp encoded\\n  function _getNibbleArray(bytes memory b)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    bytes memory nibbles = '';\\n    if (b.length > 0) {\\n      uint8 offset;\\n      uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n      if (hpNibble == 1 || hpNibble == 3) {\\n        nibbles = new bytes(b.length * 2 - 1);\\n        bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n        nibbles[0] = oddNibble;\\n        offset = 1;\\n      } else {\\n        nibbles = new bytes(b.length * 2 - 2);\\n        offset = 0;\\n      }\\n\\n      for (uint256 i = offset; i < nibbles.length; i++) {\\n        nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n      }\\n    }\\n    return nibbles;\\n  }\\n\\n  function _getNthNibbleOfBytes(uint256 n, bytes memory str)\\n    private\\n    pure\\n    returns (bytes1)\\n  {\\n    return\\n      bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/polygonFx/lib/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity ^0.7.6;\\n\\nlibrary RLPReader {\\n  uint8 private constant STRING_SHORT_START = 0x80;\\n  uint8 private constant STRING_LONG_START = 0xb8;\\n  uint8 private constant LIST_SHORT_START = 0xc0;\\n  uint8 private constant LIST_LONG_START = 0xf8;\\n  uint8 private constant WORD_SIZE = 32;\\n\\n  struct RLPItem {\\n    uint256 len;\\n    uint256 memPtr;\\n  }\\n\\n  struct Iterator {\\n    RLPItem item; // Item that's being iterated over.\\n    uint256 nextPtr; // Position of the next item in the list.\\n  }\\n\\n  /*\\n   * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n   * @param self The iterator.\\n   * @return The next element in the iteration.\\n   */\\n  function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n    require(hasNext(self));\\n\\n    uint256 ptr = self.nextPtr;\\n    uint256 itemLength = _itemLength(ptr);\\n    self.nextPtr = ptr + itemLength;\\n\\n    return RLPItem(itemLength, ptr);\\n  }\\n\\n  /*\\n   * @dev Returns true if the iteration has more elements.\\n   * @param self The iterator.\\n   * @return true if the iteration has more elements.\\n   */\\n  function hasNext(Iterator memory self) internal pure returns (bool) {\\n    RLPItem memory item = self.item;\\n    return self.nextPtr < item.memPtr + item.len;\\n  }\\n\\n  /*\\n   * @param item RLP encoded bytes\\n   */\\n  function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n    uint256 memPtr;\\n    assembly {\\n      memPtr := add(item, 0x20)\\n    }\\n\\n    return RLPItem(item.length, memPtr);\\n  }\\n\\n  /*\\n   * @dev Create an iterator. Reverts if item is not a list.\\n   * @param self The RLP item.\\n   * @return An 'Iterator' over the item.\\n   */\\n  function iterator(RLPItem memory self)\\n    internal\\n    pure\\n    returns (Iterator memory)\\n  {\\n    require(isList(self));\\n\\n    uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n    return Iterator(self, ptr);\\n  }\\n\\n  /*\\n   * @param item RLP encoded bytes\\n   */\\n  function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n    return item.len;\\n  }\\n\\n  /*\\n   * @param item RLP encoded bytes\\n   */\\n  function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n    return item.len - _payloadOffset(item.memPtr);\\n  }\\n\\n  /*\\n   * @param item RLP encoded list in bytes\\n   */\\n  function toList(RLPItem memory item)\\n    internal\\n    pure\\n    returns (RLPItem[] memory)\\n  {\\n    require(isList(item));\\n\\n    uint256 items = numItems(item);\\n    RLPItem[] memory result = new RLPItem[](items);\\n\\n    uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n    uint256 dataLen;\\n    for (uint256 i = 0; i < items; i++) {\\n      dataLen = _itemLength(memPtr);\\n      result[i] = RLPItem(dataLen, memPtr);\\n      memPtr = memPtr + dataLen;\\n    }\\n\\n    return result;\\n  }\\n\\n  // @return indicator whether encoded payload is a list. negate this function call for isData.\\n  function isList(RLPItem memory item) internal pure returns (bool) {\\n    if (item.len == 0) return false;\\n\\n    uint8 byte0;\\n    uint256 memPtr = item.memPtr;\\n    assembly {\\n      byte0 := byte(0, mload(memPtr))\\n    }\\n\\n    if (byte0 < LIST_SHORT_START) return false;\\n    return true;\\n  }\\n\\n  /*\\n   * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n   * @return keccak256 hash of RLP encoded bytes.\\n   */\\n  function rlpBytesKeccak256(RLPItem memory item)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    uint256 ptr = item.memPtr;\\n    uint256 len = item.len;\\n    bytes32 result;\\n    assembly {\\n      result := keccak256(ptr, len)\\n    }\\n    return result;\\n  }\\n\\n  function payloadLocation(RLPItem memory item)\\n    internal\\n    pure\\n    returns (uint256, uint256)\\n  {\\n    uint256 offset = _payloadOffset(item.memPtr);\\n    uint256 memPtr = item.memPtr + offset;\\n    uint256 len = item.len - offset; // data length\\n    return (memPtr, len);\\n  }\\n\\n  /*\\n   * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n   * @return keccak256 hash of the item payload.\\n   */\\n  function payloadKeccak256(RLPItem memory item)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\\n    bytes32 result;\\n    assembly {\\n      result := keccak256(memPtr, len)\\n    }\\n    return result;\\n  }\\n\\n  /** RLPItem conversions into data types **/\\n\\n  // @returns raw rlp encoding in bytes\\n  function toRlpBytes(RLPItem memory item)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    bytes memory result = new bytes(item.len);\\n    if (result.length == 0) return result;\\n\\n    uint256 ptr;\\n    assembly {\\n      ptr := add(0x20, result)\\n    }\\n\\n    copy(item.memPtr, ptr, item.len);\\n    return result;\\n  }\\n\\n  // any non-zero byte is considered true\\n  function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n    require(item.len == 1);\\n    uint256 result;\\n    uint256 memPtr = item.memPtr;\\n    assembly {\\n      result := byte(0, mload(memPtr))\\n    }\\n\\n    return result == 0 ? false : true;\\n  }\\n\\n  function toAddress(RLPItem memory item) internal pure returns (address) {\\n    // 1 byte for the length prefix\\n    require(item.len == 21);\\n\\n    return address(uint160(toUint(item)));\\n  }\\n\\n  function toUint(RLPItem memory item) internal pure returns (uint256) {\\n    require(item.len > 0 && item.len <= 33);\\n\\n    uint256 offset = _payloadOffset(item.memPtr);\\n    uint256 len = item.len - offset;\\n\\n    uint256 result;\\n    uint256 memPtr = item.memPtr + offset;\\n    assembly {\\n      result := mload(memPtr)\\n\\n      // shfit to the correct location if neccesary\\n      if lt(len, 32) {\\n        result := div(result, exp(256, sub(32, len)))\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  // enforces 32 byte length\\n  function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n    // one byte prefix\\n    require(item.len == 33);\\n\\n    uint256 result;\\n    uint256 memPtr = item.memPtr + 1;\\n    assembly {\\n      result := mload(memPtr)\\n    }\\n\\n    return result;\\n  }\\n\\n  function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n    require(item.len > 0);\\n\\n    uint256 offset = _payloadOffset(item.memPtr);\\n    uint256 len = item.len - offset; // data length\\n    bytes memory result = new bytes(len);\\n\\n    uint256 destPtr;\\n    assembly {\\n      destPtr := add(0x20, result)\\n    }\\n\\n    copy(item.memPtr + offset, destPtr, len);\\n    return result;\\n  }\\n\\n  /*\\n   * Private Helpers\\n   */\\n\\n  // @return number of payload items inside an encoded list.\\n  function numItems(RLPItem memory item) private pure returns (uint256) {\\n    if (item.len == 0) return 0;\\n\\n    uint256 count = 0;\\n    uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n    uint256 endPtr = item.memPtr + item.len;\\n    while (currPtr < endPtr) {\\n      currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n      count++;\\n    }\\n\\n    return count;\\n  }\\n\\n  // @return entire rlp item byte length\\n  function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n    uint256 itemLen;\\n    uint256 byte0;\\n    assembly {\\n      byte0 := byte(0, mload(memPtr))\\n    }\\n\\n    if (byte0 < STRING_SHORT_START) itemLen = 1;\\n    else if (byte0 < STRING_LONG_START)\\n      itemLen = byte0 - STRING_SHORT_START + 1;\\n    else if (byte0 < LIST_SHORT_START) {\\n      assembly {\\n        let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n        memPtr := add(memPtr, 1) // skip over the first byte\\n        /* 32 byte word size */\\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n        itemLen := add(dataLen, add(byteLen, 1))\\n      }\\n    } else if (byte0 < LIST_LONG_START) {\\n      itemLen = byte0 - LIST_SHORT_START + 1;\\n    } else {\\n      assembly {\\n        let byteLen := sub(byte0, 0xf7)\\n        memPtr := add(memPtr, 1)\\n\\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n        itemLen := add(dataLen, add(byteLen, 1))\\n      }\\n    }\\n\\n    return itemLen;\\n  }\\n\\n  // @return number of bytes until the data\\n  function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n    uint256 byte0;\\n    assembly {\\n      byte0 := byte(0, mload(memPtr))\\n    }\\n\\n    if (byte0 < STRING_SHORT_START) return 0;\\n    else if (\\n      byte0 < STRING_LONG_START ||\\n      (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\\n    ) return 1;\\n    else if (byte0 < LIST_SHORT_START)\\n      // being explicit\\n      return byte0 - (STRING_LONG_START - 1) + 1;\\n    else return byte0 - (LIST_LONG_START - 1) + 1;\\n  }\\n\\n  /*\\n   * @param src Pointer to source\\n   * @param dest Pointer to destination\\n   * @param len Amount of memory to copy from the source\\n   */\\n  function copy(\\n    uint256 src,\\n    uint256 dest,\\n    uint256 len\\n  ) private pure {\\n    if (len == 0) return;\\n\\n    // copy as many word sizes as possible\\n    for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n\\n      src += WORD_SIZE;\\n      dest += WORD_SIZE;\\n    }\\n\\n    // left over bytes. Mask is used to remove unwanted bytes from the word\\n    uint256 mask = 256**(WORD_SIZE - len) - 1;\\n    assembly {\\n      let srcpart := and(mload(src), not(mask)) // zero out src\\n      let destpart := and(mload(dest), mask) // retrieve the bytes\\n      mstore(dest, or(destpart, srcpart))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/polygonFx/tunnel/FxBaseRootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport { RLPReader } from '../lib/RLPReader.sol';\\nimport { MerklePatriciaProof } from '../lib/MerklePatriciaProof.sol';\\nimport { Merkle } from '../lib/Merkle.sol';\\n\\ninterface IFxStateSender {\\n  function sendMessageToChild(address _receiver, bytes calldata _data) external;\\n}\\n\\ncontract ICheckpointManager {\\n  struct HeaderBlock {\\n    bytes32 root;\\n    uint256 start;\\n    uint256 end;\\n    uint256 createdAt;\\n    address proposer;\\n  }\\n\\n  /**\\n   * @notice mapping of checkpoint header numbers to block details\\n   * @dev These checkpoints are submited by plasma contracts\\n   */\\n  mapping(uint256 => HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n  using RLPReader for bytes;\\n  using RLPReader for RLPReader.RLPItem;\\n  using Merkle for bytes32;\\n\\n  // keccak256(MessageSent(bytes))\\n  bytes32 public constant SEND_MESSAGE_EVENT_SIG =\\n    0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n  // state sender contract\\n  IFxStateSender public immutable fxRoot;\\n  // root chain manager\\n  ICheckpointManager public immutable checkpointManager;\\n  // child tunnel contract which receives and sends messages\\n  address public immutable fxChildTunnel;\\n\\n  // storage to avoid duplicate exits\\n  mapping(bytes32 => bool) public processedExits;\\n\\n  constructor(\\n    address _checkpointManager,\\n    address _fxRoot,\\n    address _fxChildTunnel\\n  ) {\\n    checkpointManager = ICheckpointManager(_checkpointManager);\\n    fxRoot = IFxStateSender(_fxRoot);\\n    fxChildTunnel = _fxChildTunnel;\\n  }\\n\\n  /**\\n   * @notice Send bytes message to Child Tunnel\\n   * @param message bytes message that will be sent to Child Tunnel\\n   * some message examples -\\n   *   abi.encode(tokenId);\\n   *   abi.encode(tokenId, tokenMetadata);\\n   *   abi.encode(messageType, messageData);\\n   */\\n  function _sendMessageToChild(bytes memory message) internal {\\n    fxRoot.sendMessageToChild(fxChildTunnel, message);\\n  }\\n\\n  function _validateAndExtractMessage(bytes memory inputData)\\n    internal\\n    returns (bytes memory)\\n  {\\n    RLPReader.RLPItem[] memory inputDataRLPList = inputData\\n      .toRlpItem()\\n      .toList();\\n\\n    // checking if exit has already been processed\\n    // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n    bytes32 exitHash = keccak256(\\n      abi.encodePacked(\\n        inputDataRLPList[2].toUint(), // blockNumber\\n        // first 2 nibbles are dropped while generating nibble array\\n        // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n        // so converting to nibble array and then hashing it\\n        MerklePatriciaProof._getNibbleArray(inputDataRLPList[8].toBytes()), // branchMask\\n        inputDataRLPList[9].toUint() // receiptLogIndex\\n      )\\n    );\\n    require(\\n      processedExits[exitHash] == false,\\n      'FxRootTunnel: EXIT_ALREADY_PROCESSED'\\n    );\\n    processedExits[exitHash] = true;\\n\\n    RLPReader.RLPItem[] memory receiptRLPList = inputDataRLPList[6]\\n      .toBytes()\\n      .toRlpItem()\\n      .toList();\\n    RLPReader.RLPItem memory logRLP = receiptRLPList[3].toList()[\\n      inputDataRLPList[9].toUint() // receiptLogIndex\\n    ];\\n\\n    RLPReader.RLPItem[] memory logRLPList = logRLP.toList();\\n\\n    // check child tunnel\\n    require(\\n      fxChildTunnel == RLPReader.toAddress(logRLPList[0]),\\n      'FxRootTunnel: INVALID_FX_CHILD_TUNNEL'\\n    );\\n\\n    // verify receipt inclusion\\n    require(\\n      MerklePatriciaProof.verify(\\n        inputDataRLPList[6].toBytes(), // receipt\\n        inputDataRLPList[8].toBytes(), // branchMask\\n        inputDataRLPList[7].toBytes(), // receiptProof\\n        bytes32(inputDataRLPList[5].toUint()) // receiptRoot\\n      ),\\n      'FxRootTunnel: INVALID_RECEIPT_PROOF'\\n    );\\n\\n    // verify checkpoint inclusion\\n    _checkBlockMembershipInCheckpoint(\\n      inputDataRLPList[2].toUint(), // blockNumber\\n      inputDataRLPList[3].toUint(), // blockTime\\n      bytes32(inputDataRLPList[4].toUint()), // txRoot\\n      bytes32(inputDataRLPList[5].toUint()), // receiptRoot\\n      inputDataRLPList[0].toUint(), // headerNumber\\n      inputDataRLPList[1].toBytes() // blockProof\\n    );\\n\\n    RLPReader.RLPItem[] memory logTopicRLPList = logRLPList[1].toList(); // topics\\n\\n    require(\\n      bytes32(logTopicRLPList[0].toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n      'FxRootTunnel: INVALID_SIGNATURE'\\n    );\\n\\n    // received message data\\n    bytes memory receivedData = logRLPList[2].toBytes();\\n    bytes memory message = abi.decode(receivedData, (bytes)); // event decodes params again, so decoding bytes to get message\\n    return message;\\n  }\\n\\n  function _checkBlockMembershipInCheckpoint(\\n    uint256 blockNumber,\\n    uint256 blockTime,\\n    bytes32 txRoot,\\n    bytes32 receiptRoot,\\n    uint256 headerNumber,\\n    bytes memory blockProof\\n  ) private view returns (uint256) {\\n    (\\n      bytes32 headerRoot,\\n      uint256 startBlock,\\n      ,\\n      uint256 createdAt,\\n\\n    ) = checkpointManager.headerBlocks(headerNumber);\\n\\n    require(\\n      keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot))\\n        .checkMembership(blockNumber - startBlock, headerRoot, blockProof),\\n      'FxRootTunnel: INVALID_HEADER'\\n    );\\n    return createdAt;\\n  }\\n\\n  /**\\n   * @notice receive message from  L2 to L1, validated by proof\\n   * @dev This function verifies if the transaction actually happened on child chain\\n   *\\n   * @param inputData RLP encoded data of the reference tx containing following list of fields\\n   *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n   *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n   *  2 - blockNumber - Block number containing the reference tx on child chain\\n   *  3 - blockTime - Reference tx block time\\n   *  4 - txRoot - Transactions root of block\\n   *  5 - receiptRoot - Receipts root of block\\n   *  6 - receipt - Receipt of the reference transaction\\n   *  7 - receiptProof - Merkle proof of the reference receipt\\n   *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n   *  9 - receiptLogIndex - Log Index to read from the receipt\\n   */\\n  function receiveMessage(bytes memory inputData) public virtual {\\n    bytes memory message = _validateAndExtractMessage(inputData);\\n    _processMessageFromChild(message);\\n  }\\n\\n  /**\\n   * @notice Process message received from Child Tunnel\\n   * @dev function needs to be implemented to handle message as per requirement\\n   * This is called by onStateReceive function.\\n   * Since it is called via a system call, any event will not be emitted during its execution.\\n   * @param message bytes message that was sent from Child Tunnel\\n   */\\n  function _processMessageFromChild(bytes memory message) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/src/investment/interfaces/IRewardHandler.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity 0.7.6;\\n\\ninterface IRewardHandler {\\n  /**\\n   * @dev Get the amount allocated for the Booster\\n   *\\n   * @return The amount which is allocated for the Booster (18 decimals)\\n   */\\n  function getBoosterRewards() external view returns (uint256);\\n\\n  /**\\n   * @dev Transfer reward and distribute the fee\\n   *\\n   * This is the new implementation of distribute() which uses internal fees\\n   * defined in the {RewardHandler} contract.\\n   *\\n   * @param recipient The recipient of the reward\\n   * @param amount The amount of WOWS to transfer to the recipient\\n   * @param fee The reward fee in 1e6 factor notation\\n   */\\n  function distribute2(\\n    address recipient,\\n    uint256 amount,\\n    uint32 fee\\n  ) external;\\n\\n  /**\\n   * @dev Transfer reward and distribute the fee\\n   *\\n   * This is the current implementation, needed for backward compatibility.\\n   *\\n   * Current ERC1155Minter and Controller call this function, later\\n   * reward handler clients should call the the new one with internal\\n   * fees specified in this contract.\\n   *\\n   * uint32 values are in 1e6 factor notation.\\n   */\\n  function distribute(\\n    address recipient,\\n    uint256 amount,\\n    uint32 fee,\\n    uint32 toTeam,\\n    uint32 toMarketing,\\n    uint32 toBooster,\\n    uint32 toRewardPool\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/polygon/WOWSERC1155RootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport { IERC1155 } from '../../0xerc1155/interfaces/IERC1155.sol';\\nimport { ERC1155Holder } from '../../0xerc1155/tokens/ERC1155/ERC1155Holder.sol';\\nimport { SafeMath } from '../../0xerc1155/utils/SafeMath.sol';\\nimport { FxBaseRootTunnel } from '../../polygonFx/tunnel/FxBaseRootTunnel.sol';\\n\\nimport { IRootTunnel } from './interfaces/IRootTunnel.sol';\\n\\nimport { IRewardHandler } from '../investment/interfaces/IRewardHandler.sol';\\nimport '../token/interfaces/IWOWSCryptofolio.sol';\\nimport '../token/interfaces/IWOWSERC1155.sol';\\nimport '../utils/TokenIds.sol';\\n\\ncontract WOWSERC1155RootTunnel is FxBaseRootTunnel, ERC1155Holder, IRootTunnel {\\n  using TokenIds for uint256;\\n  using SafeMath for uint256;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Constants\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  bytes32 private constant DEPOSIT = keccak256('DEPOSIT');\\n  bytes32 private constant DEPOSIT_BATCH = keccak256('DEPOSIT_BATCH');\\n  bytes32 private constant MIGRATE = keccak256('MIGRATE');\\n  bytes32 private constant MIGRATE_BATCH = keccak256('MIGRATE_BATCH');\\n  bytes32 private constant DISTRIBUTE = keccak256('DISTRIBUTE');\\n  bytes32 private constant WITHDRAW = keccak256('WITHDRAW');\\n  bytes32 private constant WITHDRAW_BATCH = keccak256('WITHDRAW_BATCH');\\n  bytes32 private constant MAP_TOKEN = keccak256('MAP_TOKEN');\\n\\n  uint256 private constant CHAIN_ID = 1;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Routing\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  IWOWSERC1155 private immutable rootToken_;\\n  address private immutable childToken_;\\n\\n  address private immutable migrator_;\\n  address private immutable admin_;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  IRewardHandler public rewardHandler;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Modifier\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  modifier onlyAdmin() {\\n    require(msg.sender == admin_, 'RT: Only admin');\\n    _;\\n  }\\n\\n  modifier onlyRootToken() {\\n    require(msg.sender == address(rootToken_), 'RT: Only from root');\\n    _;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  constructor(\\n    address _checkpointManager,\\n    address _fxRoot,\\n    address _childTunnel,\\n    address _rootToken,\\n    address _childToken,\\n    address _migrator,\\n    address _admin\\n  ) FxBaseRootTunnel(_checkpointManager, _fxRoot, _childTunnel) {\\n    require(_rootToken != address(0), 'RT: Invalid root');\\n    require(_childToken != address(0), 'RT: Invalid child');\\n\\n    rootToken_ = IWOWSERC1155(_rootToken);\\n    childToken_ = _childToken;\\n    migrator_ = _migrator;\\n    admin_ = _admin;\\n  }\\n\\n  /**\\n   * @dev Called from proxy\\n   */\\n  function initialize(address _rewardHandler) external {\\n    require(address(rewardHandler) == address(0), 'RT: Initialized');\\n\\n    rewardHandler = IRewardHandler(_rewardHandler);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {IERC1155TokenReceiver-onERC1155Received}\\n   */\\n  function onERC1155Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes calldata data\\n  ) public override onlyRootToken returns (bytes4) {\\n    // Get cfolios\\n    bytes memory msgData;\\n\\n    if (operator != migrator_) {\\n      require(tokenId.isBaseCard(), 'RT: Only basecard');\\n      msgData = _getTokenData('', tokenId);\\n    } else {\\n      msgData = data;\\n    }\\n\\n    // DEPOSIT, encode(rootToken, depositor, user, id, extra data)\\n    bytes memory message = abi.encode(\\n      (operator == migrator_) ? MIGRATE : DEPOSIT,\\n      abi.encode(address(rootToken_), operator, from, tokenId, msgData)\\n    );\\n    _sendMessageToChild(message);\\n\\n    // Call ancestor\\n    return super.onERC1155Received(operator, from, tokenId, amount, data);\\n  }\\n\\n  /**\\n   * @dev See {IERC1155TokenReceiver-onERC1155BatchReceived}\\n   */\\n  function onERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts,\\n    bytes calldata data\\n  ) public override onlyRootToken returns (bytes4) {\\n    bytes32 cmd = DEPOSIT_BATCH;\\n    bytes memory msgData = '';\\n    if (operator != migrator_) {\\n      msgData = '';\\n      for (uint256 i = 0; i < tokenIds.length; ++i) {\\n        require(tokenIds[i].isBaseCard(), 'RT: Only basecard');\\n        msgData = _getTokenData(msgData, tokenIds[i]);\\n      }\\n    } else {\\n      msgData = data;\\n      cmd = MIGRATE_BATCH;\\n    }\\n\\n    // DEPOSIT_BATCH, encode(rootToken, depositor, user, ids, extra data)\\n    bytes memory message = abi.encode(\\n      cmd,\\n      abi.encode(address(rootToken_), operator, from, tokenIds, msgData)\\n    );\\n    _sendMessageToChild(message);\\n\\n    // Call ancestor\\n    return\\n      super.onERC1155BatchReceived(operator, from, tokenIds, amounts, data);\\n  }\\n\\n  function mintCFolioItems(bytes memory data) external override {\\n    require(msg.sender == migrator_, 'RT: Forbidden (MC)');\\n    require(data.length > 32 && (data.length % 32) == 0, 'RT: Invalid length');\\n\\n    uint256 numTypes = data.length / 32 - 1;\\n    uint256[] memory dummyTokenIds = new uint256[](numTypes);\\n    for (uint256 i = 0; i < numTypes; ++i) dummyTokenIds[i] = uint256(-1);\\n\\n    // MIGRATE_BATCH, encode(rootToken, depositor, user, ids, extra data)\\n    bytes memory message = abi.encode(\\n      MIGRATE_BATCH,\\n      abi.encode(\\n        address(rootToken_),\\n        msg.sender,\\n        address(0), // recipient is in cfolioTypes\\n        dummyTokenIds,\\n        data\\n      )\\n    );\\n    _sendMessageToChild(message);\\n  }\\n\\n  function setRewardHandler(address newRewardHandler) external onlyAdmin {\\n    require(newRewardHandler != address(0), 'RT: Zero address');\\n\\n    rewardHandler = IRewardHandler(newRewardHandler);\\n  }\\n\\n  /**\\n   * @dev Destruct implementation\\n   */\\n  function destructContract() external onlyAdmin {\\n    // slither-disable-next-line suicidal\\n    selfdestruct(payable(admin_));\\n  }\\n\\n  /**\\n   * @dev One time MAP_TOKEN call\\n   */\\n  function mapToken() external onlyAdmin {\\n    // MAP_TOKEN, rootToken\\n    bytes memory message = abi.encode(MAP_TOKEN, rootToken_);\\n    _sendMessageToChild(message);\\n  }\\n\\n  /**\\n   * @dev In case of failure, transfer tokenId back\\n   */\\n  function emergencyTransferToken(address to, uint256 tokenId)\\n    external\\n    onlyAdmin\\n  {\\n    rootToken_.safeTransferFrom(address(this), to, tokenId, 1, '');\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Internal\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  function _processMessageFromChild(bytes memory data) internal override {\\n    (bytes32 syncType, bytes memory syncData) = abi.decode(\\n      data,\\n      (bytes32, bytes)\\n    );\\n\\n    if (syncType == WITHDRAW) {\\n      _syncWithdraw(syncData);\\n    } else if (syncType == WITHDRAW_BATCH) {\\n      _syncBatchWithdraw(syncData);\\n    } else {\\n      revert('RT: Invalid sync type');\\n    }\\n  }\\n\\n  function _syncWithdraw(bytes memory syncData) internal {\\n    (\\n      address rootToken,\\n      address childToken,\\n      address user,\\n      uint256 tokenId,\\n      bytes memory data\\n    ) = abi.decode(syncData, (address, address, address, uint256, bytes));\\n    require(rootToken == address(rootToken_), 'RT: Invalid root');\\n    require(childToken == childToken_, 'RT: Invalid child');\\n\\n    rootToken_.safeTransferFrom(address(this), user, tokenId, 1, data);\\n  }\\n\\n  function _syncBatchWithdraw(bytes memory syncData) internal {\\n    (\\n      address rootToken,\\n      address childToken,\\n      address user,\\n      uint256[] memory tokenIds,\\n      bytes memory data\\n    ) = abi.decode(syncData, (address, address, address, uint256[], bytes));\\n    require(rootToken == address(rootToken_), 'RT: Invalid root');\\n    require(childToken == childToken_, 'RT: Invalid child');\\n\\n    rootToken_.safeBatchTransferFrom(\\n      address(this),\\n      user,\\n      tokenIds,\\n      new uint256[](0),\\n      data\\n    );\\n  }\\n\\n  function _syncDistribute(bytes memory syncData) internal {\\n    (address rootToken, address childToken, uint256 amount) = abi.decode(\\n      syncData,\\n      (address, address, uint256)\\n    );\\n    require(rootToken == address(rootToken_), 'RT: Invalid root');\\n    require(childToken == childToken_, 'RT: Invalid child');\\n\\n    rewardHandler.distribute2(address(rewardHandler), amount, uint32(1e6));\\n  }\\n\\n  function _getTokenData(bytes memory data, uint256 tokenId)\\n    private\\n    view\\n    returns (bytes memory)\\n  {\\n    (uint64 mintTimestamp, ) = rootToken_.getTokenData(tokenId);\\n\\n    // Return timestamp + 0 cfolios + no booster lock\\n    return abi.encodePacked(data, uint256(mintTimestamp));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/polygon/interfaces/IRootTunnel.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @title IRootTunnel\\n */\\ninterface IRootTunnel {\\n  // One way mint / migration only\\n  function mintCFolioItems(bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSCryptofolio.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSCryptofolio {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getter\\n  //////////////////////////////////////////////////////////////////////////////\\n  /**\\n   * @dev Return the handler (CFIH) of the underlying NFT\\n   */\\n  function handler() external view returns (address);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n  /**\\n   * @dev Set the handler of the underlying NFT\\n   *\\n   * This function is called during I-NFT setup\\n   *\\n   * @param newHandler The new handler of the underlying NFT,\\n   */\\n  function setHandler(address newHandler) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSERC1155.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Sft holder contract\\n */\\ninterface IWOWSERC1155 {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Get the token ID of a given address\\n   *\\n   * A cross check is required because token ID 0 is valid.\\n   *\\n   * @param tokenAddress The address to convert to a token ID\\n   *\\n   * @return The token ID on success, or uint256(-1) if `tokenAddress` does not\\n   * belong to a token ID\\n   */\\n  function addressToTokenId(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Get the address for a given token ID\\n   *\\n   * @param tokenId The token ID to convert\\n   *\\n   * @return The address, or address(0) in case the token ID does not belong\\n   * to an NFT\\n   */\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Return the level and the mint timestamp of tokenId\\n   *\\n   * @param tokenId The tokenId to query\\n   *\\n   * @return mintTimestamp The timestamp token was minted\\n   * @return level The level token belongs to\\n   */\\n  function getTokenData(uint256 tokenId)\\n    external\\n    view\\n    returns (uint64 mintTimestamp, uint8 level);\\n\\n  /**\\n   * @dev Return all tokenIds owned by account\\n   */\\n  function getTokenIds(address account)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @dev Returns the cFolioItemType of a given cFolioItem tokenId\\n   */\\n  function getCFolioItemType(uint256 tokenId) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param owner  The address of the token holder\\n   * @param tokenId ID of the Token\\n   * @return The _owner's balance of the token type requested\\n   */\\n  function balanceOf(address owner, uint256 tokenId)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param owners The addresses of the token holders\\n   * @param tokenIds ID of the Tokens\\n   * @return       The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(\\n    address[] calldata owners,\\n    uint256[] calldata tokenIds\\n  ) external view returns (uint256[] memory);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @notice Mints tokenIds into 'to' account\\n   * @dev Emits SftTokenTransfer Event\\n   *\\n   * Throws if sender has no MINTER_ROLE\\n   * 'data' holds the CFolioItemHandler if CFI's are minted\\n   */\\n  function mintBatch(\\n    address to,\\n    uint256[] calldata tokenIds,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @notice Burns tokenIds owned by 'account'\\n   * @dev Emits SftTokenTransfer Event\\n   *\\n   * Burns all owned CFolioItems\\n   * Throws if CFolioItems have assets\\n   */\\n  function burnBatch(address account, uint256[] calldata tokenIds) external;\\n\\n  /**\\n   * @notice Transfers amount of an id from the from address to the 'to' address specified\\n   * @dev Emits SftTokenTransfer Event\\n   * Throws if 'to' is the zero address\\n   * Throws if 'from' is not the current owner\\n   * If 'to' is a smart contract, ERC1155TokenReceiver interface will checked\\n   * @param from    Source address\\n   * @param to      Target address\\n   * @param tokenId ID of the token type\\n   * @param amount  Transfered amount\\n   * @param data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @dev Batch version of {safeTransferFrom}\\n   */\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @dev Each custom card has its own level. Level will be used when\\n   * calculating rewards and raiding power.\\n   *\\n   * @param tokenId The ID of the token whose level is being set\\n   * @param cardLevel The new level of the specified token\\n   */\\n  function setCustomCardLevel(uint256 tokenId, uint8 cardLevel) external;\\n\\n  /**\\n   * @dev Sets the cfolioItemType of a cfolioItem tokenId, not yet used\\n   * sftHolder tokenId expected (without hash)\\n   */\\n  function setCFolioItemType(uint256 tokenId, uint256 cfolioItemType_) external;\\n\\n  /**\\n   * @dev Sets external NFT for display tokenId\\n   * By default NFT is rendered using our internal metadata\\n   *\\n   * Throws if not called from MINTER role\\n   */\\n  function setExternalNft(\\n    uint256 tokenId,\\n    address externalCollection,\\n    uint256 externalTokenId\\n  ) external;\\n\\n  /**\\n   * @dev Deletes external NFT settings\\n   *\\n   * Throws if not called from MINTER role\\n   */\\n  function deleteExternalNft(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/TokenIds.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary TokenIds {\\n  // 128 bit underlying hash\\n  uint256 public constant HASH_MASK = (1 << 128) - 1;\\n\\n  function isBaseCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isStockCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 32);\\n  }\\n\\n  function isCustomCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 32) && (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isCFolioCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 64) && (tokenId & HASH_MASK) < (1 << 128);\\n  }\\n\\n  function toSftTokenId(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & HASH_MASK;\\n  }\\n\\n  function maskHash(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & ~HASH_MASK;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkpointManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fxRoot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_childTunnel\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rootToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_childToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_migrator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destructContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"emergencyTransferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardHandler\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintCFolioItems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardHandler\",\"outputs\":[{\"internalType\":\"contract IRewardHandler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardHandler\",\"type\":\"address\"}],\"name\":\"setRewardHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"WOWSERC1155RootTunnel","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"00000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c287000000000000000000000000fe5e5d361b2ad62c541bab87c45a0b9b018389a2000000000000000000000000914acce8afa5726f8e37bb1e16cf6b46b6686def000000000000000000000000baa7051c139eec1763a39a0570b7c566e14e92f00000000000000000000000000f0c855dc8a7e579e04d75319a7ad6238f379b0900000000000000000000000044fad995adf37075df5db34fde150f9b680dbed9000000000000000000000000bb5a7c17ade983f03afd8b09922b1c117b9eabc0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}