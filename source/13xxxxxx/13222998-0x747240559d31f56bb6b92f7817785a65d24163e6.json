{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/libwallet/UpgradeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ApprovalLib.sol\\\";\\nimport \\\"./WalletData.sol\\\";\\n\\n\\n/// @title UpgradeLib\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary UpgradeLib\\n{\\n    using ApprovalLib     for Wallet;\\n\\n    event ChangedMasterCopy (address masterCopy);\\n\\n    bytes32 public constant CHANGE_MASTER_COPY_TYPEHASH = keccak256(\\n        \\\"changeMasterCopy(address wallet,uint256 validUntil,address masterCopy)\\\"\\n    );\\n\\n    function changeMasterCopy(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address           newMasterCopy\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        require(newMasterCopy != address(0), \\\"INVALID_MASTER_COPY\\\");\\n\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                CHANGE_MASTER_COPY_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                newMasterCopy\\n            )\\n        );\\n\\n        emit ChangedMasterCopy(newMasterCopy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/ApprovalLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../lib/EIP712.sol\\\";\\nimport \\\"../../lib/SignatureUtil.sol\\\";\\nimport \\\"./GuardianLib.sol\\\";\\nimport \\\"./WalletData.sol\\\";\\n\\n\\n/// @title ApprovalLib\\n/// @dev Utility library for better handling of signed wallet requests.\\n///      This library must be deployed and linked to other modules.\\n///\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary ApprovalLib {\\n    using SignatureUtil for bytes32;\\n\\n    function verifyApproval(\\n        Wallet  storage wallet,\\n        bytes32         domainSeparator,\\n        SigRequirement  sigRequirement,\\n        Approval memory approval,\\n        bytes    memory encodedRequest\\n        )\\n        internal\\n        returns (bytes32 approvedHash)\\n    {\\n        require(address(this) == approval.wallet, \\\"INVALID_WALLET\\\");\\n        require(block.timestamp <= approval.validUntil, \\\"EXPIRED_SIGNED_REQUEST\\\");\\n\\n        approvedHash = EIP712.hashPacked(domainSeparator, keccak256(encodedRequest));\\n\\n        // Save hash to prevent replay attacks\\n        require(!wallet.hashes[approvedHash], \\\"HASH_EXIST\\\");\\n        wallet.hashes[approvedHash] = true;\\n\\n        require(\\n            approvedHash.verifySignatures(approval.signers, approval.signatures),\\n            \\\"INVALID_SIGNATURES\\\"\\n        );\\n\\n        require(\\n            GuardianLib.requireMajority(\\n                wallet,\\n                approval.signers,\\n                sigRequirement\\n            ),\\n            \\\"PERMISSION_DENIED\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/WalletData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nenum SigRequirement\\n{\\n    MAJORITY_OWNER_NOT_ALLOWED,\\n    MAJORITY_OWNER_ALLOWED,\\n    MAJORITY_OWNER_REQUIRED,\\n    OWNER_OR_ANY_GUARDIAN,\\n    ANY_GUARDIAN\\n}\\n\\nstruct Approval\\n{\\n    address[] signers;\\n    bytes[]   signatures;\\n    uint      validUntil;\\n    address   wallet;\\n}\\n\\n// Optimized to fit into 64 bytes (2 slots)\\nstruct Quota\\n{\\n    uint128 currentQuota;\\n    uint128 pendingQuota;\\n    uint128 spentAmount;\\n    uint64  spentTimestamp;\\n    uint64  pendingUntil;\\n}\\n\\nenum GuardianStatus\\n{\\n    REMOVE,    // Being removed or removed after validUntil timestamp\\n    ADD        // Being added or added after validSince timestamp.\\n}\\n\\n// Optimized to fit into 32 bytes (1 slot)\\nstruct Guardian\\n{\\n    address addr;\\n    uint8   status;\\n    uint64  timestamp; // validSince if status = ADD; validUntil if adding = REMOVE;\\n}\\n\\nstruct Wallet\\n{\\n    address owner;\\n    uint64  creationTimestamp;\\n\\n    // relayer => nonce\\n    uint nonce;\\n    // hash => consumed\\n    mapping (bytes32 => bool) hashes;\\n\\n    bool    locked;\\n\\n    Guardian[] guardians;\\n    mapping (address => uint)  guardianIdx;\\n\\n    address    inheritor;\\n    uint32     inheritWaitingPeriod;\\n    uint64     lastActive; // the latest timestamp the owner is considered to be active\\n\\n    Quota quota;\\n\\n    // whitelisted address => effective timestamp\\n    mapping (address => uint) whitelisted;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nlibrary EIP712\\n{\\n    struct Domain {\\n        string  name;\\n        string  version;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n    string constant internal EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    function hash(Domain memory domain)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        uint _chainid;\\n        assembly { _chainid := chainid() }\\n\\n        return keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(domain.name)),\\n                keccak256(bytes(domain.version)),\\n                _chainid,\\n                domain.verifyingContract\\n            )\\n        );\\n    }\\n\\n    function hashPacked(\\n        bytes32 domainSeparator,\\n        bytes32 dataHash\\n        )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                domainSeparator,\\n                dataHash\\n            )\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SignatureUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../thirdparty/BytesUtil.sol\\\";\\nimport \\\"./AddressUtil.sol\\\";\\nimport \\\"./ERC1271.sol\\\";\\nimport \\\"./MathUint.sol\\\";\\n\\n\\n/// @title SignatureUtil\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @dev This method supports multihash standard. Each signature's last byte indicates\\n///      the signature's type.\\nlibrary SignatureUtil\\n{\\n    using BytesUtil     for bytes;\\n    using MathUint      for uint;\\n    using AddressUtil   for address;\\n\\n    enum SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP_712,\\n        ETH_SIGN,\\n        WALLET   // deprecated\\n    }\\n\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function verifySignatures(\\n        bytes32          signHash,\\n        address[] memory signers,\\n        bytes[]   memory signatures\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(signers.length == signatures.length, \\\"BAD_SIGNATURE_DATA\\\");\\n        address lastSigner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function verifySignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        return signer.isContract()?\\n            verifyERC1271Signature(signHash, signer, signature):\\n            verifyEOASignature(signHash, signer, signature);\\n    }\\n\\n    function recoverECDSASigner(\\n        bytes32      signHash,\\n        bytes memory signature\\n        )\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        if (signature.length != 65) {\\n            return address(0);\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8   v;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := and(mload(add(signature, 0x41)), 0xff)\\n        }\\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n        if (v == 27 || v == 28) {\\n            return ecrecover(signHash, v, r, s);\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function verifyEOASignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        uint signatureTypeOffset = signature.length.sub(1);\\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\\n\\n        // Strip off the last byte of the signature by updating the length\\n        assembly {\\n            mstore(signature, signatureTypeOffset)\\n        }\\n\\n        if (signatureType == SignatureType.EIP_712) {\\n            success = (signer == recoverECDSASigner(signHash, signature));\\n        } else if (signatureType == SignatureType.ETH_SIGN) {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", signHash)\\n            );\\n            success = (signer == recoverECDSASigner(hash, signature));\\n        } else {\\n            success = false;\\n        }\\n\\n        // Restore the signature length\\n        assembly {\\n            mstore(signature, add(signatureTypeOffset, 1))\\n        }\\n\\n        return success;\\n    }\\n\\n    function verifyERC1271Signature(\\n        bytes32 signHash,\\n        address signer,\\n        bytes   memory signature\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes memory callData = abi.encodeWithSelector(\\n            ERC1271.isValidSignature.selector,\\n            signHash,\\n            signature\\n        );\\n        (bool success, bytes memory result) = signer.staticcall(callData);\\n        return (\\n            success &&\\n            result.length == 32 &&\\n            result.toBytes4(0) == ERC1271_MAGICVALUE\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/libwallet/GuardianLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./WalletData.sol\\\";\\nimport \\\"./ApprovalLib.sol\\\";\\nimport \\\"../../lib/SignatureUtil.sol\\\";\\nimport \\\"../../thirdparty/SafeCast.sol\\\";\\n\\n\\n/// @title GuardianModule\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary GuardianLib\\n{\\n    using AddressUtil   for address;\\n    using SafeCast      for uint;\\n    using SignatureUtil for bytes32;\\n    using ApprovalLib   for Wallet;\\n\\n    uint public constant MAX_GUARDIANS           = 10;\\n    uint public constant GUARDIAN_PENDING_PERIOD = 3 days;\\n\\n    bytes32 public constant ADD_GUARDIAN_TYPEHASH = keccak256(\\n        \\\"addGuardian(address wallet,uint256 validUntil,address guardian)\\\"\\n    );\\n    bytes32 public constant REMOVE_GUARDIAN_TYPEHASH = keccak256(\\n        \\\"removeGuardian(address wallet,uint256 validUntil,address guardian)\\\"\\n    );\\n    bytes32 public constant RESET_GUARDIANS_TYPEHASH = keccak256(\\n        \\\"resetGuardians(address wallet,uint256 validUntil,address[] guardians)\\\"\\n    );\\n\\n    event GuardianAdded   (address guardian, uint effectiveTime);\\n    event GuardianRemoved (address guardian, uint effectiveTime);\\n\\n    function addGuardiansImmediately(\\n        Wallet    storage wallet,\\n        address[] memory  _guardians\\n        )\\n        external\\n    {\\n        address guardian = address(0);\\n        for (uint i = 0; i < _guardians.length; i++) {\\n            require(_guardians[i] > guardian, \\\"INVALID_ORDERING\\\");\\n            guardian = _guardians[i];\\n            _addGuardian(wallet, guardian, 0, true);\\n        }\\n    }\\n\\n    function addGuardian(\\n        Wallet storage wallet,\\n        address guardian\\n        )\\n        external\\n    {\\n        _addGuardian(wallet, guardian, GUARDIAN_PENDING_PERIOD, false);\\n    }\\n\\n    function addGuardianWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address  guardian\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                ADD_GUARDIAN_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                guardian\\n            )\\n        );\\n\\n        _addGuardian(wallet, guardian, 0, true);\\n    }\\n\\n    function removeGuardian(\\n        Wallet storage wallet,\\n        address guardian\\n        )\\n        external\\n    {\\n        _removeGuardian(wallet, guardian, GUARDIAN_PENDING_PERIOD, false);\\n    }\\n\\n    function removeGuardianWA(\\n        Wallet   storage  wallet,\\n        bytes32           domainSeparator,\\n        Approval calldata approval,\\n        address  guardian\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                REMOVE_GUARDIAN_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                guardian\\n            )\\n        );\\n\\n        _removeGuardian(wallet, guardian, 0, true);\\n    }\\n\\n    function resetGuardians(\\n        Wallet    storage  wallet,\\n        address[] calldata newGuardians\\n        )\\n        external\\n    {\\n        Guardian[] memory allGuardians = guardians(wallet, true);\\n        for (uint i = 0; i < allGuardians.length; i++) {\\n            _removeGuardian(wallet, allGuardians[i].addr, GUARDIAN_PENDING_PERIOD, false);\\n        }\\n\\n        for (uint j = 0; j < newGuardians.length; j++) {\\n            _addGuardian(wallet, newGuardians[j], GUARDIAN_PENDING_PERIOD, false);\\n        }\\n    }\\n\\n    function resetGuardiansWA(\\n        Wallet    storage  wallet,\\n        bytes32            domainSeparator,\\n        Approval  calldata approval,\\n        address[] calldata newGuardians\\n        )\\n        external\\n        returns (bytes32 approvedHash)\\n    {\\n        approvedHash = wallet.verifyApproval(\\n            domainSeparator,\\n            SigRequirement.MAJORITY_OWNER_REQUIRED,\\n            approval,\\n            abi.encode(\\n                RESET_GUARDIANS_TYPEHASH,\\n                approval.wallet,\\n                approval.validUntil,\\n                keccak256(abi.encodePacked(newGuardians))\\n            )\\n        );\\n\\n        removeAllGuardians(wallet);\\n        for (uint i = 0; i < newGuardians.length; i++) {\\n            _addGuardian(wallet, newGuardians[i], 0, true);\\n        }\\n    }\\n\\n    function requireMajority(\\n        Wallet         storage wallet,\\n        address[]      memory  signers,\\n        SigRequirement         requirement\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // We always need at least one signer\\n        if (signers.length == 0) {\\n            return false;\\n        }\\n\\n        // Calculate total group sizes\\n        Guardian[] memory allGuardians = guardians(wallet, false);\\n        require(allGuardians.length > 0, \\\"NO_GUARDIANS\\\");\\n\\n        address lastSigner;\\n        bool walletOwnerSigned = false;\\n        address owner = wallet.owner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            // Check for duplicates\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n\\n            if (signers[i] == owner) {\\n                walletOwnerSigned = true;\\n            } else {\\n                bool _isGuardian = false;\\n                for (uint j = 0; j < allGuardians.length; j++) {\\n                    if (allGuardians[j].addr == signers[i]) {\\n                        _isGuardian = true;\\n                        break;\\n                    }\\n                }\\n                require(_isGuardian, \\\"SIGNER_NOT_GUARDIAN\\\");\\n            }\\n        }\\n\\n        if (requirement == SigRequirement.OWNER_OR_ANY_GUARDIAN) {\\n            return signers.length == 1;\\n        } else if (requirement == SigRequirement.ANY_GUARDIAN) {\\n            require(!walletOwnerSigned, \\\"WALLET_OWNER_SIGNATURE_NOT_ALLOWED\\\");\\n            return signers.length == 1;\\n        }\\n\\n        // Check owner requirements\\n        if (requirement == SigRequirement.MAJORITY_OWNER_REQUIRED) {\\n            require(walletOwnerSigned, \\\"WALLET_OWNER_SIGNATURE_REQUIRED\\\");\\n        } else if (requirement == SigRequirement.MAJORITY_OWNER_NOT_ALLOWED) {\\n            require(!walletOwnerSigned, \\\"WALLET_OWNER_SIGNATURE_NOT_ALLOWED\\\");\\n        }\\n\\n        uint numExtendedSigners = allGuardians.length;\\n        if (walletOwnerSigned) {\\n            numExtendedSigners += 1;\\n            require(signers.length > 1, \\\"NO_GUARDIAN_SIGNED_BESIDES_OWNER\\\");\\n        }\\n\\n        return signers.length >= (numExtendedSigners >> 1) + 1;\\n    }\\n\\n    function isGuardian(\\n        Wallet storage wallet,\\n        address addr,\\n        bool    includePendingAddition\\n        )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        Guardian memory g = _getGuardian(wallet, addr);\\n        return _isActiveOrPendingAddition(g, includePendingAddition);\\n    }\\n\\n    function guardians(\\n        Wallet storage wallet,\\n        bool    includePendingAddition\\n        )\\n        public\\n        view\\n        returns (Guardian[] memory _guardians)\\n    {\\n        _guardians = new Guardian[](wallet.guardians.length);\\n        uint index = 0;\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            Guardian memory g = wallet.guardians[i];\\n            if (_isActiveOrPendingAddition(g, includePendingAddition)) {\\n                _guardians[index] = g;\\n                index++;\\n            }\\n        }\\n        assembly { mstore(_guardians, index) }\\n    }\\n\\n    function numGuardians(\\n        Wallet storage wallet,\\n        bool    includePendingAddition\\n        )\\n        public\\n        view\\n        returns (uint count)\\n    {\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            Guardian memory g = wallet.guardians[i];\\n            if (_isActiveOrPendingAddition(g, includePendingAddition)) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n     function removeAllGuardians(\\n        Wallet storage wallet\\n        )\\n        internal\\n    {\\n        uint size = wallet.guardians.length;\\n        if (size == 0) return;\\n\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            delete wallet.guardianIdx[wallet.guardians[i].addr];\\n        }\\n        delete wallet.guardians;\\n    }\\n\\n    function cancelPendingGuardians(Wallet storage wallet)\\n        internal\\n    {\\n        bool cancelled = false;\\n        for (uint i = 0; i < wallet.guardians.length; i++) {\\n            Guardian memory g = wallet.guardians[i];\\n            if (_isPendingAddition(g)) {\\n                wallet.guardians[i].status = uint8(GuardianStatus.REMOVE);\\n                wallet.guardians[i].timestamp = 0;\\n                cancelled = true;\\n            }\\n            if (_isPendingRemoval(g)) {\\n                wallet.guardians[i].status = uint8(GuardianStatus.ADD);\\n                wallet.guardians[i].timestamp = 0;\\n                cancelled = true;\\n            }\\n        }\\n        _cleanRemovedGuardians(wallet, true);\\n    }\\n\\n    function storeGuardian(\\n        Wallet storage wallet,\\n        address addr,\\n        uint    validSince,\\n        bool    alwaysOverride\\n        )\\n        internal\\n        returns (uint)\\n    {\\n        require(validSince >= block.timestamp, \\\"INVALID_VALID_SINCE\\\");\\n        require(addr != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(addr != address(this), \\\"INVALID_ADDRESS\\\");\\n\\n        uint pos = wallet.guardianIdx[addr];\\n\\n        if (pos == 0) {\\n            // Add the new guardian\\n            Guardian memory _g = Guardian(\\n                addr,\\n                uint8(GuardianStatus.ADD),\\n                validSince.toUint64()\\n            );\\n            wallet.guardians.push(_g);\\n            wallet.guardianIdx[addr] = wallet.guardians.length;\\n\\n            _cleanRemovedGuardians(wallet, false);\\n            return validSince;\\n        }\\n\\n        Guardian memory g = wallet.guardians[pos - 1];\\n\\n        if (_isRemoved(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.ADD);\\n            wallet.guardians[pos - 1].timestamp = validSince.toUint64();\\n            return validSince;\\n        }\\n\\n        if (_isPendingRemoval(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.ADD);\\n            wallet.guardians[pos - 1].timestamp = 0;\\n            return 0;\\n        }\\n\\n        if (_isPendingAddition(g)) {\\n            if (!alwaysOverride) return g.timestamp;\\n\\n            wallet.guardians[pos - 1].timestamp = validSince.toUint64();\\n            return validSince;\\n        }\\n\\n        require(_isAdded(g), \\\"UNEXPECTED_RESULT\\\");\\n        return 0;\\n    }\\n\\n    function deleteGuardian(\\n        Wallet storage wallet,\\n        address addr,\\n        uint    validUntil,\\n        bool    alwaysOverride\\n        )\\n        internal\\n        returns (uint)\\n    {\\n        require(validUntil >= block.timestamp, \\\"INVALID_VALID_UNTIL\\\");\\n        require(addr != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        uint pos = wallet.guardianIdx[addr];\\n        require(pos > 0, \\\"GUARDIAN_NOT_EXISTS\\\");\\n\\n        Guardian memory g = wallet.guardians[pos - 1];\\n\\n        if (_isAdded(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.REMOVE);\\n            wallet.guardians[pos - 1].timestamp = validUntil.toUint64();\\n            return validUntil;\\n        }\\n\\n        if (_isPendingAddition(g)) {\\n            wallet.guardians[pos - 1].status = uint8(GuardianStatus.REMOVE);\\n            wallet.guardians[pos - 1].timestamp = 0;\\n            return 0;\\n        }\\n\\n        if (_isPendingRemoval(g)) {\\n            if (!alwaysOverride) return g.timestamp;\\n\\n            wallet.guardians[pos - 1].timestamp = validUntil.toUint64();\\n            return validUntil;\\n        }\\n\\n        require(_isRemoved(g), \\\"UNEXPECTED_RESULT\\\");\\n        return 0;\\n    }\\n\\n    // --- Internal functions ---\\n\\n    function _addGuardian(\\n        Wallet storage wallet,\\n        address guardian,\\n        uint    pendingPeriod,\\n        bool    alwaysOverride\\n        )\\n        internal\\n    {\\n        uint _numGuardians = numGuardians(wallet, true);\\n        require(_numGuardians < MAX_GUARDIANS, \\\"TOO_MANY_GUARDIANS\\\");\\n        require(guardian != wallet.owner, \\\"GUARDIAN_CAN_NOT_BE_OWNER\\\");\\n\\n        uint validSince = block.timestamp;\\n        if (_numGuardians >= 2) {\\n            validSince = block.timestamp + pendingPeriod;\\n        }\\n        validSince = storeGuardian(wallet, guardian, validSince, alwaysOverride);\\n        emit GuardianAdded(guardian, validSince);\\n    }\\n\\n    function _removeGuardian(\\n        Wallet storage wallet,\\n        address guardian,\\n        uint    pendingPeriod,\\n        bool    alwaysOverride\\n        )\\n        private\\n    {\\n        uint validUntil = block.timestamp + pendingPeriod;\\n        validUntil = deleteGuardian(wallet, guardian, validUntil, alwaysOverride);\\n        emit GuardianRemoved(guardian, validUntil);\\n    }\\n\\n    function _getGuardian(\\n        Wallet storage wallet,\\n        address addr\\n        )\\n        private\\n        view\\n        returns (Guardian memory guardian)\\n    {\\n        uint pos = wallet.guardianIdx[addr];\\n        if (pos > 0) {\\n            guardian = wallet.guardians[pos - 1];\\n        }\\n    }\\n\\n    function _isAdded(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return guardian.status == uint8(GuardianStatus.ADD) &&\\n            guardian.timestamp <= block.timestamp;\\n    }\\n\\n    function _isPendingAddition(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return guardian.status == uint8(GuardianStatus.ADD) &&\\n            guardian.timestamp > block.timestamp;\\n    }\\n\\n    function _isRemoved(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return guardian.status == uint8(GuardianStatus.REMOVE) &&\\n            guardian.timestamp <= block.timestamp;\\n    }\\n\\n    function _isPendingRemoval(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n         return guardian.status == uint8(GuardianStatus.REMOVE) &&\\n            guardian.timestamp > block.timestamp;\\n    }\\n\\n    function _isActive(Guardian memory guardian)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _isAdded(guardian) || _isPendingRemoval(guardian);\\n    }\\n\\n    function _isActiveOrPendingAddition(\\n        Guardian memory guardian,\\n        bool includePendingAddition\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _isActive(guardian) || includePendingAddition && _isPendingAddition(guardian);\\n    }\\n\\n    function _cleanRemovedGuardians(\\n        Wallet storage wallet,\\n        bool    force\\n        )\\n        private\\n    {\\n        uint count = wallet.guardians.length;\\n        if (!force && count < 10) return;\\n\\n        for (int i = int(count) - 1; i >= 0; i--) {\\n            Guardian memory g = wallet.guardians[uint(i)];\\n            if (_isRemoved(g)) {\\n                Guardian memory lastGuardian = wallet.guardians[wallet.guardians.length - 1];\\n\\n                if (g.addr != lastGuardian.addr) {\\n                    wallet.guardians[uint(i)] = lastGuardian;\\n                    wallet.guardianIdx[lastGuardian.addr] = uint(i) + 1;\\n                }\\n                wallet.guardians.pop();\\n                delete wallet.guardianIdx[g.addr];\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/BytesUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\npragma solidity ^0.7.0;\\n\\nlibrary BytesUtil {\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\\n        require(_bytes.length >= (_start + 3));\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8));\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12));\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16));\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\\n        require(_bytes.length >= (_start + 4));\\n        bytes4 tempBytes4;\\n\\n        assembly {\\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes4;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function fastSHA256(\\n        bytes memory data\\n        )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32[] memory result = new bytes32[](1);\\n        bool success;\\n        assembly {\\n             let ptr := add(data, 32)\\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\\n        }\\n        require(success, \\\"SHA256_FAILED\\\");\\n        return result[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for addresses\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary AddressUtil\\n{\\n    using AddressUtil for *;\\n\\n    function isContract(\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(addr) }\\n        return (codehash != 0x0 &&\\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\n    }\\n\\n    function toPayable(\\n        address addr\\n        )\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return payable(addr);\\n    }\\n\\n    // Works like address.send but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETH(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        if (amount == 0) {\\n            return true;\\n        }\\n        address payable recipient = to.toPayable();\\n        /* solium-disable-next-line */\\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\\\"\\\");\\n    }\\n\\n    // Works like address.transfer but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETHAndVerify(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        success = to.sendETH(amount, gasLimit);\\n        require(success, \\\"TRANSFER_FAILURE\\\");\\n    }\\n\\n    // Works like call but is slightly more efficient when data\\n    // needs to be copied from memory to do the call.\\n    function fastCall(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bool success, bytes memory returnData)\\n    {\\n        if (to != address(0)) {\\n            assembly {\\n                // Do the call\\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\\n                // Copy the return data\\n                let size := returndatasize()\\n                returnData := mload(0x40)\\n                mstore(returnData, size)\\n                returndatacopy(add(returnData, 32), 0, size)\\n                // Update free memory pointer\\n                mstore(0x40, add(returnData, add(32, size)))\\n            }\\n        }\\n    }\\n\\n    // Like fastCall, but throws when the call is unsuccessful.\\n    function fastCallAndVerify(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bytes memory returnData)\\n    {\\n        bool success;\\n        (success, returnData) = fastCall(to, gasLimit, value, data);\\n        if (!success) {\\n            assembly {\\n                revert(add(returnData, 32), mload(returnData))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function isValidSignature(\\n        bytes32      _hash,\\n        bytes memory _signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MathUint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for uint\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary MathUint\\n{\\n    function mul(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a * b;\\n        require(a == 0 || c / a == b, \\\"MUL_OVERFLOW\\\");\\n    }\\n\\n    function sub(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        require(b <= a, \\\"SUB_UNDERFLOW\\\");\\n        return a - b;\\n    }\\n\\n    function add(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value < 2**96, \\\"SafeCast: value doesn\\\\'t fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value < 2**40, \\\"SafeCast: value doesn\\\\'t fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"}],\"name\":\"ChangedMasterCopy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHANGE_MASTER_COPY_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UpgradeLib","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}