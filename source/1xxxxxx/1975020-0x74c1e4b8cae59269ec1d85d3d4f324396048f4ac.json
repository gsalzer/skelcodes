{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Author: Nick Johnson (arachnid at notdot.net)\r\n * Copyright 2016; licensed CC-BY-SA.\r\n * \r\n * BeerCoin is a new cryptocurrency intended to encapsulate and record the\r\n * concept of \"I owe you a beer\". Did someone answer a difficult question you\r\n * had? Send them a BeerCoin. Did they help you carry something heavy? Send\r\n * them a BeerCoin. Someone buy you a beer? Send them a BeerCoin.\r\n * \r\n * Unlike traditional currency, anyone can issue BeerCoin simply by sending it\r\n * to someone else. A person's BeerCoin is only as valuable as the recipient's\r\n * belief that they're good for the beer, should it ever be redeemed; a beer\r\n * owed to you by Vitalik Buterin is probably worth more than a beer owed to you\r\n * by the DAO hacker (but your opinions may differ on that point).\r\n * \r\n * BeerCoin is implemented as an ERC20 compatible token, with a few extensions.\r\n * Regular ERC20 transfers will create or resolve obligations between the two\r\n * parties; they will never transfer third-party BeerCoins. Additional methods\r\n * are provided to allow you transfer beers someone owes you to a third party;\r\n * if Satoshi Nakamoto owes you a beer, you can transfer that obligation to your\r\n * friend who just bought you one down at the pub. Methods are also provided for\r\n * determining the total number of beers a person owes, to help determine if\r\n * they're good for it, and for getting a list of accounts that owe someone a\r\n * beer.\r\n * \r\n * BeerCoin may confuse some wallets, such as Mist, that expect you can only\r\n * send currency up to your current total balance; since BeerCoin operates as\r\n * individual IOUs, that restriction doesn't apply. As a result, you will\r\n * sometimes need to call the 'transfer' function on the contract itself\r\n * instead of using the wallet's built in token support.\r\n * \r\n * If anyone finds a bug in the contract, I'll buy you a beer. If you find a bug\r\n * you can exploit to adjust balances without users' consent, I'll buy you two\r\n * (or more).\r\n * \r\n * If you feel obliged to me for creating this, send me a ? at\r\n * 0x5fC8A61e097c118cE43D200b3c4dcf726Cf783a9. Don't do it unless you mean it;\r\n * if we meet I'll surely redeem it.\r\n */\r\ncontract BeerCoin {\r\n    using Itmap for Itmap.AddressUintMap;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    struct UserAccount {\r\n        bool exists;\r\n        Itmap.AddressUintMap debtors; // People who owe you a beer\r\n        mapping(address=>uint) allowances;\r\n        uint maxCredit; // Most beers any individual may owe you\r\n        uint beersOwed; // Beers owed by this person\r\n        uint beersOwing; // Beers owed to this person\r\n    }\r\n    uint beersOwing;\r\n    uint defaultMaxCredit;\r\n    \r\n    function() {\r\n        throw;\r\n    }\r\n    \r\n    function BeerCoin(uint _defaultMaxCredit) {\r\n        defaultMaxCredit = _defaultMaxCredit;\r\n    }\r\n    \r\n    mapping(address=>UserAccount) accounts;\r\n\r\n    function maximumCredit(address owner) constant returns (uint) {\r\n        if(accounts[owner].exists) {\r\n            return accounts[owner].maxCredit;\r\n        } else {\r\n            return defaultMaxCredit;\r\n        }\r\n    }\r\n\r\n    function setMaximumCredit(uint credit) {\r\n        //640k ought to be enough for anyone\r\n        if(credit > 655360)\r\n            return;\r\n\r\n        if(!accounts[msg.sender].exists)\r\n            accounts[msg.sender].exists = true;\r\n        accounts[msg.sender].maxCredit = credit;\r\n    }\r\n    \r\n    function numDebtors(address owner) constant returns (uint) {\r\n        return accounts[owner].debtors.size();\r\n    }\r\n    \r\n    function debtor(address owner, uint idx) constant returns (address) {\r\n        return accounts[owner].debtors.index(idx);\r\n    }\r\n    \r\n    function debtors(address owner) constant returns (address[]) {\r\n        return accounts[owner].debtors.keys;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256 supply) {\r\n        return beersOwing;   \r\n    }\r\n    \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return accounts[owner].beersOwing;\r\n    }\r\n    \r\n    function balanceOf(address owner, address debtor) constant returns (uint256 balance) {\r\n        return accounts[owner].debtors.get(debtor);\r\n    }\r\n    \r\n    function totalDebt(address owner) constant returns (uint256 balance) {\r\n        return accounts[owner].beersOwed;\r\n    }\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        return doTransfer(msg.sender, to, value);\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 value) returns (bool) {\r\n        if(accounts[from].allowances[msg.sender] >= value && doTransfer(from, to, value)) {\r\n            accounts[from].allowances[msg.sender] -= value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function doTransfer(address from, address to, uint value) internal returns (bool) {\r\n        if(from == to)\r\n            return false;\r\n            \r\n        if(!accounts[to].exists) {\r\n            accounts[to].exists = true;\r\n            accounts[to].maxCredit = defaultMaxCredit;\r\n        }\r\n        \r\n        // Don't allow transfers that would exceed the recipient's credit limit.\r\n        if(value > accounts[to].maxCredit + accounts[from].debtors.get(to))\r\n            return false;\r\n        \r\n        Transfer(from, to, value);\r\n\r\n        value -= reduceDebt(to, from, value);\r\n        createDebt(from, to, value);\r\n\r\n        return true;\r\n    }\r\n    \r\n    // Transfers beers owed to you by `debtor` to `to`.\r\n    function transferOther(address to, address debtor, uint value) returns (bool) {\r\n        return doTransferOther(msg.sender, to, debtor, value);\r\n    }\r\n\r\n    // Allows a third party to transfer debt owed to you by `debtor` to `to`.    \r\n    function transferOtherFrom(address from, address to, address debtor, uint value) returns (bool) {\r\n        if(accounts[from].allowances[msg.sender] >= value && doTransferOther(from, to, debtor, value)) {\r\n            accounts[from].allowances[msg.sender] -= value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function doTransferOther(address from, address to, address debtor, uint value) internal returns (bool) {\r\n        if(from == to || to == debtor)\r\n            return false;\r\n            \r\n        if(!accounts[to].exists) {\r\n            accounts[to].exists = true;\r\n            accounts[to].maxCredit = defaultMaxCredit;\r\n        }\r\n        \r\n        if(transferDebt(from, to, debtor, value)) {\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    // Creates debt owed by `debtor` to `creditor` of amount `value`.\r\n    // Returns false without making changes if this would exceed `creditor`'s\r\n    // credit limit.\r\n    function createDebt(address debtor, address creditor, uint value) internal returns (bool) {\r\n        if(value == 0)\r\n            return true;\r\n        \r\n        if(value > accounts[creditor].maxCredit)\r\n            return false;\r\n\r\n        accounts[creditor].debtors.set(\r\n            debtor, accounts[creditor].debtors.get(debtor) + value);\r\n        accounts[debtor].beersOwed += value;\r\n        accounts[creditor].beersOwing += value;\r\n        beersOwing += value;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // Reduces debt owed by `debtor` to `creditor` by `value` or the total amount,\r\n    // whichever is less. Returns the amount of debt erased.\r\n    function reduceDebt(address debtor, address creditor, uint value) internal returns (uint) {\r\n        var owed = accounts[creditor].debtors.get(debtor);\r\n        if(value >= owed) {\r\n            value = owed;\r\n            \r\n            accounts[creditor].debtors.remove(debtor);\r\n        } else {\r\n            accounts[creditor].debtors.set(debtor, owed - value);\r\n        }\r\n        \r\n        accounts[debtor].beersOwed -= value;\r\n        accounts[creditor].beersOwing -= value;\r\n        beersOwing -= value;\r\n        \r\n        return value;\r\n    }\r\n    \r\n    // Transfers debt owed by `debtor` from `oldCreditor` to `newCreditor`.\r\n    // Returns false without making any changes if `value` exceeds the amount\r\n    // owed or if the transfer would exceed `newCreditor`'s credit limit.\r\n    function transferDebt(address oldCreditor, address newCreditor, address debtor, uint value) internal returns (bool) {\r\n        var owedOld = accounts[oldCreditor].debtors.get(debtor);\r\n        if(owedOld < value)\r\n            return false;\r\n        \r\n        var owedNew = accounts[newCreditor].debtors.get(debtor);\r\n        if(value + owedNew > accounts[newCreditor].maxCredit)\r\n            return false;\r\n        \r\n        \r\n        if(owedOld == value) {\r\n            accounts[oldCreditor].debtors.remove(debtor);\r\n        } else {\r\n            accounts[oldCreditor].debtors.set(debtor, owedOld - value);\r\n        }\r\n        accounts[oldCreditor].beersOwing -= value;\r\n        \r\n        accounts[newCreditor].debtors.set(debtor, owedNew + value);\r\n        accounts[newCreditor].beersOwing += value;\r\n        \r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) returns (bool) {\r\n        accounts[msg.sender].allowances[spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address owner, address spender) constant returns (uint256) {\r\n        return accounts[owner].allowances[spender];\r\n    }\r\n}\r\n\r\n\r\nlibrary Itmap {\r\n    struct AddressUintMapEntry {\r\n        uint value;\r\n        uint idx;\r\n    }\r\n    \r\n    struct AddressUintMap {\r\n        mapping(address=>AddressUintMapEntry) entries;\r\n        address[] keys;\r\n    }\r\n    \r\n    function set(AddressUintMap storage self, address k, uint v) internal {\r\n        var entry = self.entries[k];\r\n        if(entry.idx == 0) {\r\n            entry.idx = self.keys.length + 1;\r\n            self.keys.push(k);\r\n        }\r\n        entry.value = v;\r\n    }\r\n    \r\n    function get(AddressUintMap storage self, address k) internal returns (uint) {\r\n        return self.entries[k].value;\r\n    }\r\n    \r\n    function contains(AddressUintMap storage self, address k) internal returns (bool) {\r\n        return self.entries[k].idx > 0;\r\n    }\r\n    \r\n    function remove(AddressUintMap storage self, address k) internal {\r\n        var entry = self.entries[k];\r\n        if(entry.idx > 0) {\r\n            var otherkey = self.keys[self.keys.length - 1];\r\n            self.keys[entry.idx - 1] = otherkey;\r\n            self.keys.length -= 1;\r\n            \r\n            self.entries[otherkey].idx = entry.idx;\r\n            entry.idx = 0;\r\n            entry.value = 0;\r\n        }\r\n    }\r\n    \r\n    function size(AddressUintMap storage self) internal returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n    \r\n    function index(AddressUintMap storage self, uint idx) internal returns (address) {\r\n        return self.keys[idx];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"totalDebt\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"debtor\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferOther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"credit\",\"type\":\"uint256\"}],\"name\":\"setMaximumCredit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"debtor\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferOtherFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maximumCredit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"debtor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"debtors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"numDebtors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"debtor\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_defaultMaxCredit\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BeerCoin","CompilerVersion":"v0.3.5-2016-07-21-6610add","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":""}]}