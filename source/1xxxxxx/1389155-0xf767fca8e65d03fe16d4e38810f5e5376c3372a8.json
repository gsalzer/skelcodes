{"status":"1","message":"OK","result":[{"SourceCode":"contract LuckyDoubler {\r\n//##########################################################\r\n//#### LuckyDoubler: A doubler with random payout order ####\r\n//#### Deposit 1 ETHER to participate                   ####\r\n//##########################################################\r\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\r\n//No part of this source code may be reproduced, distributed,\r\n//modified or transmitted in any form or by any means without\r\n//the prior written permission of the creator.\r\n\r\n    address private owner;\r\n    \r\n    //Stored variables\r\n    uint private balance = 0;\r\n    uint private fee = 5;\r\n    uint private multiplier = 125;\r\n\r\n    mapping (address => User) private users;\r\n    Entry[] private entries;\r\n    uint[] private unpaidEntries;\r\n    \r\n    //Set owner on contract creation\r\n    function LuckyDoubler() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyowner { if (msg.sender == owner) _ }\r\n    \r\n    struct User {\r\n        address id;\r\n        uint deposits;\r\n        uint payoutsReceived;\r\n    }\r\n    \r\n    struct Entry {\r\n        address entryAddress;\r\n        uint deposit;\r\n        uint payout;\r\n        bool paid;\r\n    }\r\n\r\n    //Fallback function\r\n    function() {\r\n        init();\r\n    }\r\n    \r\n    function init() private{\r\n        \r\n        if (msg.value < 1 ether) {\r\n             msg.sender.send(msg.value);\r\n            return;\r\n        }\r\n        \r\n        join();\r\n    }\r\n    \r\n    function join() private {\r\n        \r\n        //Limit deposits to 1ETH\r\n        uint dValue = 1 ether;\r\n        \r\n        if (msg.value > 1 ether) {\r\n            \r\n        \tmsg.sender.send(msg.value - 1 ether);\t\r\n        \tdValue = 1 ether;\r\n        }\r\n      \r\n        //Add new users to the users array\r\n        if (users[msg.sender].id == address(0))\r\n        {\r\n            users[msg.sender].id = msg.sender;\r\n            users[msg.sender].deposits = 0;\r\n            users[msg.sender].payoutsReceived = 0;\r\n        }\r\n        \r\n        //Add new entry to the entries array\r\n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\r\n        users[msg.sender].deposits++;\r\n        unpaidEntries.push(entries.length -1);\r\n        \r\n        //Collect fees and update contract balance\r\n        balance += (dValue * (100 - fee)) / 100;\r\n        \r\n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\r\n        Entry theEntry = entries[unpaidEntries[index]];\r\n        \r\n        //Pay pending entries if the new balance allows for it\r\n        if (balance > theEntry.payout) {\r\n            \r\n            uint payout = theEntry.payout;\r\n            \r\n            theEntry.entryAddress.send(payout);\r\n            theEntry.paid = true;\r\n            users[theEntry.entryAddress].payoutsReceived++;\r\n\r\n            balance -= payout;\r\n            \r\n            if (index < unpaidEntries.length - 1)\r\n                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\r\n           \r\n            unpaidEntries.length--;\r\n            \r\n        }\r\n        \r\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\r\n        uint fees = this.balance - balance;\r\n        if (fees > 0)\r\n        {\r\n                owner.send(fees);\r\n        }      \r\n       \r\n    }\r\n    \r\n    //Generate random number between 0 & max\r\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\r\n    function rand(uint max) constant private returns (uint256 result){\r\n        uint256 factor = FACTOR * 100 / max;\r\n        uint256 lastBlockNumber = block.number - 1;\r\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\r\n    \r\n        return uint256((uint256(hashVal) / factor)) % max;\r\n    }\r\n    \r\n    \r\n    //Contract management\r\n    function changeOwner(address newOwner) onlyowner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function changeMultiplier(uint multi) onlyowner {\r\n        if (multi < 110 || multi > 150) throw;\r\n        \r\n        multiplier = multi;\r\n    }\r\n    \r\n    function changeFee(uint newFee) onlyowner {\r\n        if (fee > 5) \r\n            throw;\r\n        fee = newFee;\r\n    }\r\n    \r\n    \r\n    //JSON functions\r\n    function multiplierFactor() constant returns (uint factor, string info) {\r\n        factor = multiplier;\r\n        info = 'The current multiplier applied to all deposits. Min 110%, max 150%.'; \r\n    }\r\n    \r\n    function currentFee() constant returns (uint feePercentage, string info) {\r\n        feePercentage = fee;\r\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';\r\n    }\r\n    \r\n    function totalEntries() constant returns (uint count, string info) {\r\n        count = entries.length;\r\n        info = 'The number of deposits.';\r\n    }\r\n    \r\n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\r\n    {\r\n        if (users[user].id != address(0x0))\r\n        {\r\n            deposits = users[user].deposits;\r\n            payouts = users[user].payoutsReceived;\r\n            info = 'Users stats: total deposits, payouts received.';\r\n        }\r\n    }\r\n    \r\n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\r\n    {\r\n        if (index < entries.length) {\r\n            user = entries[index].entryAddress;\r\n            payout = entries[index].payout / 1 finney;\r\n            paid = entries[index].paid;\r\n            info = 'Entry info: user address, expected payout in Finneys, payout status.';\r\n        }\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"multiplierFactor\",\"outputs\":[{\"name\":\"factor\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEntries\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userStats\",\"outputs\":[{\"name\":\"deposits\",\"type\":\"uint256\"},{\"name\":\"payouts\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"multi\",\"type\":\"uint256\"}],\"name\":\"changeMultiplier\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentFee\",\"outputs\":[{\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"entryDetails\",\"outputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"paid\",\"type\":\"bool\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"LuckyDoubler","CompilerVersion":"v0.3.1-2016-04-12-3ad5e82","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}