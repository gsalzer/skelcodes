{"status":"1","message":"OK","result":[{"SourceCode":"// King of the Ether Throne Contracts.\r\n// Copyright (c) 2016 Kieran Elby. Released under the MIT License.\r\n// Version 0.9.9.2, July 2016.\r\n//\r\n// See also http://www.kingoftheether.com and\r\n// https://github.com/kieranelby/KingOfTheEtherThrone .\r\n// \r\n// This file contains a number of contracts, of which only\r\n// these three are normally created:\r\n//\r\n// - Kingdom        = maintains the throne for a kingdom\r\n// - World          = runs the world, which is a collection of kingdoms\r\n// - KingdomFactory = used internally by the World contract\r\n//\r\n// The \"Mixin\" contracts (ThroneRulesMixin, ReentryProtectorMixin,\r\n// CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin,\r\n// NameableMixin) contain functions / data / structures used\r\n// by the three main contracts.\r\n// The ExposedInternalsForTesting contract is used by automated tests.\r\n\r\n\r\n/// @title Mixin to help avoid recursive-call attacks.\r\ncontract ReentryProtectorMixin {\r\n\r\n    // true if we are inside an external function\r\n    bool reentryProtector;\r\n\r\n    // Mark contract as having entered an external function.\r\n    // Throws an exception if called twice with no externalLeave().\r\n    // For this to work, Contracts MUST:\r\n    //  - call externalEnter() at the start of each external function\r\n    //  - call externalLeave() at the end of each external function\r\n    //  - never use return statements in between enter and leave\r\n    //  - never call an external function from another function\r\n    // WARN: serious risk of contract getting stuck if used wrongly.\r\n    function externalEnter() internal {\r\n        if (reentryProtector) {\r\n            throw;\r\n        }\r\n        reentryProtector = true;\r\n    }\r\n\r\n    // Mark contract as having left an external function.\r\n    // Do this after each call to externalEnter().\r\n    function externalLeave() internal {\r\n        reentryProtector = false;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Mixin to help send ether to untrusted addresses.\r\ncontract CarefulSenderMixin {\r\n\r\n    // Seems a reasonable amount for a well-written fallback function.\r\n    uint constant suggestedExtraGasToIncludeWithSends = 23000;\r\n\r\n    // Send `_valueWei` of our ether to `_toAddress`, including\r\n    // `_extraGasIncluded` gas above the usual 2300 gas stipend\r\n    // with the send call.\r\n    //\r\n    // This needs care because there is no way to tell if _toAddress\r\n    // is externally owned or is another contract - and sending ether\r\n    // to a contract address will invoke its fallback function; this\r\n    // has three implications:\r\n    //\r\n    // 1) Danger of recursive attack.\r\n    //  The destination contract's fallback function (or another\r\n    //  contract it calls) may call back into this contract (including\r\n    //  our fallback function and external functions inherited, or into\r\n    //  other contracts in our stack), leading to unexpected behaviour.\r\n    //  Mitigations:\r\n    //   - protect all external functions against re-entry into\r\n    //     any of them (see ReentryProtectorMixin);\r\n    //   - program very defensively (e.g. debit balance before send).\r\n    //\r\n    // 2) Destination fallback function can fail.\r\n    //  If the destination contract's fallback function fails, ether\r\n    //  will not be sent and may be locked into the sending contract.\r\n    //  Unlike most errors, it will NOT cause this contract to throw.\r\n    //  Mitigations:\r\n    //   - check the return value from this function (see below).\r\n    //\r\n    // 3) Gas usage.\r\n    //  The destination fallback function will consume the gas supplied\r\n    //  in this transaction (which is fixed and set by the transaction\r\n    //  starter, though some clients do a good job of estimating it.\r\n    //  This is a problem for lottery-type contracts where one very\r\n    //  expensive-to-call receiving contract could 'poison' the lottery\r\n    //  contract by preventing it being invoked by another person who\r\n    //  cannot supply enough gas.\r\n    //  Mitigations:\r\n    //    - choose sensible value for _extraGasIncluded (by default\r\n    //      only 2300 gas is supplied to the destination function);\r\n    //    - if call fails consider whether to throw or to ring-fence\r\n    //      funds for later withdrawal.\r\n    //\r\n    // Returns:\r\n    //\r\n    //  True if-and-only-if the send call was made and did not throw\r\n    //  an error. In this case, we will no longer own the _valueWei\r\n    //  ether. Note that we cannot get the return value of the fallback\r\n    //  function called (if any).\r\n    //\r\n    //  False if the send was made but the destination fallback function\r\n    //  threw an error (or ran out of gas). If this hapens, we still own\r\n    //  _valueWei ether and the destination's actions were undone.\r\n    //\r\n    //  This function should not normally throw an error unless:\r\n    //    - not enough gas to make the send/call\r\n    //    - max call stack depth reached\r\n    //    - insufficient ether\r\n    //\r\n    function carefulSendWithFixedGas(\r\n        address _toAddress,\r\n        uint _valueWei,\r\n        uint _extraGasIncluded\r\n    ) internal returns (bool success) {\r\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Mixin to help track who owns our ether and allow withdrawals.\r\ncontract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {\r\n\r\n    // Record here how much wei is owned by an address.\r\n    // Obviously, the entries here MUST be backed by actual ether\r\n    // owned by the contract - we cannot enforce that in this mixin.\r\n    mapping (address => uint) funds;\r\n\r\n    event FundsWithdrawnEvent(\r\n        address fromAddress,\r\n        address toAddress,\r\n        uint valueWei\r\n    );\r\n\r\n    /// @notice Amount of ether held for `_address`.\r\n    function fundsOf(address _address) constant returns (uint valueWei) {\r\n        return funds[_address];\r\n    }\r\n\r\n    /// @notice Send the caller (`msg.sender`) all ether they own.\r\n    function withdrawFunds() {\r\n        externalEnter();\r\n        withdrawFundsRP();\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Send `_valueWei` of the ether owned by the caller\r\n    /// (`msg.sender`) to `_toAddress`, including `_extraGas` gas\r\n    /// beyond the normal stipend.\r\n    function withdrawFundsAdvanced(\r\n        address _toAddress,\r\n        uint _valueWei,\r\n        uint _extraGas\r\n    ) {\r\n        externalEnter();\r\n        withdrawFundsAdvancedRP(_toAddress, _valueWei, _extraGas);\r\n        externalLeave();\r\n    }\r\n\r\n    /// @dev internal version of withdrawFunds()\r\n    function withdrawFundsRP() internal {\r\n        address fromAddress = msg.sender;\r\n        address toAddress = fromAddress;\r\n        uint allAvailableWei = funds[fromAddress];\r\n        withdrawFundsAdvancedRP(\r\n            toAddress,\r\n            allAvailableWei,\r\n            suggestedExtraGasToIncludeWithSends\r\n        );\r\n    }\r\n\r\n    /// @dev internal version of withdrawFundsAdvanced(), also used\r\n    /// by withdrawFundsRP().\r\n    function withdrawFundsAdvancedRP(\r\n        address _toAddress,\r\n        uint _valueWei,\r\n        uint _extraGasIncluded\r\n    ) internal {\r\n        if (msg.value != 0) {\r\n            throw;\r\n        }\r\n        address fromAddress = msg.sender;\r\n        if (_valueWei > funds[fromAddress]) {\r\n            throw;\r\n        }\r\n        funds[fromAddress] -= _valueWei;\r\n        bool sentOk = carefulSendWithFixedGas(\r\n            _toAddress,\r\n            _valueWei,\r\n            _extraGasIncluded\r\n        );\r\n        if (!sentOk) {\r\n            throw;\r\n        }\r\n        FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Mixin to help make nicer looking ether amounts.\r\ncontract MoneyRounderMixin {\r\n\r\n    /// @notice Make `_rawValueWei` into a nicer, rounder number.\r\n    /// @return A value that:\r\n    ///   - is no larger than `_rawValueWei`\r\n    ///   - is no smaller than `_rawValueWei` * 0.999\r\n    ///   - has no more than three significant figures UNLESS the\r\n    ///     number is very small or very large in monetary terms\r\n    ///     (which we define as < 1 finney or > 10000 ether), in\r\n    ///     which case no precision will be lost.\r\n    function roundMoneyDownNicely(uint _rawValueWei) constant internal\r\n    returns (uint nicerValueWei) {\r\n        if (_rawValueWei < 1 finney) {\r\n            return _rawValueWei;\r\n        } else if (_rawValueWei < 10 finney) {\r\n            return 10 szabo * (_rawValueWei / 10 szabo);\r\n        } else if (_rawValueWei < 100 finney) {\r\n            return 100 szabo * (_rawValueWei / 100 szabo);\r\n        } else if (_rawValueWei < 1 ether) {\r\n            return 1 finney * (_rawValueWei / 1 finney);\r\n        } else if (_rawValueWei < 10 ether) {\r\n            return 10 finney * (_rawValueWei / 10 finney);\r\n        } else if (_rawValueWei < 100 ether) {\r\n            return 100 finney * (_rawValueWei / 100 finney);\r\n        } else if (_rawValueWei < 1000 ether) {\r\n            return 1 ether * (_rawValueWei / 1 ether);\r\n        } else if (_rawValueWei < 10000 ether) {\r\n            return 10 ether * (_rawValueWei / 10 ether);\r\n        } else {\r\n            return _rawValueWei;\r\n        }\r\n    }\r\n    \r\n    /// @notice Convert `_valueWei` into a whole number of finney.\r\n    /// @return The smallest whole number of finney which is equal\r\n    /// to or greater than `_valueWei` when converted to wei.\r\n    /// WARN: May be incorrect if `_valueWei` is above 2**254.\r\n    function roundMoneyUpToWholeFinney(uint _valueWei) constant internal\r\n    returns (uint valueFinney) {\r\n        return (1 finney + _valueWei - 1 wei) / 1 finney;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Mixin to help allow users to name things.\r\ncontract NameableMixin {\r\n\r\n    // String manipulation is expensive in the EVM; keep things short.\r\n\r\n    uint constant minimumNameLength = 1;\r\n    uint constant maximumNameLength = 25;\r\n    string constant nameDataPrefix = \"NAME:\";\r\n\r\n    /// @notice Check if `_name` is a reasonable choice of name.\r\n    /// @return True if-and-only-if `_name_` meets the criteria\r\n    /// below, or false otherwise:\r\n    ///   - no fewer than 1 character\r\n    ///   - no more than 25 characters\r\n    ///   - no characters other than:\r\n    ///     - \"roman\" alphabet letters (A-Z and a-z)\r\n    ///     - western digits (0-9)\r\n    ///     - \"safe\" punctuation: ! ( ) - . _ SPACE\r\n    ///   - at least one non-punctuation character\r\n    /// Note that we deliberately exclude characters which may cause\r\n    /// security problems for websites and databases if escaping is\r\n    /// not performed correctly, such as < > \" and '.\r\n    /// Apologies for the lack of non-English language support.\r\n    function validateNameInternal(string _name) constant internal\r\n    returns (bool allowed) {\r\n        bytes memory nameBytes = bytes(_name);\r\n        uint lengthBytes = nameBytes.length;\r\n        if (lengthBytes < minimumNameLength ||\r\n            lengthBytes > maximumNameLength) {\r\n            return false;\r\n        }\r\n        bool foundNonPunctuation = false;\r\n        for (uint i = 0; i < lengthBytes; i++) {\r\n            byte b = nameBytes[i];\r\n            if (\r\n                (b >= 48 && b <= 57) || // 0 - 9\r\n                (b >= 65 && b <= 90) || // A - Z\r\n                (b >= 97 && b <= 122)   // a - z\r\n            ) {\r\n                foundNonPunctuation = true;\r\n                continue;\r\n            }\r\n            if (\r\n                b == 32 || // space\r\n                b == 33 || // !\r\n                b == 40 || // (\r\n                b == 41 || // )\r\n                b == 45 || // -\r\n                b == 46 || // .\r\n                b == 95    // _\r\n            ) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        return foundNonPunctuation;\r\n    }\r\n\r\n    // Extract a name from bytes `_data` (presumably from `msg.data`),\r\n    // or throw an exception if the data is not in the expected format.\r\n    // \r\n    // We want to make it easy for people to name things, even if\r\n    // they're not comfortable calling functions on contracts.\r\n    //\r\n    // So we allow names to be sent to the fallback function encoded\r\n    // as message data.\r\n    //\r\n    // Unfortunately, the way the Ethereum Function ABI works means we\r\n    // must be careful to avoid clashes between message data that\r\n    // represents our names and message data that represents a call\r\n    // to an external function - otherwise:\r\n    //   a) some names won't be usable;\r\n    //   b) small possibility of a phishing attack where users are\r\n    //     tricked into using certain names which cause an external\r\n    //     function call - e.g. if the data sent to the contract is\r\n    //     keccak256(\"withdrawFunds()\") then a withdrawal will occur.\r\n    //\r\n    // So we require a prefix \"NAME:\" at the start of the name (encoded\r\n    // in ASCII) when sent via the fallback function - this prefix\r\n    // doesn't clash with any external function signature hashes.\r\n    //\r\n    // e.g. web3.fromAscii('NAME:' + 'Joe Bloggs')\r\n    //\r\n    // WARN: this does not check the name for \"reasonableness\";\r\n    // use validateNameInternal() for that.\r\n    //\r\n    function extractNameFromData(bytes _data) constant internal\r\n    returns (string extractedName) {\r\n        // check prefix present\r\n        uint expectedPrefixLength = (bytes(nameDataPrefix)).length;\r\n        if (_data.length < expectedPrefixLength) {\r\n            throw;\r\n        }\r\n        uint i;\r\n        for (i = 0; i < expectedPrefixLength; i++) {\r\n            if ((bytes(nameDataPrefix))[i] != _data[i]) {\r\n                throw;\r\n            }\r\n        }\r\n        // copy data after prefix\r\n        uint payloadLength = _data.length - expectedPrefixLength;\r\n        if (payloadLength < minimumNameLength ||\r\n            payloadLength > maximumNameLength) {\r\n            throw;\r\n        }\r\n        string memory name = new string(payloadLength);\r\n        for (i = 0; i < payloadLength; i++) {\r\n            (bytes(name))[i] = _data[expectedPrefixLength + i];\r\n        }\r\n        return name;\r\n    }\r\n\r\n    // Turn a short name into a \"fuzzy hash\" with the property\r\n    // that extremely similar names will have the same fuzzy hash.\r\n    //\r\n    // This is useful to:\r\n    //  - stop people choosing names which differ only in case or\r\n    //    punctuation and would lead to confusion.\r\n    //  - faciliate searching by name without needing exact match\r\n    //\r\n    // For example, these names all have the same fuzzy hash:\r\n    //\r\n    //  \"Banana\"\r\n    //  \"BANANA\"\r\n    //  \"Ba-na-na\"\r\n    //  \"  banana  \"\r\n    //  \"Banana                        .. so long the end is ignored\"\r\n    //\r\n    // On the other hand, \"Banana1\" and \"A Banana\" are different to\r\n    // the above.\r\n    //\r\n    // WARN: this is likely to work poorly on names that do not meet\r\n    // the validateNameInternal() test.\r\n    //\r\n    function computeNameFuzzyHash(string _name) constant internal\r\n    returns (uint fuzzyHash) {\r\n        bytes memory nameBytes = bytes(_name);\r\n        uint h = 0;\r\n        uint len = nameBytes.length;\r\n        if (len > maximumNameLength) {\r\n            len = maximumNameLength;\r\n        }\r\n        for (uint i = 0; i < len; i++) {\r\n            uint mul = 128;\r\n            byte b = nameBytes[i];\r\n            uint ub = uint(b);\r\n            if (b >= 48 && b <= 57) {\r\n                // 0-9\r\n                h = h * mul + ub;\r\n            } else if (b >= 65 && b <= 90) {\r\n                // A-Z\r\n                h = h * mul + ub;\r\n            } else if (b >= 97 && b <= 122) {\r\n                // fold a-z to A-Z\r\n                uint upper = ub - 32;\r\n                h = h * mul + upper;\r\n            } else {\r\n                // ignore others\r\n            }\r\n        }\r\n        return h;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Mixin to help define the rules of a throne.\r\ncontract ThroneRulesMixin {\r\n\r\n    // See World.createKingdom(..) for documentation.\r\n    struct ThroneRules {\r\n        uint startingClaimPriceWei;\r\n        uint maximumClaimPriceWei;\r\n        uint claimPriceAdjustPercent;\r\n        uint curseIncubationDurationSeconds;\r\n        uint commissionPerThousand;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Maintains the throne of a kingdom.\r\ncontract Kingdom is\r\n  ReentryProtectorMixin,\r\n  CarefulSenderMixin,\r\n  FundsHolderMixin,\r\n  MoneyRounderMixin,\r\n  NameableMixin,\r\n  ThroneRulesMixin {\r\n\r\n    // e.g. \"King of the Ether\"\r\n    string public kingdomName;\r\n\r\n    // The World contract used to create this kingdom, or 0x0 if none.\r\n    address public world;\r\n\r\n    // The rules that govern this kingdom - see ThroneRulesMixin.\r\n    ThroneRules public rules;\r\n\r\n    // Someone who has ruled (or is ruling) our kingdom.\r\n    struct Monarch {\r\n        // where to send their compensation\r\n        address compensationAddress;\r\n        // their name\r\n        string name;\r\n        // when they became our ruler\r\n        uint coronationTimestamp;\r\n        // the claim price paid (excluding any over-payment)\r\n        uint claimPriceWei;\r\n        // the compensation sent to or held for them so far\r\n        uint compensationWei;\r\n    }\r\n\r\n    // The first ruler is number 1; the zero-th entry is a dummy entry.\r\n    Monarch[] public monarchsByNumber;\r\n\r\n    // The topWizard earns half the commission.\r\n    // They are normally the owner of the World contract.\r\n    address public topWizard;\r\n\r\n    // The subWizard earns half the commission.\r\n    // They are normally the creator of this Kingdom.\r\n    // The topWizard and subWizard can be the same address.\r\n    address public subWizard;\r\n\r\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\r\n    // and a rentryProtector from ReentryProtectorMixin.\r\n\r\n    event ThroneClaimedEvent(uint monarchNumber);\r\n    event CompensationSentEvent(address toAddress, uint valueWei);\r\n    event CompensationFailEvent(address toAddress, uint valueWei);\r\n    event CommissionEarnedEvent(address byAddress, uint valueWei);\r\n    event WizardReplacedEvent(address oldWizard, address newWizard);\r\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\r\n\r\n    // WARN - does NOT validate arguments; you MUST either call\r\n    // KingdomFactory.validateProposedThroneRules() or create\r\n    // the Kingdom via KingdomFactory/World's createKingdom().\r\n    // See World.createKingdom(..) for parameter documentation.\r\n    function Kingdom(\r\n        string _kingdomName,\r\n        address _world,\r\n        address _topWizard,\r\n        address _subWizard,\r\n        uint _startingClaimPriceWei,\r\n        uint _maximumClaimPriceWei,\r\n        uint _claimPriceAdjustPercent,\r\n        uint _curseIncubationDurationSeconds,\r\n        uint _commissionPerThousand\r\n    ) {\r\n        kingdomName = _kingdomName;\r\n        world = _world;\r\n        topWizard = _topWizard;\r\n        subWizard = _subWizard;\r\n        rules = ThroneRules(\r\n            _startingClaimPriceWei,\r\n            _maximumClaimPriceWei,\r\n            _claimPriceAdjustPercent,\r\n            _curseIncubationDurationSeconds,\r\n            _commissionPerThousand\r\n        );\r\n        // We number the monarchs starting from 1; it's sometimes useful\r\n        // to use zero = invalid, so put in a dummy entry for number 0.\r\n        monarchsByNumber.push(\r\n            Monarch(\r\n                0,\r\n                \"\",\r\n                0,\r\n                0,\r\n                0\r\n            )\r\n        );\r\n    }\r\n\r\n    function numberOfMonarchs() constant returns (uint totalCount) {\r\n        // zero-th entry is invalid\r\n        return monarchsByNumber.length - 1;\r\n    }\r\n\r\n    // False if either there are no monarchs, or if the latest monarch\r\n    // has reigned too long and been struck down by the curse.\r\n    function isLivingMonarch() constant returns (bool alive) {\r\n        if (numberOfMonarchs() == 0) {\r\n            return false;\r\n        }\r\n        uint reignStartedTimestamp = latestMonarchInternal().coronationTimestamp;\r\n        if (now < reignStartedTimestamp) {\r\n            // Should not be possible, think miners reject blocks with\r\n            // timestamps that go backwards? But some drift possible and\r\n            // it needs handling for unsigned overflow audit checks ...\r\n            return true;\r\n        }\r\n        uint elapsedReignDurationSeconds = now - reignStartedTimestamp;\r\n        if (elapsedReignDurationSeconds > rules.curseIncubationDurationSeconds) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @notice How much you must pay to claim the throne now, in wei.\r\n    function currentClaimPriceWei() constant returns (uint priceInWei) {\r\n        if (!isLivingMonarch()) {\r\n            return rules.startingClaimPriceWei;\r\n        } else {\r\n            uint lastClaimPriceWei = latestMonarchInternal().claimPriceWei;\r\n            // no danger of overflow because claim price never gets that high\r\n            uint newClaimPrice =\r\n              (lastClaimPriceWei * (100 + rules.claimPriceAdjustPercent)) / 100;\r\n            newClaimPrice = roundMoneyDownNicely(newClaimPrice);\r\n            if (newClaimPrice < rules.startingClaimPriceWei) {\r\n                newClaimPrice = rules.startingClaimPriceWei;\r\n            }\r\n            if (newClaimPrice > rules.maximumClaimPriceWei) {\r\n                newClaimPrice = rules.maximumClaimPriceWei;\r\n            }\r\n            return newClaimPrice;\r\n        }\r\n    }\r\n\r\n    /// @notice How much you must pay to claim the throne now, in finney.\r\n    function currentClaimPriceInFinney() constant\r\n    returns (uint priceInFinney) {\r\n        uint valueWei = currentClaimPriceWei();\r\n        return roundMoneyUpToWholeFinney(valueWei);\r\n    }\r\n\r\n    /// @notice Check if a name can be used as a monarch name.\r\n    /// @return True if the name satisfies the criteria of:\r\n    ///   - no fewer than 1 character\r\n    ///   - no more than 25 characters\r\n    ///   - no characters other than:\r\n    ///     - \"roman\" alphabet letters (A-Z and a-z)\r\n    ///     - western digits (0-9)\r\n    ///     - \"safe\" punctuation: ! ( ) - . _ SPACE\r\n    function validateProposedMonarchName(string _monarchName) constant\r\n    returns (bool allowed) {\r\n        return validateNameInternal(_monarchName);\r\n    }\r\n\r\n    // Get details of the latest monarch (even if they are dead).\r\n    //\r\n    // We don't expose externally because returning structs is not well\r\n    // supported in the ABI (strange that monarchsByNumber array works\r\n    // fine though). Note that the reference returned is writable - it\r\n    // can be used to update details of the latest monarch.\r\n    // WARN: you should check numberOfMonarchs() > 0 first.\r\n    function latestMonarchInternal() constant internal\r\n    returns (Monarch storage monarch) {\r\n        return monarchsByNumber[monarchsByNumber.length - 1];\r\n    }\r\n\r\n    /// @notice Claim throne by sending funds to the contract.\r\n    /// Any future compensation earned will be sent to the sender's\r\n    /// address (`msg.sender`).\r\n    /// Sending from a contract is not recommended unless you know\r\n    /// what you're doing (and you've tested it).\r\n    /// If no message data is supplied, the throne will be claimed in\r\n    /// the name of \"Anonymous\". To supply a name, send data encoded\r\n    /// using web3.fromAscii('NAME:' + 'your_chosen_valid_name').\r\n    /// Sender must include payment equal to currentClaimPriceWei().\r\n    /// Will consume up to ~300,000 gas.\r\n    /// Will throw an error if:\r\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\r\n    ///   - payment is too low or too high\r\n    /// Produces events:\r\n    ///   - `ThroneClaimedEvent`\r\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\r\n    ///   - `CommissionEarnedEvent`\r\n    function () {\r\n        externalEnter();\r\n        fallbackRP();\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Claim throne in the given `_monarchName`.\r\n    /// Any future compensation earned will be sent to the caller's\r\n    /// address (`msg.sender`).\r\n    /// Caller must include payment equal to currentClaimPriceWei().\r\n    /// Calling from a contract is not recommended unless you know\r\n    /// what you're doing (and you've tested it).\r\n    /// Will consume up to ~300,000 gas.\r\n    /// Will throw an error if:\r\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\r\n    ///   - payment is too low or too high\r\n    /// Produces events:\r\n    ///   - `ThroneClaimedEvent\r\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\r\n    ///   - `CommissionEarnedEvent`\r\n    function claimThrone(string _monarchName) {\r\n        externalEnter();\r\n        claimThroneRP(_monarchName);\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Used by either the topWizard or subWizard to transfer\r\n    /// all rights to future commissions to the `_replacement` wizard.\r\n    /// WARN: The original wizard retains ownership of any past\r\n    /// commission held for them in the `funds` mapping, which they\r\n    /// can still withdraw.\r\n    /// Produces event WizardReplacedEvent.\r\n    function replaceWizard(address _replacement) {\r\n        externalEnter();\r\n        replaceWizardRP(_replacement);\r\n        externalLeave();\r\n    }\r\n\r\n    function fallbackRP() internal {\r\n        if (msg.data.length == 0) {\r\n            claimThroneRP(\"Anonymous\");\r\n        } else {\r\n            string memory _monarchName = extractNameFromData(msg.data);\r\n            claimThroneRP(_monarchName);\r\n        }\r\n    }\r\n    \r\n    function claimThroneRP(\r\n        string _monarchName\r\n    ) internal {\r\n\r\n        address _compensationAddress = msg.sender;\r\n\r\n        if (!validateNameInternal(_monarchName)) {\r\n            throw;\r\n        }\r\n\r\n        if (_compensationAddress == 0 ||\r\n            _compensationAddress == address(this)) {\r\n            throw;\r\n        }\r\n\r\n        uint paidWei = msg.value;\r\n        uint priceWei = currentClaimPriceWei();\r\n        if (paidWei < priceWei) {\r\n            throw;\r\n        }\r\n        // Make it easy for people to pay using a whole number of finney,\r\n        // which could be a teeny bit higher than the raw wei value.\r\n        uint excessWei = paidWei - priceWei;\r\n        if (excessWei > 1 finney) {\r\n            throw;\r\n        }\r\n        \r\n        uint compensationWei;\r\n        uint commissionWei;\r\n        if (!isLivingMonarch()) {\r\n            // dead men get no compensation\r\n            commissionWei = paidWei;\r\n            compensationWei = 0;\r\n        } else {\r\n            commissionWei = (paidWei * rules.commissionPerThousand) / 1000;\r\n            compensationWei = paidWei - commissionWei;\r\n        }\r\n\r\n        if (commissionWei != 0) {\r\n            recordCommissionEarned(commissionWei);\r\n        }\r\n\r\n        if (compensationWei != 0) {\r\n            compensateLatestMonarch(compensationWei);\r\n        }\r\n\r\n        // In case of any teeny excess, we use the official price here\r\n        // since that should determine the new claim price, not paidWei.\r\n        monarchsByNumber.push(Monarch(\r\n            _compensationAddress,\r\n            _monarchName,\r\n            now,\r\n            priceWei,\r\n            0\r\n        ));\r\n\r\n        ThroneClaimedEvent(monarchsByNumber.length - 1);\r\n    }\r\n\r\n    function replaceWizardRP(address replacement) internal {\r\n        if (msg.value != 0) {\r\n            throw;\r\n        }\r\n        bool replacedOk = false;\r\n        address oldWizard;\r\n        if (msg.sender == topWizard) {\r\n            oldWizard = topWizard;\r\n            topWizard = replacement;\r\n            WizardReplacedEvent(oldWizard, replacement);\r\n            replacedOk = true;\r\n        }\r\n        // Careful - topWizard and subWizard can be the same address,\r\n        // in which case we must replace both.\r\n        if (msg.sender == subWizard) {\r\n            oldWizard = subWizard;\r\n            subWizard = replacement;\r\n            WizardReplacedEvent(oldWizard, replacement);\r\n            replacedOk = true;\r\n        }\r\n        if (!replacedOk) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    // Allow commission funds to build up in contract for the wizards\r\n    // to withdraw (carefully ring-fenced).\r\n    function recordCommissionEarned(uint _commissionWei) internal {\r\n        // give the subWizard any \"odd\" single wei\r\n        uint topWizardWei = _commissionWei / 2;\r\n        uint subWizardWei = _commissionWei - topWizardWei;\r\n        funds[topWizard] += topWizardWei;\r\n        CommissionEarnedEvent(topWizard, topWizardWei);\r\n        funds[subWizard] += subWizardWei;\r\n        CommissionEarnedEvent(subWizard, subWizardWei);\r\n    }\r\n\r\n    // Send compensation to latest monarch (or hold funds for them\r\n    // if cannot through no fault of current caller).\r\n    function compensateLatestMonarch(uint _compensationWei) internal {\r\n        address compensationAddress =\r\n          latestMonarchInternal().compensationAddress;\r\n        // record that we compensated them\r\n        latestMonarchInternal().compensationWei = _compensationWei;\r\n        // WARN: if the latest monarch is a contract whose fallback\r\n        // function needs more 25300 gas than then they will NOT\r\n        // receive compensation automatically.\r\n        bool sentOk = carefulSendWithFixedGas(\r\n            compensationAddress,\r\n            _compensationWei,\r\n            suggestedExtraGasToIncludeWithSends\r\n        );\r\n        if (sentOk) {\r\n            CompensationSentEvent(compensationAddress, _compensationWei);\r\n        } else {\r\n            // This should only happen if the latest monarch is a contract\r\n            // whose fallback-function failed or ran out of gas (despite\r\n            // us including a fair amount of gas).\r\n            // We do not throw since we do not want the throne to get\r\n            // 'stuck' (it's not the new usurpers fault) - instead save\r\n            // the funds we could not send so can be claimed later.\r\n            // Their monarch contract would need to have been designed\r\n            // to call our withdrawFundsAdvanced(..) function mind you.\r\n            funds[compensationAddress] += _compensationWei;\r\n            CompensationFailEvent(compensationAddress, _compensationWei);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Used by the World contract to create Kingdom instances.\r\n/// @dev Mostly exists so topWizard can potentially replace this\r\n/// contract to modify the Kingdom contract and/or rule validation\r\n/// logic to be used for *future* Kingdoms created by the World.\r\n/// We do not implement rentry protection because we don't send/call.\r\n/// We do not charge a fee here - but if you bypass the World then\r\n/// you won't be listed on the official World page of course.\r\ncontract KingdomFactory {\r\n\r\n    function KingdomFactory() {\r\n    }\r\n\r\n    function () {\r\n        // this contract should never have a balance\r\n        throw;\r\n    }\r\n\r\n    // See World.createKingdom(..) for parameter documentation.\r\n    function validateProposedThroneRules(\r\n        uint _startingClaimPriceWei,\r\n        uint _maximumClaimPriceWei,\r\n        uint _claimPriceAdjustPercent,\r\n        uint _curseIncubationDurationSeconds,\r\n        uint _commissionPerThousand\r\n    ) constant returns (bool allowed) {\r\n        // I suppose there is a danger that massive deflation/inflation could\r\n        // change the real-world sanity of these checks, but in that case we\r\n        // can deploy a new factory and update the world.\r\n        if (_startingClaimPriceWei < 1 finney ||\r\n            _startingClaimPriceWei > 100 ether) {\r\n            return false;\r\n        }\r\n        if (_maximumClaimPriceWei < 1 ether ||\r\n            _maximumClaimPriceWei > 100000 ether) {\r\n            return false;\r\n        }\r\n        if (_startingClaimPriceWei * 20 > _maximumClaimPriceWei) {\r\n            return false;\r\n        }\r\n        if (_claimPriceAdjustPercent < 1 ||\r\n            _claimPriceAdjustPercent > 900) {\r\n            return false;\r\n        }\r\n        if (_curseIncubationDurationSeconds < 2 hours ||\r\n            _curseIncubationDurationSeconds > 10000 days) {\r\n            return false;\r\n        }\r\n        if (_commissionPerThousand < 10 ||\r\n            _commissionPerThousand > 100) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Create a new Kingdom. Normally called by World contract.\r\n    /// WARN: Does NOT validate the _kingdomName or _world arguments.\r\n    /// Will consume up to 1,800,000 gas (!)\r\n    /// Will throw an error if:\r\n    ///   - rules invalid (see validateProposedThroneRules)\r\n    ///   - wizard addresses \"obviously\" wrong\r\n    ///   - out of gas quite likely (perhaps in future should consider\r\n    ///     using solidity libraries to reduce Kingdom size?)\r\n    // See World.createKingdom(..) for parameter documentation.\r\n    function createKingdom(\r\n        string _kingdomName,\r\n        address _world,\r\n        address _topWizard,\r\n        address _subWizard,\r\n        uint _startingClaimPriceWei,\r\n        uint _maximumClaimPriceWei,\r\n        uint _claimPriceAdjustPercent,\r\n        uint _curseIncubationDurationSeconds,\r\n        uint _commissionPerThousand\r\n    ) returns (Kingdom newKingdom) {\r\n        if (msg.value > 0) {\r\n            // this contract should never have a balance\r\n            throw;\r\n        }\r\n        // NB: topWizard and subWizard CAN be the same as each other.\r\n        if (_topWizard == 0 || _subWizard == 0) {\r\n            throw;\r\n        }\r\n        if (_topWizard == _world || _subWizard == _world) {\r\n            throw;\r\n        }\r\n        if (!validateProposedThroneRules(\r\n            _startingClaimPriceWei,\r\n            _maximumClaimPriceWei,\r\n            _claimPriceAdjustPercent,\r\n            _curseIncubationDurationSeconds,\r\n            _commissionPerThousand\r\n        )) {\r\n            throw;\r\n        }\r\n        return new Kingdom(\r\n            _kingdomName,\r\n            _world,\r\n            _topWizard,\r\n            _subWizard,\r\n            _startingClaimPriceWei,\r\n            _maximumClaimPriceWei,\r\n            _claimPriceAdjustPercent,\r\n            _curseIncubationDurationSeconds,\r\n            _commissionPerThousand\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Runs the world, which is a collection of Kingdoms.\r\ncontract World is\r\n  ReentryProtectorMixin,\r\n  NameableMixin,\r\n  MoneyRounderMixin,\r\n  FundsHolderMixin,\r\n  ThroneRulesMixin {\r\n\r\n    // The topWizard runs the world. They charge for the creation of\r\n    // kingdoms and become the topWizard in each kingdom created.\r\n    address public topWizard;\r\n\r\n    // How much one must pay to create a new kingdom (in wei).\r\n    // Can be changed by the topWizard.\r\n    uint public kingdomCreationFeeWei;\r\n\r\n    struct KingdomListing {\r\n        uint kingdomNumber;\r\n        string kingdomName;\r\n        address kingdomContract;\r\n        address kingdomCreator;\r\n        uint creationTimestamp;\r\n        address kingdomFactoryUsed;\r\n    }\r\n    \r\n    // The first kingdom is number 1; the zero-th entry is a dummy.\r\n    KingdomListing[] public kingdomsByNumber;\r\n\r\n    // For safety, we cap just how high the price can get.\r\n    // Can be changed by the topWizard, though it will only affect\r\n    // kingdoms created after that.\r\n    uint public maximumClaimPriceWei;\r\n\r\n    // Helper contract for creating Kingdom instances. Can be\r\n    // upgraded by the topWizard (won't affect existing ones).\r\n    KingdomFactory public kingdomFactory;\r\n\r\n    // Avoids duplicate kingdom names and allows searching by name.\r\n    mapping (uint => uint) kingdomNumbersByfuzzyHash;\r\n\r\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\r\n    // and a rentryProtector from ReentryProtectorMixin.\r\n\r\n    event KingdomCreatedEvent(uint kingdomNumber);\r\n    event CreationFeeChangedEvent(uint newFeeWei);\r\n    event FactoryChangedEvent(address newFactory);\r\n    event WizardReplacedEvent(address oldWizard, address newWizard);\r\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\r\n\r\n    // Create the world with no kingdoms yet.\r\n    // Costs about 1.9M gas to deploy.\r\n    function World(\r\n        address _topWizard,\r\n        uint _kingdomCreationFeeWei,\r\n        KingdomFactory _kingdomFactory,\r\n        uint _maximumClaimPriceWei\r\n    ) {\r\n        if (_topWizard == 0) {\r\n            throw;\r\n        }\r\n        if (_maximumClaimPriceWei < 1 ether) {\r\n            throw;\r\n        }\r\n        topWizard = _topWizard;\r\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\r\n        kingdomFactory = _kingdomFactory;\r\n        maximumClaimPriceWei = _maximumClaimPriceWei;\r\n        // We number the kingdoms starting from 1 since it's sometimes\r\n        // useful to use zero = invalid. Create dummy zero-th entry.\r\n        kingdomsByNumber.push(KingdomListing(0, \"\", 0, 0, 0, 0));\r\n    }\r\n\r\n    function numberOfKingdoms() constant returns (uint totalCount) {\r\n        return kingdomsByNumber.length - 1;\r\n    }\r\n\r\n    /// @return index into kingdomsByNumber if found, or zero if not. \r\n    function findKingdomCalled(string _kingdomName) constant\r\n    returns (uint kingdomNumber) {\r\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\r\n        return kingdomNumbersByfuzzyHash[fuzzyHash];\r\n    }\r\n\r\n    /// @notice Check if a name can be used as a kingdom name.\r\n    /// @return True if the name satisfies the criteria of:\r\n    ///   - no fewer than 1 character\r\n    ///   - no more than 25 characters\r\n    ///   - no characters other than:\r\n    ///     - \"roman\" alphabet letters (A-Z and a-z)\r\n    ///     - western digits (0-9)\r\n    ///     - \"safe\" punctuation: ! ( ) - . _ SPACE\r\n    ///\r\n    /// WARN: does not check if the name is already in use;\r\n    /// use `findKingdomCalled(string)` for that afterwards.\r\n    function validateProposedKingdomName(string _kingdomName) constant\r\n    returns (bool allowed) {\r\n        return validateNameInternal(_kingdomName);\r\n    }\r\n\r\n    // Check if rules would be allowed for a new custom Kingdom.\r\n    // Typically used before calling `createKingdom(...)`.\r\n    function validateProposedThroneRules(\r\n        uint _startingClaimPriceWei,\r\n        uint _claimPriceAdjustPercent,\r\n        uint _curseIncubationDurationSeconds,\r\n        uint _commissionPerThousand\r\n    ) constant returns (bool allowed) {\r\n        return kingdomFactory.validateProposedThroneRules(\r\n            _startingClaimPriceWei,\r\n            maximumClaimPriceWei,\r\n            _claimPriceAdjustPercent,\r\n            _curseIncubationDurationSeconds,\r\n            _commissionPerThousand\r\n        );\r\n    }\r\n\r\n    // How much one must pay to create a new kingdom (in finney).\r\n    // Can be changed by the topWizard.\r\n    function kingdomCreationFeeInFinney() constant\r\n    returns (uint feeInFinney) {\r\n        return roundMoneyUpToWholeFinney(kingdomCreationFeeWei);\r\n    }\r\n\r\n    // Reject funds sent to the contract - wizards who cannot interact\r\n    // with it via the API won't be able to withdraw their commission.\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    /// @notice Create a new kingdom using custom rules.\r\n    /// @param _kingdomName \\\r\n    ///   e.g. \"King of the Ether Throne\"\r\n    /// @param _startingClaimPriceWei \\\r\n    ///   How much it will cost the first monarch to claim the throne\r\n    ///   (and also the price after the death of a monarch).\r\n    /// @param _claimPriceAdjustPercent \\\r\n    ///   Percentage increase after each claim - e.g. if claim price\r\n    ///   was 200 ETH, and `_claimPriceAdjustPercent` is 50, the next\r\n    ///   claim price will be 200 ETH + (50% of 200 ETH) => 300 ETH.\r\n    /// @param _curseIncubationDurationSeconds \\\r\n    ///   The maximum length of a time a monarch can rule before the\r\n    ///   curse strikes and they are removed without compensation.\r\n    /// @param _commissionPerThousand \\\r\n    ///   How much of each payment is given to the wizards to share,\r\n    ///   expressed in parts per thousand - e.g. 25 means 25/1000,\r\n    ///   or 2.5%.\r\n    /// \r\n    /// Caller must include payment equal to kingdomCreationFeeWei.\r\n    /// The caller will become the 'sub-wizard' and will earn half\r\n    /// any commission charged by the Kingdom.  Note however they\r\n    /// will need to call withdrawFunds() on the Kingdom contract\r\n    /// to get their commission - it's not send automatically.\r\n    ///\r\n    /// Will consume up to 1,900,000 gas (!)\r\n    /// Will throw an error if:\r\n    ///   - name is invalid (see `validateProposedKingdomName(string)`)\r\n    ///   - name is already in use (see `findKingdomCalled(string)`)\r\n    ///   - rules are invalid (see `validateProposedKingdomRules(...)`)\r\n    ///   - payment is too low or too high\r\n    ///   - insufficient gas (quite likely!)\r\n    /// Produces event KingdomCreatedEvent.\r\n    function createKingdom(\r\n        string _kingdomName,\r\n        uint _startingClaimPriceWei,\r\n        uint _claimPriceAdjustPercent,\r\n        uint _curseIncubationDurationSeconds,\r\n        uint _commissionPerThousand\r\n    ) {\r\n        externalEnter();\r\n        createKingdomRP(\r\n            _kingdomName,\r\n            _startingClaimPriceWei,\r\n            _claimPriceAdjustPercent,\r\n            _curseIncubationDurationSeconds,\r\n            _commissionPerThousand\r\n        );\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Used by topWizard to transfer all rights to future\r\n    /// fees and future kingdom wizardships to `_replacement` wizard.\r\n    /// WARN: The original wizard retains ownership of any past fees\r\n    /// held for them in the `funds` mapping, which they can still\r\n    /// withdraw. They also remain topWizard in any existing Kingdoms.\r\n    /// Produces event WizardReplacedEvent.\r\n    function replaceWizard(address _replacement) {\r\n        externalEnter();\r\n        replaceWizardRP(_replacement);\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Used by topWizard to vary the fee for creating kingdoms.\r\n    function setKingdomCreationFeeWei(uint _kingdomCreationFeeWei) {\r\n        externalEnter();\r\n        setKingdomCreationFeeWeiRP(_kingdomCreationFeeWei);\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Used by topWizard to vary the cap on claim price.\r\n    function setMaximumClaimPriceWei(uint _maximumClaimPriceWei) {\r\n        externalEnter();\r\n        setMaximumClaimPriceWeiRP(_maximumClaimPriceWei);\r\n        externalLeave();\r\n    }\r\n\r\n    /// @notice Used by topWizard to vary the factory contract which\r\n    /// will be used to create future Kingdoms.\r\n    function setKingdomFactory(KingdomFactory _kingdomFactory) {\r\n        externalEnter();\r\n        setKingdomFactoryRP(_kingdomFactory);\r\n        externalLeave();\r\n    }\r\n\r\n    function createKingdomRP(\r\n        string _kingdomName,\r\n        uint _startingClaimPriceWei,\r\n        uint _claimPriceAdjustPercent,\r\n        uint _curseIncubationDurationSeconds,\r\n        uint _commissionPerThousand\r\n    ) internal {\r\n\r\n        address subWizard = msg.sender;\r\n\r\n        if (!validateNameInternal(_kingdomName)) {\r\n            throw;\r\n        }\r\n\r\n        uint newKingdomNumber = kingdomsByNumber.length;\r\n        checkUniqueAndRegisterNewKingdomName(\r\n            _kingdomName,\r\n            newKingdomNumber\r\n        );\r\n\r\n        uint paidWei = msg.value;\r\n        if (paidWei < kingdomCreationFeeWei) {\r\n            throw;\r\n        }\r\n        // Make it easy for people to pay using a whole number of finney,\r\n        // which could be a teeny bit higher than the raw wei value.\r\n        uint excessWei = paidWei - kingdomCreationFeeWei;\r\n        if (excessWei > 1 finney) {\r\n            throw;\r\n        }\r\n        funds[topWizard] += paidWei;\r\n        \r\n        // This will perform rule validation.\r\n        Kingdom kingdomContract = kingdomFactory.createKingdom(\r\n            _kingdomName,\r\n            address(this),\r\n            topWizard,\r\n            subWizard,\r\n            _startingClaimPriceWei,\r\n            maximumClaimPriceWei,\r\n            _claimPriceAdjustPercent,\r\n            _curseIncubationDurationSeconds,\r\n            _commissionPerThousand\r\n        );\r\n\r\n        kingdomsByNumber.push(KingdomListing(\r\n            newKingdomNumber,\r\n            _kingdomName,\r\n            kingdomContract,\r\n            msg.sender,\r\n            now,\r\n            kingdomFactory\r\n        ));\r\n    }\r\n\r\n    function replaceWizardRP(address replacement) internal { \r\n        if (msg.sender != topWizard) {\r\n            throw;\r\n        }\r\n        if (msg.value != 0) {\r\n            throw;\r\n        }\r\n        address oldWizard = topWizard;\r\n        topWizard = replacement;\r\n        WizardReplacedEvent(oldWizard, replacement);\r\n    }\r\n\r\n    function setKingdomCreationFeeWeiRP(uint _kingdomCreationFeeWei) internal {\r\n        if (msg.sender != topWizard) {\r\n            throw;\r\n        }\r\n        if (msg.value != 0) {\r\n            throw;\r\n        }\r\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\r\n        CreationFeeChangedEvent(kingdomCreationFeeWei);\r\n    }\r\n\r\n    function setMaximumClaimPriceWeiRP(uint _maximumClaimPriceWei) internal {\r\n        if (msg.sender != topWizard) {\r\n            throw;\r\n        }\r\n        if (_maximumClaimPriceWei < 1 ether) {\r\n            throw;\r\n        }\r\n        maximumClaimPriceWei = _maximumClaimPriceWei;\r\n    }\r\n\r\n    function setKingdomFactoryRP(KingdomFactory _kingdomFactory) internal {\r\n        if (msg.sender != topWizard) {\r\n            throw;\r\n        }\r\n        if (msg.value != 0) {\r\n            throw;\r\n        }\r\n        kingdomFactory = _kingdomFactory;\r\n        FactoryChangedEvent(kingdomFactory);\r\n    }\r\n\r\n    // If there is no existing kingdom called `_kingdomName`, create\r\n    // a record mapping that name to kingdom no. `_newKingdomNumber`.\r\n    // Throws an error if an existing kingdom with the same (or\r\n    // fuzzily similar - see computeNameFuzzyHash) name exists.\r\n    function checkUniqueAndRegisterNewKingdomName(\r\n        string _kingdomName,\r\n        uint _newKingdomNumber\r\n    ) internal {\r\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\r\n        if (kingdomNumbersByfuzzyHash[fuzzyHash] != 0) {\r\n            throw;\r\n        }\r\n        kingdomNumbersByfuzzyHash[fuzzyHash] = _newKingdomNumber;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Used on the testnet to allow automated testing of internals.\r\ncontract ExposedInternalsForTesting is\r\n  MoneyRounderMixin, NameableMixin {\r\n\r\n    function roundMoneyDownNicelyET(uint _rawValueWei) constant\r\n    returns (uint nicerValueWei) {\r\n        return roundMoneyDownNicely(_rawValueWei);\r\n    }\r\n\r\n    function roundMoneyUpToWholeFinneyET(uint _valueWei) constant\r\n    returns (uint valueFinney) {\r\n        return roundMoneyUpToWholeFinney(_valueWei);\r\n    }\r\n\r\n    function validateNameInternalET(string _name) constant\r\n    returns (bool allowed) {\r\n        return validateNameInternal(_name);\r\n    }\r\n\r\n    function extractNameFromDataET(bytes _data) constant\r\n    returns (string extractedName) {\r\n        return extractNameFromData(_data);\r\n    }\r\n    \r\n    function computeNameFuzzyHashET(string _name) constant\r\n    returns (uint fuzzyHash) {\r\n        return computeNameFuzzyHash(_name);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"kingdomFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfKingdoms\",\"outputs\":[{\"name\":\"totalCount\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"fundsOf\",\"outputs\":[{\"name\":\"valueWei\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kingdomName\",\"type\":\"string\"}],\"name\":\"validateProposedKingdomName\",\"outputs\":[{\"name\":\"allowed\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kingdomName\",\"type\":\"string\"},{\"name\":\"_startingClaimPriceWei\",\"type\":\"uint256\"},{\"name\":\"_claimPriceAdjustPercent\",\"type\":\"uint256\"},{\"name\":\"_curseIncubationDurationSeconds\",\"type\":\"uint256\"},{\"name\":\"_commissionPerThousand\",\"type\":\"uint256\"}],\"name\":\"createKingdom\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumClaimPriceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maximumClaimPriceWei\",\"type\":\"uint256\"}],\"name\":\"setMaximumClaimPriceWei\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kingdomsByNumber\",\"outputs\":[{\"name\":\"kingdomNumber\",\"type\":\"uint256\"},{\"name\":\"kingdomName\",\"type\":\"string\"},{\"name\":\"kingdomContract\",\"type\":\"address\"},{\"name\":\"kingdomCreator\",\"type\":\"address\"},{\"name\":\"creationTimestamp\",\"type\":\"uint256\"},{\"name\":\"kingdomFactoryUsed\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_replacement\",\"type\":\"address\"}],\"name\":\"replaceWizard\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kingdomCreationFeeWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_startingClaimPriceWei\",\"type\":\"uint256\"},{\"name\":\"_claimPriceAdjustPercent\",\"type\":\"uint256\"},{\"name\":\"_curseIncubationDurationSeconds\",\"type\":\"uint256\"},{\"name\":\"_commissionPerThousand\",\"type\":\"uint256\"}],\"name\":\"validateProposedThroneRules\",\"outputs\":[{\"name\":\"allowed\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kingdomName\",\"type\":\"string\"}],\"name\":\"findKingdomCalled\",\"outputs\":[{\"name\":\"kingdomNumber\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kingdomFactory\",\"type\":\"address\"}],\"name\":\"setKingdomFactory\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topWizard\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kingdomCreationFeeWei\",\"type\":\"uint256\"}],\"name\":\"setKingdomCreationFeeWei\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_valueWei\",\"type\":\"uint256\"},{\"name\":\"_extraGas\",\"type\":\"uint256\"}],\"name\":\"withdrawFundsAdvanced\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kingdomCreationFeeInFinney\",\"outputs\":[{\"name\":\"feeInFinney\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_topWizard\",\"type\":\"address\"},{\"name\":\"_kingdomCreationFeeWei\",\"type\":\"uint256\"},{\"name\":\"_kingdomFactory\",\"type\":\"address\"},{\"name\":\"_maximumClaimPriceWei\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"kingdomNumber\",\"type\":\"uint256\"}],\"name\":\"KingdomCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFeeWei\",\"type\":\"uint256\"}],\"name\":\"CreationFeeChangedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFactory\",\"type\":\"address\"}],\"name\":\"FactoryChangedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldWizard\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newWizard\",\"type\":\"address\"}],\"name\":\"WizardReplacedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueWei\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawnEvent\",\"type\":\"event\"}]","ContractName":"World","CompilerVersion":"v0.3.5-2016-07-21-6610add","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002a9110f3f0b32e7e29329cb7200d46f9c754fd8f000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000cc9724b345887827cb5eae025cad9f4ccc3c90f600000000000000000000000000000000000000000000152d02c7e14af6800000","Library":"","SwarmSource":""}]}