{"status":"1","message":"OK","result":[{"SourceCode":"contract Etheropt {\r\n\r\n  struct Option {\r\n    int strike;\r\n  }\r\n  struct Position {\r\n    mapping(uint => int) positions;\r\n    int cash;\r\n    bool expired;\r\n    bool hasPosition;\r\n  }\r\n  struct OptionChain {\r\n    uint expiration;\r\n    string underlying;\r\n    uint margin;\r\n    uint realityID;\r\n    bytes32 factHash;\r\n    address ethAddr;\r\n    mapping(uint => Option) options;\r\n    uint numOptions;\r\n    bool expired;\r\n    mapping(address => Position) positions;\r\n    uint numPositions;\r\n    uint numPositionsExpired;\r\n  }\r\n  mapping(uint => OptionChain) optionChains;\r\n  uint numOptionChains;\r\n  struct Account {\r\n    address user;\r\n    int capital;\r\n  }\r\n  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\r\n  struct MarketMaker {\r\n    address user;\r\n    string server;\r\n  }\r\n  mapping(uint => MarketMaker) marketMakers; //starts at 1\r\n  uint public numMarketMakers = 0;\r\n  mapping(address => uint) marketMakerIDs;\r\n  mapping(uint => Account) accounts;\r\n  uint public numAccounts;\r\n  mapping(address => uint) accountIDs; //starts at 1\r\n\r\n  function Market() {\r\n  }\r\n\r\n  function getAccountID(address user) constant returns(uint) {\r\n    return accountIDs[user];\r\n  }\r\n\r\n  function getAccount(uint accountID) constant returns(address) {\r\n    return accounts[accountID].user;\r\n  }\r\n\r\n  function addFunds() {\r\n    if (accountIDs[msg.sender]>0) {\r\n      accounts[accountIDs[msg.sender]].capital += int(msg.value);\r\n    } else {\r\n      uint accountID = ++numAccounts;\r\n      accounts[accountID].user = msg.sender;\r\n      accounts[accountID].capital += int(msg.value);\r\n      accountIDs[msg.sender] = accountID;\r\n    }\r\n  }\r\n\r\n  function withdrawFunds(uint amount) {\r\n    if (accountIDs[msg.sender]>0) {\r\n      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\r\n        accounts[accountIDs[msg.sender]].capital -= int(amount);\r\n        msg.sender.send(amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getFunds(address user, bool onlyAvailable) constant returns(int) {\r\n    if (accountIDs[user]>0) {\r\n      if (onlyAvailable == false) {\r\n        return accounts[accountIDs[user]].capital;\r\n      } else {\r\n        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);\r\n      }\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function getFundsAndAvailable(address user) constant returns(int, int) {\r\n    return (getFunds(user, false), getFunds(user, true));\r\n  }\r\n\r\n  function marketMaker(string server) {\r\n    if (msg.value>0) throw;\r\n    if (marketMakerIDs[msg.sender]>0) {\r\n      marketMakers[marketMakerIDs[msg.sender]].server = server;\r\n    } else {\r\n      int funds = getFunds(marketMakers[i].user, false);\r\n      uint marketMakerID = 0;\r\n      if (numMarketMakers<6) {\r\n        marketMakerID = ++numMarketMakers;\r\n      } else {\r\n        for (uint i=2; i<=numMarketMakers; i++) {\r\n          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\r\n            marketMakerID = i;\r\n          }\r\n        }\r\n      }\r\n      if (marketMakerID>0) {\r\n        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\r\n        marketMakers[marketMakerID].user = msg.sender;\r\n        marketMakers[marketMakerID].server = server;\r\n        marketMakerIDs[msg.sender] = marketMakerID;\r\n      } else {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getMarketMakers() constant returns(string, string, string, string, string, string) {\r\n    string[] memory servers = new string[](6);\r\n    for (uint i=1; i<=numMarketMakers; i++) {\r\n      servers[i-1] = marketMakers[i].server;\r\n    }\r\n    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\r\n  }\r\n\r\n  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\r\n    int[] memory funds = new int[](6);\r\n    for (uint i=1; i<=numMarketMakers; i++) {\r\n      funds[i-1] = getFunds(marketMakers[i].user, false);\r\n    }\r\n    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\r\n  }\r\n\r\n  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {\r\n    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);\r\n  }\r\n\r\n  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\r\n    uint[] memory optionIDs = new uint[](60);\r\n    int[] memory strikes = new int[](60);\r\n    int[] memory positions = new int[](60);\r\n    int[] memory cashes = new int[](60);\r\n    uint z = 0;\r\n    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {\r\n      if (optionChains[uint(optionChainID)].expired == false) {\r\n        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {\r\n          optionIDs[z] = uint(optionChainID)*1000 + optionID;\r\n          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;\r\n          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];\r\n          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;\r\n          z++;\r\n        }\r\n      }\r\n    }\r\n    return (optionIDs, strikes, positions, cashes);\r\n  }\r\n\r\n  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\r\n    if (optionChains[optionChainID].expired == false) {\r\n      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {\r\n        uint lastAccount = numAccounts;\r\n        if (accountID==0) {\r\n          accountID = 1;\r\n        } else {\r\n          lastAccount = accountID;\r\n        }\r\n        for (accountID=accountID; accountID<=lastAccount; accountID++) {\r\n          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {\r\n            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;\r\n            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {\r\n              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);\r\n              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\r\n            }\r\n            accounts[accountID].capital = accounts[accountID].capital + result;\r\n            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;\r\n            optionChains[optionChainID].numPositionsExpired++;\r\n          }\r\n        }\r\n        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {\r\n          optionChains[optionChainID].expired = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\r\n    if (strike>=0) { //call\r\n      if (settlement>uint(strike)) {\r\n        if (settlement-uint(strike)<margin) {\r\n          return int(settlement-uint(strike));\r\n        } else {\r\n          return int(margin);\r\n        }\r\n      } else {\r\n        return 0;\r\n      }\r\n    } else { //put\r\n      if (settlement<uint(-strike)) {\r\n        if (uint(-strike)-settlement<margin) {\r\n          return int(uint(-strike)-settlement);\r\n        } else {\r\n          return int(margin);\r\n        }\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {\r\n    uint optionChainID = 6;\r\n    if (numOptionChains<6) {\r\n      optionChainID = numOptionChains++;\r\n    } else {\r\n      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {\r\n        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {\r\n          optionChainID = i;\r\n        }\r\n      }\r\n    }\r\n    if (optionChainID<6) {\r\n      delete optionChains[optionChainID];\r\n      optionChains[optionChainID].expiration = expiration;\r\n      optionChains[optionChainID].underlying = underlying;\r\n      optionChains[optionChainID].margin = margin;\r\n      optionChains[optionChainID].realityID = realityID;\r\n      optionChains[optionChainID].factHash = factHash;\r\n      optionChains[optionChainID].ethAddr = ethAddr;\r\n      for (i=0; i < strikes.length; i++) {\r\n        if (optionChains[optionChainID].numOptions<10) {\r\n          uint optionID = optionChains[optionChainID].numOptions++;\r\n          Option option = optionChains[optionChainID].options[i];\r\n          option.strike = strikes[i];\r\n          optionChains[optionChainID].options[i] = option;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {\r\n    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\r\n    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);\r\n    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\r\n      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {\r\n        optionChains[optionChainID].positions[msg.sender].hasPosition = true;\r\n        optionChains[optionChainID].numPositions++;\r\n      }\r\n      if (optionChains[optionChainID].positions[addr].hasPosition == false) {\r\n        optionChains[optionChainID].positions[addr].hasPosition = true;\r\n        optionChains[optionChainID].numPositions++;\r\n      }\r\n      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;\r\n      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);\r\n      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;\r\n      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);\r\n      orderFills[hash] -= matchSize;\r\n    }\r\n  }\r\n\r\n  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {\r\n    int totalMaxLoss = 0;\r\n    for (uint i=0; i<numOptionChains; i++) {\r\n      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {\r\n        bool maxLossInitialized = false;\r\n        int maxLoss = 0;\r\n        for (uint s=0; s<optionChains[i].numOptions; s++) {\r\n          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;\r\n          if (i==optionChainID) {\r\n            pnl += cashChange / 1000000000000000000;\r\n          }\r\n          uint settlement = 0;\r\n          if (optionChains[i].options[s].strike<0) {\r\n            settlement = uint(-optionChains[i].options[s].strike);\r\n          } else {\r\n            settlement = uint(optionChains[i].options[s].strike);\r\n          }\r\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\r\n          if (pnl<maxLoss || maxLossInitialized==false) {\r\n            maxLossInitialized = true;\r\n            maxLoss = pnl;\r\n          }\r\n          pnl = optionChains[i].positions[user].cash / 1000000000000000000;\r\n          if (i==optionChainID) {\r\n            pnl += cashChange / 1000000000000000000;\r\n          }\r\n          settlement = 0;\r\n          if (optionChains[i].options[s].strike<0) {\r\n            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {\r\n              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;\r\n            } else {\r\n              settlement = 0;\r\n            }\r\n          } else {\r\n            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;\r\n          }\r\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\r\n          if (pnl<maxLoss) {\r\n            maxLoss = pnl;\r\n          }\r\n        }\r\n        totalMaxLoss += maxLoss;\r\n      }\r\n    }\r\n    return totalMaxLoss;\r\n  }\r\n\r\n  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {\r\n    int pnl = 0;\r\n    for (uint j=0; j<optionChains[i].numOptions; j++) {\r\n      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\r\n      if (i==optionChainID && j==optionID) {\r\n        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\r\n      }\r\n    }\r\n    return pnl;\r\n  }\r\n\r\n  function min(uint a, uint b) constant returns(uint) {\r\n    if (a<b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"accountID\",\"type\":\"uint256\"},{\"name\":\"optionChainID\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"expire\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketMakerFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"optionChainID\",\"type\":\"uint256\"}],\"name\":\"getOptionChain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketMakers\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"optionChainID\",\"type\":\"uint256\"},{\"name\":\"optionID\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"size\",\"type\":\"int256\"},{\"name\":\"orderID\",\"type\":\"uint256\"},{\"name\":\"blockExpires\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"matchSize\",\"type\":\"int256\"}],\"name\":\"orderMatchTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"server\",\"type\":\"string\"}],\"name\":\"marketMaker\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"onlyAvailable\",\"type\":\"bool\"}],\"name\":\"getFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Market\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"optionChainID\",\"type\":\"uint256\"},{\"name\":\"optionID\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"size\",\"type\":\"int256\"},{\"name\":\"orderID\",\"type\":\"uint256\"},{\"name\":\"blockExpires\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"matchSize\",\"type\":\"int256\"}],\"name\":\"orderMatch\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAccountID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"underlying\",\"type\":\"string\"},{\"name\":\"margin\",\"type\":\"uint256\"},{\"name\":\"realityID\",\"type\":\"uint256\"},{\"name\":\"factHash\",\"type\":\"bytes32\"},{\"name\":\"ethAddr\",\"type\":\"address\"},{\"name\":\"strikes\",\"type\":\"int256[]\"}],\"name\":\"addOptionChain\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addFunds\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountID\",\"type\":\"uint256\"}],\"name\":\"getAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"int256[]\"},{\"name\":\"\",\"type\":\"int256[]\"},{\"name\":\"\",\"type\":\"int256[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getFundsAndAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numMarketMakers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"strike\",\"type\":\"int256\"},{\"name\":\"settlement\",\"type\":\"uint256\"},{\"name\":\"margin\",\"type\":\"uint256\"}],\"name\":\"getMoneyness\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"optionChainID\",\"type\":\"uint256\"},{\"name\":\"optionID\",\"type\":\"uint256\"},{\"name\":\"positionChange\",\"type\":\"int256\"},{\"name\":\"cashChange\",\"type\":\"int256\"}],\"name\":\"getMaxLossAfterTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"}]","ContractName":"Etheropt","CompilerVersion":"v0.3.0-2016-03-18-e759a24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}