{"status":"1","message":"OK","result":[{"SourceCode":"//last compiled with soljson-v0.3.5-2016-07-21-6610add\r\n\r\ncontract Etheropt {\r\n\r\n  struct Position {\r\n    mapping(uint => int) positions;\r\n    int cash;\r\n    bool expired;\r\n    bool hasPosition;\r\n  }\r\n  uint public expiration;\r\n  string public underlying;\r\n  uint public margin;\r\n  uint public realityID;\r\n  bytes32 public factHash;\r\n  address public ethAddr;\r\n  mapping(uint => int) options;\r\n  uint public numOptions;\r\n  bool public expired;\r\n  mapping(address => Position) positions;\r\n  uint public numPositions;\r\n  uint public numPositionsExpired;\r\n  struct Account {\r\n    address user;\r\n    int capital;\r\n  }\r\n  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\r\n  struct MarketMaker {\r\n    address user;\r\n    string server;\r\n  }\r\n  mapping(uint => MarketMaker) marketMakers; //starts at 1\r\n  uint public numMarketMakers = 0;\r\n  mapping(address => uint) marketMakerIDs;\r\n  mapping(uint => Account) accounts;\r\n  uint public numAccounts;\r\n  mapping(address => uint) accountIDs; //starts at 1\r\n\r\n  //events\r\n  event Deposit(address indexed user, uint amount, int balance); //balance is balance after deposit\r\n  event Withdraw(address indexed user, uint amount, int balance); //balance is balance after withdraw\r\n  event NewMarketMaker(address indexed user, string server);\r\n  event Expire(address indexed caller, address indexed user); //user is the account that was expired\r\n  event OrderMatchFailure(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);\r\n  event OrderMatch(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);\r\n\r\n  function Etheropt(uint expiration_, string underlying_, uint margin_, uint realityID_, bytes32 factHash_, address ethAddr_, int[] strikes_) {\r\n    expiration = expiration_;\r\n    underlying = underlying_;\r\n    margin = margin_;\r\n    realityID = realityID_;\r\n    factHash = factHash_;\r\n    ethAddr = ethAddr_;\r\n    for (uint i=0; i < strikes_.length; i++) {\r\n      if (numOptions<20) {\r\n        uint optionID = numOptions++;\r\n        options[optionID] = strikes_[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  function getAccountID(address user) constant returns(uint) {\r\n    return accountIDs[user];\r\n  }\r\n\r\n  function getAccount(uint accountID) constant returns(address) {\r\n    return accounts[accountID].user;\r\n  }\r\n\r\n  function addFunds() {\r\n    if (accountIDs[msg.sender]>0) {\r\n      accounts[accountIDs[msg.sender]].capital += int(msg.value);\r\n    } else {\r\n      uint accountID = ++numAccounts;\r\n      accounts[accountID].user = msg.sender;\r\n      accounts[accountID].capital += int(msg.value);\r\n      accountIDs[msg.sender] = accountID;\r\n    }\r\n    Deposit(msg.sender, msg.value, accounts[accountIDs[msg.sender]].capital);\r\n  }\r\n\r\n  function withdrawFunds(uint amount) {\r\n    if (accountIDs[msg.sender]>0) {\r\n      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\r\n        accounts[accountIDs[msg.sender]].capital -= int(amount);\r\n        msg.sender.call.value(amount)();\r\n        Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getFunds(address user, bool onlyAvailable) constant returns(int) {\r\n    if (accountIDs[user]>0) {\r\n      if (onlyAvailable == false) {\r\n        return accounts[accountIDs[user]].capital;\r\n      } else {\r\n        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0);\r\n      }\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function getFundsAndAvailable(address user) constant returns(int, int) {\r\n    return (getFunds(user, false), getFunds(user, true));\r\n  }\r\n\r\n  function marketMaker(string server) {\r\n    if (msg.value>0) throw;\r\n    if (marketMakerIDs[msg.sender]>0) {\r\n      marketMakers[marketMakerIDs[msg.sender]].server = server;\r\n    } else {\r\n      int funds = getFunds(marketMakers[i].user, false);\r\n      uint marketMakerID = 0;\r\n      if (numMarketMakers<6) {\r\n        marketMakerID = ++numMarketMakers;\r\n      } else {\r\n        for (uint i=2; i<=numMarketMakers; i++) {\r\n          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\r\n            marketMakerID = i;\r\n          }\r\n        }\r\n      }\r\n      if (marketMakerID>0) {\r\n        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\r\n        marketMakers[marketMakerID].user = msg.sender;\r\n        marketMakers[marketMakerID].server = server;\r\n        marketMakerIDs[msg.sender] = marketMakerID;\r\n        NewMarketMaker(msg.sender, server);\r\n      } else {\r\n        throw;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getMarketMakers() constant returns(string, string, string, string, string, string) {\r\n    string[] memory servers = new string[](6);\r\n    for (uint i=1; i<=numMarketMakers; i++) {\r\n      servers[i-1] = marketMakers[i].server;\r\n    }\r\n    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\r\n  }\r\n\r\n  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\r\n    int[] memory funds = new int[](6);\r\n    for (uint i=1; i<=numMarketMakers; i++) {\r\n      funds[i-1] = getFunds(marketMakers[i].user, false);\r\n    }\r\n    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\r\n  }\r\n\r\n  function getOptionChain() constant returns (uint, string, uint, uint, bytes32, address) {\r\n    return (expiration, underlying, margin, realityID, factHash, ethAddr);\r\n  }\r\n\r\n  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\r\n    uint[] memory optionIDs = new uint[](20);\r\n    int[] memory strikes_ = new int[](20);\r\n    int[] memory positions_ = new int[](20);\r\n    int[] memory cashes = new int[](20);\r\n    uint z = 0;\r\n    if (expired == false) {\r\n      for (uint optionID=0; optionID<numOptions; optionID++) {\r\n        optionIDs[z] = optionID;\r\n        strikes_[z] = options[optionID];\r\n        positions_[z] = positions[user].positions[optionID];\r\n        cashes[z] = positions[user].cash;\r\n        z++;\r\n      }\r\n    }\r\n    return (optionIDs, strikes_, positions_, cashes);\r\n  }\r\n\r\n  function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\r\n    if (expired == false) {\r\n      if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {\r\n        uint lastAccount = numAccounts;\r\n        if (accountID==0) {\r\n          accountID = 1;\r\n        } else {\r\n          lastAccount = accountID;\r\n        }\r\n        for (accountID=accountID; accountID<=lastAccount; accountID++) {\r\n          if (positions[accounts[accountID].user].expired == false) {\r\n            int result = positions[accounts[accountID].user].cash / 1000000000000000000;\r\n            for (uint optionID=0; optionID<numOptions; optionID++) {\r\n              int moneyness = getMoneyness(options[optionID], uint(value), margin);\r\n              result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\r\n            }\r\n            positions[accounts[accountID].user].expired = true;\r\n            uint amountToSend = uint(accounts[accountID].capital + result);\r\n            accounts[accountID].capital = 0;\r\n            if (positions[accounts[accountID].user].hasPosition==true) {\r\n              numPositionsExpired++;\r\n            }\r\n            accounts[accountID].user.call.value(amountToSend)();\r\n            Expire(msg.sender, accounts[accountID].user);\r\n          }\r\n        }\r\n        if (numPositionsExpired == numPositions) {\r\n          expired = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\r\n    if (strike>=0) { //call\r\n      if (settlement>uint(strike)) {\r\n        if (settlement-uint(strike)<margin) {\r\n          return int(settlement-uint(strike));\r\n        } else {\r\n          return int(margin);\r\n        }\r\n      } else {\r\n        return 0;\r\n      }\r\n    } else { //put\r\n      if (settlement<uint(-strike)) {\r\n        if (uint(-strike)-settlement<margin) {\r\n          return int(uint(-strike)-settlement);\r\n        } else {\r\n          return int(margin);\r\n        }\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  function orderMatchTest(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, uint value, int matchSize) constant returns(bool) {\r\n    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+int(value)+getMaxLossAfterTrade(sender, optionID, matchSize, -matchSize * int(price))>0) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function orderMatch(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\r\n    addFunds();\r\n    bytes32 hash = sha256(optionID, price, size, orderID, blockExpires);\r\n    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionID, matchSize, -matchSize * int(price))>0) {\r\n      if (positions[msg.sender].hasPosition == false) {\r\n        positions[msg.sender].hasPosition = true;\r\n        numPositions++;\r\n      }\r\n      if (positions[addr].hasPosition == false) {\r\n        positions[addr].hasPosition = true;\r\n        numPositions++;\r\n      }\r\n      positions[msg.sender].positions[optionID] += matchSize;\r\n      positions[msg.sender].cash -= matchSize * int(price);\r\n      positions[addr].positions[optionID] -= matchSize;\r\n      positions[addr].cash += matchSize * int(price);\r\n      orderFills[hash] -= matchSize;\r\n      OrderMatch(msg.sender, matchSize, addr, size, optionID, price);\r\n    } else {\r\n      OrderMatchFailure(msg.sender, matchSize, addr, size, optionID, price);\r\n    }\r\n  }\r\n\r\n  function getMaxLossAfterTrade(address user, uint optionID, int positionChange, int cashChange) constant returns(int) {\r\n    bool maxLossInitialized = false;\r\n    int maxLoss = 0;\r\n    if (positions[user].expired == false && numOptions>0) {\r\n      for (uint s=0; s<numOptions; s++) {\r\n        int pnl = positions[user].cash / 1000000000000000000;\r\n        pnl += cashChange / 1000000000000000000;\r\n        uint settlement = 0;\r\n        if (options[s]<0) {\r\n          settlement = uint(-options[s]);\r\n        } else {\r\n          settlement = uint(options[s]);\r\n        }\r\n        pnl += moneySumAtSettlement(user, optionID, positionChange, settlement);\r\n        if (pnl<maxLoss || maxLossInitialized==false) {\r\n          maxLossInitialized = true;\r\n          maxLoss = pnl;\r\n        }\r\n        pnl = positions[user].cash / 1000000000000000000;\r\n        pnl += cashChange / 1000000000000000000;\r\n        settlement = 0;\r\n        if (options[s]<0) {\r\n          if (uint(-options[s])>margin) {\r\n            settlement = uint(-options[s])-margin;\r\n          } else {\r\n            settlement = 0;\r\n          }\r\n        } else {\r\n          settlement = uint(options[s])+margin;\r\n        }\r\n        pnl += moneySumAtSettlement(user, optionID, positionChange, settlement);\r\n        if (pnl<maxLoss) {\r\n          maxLoss = pnl;\r\n        }\r\n      }\r\n    }\r\n    return maxLoss;\r\n  }\r\n\r\n  function moneySumAtSettlement(address user, uint optionID, int positionChange, uint settlement) internal returns(int) {\r\n    int pnl = 0;\r\n    for (uint j=0; j<numOptions; j++) {\r\n      pnl += positions[user].positions[j] * getMoneyness(options[j], settlement, margin) / 1000000000000000000;\r\n      if (j==optionID) {\r\n        pnl += positionChange * getMoneyness(options[j], settlement, margin) / 1000000000000000000;\r\n      }\r\n    }\r\n    return pnl;\r\n  }\r\n\r\n  function min(uint a, uint b) constant returns(uint) {\r\n    if (a<b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getMarketMakerFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"optionID\",\"type\":\"uint256\"},{\"name\":\"positionChange\",\"type\":\"int256\"},{\"name\":\"cashChange\",\"type\":\"int256\"}],\"name\":\"getMaxLossAfterTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketMakers\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOptions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"server\",\"type\":\"string\"}],\"name\":\"marketMaker\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"onlyAvailable\",\"type\":\"bool\"}],\"name\":\"getFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numPositions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOptionChain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAccountID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"margin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"realityID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numPositionsExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addFunds\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"optionID\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"size\",\"type\":\"int256\"},{\"name\":\"orderID\",\"type\":\"uint256\"},{\"name\":\"blockExpires\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"matchSize\",\"type\":\"int256\"}],\"name\":\"orderMatch\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"optionID\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"size\",\"type\":\"int256\"},{\"name\":\"orderID\",\"type\":\"uint256\"},{\"name\":\"blockExpires\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"matchSize\",\"type\":\"int256\"}],\"name\":\"orderMatchTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountID\",\"type\":\"uint256\"}],\"name\":\"getAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"accountID\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"expire\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"int256[]\"},{\"name\":\"\",\"type\":\"int256[]\"},{\"name\":\"\",\"type\":\"int256[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getFundsAndAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numMarketMakers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"strike\",\"type\":\"int256\"},{\"name\":\"settlement\",\"type\":\"uint256\"},{\"name\":\"margin\",\"type\":\"uint256\"}],\"name\":\"getMoneyness\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"expiration_\",\"type\":\"uint256\"},{\"name\":\"underlying_\",\"type\":\"string\"},{\"name\":\"margin_\",\"type\":\"uint256\"},{\"name\":\"realityID_\",\"type\":\"uint256\"},{\"name\":\"factHash_\",\"type\":\"bytes32\"},{\"name\":\"ethAddr_\",\"type\":\"address\"},{\"name\":\"strikes_\",\"type\":\"int256[]\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"int256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"int256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"server\",\"type\":\"string\"}],\"name\":\"NewMarketMaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Expire\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"matchUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"matchSize\",\"type\":\"int256\"},{\"indexed\":true,\"name\":\"orderUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderSize\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"optionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"OrderMatchFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"matchUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"matchSize\",\"type\":\"int256\"},{\"indexed\":true,\"name\":\"orderUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderSize\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"optionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"OrderMatch\",\"type\":\"event\"}]","ContractName":"Etheropt","CompilerVersion":"v0.3.5-2016-07-21-6610add","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000057c61e0000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000000000000002646678d232d8915adac718f2f49812085d117807a29069a37b50e983463cb4d20840000000000000000000000006fde387af081c37d9ffa762b49d340e6ae213395000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000074554482f55534400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000affffffffffffffffffffffffffffffffffffffffffffffff7538dcfb761800000000000000000000000000000000000000000000000000008ac7230489e80000ffffffffffffffffffffffffffffffffffffffffffffffff5287143a539e0000000000000000000000000000000000000000000000000000ad78ebc5ac620000ffffffffffffffffffffffffffffffffffffffffffffffff2fd54b7931240000000000000000000000000000000000000000000000000000d02ab486cedc0000fffffffffffffffffffffffffffffffffffffffffffffffeea71b9f6ec300000000000000000000000000000000000000000000000000001158e460913d00000fffffffffffffffffffffffffffffffffffffffffffffffea50e2874a73c00000000000000000000000000000000000000000000000000015af1d78b58c40000","Library":"","SwarmSource":""}]}