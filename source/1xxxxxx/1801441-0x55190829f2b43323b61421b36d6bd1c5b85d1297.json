{"status":"1","message":"OK","result":[{"SourceCode":"contract BTCRelay {\r\n    function getLastBlockHeight() returns (int);\r\n    function getBlockchainHead() returns (int);\r\n    function getFeeAmount(int blockHash) returns (int);\r\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\r\n}\r\n\r\ncontract Lottery {\r\n    int constant LOTTERY_BLOCKS = 7 * 24 * 6;\r\n    uint constant LOTTERY_INTERVAL = 7 days;\r\n    int constant CUTOFF_BLOCKS = 6 * 6;\r\n    uint constant CUTOFF_INTERVAL = 6 hours;\r\n    uint constant TICKET_PRICE = 10 finney;\r\n    uint constant FEE_FACTOR = 200; // 0.5 %\r\n\r\n    BTCRelay btcRelay = BTCRelay(0x41f274c0023f83391de4e0733c609df5a124c3d4);\r\n\r\n    struct Bucket {\r\n        uint numHolders;\r\n        address[] ticketHolders;\r\n    }\r\n\r\n    struct Payout {\r\n        address winner;\r\n        uint amount;\r\n        uint blockNumber;\r\n        uint timestamp;\r\n        address processor;\r\n    }\r\n\r\n    int public decidingBlock;\r\n    int public cutoffBlock;\r\n    uint public cutoffTimestamp;\r\n    int public nearestKnownBlock;\r\n    int public nearestKnownBlockHash;\r\n\r\n    uint public numTickets;\r\n    uint public numBuckets;\r\n    mapping (uint => Bucket) buckets;\r\n    uint public lastSaleTimestamp;\r\n\r\n    Payout[] public payouts;\r\n    uint public payoutIdx;\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner { if (msg.sender == owner) _ }\r\n\r\n    event Activity();\r\n\r\n    function Lottery() {\r\n        owner = msg.sender;\r\n        payouts.length = 3;\r\n        prepareLottery();\r\n    }\r\n\r\n    function prepareLottery() internal {\r\n        decidingBlock = btcRelay.getLastBlockHeight() + LOTTERY_BLOCKS;\r\n        cutoffBlock = decidingBlock - CUTOFF_BLOCKS;\r\n        cutoffTimestamp = now + LOTTERY_INTERVAL - CUTOFF_INTERVAL;\r\n        nearestKnownBlock = 0;\r\n        nearestKnownBlockHash = 0;\r\n\r\n        numTickets = 0;\r\n        for (uint i = 0; i < numBuckets; i++) {\r\n            buckets[i].numHolders = 0;\r\n        }\r\n        numBuckets = 0;\r\n        lastSaleTimestamp = 0;\r\n    }\r\n\r\n    function resetLottery() {\r\n        if (numTickets > 0) throw;\r\n        if (!payoutReady()) throw;\r\n\r\n        prepareLottery();\r\n        Activity();\r\n    }\r\n\r\n    function () {\r\n        buyTickets(msg.sender);\r\n    }\r\n\r\n    function buyTickets(address ticketHolder) {\r\n        if (msg.value < TICKET_PRICE) throw;\r\n        if (!ticketsAvailable()) throw;\r\n\r\n        uint n = msg.value / TICKET_PRICE;\r\n        numTickets += n;\r\n\r\n        // We maintain the list of ticket holders in a number of buckets.\r\n        // Entries in the first bucket represent one ticket each, in the\r\n        // second bucket they represent two tickets each, then four tickets\r\n        // each and so on. This allows us to process the sale of n tickets\r\n        // with a gas cost of O(log(n)).\r\n        uint bucket = 0;\r\n        while (n > 0) {\r\n            uint inThisBucket = n & (2 ** bucket);\r\n            if (inThisBucket > 0) {\r\n                uint pos = buckets[bucket].numHolders++;\r\n                if (buckets[bucket].ticketHolders.length <\r\n                    buckets[bucket].numHolders) {\r\n                    buckets[bucket].ticketHolders.length =\r\n                        buckets[bucket].numHolders;\r\n                }\r\n                buckets[bucket].ticketHolders[pos] = ticketHolder;\r\n                n -= inThisBucket;\r\n            }\r\n            bucket += 1;\r\n        }\r\n\r\n        if (bucket > numBuckets) numBuckets = bucket;\r\n\r\n        int missingBlocks = decidingBlock - btcRelay.getLastBlockHeight();\r\n        uint betterCutoffTimestamp =\r\n            now + uint(missingBlocks) * 10 minutes - CUTOFF_INTERVAL;\r\n        if (betterCutoffTimestamp < cutoffTimestamp) {\r\n            cutoffTimestamp = betterCutoffTimestamp;\r\n        }\r\n\r\n        lastSaleTimestamp = now;\r\n        Activity();\r\n    }\r\n\r\n    function ticketsAvailable() constant returns (bool) {\r\n        return now < cutoffTimestamp &&\r\n            btcRelay.getLastBlockHeight() < cutoffBlock;\r\n    }\r\n\r\n    function lookupTicketHolder(uint idx) constant returns (address) {\r\n        uint bucket = 0;\r\n        while (idx >= buckets[bucket].numHolders * (2 ** bucket)) {\r\n            idx -= buckets[bucket].numHolders * (2 ** bucket);\r\n            bucket += 1;\r\n        }\r\n\r\n        return buckets[bucket].ticketHolders[idx / (2 ** bucket)];\r\n    }\r\n\r\n    function getNumHolders(uint bucket) constant returns (uint) {\r\n        return buckets[bucket].numHolders;\r\n    }\r\n\r\n    function getTicketHolders(uint bucket) constant returns (address[]) {\r\n        return buckets[bucket].ticketHolders;\r\n    }\r\n\r\n    function getLastBlockHeight() constant returns (int) {\r\n        return btcRelay.getLastBlockHeight();\r\n    }\r\n\r\n    function getOperatingBudget() constant returns (uint) {\r\n        return this.balance - numTickets * TICKET_PRICE;\r\n    }\r\n\r\n    function payoutReady() constant returns (bool) {\r\n        return decidingBlock <= btcRelay.getLastBlockHeight();\r\n    }\r\n\r\n    function processPayout() returns (bool done) {\r\n        if (!payoutReady()) throw;\r\n        if (getOperatingBudget() < 1 ether) throw;\r\n        if (numTickets == 0) throw;\r\n\r\n        var (walkingDone, blockHash) = walkTowardsBlock();\r\n        if (!walkingDone) return false;\r\n\r\n        int winnerIdx = blockHash % int(numTickets);\r\n        address winner = lookupTicketHolder(uint(winnerIdx));\r\n        uint fee = (numTickets * TICKET_PRICE) / FEE_FACTOR;\r\n        uint amount = (numTickets * TICKET_PRICE) - fee;\r\n\r\n        // keep some records\r\n        payouts[payoutIdx].winner = winner;\r\n        payouts[payoutIdx].amount = amount;\r\n        payouts[payoutIdx].blockNumber = block.number;\r\n        payouts[payoutIdx].timestamp = now;\r\n        payouts[payoutIdx].processor = msg.sender;\r\n        payoutIdx = (payoutIdx + 1) % 3;\r\n\r\n        prepareLottery();   // prepare next round\r\n        var _ = winner.send(amount);\r\n        Activity();\r\n\r\n        return true;\r\n    }\r\n\r\n    function walkTowardsBlock() internal returns (bool, int) {\r\n        int blockHeight;\r\n        int blockHash;\r\n        if (nearestKnownBlock == 0) {\r\n            blockHeight = btcRelay.getLastBlockHeight();\r\n            blockHash = btcRelay.getBlockchainHead();\r\n        } else {\r\n            blockHeight = nearestKnownBlock;\r\n            blockHash = nearestKnownBlockHash;\r\n        }\r\n\r\n        // Walk at most 5 steps to keep an upper limit on gas costs.\r\n        for (uint steps = 0; steps < 5; steps++) {\r\n            if (blockHeight == decidingBlock) {\r\n                return (true, blockHash);\r\n            }\r\n\r\n            uint fee = uint(btcRelay.getFeeAmount(blockHash));\r\n            bytes32 blockHeader =\r\n                btcRelay.getBlockHeader.value(fee)(blockHash)[2];\r\n            bytes32 temp;\r\n\r\n            assembly {\r\n                let x := mload(0x40)\r\n                mstore(x, blockHeader)\r\n                temp := mload(add(x, 0x04))\r\n            }\r\n\r\n            blockHeight -= 1;\r\n            blockHash = 0;\r\n            for (int i = 0; i < 32; i++) {\r\n                blockHash = blockHash | int(temp[uint(i)]) * (256 ** i);\r\n            }\r\n        }\r\n\r\n        // Store the progress to pick up from there next time.\r\n        nearestKnownBlock = blockHeight;\r\n        nearestKnownBlockHash = blockHash;\r\n\r\n        return (false, 0);\r\n    }\r\n\r\n    function accessOperatingBudget(uint amount) onlyOwner {\r\n        if (getOperatingBudget() < 1 ether) throw;\r\n\r\n        uint safeToAccess = getOperatingBudget() - 1 ether;\r\n        if (amount > safeToAccess) throw;\r\n\r\n        var _ = owner.send(amount);\r\n    }\r\n\r\n    function setOwner(address _owner) onlyOwner {\r\n        owner = _owner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"bucket\",\"type\":\"uint256\"}],\"name\":\"getTicketHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastBlockHeight\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketsAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cutoffTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"processor\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cutoffBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nearestKnownBlockHash\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ticketHolder\",\"type\":\"address\"}],\"name\":\"buyTickets\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bucket\",\"type\":\"uint256\"}],\"name\":\"getNumHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperatingBudget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"accessOperatingBudget\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processPayout\",\"outputs\":[{\"name\":\"done\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nearestKnownBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decidingBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"lookupTicketHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBuckets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetLottery\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutReady\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSaleTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Activity\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.3.5-2016-06-27-2ccfea8","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}