{"status":"1","message":"OK","result":[{"SourceCode":"contract Ambi {\r\n    function getNodeAddress(bytes32) constant returns (address);\r\n    function addNode(bytes32, address) external returns (bool);\r\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi ambiC;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) constant returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            bool isNode = ambiContract.addNode(_name, address(this));\r\n            if (!isNode){\r\n                return false;\r\n            }   \r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function remove() checkAccess(\"owner\") {\r\n        suicide(msg.sender);\r\n    }\r\n}\r\n\r\ncontract ElcoinDb {\r\n    address owner;\r\n    address caller;\r\n\r\n    event Transaction(bytes32 indexed hash, address indexed from, address indexed to, uint time, uint amount);\r\n\r\n    modifier checkOwner() { _ }\r\n    modifier checkCaller() { _ }\r\n    mapping (address => uint) public balances;\r\n\r\n    function ElcoinDb(address pCaller) {\r\n        owner = msg.sender;\r\n        caller = pCaller;\r\n    }\r\n\r\n    function getOwner() constant returns (address rv) {\r\n        return owner;\r\n    }\r\n\r\n    function getCaller() constant returns (address rv) {\r\n        return caller;\r\n    }\r\n\r\n    function setCaller(address pCaller) checkOwner() returns (bool _success) {\r\n        caller = pCaller;\r\n\r\n        return true;\r\n    }\r\n\r\n    function setOwner(address pOwner) checkOwner() returns (bool _success) {\r\n        owner = pOwner;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getBalance(address addr) constant returns(uint balance) {\r\n        return balances[addr];\r\n    }\r\n\r\n    function deposit(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\r\n        balances[addr] += amount;\r\n        Transaction(hash, 0, addr, time, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\r\n        uint oldBalance = balances[addr];\r\n        if (oldBalance >= amount) {\r\n            balances[addr] = oldBalance - amount;\r\n            Transaction(hash, addr, 0, time, amount);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract ElcoinInterface {\r\n    function rewardTo(address _to, uint _amount) returns (bool);\r\n}\r\n\r\ncontract PotRewards is AmbiEnabled {\r\n\r\n    event Reward(address indexed beneficiary, uint indexed round, uint value, uint position);\r\n\r\n    struct Transaction {\r\n        address from;\r\n        uint amount;\r\n    }\r\n\r\n    uint public round = 0;\r\n    uint public counter = 0;            //counts each transaction\r\n    Transaction[] public transactions;  //records details of txns participating in next auction round\r\n\r\n    //parameters\r\n    uint public periodicity;        //how often does an auction happen (ie. each 10000 tx)\r\n    uint8 public auctionSize;       //how many transactions participate in auction\r\n    uint public prize;              //total amount of prize for each round\r\n    uint public minTx;              //transactions less than this amount will not be counted\r\n    uint public startTime;          //starting at startTime to calculate double rewards\r\n\r\n    ElcoinInterface public elcoin;  //contract to do rewardTo calls\r\n\r\n    function configure(uint _periodicity, uint8 _auctionSize, uint _prize, uint _minTx, uint _counter, uint _startTime) checkAccess(\"owner\") returns (bool) {\r\n        if (_auctionSize > _periodicity || _prize == 0 || _auctionSize > 255) {\r\n            return false;\r\n        }\r\n        periodicity = _periodicity;\r\n        auctionSize = _auctionSize;\r\n        prize = _prize;\r\n        minTx = _minTx;\r\n        counter = _counter;\r\n        startTime = _startTime;\r\n        elcoin = ElcoinInterface(getAddress(\"elcoin\"));\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _from, address _to, uint _amount) checkAccess(\"elcoin\") {\r\n        if (startTime > now || periodicity == 0 || auctionSize == 0 || prize == 0) {\r\n            return;\r\n        }\r\n        counter++;\r\n        if (_amount >= minTx && counter > periodicity - auctionSize) {\r\n            transactions.push(Transaction(_from, _amount));\r\n        }\r\n\r\n        if (counter >= periodicity) {\r\n            _prepareAndSendReward();\r\n            counter = 0;\r\n            round++;\r\n            delete transactions;\r\n        }\r\n    }\r\n\r\n    mapping(uint => mapping(address => uint)) public prizes;\r\n\r\n    function _prepareAndSendReward() internal {\r\n        uint amount = 0;\r\n        address[] memory winners = new address[](auctionSize);\r\n        uint winnerPosition = 0;\r\n        for (uint8 i = 0; i < transactions.length; i++) {\r\n            if (transactions[i].amount == amount) {\r\n                winners[winnerPosition++] = transactions[i].from;\r\n            }\r\n            if (transactions[i].amount > amount) {\r\n                amount = transactions[i].amount;\r\n                winnerPosition = 0;\r\n                winners[winnerPosition++] = transactions[i].from;\r\n            }\r\n        }\r\n        if (winnerPosition == 0) {\r\n            return;\r\n        }\r\n        address[] memory uniqueWinners = new address[](winnerPosition);\r\n        uint uniqueWinnerPosition = 0;\r\n        uint currentPrize = _is360thDay() ? prize*2 : prize;\r\n        uint reward = currentPrize / winnerPosition;\r\n        for (uint8 position = 0; position < winnerPosition; position++) {\r\n            address winner = winners[position];\r\n            if (prizes[round][winner] == 0) {\r\n                uniqueWinners[uniqueWinnerPosition++] = winner;\r\n            }\r\n            prizes[round][winner] += reward;\r\n        }\r\n        for (position = 0; position < uniqueWinnerPosition; position++) {\r\n            winner = uniqueWinners[position];\r\n            uint winnerReward = prizes[round][winner];\r\n            if (elcoin.rewardTo(winner, winnerReward)) {\r\n                Reward(winner, round, winnerReward, position);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _is360thDay() internal constant returns(bool) {\r\n        if (startTime > now) {\r\n            return false;\r\n        }\r\n\r\n        return (((now - startTime) / 1 days) + 1) % 360 == 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_periodicity\",\"type\":\"uint256\"},{\"name\":\"_auctionSize\",\"type\":\"uint8\"},{\"name\":\"_prize\",\"type\":\"uint256\"},{\"name\":\"_minTx\",\"type\":\"uint256\"},{\"name\":\"_counter\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"configure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"elcoin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ambi\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"setAmbiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"remove\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"prizes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodicity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"}]","ContractName":"PotRewards","CompilerVersion":"v0.3.2-2016-05-06-9e36bdd","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}