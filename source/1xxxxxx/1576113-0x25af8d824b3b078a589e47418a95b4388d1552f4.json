{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\r\nto automate organizational governance and decision-making.\r\n*/\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nBasic account, used by the DAO contract to separately manage both the rewards \r\nand the extraBalance accounts. \r\n*/\r\n\r\ncontract ManagedAccountInterface {\r\n    // The only address with permission to withdraw from this account\r\n    address public owner;\r\n    // If true, only the owner of the account can receive ether from it\r\n    bool public payOwnerOnly;\r\n    // The sum of ether (in wei) which has been sent to this contract\r\n    uint public accumulatedInput;\r\n\r\n    /// @notice Sends `_amount` of wei to _recipient\r\n    /// @param _amount The amount of wei to send to `_recipient`\r\n    /// @param _recipient The address to receive `_amount` of wei\r\n    /// @return True if the send completed\r\n    function payOut(address _recipient, uint _amount) returns (bool);\r\n\r\n    event PayOut(address indexed _recipient, uint _amount);\r\n}\r\n\r\n\r\ncontract ManagedAccount is ManagedAccountInterface{\r\n\r\n    // The constructor sets the owner of the account\r\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\r\n        owner = _owner;\r\n        payOwnerOnly = _payOwnerOnly;\r\n    }\r\n\r\n    // When the contract receives a transaction without data this is called. \r\n    // It counts the amount of ether it receives and stores it in \r\n    // accumulatedInput.\r\n    function() {\r\n        accumulatedInput += msg.value;\r\n    }\r\n\r\n    function payOut(address _recipient, uint _amount) returns (bool) {\r\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\r\n            throw;\r\n        if (_recipient.call.value(_amount)()) {\r\n            PayOut(_recipient, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\n * Token Creation contract, used by the DAO to create its tokens and initialize\r\n * its ether. Feel free to modify the divisor method to implement different\r\n * Token Creation parameters\r\n*/\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nBasic, standardized Token contract with no \"premine\". Defines the functions to\r\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\r\ncorresponding approval process. Tokens need to be created by a derived\r\ncontract (e.g. TokenCreation.sol).\r\n\r\nThank you ConsenSys, this contract originated from:\r\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\r\nWhich is itself based on the Ethereum standardized contract APIs:\r\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\r\n*/\r\n\r\n/// @title Standard Token Contract.\r\n\r\ncontract TokenInterface {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /// Total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    /// is approved by `_from`\r\n    /// @param _from The address of the origin of the transfer\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    /// its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _amount) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    /// to spend\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    ) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n    );\r\n}\r\n\r\n\r\ncontract Token is TokenInterface {\r\n    // Protects users by preventing the execution of method calls that\r\n    // inadvertently also transferred ether\r\n    modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n           return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) noEther returns (bool success) {\r\n\r\n        if (balances[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0) {\r\n\r\n            balances[_to] += _amount;\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract TokenCreationInterface {\r\n\r\n    // End of token creation, in Unix time\r\n    uint public closingTime;\r\n    // Minimum fueling goal of the token creation, denominated in tokens to\r\n    // be created\r\n    uint public minTokensToCreate;\r\n    // True if the DAO reached its minimum fueling goal, false otherwise\r\n    bool public isFueled;\r\n    // For DAO splits - if privateCreation is 0, then it is a public token\r\n    // creation, otherwise only the address stored in privateCreation is\r\n    // allowed to create tokens\r\n    address public privateCreation;\r\n    // hold extra ether which has been sent after the DAO token\r\n    // creation rate has increased\r\n    ManagedAccount public extraBalance;\r\n    // tracks the amount of wei given from each contributor (used for refund)\r\n    mapping (address => uint256) weiGiven;\r\n\r\n    /// @dev Constructor setting the minimum fueling goal and the\r\n    /// end of the Token Creation\r\n    /// @param _minTokensToCreate Minimum fueling goal in number of\r\n    ///        Tokens to be created\r\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\r\n    /// @param _privateCreation Zero means that the creation is public.  A\r\n    /// non-zero address represents the only address that can create Tokens\r\n    /// (the address can also create Tokens on behalf of other accounts)\r\n    // This is the constructor: it can not be overloaded so it is commented out\r\n    //  function TokenCreation(\r\n        //  uint _minTokensTocreate,\r\n        //  uint _closingTime,\r\n        //  address _privateCreation\r\n    //  );\r\n\r\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\r\n    /// @param _tokenHolder The address of the Tokens's recipient\r\n    /// @return Whether the token creation was successful\r\n    function createTokenProxy(address _tokenHolder) returns (bool success);\r\n\r\n    /// @notice Refund `msg.sender` in the case the Token Creation did\r\n    /// not reach its minimum fueling goal\r\n    function refund();\r\n\r\n    /// @return The divisor used to calculate the token creation rate during\r\n    /// the creation phase\r\n    function divisor() constant returns (uint divisor);\r\n\r\n    event FuelingToDate(uint value);\r\n    event CreatedToken(address indexed to, uint amount);\r\n    event Refund(address indexed to, uint value);\r\n}\r\n\r\n\r\ncontract TokenCreation is TokenCreationInterface, Token {\r\n    function TokenCreation(\r\n        uint _minTokensToCreate,\r\n        uint _closingTime,\r\n        address _privateCreation) {\r\n\r\n        closingTime = _closingTime;\r\n        minTokensToCreate = _minTokensToCreate;\r\n        privateCreation = _privateCreation;\r\n        extraBalance = new ManagedAccount(address(this), true);\r\n    }\r\n\r\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\r\n        if (now < closingTime && msg.value > 0\r\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\r\n\r\n            uint token = (msg.value * 20) / divisor();\r\n            extraBalance.call.value(msg.value - token)();\r\n            balances[_tokenHolder] += token;\r\n            totalSupply += token;\r\n            weiGiven[_tokenHolder] += msg.value;\r\n            CreatedToken(_tokenHolder, token);\r\n            if (totalSupply >= minTokensToCreate && !isFueled) {\r\n                isFueled = true;\r\n                FuelingToDate(totalSupply);\r\n            }\r\n            return true;\r\n        }\r\n        throw;\r\n    }\r\n\r\n    function refund() noEther {\r\n        if (now > closingTime && !isFueled) {\r\n            // Get extraBalance - will only succeed when called for the first time\r\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\r\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\r\n\r\n            // Execute refund\r\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\r\n                Refund(msg.sender, weiGiven[msg.sender]);\r\n                totalSupply -= balances[msg.sender];\r\n                balances[msg.sender] = 0;\r\n                weiGiven[msg.sender] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function divisor() constant returns (uint divisor) {\r\n            return 20;\r\n    }\r\n}\r\n\r\n\r\ncontract DAOInterface {\r\n\r\n    // The amount of days for which people who try to participate in the\r\n    // creation by calling the fallback function will still get their ether back\r\n    uint constant creationGracePeriod = 40 days;\r\n    // The minimum debate period that a generic proposal can have\r\n    uint constant minProposalDebatePeriod = 3 days;\r\n    // The minimum debate period that a split proposal can have\r\n    uint constant minSplitDebatePeriod = 0 days;\r\n    // Period of days inside which it's possible to execute a DAO split\r\n    uint constant splitExecutionPeriod = 1 days;\r\n    // Period of time after which the minimum Quorum is halved\r\n    uint constant quorumHalvingPeriod = 2 weeks;\r\n    // Period after which a proposal is closed\r\n    // (used in the case `executeProposal` fails because it throws)\r\n    uint constant executeProposalPeriod = 2 days;\r\n    // Denotes the maximum proposal deposit that can be given. It is given as\r\n    // a fraction of total Ether spent plus balance of the DAO\r\n    uint constant maxDepositDivisor = 100;\r\n\r\n    // Proposals to spend the DAO's ether or to choose a new Curator\r\n    Proposal[] public proposals;\r\n    // The quorum needed for each proposal is partially calculated by\r\n    // totalSupply / minQuorumDivisor\r\n    uint public minQuorumDivisor;\r\n    // The unix time of the last time quorum was reached on a proposal\r\n    uint public lastTimeMinQuorumMet;\r\n\r\n    // Address of the curator\r\n    address public curator;\r\n    // The whitelist: List of addresses the DAO is allowed to send ether to\r\n    mapping (address => bool) public allowedRecipients;\r\n\r\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\r\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\r\n    // represent the proportion of the rewards that the DAO has the right to\r\n    // receive. These Reward Tokens are generated when the DAO spends ether.\r\n    mapping (address => uint) public rewardToken;\r\n    // Total supply of rewardToken\r\n    uint public totalRewardToken;\r\n\r\n    // The account used to manage the rewards which are to be distributed to the\r\n    // DAO Token Holders of this DAO\r\n    ManagedAccount public rewardAccount;\r\n\r\n    // The account used to manage the rewards which are to be distributed to\r\n    // any DAO that holds Reward Tokens\r\n    ManagedAccount public DAOrewardAccount;\r\n\r\n    // Amount of rewards (in wei) already paid out to a certain DAO\r\n    mapping (address => uint) public DAOpaidOut;\r\n\r\n    // Amount of rewards (in wei) already paid out to a certain address\r\n    mapping (address => uint) public paidOut;\r\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\r\n    // tokens). The address points to the proposal ID.\r\n    mapping (address => uint) public blocked;\r\n\r\n    // The minimum deposit (in wei) required to submit any proposal that is not\r\n    // requesting a new Curator (no deposit is required for splits)\r\n    uint public proposalDeposit;\r\n\r\n    // the accumulated sum of all current proposal deposits\r\n    uint sumOfProposalDeposits;\r\n\r\n    // Contract that is able to create a new DAO (with the same code as\r\n    // this one), used for splits\r\n    DAO_Creator public daoCreator;\r\n\r\n    // A proposal with `newCurator == false` represents a transaction\r\n    // to be issued by this DAO\r\n    // A proposal with `newCurator == true` represents a DAO split\r\n    struct Proposal {\r\n        // The address where the `amount` will go to if the proposal is accepted\r\n        // or if `newCurator` is true, the proposed Curator of\r\n        // the new DAO).\r\n        address recipient;\r\n        // The amount to transfer to `recipient` if the proposal is accepted.\r\n        uint amount;\r\n        // A plain text description of the proposal\r\n        string description;\r\n        // A unix timestamp, denoting the end of the voting period\r\n        uint votingDeadline;\r\n        // True if the proposal's votes have yet to be counted, otherwise False\r\n        bool open;\r\n        // True if quorum has been reached, the votes have been counted, and\r\n        // the majority said yes\r\n        bool proposalPassed;\r\n        // A hash to check validity of a proposal\r\n        bytes32 proposalHash;\r\n        // Deposit in wei the creator added when submitting their proposal. It\r\n        // is taken from the msg.value of a newProposal call.\r\n        uint proposalDeposit;\r\n        // True if this proposal is to assign a new Curator\r\n        bool newCurator;\r\n        // Data needed for splitting the DAO\r\n        SplitData[] splitData;\r\n        // Number of Tokens in favor of the proposal\r\n        uint yea;\r\n        // Number of Tokens opposed to the proposal\r\n        uint nay;\r\n        // Simple mapping to check if a shareholder has voted for it\r\n        mapping (address => bool) votedYes;\r\n        // Simple mapping to check if a shareholder has voted against it\r\n        mapping (address => bool) votedNo;\r\n        // Address of the shareholder who created the proposal\r\n        address creator;\r\n    }\r\n\r\n    // Used only in the case of a newCurator proposal.\r\n    struct SplitData {\r\n        // The balance of the current DAO minus the deposit at the time of split\r\n        uint splitBalance;\r\n        // The total amount of DAO Tokens in existence at the time of split.\r\n        uint totalSupply;\r\n        // Amount of Reward Tokens owned by the DAO at the time of split.\r\n        uint rewardToken;\r\n        // The new DAO contract created at the time of split.\r\n        MICRODAO newDAO;\r\n    }\r\n\r\n    // Used to restrict access to certain functions to only DAO Token Holders\r\n    modifier onlyTokenholders {}\r\n\r\n    /// @dev Constructor setting the Curator and the address\r\n    /// for the contract able to create another DAO as well as the parameters\r\n    /// for the DAO Token Creation\r\n    /// @param _curator The Curator\r\n    /// @param _daoCreator The contract able to (re)create this DAO\r\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\r\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\r\n    ///        to be created for a successful DAO Token Creation\r\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\r\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\r\n    /// non-zero address means that the DAO Token Creation is only for the address\r\n    // This is the constructor: it can not be overloaded so it is commented out\r\n    //  function DAO(\r\n        //  address _curator,\r\n        //  DAO_Creator _daoCreator,\r\n        //  uint _proposalDeposit,\r\n        //  uint _minTokensToCreate,\r\n        //  uint _closingTime,\r\n        //  addresses _privateCreation\r\n    //  );\r\n\r\n    /// @notice Create Token with `msg.sender` as the beneficiary\r\n    /// @return Whether the token creation was successful\r\n    function () returns (bool success);\r\n\r\n\r\n    /// @dev This function is used to send ether back\r\n    /// to the DAO, it can also be used to receive payments that should not be\r\n    /// counted as rewards (donations, grants, etc.)\r\n    /// @return Whether the DAO received the ether successfully\r\n    function receiveEther() returns(bool);\r\n\r\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\r\n    /// `_recipient` with the transaction data `_transactionData`. If\r\n    /// `_newCurator` is true, then this is a proposal that splits the\r\n    /// DAO and sets `_recipient` as the new DAO's Curator.\r\n    /// @param _recipient Address of the recipient of the proposed transaction\r\n    /// @param _amount Amount of wei to be sent with the proposed transaction\r\n    /// @param _description String describing the proposal\r\n    /// @param _transactionData Data of the proposed transaction\r\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\r\n    /// weeks for a regular proposal, 10 days for new Curator proposal\r\n    /// @param _newCurator Bool defining whether this proposal is about\r\n    /// a new Curator or not\r\n    /// @return The proposal ID. Needed for voting on the proposal\r\n    function newProposal(\r\n        address _recipient,\r\n        uint _amount,\r\n        string _description,\r\n        bytes _transactionData,\r\n        uint _debatingPeriod,\r\n        bool _newCurator\r\n    ) onlyTokenholders returns (uint _proposalID);\r\n\r\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\r\n    /// transaction which sends `_amount` with data `_transactionData`\r\n    /// to `_recipient`\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _recipient The recipient of the proposed transaction\r\n    /// @param _amount The amount of wei to be sent in the proposed transaction\r\n    /// @param _transactionData The data of the proposed transaction\r\n    /// @return Whether the proposal ID matches the transaction data or not\r\n    function checkProposalCode(\r\n        uint _proposalID,\r\n        address _recipient,\r\n        uint _amount,\r\n        bytes _transactionData\r\n    ) constant returns (bool _codeChecksOut);\r\n\r\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _supportsProposal Yes/No - support of the proposal\r\n    /// @return The vote ID.\r\n    function vote(\r\n        uint _proposalID,\r\n        bool _supportsProposal\r\n    ) onlyTokenholders returns (uint _voteID);\r\n\r\n    /// @notice Checks whether proposal `_proposalID` with transaction data\r\n    /// `_transactionData` has been voted for or rejected, and executes the\r\n    /// transaction in the case it has been voted for.\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _transactionData The data of the proposed transaction\r\n    /// @return Whether the proposed transaction has been executed or not\r\n    function executeProposal(\r\n        uint _proposalID,\r\n        bytes _transactionData\r\n    ) returns (bool _success);\r\n\r\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\r\n    /// with `_newCurator` as the new Curator, as has been\r\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\r\n    /// not be undone and will split the DAO into two DAO's, with two\r\n    /// different underlying tokens.\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _newCurator The new Curator of the new DAO\r\n    /// @dev This function, when called for the first time for this proposal,\r\n    /// will create a new DAO and send the sender's portion of the remaining\r\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\r\n    /// of the sender.\r\n    function splitDAO(\r\n        uint _proposalID,\r\n        address _newCurator\r\n    ) returns (bool _success);\r\n\r\n    /// @dev can only be called by the DAO itself through a proposal\r\n    /// updates the contract of the DAO by sending all ether and rewardTokens\r\n    /// to the new DAO. The new DAO needs to be approved by the Curator\r\n    /// @param _newContract the address of the new contract\r\n    function newContract(address _newContract);\r\n\r\n\r\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\r\n    /// that the DAO can send transactions to them (using proposals)\r\n    /// @param _recipient New recipient address\r\n    /// @dev Can only be called by the current Curator\r\n    /// @return Whether successful or not\r\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\r\n\r\n\r\n    /// @notice Change the minimum deposit required to submit a proposal\r\n    /// @param _proposalDeposit The new proposal deposit\r\n    /// @dev Can only be called by this DAO (through proposals with the\r\n    /// recipient being this DAO itself)\r\n    function changeProposalDeposit(uint _proposalDeposit) external;\r\n\r\n    /// @notice Move rewards from the DAORewards managed account\r\n    /// @param _toMembers If true rewards are moved to the actual reward account\r\n    ///                   for the DAO. If not then it's moved to the DAO itself\r\n    /// @return Whether the call was successful\r\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\r\n\r\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\r\n    /// @return Whether the call was successful\r\n    function getMyReward() returns(bool _success);\r\n\r\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\r\n    /// to `_account`'s balance\r\n    /// @return Whether the call was successful\r\n    function withdrawRewardFor(address _account) internal returns (bool _success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\r\n    /// getMyReward() is called.\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transfered\r\n    /// @return Whether the transfer was successful or not\r\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    /// is approved by `_from`. Prior to this getMyReward() is called.\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transfered\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFromWithoutReward(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) returns (bool success);\r\n\r\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\r\n    /// achieved in 52 weeks\r\n    /// @return Whether the change was successful or not\r\n    function halveMinQuorum() returns (bool _success);\r\n\r\n    /// @return total number of proposals ever created\r\n    function numberOfProposals() constant returns (uint _numberOfProposals);\r\n\r\n    /// @param _proposalID Id of the new curator proposal\r\n    /// @return Address of the new DAO\r\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\r\n\r\n    /// @param _account The address of the account which is checked.\r\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\r\n    function isBlocked(address _account) internal returns (bool);\r\n\r\n    /// @notice If the caller is blocked by a proposal whose voting deadline\r\n    /// has exprired then unblock him.\r\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\r\n    function unblockMe() returns (bool);\r\n\r\n    event ProposalAdded(\r\n        uint indexed proposalID,\r\n        address recipient,\r\n        uint amount,\r\n        bool newCurator,\r\n        string description\r\n    );\r\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\r\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\r\n    event NewCurator(address indexed _newCurator);\r\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\r\n}\r\n\r\n// The DAO contract itself\r\ncontract MICRODAO is DAOInterface, Token, TokenCreation {\r\n\r\n    // Modifier that allows only shareholders to vote and create new proposals\r\n    modifier onlyTokenholders {\r\n        if (balanceOf(msg.sender) == 0) throw;\r\n            _\r\n    }\r\n\r\n    function MICRODAO(\r\n        address _curator,\r\n        DAO_Creator _daoCreator,\r\n        uint _proposalDeposit,\r\n        uint _minTokensToCreate,\r\n        uint _closingTime,\r\n        address _privateCreation\r\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\r\n\r\n        curator = _curator;\r\n        daoCreator = _daoCreator;\r\n        proposalDeposit = _proposalDeposit;\r\n        rewardAccount = new ManagedAccount(address(this), false);\r\n        DAOrewardAccount = new ManagedAccount(address(this), false);\r\n        if (address(rewardAccount) == 0)\r\n            throw;\r\n        if (address(DAOrewardAccount) == 0)\r\n            throw;\r\n        lastTimeMinQuorumMet = now;\r\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\r\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\r\n\r\n        allowedRecipients[address(this)] = true;\r\n        allowedRecipients[curator] = true;\r\n    }\r\n\r\n    function () returns (bool success) {\r\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\r\n            return createTokenProxy(msg.sender);\r\n        else\r\n            return receiveEther();\r\n    }\r\n\r\n\r\n    function receiveEther() returns (bool) {\r\n        return true;\r\n    }\r\n\r\n\r\n    function newProposal(\r\n        address _recipient,\r\n        uint _amount,\r\n        string _description,\r\n        bytes _transactionData,\r\n        uint _debatingPeriod,\r\n        bool _newCurator\r\n    ) onlyTokenholders returns (uint _proposalID) {\r\n\r\n        // Sanity check\r\n        if (_newCurator && (\r\n            _amount != 0\r\n            || _transactionData.length != 0\r\n            || _recipient == curator\r\n            || msg.value > 0)) {\r\n            throw;\r\n        } else if (\r\n            !_newCurator\r\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\r\n        ) {\r\n            throw;\r\n        }\r\n\r\n        if (_debatingPeriod > 8 weeks)\r\n            throw;\r\n\r\n        if (!isFueled\r\n            || now < closingTime\r\n            || (msg.value < proposalDeposit && !_newCurator)) {\r\n\r\n            throw;\r\n        }\r\n\r\n        if (now + _debatingPeriod < now) // prevents overflow\r\n            throw;\r\n\r\n        // to prevent a 51% attacker to convert the ether into deposit\r\n        if (msg.sender == address(this))\r\n            throw;\r\n\r\n        // to prevent curator from halving quorum before first proposal\r\n        if (proposals.length == 1) // initial length is 1 (see constructor)\r\n            lastTimeMinQuorumMet = now;\r\n\r\n        _proposalID = proposals.length++;\r\n        Proposal p = proposals[_proposalID];\r\n        p.recipient = _recipient;\r\n        p.amount = _amount;\r\n        p.description = _description;\r\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\r\n        p.votingDeadline = now + _debatingPeriod;\r\n        p.open = true;\r\n        //p.proposalPassed = False; // that's default\r\n        p.newCurator = _newCurator;\r\n        if (_newCurator)\r\n            p.splitData.length++;\r\n        p.creator = msg.sender;\r\n        p.proposalDeposit = msg.value;\r\n\r\n        sumOfProposalDeposits += msg.value;\r\n\r\n        ProposalAdded(\r\n            _proposalID,\r\n            _recipient,\r\n            _amount,\r\n            _newCurator,\r\n            _description\r\n        );\r\n    }\r\n\r\n\r\n    function checkProposalCode(\r\n        uint _proposalID,\r\n        address _recipient,\r\n        uint _amount,\r\n        bytes _transactionData\r\n    ) noEther constant returns (bool _codeChecksOut) {\r\n        Proposal p = proposals[_proposalID];\r\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\r\n    }\r\n\r\n\r\n    function vote(\r\n        uint _proposalID,\r\n        bool _supportsProposal\r\n    ) onlyTokenholders noEther returns (uint _voteID) {\r\n\r\n        Proposal p = proposals[_proposalID];\r\n        if (p.votedYes[msg.sender]\r\n            || p.votedNo[msg.sender]\r\n            || now >= p.votingDeadline) {\r\n\r\n            throw;\r\n        }\r\n\r\n        if (_supportsProposal) {\r\n            p.yea += balances[msg.sender];\r\n            p.votedYes[msg.sender] = true;\r\n        } else {\r\n            p.nay += balances[msg.sender];\r\n            p.votedNo[msg.sender] = true;\r\n        }\r\n\r\n        if (blocked[msg.sender] == 0) {\r\n            blocked[msg.sender] = _proposalID;\r\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\r\n            // this proposal's voting deadline is further into the future than\r\n            // the proposal that blocks the sender so make it the blocker\r\n            blocked[msg.sender] = _proposalID;\r\n        }\r\n\r\n        Voted(_proposalID, _supportsProposal, msg.sender);\r\n    }\r\n\r\n\r\n    function executeProposal(\r\n        uint _proposalID,\r\n        bytes _transactionData\r\n    ) noEther returns (bool _success) {\r\n\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        uint waitPeriod = p.newCurator\r\n            ? splitExecutionPeriod\r\n            : executeProposalPeriod;\r\n        // If we are over deadline and waiting period, assert proposal is closed\r\n        if (p.open && now > p.votingDeadline + waitPeriod) {\r\n            closeProposal(_proposalID);\r\n            return;\r\n        }\r\n\r\n        // Check if the proposal can be executed\r\n        if (now < p.votingDeadline  // has the voting deadline arrived?\r\n            // Have the votes been counted?\r\n            || !p.open\r\n            // Does the transaction code match the proposal?\r\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\r\n\r\n            throw;\r\n        }\r\n\r\n        // If the curator removed the recipient from the whitelist, close the proposal\r\n        // in order to free the deposit and allow unblocking of voters\r\n        if (!isRecipientAllowed(p.recipient)) {\r\n            closeProposal(_proposalID);\r\n            p.creator.send(p.proposalDeposit);\r\n            return;\r\n        }\r\n\r\n        bool proposalCheck = true;\r\n\r\n        if (p.amount > actualBalance())\r\n            proposalCheck = false;\r\n\r\n        uint quorum = p.yea + p.nay;\r\n\r\n        // require 53% for calling newContract()\r\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\r\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\r\n            && _transactionData[3] == 0x1e\r\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\r\n\r\n                proposalCheck = false;\r\n        }\r\n\r\n        if (quorum >= minQuorum(p.amount)) {\r\n            if (!p.creator.send(p.proposalDeposit))\r\n                throw;\r\n\r\n            lastTimeMinQuorumMet = now;\r\n            // set the minQuorum to 20% again, in the case it has been reached\r\n            if (quorum > totalSupply / 5)\r\n                minQuorumDivisor = 5;\r\n        }\r\n\r\n        // Execute result\r\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\r\n            if (!p.recipient.call.value(p.amount)(_transactionData))\r\n                throw;\r\n\r\n            p.proposalPassed = true;\r\n            _success = true;\r\n\r\n            // only create reward tokens when ether is not sent to the DAO itself and\r\n            // related addresses. Proxy addresses should be forbidden by the curator.\r\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\r\n                && p.recipient != address(DAOrewardAccount)\r\n                && p.recipient != address(extraBalance)\r\n                && p.recipient != address(curator)) {\r\n\r\n                rewardToken[address(this)] += p.amount;\r\n                totalRewardToken += p.amount;\r\n            }\r\n        }\r\n\r\n        closeProposal(_proposalID);\r\n\r\n        // Initiate event\r\n        ProposalTallied(_proposalID, _success, quorum);\r\n    }\r\n\r\n\r\n    function closeProposal(uint _proposalID) internal {\r\n        Proposal p = proposals[_proposalID];\r\n        if (p.open)\r\n            sumOfProposalDeposits -= p.proposalDeposit;\r\n        p.open = false;\r\n    }\r\n\r\n    function splitDAO(\r\n        uint _proposalID,\r\n        address _newCurator\r\n    ) noEther onlyTokenholders returns (bool _success) {\r\n\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        // Sanity check\r\n\r\n        if (now < p.votingDeadline  // has the voting deadline arrived?\r\n            //The request for a split expires XX days after the voting deadline\r\n            || now > p.votingDeadline + splitExecutionPeriod\r\n            // Does the new Curator address match?\r\n            || p.recipient != _newCurator\r\n            // Is it a new curator proposal?\r\n            || !p.newCurator\r\n            // Have you voted for this split?\r\n            || !p.votedYes[msg.sender]\r\n            // Did you already vote on another proposal?\r\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\r\n\r\n            throw;\r\n        }\r\n\r\n        // If the new DAO doesn't exist yet, create the new DAO and store the\r\n        // current split data\r\n        if (address(p.splitData[0].newDAO) == 0) {\r\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\r\n            // Call depth limit reached, etc.\r\n            if (address(p.splitData[0].newDAO) == 0)\r\n                throw;\r\n            // should never happen\r\n            if (this.balance < sumOfProposalDeposits)\r\n                throw;\r\n            p.splitData[0].splitBalance = actualBalance();\r\n            p.splitData[0].rewardToken = rewardToken[address(this)];\r\n            p.splitData[0].totalSupply = totalSupply;\r\n            p.proposalPassed = true;\r\n        }\r\n\r\n        // Move ether and assign new Tokens\r\n        uint fundsToBeMoved =\r\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\r\n            p.splitData[0].totalSupply;\r\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\r\n            throw;\r\n\r\n\r\n        // Assign reward rights to new DAO\r\n        uint rewardTokenToBeMoved =\r\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\r\n            p.splitData[0].totalSupply;\r\n\r\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\r\n            rewardToken[address(this)];\r\n\r\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\r\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\r\n            throw;\r\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\r\n\r\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\r\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\r\n            throw;\r\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\r\n\r\n        // Burn DAO Tokens\r\n        Transfer(msg.sender, 0, balances[msg.sender]);\r\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\r\n        totalSupply -= balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        paidOut[msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    function newContract(address _newContract){\r\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\r\n        // move all ether\r\n        if (!_newContract.call.value(address(this).balance)()) {\r\n            throw;\r\n        }\r\n\r\n        //move all reward tokens\r\n        rewardToken[_newContract] += rewardToken[address(this)];\r\n        rewardToken[address(this)] = 0;\r\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\r\n        DAOpaidOut[address(this)] = 0;\r\n    }\r\n\r\n\r\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\r\n        MICRODAO dao = MICRODAO(msg.sender);\r\n\r\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\r\n            totalRewardToken < DAOpaidOut[msg.sender])\r\n            throw;\r\n\r\n        uint reward =\r\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\r\n            totalRewardToken - DAOpaidOut[msg.sender];\r\n\r\n        reward = DAOrewardAccount.balance < reward ? DAOrewardAccount.balance : reward;\r\n\r\n        if(_toMembers) {\r\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\r\n                throw;\r\n            }\r\n        else {\r\n            if (!DAOrewardAccount.payOut(dao, reward))\r\n                throw;\r\n        }\r\n        DAOpaidOut[msg.sender] += reward;\r\n        return true;\r\n    }\r\n\r\n    function getMyReward() noEther returns (bool _success) {\r\n        return withdrawRewardFor(msg.sender);\r\n    }\r\n\r\n\r\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\r\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\r\n            throw;\r\n\r\n        uint reward =\r\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\r\n\r\n        reward = rewardAccount.balance < reward ? rewardAccount.balance : reward;\r\n\r\n        if (!rewardAccount.payOut(_account, reward))\r\n            throw;\r\n        paidOut[_account] += reward;\r\n        return true;\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (isFueled\r\n            && now > closingTime\r\n            && !isBlocked(msg.sender)\r\n            && transferPaidOut(msg.sender, _to, _value)\r\n            && super.transfer(_to, _value)) {\r\n\r\n            return true;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n\r\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\r\n        if (!getMyReward())\r\n            throw;\r\n        return transfer(_to, _value);\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (isFueled\r\n            && now > closingTime\r\n            && !isBlocked(_from)\r\n            && transferPaidOut(_from, _to, _value)\r\n            && super.transferFrom(_from, _to, _value)) {\r\n\r\n            return true;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n\r\n    function transferFromWithoutReward(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) returns (bool success) {\r\n\r\n        if (!withdrawRewardFor(_from))\r\n            throw;\r\n        return transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    function transferPaidOut(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal returns (bool success) {\r\n\r\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\r\n        if (transferPaidOut > paidOut[_from])\r\n            throw;\r\n        paidOut[_from] -= transferPaidOut;\r\n        paidOut[_to] += transferPaidOut;\r\n        return true;\r\n    }\r\n\r\n\r\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\r\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\r\n            / maxDepositDivisor) {\r\n\r\n            throw;\r\n        }\r\n        proposalDeposit = _proposalDeposit;\r\n    }\r\n\r\n\r\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\r\n        if (msg.sender != curator)\r\n            throw;\r\n        allowedRecipients[_recipient] = _allowed;\r\n        AllowedRecipientChanged(_recipient, _allowed);\r\n        return true;\r\n    }\r\n\r\n\r\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\r\n        if (allowedRecipients[_recipient]\r\n            || (_recipient == address(extraBalance)\r\n                // only allowed when at least the amount held in the\r\n                // extraBalance account has been spent from the DAO\r\n                && totalRewardToken > extraBalance.accumulatedInput()))\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    function actualBalance() constant returns (uint _actualBalance) {\r\n        return this.balance - sumOfProposalDeposits;\r\n    }\r\n\r\n\r\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\r\n        // minimum of 20% and maximum of 53.33%\r\n        return totalSupply / minQuorumDivisor +\r\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\r\n    }\r\n\r\n\r\n    function halveMinQuorum() returns (bool _success) {\r\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime after\r\n        // fueling by the curator with a delay of at least `minProposalDebatePeriod`\r\n        // between the calls\r\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\r\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)\r\n            && now >= closingTime\r\n            && proposals.length > 1) {\r\n            lastTimeMinQuorumMet = now;\r\n            minQuorumDivisor *= 2;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function createNewDAO(address _newCurator) internal returns (MICRODAO _newDAO) {\r\n        NewCurator(_newCurator);\r\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\r\n    }\r\n\r\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\r\n        // Don't count index 0. It's used by isBlocked() and exists from start\r\n        return proposals.length - 1;\r\n    }\r\n\r\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\r\n        return proposals[_proposalID].splitData[0].newDAO;\r\n    }\r\n\r\n    function isBlocked(address _account) internal returns (bool) {\r\n        if (blocked[_account] == 0)\r\n            return false;\r\n        Proposal p = proposals[blocked[_account]];\r\n        if (now > p.votingDeadline) {\r\n            blocked[_account] = 0;\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function unblockMe() returns (bool) {\r\n        return isBlocked(msg.sender);\r\n    }\r\n}\r\n\r\ncontract DAO_Creator {\r\n    function createDAO(\r\n        address _curator,\r\n        uint _proposalDeposit,\r\n        uint _minTokensToCreate,\r\n        uint _closingTime\r\n    ) returns (MICRODAO _newDAO) {\r\n\r\n        return new MICRODAO(\r\n            _curator,\r\n            DAO_Creator(this),\r\n            _proposalDeposit,\r\n            _minTokensToCreate,\r\n            _closingTime,\r\n            msg.sender\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"newCurator\",\"type\":\"bool\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokensToCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daoCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisor\",\"outputs\":[{\"name\":\"divisor\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unblockMe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actualBalance\",\"outputs\":[{\"name\":\"_actualBalance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedRecipients\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferWithoutReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"},{\"name\":\"_debatingPeriod\",\"type\":\"uint256\"},{\"name\":\"_newCurator\",\"type\":\"bool\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"DAOpaidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minQuorumDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"newContract\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"changeAllowedRecipients\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halveMinQuorum\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_newCurator\",\"type\":\"address\"}],\"name\":\"splitDAO\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAOrewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfProposals\",\"outputs\":[{\"name\":\"_numberOfProposals\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeMinQuorumMet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toMembers\",\"type\":\"bool\"}],\"name\":\"retrieveDAOReward\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFueled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"createTokenProxy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"getNewDAOAddress\",\"outputs\":[{\"name\":\"_newDAO\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"_voteID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyReward\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromWithoutReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"}],\"name\":\"changeProposalDeposit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"_codeChecksOut\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateCreation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_curator\",\"type\":\"address\"},{\"name\":\"_daoCreator\",\"type\":\"address\"},{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"_minTokensToCreate\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_privateCreation\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FuelingToDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreatedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newCurator\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newCurator\",\"type\":\"address\"}],\"name\":\"NewCurator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"AllowedRecipientChanged\",\"type\":\"event\"}]","ContractName":"MICRODAO","CompilerVersion":"v0.3.1-2016-04-12-3ad5e82","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000050f54ed2cafd4b7245e60557a6b56d9ac91930250000000000000000000000007d733668aefd4a1b8624410daa883b35369b663c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000574835300000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":""}]}