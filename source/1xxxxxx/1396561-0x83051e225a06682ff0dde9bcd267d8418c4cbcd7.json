{"status":"1","message":"OK","result":[{"SourceCode":"contract ParallelGambling {\r\n    \r\n    //--------parameters\r\n    uint[3] private deposit;\r\n    uint private feesThousandth = 10;       //1% of fees !\r\n    uint private time_max = 6 * 60 * 60;   //6 hours in seconds, time to wait before you can cancel the round\r\n    uint private fees = 0; \r\n    \r\n    //percentage of attribution of differents prizes\r\n    uint private first_prize = 170;     //Big winner gets 160 %\r\n    uint private second_prize = 130;    //Little winner gets 140 %\r\n    uint private third_prize = 0;       //looser gets nothing !\r\n    \r\n    //--Contract ledger for the 3 \"play zones\"\r\n    \r\n    uint[3] private Balance;\r\n    uint[3] private id;\r\n    uint[3] private cursor;\r\n    uint[3] private nb_player ;\r\n    uint[3] private last_time ;\r\n    \r\n    // -- random uniformers -\r\n\tuint256 private toss1;\r\n\tuint256 private toss2;\r\n\t\r\n\t\r\n    address private admin;\r\n    \r\n    //Constructor - executed on creation only\r\n    function ParallelGambling() {\r\n        admin = msg.sender;\r\n        uint i;\r\n        //*****initiate everything properly****\r\n        for(i=0;i<3;i++){\r\n            Balance[i]=0;\r\n            last_time[i] = block.timestamp;\r\n            nb_player[i]=0;\r\n            id[i]=0;\r\n\t\t\tcursor[i]=0;\r\n        }\r\n        deposit[0]= 100 finney; // ZONE 1\r\n        deposit[1]= 1 ether;    // ZONE 2\r\n        deposit[2]= 5 ether;    // ZONE 3\r\n    }\r\n\r\n    modifier onlyowner {if (msg.sender == admin) _  }\r\n\r\n    \r\n    struct Player { //for each entry\r\n        address addr;\r\n        uint payout; //this section is filled when payout are done !\r\n        bool paid;\r\n    }\r\n    \r\n    Player[][3] private players;\r\n\t\r\n\t\r\n\tstruct GamblerStats { //for each address, to keep a record\r\n\t\tuint bets;\r\n\t\tuint deposits;\r\n\t\tuint paid;\r\n\t}\r\n\tmapping(address => GamblerStats) private gamblers;\r\n\r\n    \r\n    function() {\r\n        init();\r\n    }\r\n\r\n    \r\n    function init() private {\r\n        //------ Verifications to select play zone-----\r\n        uint256 actual_deposit = msg.value;\r\n        uint zone_selected;\r\n        \r\n        if (actual_deposit < deposit[0]) { //not enough for any zones !\r\n            msg.sender.send(actual_deposit);\r\n            return;\r\n        }\r\n        if(actual_deposit >= deposit[0] && actual_deposit < deposit[1]){   // GAME ZONE 1\r\n\t\t\tif( actual_deposit-deposit[0] >0){\r\n\t\t\t\tmsg.sender.send(actual_deposit-deposit[0]);\r\n\t\t\t}\r\n            actual_deposit=deposit[0];\r\n            zone_selected=0;\r\n        }\r\n        if(actual_deposit >= deposit[1] && actual_deposit < deposit[2]){   // GAME ZONE 2\r\n\t\t\tif( actual_deposit-deposit[1] >0){\r\n\t\t\t\tmsg.sender.send(actual_deposit-deposit[1]);\r\n\t\t\t}\r\n            actual_deposit=deposit[1];\r\n            zone_selected=1;\r\n        }\r\n        if(actual_deposit >= deposit[2]){                             // GAME ZONE 3\r\n\t\t\tif( actual_deposit-deposit[2] >0){\r\n\t\t\t\tmsg.sender.send(actual_deposit-deposit[2]);\r\n\t\t\t}\r\n            actual_deposit=deposit[2];\r\n            zone_selected=2;\r\n        }\r\n        \r\n        //----update balances and ledger according to the playing zone selected---\r\n        \r\n        fees += (actual_deposit * feesThousandth) / 1000;      // collect 1% fee\r\n        Balance[zone_selected] += (actual_deposit * (1000 - feesThousandth )) / 1000; //update balance\r\n        \r\n        last_time[zone_selected] = block.timestamp;\r\n        \r\n        players[zone_selected].length++;\r\n        players[zone_selected][cursor[zone_selected]]=(Player(msg.sender,  0 , false));\r\n\t\tcursor[zone_selected]++;\r\n        nb_player[zone_selected]++;\r\n\t\t\r\n\t\t//update stats\r\n\t\tgamblers[msg.sender].bets++;\r\n\t\tgamblers[msg.sender].deposits += actual_deposit;\r\n\t\t\r\n\t\t//random\r\n\t\tif(nb_player[zone_selected]%2 ==0)\ttoss1 = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\r\n\t\telse toss2 = uint256(sha3(tx.gasprice+block.difficulty)); \r\n        \r\n        //-check if end of the round\r\n        if(nb_player[zone_selected] == 3){ //end of a round\r\n            EndRound(zone_selected);\r\n        }\r\n    }\r\n    \r\n    function EndRound(uint zone) private{\r\n        \r\n        //randomness is created here from previous toss\r\n        uint256 toss = toss1+toss2+msg.value; //send a value higher than the required deposit to create more randomness if you are the third player (ending round).\r\n\t\t//indices of players\r\n        uint i_big_winner;\r\n        uint i_small_winner;\r\n        uint i_looser;\r\n        \r\n        if( toss % 3 == 0 ){\r\n            i_big_winner=id[zone];\r\n            i_small_winner=id[zone]+1;\r\n            i_looser =id[zone]+2;\r\n        }\r\n        else if( toss % 3 == 1){\r\n            i_big_winner=id[zone]+2;\r\n            i_small_winner=id[zone];\r\n            i_looser =id[zone]+1;\r\n        }\r\n        else{\r\n            i_big_winner=id[zone]+1;\r\n            i_small_winner=id[zone]+2;\r\n            i_looser =id[zone];\r\n        }\r\n        \r\n        uint256 effective_bet = (deposit[zone] * (1000 - feesThousandth )) / 1000;\r\n        \r\n        players[zone][i_big_winner].addr.send(effective_bet*first_prize/100);     //big win\r\n        players[zone][i_small_winner].addr.send(effective_bet*second_prize/100);    //small win\r\n        if(third_prize > 0){\r\n            players[zone][i_small_winner].addr.send(effective_bet*third_prize/100);    //looser\r\n        }\r\n        \r\n        //update zone information\r\n        players[zone][i_big_winner].payout=effective_bet*first_prize/100;\r\n        players[zone][i_small_winner].payout=effective_bet*second_prize/100;\r\n        players[zone][i_looser].payout=effective_bet*third_prize/100;\r\n        players[zone][id[zone]].paid=true;\r\n        players[zone][id[zone]+1].paid=true;\r\n        players[zone][id[zone]+2].paid=true;\r\n\t\t//update gamblers ledger\r\n\t\tgamblers[players[zone][i_big_winner].addr].paid += players[zone][i_big_winner].payout;\r\n\t\tgamblers[players[zone][i_small_winner].addr].paid += players[zone][i_small_winner].payout;\r\n\t\tgamblers[players[zone][i_looser].addr].paid += players[zone][i_looser].payout;\r\n\t\t\r\n        Balance[zone]=0;\r\n        nb_player[zone]=0;\r\n        id[zone] += 3;\r\n    }\r\n\r\n    \r\n    function CancelRoundAndRefundAll(uint zone) { //refund every participants in a zone, anyone can call this !\r\n        if(zone<0 && zone>3) throw;\r\n        if(nb_player[zone]==0) return;\r\n        \r\n        uint256 pay=(deposit[zone] * (1000 - feesThousandth )) / 1000;\r\n        \r\n        if (last_time[zone] + time_max < block.timestamp) {\r\n            for(uint i=id[zone]; i<(id[zone]+nb_player[zone]); i++){\r\n                players[zone][i].addr.send(pay);\r\n                players[zone][i].paid=true;\r\n                players[zone][i].payout=pay;\r\n\t\t\t\t\r\n\t\t\t\tgamblers[players[zone][i].addr].bets--;\r\n\t\t\t\tgamblers[players[zone][i].addr].deposits -= pay;\r\n            }\r\n            id[zone] += nb_player[zone];\r\n            nb_player[zone]=0;\r\n\t\t\tBalance[zone]=0;\r\n\t\t\t//remove informations from stats - cancelling = removing\r\n\t\t\t\r\n        }\r\n    }\r\n    \r\n    //------------ Contract informations -----------------------------------\r\n    \r\n    \r\n    function LookAtBalance() constant returns(uint BalanceOfZone1,uint BalanceOfZone2,uint BalanceOfZone3, string info) {\r\n        BalanceOfZone1 = Balance[0] /  1 finney;\r\n        BalanceOfZone2 = Balance[1] /  1 finney;\r\n        BalanceOfZone3 = Balance[2] /  1 finney;\r\n        info ='Balances of all play zones in finney';\r\n    }\r\n    \r\n    function PlayerInfoPerZone(uint id, uint zone) constant returns(address Address, uint Payout, bool UserPaid, string info) {\r\n        if(zone<0 && zone>3) throw;\r\n        if (id <= players[zone].length) {\r\n            Address = players[zone][id].addr;\r\n            Payout = (players[zone][id].payout) / 1 finney;\r\n            UserPaid= players[zone][id].paid;\r\n        }\r\n\t\t\r\n\t\tinfo = 'Select zone between 0 and 2, then use the id to look trough this zone';\r\n    }\r\n    \r\n    function LookAtLastTimePerZone(uint zone) constant returns(uint LastTimeForSelectedZone,uint TimeToWaitEnablingRefund, string info) {\r\n        if(zone<0 && zone>3) throw;\r\n        LastTimeForSelectedZone = last_time[zone];\r\n        TimeToWaitEnablingRefund = time_max;\r\n        info ='Timestamps, use this to know when you can cancel a round to get back funds, TimeToWait in seconds !';\r\n    }\r\n\r\n    function LookAtCollectedFees() constant returns(uint Fees, string info) {\r\n        Fees = fees / 1 finney;\r\n\t\tinfo = 'Fees collected, in finney.';\r\n    }\r\n    \r\n    \r\n    function LookAtDepositsToPlay() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\r\n        InZone1 = deposit[0] / 1 finney;\r\n        InZone2 = deposit[1] / 1 finney;\r\n        InZone3 = deposit[2] / 1 finney;\r\n\t\tinfo = 'Deposit for each zones, in finney. Surpus are always refunded.';\r\n    }\r\n\r\n    function LookAtPrizes() constant returns(uint FirstPrize,uint SecondPrize,uint LooserPrize, string info) {\r\n\t\tFirstPrize=first_prize;\r\n\t\tSecondPrize=second_prize;\r\n\t\tLooserPrize=third_prize;\r\n\t\r\n\t\tinfo = 'Prizes in percent of the deposit';\r\n    }\r\n\t\r\n\tfunction GamblerPerAddress(address addr) constant returns(uint Bets, uint Deposited, uint PaidOut, string info) {\r\n\t\tBets      = gamblers[addr].bets;\r\n\t\tDeposited = gamblers[addr].deposits / 1 finney;\r\n\t\tPaidOut   = gamblers[addr].paid / 1 finney;\r\n\t\tinfo ='Bets is the number of time you participated, no matter the zone.';\r\n\t}\r\n\t\r\n    function LookAtNumberOfPlayers() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\r\n        InZone1 = nb_player[0];\r\n        InZone2 = nb_player[1];\r\n        InZone3 = nb_player[2];\r\n\t\t\r\n\t\tinfo = 'Players in a round, in each zones.';\r\n    }\r\n    //----------- Contract management functions -------------------------\r\n    \r\n    function ChangeOwnership(address _owner) onlyowner {\r\n        admin = _owner;\r\n    }\r\n\t\r\n\t\r\n    function ModifyFeeFraction(uint new_fee) onlyowner {\r\n\t\tif( new_fee>=0 && new_fee<=20 ){ //admin can only set the fee percentage between 0 and 2%, initially 1%\r\n\t\t\tfeesThousandth = new_fee;\r\n\t\t}\r\n    }\r\n    \r\n    //function to modify settings, only if no player in a round !\r\n    function ModifySettings(uint new_time_max, uint new_first_prize, uint new_second_prize, uint new_third_prize,\r\n                            uint deposit_1,uint deposit_2,uint deposit_3) onlyowner {\r\n        if(nb_player[0]!=0 || nb_player[1]!=0 || nb_player[2]!=0 ) throw; //can only modify if nobody plays !\r\n        \r\n        if(new_time_max>=(1 * 60 * 60) && new_time_max<=(24 * 60 * 60) ) time_max=new_time_max;\r\n\t\t\r\n\t\tif((new_first_prize+new_second_prize+new_third_prize)==300){ //the total must be distributed in a correct way\r\n\t\t\tif(new_first_prize>=130 && new_first_prize<=190){\t\t\t\r\n\t\t\t\tfirst_prize=new_first_prize;\r\n\t\t\t\tif(new_second_prize>100 && new_second_prize<=130){\r\n\t\t\t\t\tsecond_prize=new_second_prize;\r\n\t\t\t\t\tif(new_third_prize>=0 && new_third_prize<=50) third_prize=new_third_prize;\r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n        if(deposit_1>=(1 finney) && deposit_1<(1 ether)) deposit[0]=deposit_1;\r\n        if(deposit_2>=(1 ether) && deposit_2<(5 ether)) deposit[1]=deposit_2;\r\n        if(deposit_3>=(5 ether) && deposit_3<=(20 ether)) deposit[2]=deposit_3;\r\n        \r\n    }\r\n    \r\n    function CollectAllFees() onlyowner { //it just send fees, that's all folks !\r\n        if (fees == 0) throw;\r\n        admin.send(fees);\r\n        fees = this.balance -Balance[0]-Balance[1]-Balance[2]; //just in case there is lost ethers.\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ChangeOwnership\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LookAtCollectedFees\",\"outputs\":[{\"name\":\"Fees\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"}],\"name\":\"ModifyFeeFraction\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"zone\",\"type\":\"uint256\"}],\"name\":\"PlayerInfoPerZone\",\"outputs\":[{\"name\":\"Address\",\"type\":\"address\"},{\"name\":\"Payout\",\"type\":\"uint256\"},{\"name\":\"UserPaid\",\"type\":\"bool\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CollectAllFees\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LookAtDepositsToPlay\",\"outputs\":[{\"name\":\"InZone1\",\"type\":\"uint256\"},{\"name\":\"InZone2\",\"type\":\"uint256\"},{\"name\":\"InZone3\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"zone\",\"type\":\"uint256\"}],\"name\":\"CancelRoundAndRefundAll\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_time_max\",\"type\":\"uint256\"},{\"name\":\"new_first_prize\",\"type\":\"uint256\"},{\"name\":\"new_second_prize\",\"type\":\"uint256\"},{\"name\":\"new_third_prize\",\"type\":\"uint256\"},{\"name\":\"deposit_1\",\"type\":\"uint256\"},{\"name\":\"deposit_2\",\"type\":\"uint256\"},{\"name\":\"deposit_3\",\"type\":\"uint256\"}],\"name\":\"ModifySettings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"zone\",\"type\":\"uint256\"}],\"name\":\"LookAtLastTimePerZone\",\"outputs\":[{\"name\":\"LastTimeForSelectedZone\",\"type\":\"uint256\"},{\"name\":\"TimeToWaitEnablingRefund\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LookAtNumberOfPlayers\",\"outputs\":[{\"name\":\"InZone1\",\"type\":\"uint256\"},{\"name\":\"InZone2\",\"type\":\"uint256\"},{\"name\":\"InZone3\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LookAtPrizes\",\"outputs\":[{\"name\":\"FirstPrize\",\"type\":\"uint256\"},{\"name\":\"SecondPrize\",\"type\":\"uint256\"},{\"name\":\"LooserPrize\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LookAtBalance\",\"outputs\":[{\"name\":\"BalanceOfZone1\",\"type\":\"uint256\"},{\"name\":\"BalanceOfZone2\",\"type\":\"uint256\"},{\"name\":\"BalanceOfZone3\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GamblerPerAddress\",\"outputs\":[{\"name\":\"Bets\",\"type\":\"uint256\"},{\"name\":\"Deposited\",\"type\":\"uint256\"},{\"name\":\"PaidOut\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"ParallelGambling","CompilerVersion":"v0.3.1-2016-04-12-3ad5e82","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}