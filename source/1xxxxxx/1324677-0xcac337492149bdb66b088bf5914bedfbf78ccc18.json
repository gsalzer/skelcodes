{"status":"1","message":"OK","result":[{"SourceCode":"contract theRun {\r\n        uint private Balance = 0;\r\n        uint private Payout_id = 0;\r\n        uint private Last_Payout = 0;\r\n        uint private WinningPot = 0;\r\n        uint private Min_multiplier = 1100; //110%\r\n        \r\n\r\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\r\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\r\n        uint private fees = 0;\r\n        uint private feeFrac = 20; //Fraction for fees in per\"thousand\", not percent, so 20 is 2%\r\n        \r\n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\r\n        \r\n        \r\n        address private admin;\r\n        \r\n        function theRun() {\r\n            admin = msg.sender;\r\n        }\r\n\r\n        modifier onlyowner {if (msg.sender == admin) _  }\r\n\r\n        struct Player {\r\n            address addr;\r\n            uint payout;\r\n            bool paid;\r\n        }\r\n\r\n        Player[] private players;\r\n\r\n        //--Fallback function\r\n        function() {\r\n            init();\r\n        }\r\n\r\n        //--initiated function\r\n        function init() private {\r\n            uint deposit=msg.value;\r\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\r\n                    msg.sender.send(msg.value);\r\n                    return;\r\n            }\r\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\r\n                    msg.sender.send(msg.value- (20 ether));\r\n                    deposit=20 ether;\r\n            }\r\n            Participate(deposit);\r\n        }\r\n\r\n        //------- Core of the game----------\r\n        function Participate(uint deposit) private {\r\n                //calculate the multiplier to apply to the future payout\r\n                \r\n\r\n                uint total_multiplier=Min_multiplier; //initiate total_multiplier\r\n                if(Balance < 1 ether && players.length>1){\r\n                    total_multiplier+=100; // + 10 %\r\n                }\r\n                if( (players.length % 10)==0 && players.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\r\n                    total_multiplier+=100; // + 10 %\r\n                }\r\n                \r\n                //add new player in the queue !\r\n                players.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));\r\n                \r\n                //--- UPDATING CONTRACT STATS ----\r\n                WinningPot += (deposit * PotFrac) / 1000; // take some 3% to add for the winning pot !\r\n                fees += (deposit * feeFrac) / 1000; // collect maintenance fees 2%\r\n                Balance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000; // update balance\r\n\r\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\r\n                if(  ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){ \r\n                    uint roll = random(100); //take a random number between 1 & 100\r\n                    if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! \r\n                        msg.sender.send(WinningPot); // Bravo !\r\n                        WinningPot=0;\r\n                    }\r\n                    \r\n                }\r\n                \r\n                //Classic payout for the participants\r\n                while ( Balance > players[Payout_id].payout ) {\r\n                    Last_Payout = players[Payout_id].payout;\r\n                    players[Payout_id].addr.send(Last_Payout); //pay the man, please !\r\n                    Balance -= players[Payout_id].payout; //update the balance\r\n                    players[Payout_id].paid=true;\r\n                    \r\n                    Payout_id += 1;\r\n                }\r\n        }\r\n\r\n\r\n\r\n    uint256 constant private salt =  block.timestamp;\r\n    \r\n    function random(uint Max) constant private returns (uint256 result){\r\n        //get the best seed for randomness\r\n        uint256 x = salt * 100 / Max;\r\n        uint256 y = salt * block.number / (salt % 5) ;\r\n        uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; \r\n        uint256 h = uint256(block.blockhash(seed)); \r\n    \r\n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\r\n    }\r\n    \r\n    \r\n\r\n    //---Contract management functions\r\n    function ChangeOwnership(address _owner) onlyowner {\r\n        admin = _owner;\r\n    }\r\n    function WatchBalance() constant returns(uint TotalBalance) {\r\n        TotalBalance = Balance /  1 wei;\r\n    }\r\n    \r\n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\r\n        TotalBalanceInEther = Balance /  1 ether;\r\n    }\r\n    \r\n    \r\n    //Fee functions for creator\r\n    function CollectAllFees() onlyowner {\r\n        if (fees == 0) throw;\r\n        admin.send(fees);\r\n        feeFrac-=1;\r\n        fees = 0;\r\n    }\r\n    \r\n    function GetAndReduceFeesByFraction(uint p) onlyowner {\r\n        if (fees == 0) feeFrac-=1; //Reduce fees.\r\n        admin.send(fees / 1000 * p);//send a percent of fees\r\n        fees -= fees / 1000 * p;\r\n    }\r\n        \r\n\r\n//---Contract informations\r\nfunction NextPayout() constant returns(uint NextPayout) {\r\n    NextPayout = players[Payout_id].payout /  1 wei;\r\n}\r\n\r\nfunction WatchFees() constant returns(uint CollectedFees) {\r\n    CollectedFees = fees / 1 wei;\r\n}\r\n\r\n\r\nfunction WatchWinningPot() constant returns(uint WinningPot) {\r\n    WinningPot = WinningPot / 1 wei;\r\n}\r\n\r\nfunction WatchLastPayout() constant returns(uint payout) {\r\n    payout = Last_Payout;\r\n}\r\n\r\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\r\n    NumberOfPlayers = players.length;\r\n}\r\n\r\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\r\n    if (id <= players.length) {\r\n        Address = players[id].addr;\r\n        Payout = players[id].payout / 1 wei;\r\n        UserPaid=players[id].paid;\r\n    }\r\n}\r\n\r\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\r\n    QueueSize = players.length - Payout_id;\r\n}\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"WatchFees\",\"outputs\":[{\"name\":\"CollectedFees\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ChangeOwnership\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PlayerInfo\",\"outputs\":[{\"name\":\"Address\",\"type\":\"address\"},{\"name\":\"Payout\",\"type\":\"uint256\"},{\"name\":\"UserPaid\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WatchWinningPot\",\"outputs\":[{\"name\":\"WinningPot\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CollectAllFees\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PayoutQueueSize\",\"outputs\":[{\"name\":\"QueueSize\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextPayout\",\"outputs\":[{\"name\":\"NextPayout\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"GetAndReduceFeesByFraction\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WatchLastPayout\",\"outputs\":[{\"name\":\"payout\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WatchBalance\",\"outputs\":[{\"name\":\"TotalBalance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Total_of_Players\",\"outputs\":[{\"name\":\"NumberOfPlayers\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WatchBalanceInEther\",\"outputs\":[{\"name\":\"TotalBalanceInEther\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"theRun","CompilerVersion":"v0.3.1-2016-04-07-054bc2a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}