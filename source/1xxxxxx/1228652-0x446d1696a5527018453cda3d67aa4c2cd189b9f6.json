{"status":"1","message":"OK","result":[{"SourceCode":"contract GreedPit {\r\n    \r\n    address private owner;\r\n    \r\n    //Stored variables\r\n    uint private balance = 0;\r\n    uint private uniqueUsers = 0;\r\n    uint private usersProfits = 0;\r\n    uint private rescues = 0;\r\n    uint private collectedFees = 0;\r\n    uint private jumpFee = 10;\r\n    uint private baseMultiplier = 110;\r\n    uint private maxMultiplier = 200;\r\n    uint private payoutOrder = 0;\r\n    uint private rescueRecord = 0;\r\n    uint timeOfLastDeposit = now;\r\n    address private hero = 0x0;\r\n    \r\n    mapping (address => User) private users;\r\n    Entry[] private entries;\r\n    \r\n    event Jump(address who, uint deposit, uint payout);\r\n    event Rescue(address who, address saviour, uint payout);\r\n    event NewHero(address who);\r\n    \r\n    //Set owner on contract creation\r\n    function GreedPit() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyowner { if (msg.sender == owner) _ }\r\n    \r\n    struct User {\r\n        uint id;\r\n        address addr;\r\n        string nickname;\r\n        uint rescueCount;\r\n        uint rescueTokens;\r\n    }\r\n    \r\n    struct Entry {\r\n        address entryAddress;\r\n        uint deposit;\r\n        uint payout;\r\n        uint tokens;\r\n    }\r\n\r\n    //Fallback function\r\n    function() {\r\n        init();\r\n    }\r\n    \r\n    function init() private{\r\n        //Only deposits >0.1ETH are allowed to join\r\n        if (msg.value < 100 finney) {\r\n            return;\r\n        }\r\n        \r\n        jumpIn();\r\n        \r\n        //Prevent cheap trolls from reviving the pit if it dies (death = ~3months without deposits)\r\n        if (msg.value > 5)\r\n            timeOfLastDeposit = now;\r\n    }\r\n    \r\n    //Join the pit\r\n    function jumpIn() private {\r\n        \r\n        //Limit deposits to 50ETH\r\n\t\tuint dValue = 100 finney;\r\n\t\tif (msg.value > 50 ether) {\r\n\t\t    //Make sure we receied the money before refunding the surplus\r\n\t\t    if (this.balance >= balance + collectedFees + msg.value)\r\n\t\t\t    msg.sender.send(msg.value - 50 ether);\t\r\n\t\t\tdValue = 50 ether;\r\n\t\t}\r\n\t\telse { dValue = msg.value; }\r\n\r\n        //Add new users to the users array if he's a new player\r\n        addNewUser(msg.sender);\r\n        \r\n        //Make sure that only up to 5 rescue tokens are spent at a time\r\n        uint tokensToUse = users[msg.sender].rescueTokens >= 5 ? 5 : users[msg.sender].rescueTokens;\r\n        uint tokensUsed = 0;\r\n        \r\n        //Enforce lower payouts if too many people stuck in the pit\r\n        uint randMultiplier = rand(50);\r\n        uint currentEntries = entries.length - payoutOrder;\r\n        randMultiplier = currentEntries > 15 ? (randMultiplier / 2) : randMultiplier;\r\n        randMultiplier = currentEntries > 25 ? 0 : randMultiplier;\r\n        //Incentive to join if the pit is nearly empty (+50% random multiplier)\r\n        randMultiplier = currentEntries <= 5 && dValue <= 20 ? randMultiplier * 3 / 2 : randMultiplier;\r\n        \r\n        //Calculate the optimal amount of rescue tokens to spend\r\n        while (tokensToUse > 0 && (baseMultiplier + randMultiplier + tokensUsed*10) < maxMultiplier)\r\n        {\r\n            tokensToUse--;\r\n            tokensUsed++;\r\n        }\r\n        \r\n        uint finalMultiplier = (baseMultiplier + randMultiplier + tokensUsed*10);\r\n        \r\n        if (finalMultiplier > maxMultiplier)\r\n            finalMultiplier = maxMultiplier;\r\n            \r\n        //Add new entry to the entries array    \r\n        if (msg.value < 50 ether)\r\n            entries.push(Entry(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100), tokensUsed));\r\n        else\r\n            entries.push(Entry(msg.sender, 50 ether,((50 ether) * (finalMultiplier) / 100), tokensUsed));\r\n\r\n        //Trigger jump event\r\n        if (msg.value < 50 ether)\r\n            Jump(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100));\r\n        else\r\n            Jump(msg.sender, 50 ether, ((50 ether) * (finalMultiplier) / 100));\r\n\r\n        users[msg.sender].rescueTokens -= tokensUsed;\r\n        \r\n        //Collect fees and update contract balance\r\n        balance += (dValue * (100 - jumpFee)) / 100;\r\n        collectedFees += (dValue * jumpFee) / 100;\r\n        \r\n        bool saviour = false;\r\n        \r\n        //Pay pending entries if the new balance allows for it\r\n        while (balance > entries[payoutOrder].payout) {\r\n            \r\n            saviour = false;\r\n            \r\n            uint entryPayout = entries[payoutOrder].payout;\r\n            uint entryDeposit = entries[payoutOrder].deposit;\r\n            uint profit = entryPayout - entryDeposit;\r\n            uint saviourShare = 0;\r\n            \r\n            //Give credit & reward for the rescue if the user saved someone else\r\n            if (users[msg.sender].addr != entries[payoutOrder].entryAddress)\r\n            {\r\n                users[msg.sender].rescueCount++;\r\n                //Double or triple token bonus if the user is taking a moderate/high risk to help those trapped\r\n                if (entryDeposit >= 1 ether) {\r\n                    users[msg.sender].rescueTokens += dValue < 20 || currentEntries < 15 ? 1 : 2;\r\n                    users[msg.sender].rescueTokens += dValue < 40 || currentEntries < 25 ? 0 : 1;\r\n                }\r\n                saviour = true;\r\n            }\r\n            \r\n            bool isHero = false;\r\n            \r\n            isHero = entries[payoutOrder].entryAddress == hero;\r\n            \r\n            //Share profit with saviour if the gain is substantial enough and the saviour invested enough (hero exempt)\r\n            if (saviour && !isHero && profit > 20 * entryDeposit / 100 && profit > 100 finney && dValue >= 5 ether)\r\n            {\r\n                if (dValue < 10 ether)\r\n                   saviourShare = 3 + rand(5);\r\n                else if (dValue >= 10 ether && dValue < 25 ether)\r\n                  saviourShare = 7 + rand(8);\r\n                else if (dValue >= 25 ether && dValue < 40 ether)\r\n                   saviourShare = 12 + rand(13);\r\n                else if (dValue >= 40 ether)\r\n                   saviourShare = rand(50);\r\n                   \r\n                saviourShare *= profit / 100;\r\n                   \r\n                msg.sender.send(saviourShare);\r\n            }\r\n            \r\n            uint payout = entryPayout - saviourShare;\r\n            entries[payoutOrder].entryAddress.send(payout);\r\n            \r\n            //Trigger rescue event\r\n            Rescue(entries[payoutOrder].entryAddress, msg.sender, payout);\r\n\r\n            balance -= entryPayout;\r\n            usersProfits += entryPayout;\r\n            \r\n            rescues++;\r\n            payoutOrder++;\r\n        }\r\n        \r\n        //Check for new Hero of the Pit\r\n        if (saviour && users[msg.sender].rescueCount > rescueRecord)\r\n        {\r\n            rescueRecord = users[msg.sender].rescueCount;\r\n            hero = msg.sender;\r\n            //Trigger new hero event\r\n            NewHero(msg.sender);\r\n        }\r\n    }\r\n    \r\n    //Generate random number between 1 & max\r\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\r\n    function rand(uint max) constant private returns (uint256 result){\r\n        uint256 factor = FACTOR * 100 / max;\r\n        uint256 lastBlockNumber = block.number - 1;\r\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\r\n    \r\n        return uint256((uint256(hashVal) / factor)) % max + 1;\r\n    }\r\n    \r\n    function addNewUser(address Address) private\r\n    {\r\n        if (users[Address].addr == address(0))\r\n        {\r\n            users[Address].id = ++uniqueUsers;\r\n            users[Address].addr = Address;\r\n            users[Address].nickname = 'UnnamedPlayer';\r\n            users[Address].rescueCount = 0;\r\n            users[Address].rescueTokens = 0;\r\n        }\r\n    }\r\n    \r\n    //Transfer earnings from fees to the owner\r\n    function collectFees() onlyowner {\r\n        if (collectedFees == 0) throw;\r\n\r\n        owner.send(collectedFees);\r\n        collectedFees = 0;\r\n    }\r\n\r\n    //Contract management\r\n    function changeOwner(address newOwner) onlyowner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function changeBaseMultiplier(uint multi) onlyowner {\r\n        if (multi < 110 || multi > 150) throw;\r\n        \r\n        baseMultiplier = multi;\r\n    }\r\n    \r\n    function changeMaxMultiplier(uint multi) onlyowner {\r\n        if (multi < 200 || multi > 300) throw;\r\n        \r\n        maxMultiplier = multi;\r\n    }\r\n    \r\n    function changeFee(uint fee) onlyowner {\r\n        if (fee < 0 || fee > 10) throw;\r\n        \r\n        jumpFee = fee;\r\n    }\r\n    \r\n    \r\n    //JSON functions\r\n    function setNickname(string name) {\r\n        addNewUser(msg.sender);\r\n        \r\n        if (bytes(name).length >= 2 && bytes(name).length <= 16)\r\n            users[msg.sender].nickname = name;\r\n    }\r\n    \r\n    function currentBalance() constant returns (uint pitBalance, string info) {\r\n        pitBalance = balance / 1 finney;\r\n        info = 'The balance of the pit in Finneys (contract balance minus fees).';\r\n    }\r\n    \r\n    function heroOfThePit() constant returns (address theHero, string nickname, uint peopleSaved, string info) {\r\n        theHero = hero;  \r\n        nickname = users[theHero].nickname;\r\n        peopleSaved = rescueRecord;\r\n        info = 'The current rescue record holder. All hail!';\r\n    }\r\n    \r\n    function userName(address Address) constant returns (string nickname) {\r\n        nickname = users[Address].nickname;\r\n    }\r\n    \r\n    function totalRescues() constant returns (uint rescueCount, string info) {\r\n        rescueCount = rescues;\r\n        info = 'The number of times that people have been rescued from the pit (aka the number of times people made a profit).';\r\n    }\r\n    \r\n    function multipliers() constant returns (uint BaseMultiplier, uint MaxMultiplier, string info) {\r\n        BaseMultiplier = baseMultiplier;\r\n        MaxMultiplier = maxMultiplier;\r\n        info = 'The multipliers applied to all deposits: the final multiplier is a random number between the multpliers shown divided by 100. By default x1.1~x1.5 (up to x2 if rescue tokens are used, granting +0.1 per token). It determines the amount of money you will get when rescued (a saviour share might be deducted).';\r\n    }\r\n    \r\n    function pitFee() constant returns (uint feePercentage, string info) {\r\n        feePercentage = jumpFee;\r\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 10%).';\r\n    }\r\n    \r\n    function nextPayoutGoal() constant returns (uint finneys, string info) {\r\n        finneys = (entries[payoutOrder].payout - balance) / 1 finney;\r\n        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next payout to be executed.';\r\n    }\r\n    \r\n    function unclaimedFees() constant returns (uint ethers, string info) {\r\n        ethers = collectedFees / 1 ether;\r\n        info = 'The amount of Ethers obtained through fees that have not yet been collected by the owner.';\r\n    }\r\n    \r\n    function totalEntries() constant returns (uint count, string info) {\r\n        count = entries.length;\r\n        info = 'The number of times that people have jumped into the pit.';\r\n    }\r\n    \r\n    function totalUsers() constant returns (uint users, string info) {\r\n        users = uniqueUsers;\r\n        info = 'The number of unique users that have joined the pit.';\r\n    }\r\n    \r\n    function awaitingPayout() constant returns (uint count, string info) {\r\n        count = entries.length - payoutOrder;\r\n        info = 'The number of people waiting to be saved.';\r\n    }\r\n    \r\n    function entryDetails(uint index) constant returns (address user, string nickName, uint deposit, uint payout, uint tokensUsed, string info)\r\n    {\r\n        if (index <= entries.length) {\r\n            user = entries[index].entryAddress;\r\n            nickName = users[entries[index].entryAddress].nickname;\r\n            deposit = entries[index].deposit / 1 finney;\r\n            payout = entries[index].payout / 1 finney;\r\n            tokensUsed = entries[index].tokens;\r\n            info = 'Entry info: user address, name, expected payout in Finneys (approximate), rescue tokens used.';\r\n        }\r\n    }\r\n    \r\n    function userId(address user) constant returns (uint id, string info) {\r\n        id = users[user].id;\r\n        info = 'The id of the user, represents the order in which he first joined the pit.';\r\n    }\r\n    \r\n    function userTokens(address user) constant returns (uint tokens, string info) {\r\n        tokens = users[user].addr != address(0x0) ? users[user].rescueTokens : 0;\r\n        info = 'The number of Rescue Tokens the user has. Tokens are awarded when your deposits save people, and used automatically on your next deposit. They provide a 0.1 multiplier increase per token. (+0.5 max)';\r\n    }\r\n    \r\n    function userRescues(address user) constant returns(uint rescueCount, string info) {\r\n        rescueCount = users[user].addr != address(0x0) ? users[user].rescueCount : 0;\r\n        info = 'The number of times the user has rescued someone from the pit.';\r\n    }\r\n    \r\n    function userProfits() constant returns(uint profits, string info) {\r\n        profits = usersProfits / 1 finney;\r\n        info = 'The combined earnings of all users in Finney.';\r\n    }\r\n    \r\n    //Destroy the contract after ~3 months of inactivity at the owner's discretion\r\n    function recycle() onlyowner\r\n    {\r\n        if (now >= timeOfLastDeposit + 10 weeks) \r\n        { \r\n            //Refund the current balance\r\n            if (balance > 0) \r\n            {\r\n                entries[0].entryAddress.send(balance);\r\n            }\r\n            \r\n            //Destroy the contract\r\n            selfdestruct(owner);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"recycle\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"awaitingPayout\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setNickname\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPayoutGoal\",\"outputs\":[{\"name\":\"finneys\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userId\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRescues\",\"outputs\":[{\"name\":\"rescueCount\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedFees\",\"outputs\":[{\"name\":\"ethers\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userProfits\",\"outputs\":[{\"name\":\"profits\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEntries\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"multi\",\"type\":\"uint256\"}],\"name\":\"changeBaseMultiplier\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multipliers\",\"outputs\":[{\"name\":\"BaseMultiplier\",\"type\":\"uint256\"},{\"name\":\"MaxMultiplier\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"multi\",\"type\":\"uint256\"}],\"name\":\"changeMaxMultiplier\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pitFee\",\"outputs\":[{\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"name\":\"users\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroOfThePit\",\"outputs\":[{\"name\":\"theHero\",\"type\":\"address\"},{\"name\":\"nickname\",\"type\":\"string\"},{\"name\":\"peopleSaved\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBalance\",\"outputs\":[{\"name\":\"pitBalance\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userRescues\",\"outputs\":[{\"name\":\"rescueCount\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Address\",\"type\":\"address\"}],\"name\":\"userName\",\"outputs\":[{\"name\":\"nickname\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"entryDetails\",\"outputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nickName\",\"type\":\"string\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"tokensUsed\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"Jump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"saviour\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"Rescue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"NewHero\",\"type\":\"event\"}]","ContractName":"GreedPit","CompilerVersion":"v0.3.0-2016-03-11-1f9578c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}