{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nThis file is part of the DAO.\r\n000000000000000000000000bb9bc244d798123fde783fcc1c72d3bb8c189413\r\n\r\nAccount 0xB3267B3B37a1C153Ca574c3A50359f9d1613F95d\r\ndthPool 0xB256D572885A5246DDbF548F39da57f5f8074b9a\r\n\r\nHello all! I just deployed the first DTHPool (Delegate) in the real net.\r\nThe delegate in this contract is myself. My intention is not to be a stable delegate but to construct a repository of delegates where DTH’s can choose.\r\nI tested to delegate and undelegate some tokens. I also set up the votes for the proposals made to the DAO until now. \r\nIf any body wants to delegate me some tokens, he will be wellcome!. You can also check the votes set up and his motivations. \r\nI'll appreciate any feedback.\r\nIf any body wants to be a delegate, I’m absolutely open to help him to deploy the contract.\r\n\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\n\r\n/*\r\nBasic, standardized Token contract with no \"premine\". Defines the functions to\r\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\r\ncorresponding approval process. Tokens need to be created by a derived\r\ncontract (e.g. TokenCreation.sol).\r\n\r\nThank you ConsenSys, this contract originated from:\r\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\r\nWhich is itself based on the Ethereum standardized contract APIs:\r\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\r\n*/\r\n\r\n/// @title Standard Token Contract.\r\n\r\ncontract TokenInterface {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /// Public variables of the token, all used for display \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    string public standard = 'Token 0.1';\r\n\r\n    /// Total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    /// is approved by `_from`\r\n    /// @param _from The address of the origin of the transfer\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    /// its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _amount) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    /// to spend\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    ) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n    );\r\n}\r\n\r\ncontract tokenRecipient { \r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \r\n}\r\n\r\ncontract Token is TokenInterface {\r\n    // Protects users by preventing the execution of method calls that\r\n    // inadvertently also transferred ether\r\n    modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n           return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) noEther returns (bool success) {\r\n\r\n        if (balances[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0) {\r\n\r\n            balances[_to] += _amount;\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /// Allow another contract to spend some tokens in your behalf \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/////////////////////\r\n// There is a solidity bug in the return parameters that it's not solved\r\n// when the bug is solved, the import from DAO is more clean.\r\n// In the meantime, a workaround proxy is defined\r\n\r\n// Uncoment this line when error fixed\r\n// import \"./DAO.sol\";\r\n\r\n// Workaround proxy remove when fixed\r\ncontract DAO {\r\n    function proposals(uint _proposalID) returns(\r\n        address recipient,\r\n        uint amount,\r\n        uint descriptionIdx,\r\n        uint votingDeadline,\r\n        bool open,\r\n        bool proposalPassed,\r\n        bytes32 proposalHash,\r\n        uint proposalDeposit,\r\n        bool newCurator\r\n    );\r\n\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\r\n\r\n    function vote(\r\n        uint _proposalID,\r\n        bool _supportsProposal\r\n    ) returns (uint _voteID);\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n}\r\n// End of workaround proxy\r\n////////////////////\r\n\r\n\r\ncontract DTHPoolInterface {\r\n\r\n    // delegae url\r\n    string public delegateUrl;\r\n\r\n    // Max time the tokens can be blocked.\r\n    // The real voting in the DAO will be called in the last moment in order\r\n    // to block the tokens for the minimum time. This parameter defines the\r\n    // seconds before the voting period ends that the vote can be performed\r\n    uint maxTimeBlocked;\r\n\r\n\r\n    // Address of the delegate\r\n    address public delegate;\r\n\r\n    // The DAO contract\r\n    address public daoAddress;\r\n\r\n    struct ProposalStatus {\r\n\r\n        // True when the delegate sets the vote\r\n        bool voteSet;\r\n\r\n        // True if the proposal should ve voted\r\n        bool willVote;\r\n\r\n        // True if the proposal should be accepted.\r\n        bool suportProposal;\r\n\r\n        // True when the vote is performed;\r\n        bool executed;\r\n\r\n        // Proposal votingDeadline\r\n        uint votingDeadline;\r\n\r\n        // String set by the delegator with the motivation\r\n        string motivation;\r\n    }\r\n\r\n    // Statuses of the diferent proposal\r\n    mapping (uint => ProposalStatus) public proposalStatuses;\r\n\r\n\r\n    // Index of proposals by oraclizeId\r\n    mapping (bytes32 => uint) public oraclizeId2proposalId;\r\n\r\n    /// @dev Constructor setting the dao address and the delegate\r\n    /// @param _daoAddress address of the DAO\r\n    /// @param _delegate adddress of the delegate.\r\n    /// @param _maxTimeBlocked the maximum time the tokens will be blocked\r\n    /// @param _delegateName Name of the delegate\r\n    /// @param _delegateUrl Url of the delegate\r\n    /// @param _tokenSymbol token  symbol.\r\n    // DTHPool(address _daoAddress, address _delegate, uint _maxTimeBlocked, string _delegateName, string _delegateUrl, string _tokenSymbol);\r\n\r\n\r\n    /// @notice send votes to this contract.\r\n    /// @param _amount Tokens that will be transfered to the pool.\r\n    /// @return Whether the transfer was successful or not\r\n    function delegateDAOTokens(uint _amount) returns (bool _success);\r\n\r\n    /// Returns DAO tokens to the original\r\n    /// @param _amount that will be transfered back to the owner.\r\n    /// @return Whether the transfer was successful or not\r\n    function undelegateDAOTokens(uint _amount) returns (bool _success);\r\n\r\n\r\n    /// @notice This method will be called by the delegate to publish what will\r\n    /// be his vote in a specific proposal.\r\n    /// @param _proposalID The proposal to set the vote.\r\n    /// @param _willVote true If the proposal will be voted.\r\n    /// @param _supportsProposal What will be the vote.\r\n    function setVoteIntention(\r\n        uint _proposalID,\r\n        bool _willVote,\r\n        bool _supportsProposal,\r\n        string _motivation\r\n    ) returns (bool _success);\r\n\r\n    /// @notice This method will be doing the actual voting in the DAO\r\n    /// for the _proposalID\r\n    /// @param _proposalID The proposal to set the vote.\r\n    /// @return _finalized true if this vote Proposal must not be executed again.\r\n    function executeVote(uint _proposalID) returns (bool _finalized);\r\n\r\n\r\n    /// @notice This function is intended because if some body sends tokens\r\n    /// directly to this contract, the tokens can be sent to the delegate\r\n    function fixTokens() returns (bool _success);\r\n\r\n\r\n    /// @notice If some body sends ether to this contract, the delegate will be\r\n    /// able to extract it.\r\n    function getEther() returns (uint _amount);\r\n\r\n    /// @notice Called when some body delegates token to the pool\r\n    event Delegate(address indexed _from, uint256 _amount);\r\n\r\n    /// @notice Called when some body undelegates token to the pool\r\n    event Undelegate(address indexed _from, uint256 _amount);\r\n\r\n    /// @notice Called when the delegate set se vote intention\r\n    event VoteIntentionSet(uint indexed _proposalID, bool _willVote, bool _supportsProposal);\r\n\r\n    /// @notice Called when the vote is executed in the DAO\r\n    event VoteExecuted(uint indexed _proposalID);\r\n\r\n}\r\n\r\ncontract DTHPool is DTHPoolInterface, Token, usingOraclize {\r\n\r\n    modifier onlyDelegate() {if (msg.sender != delegate) throw; _}\r\n\r\n    // DTHPool(address _daoAddress, address _delegate, uint _maxTimeBlocked, string _delegateName, string _delegateUrl, string _tokenSymbol);\r\n\r\n    function DTHPool(\r\n        address _daoAddress,\r\n        address _delegate,\r\n        uint _maxTimeBlocked,\r\n        string _delegateName,\r\n        string _delegateUrl,\r\n        string _tokenSymbol\r\n    ) {\r\n        daoAddress = _daoAddress;\r\n        delegate = _delegate;\r\n        delegateUrl = _delegateUrl;\r\n        maxTimeBlocked = _maxTimeBlocked;\r\n        name = _delegateName;\r\n        symbol = _tokenSymbol;\r\n        decimals = 16;\r\n        oraclize_setNetwork(networkID_auto);\r\n    }\r\n\r\n    function delegateDAOTokens(uint _amount) returns (bool _success) {\r\n        DAO dao = DAO(daoAddress);\r\n        if (!dao.transferFrom(msg.sender, address(this), _amount)) {\r\n            throw;\r\n        }\r\n\r\n        balances[msg.sender] += _amount;\r\n        totalSupply += _amount;\r\n        Delegate(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function undelegateDAOTokens(uint _amount) returns (bool _success) {\r\n        DAO dao = DAO(daoAddress);\r\n        if (_amount > balances[msg.sender]) {\r\n            throw;\r\n        }\r\n\r\n        if (!dao.transfer(msg.sender, _amount)) {\r\n            throw;\r\n        }\r\n\r\n        balances[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        Undelegate(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function setVoteIntention(\r\n        uint _proposalID,\r\n        bool _willVote,\r\n        bool _supportsProposal,\r\n        string _motivation\r\n    ) onlyDelegate returns (bool _success) {\r\n        DAO dao = DAO(daoAddress);\r\n\r\n        ProposalStatus proposalStatus = proposalStatuses[_proposalID];\r\n\r\n        if (proposalStatus.voteSet) {\r\n            throw;\r\n        }\r\n\r\n        var (,,,votingDeadline, ,,,,newCurator) = dao.proposals(_proposalID);\r\n\r\n        if (votingDeadline < now || newCurator ) {\r\n            throw;\r\n        }\r\n\r\n        proposalStatus.voteSet = true;\r\n        proposalStatus.willVote = _willVote;\r\n        proposalStatus.suportProposal = _supportsProposal;\r\n        proposalStatus.votingDeadline = votingDeadline;\r\n        proposalStatus.motivation = _motivation;\r\n\r\n        VoteIntentionSet(_proposalID, _willVote, _supportsProposal);\r\n\r\n        if (!_willVote) {\r\n            proposalStatus.executed = true;\r\n            VoteExecuted(_proposalID);\r\n        }\r\n\r\n        bool finalized = executeVote(_proposalID);\r\n\r\n        if ((!finalized)&&(address(OAR) != 0)) {\r\n            bytes32 oraclizeId = oraclize_query(votingDeadline - maxTimeBlocked +15, \"URL\", \"\");\r\n\r\n            oraclizeId2proposalId[oraclizeId] = _proposalID;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function executeVote(uint _proposalID) returns (bool _finalized) {\r\n        DAO dao = DAO(daoAddress);\r\n        ProposalStatus proposalStatus = proposalStatuses[_proposalID];\r\n\r\n        if (!proposalStatus.voteSet\r\n            || now > proposalStatus.votingDeadline\r\n            || !proposalStatus.willVote\r\n            || proposalStatus.executed) {\r\n\r\n            return true;\r\n        }\r\n\r\n        if (now < proposalStatus.votingDeadline - maxTimeBlocked) {\r\n            return false;\r\n        }\r\n\r\n        dao.vote(_proposalID, proposalStatus.suportProposal);\r\n        proposalStatus.executed = true;\r\n        VoteExecuted(_proposalID);\r\n\r\n        return true;\r\n    }\r\n\r\n    function __callback(bytes32 oid, string result) {\r\n        uint proposalId = oraclizeId2proposalId[oid];\r\n        executeVote(proposalId);\r\n        oraclizeId2proposalId[oid] = 0;\r\n    }\r\n\r\n    function fixTokens() returns (bool _success) {\r\n        DAO dao = DAO(daoAddress);\r\n        uint ownedTokens = dao.balanceOf(this);\r\n        if (ownedTokens < totalSupply) {\r\n            throw;\r\n        }\r\n        uint fixTokens = ownedTokens - totalSupply;\r\n\r\n        if (fixTokens == 0) {\r\n            return true;\r\n        }\r\n\r\n        balances[delegate] += fixTokens;\r\n        totalSupply += fixTokens;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getEther() onlyDelegate returns (uint _amount) {\r\n        uint amount = this.balance;\r\n\r\n        if (!delegate.call.value(amount)()) {\r\n            throw;\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalStatuses\",\"outputs\":[{\"name\":\"voteSet\",\"type\":\"bool\"},{\"name\":\"willVote\",\"type\":\"bool\"},{\"name\":\"suportProposal\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"motivation\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_willVote\",\"type\":\"bool\"},{\"name\":\"_supportsProposal\",\"type\":\"bool\"},{\"name\":\"_motivation\",\"type\":\"string\"}],\"name\":\"setVoteIntention\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oraclizeId2proposalId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"delegateDAOTokens\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateUrl\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEther\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"undelegateDAOTokens\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fixTokens\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"executeVote\",\"outputs\":[{\"name\":\"_finalized\",\"type\":\"bool\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_daoAddress\",\"type\":\"address\"},{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_maxTimeBlocked\",\"type\":\"uint256\"},{\"name\":\"_delegateName\",\"type\":\"string\"},{\"name\":\"_delegateUrl\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Undelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_willVote\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"VoteIntentionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"VoteExecuted\",\"type\":\"event\"}]","ContractName":"DTHPool","CompilerVersion":"v0.3.4-2016-06-06-e97ac4f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bb9bc244d798123fde783fcc1c72d3bb8c189413000000000000000000000000b3267b3b37a1c153ca574c3a50359f9d1613f95d0000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000001d4a6f726469204261796c696e612054686544414f2044454c45474154450000000000000000000000000000000000000000000000000000000000000000000016687474703a2f2f7777772e6261796c696e612e6361740000000000000000000000000000000000000000000000000000000000000000000000000000000000046a62c39000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":""}]}