{"status":"1","message":"OK","result":[{"SourceCode":"contract Government {\r\n\r\n    // Global Variables\r\n    uint32 public lastCreditorPayedOut;\r\n    uint public lastTimeOfNewCredit;\r\n    uint public profitFromCrash;\r\n    address[] public creditorAddresses;\r\n    uint[] public creditorAmounts;\r\n    address public corruptElite;\r\n    mapping (address => uint) buddies;\r\n    uint constant TWELVE_HOURS = 43200;\r\n    uint8 public round;\r\n\r\n    function Government() {\r\n        // The corrupt elite establishes a new government\r\n        // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\r\n        profitFromCrash = msg.value;\r\n        corruptElite = msg.sender;\r\n        lastTimeOfNewCredit = block.timestamp;\r\n    }\r\n\r\n    function lendGovernmentMoney(address buddy) returns (bool) {\r\n        uint amount = msg.value;\r\n        // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\r\n        // 12h are on average = 60*60*12/12.5 = 3456\r\n        if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\r\n            // Return money to sender\r\n            msg.sender.send(amount);\r\n            // Sends all contract money to the last creditor\r\n            creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\r\n            corruptElite.send(this.balance);\r\n            // Reset contract state\r\n            lastCreditorPayedOut = 0;\r\n            lastTimeOfNewCredit = block.timestamp;\r\n            profitFromCrash = 0;\r\n            creditorAddresses = new address[](0);\r\n            creditorAmounts = new uint[](0);\r\n            round += 1;\r\n            return false;\r\n        }\r\n        else {\r\n            // the system needs to collect at least 1% of the profit from a crash to stay alive\r\n            if (amount >= 10 ** 18) {\r\n                // the System has received fresh money, it will survive at leat 12h more\r\n                lastTimeOfNewCredit = block.timestamp;\r\n                // register the new creditor and his amount with 10% interest rate\r\n                creditorAddresses.push(msg.sender);\r\n                creditorAmounts.push(amount * 110 / 100);\r\n                // now the money is distributed\r\n                // first the corrupt elite grabs 5% - thieves!\r\n                corruptElite.send(amount * 5/100);\r\n                // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\r\n                if (profitFromCrash < 10000 * 10**18) {\r\n                    profitFromCrash += amount * 5/100;\r\n                }\r\n                // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\r\n                // Make a deal with him.\r\n                if(buddies[buddy] >= amount) {\r\n                    buddy.send(amount * 5/100);\r\n                }\r\n                buddies[msg.sender] += amount * 110 / 100;\r\n                // 90% of the money will be used to pay out old creditors\r\n                if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\r\n                    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\r\n                    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\r\n                    lastCreditorPayedOut += 1;\r\n                }\r\n                return true;\r\n            }\r\n            else {\r\n                msg.sender.send(amount);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // fallback function\r\n    function() {\r\n        lendGovernmentMoney(0);\r\n    }\r\n\r\n    function totalDebt() returns (uint debt) {\r\n        for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\r\n            debt += creditorAmounts[i];\r\n        }\r\n    }\r\n\r\n    function totalPayedOut() returns (uint payout) {\r\n        for(uint i=0; i<lastCreditorPayedOut; i++){\r\n            payout += creditorAmounts[i];\r\n        }\r\n    }\r\n\r\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\r\n    function investInTheSystem() {\r\n        profitFromCrash += msg.value;\r\n    }\r\n\r\n    // From time to time the corrupt elite inherits it's power to the next generation\r\n    function inheritToNextGeneration(address nextGeneration) {\r\n        if (msg.sender == corruptElite) {\r\n            corruptElite = nextGeneration;\r\n        }\r\n    }\r\n\r\n    function getCreditorAddresses() returns (address[]) {\r\n        return creditorAddresses;\r\n    }\r\n\r\n    function getCreditorAmounts() returns (uint[]) {\r\n        return creditorAmounts;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastCreditorPayedOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"corruptElite\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeOfNewCredit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nextGeneration\",\"type\":\"address\"}],\"name\":\"inheritToNextGeneration\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investInTheSystem\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"totalPayedOut\",\"outputs\":[{\"name\":\"payout\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitFromCrash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCreditorAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"creditorAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getCreditorAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buddy\",\"type\":\"address\"}],\"name\":\"lendGovernmentMoney\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"creditorAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"name\":\"debt\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"Government","CompilerVersion":"v0.2.1-2016-01-30-91a6b35","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}