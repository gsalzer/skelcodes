{"status":"1","message":"OK","result":[{"SourceCode":"//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//   WHYSOS3RIOUS   PRESENTS :   \r\n//   The ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become an investor in the Casino and share the profits/losses.) \r\n//\r\n//\r\n//   Full GUI on website with all info to play : \r\n//                   \r\n//                  www.Rouleth.com\r\n//\r\n//\r\n//   All documentation on playing and investing are on the website.\r\n//\r\n//   News : www.reddit.com/r/Rouleth\r\n//   twitter : https://twitter.com/TheRouleth\r\n//\r\n//   Github : https://github.com/Bunjin/Rouleth\r\n//\r\n//   check latest contract version on website\r\n//   V 1.2\r\n//\r\n// *** coded by WhySoS3rious, 2016.                                       ***//\r\n// *** please do not copy without authorization                          ***//\r\n// *** contact : reddit    /u/WhySoS3rious                               ***//\r\n//\r\n//\r\n//  Stake : Variable, check on website for the max bet.\r\n\r\ncontract Rouleth\r\n{\r\n\r\n    //Variables, Structure\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit;\r\n    //Current gamble value possibly lower than config (<payroll/(casinoStatisticalLimit*35))\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\t//Possible bet types\r\n        BetTypes betType;\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet -1\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; //records current status of player\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n    function  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=2; //delay to wait between bet and spin\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        maxGamble=500 finney; //configurable max bet\r\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\r\n        casinoStatisticalLimit=20;\r\n    }\r\n\t\r\n    modifier onlyDeveloper() \r\n    {\r\n\tif (msg.sender!=developer) throw;\r\n\t_\r\n    }\r\n\t\r\n    function changeDeveloper(address new_dev)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tdeveloper=new_dev;\r\n    }\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private state;\r\n\t\r\n    function disableBetting()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        state=States.inactive;\r\n    }\r\n    function enableBetting()\r\n    onlyDeveloper\r\n    noEthSent\r\n    {\r\n        state=States.active;\r\n    }\r\n    \r\n    modifier onlyActive\r\n    {\r\n        if (state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n    //Change some settings within safety bounds\r\n    function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n    noEthSent\r\n    onlyDeveloper\r\n\t{\r\n\t        // changes the statistical multiplier that guarantees the long run casino survival\r\n\t        if (newCasinoStatLimit<10) throw;\r\n\t        casinoStatisticalLimit=newCasinoStatLimit;\r\n\t        //Max number of bets per block to prevent miner cheating\r\n\t        maxBetsPerBlock=newMaxBetsBlock;\r\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\r\n\t\tif (newMaxGamble<=0) throw; \r\n\t\telse { maxGamble=newMaxGamble; }\r\n                //MAX NB of INVESTORS (can only increase and max of 149)\r\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\r\n                else { setting_maxInvestors=newMaxInvestor;}\r\n                //MIN INVEST : \r\n                setting_minInvestment=newMinInvestment;\r\n                //Invest LOCK PERIOD\r\n                if (setting_lockPeriod>90 days) throw; //3 months max\r\n                setting_lockPeriod=newLockPeriod;\r\n\t\t//Delay before roll :\r\n\t\tif (blockDelay<1) throw;\r\n\t\tblockDelay=newBlockDelay;\r\n                updateMaxBet();\r\n\t\tif (newBlockExpiration<50) throw;\r\n\t\tblockExpiration=newBlockExpiration;\r\n\t}\r\n \r\n\r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n//***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n   {\r\n       //if player is not playing : bet on Red\r\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnColor(true,false);\r\n       //if player is already playing, spin the wheel\r\n       else spinTheWheel();\r\n    } \r\n\r\n    function updateMaxBet() private\r\n    {\r\n    //check that maxGamble setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t\t{ \r\n\t\t\tcurrentMaxGamble=maxGamble;\r\n                }\r\n\telse\r\n\t\t{ \r\n\t\t\tcurrentMaxGamble = payroll/(casinoStatisticalLimit*35);\r\n\t\t}\r\n     }\r\n\r\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        updateMaxBet();\r\n\t\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t\t{\r\n\t\t\tif (msg.sender.send(msg.value-currentMaxGamble)==false) throw;\r\n\t\t    playerBetValue=currentMaxGamble;\r\n\t\t}\r\n                else\r\n                { playerBetValue=msg.value; }\r\n         return;\r\n       }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n    //check that the player is not playing already (unless it has expired)\r\n    modifier checkWaitingForBet{\r\n        //if player is already in gamble\r\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\r\n        {\r\n             //case not expired\r\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\r\n             //case expired\r\n             else\r\n             {\r\n                  //add bet to PL and reset status\r\n                  solveBet(msg.sender, 255, false, 0) ;\r\n\r\n              }\r\n        }\r\n\t_\r\n\t}\r\n\r\n    function updateStatusPlayer() private\r\n    expireGambles\r\n    {\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length;\r\n     }\r\n\r\n//***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n        //adapts wager to casino limits\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\r\n    }\r\n\r\n//***// function betOnColor\r\n\t//bet type : color\r\n\t//input : 0 for red\r\n\t//input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Black) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\r\n    }\r\n\r\n//***// function betOnLow_High\r\n\t//bet type : lowhigh\r\n\t//input : 0 for low\r\n\t//input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (High) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\r\n    }\r\n\r\n//***// function betOnOdd_Even\r\n\t//bet type : parity\r\n     //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Odd) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\r\n    }\r\n\r\n\r\n//***// function betOnDozen\r\n//     //bet type : dozen\r\n//     //input : 0 for first dozen\r\n//     //input : 1 for second dozen\r\n//     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    {\r\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n// //***// function betOnColumn\r\n//     //bet type : column\r\n//     //input : 0 for first column\r\n//     //input : 1 for second column\r\n//     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    {\r\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n     }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    { \r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Second) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (Third) \r\n        {\r\n             count+=1; \r\n             input=2;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\r\n    }\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n\tevent Win(address player, uint8 result, uint value_won);\r\n\tevent Loss(address player, uint8 result, uint value_loss);\r\n\r\n    //check that player has to spin the wheel\r\n    modifier checkWaitingForSpin{\r\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\r\n\t_\r\n\t}\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) \r\n\t\t{\r\n\t\t\t\tif (msg.sender.send(msg.value)==false) throw;\r\n\t\t}\r\n        _\r\n    }\r\n\r\n//***//function to spin\r\n    function spinTheWheel()\r\n    noEthSent\r\n    checkWaitingForSpin\r\n    {\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired\r\n\tuint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\r\n\tif (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\r\n        else\r\n\t{\r\n\t    uint8 wheelResult;\r\n            //Spin the wheel, Reset player status and record result\r\n\t    wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\r\n\t    gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\r\n            //check result against bet and pay if win\r\n\t    checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\r\n\t    updateFirstActiveGamble();\r\n\t}\r\n    }\r\n\r\n//update pointer of first gamble not spinned\r\nfunction updateFirstActiveGamble() private\r\n     {\r\n              for (uint k=firstActiveGamble; k<=firstActiveGamble+50; k++) \r\n              //limit the update to 50 to cap the gas cost and share the work among users\r\n              {\r\n                 if (k>=gambles.length || !gambles[k].spinned)\r\n                 {\r\n                    firstActiveGamble=k;\r\n                    break; \r\n                 }\r\n              }\r\n }\r\n\t\r\n//checks if there are expired gambles\r\nmodifier expireGambles{\r\n    if (  gambles.length!=0 && gambles.length-1>=firstActiveGamble \r\n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number \r\n          && !gambles[firstActiveGamble].spinned )  \r\n    { \r\n\tsolveBet(gambles[firstActiveGamble].player, 255, false, 0); //expires\r\n    }\r\n        updateFirstActiveGamble(); //update pointer\r\n        _\r\n}\r\n\t\r\n\r\n     //CHECK BETS FUNCTIONS private\r\n     function checkBetResult(uint8 result, BetTypes betType) private\r\n     {\r\n          //bet on Number\r\n          if (betType==BetTypes.number) checkBetNumber(result);\r\n          else if (betType==BetTypes.parity) checkBetParity(result);\r\n          else if (betType==BetTypes.color) checkBetColor(result);\r\n\t else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\r\n\t else if (betType==BetTypes.dozen) checkBetDozen(result);\r\n\telse if (betType==BetTypes.column) checkBetColumn(result);\r\n          updateMaxBet(); \r\n     }\r\n\r\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\r\n     {\r\n        playerStatus[player]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n            if (win)\r\n            {\r\n                  if (player!=gambles[gambleIndex[player]].player) throw; //security failcheck\r\n\t\t  gambles[gambleIndex[player]].win=true;\r\n\t\t  uint win_v = multiplier*bet_v;\r\n                  lossSinceChange+=win_v-bet_v;\r\n\t\t  Win(player, result, win_v);\r\n\t\t\t\tif (player.send(win_v)==false) throw;\r\n             }\r\n            else\r\n            {\r\n\t\tLoss(player, result, bet_v);\r\n                profitSinceChange+=bet_v;\r\n            }\r\n\r\n      }\r\n\r\n\r\n     // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n     function checkBetNumber(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result==gambles[gambleIndex[msg.sender]].input)\r\n\t    {\r\n                  win=true;  \r\n             }\r\n             solveBet(msg.sender, result,win,36);\r\n     }\r\n\r\n\r\n     // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n     function checkBetParity(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\r\n\t    {\r\n                  win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n        \r\n     }\r\n\t\r\n     // checkbet on lowhigh\r\n     // bet type : lowhigh\r\n     // input : 0 low, 1 high\r\n     function checkBetLowhigh(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t\t if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\r\n\t\t\t || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\r\n\t\t\t ) )\r\n\t    {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n     }\r\n\r\n     // checkbet on color\r\n     // bet type : color\r\n     // input : 0 red, 1 black\r\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n      function checkBetColor(uint8 result) private\r\n      {\r\n             bool red;\r\n             //check if red\r\n             for (uint8 k; k<18; k++)\r\n             { \r\n                    if (red_list[k]==result) \r\n                    { \r\n                          red=true; \r\n                          break;\r\n                    }\r\n             }\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n       }\r\n\r\n     // checkbet on dozen\r\n     // bet type : dozen\r\n     // input : 0 first, 1 second, 2 third\r\n     function checkBetDozen(uint8 result) private\r\n     { \r\n            bool win;\r\n            //win on first dozen\r\n     \t\t if ( result!=0 &&\r\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\r\n     \t\t\t||\r\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\r\n                    ||\r\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\r\n     \t    {\r\n                   win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n     }\r\n\r\n     // checkbet on column\r\n     // bet type : column\r\n     // input : 0 first, 1 second, 2 third\r\n      function checkBetColumn(uint8 result) private\r\n      {\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\r\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n      }\r\n\r\n\r\n//INVESTORS FUNCTIONS\r\n\r\n\r\n//total casino payroll\r\n    uint256 payroll;\r\n//Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n//investor struct array (hard capped to 150)\r\n    uint8 setting_maxInvestors = 50;\r\n    struct Investor\r\n    {\r\n\t    address investor;\r\n\t    uint256 time;\r\n    }\t\r\n\t\r\n    Investor[250] private investors ;\r\n    //Balances of the investors\r\n    mapping (address=>uint256) balance; \r\n    //Investor lockPeriod\r\n    //lock time to avoid invest and withdraw for refresh only\r\n    //also time during which you cannot be outbet by a new investor if it is full\r\n    uint256 setting_lockPeriod=30 days ;\r\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\r\n    //if full and unlocked position, indicates the cheapest amount to outbid\r\n    //otherwise cheapestUnlockedPosition=255\r\n    uint8 cheapestUnlockedPosition; \r\n    uint256 minCurrentInvest; \r\n    //record open position index\r\n    // =255 if full\r\n    uint8 openPosition;\r\n\t\r\n    event newInvest(address player, uint invest_v);\r\n\r\n\r\n     function invest()\r\n     {\r\n          // check that min 10 ETH is sent (variable setting)\r\n          if (msg.value<setting_minInvestment) throw;\r\n          // check if already investor\r\n          bool alreadyInvestor;\r\n          // reset the position counters to values out of bounds\r\n          openPosition=255;\r\n          cheapestUnlockedPosition=255;\r\n          minCurrentInvest=1000000000 ether;\r\n          // update balances before altering the investor shares\r\n          updateBalances();\r\n          // loop over investor's array to find if already investor, \r\n          // or openPosition and cheapest UnlockedPosition\r\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n          { \r\n               //captures an index of an open position\r\n               if (investors[k].investor==0) openPosition=k; \r\n               //captures if already an investor \r\n               else if (investors[k].investor==msg.sender)\r\n               {\r\n                    investors[k].time=now; //refresh time invest\r\n                    alreadyInvestor=true;\r\n                }\r\n               //captures the index of the investor with the min investment (after lock period)\r\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\r\n               {\r\n                    cheapestUnlockedPosition=k;\r\n                    minCurrentInvest=balance[investors[k].investor];\r\n                }\r\n           }\r\n           //case New investor\r\n           if (alreadyInvestor==false)\r\n           {\r\n                    //case : investor array not full, record new investor\r\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\r\n                    //case : investor array full\r\n                    else\r\n                    {\r\n                         //subcase : investor has not outbid or all positions under lock period\r\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\r\n                         //subcase : investor outbid, record investor change and refund previous\r\n                         else\r\n                         {\r\n                              address previous = investors[cheapestUnlockedPosition].investor;\r\n                              balance[previous]=0;\r\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\r\n                              if (previous.send(balance[previous])==false) throw;\r\n                          }\r\n                     }\r\n            }\r\n          //add investment to balance of investor and to payroll\r\n\r\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\r\n          uint256 netInvest=msg.value - maintenanceFees;\r\n          newInvest(msg.sender, netInvest);\r\n          balance[msg.sender]+=netInvest; //add invest to balance\r\n          payroll+=netInvest;\r\n          //send maintenance fees to developer \r\n          if (developer.send(maintenanceFees)==false) throw;\r\n          updateMaxBet();\r\n      }\r\n\r\n//***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min investment required,\r\n    // your balance is fully withdrawn\r\n\tevent withdraw(address player, uint withdraw_v);\r\n\t\r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve investor ID\r\n        uint8 investorID=255;\r\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n               if (investors[k].investor==msg.sender)\r\n               {\r\n                    investorID=k;\r\n                    break;\r\n               }\r\n        }\r\n           if (investorID==255) throw; //stop if not an investor\r\n           //check if investment lock period is over\r\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n           //if balance left after withdraw is still above min investment accept partial withdraw\r\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n           {\r\n               balance[msg.sender]-=amountToWithdrawInWei;\r\n               payroll-=amountToWithdrawInWei;\r\n               //send amount to investor (with security if transaction fails)\r\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t       withdraw(msg.sender, amountToWithdrawInWei);\r\n           }\r\n           else\r\n           //if amountToWithdraw=0 : user wants full withdraw\r\n           //if balance after withdraw is < min invest, withdraw all and delete investor\r\n           {\r\n               //send amount to investor (with security if transaction fails)\r\n               uint256 fullAmount=balance[msg.sender];\r\n               payroll-=fullAmount;\r\n               balance[msg.sender]=0;\r\n               //delete investor\r\n               delete investors[investorID];\r\n               if (msg.sender.send(fullAmount)==false) throw;\r\n   \t       withdraw(msg.sender, fullAmount);\r\n            }\r\n          updateMaxBet();\r\n     }\r\n\r\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\r\n\r\n\tfunction manualUpdateBalances()\r\n\texpireGambles\r\n\tnoEthSent\r\n\tonlyDeveloper\r\n\t{\r\n\t    updateBalances();\r\n\t}\r\n    function updateBalances() private\r\n    {\r\n         //split Profits\r\n         uint256 profitToSplit;\r\n         uint256 lossToSplit;\r\n         if (profitSinceChange==0 && lossSinceChange==0)\r\n         { return; }\r\n         \r\n         else\r\n         {\r\n             // Case : Global profit (more win than losses)\r\n             // 2% fees for developer on global profit (if profit>loss)\r\n             if (profitSinceChange>lossSinceChange)\r\n             {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*2/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n             }\r\n             else\r\n             {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n             }\r\n         \r\n         //share the loss and profits between all invest \r\n         //(proportionnaly. to each investor balance)\r\n         uint totalShared;\r\n             for (uint8 k=0; k<setting_maxInvestors; k++)\r\n             {\r\n                 address inv=investors[k].investor;\r\n                 if (inv==0) continue;\r\n                 else\r\n                 {\r\n                       if (profitToSplit!=0) \r\n                       {\r\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                           balance[inv]+=profitShare;\r\n                           totalShared+=profitShare;\r\n                       }\r\n                       if (lossToSplit!=0) \r\n                       {\r\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                           balance[inv]-=lossShare;\r\n                           totalShared+=lossShare;\r\n                           \r\n                       }\r\n                 }\r\n             }\r\n          // update payroll\r\n          if (profitToSplit !=0) \r\n          {\r\n              payroll+=profitToSplit;\r\n              balance[developer]+=profitToSplit-totalShared;\r\n          }\r\n          if (lossToSplit !=0) \r\n          {\r\n              payroll-=lossToSplit;\r\n              balance[developer]-=lossToSplit-totalShared;\r\n          }\r\n          profitSinceChange=0; //reset Profit;\r\n          lossSinceChange=0; //reset Loss ;\r\n          \r\n          }\r\n     }\r\n     \r\n     \r\n     //INFORMATION FUNCTIONS\r\n     \r\n     function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances)\r\n     {\r\n        profit_since_update_balances=profitSinceChange;\r\n        loss_since_update_balances=lossSinceChange;\r\n        return;\r\n     }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n          balanceInWei=balance[investor];\r\n          return;\r\n     }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n          investor=investors[index].investor;\r\n          endLockPeriod=investors[index].time+setting_lockPeriod;\r\n          return;\r\n    }\r\n\t\r\n\r\n\tfunction investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\r\n\t{\r\n\t\tif (openPosition!=255) open_position=true;\r\n\t\tif (cheapestUnlockedPosition!=255) \r\n\t\t{\r\n\t\t\tunlocked_position=true;\r\n\t\t\tbuyout_amount=minCurrentInvest;\r\n\t\t}\r\n\t\tinvestLockPeriod=setting_lockPeriod;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfunction getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n\t{\r\n\t    maxBet=currentMaxGamble;\r\n\t    blockDelayBeforeSpin=blockDelay;\r\n\t    return ;\r\n\t}\r\n\r\n\tfunction getFirstActiveGamble() constant returns(uint _firstActiveGamble)\r\n\t{\r\n            _firstActiveGamble=firstActiveGamble;\r\n\t    return ;\r\n\t}\r\n\t\r\n\tfunction getPayroll() constant returns(uint payroll_at_last_update_balances)\r\n\t{\r\n            payroll_at_last_update_balances=payroll;\r\n\t    return ;\r\n\t}\r\n\r\n\t\r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\r\n    {\r\n          player_status=playerStatus[player];\r\n          bettype=gambles[gambleIndex[player]].betType;\r\n          input=gambles[gambleIndex[player]].input;\r\n          value=gambles[gambleIndex[player]].wager;\r\n          result=gambles[gambleIndex[player]].wheelResult;\r\n          wheelspinned=gambles[gambleIndex[player]].spinned;\r\n          win=gambles[gambleIndex[player]].win;\r\n          blockNb=gambles[gambleIndex[player]].blockNumber;\r\n\t  return;\r\n     }\r\n     \r\n         function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\r\n    {\r\n          player=gambles[index].player;\r\n          bettype=gambles[index].betType;\r\n          input=gambles[index].input;\r\n          value=gambles[index].wager;\r\n          result=gambles[index].wheelResult;\r\n          wheelspinned=gambles[index].spinned;\r\n          win=gambles[index].win;\r\n\t  blockNb=gambles[index].blockNumber;\r\n\t  return;\r\n     }\r\n\r\n} //end of contract","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amountToWithdrawInWei\",\"type\":\"uint256\"}],\"name\":\"withdrawInvestment\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkProfitLossSinceInvestorChange\",\"outputs\":[{\"name\":\"profit_since_update_balances\",\"type\":\"uint256\"},{\"name\":\"loss_since_update_balances\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_dev\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Red\",\"type\":\"bool\"},{\"name\":\"Black\",\"type\":\"bool\"}],\"name\":\"betOnColor\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableBetting\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCasinoStatLimit\",\"type\":\"uint256\"},{\"name\":\"newMaxBetsBlock\",\"type\":\"uint256\"},{\"name\":\"newMaxGamble\",\"type\":\"uint256\"},{\"name\":\"newMaxInvestor\",\"type\":\"uint8\"},{\"name\":\"newMinInvestment\",\"type\":\"uint256\"},{\"name\":\"newLockPeriod\",\"type\":\"uint256\"},{\"name\":\"newBlockDelay\",\"type\":\"uint8\"},{\"name\":\"newBlockExpiration\",\"type\":\"uint8\"}],\"name\":\"changeSettings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkMyBet\",\"outputs\":[{\"name\":\"player_status\",\"type\":\"uint8\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorList\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"endLockPeriod\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"name\":\"maxBet\",\"type\":\"uint256\"},{\"name\":\"blockDelayBeforeSpin\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPayroll\",\"outputs\":[{\"name\":\"payroll_at_last_update_balances\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstActiveGamble\",\"outputs\":[{\"name\":\"_firstActiveGamble\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Low\",\"type\":\"bool\"},{\"name\":\"High\",\"type\":\"bool\"}],\"name\":\"betOnLowHigh\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualUpdateBalances\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberChosen\",\"type\":\"uint8\"}],\"name\":\"betOnNumber\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Odd\",\"type\":\"bool\"},{\"name\":\"Even\",\"type\":\"bool\"}],\"name\":\"betOnOddEven\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGamblesList\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"First\",\"type\":\"bool\"},{\"name\":\"Second\",\"type\":\"bool\"},{\"name\":\"Third\",\"type\":\"bool\"}],\"name\":\"betOnDozen\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBetting\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"spinTheWheel\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"First\",\"type\":\"bool\"},{\"name\":\"Second\",\"type\":\"bool\"},{\"name\":\"Third\",\"type\":\"bool\"}],\"name\":\"betOnColumn\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"checkInvestorBalance\",\"outputs\":[{\"name\":\"balanceInWei\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentEntryCost\",\"outputs\":[{\"name\":\"open_position\",\"type\":\"bool\"},{\"name\":\"unlocked_position\",\"type\":\"bool\"},{\"name\":\"buyout_amount\",\"type\":\"uint256\"},{\"name\":\"investLockPeriod\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_won\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_loss\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invest_v\",\"type\":\"uint256\"}],\"name\":\"newInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdraw_v\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"type\":\"event\"}]","ContractName":"Rouleth","CompilerVersion":"v0.3.4-2016-05-31-7dab890","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}