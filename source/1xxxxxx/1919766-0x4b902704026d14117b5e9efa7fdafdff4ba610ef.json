{"status":"1","message":"OK","result":[{"SourceCode":"contract DaoAccount\r\n{\r\n\t/**************************\r\n\t\t\t    Constants\r\n\t***************************/\r\n\r\n\tuint256 constant tokenPrice = 1000000000000000; // 1 finney\r\n\r\n\t/**************************\r\n\t\t\t\t\tEvents\r\n\t***************************/\r\n\r\n\t// No events\r\n\t\r\n\t/**************************\r\n\t     Public variables\r\n\t***************************/\r\n\r\n  uint256 public tokenBalance; // number of tokens in this account\r\n\r\n\t/**************************\r\n\t     Private variables\r\n\t***************************/\r\n\r\n  address owner;        // owner of the otkens\r\n\taddress daoChallenge; // the DaoChallenge this account belongs to\r\n\r\n  // Owner of the challenge with backdoor access.\r\n  // Remove for a real DAO contract:\r\n  address challengeOwner;\r\n\r\n\t/**************************\r\n\t\t\t     Modifiers\r\n\t***************************/\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t/**************************\r\n\t Constructor and fallback\r\n\t**************************/\r\n\r\n  function DaoAccount (address _owner, address _challengeOwner) {\r\n    owner = _owner;\r\n    daoChallenge = msg.sender;\r\n\r\n    // Remove for a real DAO contract:\r\n    challengeOwner = _challengeOwner;\r\n\t}\r\n\r\n  // Only owner can fund:\r\n\tfunction () onlyOwner returns (uint256 newBalance){\r\n\t\tuint256 amount = msg.value;\r\n\r\n\t\t// No fractional tokens:\r\n\t\tif (amount % tokenPrice != 0) {\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n    uint256 tokens = amount / tokenPrice;\r\n\r\n\t\ttokenBalance += tokens;\r\n\r\n    return tokenBalance;\r\n\t}\r\n\r\n\t/**************************\r\n\t     Private functions\r\n\t***************************/\r\n\r\n\t// This uses call.value()() rather than send(), but only sends to msg.sender\r\n  // who is also the owner.\r\n\tfunction withdrawEtherOrThrow(uint256 amount) private {\r\n    if (msg.sender != owner) throw;\r\n\t\tbool result = owner.call.value(amount)();\r\n\t\tif (!result) {\r\n\t\t\tthrow;\r\n\t\t}\r\n\t}\r\n\r\n\t/**************************\r\n\t\t\t Public functions\r\n\t***************************/\r\n\r\n\tfunction refund() noEther onlyOwner {\r\n\t\tif (tokenBalance == 0) throw;\r\n\t\ttokenBalance = 0;\r\n\t\twithdrawEtherOrThrow(tokenBalance * tokenPrice);\r\n\t}\r\n\r\n\t// The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}\r\ncontract DaoChallenge\r\n{\r\n\t/**************************\r\n\t\t\t\t\tConstants\r\n\t***************************/\r\n\r\n\t// No Constants\r\n\r\n\t/**************************\r\n\t\t\t\t\tEvents\r\n\t***************************/\r\n\r\n\tevent notifyTerminate(uint256 finalBalance);\r\n\r\n\t/**************************\r\n\t     Public variables\r\n\t***************************/\r\n\r\n\t/**************************\r\n\t\t\t Private variables\r\n\t***************************/\r\n\r\n\t// Owner of the challenge; a real DAO doesn't an owner.\r\n\taddress owner;\r\n\r\n\tmapping (address => DaoAccount) private daoAccounts;\r\n\r\n\t/**************************\r\n\t\t\t\t\t Modifiers\r\n\t***************************/\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\t/**************************\r\n\t Constructor and fallback\r\n\t**************************/\r\n\r\n\tfunction DaoChallenge () {\r\n\t\towner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\r\n\t}\r\n\r\n\tfunction () noEther {\r\n\t}\r\n\r\n\t/**************************\r\n\t     Private functions\r\n\t***************************/\r\n\r\n\t// No private functions\r\n\r\n\t/**************************\r\n\t     Public functions\r\n\t***************************/\r\n\r\n\tfunction createAccount () noEther returns (DaoAccount account) {\r\n\t\taddress accountOwner = msg.sender;\r\n\t\taddress challengeOwner = owner; // Don't use in a real DAO\r\n\r\n\t\t// One account per address:\r\n\t\tif(daoAccounts[accountOwner] != DaoAccount(0x00)) throw;\r\n\r\n\t\tdaoAccounts[accountOwner] = new DaoAccount(accountOwner, challengeOwner);\r\n\t\treturn daoAccounts[accountOwner];\r\n\t}\r\n\r\n\tfunction myAccount () noEther returns (DaoAccount) {\r\n\t\taddress accountOwner = msg.sender;\r\n\t\treturn daoAccounts[accountOwner];\r\n\t}\r\n\r\n\t// The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n\tfunction terminate() noEther onlyOwner {\r\n\t\tnotifyTerminate(this.balance);\r\n\t\tsuicide(owner);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"myAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"finalBalance\",\"type\":\"uint256\"}],\"name\":\"notifyTerminate\",\"type\":\"event\"}]","ContractName":"DaoChallenge","CompilerVersion":"v0.3.5-nightly.2016.7.1+commit.48238c9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}