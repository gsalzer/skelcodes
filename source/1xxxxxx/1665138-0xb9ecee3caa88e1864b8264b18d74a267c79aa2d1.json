{"status":"1","message":"OK","result":[{"SourceCode":"contract EthereumRouletteInterface {\r\n\r\n  // The owner is responsible for committing and revealing spin results.\r\n  address public owner;\r\n  // Funds that are kept in reserve in order to pay off the winners in all revealed spins.\r\n  // This number increases when new bets are made and decreases when winners collect their\r\n  // winnings. When all winnings have been collected, this should be 0.\r\n  uint public locked_funds_for_revealed_spins;\r\n  // How much time (in seconds) the owner has to reveal the result to a spin after the\r\n  // first bet has been made.\r\n  uint public owner_time_limit;\r\n  // Used to calculate the maximum bet a player can make.\r\n  uint public fraction;\r\n  // Maximum bet that a player can make on one of the numbers this spin.\r\n  uint public max_bet_this_spin;\r\n  // Contains all spins that happened so far. All spins, except that last two, are\r\n  // settled. A spin is settled if and only if the spin_result and nonce are revealed by\r\n  // the owner or owner_took_too_long flag is true. If a spin is settled, then players can\r\n  // collect their winnings from that spin. It's possible that the last two spins are also\r\n  // settled if the owner took too long.\r\n  Spin[] public spins;\r\n\r\n  struct Spin {\r\n    // If owner takes too long (does not respond in time and someone calls the\r\n    // player_declare_taking_too_long function), owner_took_too_long will be set to true\r\n    // and all players will be paid out. This represents the total sum that will be paid\r\n    // out in that case.\r\n    uint total_payout;\r\n    // The owner privately computes the sha3 of spin_result + nonce.\r\n    bytes32 commit_hash;\r\n    // Should be in [0, 37] range. 0 and 37 represent 0 and 00 on the roulette wheel.\r\n    uint8 spin_result;\r\n    // Some random value that the owner generates to make it impossible for someone to\r\n    // guess the spin_result based on the commit_hash.\r\n    bytes32 nonce;\r\n    // Total amount that was bet on a particular number. Used to verify that the amount\r\n    // bet on a number does not exceed max_bet_this_spin.\r\n    mapping(uint8 => uint) total_bet_on_number;\r\n    // Maps player address to a bet on a particular spin_result.\r\n    mapping(address => mapping(uint8 => Bet)) bets;\r\n    // This can be set to true if player_declare_taking_too_long is called if the owner is\r\n    // taking too long. In that case all bets in this round will be winners.\r\n    bool owner_took_too_long;\r\n    // Time (in seconds) by which the spin result should be revealed by the owner.\r\n    uint time_of_latest_reveal;\r\n  }\r\n\r\n  struct Bet {\r\n    uint amount;\r\n    // True if this bet was already paid.\r\n    bool already_paid;\r\n  }\r\n\r\n  // Allows only the owner to call certain functions.\r\n  modifier onlyOwner {}\r\n  // Verifies no Ether is sent when calling a function.\r\n  modifier noEther {}\r\n  // Verifies that more than 0 Ether is sent when calling a function.\r\n  modifier etherRequired {}\r\n\r\n  // Player makes a bet on a particular spin_result.\r\n  function player_make_bet(uint8 spin_result) etherRequired;\r\n\r\n  // Player calls this function to collect all winnings from a particular spin.\r\n  function player_collect_winnings(uint spin_num) noEther;\r\n\r\n  // If the owner is taking too long to reveal the spin result, player can call this\r\n  // function. If enough time passed, all bets in the last two spins (which are\r\n  // unrevealed) will become winners. Player can then call player_collect_winnings.\r\n  function player_declare_taking_too_long() noEther;\r\n\r\n  // Owner reveals the spin_result and nonce for the first unrevealed spin (which is\r\n  // second last in the spins array). Owner also also adds a new unrevealed spin to the\r\n  // spins array. All new player bets will be on this new spin after this function is\r\n  // called.\r\n  //\r\n  // The reason why we always have two unrevealed spins (instead of 1) is because of this\r\n  // function. If there was only 1 unrevealed spin, when the owner tried revealing it,\r\n  // an attacker would be able to see the spin result in the transaction that the owner\r\n  // submits and quickly try to place a bet on the spin_result to try to get his\r\n  // trasaction to be processed before the owner.\r\n  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther;\r\n\r\n  // Set a new time limit for the owner between commit and reveal.\r\n  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther;\r\n\r\n  // Allows the owner to deposit additional funds into the contract.\r\n  function owner_deposit() onlyOwner etherRequired;\r\n\r\n  // Allows the owner to withdraw the winnings. Makes sure that the owner does not\r\n  // withdraw any funds that should be paid out to the players.\r\n  function owner_withdraw(uint amount) onlyOwner noEther;\r\n\r\n  // Updates the fraction (has an effect on how large the player bets can be).\r\n  function owner_set_fraction(uint _fraction) onlyOwner noEther;\r\n\r\n  function owner_transfer_ownership(address new_owner) onlyOwner noEther;\r\n\r\n  event MadeBet(uint amount, uint8 spin_result, address player_addr);\r\n  event Revealed(uint spin_number, uint8 spin_result);\r\n}\r\n\r\n\r\ncontract EthereumRoulette is EthereumRouletteInterface {\r\n\r\n  modifier onlyOwner {if (msg.sender != owner) throw; _}\r\n\r\n  modifier noEther {if (msg.value > 0) throw; _}\r\n\r\n  modifier etherRequired {if (msg.value == 0) throw; _}\r\n\r\n  function EthereumRoulette() {\r\n    owner = msg.sender;\r\n    fraction = 800;\r\n    owner_time_limit = 7 days;\r\n    // The contract must always have 2 unrevealed spins. This is why we commit the first\r\n    // two spins in the constructor. This means that it's not possible to bet on spin #1.\r\n    bytes32 first_num_hash = 0x3c81cf7279de81901303687979a6b62fdf04ec93480108d2ef38090d6135ad9f;\r\n    bytes32 second_num_hash = 0xb1540f17822cbe4daef5f1d96662b2dc92c5f9a2411429faaf73555d3149b68e;\r\n    spins.length++;\r\n    spins[spins.length - 1].commit_hash = first_num_hash;\r\n    spins.length++;\r\n    spins[spins.length - 1].commit_hash = second_num_hash;\r\n    max_bet_this_spin = address(this).balance / fraction;\r\n  }\r\n\r\n  function player_make_bet(uint8 spin_result) etherRequired {\r\n    Spin second_unrevealed_spin = spins[spins.length - 1];\r\n    if (second_unrevealed_spin.owner_took_too_long\r\n        || spin_result > 37\r\n        || msg.value + second_unrevealed_spin.total_bet_on_number[spin_result] > max_bet_this_spin\r\n        // verify it will be possible to pay the player in the worst case\r\n        || msg.value * 36 + reserved_funds() > address(this).balance) {\r\n      throw;\r\n    }\r\n    Bet b = second_unrevealed_spin.bets[msg.sender][spin_result];\r\n    b.amount += msg.value;\r\n    second_unrevealed_spin.total_bet_on_number[spin_result] += msg.value;\r\n    second_unrevealed_spin.total_payout += msg.value * 36;\r\n    if (second_unrevealed_spin.time_of_latest_reveal == 0) {\r\n      second_unrevealed_spin.time_of_latest_reveal = now + owner_time_limit;\r\n    }\r\n    MadeBet(msg.value, spin_result, msg.sender);\r\n  }\r\n\r\n  function player_collect_winnings(uint spin_num) noEther {\r\n    Spin s = spins[spin_num];\r\n    if (spin_num >= spins.length - 2) {\r\n      throw;\r\n    }\r\n    if (s.owner_took_too_long) {\r\n      bool at_least_one_number_paid = false;\r\n      for (uint8 roulette_num = 0; roulette_num < 38; roulette_num++) {\r\n        Bet messed_up_bet = s.bets[msg.sender][roulette_num];\r\n        if (messed_up_bet.already_paid) {\r\n          throw;\r\n        }\r\n        if (messed_up_bet.amount > 0) {\r\n          msg.sender.send(messed_up_bet.amount * 36);\r\n          locked_funds_for_revealed_spins -= messed_up_bet.amount * 36;\r\n          messed_up_bet.already_paid = true;\r\n          at_least_one_number_paid = true;\r\n        }\r\n      }\r\n      if (!at_least_one_number_paid) {\r\n        // If at least one number does not get paid, we let the user know when they try to estimate gas.\r\n        throw;\r\n      }\r\n    } else {\r\n      Bet b = s.bets[msg.sender][s.spin_result];\r\n      if (b.already_paid || b.amount == 0) {\r\n        throw;\r\n      }\r\n      msg.sender.send(b.amount * 36);\r\n      locked_funds_for_revealed_spins -= b.amount * 36;\r\n      b.already_paid = true;\r\n    }\r\n  }\r\n\r\n  function player_declare_taking_too_long() noEther {\r\n    Spin first_unrevealed_spin = spins[spins.length - 2];\r\n    bool first_spin_too_long = first_unrevealed_spin.time_of_latest_reveal != 0\r\n        && now > first_unrevealed_spin.time_of_latest_reveal;\r\n    Spin second_unrevealed_spin = spins[spins.length - 1];\r\n    bool second_spin_too_long = second_unrevealed_spin.time_of_latest_reveal != 0\r\n        && now > second_unrevealed_spin.time_of_latest_reveal;\r\n    if (!(first_spin_too_long || second_spin_too_long)) {\r\n      throw;\r\n    }\r\n    first_unrevealed_spin.owner_took_too_long = true;\r\n    second_unrevealed_spin.owner_took_too_long = true;\r\n    locked_funds_for_revealed_spins += (first_unrevealed_spin.total_payout + second_unrevealed_spin.total_payout);\r\n  }\r\n\r\n  function () {\r\n    // Do not allow sending Ether without calling a function.\r\n    throw;\r\n  }\r\n\r\n  function commit(bytes32 commit_hash) internal {\r\n    uint spin_num = spins.length++;\r\n    Spin second_unrevealed_spin = spins[spins.length - 1];\r\n    second_unrevealed_spin.commit_hash = commit_hash;\r\n    max_bet_this_spin = (address(this).balance - reserved_funds()) / fraction;\r\n  }\r\n\r\n  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther {\r\n    Spin first_unrevealed_spin = spins[spins.length - 2];\r\n    if (!first_unrevealed_spin.owner_took_too_long) {\r\n      if (sha3(spin_result, nonce) != first_unrevealed_spin.commit_hash || spin_result > 37) {\r\n        throw;\r\n      }\r\n      first_unrevealed_spin.spin_result = spin_result;\r\n      first_unrevealed_spin.nonce = nonce;\r\n      locked_funds_for_revealed_spins += first_unrevealed_spin.total_bet_on_number[spin_result] * 36;\r\n      Revealed(spins.length - 2, spin_result);\r\n    }\r\n    // If owner took too long, the spin result and nonce can be ignored because all payers\r\n    // won.\r\n    commit(commit_hash);\r\n  }\r\n\r\n  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther {\r\n    if (new_time_limit > 2 weeks) {\r\n      // We don't want the owner to be able to set a time limit of something like 1000\r\n      // years.\r\n      throw;\r\n    }\r\n    owner_time_limit = new_time_limit;\r\n  }\r\n\r\n  function owner_deposit() onlyOwner etherRequired {}\r\n\r\n  function owner_withdraw(uint amount) onlyOwner noEther {\r\n    if (amount > address(this).balance - reserved_funds()) {\r\n      throw;\r\n    }\r\n    owner.send(amount);\r\n  }\r\n\r\n  function owner_set_fraction(uint _fraction) onlyOwner noEther {\r\n    if (_fraction == 0) {\r\n      throw;\r\n    }\r\n    fraction = _fraction;\r\n  }\r\n\r\n  function owner_transfer_ownership(address new_owner) onlyOwner noEther {\r\n    owner = new_owner;\r\n  }\r\n\r\n  function seconds_left() constant returns(int) {\r\n    // Seconds left until player_declare_taking_too_long can be called.\r\n    Spin s = spins[spins.length - 1];\r\n    if (s.time_of_latest_reveal == 0) {\r\n      return -1;\r\n    }\r\n    if (now > s.time_of_latest_reveal) {\r\n      return 0;\r\n    }\r\n    return int(s.time_of_latest_reveal - now);\r\n  }\r\n\r\n  function reserved_funds() constant returns (uint) {\r\n    // These funds cannot be withdrawn by the owner. This is the amount contract will have\r\n    // to keep in reserve to be able to pay all players in the worst case.\r\n    uint total = locked_funds_for_revealed_spins;\r\n    Spin first_unrevealed_spin = spins[spins.length - 2];\r\n    if (!first_unrevealed_spin.owner_took_too_long) {\r\n      total += first_unrevealed_spin.total_payout;\r\n    }\r\n    Spin second_unrevealed_spin = spins[spins.length - 1];\r\n    if (!second_unrevealed_spin.owner_took_too_long) {\r\n      total += second_unrevealed_spin.total_payout;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  function get_hash(uint8 number, bytes32 nonce) constant returns (bytes32) {\r\n    return sha3(number, nonce);\r\n  }\r\n\r\n  function bet_this_spin() constant returns (bool) {\r\n    // Returns true if there was a bet placed in the latest spin.\r\n    Spin s = spins[spins.length - 1];\r\n    return s.time_of_latest_reveal != 0;\r\n  }\r\n\r\n  function check_bet(uint spin_num, address player_addr, uint8 spin_result) constant returns (uint) {\r\n    // Returns the amount of ether a player player bet on a spin result in a given spin\r\n    // number.\r\n    Spin s = spins[spin_num];\r\n    Bet b = s.bets[player_addr][spin_result];\r\n    return b.amount;\r\n  }\r\n\r\n  function current_spin_number() constant returns (uint) {\r\n    // Returns the number of the current spin.\r\n    return spins.length - 1;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"owner_transfer_ownership\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"owner_set_fraction\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bet_this_spin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_spin_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserved_funds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"number\",\"type\":\"uint8\"},{\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"get_hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked_funds_for_revealed_spins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spins\",\"outputs\":[{\"name\":\"total_payout\",\"type\":\"uint256\"},{\"name\":\"commit_hash\",\"type\":\"bytes32\"},{\"name\":\"spin_result\",\"type\":\"uint8\"},{\"name\":\"nonce\",\"type\":\"bytes32\"},{\"name\":\"owner_took_too_long\",\"type\":\"bool\"},{\"name\":\"time_of_latest_reveal\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_time_limit\",\"type\":\"uint256\"}],\"name\":\"owner_set_time_limit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_bet_this_spin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_time_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spin_result\",\"type\":\"uint8\"},{\"name\":\"nonce\",\"type\":\"bytes32\"},{\"name\":\"commit_hash\",\"type\":\"bytes32\"}],\"name\":\"owner_reveal_and_commit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"player_declare_taking_too_long\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"owner_deposit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"owner_withdraw\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spin_num\",\"type\":\"uint256\"}],\"name\":\"player_collect_winnings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"spin_num\",\"type\":\"uint256\"},{\"name\":\"player_addr\",\"type\":\"address\"},{\"name\":\"spin_result\",\"type\":\"uint8\"}],\"name\":\"check_bet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spin_result\",\"type\":\"uint8\"}],\"name\":\"player_make_bet\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seconds_left\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"spin_result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"player_addr\",\"type\":\"address\"}],\"name\":\"MadeBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"spin_number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"spin_result\",\"type\":\"uint8\"}],\"name\":\"Revealed\",\"type\":\"event\"}]","ContractName":"EthereumRoulette","CompilerVersion":"v0.3.4-2016-06-06-e97ac4f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}