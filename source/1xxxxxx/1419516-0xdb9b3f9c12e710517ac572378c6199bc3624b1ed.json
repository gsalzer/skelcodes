{"status":"1","message":"OK","result":[{"SourceCode":"//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'         '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//   WHYSOS3RIOUS   PRESENTS :                          \r\n//                                                                \r\n//   MATCHING ETHERS                              \r\n//   a Strategy and Luck DaapGame          \r\n//   www.matching-ethers.com                 \r\n//\r\n//\r\n// *** coded by WhySoS3rious, 2016.                                       ***//\r\n// *** please do not copy without authorization                       ***//\r\n// *** contact : reddit    /u/WhySoS3rious                                ***//\r\n\r\n//VERSION : 1.0\r\n\r\n// GAME MODE : MATCHING FINNEYS\r\n// STAKE : 0.1 ETH\r\n\r\n contract Matching_Finneys\r\n{\r\n    enum State{Active, Deactivated}\r\n    State public state;\r\n\r\n    modifier onlyOwner() {\r\n\t    if (msg.sender!=owner) throw;\r\n\t    _\r\n    }\r\n    modifier onlyActive() {\r\n         if (state!=State.Active) throw;\r\n         _\r\n    }\r\n    modifier onlyInactive() {\r\n         if (state!=State.Deactivated) throw;\r\n         _\r\n    }\r\n    modifier equalGambleValue() {\r\n\tif (msg.value < gamble_value) throw;\r\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\r\n\t_\r\n    }\r\n    modifier resolvePendingRound{\r\n        blockLastPlayer=block.number+1;    \r\n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\r\n\telse if (pendingRound && blockLastPlayer==blockEndRound) throw;\r\n\t_\r\n    }\r\n\r\n    uint blockLastPlayer;\r\n    address private owner;\r\n    uint gamble_value;\r\n    uint information_cost;\r\n    uint round_max_size ;\r\n    uint round_min_size  ;  \r\n    uint index_player;\r\n    uint index_round_ended;\r\n    uint index_player_in_round;\r\n    bool pendingRound = false;\r\n    uint blockEndRound;\r\n    struct Gamble  {\r\n\t    address player;\r\n\t    bool flipped;\r\n    }\r\n    Gamble[] matchers; \r\n    Gamble[] contrarians;\r\n    struct Result  {\r\n\t    address player_matcher;\r\n\t    bool flipped_matcher;\r\n\t    uint256 payout_matcher;\r\n\t    address player_contrarian;\r\n\t    bool flipped_contrarian;\r\n\t    uint256 payout_contrarian;\r\n    }\r\n    Result[] results; \r\n    mapping (address => uint) payout_history;\r\n    mapping (address => uint) times_played_history;    \r\n     \r\n    //Contract Construtor\r\n    function Matching_Ethers() { //Initial settings\r\n\t    owner = msg.sender; \r\n\t    round_min_size = 16;\r\n\t    round_max_size = 20;\r\n\t    information_cost= 500 szabo; //0.005 ether, 5 finney\r\n            gamble_value = 100000 szabo; //0.1 ether\r\n    }\r\n    //FallBack Function (play by sending a transaction)\r\n    function () { \r\n        bool flipped;\r\n        if (msg.value == gamble_value) flipped=false; \r\n        if (msg.value > gamble_value) {\r\n            flipped=true;\r\n        }\r\n        Play(flipped); \r\n    }\r\n    //Play Function (play by contract function call)\r\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\r\n        if ( index_player_in_round%2==0 ) {   //first is matcher\r\n\t    matchers.push(Gamble(msg.sender, flipped));\r\n\t}\r\n\telse {\r\n\t    contrarians.push(Gamble(msg.sender, flipped));\r\n\t}\r\n        index_player+=1;\r\n        index_player_in_round+=1;\r\n\ttimes_played_history[msg.sender]+=1;\r\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\r\n\t            bool end = randomEnd();\r\n\t\t    if (end) {\r\n\t\t        pendingRound=true;\r\n\t\t\tblockEndRound=block.number;}\r\n        }\r\n    }\r\n    //Random Number Generator (between 1 and range)\r\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\r\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\r\n    }\r\n    //Function that determines randomly when the round should be ended\r\n    function randomEnd() private returns(bool) {\r\n\tif (index_player_in_round==round_max_size) return true; //end if max_size\r\n\telse{\r\n\t    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\r\n\t    if (random==1) return true;\r\n\t    else return false;\r\n\t    }\r\n    }\r\n    //Function to end Round and pay winners\r\n    function endRound() private {\r\n        delete results;\r\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\r\n        uint256 payout_total;\r\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\r\n            uint256 index_contrarian;\r\n\t    if (k+random_start_contrarian<(index_player_in_round)/2){\r\n\t        index_contrarian=k+random_start_contrarian;\r\n            }\r\n\t    else{\r\n\t        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\r\n\t    }\r\n\t    uint256 information_cost_matcher = information_cost * k;\r\n\t    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\r\n\t    uint256 information_cost_contrarian = information_cost * index_contrarian;\r\n\t    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\r\n\t    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\r\n\t    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\r\n\t        matchers[k].player.send(payout_matcher);\r\n\t\tpayout_total+=payout_matcher;\r\n\t\tpayout_history[matchers[k].player]+=payout_matcher;\r\n\t    }\r\n\t    else {\r\n\t        contrarians[index_contrarian].player.send(payout_contrarian);\r\n\t\tpayout_total+=payout_contrarian;\r\n\t\tpayout_history[contrarians[k].player]+=payout_contrarian;\r\n\t    }\r\n\t}\r\n        index_round_ended+=1;\r\n        owner.send(index_player_in_round*gamble_value-payout_total);\r\n\tpayout_total=0;\r\n        index_player_in_round=0;\r\n        delete matchers;\r\n        delete contrarians;\r\n\tpendingRound=false;\r\n\tif (terminate_after_round==true) state=State.Deactivated;\r\n    }\r\n    //Full Refund of Current Round (if needed)\r\n    function refundRound() \r\n    onlyActive\r\n    onlyOwner noEthSent{  \r\n        uint totalRefund;\r\n\tuint balanceBeforeRefund=this.balance;\r\n        for (var k = 0;  k< matchers.length; k++) {\r\n\t            matchers[k].player.send(gamble_value);\r\n\t\t    totalRefund+=gamble_value;\r\n        }\r\n        for (var j = 0;  j< contrarians.length ; j++) {\t\r\n\t            contrarians[j].player.send(gamble_value);\r\n\t\t    totalRefund+=gamble_value;\t\t    \r\n        }\r\n\tdelete matchers;\r\n\tdelete contrarians;\r\n\tstate=State.Deactivated;\r\n\tindex_player_in_round=0;\r\n        uint balanceLeft = balanceBeforeRefund-totalRefund;\r\n\tif (balanceLeft >0) owner.send(balanceLeft);\r\n    }\r\n    //Function Pause contract after next round (for new contract or to change settings) \r\n    bool terminate_after_round=false;\r\n    function deactivate()\r\n    onlyOwner noEthSent{\r\n\t    terminate_after_round=true;\r\n    }\r\n    //Function Reactivates contract (after change of settings for instance or a refound)\r\n    function reactivate()\r\n    onlyOwner noEthSent{\r\n        state=State.Active;\r\n        terminate_after_round=false;\r\n    }\r\n    //Function to change game settings (within limits)\r\n    //(to adapt to community feedback, popularity)\r\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\r\n\t    onlyOwner\r\n\t    onlyInactive noEthSent{\r\n\t    if (new_max_round<new_min_round) throw;\r\n\t    if (new_information_cost > new_gamble_value/100) throw;\r\n\t    round_max_size = new_max_round;\r\n\t    round_min_size = new_min_round;\r\n\t    information_cost= new_information_cost;\r\n\t    gamble_value = new_gamble_value;\r\n    }\r\n    function changeOwner(address new_owner)\r\n\t    onlyOwner noEthSent{\r\n\t    owner=new_owner;\r\n    }\r\n    \r\n\r\n    modifier noEthSent(){\r\n        if (msg.value>0) throw;\r\n\t_\r\n    }\r\n    //JSON GLOBAL STATS\r\n    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\r\n    {\r\n         number_of_player_in_round = index_player_in_round;\r\n\t total_number_of_player = index_player;\r\n\t number_of_round_ended = index_round_ended;\r\n\t pending_round_to_resolve = pendingRound;\r\n\t block_end_last_round = blockEndRound;\r\n\t block_last_player = blockLastPlayer;\r\n\t state = state;\r\n\t pause_contract_after_round = terminate_after_round;\r\n     }\r\n     //JSON CURRENT SETTINGS\r\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\r\n\t _gamble_value = gamble_value;\r\n\t _information_cost = information_cost;\r\n\t _round_min_size = round_min_size;\r\n\t _round_max_size = round_max_size;\r\n     }\r\n\r\n    //JSON MATCHER TEAM\r\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\r\n        _address=matchers[_index].player;\r\n\t_flipped = matchers[_index].flipped;\r\n    }\r\n    //JSON CONTRARIAN TEAM\r\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\r\n        _address=contrarians[_index].player;\r\n\t_flipped = contrarians[_index].flipped;\r\n    }\r\n    //JSON LAST ROUND RESULT\r\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\r\n        _address_matcher=results[_index].player_matcher;\r\n        _address_contrarian=results[_index].player_contrarian;\r\n\t_flipped_matcher = results[_index].flipped_matcher;\r\n\t_flipped_contrarian = results[_index].flipped_contrarian;\r\n\t_payout_matcher =  results[_index].payout_matcher;\r\n\t_payout_contrarian =  results[_index].payout_contrarian;\r\n    }\r\n    //User set nickname for the website\r\n     mapping (address => string) nicknames;\r\n     function setNickname(string name) noEthSent{\r\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\r\n             nicknames[msg.sender] = name;\r\n     }\r\n     function getNickname(address _address) noEthSent constant returns(string _name) {\r\n             _name = nicknames[_address];\r\n     }\r\n     //JSON HISTORY\r\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\r\n             _payout = payout_history[_address]; \r\n     }\r\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\r\n             _count = times_played_history[_address]; \r\n     }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"flipped\",\"type\":\"bool\"}],\"name\":\"Play\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setNickname\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getContrarians_by_index\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_flipped\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLastRoundResults_by_index\",\"outputs\":[{\"name\":\"_address_matcher\",\"type\":\"address\"},{\"name\":\"_address_contrarian\",\"type\":\"address\"},{\"name\":\"_flipped_matcher\",\"type\":\"bool\"},{\"name\":\"_flipped_contrarian\",\"type\":\"bool\"},{\"name\":\"_payout_matcher\",\"type\":\"uint256\"},{\"name\":\"_payout_contrarian\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Matching_Ethers\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundRound\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"historyPayout\",\"outputs\":[{\"name\":\"_payout\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getNickname\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameSettings\",\"outputs\":[{\"name\":\"_gamble_value\",\"type\":\"uint256\"},{\"name\":\"_information_cost\",\"type\":\"uint256\"},{\"name\":\"_round_min_size\",\"type\":\"uint256\"},{\"name\":\"_round_max_size\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_max_round\",\"type\":\"uint256\"},{\"name\":\"new_min_round\",\"type\":\"uint256\"},{\"name\":\"new_information_cost\",\"type\":\"uint256\"},{\"name\":\"new_gamble_value\",\"type\":\"uint256\"}],\"name\":\"config\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reactivate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameStats\",\"outputs\":[{\"name\":\"number_of_player_in_round\",\"type\":\"uint256\"},{\"name\":\"total_number_of_player\",\"type\":\"uint256\"},{\"name\":\"number_of_round_ended\",\"type\":\"uint256\"},{\"name\":\"pending_round_to_resolve\",\"type\":\"bool\"},{\"name\":\"block_end_last_round\",\"type\":\"uint256\"},{\"name\":\"block_last_player\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"pause_contract_after_round\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"historyTimesPlayed\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getMatchers_by_index\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_flipped\",\"type\":\"bool\"}],\"type\":\"function\"}]","ContractName":"Matching_Finneys","CompilerVersion":"v0.2.1-2016-02-03-fad2d4d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}