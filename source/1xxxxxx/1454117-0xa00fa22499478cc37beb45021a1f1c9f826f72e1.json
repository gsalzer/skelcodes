{"status":"1","message":"OK","result":[{"SourceCode":"contract Ambi {\r\n    function getNodeAddress(bytes32) constant returns (address);\r\n    function addNode(bytes32, address) external returns (bool);\r\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi ambiC;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            bool isNode = ambiContract.addNode(_name, address(this));\r\n            if (!isNode){\r\n                return false;\r\n            }   \r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function remove(){\r\n        if(msg.sender == address(ambiC)){\r\n            suicide(msg.sender);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ElcoinDb {\r\n    function getBalance(address addr) constant returns(uint balance);\r\n}\r\n\r\ncontract ElcoinInterface {\r\n    function rewardTo(address _to, uint _amount) returns (bool);\r\n}\r\n\r\ncontract PosRewards is AmbiEnabled {\r\n\r\n    event Reward(address indexed beneficiary, uint indexed cycle, uint value, uint position);\r\n\r\n    uint public cycleLength; // PoS will be ready to send each cycleLength seconds\r\n    uint public startTime;   // starting at startTime\r\n    uint public cycleLimit;  // and will stop after cycleLimit cycles pass\r\n    uint public minimalRewardedBalance; // but only those accounts having balance\r\n                             // >= minimalRewardedBalance will get reward\r\n    uint[] public bannedCycles;\r\n\r\n    enum RewardStatuses { Unsent, Sent, TooSmallToSend }\r\n\r\n    struct Account {\r\n        address recipient;\r\n        RewardStatuses status;\r\n    }\r\n\r\n    // cycleNumber => (address => minimalBalance)\r\n    mapping (uint => mapping (address => int)) public accountsBalances;\r\n    // cycleNumber => Account[]\r\n    mapping (uint => Account[]) public accountsUsed;\r\n\r\n    function PosRewards() {\r\n        cycleLength = 864000; // 864000 seconds = 10 days, 14400 = 4 hours\r\n        cycleLimit = 255; // that's 9 + 9 + 9 + 9 + 219, see getRate() for info\r\n        minimalRewardedBalance = 1000000; // 1 coin\r\n        startTime = now;\r\n    }\r\n\r\n    // USE THIS FUNCTION ONLY IN NEW CONTRACT, IT WILL CORRUPT ALREADY COLLECTED DATA!\r\n    // startTime should be set to the time when PoS starts (on Dec 17, probably block 705000 or so).\r\n    // It should be at 12:00 Moscow time, this would be the start of all PoS cycles.\r\n    function setStartTime(uint _startTime) checkAccess(\"owner\") {\r\n        startTime = _startTime;\r\n    }\r\n\r\n    // this allows to end PoS before 2550 days pass or to extend it further\r\n    function setCycleLimit(uint _cycleLimit) checkAccess(\"owner\") {\r\n        cycleLimit = _cycleLimit;\r\n    }\r\n\r\n    // this allows to disable PoS sending for some of the cycles in case we\r\n    // need to send custom PoS. This will be 100% used on first deploy.\r\n    function setBannedCycles(uint[] _cycles) checkAccess(\"owner\") {\r\n        bannedCycles = _cycles;\r\n    }\r\n\r\n    // set to 0 to reward everyone\r\n    function setMinimalRewardedBalance(uint _balance) checkAccess(\"owner\") {\r\n        minimalRewardedBalance = _balance;\r\n    }\r\n\r\n    function kill() checkAccess(\"owner\") {\r\n        suicide(msg.sender); // kills this contract and sends remaining funds back to msg.sender\r\n    }\r\n\r\n    // First 90 days 50% yearly\r\n    // Next 90 days 40%\r\n    // Next 90 days 30%\r\n    // Next 90 days 20%\r\n    // Next 2190 days 10%\r\n    function getRate(uint cycle) constant returns (uint) {\r\n        if (cycle <= 9) {\r\n            return 50;\r\n        }\r\n        if (cycle <= 18) {\r\n            return 40;\r\n        }\r\n        if (cycle <= 27) {\r\n            return 30;\r\n        }\r\n        if (cycle <= 35) { // not 36 because 36 is elDay\r\n            return 20;\r\n        }\r\n        if (cycle == 36) {\r\n            return 40;\r\n        }\r\n        if (cycle <= cycleLimit) {\r\n            if (cycle % 36 == 0) {\r\n                // Every 360th day, reward amounts double.\r\n                // The elDay lasts precisely 24 hours, and after that, reward amounts revert to their original values.\r\n                return 20;\r\n            }\r\n\r\n            return 10;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Cycle numeration starts from 1, 0 will be handled as not valid cycle\r\n    function currentCycle() constant returns (uint) {\r\n        if (startTime > now) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + ((now - startTime) / cycleLength);\r\n    }\r\n\r\n    function _isCycleValid(uint _cycle) constant internal returns (bool) {\r\n        if (_cycle >= currentCycle() || _cycle == 0) {\r\n            return false;\r\n        }\r\n        for (uint i; i<bannedCycles.length; i++) {\r\n            if (bannedCycles[i] == _cycle) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Returns how much Elcoin would be granted for user's minimal balance X in cycle Y\r\n    // The function is optimized to work with whole integer arithmetics\r\n    function getInterest(uint amount, uint cycle) constant returns (uint) {\r\n        return (amount * getRate(cycle)) / 3650;\r\n    }\r\n\r\n    // This function logs the balances after the transfer to be used in further calculations\r\n    function transfer(address _from, address _to) checkAccess(\"elcoin\") {\r\n        if (startTime == 0) {\r\n            return; // the easy way to disable PoS\r\n        }\r\n\r\n        _storeBalanceRecord(_from);\r\n        _storeBalanceRecord(_to);\r\n    }\r\n\r\n    function _storeBalanceRecord(address _addr) internal {\r\n        ElcoinDb db = ElcoinDb(getAddress(\"elcoinDb\"));\r\n        uint cycle = currentCycle();\r\n\r\n        if (cycle > cycleLimit) {\r\n            return;\r\n        }\r\n\r\n        int balance = int(db.getBalance(_addr));\r\n        bool accountNotUsedInCycle = (accountsBalances[cycle][_addr] == 0);\r\n\r\n        // We'll use -1 to mark accounts that have zero balance because\r\n        // mappings return 0 for unexisting records and there is no way to\r\n        // differ them without additional data structure\r\n        if (accountsBalances[cycle][_addr] != -1 && (accountNotUsedInCycle || accountsBalances[cycle][_addr] > balance)) {\r\n            if (balance == 0) {\r\n                balance = -1;\r\n            }\r\n            accountsBalances[cycle][_addr] = balance;\r\n\r\n            if (accountNotUsedInCycle) {\r\n                // do this only once for each account in each cycle\r\n                accountsUsed[cycle].push(Account(_addr, RewardStatuses.Unsent));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get minimal balance for address in some cycle\r\n    function getMinimalBalance(uint _cycle, address _addr) constant returns(int) {\r\n        int balance = accountsBalances[_cycle][_addr];\r\n        if (balance == -1) {\r\n            balance = 0;\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    // Get information from accountsUsed structure\r\n    function getAccountInfo(uint _cycle, uint _position) constant returns(address, RewardStatuses, int) {\r\n        return (\r\n            accountsUsed[_cycle][_position].recipient,\r\n            accountsUsed[_cycle][_position].status,\r\n            accountsBalances[_cycle][accountsUsed[_cycle][_position].recipient]\r\n          );\r\n    }\r\n\r\n    // Get information from accountsUsed structure\r\n    function getRewardsCount(uint _cycle) constant returns(uint) {\r\n        return accountsUsed[_cycle].length;\r\n    }\r\n\r\n    function sendReward(uint _cycle, uint _position) returns(bool) {\r\n        // Check that parameters are in valid ranges\r\n        if (!_isCycleValid(_cycle) || _position >= accountsUsed[_cycle].length) {\r\n            return false;\r\n        }\r\n\r\n        // Check that this reward was not sent\r\n        Account claimant = accountsUsed[_cycle][_position];\r\n        if (claimant.status != RewardStatuses.Unsent) {\r\n            return false;\r\n        }\r\n\r\n        // Check that this reward passes the conditions\r\n        int minimalAccountBalance = accountsBalances[_cycle][claimant.recipient];\r\n        if (minimalAccountBalance < int(minimalRewardedBalance)) {\r\n            claimant.status = RewardStatuses.TooSmallToSend;\r\n            return false;\r\n        }\r\n\r\n        uint rewardAmount = getInterest(uint(minimalAccountBalance), _cycle);\r\n\r\n        // We are ready to send the reward\r\n        ElcoinInterface elcoin = ElcoinInterface(getAddress(\"elcoin\"));\r\n        bool result = elcoin.rewardTo(claimant.recipient, rewardAmount);\r\n        if (result) {\r\n            Reward(claimant.recipient, _cycle, rewardAmount, _position);\r\n            claimant.status = RewardStatuses.Sent;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setMinimalRewardedBalance\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bannedCycles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsUsed\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getMinimalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cycles\",\"type\":\"uint256[]\"}],\"name\":\"setBannedCycles\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getRewardsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"},{\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"sendReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ambi\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"setAmbiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cycleLimit\",\"type\":\"uint256\"}],\"name\":\"setCycleLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"remove\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalRewardedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"},{\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"int256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"}]","ContractName":"PosRewards","CompilerVersion":"v0.3.2-2016-05-03-aa4dcbb","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}