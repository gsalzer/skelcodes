{"status":"1","message":"OK","result":[{"SourceCode":"// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        mint *= 10 ** _b;\r\n        return mint;\r\n    }\r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nBasic, standardized Token contract with no \"premine\". Defines the functions to\r\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\r\ncorresponding approval process. Tokens need to be created by a derived\r\ncontract (e.g. TokenCreation.sol).\r\n\r\nThank you ConsenSys, this contract originated from:\r\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\r\nWhich is itself based on the Ethereum standardized contract APIs:\r\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\r\n*/\r\n\r\n/// @title Standard Token Contract.\r\n\r\ncontract TokenInterface {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /// Total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    /// is approved by `_from`\r\n    /// @param _from The address of the origin of the transfer\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    /// its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _amount) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    /// to spend\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    ) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n    );\r\n}\r\n\r\n\r\ncontract Token is TokenInterface {\r\n    // Protects users by preventing the execution of method calls that\r\n    // inadvertently also transferred ether\r\n    modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _amount) internal returns (bool success) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n           return false;\r\n        }\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (bool success) {\r\n\r\n        if (balances[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0) {\r\n\r\n            balances[_to] += _amount;\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract KissBTCCallback {\r\n    function kissBTCCallback(uint id, uint amount);\r\n}\r\n\r\ncontract ApprovalRecipient {\r\n    function receiveApproval(address _from, uint256 _amount,\r\n                             address _tokenContract, bytes _extraData);\r\n}\r\n\r\ncontract KissBTC is usingOraclize, Token {\r\n    string constant PRICE_FEED =\r\n        \"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0\";\r\n    uint constant MAX_AMOUNT =\r\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint constant MAX_ETH_VALUE = 10 ether;\r\n    uint constant MIN_ETH_VALUE = 50 finney;\r\n    uint constant MAX_KISS_BTC_VALUE = 25000000;\r\n    uint constant MIN_KISS_BTC_VALUE = 125000;\r\n    uint constant DEFAULT_GAS_LIMIT = 200000;\r\n\r\n    string public standard = \"Token 0.1\";\r\n    string public name = \"kissBTC\";\r\n    string public symbol = \"kissBTC\";\r\n    uint8 public decimals = 8;\r\n\r\n    struct Task {\r\n        bytes32 oraclizeId;\r\n        bool toKissBTC;\r\n        address sender;\r\n        uint value;\r\n        address callback;\r\n        uint timestamp;\r\n    }\r\n\r\n    mapping (uint => Task) public tasks;\r\n    mapping (bytes32 => uint) public oraclizeRequests;\r\n    uint public exchangeRate;\r\n    uint public nextId = 1;\r\n\r\n    address public owner;\r\n    uint public timestamp;\r\n\r\n    modifier onlyowner { if (msg.sender == owner) _ }\r\n\r\n    function KissBTC() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // default action is to turn Ether into kissBTC\r\n    function () {\r\n        buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\r\n    }\r\n\r\n    function buyKissBTC() {\r\n        buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\r\n    }\r\n\r\n    function buyKissBTCWithCallback(address callback,\r\n                                    uint gasLimit) oraclizeAPI\r\n                                    returns (uint id) {\r\n        if (msg.value < MIN_ETH_VALUE || msg.value > MAX_ETH_VALUE) throw;\r\n        if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\r\n\r\n        uint oraclizePrice = oraclize.getPrice(\"URL\", gasLimit);\r\n        uint fee = msg.value / 100; // for the contract's coffers\r\n\r\n        if (msg.value <= oraclizePrice + fee) throw;\r\n        uint value = msg.value - (oraclizePrice + fee);\r\n\r\n        id = nextId++;\r\n        bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\r\n            0,\r\n            \"URL\",\r\n            PRICE_FEED,\r\n            gasLimit\r\n        );\r\n        tasks[id].oraclizeId = oraclizeId;\r\n        tasks[id].toKissBTC = true;\r\n        tasks[id].sender = msg.sender;\r\n        tasks[id].value = value;\r\n        tasks[id].callback = callback;\r\n        tasks[id].timestamp = now;\r\n        oraclizeRequests[oraclizeId] = id;\r\n    }\r\n\r\n    function transfer(address _to,\r\n                      uint256 _amount) noEther returns (bool success) {\r\n        if (_to == address(this)) {\r\n            sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\r\n            return true;\r\n        } else {\r\n            return _transfer(_to, _amount);    // standard transfer\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from,\r\n                          address _to,\r\n                          uint256 _amount) noEther returns (bool success) {\r\n        if (_to == address(this)) throw;       // not supported;\r\n        return _transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    function sellKissBTC(uint256 _amount) returns (uint id) {\r\n        return sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\r\n    }\r\n\r\n    function sellKissBTCWithCallback(uint256 _amount,\r\n                                     address callback,\r\n                                     uint gasLimit) oraclizeAPI\r\n                                     returns (uint id) {\r\n        if (_amount < MIN_KISS_BTC_VALUE\r\n            || _amount > MAX_KISS_BTC_VALUE) throw;\r\n        if (balances[msg.sender] < _amount) throw;\r\n        if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\r\n\r\n        if (!safeToSell(_amount)) throw;    // we need a bailout\r\n\r\n        uint oraclizePrice = oraclize.getPrice(\"URL\", gasLimit);\r\n        uint oraclizePriceKissBTC = inKissBTC(oraclizePrice);\r\n        uint fee = _amount / 100; // for the contract's coffers\r\n\r\n        if (_amount <= oraclizePriceKissBTC + fee) throw;\r\n        uint value = _amount - (oraclizePriceKissBTC + fee);\r\n\r\n        balances[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        Transfer(msg.sender, address(this), _amount);\r\n\r\n        id = nextId++;\r\n        bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\r\n            0,\r\n            \"URL\",\r\n            PRICE_FEED,\r\n            gasLimit\r\n        );\r\n        tasks[id].oraclizeId = oraclizeId;\r\n        tasks[id].toKissBTC = false;\r\n        tasks[id].sender = msg.sender;\r\n        tasks[id].value = value;\r\n        tasks[id].callback = callback;\r\n        tasks[id].timestamp = now;\r\n        oraclizeRequests[oraclizeId] = id;\r\n    }\r\n\r\n    function inKissBTC(uint amount) constant returns (uint) {\r\n        return (amount * exchangeRate) / 1000000000000000000;\r\n    }\r\n\r\n    function inEther(uint amount) constant returns (uint) {\r\n        return (amount * 1000000000000000000) / exchangeRate;\r\n    }\r\n\r\n    function safeToSell(uint amount) constant returns (bool) {\r\n        // Only allow sales when we have an extra 25 % in reserve.\r\n        return inEther(amount) * 125 < this.balance * 100;\r\n    }\r\n\r\n    function __callback(bytes32 oraclizeId, string result) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        uint _exchangeRate = parseInt(result, 6) * 100;\r\n        if (_exchangeRate > 0) {\r\n            exchangeRate = _exchangeRate;\r\n        }\r\n\r\n        uint id = oraclizeRequests[oraclizeId];\r\n        if (id == 0) return;\r\n\r\n        address sender = tasks[id].sender;\r\n        address callback = tasks[id].callback;\r\n        if (tasks[id].toKissBTC) {\r\n            uint freshKissBTC = inKissBTC(tasks[id].value);\r\n\r\n            totalSupply += freshKissBTC;\r\n            balances[sender] += freshKissBTC;\r\n            Transfer(address(this), sender, freshKissBTC);\r\n\r\n            if (callback != 0) {\r\n                // Note: If the callback throws an exception, everything\r\n                // will be rolled back and you won't receive any tokens.\r\n                // You can however invoke retryOraclizeRequest() in that case.\r\n                KissBTCCallback(callback).kissBTCCallback.\r\n                    value(0)(id, freshKissBTC);\r\n            }\r\n        } else {\r\n            uint releasedEther = inEther(tasks[id].value);\r\n\r\n            sender.send(releasedEther);\r\n\r\n            if (callback != 0) {\r\n                KissBTCCallback(callback).kissBTCCallback.\r\n                    value(0)(id, releasedEther);\r\n            }\r\n        }\r\n\r\n        delete oraclizeRequests[oraclizeId];\r\n        delete tasks[id];\r\n    }\r\n\r\n    function retryOraclizeRequest(uint id) oraclizeAPI {\r\n        if (tasks[id].oraclizeId == 0) throw;\r\n\r\n        uint timePassed = now - tasks[id].timestamp;\r\n        if (timePassed < 60 minutes) throw;\r\n\r\n        // Allow to retry a request to Oraclize if there has been\r\n        // no reply within the last hour for some reason. Because a\r\n        // failed callback might have been the problem, we discard those.\r\n        uint price = oraclize.getPrice(\"URL\", DEFAULT_GAS_LIMIT);\r\n        bytes32 newOraclizeId = oraclize.query_withGasLimit.value(price)(\r\n            0,\r\n            \"URL\",\r\n            PRICE_FEED,\r\n            DEFAULT_GAS_LIMIT\r\n        );\r\n\r\n        delete oraclizeRequests[tasks[id].oraclizeId];\r\n        tasks[id].oraclizeId = newOraclizeId;\r\n        tasks[id].callback = 0;\r\n        tasks[id].timestamp = now;\r\n        oraclizeRequests[newOraclizeId] = id;\r\n    }\r\n\r\n    function whitelist(address _spender) returns (bool success) {\r\n        return approve(_spender, MAX_AMOUNT);\r\n    }\r\n\r\n    function approveAndCall(address _spender,\r\n                            uint256 _amount,\r\n                            bytes _extraData) returns (bool success) {\r\n        approve(_spender, _amount);\r\n        ApprovalRecipient(_spender).receiveApproval.\r\n            value(0)(msg.sender, _amount, this, _extraData);\r\n        return true;\r\n    }\r\n\r\n    function donate() {\r\n        // Send ether here if you would like to\r\n        // increase the contract's reserves.\r\n    }\r\n\r\n    function toldYouItWouldWork() onlyowner {\r\n        if (now - timestamp < 24 hours) throw;  // only once a day\r\n\r\n        uint obligations = inEther(totalSupply);\r\n        if (this.balance <= obligations * 3) throw;\r\n\r\n        // Owner can withdraw 1 % of excess funds if the contract\r\n        // has more than three times its obligations in reserve.\r\n        uint excess = this.balance - (obligations * 3);\r\n        uint payment = excess / 100;\r\n        if (payment > 0) owner.send(payment);\r\n        timestamp = now;\r\n    }\r\n\r\n    function setOwner(address _owner) onlyowner {\r\n        owner = _owner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oraclizeRequests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"inEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oraclizeId\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellKissBTC\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"callback\",\"type\":\"address\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"sellKissBTCWithCallback\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"callback\",\"type\":\"address\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"buyKissBTCWithCallback\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"retryOraclizeRequest\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"name\":\"oraclizeId\",\"type\":\"bytes32\"},{\"name\":\"toKissBTC\",\"type\":\"bool\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"callback\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"inKissBTC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"safeToSell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyKissBTC\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toldYouItWouldWork\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"KissBTC","CompilerVersion":"v0.3.4-2016-05-31-7dab890","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}