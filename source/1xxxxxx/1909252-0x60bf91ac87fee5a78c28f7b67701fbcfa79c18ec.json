{"status":"1","message":"OK","result":[{"SourceCode":"// This software is a subject to Ambisafe License Agreement.\r\n// No use or distribution is allowed without written permission from Ambisafe.\r\n// https://ambisafe.com/terms.pdf\r\n\r\ncontract Ambi {\r\n    function getNodeAddress(bytes32 _nodeName) constant returns(address);\r\n    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\r\n    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi public ambiC;\r\n    bool public isImmortal;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) constant returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            if (!ambiContract.addNode(_name, address(this))){\r\n                return false;\r\n            }\r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function immortality() checkAccess(\"owner\") returns(bool) {\r\n        isImmortal = true;\r\n        return true;\r\n    }\r\n\r\n    function remove() checkAccess(\"owner\") returns(bool) {\r\n        if (isImmortal) {\r\n            return false;\r\n        }\r\n        selfdestruct(msg.sender);\r\n        return true;\r\n    }\r\n}\r\n\r\nlibrary StackDepthLib {\r\n    // This will probably work with a value of 390 but no need to cut it\r\n    // that close in the case that the optimizer changes slightly or\r\n    // something causing that number to rise slightly.\r\n    uint constant GAS_PER_DEPTH = 400;\r\n\r\n    function checkDepth(address self, uint n) constant returns(bool) {\r\n        if (n == 0) return true;\r\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\r\n    }\r\n\r\n    function __dig(uint n) constant {\r\n        if (n == 0) return;\r\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\r\n    }\r\n}\r\n\r\ncontract Safe {\r\n    // Should always be placed as first modifier!\r\n    modifier noValue {\r\n        if (msg.value > 0) {\r\n            // Internal Out Of Gas/Throw: revert this transaction too;\r\n            // Call Stack Depth Limit reached: revert this transaction too;\r\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\r\n            _safeSend(msg.sender, msg.value);\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier onlyHuman {\r\n        if (_isHuman()) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier noCallback {\r\n        if (!isCall) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier immutable(address _address) {\r\n        if (_address == 0) {\r\n            _\r\n        }\r\n    }\r\n\r\n    address stackDepthLib;\r\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\r\n        stackDepthLib = _stackDepthLib;\r\n        return true;\r\n    }\r\n\r\n    modifier requireStackDepth(uint16 _depth) {\r\n        if (stackDepthLib == 0x0) {\r\n            throw;\r\n        }\r\n        if (_depth > 1023) {\r\n            throw;\r\n        }\r\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    // Must not be used inside the functions that have noValue() modifier!\r\n    function _safeFalse() internal noValue() returns(bool) {\r\n        return false;\r\n    }\r\n\r\n    function _safeSend(address _to, uint _value) internal {\r\n        if (!_unsafeSend(_to, _value)) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\r\n        return _to.call.value(_value)();\r\n    }\r\n\r\n    function _isContract() constant internal returns(bool) {\r\n        return msg.sender != tx.origin;\r\n    }\r\n\r\n    function _isHuman() constant internal returns(bool) {\r\n        return !_isContract();\r\n    }\r\n\r\n    bool private isCall = false;\r\n    function _setupNoCallback() internal {\r\n        isCall = true;\r\n    }\r\n\r\n    function _finishNoCallback() internal {\r\n        isCall = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Events History universal contract.\r\n *\r\n * Contract serves as an Events storage and version history for a particular contract type.\r\n * Events appear on this contract address but their definitions provided by other contracts/libraries.\r\n * Version info is provided for historical and informational purposes.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract EventsHistory is AmbiEnabled, Safe {\r\n    // Event emitter signature to address with Event definiton mapping.\r\n    mapping(bytes4 => address) public emitters;\r\n\r\n    // Calling contract address to version mapping.\r\n    mapping(address => uint) public versions;\r\n\r\n    // Version to info mapping.\r\n    mapping(uint => VersionInfo) public versionInfo;\r\n\r\n    // Latest verion number.\r\n    uint public latestVersion;\r\n\r\n    struct VersionInfo {\r\n        uint block;        // Block number in which version has been introduced.\r\n        address by;        // Contract owner address who added version.\r\n        address caller;    // Address of this version calling contract.\r\n        string name;       // Version name, informative.\r\n        string changelog;  // Version changelog, informative.\r\n    }\r\n\r\n    /**\r\n     * Assign emitter address to a specified emit function signature.\r\n     *\r\n     * Can be set only once for each signature, and only by contract owner.\r\n     * Caller contract should be sure that emitter for a particular signature will never change.\r\n     *\r\n     * @param _eventSignature signature of the event emitting function.\r\n     * @param _emitter address with Event definition.\r\n     *\r\n     * @return success.\r\n     */\r\n    function addEmitter(bytes4 _eventSignature, address _emitter) noValue() checkAccess(\"admin\") returns(bool) {\r\n        if (emitters[_eventSignature] != 0x0) {\r\n            return false;\r\n        }\r\n        emitters[_eventSignature] = _emitter;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Introduce new caller contract version specifing version information.\r\n     *\r\n     * Can be set only once for each caller, and only by contract owner.\r\n     * Name and changelog should not be empty.\r\n     *\r\n     * @param _caller address of the new caller.\r\n     * @param _name version name.\r\n     * @param _changelog version changelog.\r\n     *\r\n     * @return success.\r\n     */\r\n    function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(\"admin\") returns(bool) {\r\n        if (versions[_caller] != 0) {\r\n            return false;\r\n        }\r\n        if (bytes(_name).length == 0) {\r\n            return false;\r\n        }\r\n        if (bytes(_changelog).length == 0) {\r\n            return false;\r\n        }\r\n        uint version = ++latestVersion;\r\n        versions[_caller] = version;\r\n        versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Event emitting fallback.\r\n     *\r\n     * Can be and only called caller with assigned version.\r\n     * Resolves msg.sig to an emitter address, and calls it to emit an event.\r\n     *\r\n     * Throws if emit function signature is not registered, or call failed.\r\n     */\r\n    function () noValue() {\r\n        if (versions[msg.sender] == 0) {\r\n            return;\r\n        }\r\n        // Internal Out Of Gas/Throw: revert this transaction too;\r\n        // Call Stack Depth Limit reached: revert this transaction too;\r\n        // Recursive Call: safe, all changes already made.\r\n        if (!emitters[msg.sig].delegatecall(msg.data)) {\r\n            throw;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stackDepthLib\",\"type\":\"address\"}],\"name\":\"setupStackDepthLib\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eventSignature\",\"type\":\"bytes4\"},{\"name\":\"_emitter\",\"type\":\"address\"}],\"name\":\"addEmitter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"versions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ambiC\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_caller\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_changelog\",\"type\":\"string\"}],\"name\":\"addVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isImmortal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ambi\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"setAmbiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"versionInfo\",\"outputs\":[{\"name\":\"block\",\"type\":\"uint256\"},{\"name\":\"by\",\"type\":\"address\"},{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"changelog\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"remove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"emitters\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"immortality\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"}]","ContractName":"EventsHistory","CompilerVersion":"v0.3.5-nightly.2016.7.1+commit.48238c9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}