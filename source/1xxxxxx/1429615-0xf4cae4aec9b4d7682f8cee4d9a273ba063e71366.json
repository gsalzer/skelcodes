{"status":"1","message":"OK","result":[{"SourceCode":"contract EtherTopDog {\r\n\r\n\t// fund for bailing out underdogs when they are pushed out\r\n\tuint private bailoutBalance = 0;\r\n\r\n\r\n\t// === Underdog Payin Distribution: ===\r\n\t\r\n\t// percent of underdog deposit amount to go in bailout fund\r\n\tuint constant private bailoutFundPercent = 70;\r\n\r\n\t// percent of underdog deposit that goes to the top dog's dividend\r\n\tuint constant private topDogDividend = 15;\r\n\r\n\t// percent of underdog deposit sent chip away top dog's strength\r\n\tuint constant private topDogDecayPercent = 10;\r\n\r\n\t// percent of underdog deposiot that goes to lucky dog's dividend\r\n\tuint constant private luckyDogDividend = 3;\r\n\r\n\t// vision dog takes a small fee from each underdog deposit\r\n\tuint constant private visionDogFeePercent = 2;\r\n\r\n\t// === === === === === === === === ===\r\n\r\n\t\r\n\t// percentage markup from payin for calculating new mininum TopDog price threshold\r\n\tuint constant private topDogMinMarkup = 125;\r\n\r\n\t// minimum required deposit to become the next Top Dog\r\n\t// (aka Top Dog strength / lowest possible takeover threshold)\r\n\t// starts at 125% of Top Dog's deposit, slowly declines as underdogs join\r\n\tuint private topDogMinPrice = 1;\r\n\r\n\t// range above the topdog strength (aka topDogMinPrice) within which\r\n\t// the randomly generated required takeover threhold is set\r\n\tuint constant private topDogBuyoutRange = 150;\r\n\r\n\t// percentage of topdog buyout fee gets paid to creator\r\n\tuint constant private visionDogBuyPercent = 5;\r\n\r\n\r\n\r\n\t// underdog payout markup, as a percentage of their deposits\r\n\t// gets reset to 150% after each round when the top dog gets replaced\r\n\t// gradually decays to mininum of 120% as underdogs chip away at top dog's strength\r\n\tuint private underDogMarkup = 150;\r\n\r\n\t// as top dog price declines, these keep track of the range\r\n\t// so underDopMarkup can slowly go from 150% to 120% return\r\n\t// as the Top Dog mininum price starts at the price ceiling,\r\n\t// and declines until it reaches the floor (or lower)\r\n\tuint private topDogPriceCeiling = 0;\r\n\tuint private topDogPriceFloor = 0;\r\n\r\n\t// total collected fees from underdogs, paid out whenever Top Dog is bought out\r\n\tuint private visionFees = 0;\r\n\r\n\t// current top dog\r\n\taddress private topDog = 0x0;\r\n\r\n\t// underdog entries\r\n\tstruct Underdog {\r\n\t\taddress addr;\r\n\t\tuint deposit;\r\n\t\tuint payout;\r\n\t\tuint bailouts;\r\n\t}\r\n\tUnderdog[] private Underdogs;\r\n\r\n\t// player names for fun\r\n\tmapping (address => string) dogNames;\r\n\r\n\t// current lucky dog (if exists) will receive 3% of underdog payins\r\n\t// specified as index in Underdogs array\r\n\t// 0 = nobody (the very first underdog to join the game is precluded from becoming the Lucky Dog)\r\n\tuint private luckyDog = 0;\r\n\r\n\t// index of next underdog to be paid \r\n\tuint private payoutIndex = 0;\r\n\r\n\t// count payouts made by underdogs currently in the game\r\n\t// so we can have a baseline for dividing the scraps\r\n\tuint private payoutCount = 0;\r\n\r\n\t// address of the creator\r\n\taddress private visionDog;\r\n\r\n\tfunction EtherTopDog() {\r\n\t\tvisionDog = msg.sender;\r\n\t}\r\n\r\n\r\n\t// ==== Game Info Display ABI functions: ====\r\n\tfunction underdogPayoutFund() public constant returns (uint balance) {\r\n\t\tbalance = bailoutBalance;\r\n\t}\r\n\r\n\tfunction nextUnderdogPayout() public constant returns (uint) {\r\n\t\tif (Underdogs.length - payoutIndex >= 1) {\r\n\t\t\treturn Underdogs[payoutIndex].payout;\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tfunction underdogPayoutMarkup() public constant returns (uint) {\r\n\t\treturn underDogMarkup;\r\n\t}\r\n\r\n\tfunction topDogInfo() public constant returns (string name, uint strength) {\r\n\t\tif (topDog != address(0x0)) {\r\n\t\t\tname = getDogName(topDog);\r\n\t\t} else {\r\n\t\t\tname = \"[not set]\";\r\n\t\t}\r\n\t\tstrength = topDogMinPrice;\r\n\t}\r\n\tfunction luckyDogInfo() public constant returns (string name) {\r\n\t\tif (luckyDog > 0) {\r\n\t\t\tname = getDogName(Underdogs[luckyDog].addr);\r\n\t\t} else {\r\n\t\t\tname = \"[nobody]\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction underdogCount() constant returns (uint) {\r\n\t\treturn Underdogs.length - payoutIndex;\r\n\t} \r\n\r\n\tfunction underdogInfo(uint linePosition) constant returns (string name, address dogAddress, uint deposit, uint payout, uint scrapBonus) {\r\n\t\tif (linePosition > 0 && linePosition <= Underdogs.length - payoutIndex) {\r\n\r\n\t\t\tUnderdog thedog = Underdogs[payoutIndex + (linePosition - 1)];\r\n\t\t\tname = getDogName(thedog.addr);\r\n\t\t\tdogAddress = thedog.addr;\r\n\t\t\tdeposit = thedog.deposit;\r\n\t\t\tpayout= thedog.payout;\r\n\t\t\tscrapBonus = thedog.bailouts;\r\n\t\t}\r\n\t}\r\n\r\n\t// ==== End ABI Functions ====\r\n\r\n\r\n\r\n\t// ==== Public transaction functions: ====\r\n\r\n\t// default fallback : play a round\r\n\tfunction() {\r\n\t\tdogFight();\r\n\t}\r\n\t\r\n\t// sets name, optionally plays a round if Ether was sent\r\n\tfunction setName(string DogName) {\r\n\t\tif (bytes(DogName).length >= 2 && bytes(DogName).length <= 16)\r\n\t\t\tdogNames[msg.sender] = DogName;\r\n\r\n\t\t// if a deposit was sent, play it!\r\n\t\tif (msg.value > 0) {\r\n\t\t\tdogFight();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tfunction dogFight() public {\r\n\t\t// minimum 1 ETH required to play\r\n\t\tif (msg.value < 1 ether) {\r\n\t\t\tmsg.sender.send(msg.value);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// does a topdog exist ?\r\n\t\tif (topDog != address(0x0)) {\r\n\r\n\t\t\t// the actual amount required to knock out the top dig is random within the buyout range\r\n\t\t\tuint topDogPrice = topDogMinPrice + randInt( (topDogMinPrice * topDogBuyoutRange / 100) - topDogMinPrice, 4321);\r\n\r\n\t\t\t// Calculate the top dog price\r\n\t\t\tif (msg.value >= topDogPrice) {\r\n\t\t\t\t// They bought out the top dog!\r\n\t\t\t\tbuyTopDog(topDogPrice, msg.value - topDogPrice);\r\n\t\t\t} else {\r\n\t\t\t\t// didn't buy the top dog, this participant becomes an underdog!\r\n\t\t\t\taddUnderDog(msg.value);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// no top dog exists yet, the game must be just getting started\r\n\t\t\t// put the first deposit in the bailout fund, initialize the game\r\n\r\n\t\t\t// set first topDog \r\n\t\t\ttopDog = msg.sender;\r\n\r\n\t\t\ttopDogPriceFloor = topDogMinPrice;\r\n\r\n\t\t\tbailoutBalance += msg.value;\r\n\t\t\ttopDogMinPrice = msg.value * topDogMinMarkup / 100;\r\n\r\n\t\t\ttopDogPriceCeiling = topDogMinPrice;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// ==== End Public Functions ====\r\n\r\n\r\n\r\n\t// ==== Private Functions: ====\r\n\tfunction addUnderDog(uint buyin) private {\r\n\r\n\t\tuint bailcount = 0;\r\n\r\n\t\t// amount this depositor will be paid when the fund allows\r\n\t\tuint payoutval = buyin * underDogMarkup / 100;\r\n\r\n\t\t// add portion of deposit to bailout fund \r\n\t\tbailoutBalance += buyin * bailoutFundPercent / 100;\r\n\r\n\t\t// top dog / lucky dog dividends\r\n\t\tuint topdividend = buyin * topDogDividend / 100;\r\n\t\tuint luckydividend = buyin * luckyDogDividend / 100;\r\n\r\n\t\t// is there a lucky dog?\r\n\t\tif (luckyDog != 0 && luckyDog >= payoutIndex) {\r\n\t\t\t// pay lucky dog dividends\r\n\t\t\tUnderdogs[luckyDog].addr.send(luckydividend);\r\n\t\t} else {\r\n\t\t\t// no lucky dog exists, all dividends go to top dog\r\n\t\t\ttopdividend += luckydividend;\r\n\t\t}\r\n\r\n\t\t// pay top dog dividends\r\n\t\ttopDog.send(topdividend);\r\n\r\n\r\n\t\t// chip away at the top dog's strength\r\n\t\tuint topdecay = (buyin * topDogDecayPercent / 100);\r\n\t\ttopDogMinPrice -= topdecay;\r\n\r\n\t\t// update underdog markup % for next round\r\n\r\n\t\t// specified as n/100000 to avoid floating point math\r\n\t\tuint decayfactor = 0;\r\n\r\n\t\t// calculate the payout markup for next underdog\r\n\t\tif (topDogMinPrice > topDogPriceFloor) {\r\n\t\t\tuint decayrange = (topDogPriceCeiling - topDogPriceFloor);\r\n\t\t\tdecayfactor = 100000 * (topDogPriceCeiling - topDogMinPrice) / decayrange;\r\n\t\t} else {\r\n\t\t\tdecayfactor = 100000;\r\n\t\t}\r\n\t\t// markup will be between 120-150% corresponding to current top dog price decline (150% - 30% = 120%)\r\n\t\tunderDogMarkup = 150 - (decayfactor * 30 / 100000);\r\n\r\n\r\n\r\n\t\t// creator takes a slice\r\n\t\tvisionFees += (buyin * visionDogFeePercent / 100);\r\n\t\t\r\n\r\n\t\t// payout as many previous underdogs as the fund can afford\r\n\t\twhile (payoutIndex < Underdogs.length && bailoutBalance >= Underdogs[payoutIndex].payout ) {\r\n\t\t\tpayoutCount -= Underdogs[payoutIndex].bailouts;\r\n\t\t\tbailoutBalance -= Underdogs[payoutIndex].payout;\r\n\t\t\tUnderdogs[payoutIndex].addr.send(Underdogs[payoutIndex].payout);\r\n\r\n\r\n\t\t\t// if the lucky dog was bailed out, the user who did it now becomes the lucky dog\r\n\t\t\tif (payoutIndex == luckyDog && luckyDog != 0)\r\n\t\t\t\tluckyDog = Underdogs.length;\r\n\r\n\t\t\tpayoutIndex++;\r\n\t\t\tbailcount++;\r\n\t\t\tpayoutCount++;\r\n\t\t}\r\n\r\n\t\t\r\n\t\t// add the new underdog to the queue\r\n\t\tUnderdogs.push(Underdog(msg.sender, buyin, payoutval, bailcount));\r\n\r\n\t}\r\n\r\n\tfunction buyTopDog(uint buyprice, uint surplus) private {\r\n\r\n\t\t// take out vizionDog fee\r\n\t\tuint vfee = buyprice * visionDogBuyPercent / 100;\r\n\r\n\t\tuint dogpayoff = (buyprice - vfee);\r\n\r\n\t\t// payout previous top dog\r\n\t\ttopDog.send(dogpayoff);\r\n\r\n\t\tvisionFees += vfee;\r\n\r\n\t\t// send buy fee (plus previous collected underdog fees) to visionDog\r\n\t\tvisionDog.send(visionFees);\r\n\t\tvisionFees = 0;\r\n\r\n\t\t// record a price floor for underdog markup decay calculation during the next round:\r\n\t\t// the mininum purchase price before buyout\r\n\t\ttopDogPriceFloor = topDogMinPrice;\r\n\r\n\t\t// set the initial minimum buy price for the next top dog\r\n\t\ttopDogMinPrice = msg.value * topDogMinMarkup / 100;\r\n\r\n\t\t// the price ceiling for calculating the underdog markup decay is the new minimum price\r\n\t\ttopDogPriceCeiling = topDogMinPrice;\r\n\r\n\r\n\t\t// check for eligible lucky dog...\r\n//\t\tif (Underdogs.length - payoutIndex > 0) {\r\n\t\t\t// lucky dog is most recent underdog to make an entry\r\n//\t\t\tluckyDog = Underdogs.length - 1;\r\n//\t\t} else {\r\n\t\t\t// no dogs waiting in line?  all dividends will go to top dog this round\r\n//\t\t\tluckyDog = 0;\r\n//\t\t}\r\n\t\t\r\n\r\n\t\t// reset underdog markup for next round\r\n\t\tunderDogMarkup = 150;\r\n\r\n\t\t// how many dogs are waiting?\r\n\t\tuint linelength = Underdogs.length - payoutIndex;\r\n\r\n\t\t// surplus goes to pay scraps to random underdogs\r\n\t\t// calculate and pay scraps\r\n\r\n\r\n\t\t// are there underdogs around to receive the scraps?\r\n\t\tif (surplus > 0 && linelength > 0 ) {\r\n\t\t\tthrowScraps(surplus);\r\n\t\t}\r\n\r\n\r\n\t\t// if there are any underdogs in line, the lucky dog will be picked from among them\t\r\n\t\tif (linelength > 0) {\r\n\r\n\t\t\t// randomly pick a new lucky dog, with luck weighted toward more recent entries\r\n\r\n\t\t\t// weighting works like this:\r\n\t\t\t// \tFor example, if the line length is 6, the most recent entry will\r\n\t\t\t//\tbe 6 times more likely than the oldest (6/21 odds),\r\n\t\t\t//\tthe second most recent will be 5 times more likely than the oldest (5/21 odds)\r\n\t\t\t//\tthe third most recent will be 4 times as likely as the oldest (4/21 odds),\r\n\t\t\t//\tetc...\r\n\r\n\t\t\t//\tof course, the player that has been in line longest is\r\n\t\t\t//\tleast likely to be lucky (1/21 odds in this example)\r\n\t\t\t//\tand will be getting sent out of the game soonest anyway\r\n\r\n\t\t\tuint luckypickline = (linelength % 2 == 1) ?\r\n\t\t\t\t( linelength / 2 + 1 ) + (linelength + 1) * (linelength / 2) :  // odd\r\n\t\t\t\t( (linelength + 1) * (linelength / 2)  ); // even\r\n\r\n\t\t\tuint luckypick = randInt(luckypickline, 69);\r\n\t\r\n\t\t\tuint pickpos = luckypickline - linelength;\r\n\t\t\tuint linepos = 1;\r\n\r\n\t\t\twhile (pickpos >= luckypick && linepos < linelength) {\r\n\t\t\t\tpickpos -= (linelength - linepos);\r\n\t\t\t\tlinepos++;\r\n\t\t\t}\r\n\r\n\t\t\tluckyDog = Underdogs.length - linepos;\r\n\t\t} else {\r\n\t\t\t// no underdogs in line?  no lucky dog this round.\r\n\t\t\t// (should only possibly happen when game starts)\r\n\t\t\tluckyDog = 0;\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// the new top dog is crowned!\r\n\t\ttopDog = msg.sender;\r\n\t}\r\n\r\n\tfunction throwScraps(uint totalscrapvalue) private {\r\n\r\n\t\t// how many dogs are waiting?\r\n\t\tuint linelength = Underdogs.length - payoutIndex;\r\n\r\n\t\t// to keep from having too many transactions, make sure we never have more than 7 scraps.\r\n\t\t// the more dogs in line, the more we jump over when scraps get scattered\r\n\t\tuint skipstep = (linelength / 7) + 1;\r\n\r\n\t\t// how many pieces to divide (roughly, randomization might make it more or less)\r\n\t\tuint pieces = linelength / skipstep;\r\n\r\n\t\t// how far from the end of the queue to start throwing the first scrap (semi-random)\r\n\t\tuint startoffset = randInt(skipstep, 42) - 1;\r\n\r\n\t\t// base size for scraps...  \r\n\t\tuint scrapbasesize = totalscrapvalue / (pieces + payoutCount);\r\n\r\n\t\t// minimum base scrap size of 0.5 eth\r\n\t\tif (scrapbasesize < 500 finney) {\r\n\t\t\tscrapbasesize = 500 finney;\r\n\t\t}\r\n\r\n\t\tuint scrapsize;\r\n\t\tuint sptr = Underdogs.length - 1 - startoffset;\r\n\r\n\t\tuint scrapvalueleft = totalscrapvalue;\r\n\r\n\t\twhile (pieces > 0 && scrapvalueleft > 0 && sptr >= payoutIndex) {\r\n\t\t\t// those who bailed out other dogs get bigger scraps\r\n\t\t\t// size of the scrap is multiplied by # of other dogs the user bailed out\r\n\t\t\tscrapsize = scrapbasesize * (Underdogs[sptr].bailouts + 1);\r\n\r\n\r\n\t\t\t// scraps can never be more than what's in the pile\r\n\t\t\tif (scrapsize < scrapvalueleft) {\r\n\t\t\t\tscrapvalueleft -= scrapsize;\r\n\t\t\t} else {\r\n\t\t\t\tscrapsize = scrapvalueleft;\r\n\t\t\t\tscrapvalueleft = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// pay it\r\n\t\t\tUnderdogs[sptr].addr.send(scrapsize);\r\n\t\t\tpieces--;\r\n\t\t\tsptr -= skipstep;\r\n\t\t}\r\n\r\n\t\t// any scraps left uncaught? put them in the bailout fund for the underdogs\r\n\t\tif (scrapvalueleft > 0) {\r\n\t\t\tbailoutBalance += scrapvalueleft;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getDogName(address adr) private constant returns (string thename) {\r\n\t\tif (bytes(dogNames[adr]).length > 0)\r\n\t\t\tthename = dogNames[adr];\r\n\t\telse\r\n\t\t\tthename = 'Unnamed Mutt';\r\n\t}\r\n\t\r\n\t// Generate pseudo semi-random number between 1 - max \r\n\tfunction randInt(uint max, uint seedswitch) private constant returns (uint randomNumber) {\r\n\t\treturn( uint(sha3(block.blockhash(block.number-1), block.timestamp + seedswitch) ) % max + 1 );\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"luckyDogInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underdogPayoutMarkup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topDogInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"strength\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"linePosition\",\"type\":\"uint256\"}],\"name\":\"underdogInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"dogAddress\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"scrapBonus\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underdogPayoutFund\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextUnderdogPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"DogName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dogFight\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underdogCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"EtherTopDog","CompilerVersion":"v0.3.1-2016-04-12-3ad5e82","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}