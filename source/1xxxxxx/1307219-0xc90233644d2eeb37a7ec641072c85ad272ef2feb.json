{"status":"1","message":"OK","result":[{"SourceCode":"// ALPHA 0.1.0 General Purpose Profit Splitter\r\n\r\n// INSERT ANYTHING ABOVE 1 FINNEY TO BE A CONTRIBUTOR.\r\n// TO INSERT PROFIT, SEND 1 FINNEY TO THIS CONTRACT FIRST!\r\n// THEN YOU HAVE TO SEND THE PROFIT DIRECTLY AFTER - IN 1 TRANSACTION - WITH THE SAME ADDRESS!\r\n\r\n// NO COPYRIGHT, NO FEES, NO OWNER (Only an owner in beta)\r\n// COPY THIS CODE ALL YOU WANT (not my responsibility)\r\n\r\n// IF YOU'RE INEXPERIENCED IN CODING, BUT WILLING TO LEARN. I'LL TRY TO DESCRIBE EVERYTHING THE BEST I CAN!\r\n// I'M AN INEXPERIENCED CODER MYSELF.\r\n// YOU CAN TELL, BECAUSE I HAVE NO IDEA HOW VERSION NUMBERS WORK.\r\n\r\ncontract GeneralPurposeProfitSplitter {         // Title of the contract, you have to give it a name.\r\n\r\n    struct Contributor {                        // this will make a database of contributors, the address, contribution and profits are saved.\r\n        address addr;                           // this is the contributors address\r\n        uint index;                             // where does the contributor stand in the database index?\r\n        uint contribution;                      // how much the contributor has contributed in the contract\r\n        uint profit;                            // how much profit the contributor has made, because of the contribution\r\n        uint total;                             // how much does this contributor have in total?\r\n        uint lastContribution;                  // how much did the contributor contribute last time?\r\n        uint lastProfit;                        // how much was the last profit amount?\r\n        uint lastProfitShare;                   // how much share did the contributor have last time profit was distrebuted?\r\n        uint lastPayout;                        // how much did the contributor pay out the last time?\r\n        string error;                           // If there is something wrong you will know\r\n    }\r\n    \r\n    Contributor[] public contributors;          // use contributors[index of contributor].addr/contribution/profit. to get data from that contributor.\r\n    uint contributorFound = 0;                  // if a contributor is found this value turns into an index number later on\r\n    uint contributorTotal = 0;                  // this is a contributors contribution + profits\r\n    uint contributorShare = 0;                  // this is how much that total is in comparison with all contributions\r\n    uint public contributorsIndex = 0;          // this counts how many contributors are in the contract.\r\n    \r\n    uint public totalContributorsContribution = 0;    // this counts how much contribution in total is in the contract.\r\n    uint public totalContributorsProfit = 0;    // this counts how much profits in total is still in the contract.\r\n    uint totalContributorsTotal = 0;            // counts up all the contribution and all the profits now in contract.\r\n    address public beta;                        // Only ME can decide to give all the contributions and profit back to the contributors. LAST RESORT or SCHEDULED!\r\n    address public nextInputProfit;             // IF you inserted 1 finney in the contract first, THEN that address will be saved for the next contract execution.\r\n    \r\n    uint i = 0;                                 // the i gets used to find a contributor for certain functions\r\n    uint correctProfit = 0;                     // Because i take 1 finney away for recognition, I will have to add one later.\r\n    \r\n    function GeneralPurposeProfitSplitter() {   // without this, mist browser doesn't know how to deploy this contract, as far as I know\r\n        beta = msg.sender;                      // I am the beta-address so I can give ether back if everything goes wrong\r\n    }                                           // ADD two lines of code empty between functions. I don't know why, but I read it somewhere that you have to.\r\n\r\n    \r\n    function() {                                // this function has no name, which means that this function will get triggered when only money gets send\r\n        if (msg.value < 1 finney) {             // DON'T SEND SOMETHING LESS THEN 1 FINNEY TO THIS CONTRACT\r\n            msg.sender.send(msg.value);         // well you can, but this contract will just send it back, all the wasted gas\r\n            throw;                              // and we will pretend it never happened\r\n        }\r\n        \r\n        if (msg.value == 1 finney) {            // IF the value you send to this contract is 1 finney\r\n            nextInputProfit = msg.sender;       // THEN the address will get saved as nextInputProfit, because the next input will be profit\r\n            throw;                              // THEN THE OTHER CONTRACT that provides the profit HAS to send the profit to this contract WITH THE SAME ADDRESS\r\n        }\r\n        \r\n        if (nextInputProfit == msg.sender) {    // IF this is the second time the smartcontract that provides profit insert ether, it checks its address to see if it matches\r\n            nextInputProfit = 0;                // this resets the nextInputProfit to nothing. because the code is now being executed and won't be executed again, unless it sends 1 finney again.\r\n            correctProfit = msg.value + 1 finney; // this adds the 1 finney that was taken away for code recognition.\r\n            insertProfitHere();                 // GO TO the function that destributes profits.\r\n        }\r\n        else {                                  // IF you're NOT a profit providing smartcontract and have NOT inserted 1 finney first, then the contract recognizes you as contributor\r\n            for(i; i<contributors.length; i++) {// this will go through ALL contributors untill it has found a matching address (LEARN ABOUT FOR LOOPS ON GOOGLE (if it still exists))\r\n                if (contributors[i].addr == msg.sender) {// If it has found one, it'll prevent the same contributor added twice\r\n                    contributorFound = i;       // then the number i is the contributors index number.\r\n                    i = contributors.length;    // this will make the for loop stop, to save gas.\r\n                }\r\n            }\r\n            i = 0;                              // resets that i thingy back to zero, because... you know. \r\n            if (contributorFound > 0) {         // if the contributorsFound is NOT 0, like in the beginning of this contract, that means this is not the first time this address contributed\r\n                contributors[contributorFound].contribution += msg.value; // add the new contribution value to the existing contribution value\r\n                contributors[contributorFound].total = contributorTotal; // for show in Mist Browser\r\n                contributors[contributorFound].lastContribution = msg.value; // for show in Mist Browser\r\n                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit;   // Counts up the total amount a contributor has\r\n            }\r\n            else {                              // if this is the first time your address contributed here, welcome first of all, and you will be added in the database\r\n                contributors[contributorsIndex].addr = msg.sender; // IF you're the first contributor, you will get contributorsIndex number 0.\r\n                contributors[contributorsIndex].index = contributorsIndex; // so you know where you stand                \r\n                contributors[contributorsIndex].contribution = msg.value; // your value will now be seen as a contribution, and you will receive profits\r\n                contributors[contributorsIndex].total = msg.value;  // for show in Mist Browser\r\n                contributors[contributorsIndex].lastContribution = msg.value; // for show in Mist Browser\r\n                contributorsIndex += 1;         // add one to the contributors index, no two contributors gets the same index number\r\n            }\r\n            totalContributorsContribution += msg.value;   // If you want to give you're contributors the correct share of profits, the total contributors amount has to be correct all the time.\r\n        }\r\n    }\r\n    \r\n    \r\n    function insertProfitHere() {               // so if the contract recognizes your input as profit, it executes this function. You can also use the mist browser to add profits.\r\n        totalContributorsTotal = totalContributorsProfit + totalContributorsContribution; // count up everything to calculate shares later on\r\n        i = contributors.length;                // I begin with the last contributor, because last added, first served.\r\n        uint CorrectProfitCounter = correctProfit;  // I need an additional counter to NOT give out too much profit then that there is.\r\n        uint addedProfit;                       //after calculating shares, addedProfit is the amount one contributor gets.\r\n        uint errorBelow = 0;                    // in case there is not enought profit to share around, if it happens, something went wrong.\r\n            for(i; i >= 0; i--) {               // this gathers all the contributors one by one, starting with the last contributor\r\n            contributorTotal = contributors[i].contribution + contributors[i].profit;   // Counts up the total amount a contributor has\r\n            contributorShare = contributorTotal / totalContributorsTotal;  // compares it with the amount of all contribution\r\n            addedProfit = contributorShare / correctProfit;    // the contract gives the contributor the fair share in comparison of the rest of all the contributors\r\n            CorrectProfitCounter -= addedProfit;// I don't want the contract balance to be below zero, because of miscalculations, so I keep subtracting to check\r\n            if (CorrectProfitCounter > 0){      // if there is still enough profit to share, share it. If it doesn't, then something went wrong.\r\n                contributors[i].profit += addedProfit;  // add the profit to the contributors database index\r\n                totalContributorsProfit += addedProfit; // also add that same amount to the total of all contributors\r\n                contributors[i].lastProfit = addedProfit; // Also for show in the Mist browser                \r\n            }\r\n            else {                              // if this code gets executes, then something went wrong and the duped ones get notified\r\n                errorBelow = i;                 // let's hope this never happens\r\n                i = 0;                          // this makes the for loop stop\r\n            }\r\n        }\r\n        if (errorBelow >= 0){                   // something went wrong, we have to tell the duped about it quick!\r\n            for(errorBelow; errorBelow > 0; errorBelow--) { // for loop to tell the ones who are duped that something went wrong\r\n                contributors[errorBelow].error = \"Please cash all out and recontribute to continue getting profit\"; // haha quickfix\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    function cashOutProfit() {                  // This is the best part for contributors\r\n        for(i; i<contributors.length; i++) {    // for loop again to search you up\r\n            if (contributors[i].addr == msg.sender) {   // see if it matches\r\n                contributorFound = i;           // we found you\r\n                i = contributors.length;        // stop the for loop\r\n                msg.sender.send(contributors[contributorFound].profit); // send the profits you've earned\r\n                totalContributorsProfit -= contributors[contributorFound].profit;   // remove the profits from the total to correctly calculate shares in the future\r\n                contributors[contributorFound].profit = 0;  // if you've cashed all your profit out, you have no more profit in the contract\r\n            }\r\n            \r\n        }\r\n        i = 0;                                  // this might be unnessecary, but who cares\r\n    }\r\n    \r\n    \r\n    function cashAllOut() {                     // this is when you want to stop getting profits as well\r\n        for(i; i<contributors.length; i++) {    // for loop to search you up\r\n            if (contributors[i].addr == msg.sender) {   // match or no?\r\n                contributorFound = i;           // tadaaaa\r\n                i = contributors.length;        // stop the for loop please\r\n                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit; // count all your funds up\r\n                msg.sender.send(contributorTotal);  // and send it back to you, have fun\r\n                totalContributorsContribution -= contributors[contributorFound].contribution;   // to correct shares later\r\n                contributors[contributorFound].contribution = 0;    // all gone, because you cashed out\r\n                totalContributorsProfit -= contributors[contributorFound].profit;   // to correct the shares later also\r\n                contributors[contributorFound].profit = 0;  // no profit if you've asked for it\r\n            }\r\n            \r\n        }\r\n        i = 0;                                  // This is the end I guess\r\n    }\r\n    \r\n    \r\n//------------------------------------------------------------------------------\r\n//------ALPHA/BETA FUNCTIONS ONLY-----------------------------------------------\r\n//------------------------------------------------------------------------------\r\n    function giveAllBack() {                    // TIME TO YELL SCAM!\r\n        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, to be sure\r\n            for(i; i<contributors.length; i++) {// ow nevermind..\r\n                contributorTotal = contributors[i].contribution + contributors[i].profit;   // count up how much the contributors have individually\r\n                contributors[i].addr.send(contributorTotal);    // aaaand send it back\r\n                contributors[i].contribution = 0; // reset all the balances\r\n                totalContributorsContribution = 0;   // balance reset\r\n                contributors[i].profit = 0; // never had a reset to serious\r\n                totalContributorsProfit = 0;    // balance reset\r\n            }\r\n            i = 0;                              // search function stuff\r\n        }\r\n    }\r\n    \r\n\r\n    function giveContributionsBackProfitBugged() {  // Yeah now you can yell scam!\r\n        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, or else everyone can do this\r\n            for(i; i<contributors.length; i++) {    // get all the contributors\r\n                contributorTotal = contributors[i].contribution;    // only give back all user contribution\r\n                contributors[i].contribution = 0; // reset everything\r\n                contributors[i].addr.send(contributorTotal); // Yeah so the contract now only has claimable profits left\r\n            }\r\n            i = 0;                              // at least I tried making this smartcontract\r\n        }\r\n    }\r\n\r\n\r\n    function Fokitol() {                        // scream scam NOW!! If you don't, people will be baited and the world as we know it will end!!\r\n        if (beta == msg.sender) {               // is it the deployer?\r\n            beta.send(this.balance);            // send him everything, which is super lame to do if there are other people contributing as well.\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"giveContributionsBackProfitBugged\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giveAllBack\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContributorsProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"contribution\",\"type\":\"uint256\"},{\"name\":\"profit\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"lastContribution\",\"type\":\"uint256\"},{\"name\":\"lastProfit\",\"type\":\"uint256\"},{\"name\":\"lastProfitShare\",\"type\":\"uint256\"},{\"name\":\"lastPayout\",\"type\":\"uint256\"},{\"name\":\"error\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Fokitol\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContributorsContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashAllOut\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributorsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beta\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextInputProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashOutProfit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"insertProfitHere\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"GeneralPurposeProfitSplitter","CompilerVersion":"v0.3.1-2016-04-07-054bc2a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}