{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Decentraliced Grid Organization\r\n * Version: 0.0.1\r\n * Author: Thorsten Zoerner <me@thorsten-zoerner.com>\r\n * Donations: btc:1MvghD6TE2nurN4iCUSLdmcCRiwohgCA86 eth:0x697a040b13aefdd9553f3922dcb547be6efd88d2\r\n * Implementation: Ethereum/Solidity\r\n */\r\n\r\n/**\r\nBusiness Case / Purpose\r\n=========================================================================================\r\nIntroduces a smart contract for members of a power grid to facilitate P2P balancing.\r\n\r\n- Implements post delivery balancing with peers\r\n- Provides tokens per GridMember for clearing\r\n- Handles simple prioty list for merit order \r\n- Allow Exchange of Meter Device\r\n- Allow multiple \"Listeners\" (Push Clients) per MP (according to Smart Meter Gateway Concept)\r\n\r\nRequires independend smart meter operator.\r\n*/\r\n/*\r\n[{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"switchMPO\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"}]\r\n*/\r\ncontract MPO { \r\n\tuint256 public reading;\r\n\tuint256 public time;\r\n\taddress public operator; \r\n\tuint256 shift;\r\n\tstring public name =\"MP\";\r\n\tstring public symbol =\"Wh\";\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tmapping (address => uint256) public balanceOf;\r\n\taddress[] public listeners;\r\n\t\r\n\tfunction MPO() {\r\n\t\toperator=msg.sender;\r\n\t\tshift=0;\r\n\t}\r\n\t\r\n\tfunction updateReading(uint256 last_reading,uint256 timeofreading) {\t\t\r\n\t\tif(msg.sender!=operator) throw;\r\n\t\tif((timeofreading<time)||(reading>last_reading)) throw;\t\r\n\t\tvar oldreading=last_reading;\r\n\t\treading=last_reading-shift;\r\n\t\ttime=timeofreading;\t\r\n\t\tbalanceOf[this]=last_reading;\r\n\t\tfor(var i=0;i<listeners.length;i++) {\r\n\t\t\tbalanceOf[listeners[i]]=last_reading;\r\n\t\t\tTransfer(msg.sender,listeners[i],last_reading-oldreading);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction registerListening(address a) {\r\n\t\tlisteners.push(a);\r\n\t\tbalanceOf[a]=reading;\r\n\t\tTransfer(msg.sender,a,reading);\r\n\t}\r\n\t\r\n\tfunction unregisterListening(address a) {\r\n\t\r\n\t\tfor(var i=0;i<listeners.length;i++) {\r\n\t\t\tif(listeners[i]==a) listeners[i]=0;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tfunction transferOwnership(address to) {\r\n\t\tif(msg.sender!=operator) throw;\r\n\t\toperator=to;\r\n\t}\r\n\tfunction transfer(address _to, uint256 _value) {\r\n\t\t/* Function stub required to see tokens in wallet */\t\t\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n    }\r\n\tfunction assetMoveInformation(address newmpo,address gridMemberToInform) {\r\n\t\tif(msg.sender!=operator) throw;\r\n\t\t/*var gm=GridMember(gridMemberToInform);\r\n\t\tgm.switchMPO(this,newmpo);\r\n\t\t*/\r\n\t}\r\n\t\r\n}\r\ncontract MPOListener {\r\n\tMPO public mp;\r\n\t\r\n\tfunction switchMPO(address from, address to) {\r\n\t\tif(msg.sender!=mp.operator()) throw;\r\n\t\tif(mp==from) {\r\n\t\t\tmp=MPO(to);\t\t\t\r\n\t\t}\r\n\t}\r\n}\r\ncontract operated {\r\n    address public operator;\r\n\r\n    function operated() {\r\n        operator = msg.sender;\r\n    }\r\n\r\n    modifier onlyOperator {\r\n        if (msg.sender != operator) throw;\r\n        _\r\n    }\r\n\r\n    function transferOperator(address newOperator) onlyOperator {\r\n        operator = newOperator;\r\n    }\r\n}\r\n\r\ncontract GridMember is operated,MPOListener {\r\n\t\t\r\n\t\r\n\taddress[] public peers;\r\n\tuint256 public lastreading;\r\n\tstring public name;\r\n\tuint256 public actual_feedin=0;\r\n\tuint256 public actual_feedout=0;\t\r\n\tuint256 public total_feedin;\r\n\tuint256 public total_feedout;\r\n\tstring public symbol =\"Wh\";\r\n\tuint256 public managedbalance;\r\n\tbool public feedin;\r\n\tbool public autobalancepeers;\r\n\tbool listening;\r\n\taddress public aggregate;\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => uint256) public allowance;\t\r\n\t\r\n\tmapping (address => uint256) public molist;\r\n\t\r\n\tfunction GridMember(string membername,uint256 managablebalance,bool directionFeedin,address mpo,address aggregation) {\t\t\t\r\n\t\tname=membername;\r\n\t\tmanagedbalance=managablebalance;\r\n\t\tbalanceOf[this]=managablebalance;\r\n\t\tTransfer(msg.sender,this,managablebalance);\r\n\t\tfeedin=directionFeedin;\t\t\r\n\t\tif(feedin) total_feedin=lastreading; else total_feedout=lastreading;\r\n\t\tautobalancepeers=false;\t\r\n\t\tmp=MPO(mpo);\r\n\t\tupdateReading(mp.reading());\t\t\r\n\t\tactual_feedin=0;\r\n\t\tactual_feedout=0;\r\n\t\tlistening=false;\r\n\t\taggregate=aggregation;\r\n\t}\r\n\t\r\n\tfunction switchMPO(address from, address to) {\r\n\t\tif(msg.sender!=mp.operator()) throw;\r\n\t\tupdateWithMPO();\r\n\t\tlastreading=0;\r\n\t\tsuper.switchMPO(from,to);\r\n\t\tupdateWithMPO();\r\n\t\tlistening=false;\r\n\t}\r\n\tfunction registerListening() onlyOperator {\r\n\t\tmp.registerListening(this);\r\n\t\tlistening=true;\r\n\t}\r\n\t\r\n\tfunction addPowerSource(address peer,uint256 manageallowed,uint merritorder) onlyOperator {\r\n\t\tif(merritorder>9) throw;\r\n\t\tif(feedin) throw;\r\n \t\tallowance[peer]=manageallowed;\r\n\t\tpeers.push(peer);\r\n\t\tmolist[peer]=merritorder;\r\n\t\t\r\n\t} \r\n\t\r\n\tfunction updateWithMPO() {\t\t\t\r\n\t\tupdateReading(mp.balanceOf(mp));\r\n\t}\r\n\t\t\r\n\tfunction updateReading(uint256 reading) private {\t\r\n\t\tif(getActual()>0) runPeerBalance();\r\n\t\tif(reading<lastreading) throw;\r\n\t\tvar actual = reading -lastreading;\r\n\t\tif(feedin) actual_feedin+=actual; else actual_feedout+=actual;\t\t\r\n\t\tif(feedin) total_feedin+=actual; else total_feedout+=actual;\t\t\t\t\t\t\t\t\t\t\r\n\t\tlastreading=reading;\r\n\t\trunPeerBalance();\r\n\t}\r\n\t\r\n\tfunction requestPeerBalance() onlyOperator {\r\n\t\tupdateWithMPO();\r\n\t\trunPeerBalance();\r\n\t\tAggregation a = Aggregation(aggregate);\r\n\t\ta.doBalanceFor(this);\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction runPeerBalance() private {\r\n\t\tfor(var j=0;j<10;j++) {\r\n\t\t\tfor(var i=0;i<peers.length;i++) {\r\n\t\t\t\tif(molist[peers[i]]==j) {\r\n\t\t\t\tGridMember peer = GridMember(peers[i]);\r\n\t\t\t\tallowance[peer]=getActual();\r\n\t\t\t\tpeer.doBalance(this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\r\n\t}\r\n\tfunction getActual() returns(uint256) {\r\n\t\tif(feedin) return actual_feedin; else return actual_feedout;\t\t\t\t\r\n\t}\r\n\t\r\n\tfunction receiveTransfer(uint256 amount) {\r\n\t\tif(tx.origin!=operator) throw;\t\r\n\t\tif(feedin) actual_feedin-=amount; else actual_feedout-=amount;\r\n\t}\r\n\tfunction sendToAggregation(uint256 amount) {\r\n\t\tbalanceOf[this]-=amount;\r\n\t\tbalanceOf[aggregate]+=amount;\r\n\t\tif(feedin) actual_feedin-=amount; else actual_feedout-=amount;\r\n\t\tTransfer(this,aggregate,amount);\r\n\t}\r\n\tfunction doBalance(address requester) {\t\t\r\n\t\tupdateWithMPO();\r\n\t\tif(autobalancepeers) {\r\n\t\t\tif((actual_feedin>0)||(actual_feedout>0)) {\r\n\t\t\t\t// Prevent Loop Condition!\r\n\t\t\t\t\r\n\t\t\t}\t\t\t\t\r\n\t\t}\r\n\t\tGridMember peer = GridMember(requester);\t\t\r\n\t\t\r\n\t\tif(feedin==peer.feedin()) return;\r\n\t\tuint256 peer_allowance = peer.allowance(this);\r\n\t\tuint256 balance_amount=0;\r\n\t\t//\r\n\t\tif(feedin) { balance_amount=actual_feedin; } else { balance_amount=actual_feedout; }\r\n\t\tif(peer_allowance<balance_amount) { balance_amount=peer_allowance; }\t\t\r\n\t\tif(balanceOf[this]<balance_amount) balance_amount=balanceOf[this];\t\r\n\t\t\r\n\t\tif((peer.managedbalance()-peer.balanceOf(requester))+peer.getActual()<balance_amount) balance_amount=(peer.managedbalance()-peer.balanceOf(requester))+peer.getActual();\r\n\t\t\r\n\t\tif(balance_amount>0) {\r\n\t\t\tbalanceOf[this]-=balance_amount;\r\n\t\t\tbalanceOf[requester]+=balance_amount;\r\n\t\t\tTransfer(this,requester,balance_amount);\r\n\t\t\tif(feedin) { actual_feedin-=balance_amount; \t\t\t\t\t\t\r\n\t\t\t\t\t   } else { actual_feedout-=balance_amount; }\r\n\t\t\tpeer.receiveTransfer(balance_amount);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t\r\n\tfunction transfer(address _to, uint256 _value) {\r\n\t\t/* Function stub required to see tokens in wallet */\t\t\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n    }\r\n   \r\n}\r\n\r\n\r\ncontract Aggregation {\r\n\taddress public owner;\r\n\taddress[] public members;\r\n\tuint256 public actual_feedin;\r\n\tuint256 public actual_feedout;\r\n\tuint256 public balance_in;\r\n\tuint256 public balance_out;\r\n\tuint256 public last_balance;\r\n\tuint256 public next_balance;\r\n\tstring public name=\"Aggregation\";\r\n\tstring public symbol=\"Wh\";\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => uint256) public lastbalancing;\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tfunction Aggregation() {\r\n\t\towner=msg.sender;\r\n\t\tnext_balance=now+3600;\r\n\t}\r\n\t\r\n\tfunction addGridMember(address gridmember) {\r\n\t\tif(msg.sender!=owner) throw;\r\n\t\r\n\t\tmembers.push(gridmember);\r\n\t}\r\n\tfunction transfer(address _to, uint256 _value) {\r\n\t\t/* Function stub required to see tokens in wallet */\t\t\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n    }\r\n\t\r\n\tfunction doBalanceFor(address a) {\r\n\t\tbool found=false;\r\n\t\tfor(var i=0;i<members.length;i++) {\r\n\t\t\tif(members[i]==a) found=true; \r\n\t\t}\r\n\t\tif(!found) throw;\r\n\t\t\r\n\t\tGridMember g = GridMember(a);\r\n\t\tactual_feedin+=g.actual_feedin();\r\n\t\tactual_feedout+=g.actual_feedout();\r\n\t\t// as a member is either feeder or consumer this is not dangerous... :)\r\n\r\n\t\tg.sendToAggregation(g.actual_feedin()+g.actual_feedout());\r\n\t\tlastbalancing[a]=now;\r\n\t\t\r\n\t}\t\r\n\tfunction doBalance() {\r\n\t\tif(now<next_balance) throw;\r\n\t\tfor(var i=0;i<members.length;i++) {\r\n\t\t\tdoBalanceFor(members[i]);\t\t\t\r\n\t\t}\r\n\t\tnext_balance=now+3600;\r\n\t}\r\n}\r\n// Aggregation Testnet: 0x70F24857194520Fd70a788C6a9D9638bA44a0B85","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doBalance\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance_in\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gridmember\",\"type\":\"address\"}],\"name\":\"addGridMember\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"doBalanceFor\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actual_feedout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance_out\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"next_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastbalancing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actual_feedin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Aggregation","CompilerVersion":"v0.3.1-2016-04-18-81ae2a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}