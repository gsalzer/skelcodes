{"status":"1","message":"OK","result":[{"SourceCode":"//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//   WHYSOS3RIOUS   PRESENTS :                          \r\n//                                                                \r\n//   ROCK PAPER SCISSORS\r\n//   Challenge an opponent with an encrypted hand\r\n//   www.matching-ethers.com/rps                 \r\n//\r\n//\r\n// *** coded by WhySoS3rious, 2016.                                       ***//\r\n// *** please do not copy without authorization                          ***//\r\n// *** contact : reddit    /u/WhySoS3rious                               ***//\r\n\r\n//          STAKE : 0.1 ETH\r\n//          DRAW : Full refund\r\n//          WIN : 0.198 ETH (house : 0.002)\r\n//          EXPIRATION TIME : 24 hour after duel starts (refreshed when one player reveals)\r\n//          If only one player reveals, he wins after 24 hour if the other doesn't reveal\r\n//          he will be paid automatically when other ppl play the game.\r\n//          If both player don't reveal and forget the bet, it is refunded (-house)\r\n\r\n//         HOW TO PLAY ?\r\n//         1- Send a encrypted Hand (generated on the game's website or by yourself)\r\n//         2- Wait for opponent (can cancel if you wish)\r\n//         3- Once matched, reveal your hand with the appropriate function and your secret\r\n//         4- Wait for your duel to resolve and the automatic payout\r\n\r\n//         ENCRYPT YOUR HAND\r\n//         Encrypt your hands on the website or\r\n//         directly with web3.js :  web3.sha3(secret+hand)\r\n\r\n// exemple results with secret = \"testing\"\r\n//hand = \"rock\" :  web3.sha3(\"testing\"+\"rock\")\r\n// 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\r\n//hand = \"paper\" : \r\n// 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\r\n//hand = \"scissors\" : \r\n//0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\r\n\r\ncontract Crypted_RPS\r\n{\r\n    address owner;\r\n    uint256 gambleValue;\r\n    uint256 expirationTime;\r\n    uint256 house;\r\n    uint256 houseTotal;\r\n    modifier noEthSent(){\r\n        if (msg.value>0) msg.sender.send(msg.value);\r\n        _\r\n    }\r\n    modifier onlyOwner() {\r\n\t    if (msg.sender!=owner) throw;\r\n\t    _\r\n    }\r\n    modifier equalGambleValue() {\r\n\tif (msg.value < gambleValue) throw;\r\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\r\n\t_\r\n    }\r\n\r\n    struct PlayerWaiting\r\n    {\r\n        bool full;\r\n        address player;\r\n        bytes32 cryptedHand;\r\n    }\r\n    PlayerWaiting playerWaiting;\r\n\r\n    struct Duel2Decrypt\r\n    {\r\n\taddress player_1;\r\n        bytes32 cryptedHand_1;\r\n        address player_2;\r\n \tbytes32 cryptedHand_2;\r\n        bool decrypted;\r\n        uint256 timeStamp;\r\n    }\r\n    Duel2Decrypt[] duels2Decrypt;\r\n    uint firstActiveDuel2; //index of first Duel 2 not decrypted\r\n\r\n    struct Duel1Decrypt\r\n   {\r\n\taddress player_1;\r\n        string hand_1;\r\n        address player_2;\r\n\tbytes32 cryptedHand_2;\r\n        bool decrypted;\r\n        uint256 timeStamp;\r\n    }\r\n    Duel1Decrypt[] duels1Decrypt;\r\n    uint firstActiveDuel1;\r\n\r\n    struct Result  \r\n    {\r\n       address player_1;\r\n       string hand_1;\r\n       address player_2;\r\n       string hand_2;\r\n       uint result; //0 draw, 1 wins, 2 wins\r\n    }\r\n    Result[] results;\r\n\r\n\r\n    mapping (address => uint) player_progress;\r\n    // 0 not here, 1 waiting, 2 2crypted, 3 1crypted\r\n    mapping (address => uint) player_bet_id;\r\n    mapping (address => uint) player_bet_position;\r\n\r\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\r\n    {\r\n         if (option==0) {result = player_progress[player];}\r\n         else if (option==1) {result= player_bet_id[player];}\r\n         else if (option==2) {result = player_bet_position[player];}\r\n         return result;\r\n    }\r\n\r\n\r\n    mapping (string => mapping(string => int)) payoffMatrix;\r\n    //constructor\r\n    function Crypted_RPS()\r\n    {\r\n\towner= msg.sender;\r\n\tgambleValue = 100000 szabo;\r\n        house = 1000 szabo;\r\n        expirationTime = 86400;   //24 hour\r\n        payoffMatrix[\"rock\"][\"rock\"] = 0;\r\n        payoffMatrix[\"rock\"][\"paper\"] = 2;\r\n        payoffMatrix[\"rock\"][\"scissors\"] = 1;\r\n        payoffMatrix[\"paper\"][\"rock\"] = 1;\r\n        payoffMatrix[\"paper\"][\"paper\"] = 0;\r\n        payoffMatrix[\"paper\"][\"scissors\"] = 2;\r\n        payoffMatrix[\"scissors\"][\"rock\"] = 2;\r\n        payoffMatrix[\"scissors\"][\"paper\"] = 1;\r\n        payoffMatrix[\"scissors\"][\"scissors\"] = 0;\r\n    }\r\n\r\n    function () {throw;} //no callback, use the functions to play\r\n\r\n    modifier payexpired2Duel{\r\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\r\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\r\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\r\n            houseTotal+=2*house;\r\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\r\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\r\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\r\n            updateFirstDuel2(firstActiveDuel2);\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier payexpired1Duel{\r\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\r\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\r\n            houseTotal+=2*house;\r\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\r\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\r\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\r\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,\"expired\", 1));\r\n            updateFirstDuel1(firstActiveDuel1);\r\n           \r\n        }\r\n        _\r\n    }\r\n        \r\n\r\n    function cancelWaitingForOpponent()\r\n    noEthSent {\r\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\r\n        {\r\n             msg.sender.send(gambleValue);\r\n             playerWaiting.full=false;\r\n             player_progress[msg.sender]=0;\r\n        }\r\n        else { throw;}\r\n    }\t\r\n\r\n\r\n    //checks that the player is not already in the game\r\n    modifier notPlayingAlready \r\n    {\r\n          //one not resolved duel per player only\r\n          uint progress = player_progress[msg.sender];\r\n          uint position = player_bet_position[msg.sender];\r\n          if ( progress==3 && position==1 ) throw;\r\n          if (progress == 2 ) throw; \r\n          if (progress ==  1 ) throw; //no selfdueling\r\n          _\r\n    }\r\n\r\n\r\n    function sendCryptedHand(bytes32 cryptedH)\r\n    notPlayingAlready\r\n    equalGambleValue\r\n    payexpired2Duel\r\n    payexpired1Duel\r\n    {\r\n          if (!playerWaiting.full) \r\n          {\r\n              playerWaiting.player=msg.sender;\r\n              playerWaiting.cryptedHand= cryptedH;\r\n              playerWaiting.full=true;\r\n              player_progress[msg.sender]=1;\r\n          }\r\n          else\r\n          {\r\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\r\n                player_progress[playerWaiting.player]=2;\r\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\r\n                player_bet_position[playerWaiting.player]=0;\r\n                player_progress[msg.sender]=2;\r\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\r\n                player_bet_position[msg.sender]=1;         \r\n                playerWaiting.full=false;\r\n          }\r\n\r\n    }\r\n\r\n\r\n    function revealRock(string secret)\r\n    {\r\n        bytes32 hashRevealed = sha3(secret, \"rock\");\r\n        reveal(hashRevealed, \"rock\");\r\n    }\r\n    function revealPaper(string secret)\r\n    {\r\n        bytes32 hashRevealed = sha3(secret, \"paper\");\r\n        reveal(hashRevealed, \"paper\");\r\n    }\r\n    function revealScissors(string secret)\r\n    {\r\n        bytes32 hashRevealed = sha3(secret, \"scissors\");\r\n        reveal(hashRevealed, \"scissors\");\r\n    }\r\n\r\n    function reveal(bytes32 hashRevealed, string hand) private\r\n    noEthSent\r\n   {\r\n\r\n        uint progress =  getPlayerStatus(msg.sender,0);\r\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\r\n        uint position  =  getPlayerStatus(msg.sender,2);\r\n        \r\n\r\n        bytes32 hashStored;        \r\n        if (progress==2)  //duel not revealed\r\n        { \r\n            if (position == 0)\r\n            {\r\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\r\n            }\r\n            else\r\n            {\r\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\r\n            }\r\n        }\r\n        else if (progress==3 && position==1) //duel half revealed already\r\n        { \r\n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\r\n        }\r\n        else { throw;} //player has nothing to reveal\r\n\r\n\tif (hashStored==hashRevealed)\r\n        {\r\n              decryptHand(hand, progress, bet_id, position);\r\n        }\r\n        else\r\n        {\r\n             throw; //wrong secret or hand\r\n         }\r\n    }\r\n    \r\n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\r\n    {\r\n             address op_add;\r\n             bytes32 op_cH;\r\n\r\n         if (progress==2)\r\n         {  \r\n             if (position==0) \r\n             {\r\n                 op_add = duels2Decrypt[bet_id].player_2;\r\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\r\n\r\n             }\r\n             else\r\n             {\r\n                 op_add = duels2Decrypt[bet_id].player_1;\r\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\r\n             }\r\n\r\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\r\n              duels2Decrypt[bet_id].decrypted=true;\r\n              updateFirstDuel2(bet_id);\r\n              player_progress[msg.sender]=3;\r\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\r\n              player_bet_position[msg.sender]=0;\r\n              player_progress[op_add]=3;\r\n              player_bet_id[op_add]=duels1Decrypt.length-1;\r\n              player_bet_position[op_add]=1;\r\n\r\n         }\r\n         else if (progress==3 && position==1)\r\n         {\r\n              op_add = duels1Decrypt[bet_id].player_1;\r\n              string op_h = duels1Decrypt[bet_id].hand_1;\r\n              duels1Decrypt[bet_id].decrypted=true;\r\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\r\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\r\n              updateFirstDuel1(bet_id);\r\n              player_progress[msg.sender]=0;\r\n              player_progress[op_add]=0;\r\n          }\r\n     }\r\n\r\n     function updateFirstDuel2(uint bet_id) private\r\n     {\r\n         if (bet_id==firstActiveDuel2)\r\n         {   \r\n              uint index;\r\n              while (true) {\r\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\r\n                     index=index+1;\r\n                 }\r\n                 else {break; }\r\n              }\r\n              firstActiveDuel2=index;\r\n              return;\r\n          }\r\n      }\r\n\r\n     function updateFirstDuel1(uint bet_id) private\r\n     {\r\n         if (bet_id==firstActiveDuel1)\r\n         {   \r\n              uint index;\r\n              while (true) {\r\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\r\n                     index=index+1;\r\n                 }\r\n                 else {break; }\r\n              }\r\n              firstActiveDuel1=index;\r\n              return;\r\n          }\r\n      }\r\n\r\n     // in case there is too much expired duels in queue for automatic payout, \r\n     //I can help to catch up\r\n     function manualPayExpiredDuel() \r\n     onlyOwner\r\n     payexpired2Duel\r\n     payexpired1Duel\r\n     noEthSent\r\n     {\r\n         return;\r\n     }\r\n\r\n     //payout\r\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \r\n     {\r\n              if (payoffMatrix[hand_1][hand_2]==0) //draw\r\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\r\n              else if (payoffMatrix[hand_1][hand_2]==1) //1 win\r\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\r\n              if (payoffMatrix[hand_1][hand_2]==2) //2 wins\r\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\r\n              return result;\r\n      }\r\n\r\n     function payHouse() \r\n     onlyOwner\r\n     noEthSent {\r\n         owner.send(houseTotal);\r\n         houseTotal=0;\r\n     }\r\n\r\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\r\n         return firstActiveDuel1;}\r\n     function getLastDuel1() constant returns(uint lD1) {\r\n         return duels1Decrypt.length;}\r\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\r\n         p1 = duels1Decrypt[index].player_1;\r\n         h1 = duels1Decrypt[index].hand_1;\r\n         p2 = duels1Decrypt[index].player_2;\r\n         dC = duels1Decrypt[index].decrypted;\r\n         tS  = duels1Decrypt[index].timeStamp;\r\n     }\r\n\r\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\r\n         return firstActiveDuel2;}\r\n     function getLastDuel2() constant returns(uint lD2) {\r\n         return duels2Decrypt.length;}\r\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\r\n         p1 = duels2Decrypt[index].player_1;\r\n         p2 = duels2Decrypt[index].player_2;\r\n         dC = duels2Decrypt[index].decrypted;\r\n         tS  = duels2Decrypt[index].timeStamp;\r\n     }\r\n\r\n     function getPlayerWaiting() constant returns(address p, bool full) {\r\n         p = playerWaiting.player;\r\n         full = playerWaiting.full;\r\n     }\r\n\r\n     function getLastResult() constant returns(uint lD2) {\r\n         return results.length;}\r\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\r\n         p1 = results[index].player_1;\r\n         h1 = results[index].hand_1;\r\n         p2 = results[index].player_2;\r\n         h2 = results[index].hand_2;\r\n         r = results[index].result;\r\n     }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"cryptedH\",\"type\":\"bytes32\"}],\"name\":\"sendCryptedHand\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret\",\"type\":\"string\"}],\"name\":\"revealRock\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualPayExpiredDuel\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastDuel2\",\"outputs\":[{\"name\":\"lD2\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstActiveDuel1\",\"outputs\":[{\"name\":\"fAD1\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getResults\",\"outputs\":[{\"name\":\"p1\",\"type\":\"address\"},{\"name\":\"h1\",\"type\":\"string\"},{\"name\":\"p2\",\"type\":\"address\"},{\"name\":\"h2\",\"type\":\"string\"},{\"name\":\"r\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDuel1\",\"outputs\":[{\"name\":\"p1\",\"type\":\"address\"},{\"name\":\"h1\",\"type\":\"string\"},{\"name\":\"p2\",\"type\":\"address\"},{\"name\":\"dC\",\"type\":\"bool\"},{\"name\":\"tS\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastResult\",\"outputs\":[{\"name\":\"lD2\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret\",\"type\":\"string\"}],\"name\":\"revealScissors\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDuel2\",\"outputs\":[{\"name\":\"p1\",\"type\":\"address\"},{\"name\":\"p2\",\"type\":\"address\"},{\"name\":\"dC\",\"type\":\"bool\"},{\"name\":\"tS\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payHouse\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"getPlayerStatus\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelWaitingForOpponent\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstActiveDuel2\",\"outputs\":[{\"name\":\"fAD2\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastDuel1\",\"outputs\":[{\"name\":\"lD1\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerWaiting\",\"outputs\":[{\"name\":\"p\",\"type\":\"address\"},{\"name\":\"full\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret\",\"type\":\"string\"}],\"name\":\"revealPaper\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"Crypted_RPS","CompilerVersion":"v0.3.1-2016-03-31-c67926c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}