{"status":"1","message":"OK","result":[{"SourceCode":"//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//   WHYSOS3RIOUS   PRESENTS :   \r\n//   The ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become an investor in the Casino and share the profits/losses.) \r\n//\r\n//\r\n//   website : www.WhySoS3rious.com/Rouleth\r\n//               with a flashy roulette :) !\r\n//\r\n// *** coded by WhySoS3rious, 2016.                                       ***//\r\n// *** please do not copy without authorization                          ***//\r\n// *** contact : reddit    /u/WhySoS3rious                               ***//\r\n//\r\n//\r\n//  Stake : Variable, check on website for the max bet.\r\n//  At launch the max stake is 0.05 ETH\r\n//\r\n//\r\n//  How to play ?\r\n//  1) Simplest (via transactions from your wallet, not an exchange) : \r\n//  Just send the value you want to bet to the contract and add enough gas \r\n//  (you can enter the max gas amount of ~4,5Million, any excess is refunded anyways)\r\n//  This will by default place a bet on number 7\r\n//  Wait 2 minutes (6 blocks) and send (with enough gas) 1 wei (or any amount, it will be refunded)\r\n//  This will spin the wheel and you will receive * 35 your bet if you win.\r\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\r\n//\r\n//  2) Advanced (via contract functions, e.g. Mist, cf. tutorial on my website for more details) :\r\n//  Import the contract in Mist wallet using the code of the ABI (link on my website)\r\n//  Use the functions (betOnNumber, betOnColor ...) to place any type of bet you want\r\n//  Provide the appropriate input (ex: check box Red or Black)\r\n//  add the amount you want to bet.\r\n//  wait 6 blocks, then use the function spinTheWheel, this will solve the bet.\r\n//  You can only place one bet at a time before you spin the wheel.\r\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\r\n//\r\n//\r\n//\r\n//  Use the website to track your bets and the results of the spins\r\n//\r\n//\r\n//   How to invest ?\r\n//   Import the contract in Mist Wallet using the code of the ABI (link on my website)\r\n//   Use the Invest function with an amount >10 Ether (can change, check on my website)\r\n//   You will become an investor and share the profits and losses of the roulette\r\n//   proportionally to your investment. There is a 2% fee on investment to help with the server/website\r\n//   cost and also 2% on profit that go to the developper.\r\n//   The rest of your investment goes directly to the payroll and 98% of profits are shared between \r\n//   investors relatively to their share of total. Losses are split similarly.\r\n//   You can withdraw your funds at any time after the initial lock period (set to 1 week)\r\n//   To withdraw use the function withdraw and specify the amoutn you want to withdraw in Wei.\r\n//   If your withdraw brings your investment under 10 eth (the min invest, subject to change)\r\n//   then you will execute a full withdraw and stop being an investor.\r\n//   Check your current investor balance in Mist by using the information functions on the left side\r\n//   If you want to update the balances to the last state (otherwise they are automatically\r\n//   updated after each invest or withdraw), you can use the function manualUpdateBalances in Mist.\r\n//   \r\n//   The casino should be profitable in the long run (with 99% confidence). \r\n//   The maximum bet allowed has been computed through statistical analysis to yield high confidence \r\n//   in the long run survival of the casino. The maximum bet is always smaller than the current payroll \r\n//   of the casino * 35 (max pay multiplier) * casinoStatisticalLimit (statistical sample size that allows \r\n//   to have enough confidence in survival, set at 20 at start, should increase to 200 when we have more \r\n//   investors to increase the safety).\r\n//   \r\n//   At start there is a limit of 50 investors (can be changed via settings up to 150)\r\n//   If there is no open position and you want to invest, you can try to buyout a current investor.\r\n//   To buyout, you have to invest more than any investor whose funds are unlocked (after 1 week grace lock period)\r\n//   If there are no remaining open position and all investors are under grace period, it is not possible to \r\n//   become a new investor in the casino.\r\n//\r\n//   At any time an investor can add funds to his investment with the withdraw function.\r\n//   Doing so will refresh the lock period and secure your position.\r\n//\r\n//\r\n//   A provably fair roulette :  note on Random Number Generation.\r\n//   The roulette result is based on the hash of the 6th block after the player commits his bet.\r\n//   This guarantees a provably fair roulette with equiprobable results and non predictable\r\n//   unless someone has more computing power than all the Ethereum Network.\r\n//   Yet Miners could try to exploit their position in 2 ways.\r\n//   First they could try to mine 7 blocks in a row (to commit their bet based on result for a sure win),\r\n//   but this is highly improbable and not predictible.\r\n//   Second they could commit a bet, then wait 6 blocks and hope that they will be the one forming the \r\n//   block on which their commited bet depends. If this is the case and the hash they find is not a\r\n//   winning one, they could decide to not share the block with the network but would lose 5 ether.\r\n//   To counter this potential miner edge (=base win proba + (miner proba to find block)*base win proba )\r\n//   we keep wager amounts far smaller than 5 Eth so that the miner prefers to get his block reward than cheat.\r\n//   Note that a miner could place several bets on the same block to increase his potential profit from dropping a block\r\n//   For this reason we limit the number of bets per block to 2 at start (configurable later if needed).\r\ncontract Rouleth\r\n{\r\n\r\n    //Variables, Structure\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit;\r\n    //Current gamble value possibly lower than config (<payroll/(20*35))\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\tBetTypes betType; //number/color/dozen/oddeven\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet -1\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    enum Status {waitingForBet, waitingForSpin} Status status; //gamble status\r\n    mapping (address=>Status) playerStatus; //progress of the player's gamble\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n\tfunction  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=6; //delay to wait between bet and spin\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        maxGamble=50 finney; //0.05 ether as max bet to start (payroll of 35 eth)\r\n        maxBetsPerBlock=2; // limit of 2 bets per block, to prevent multiple bets per miners (to keep max reward<5ETH)\r\n        casinoStatisticalLimit=20;\r\n    }\r\n\t\r\n    modifier onlyDeveloper() {\r\n\t    if (msg.sender!=developer) throw;\r\n\t    _\r\n    }\r\n\t\r\n\tfunction changeDeveloper(address new_dev)\r\n        noEthSent\r\n\t    onlyDeveloper\r\n\t{\r\n\t\tdeveloper=new_dev;\r\n\t}\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private state;\r\n\tfunction disableBetting()\r\n    noEthSent\r\n\tonlyDeveloper\r\n\t{\r\n            state=States.inactive;\r\n\t}\r\n\tfunction enableBetting()\r\n\tonlyDeveloper\r\n        noEthSent\r\n\t{\r\n            state=States.active;\r\n\t}\r\n    \r\n\tmodifier onlyActive\r\n    {\r\n        if (state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n         //Change some settings within safety bounds\r\n\tfunction changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n\tnoEthSent\r\n\tonlyDeveloper\r\n\t{\r\n\t        // changes the statistical multiplier that guarantees the long run casino survival\r\n\t        if (newCasinoStatLimit<20) throw;\r\n\t        casinoStatisticalLimit=newCasinoStatLimit;\r\n\t        //Max number of bets per block to prevent miner cheating\r\n\t        maxBetsPerBlock=newMaxBetsBlock;\r\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\r\n\t\tif (newMaxGamble<=0 || newMaxGamble>=this.balance/(20*35)) throw; \r\n\t\telse { maxGamble=newMaxGamble; }\r\n                //MAX NB of INVESTORS (can only increase and max of 149)\r\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\r\n                else { setting_maxInvestors=newMaxInvestor;}\r\n                //MIN INVEST : \r\n                setting_minInvestment=newMinInvestment;\r\n                //Invest LOCK PERIOD\r\n                if (setting_lockPeriod>5184000) throw; //2 months max\r\n                setting_lockPeriod=newLockPeriod;\r\n\t\t        //Delay before roll :\r\n\t\tif (blockDelay<1) throw;\r\n\t\t        blockDelay=newBlockDelay;\r\n                updateMaxBet();\r\n\t\tif (newBlockExpiration<100) throw;\r\n\t\tblockExpiration=newBlockExpiration;\r\n\t}\r\n \r\n\r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n//***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n   {\r\n       //if player is not playing : bet on 7\r\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnNumber(7);\r\n       //if player is already playing, spin the wheel\r\n       else spinTheWheel();\r\n    } \r\n\r\n    function updateMaxBet() private\r\n    {\r\n    //check that maxGamble setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t\t{ \r\n\t\t\tcurrentMaxGamble=maxGamble;\r\n                }\r\n\telse\r\n\t\t{ \r\n\t\t\tcurrentMaxGamble = payroll/(20*35);\r\n\t\t}\r\n     }\r\n\r\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        updateMaxBet();\r\n\t\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t\t{\r\n\t\t    msg.sender.send(msg.value-currentMaxGamble);\r\n\t\t    playerBetValue=currentMaxGamble;\r\n\t\t}\r\n                else\r\n                { playerBetValue=msg.value; }\r\n       }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating and keep max reward per block <5ETH)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n    //check that the player is not playing already (unless it has expired)\r\n    modifier checkWaitingForBet{\r\n        //if player is already in gamble\r\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\r\n        {\r\n             //case not expired\r\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\r\n             //case expired\r\n             else\r\n             {\r\n                  //add bet to PL and reset status\r\n                  solveBet(msg.sender, 255, false, 0) ;\r\n\r\n              }\r\n        }\r\n\t_\r\n\t}\r\n\r\n    //Possible bet types\r\n    enum BetTypes{ number, color, parity, dozen, column, lowhigh} BetTypes private initbetTypes;\r\n\r\n    function updateStatusPlayer() private\r\n    expireGambles\r\n    {\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length-1;\r\n     }\r\n\r\n//***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n\t\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\t    gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n//***// function betOnColor\r\n\t//bet type : color\r\n\t//input : 0 for red\r\n\t//input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Black) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\t    gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n//***// function betOnLow_High\r\n\t//bet type : lowhigh\r\n\t//input : 0 for low\r\n\t//input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (High) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n//***// function betOnOdd_Even\r\n\t//bet type : parity\r\n     //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Odd) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n\r\n//***// function betOnDozen\r\n//     //bet type : dozen\r\n//     //input : 0 for first dozen\r\n//     //input : 1 for second dozen\r\n//     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n// //***// function betOnColumn\r\n//     //bet type : column\r\n//     //input : 0 for first column\r\n//     //input : 1 for second column\r\n//     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n     }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    { \r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Second) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (Third) \r\n        {\r\n             count+=1; \r\n             input=2;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\t    gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n\tevent Win(address player, uint8 result, uint value_won);\r\n\tevent Loss(address player, uint8 result, uint value_loss);\r\n\r\n    //check that player has to spin the wheel\r\n    modifier checkWaitingForSpin{\r\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\r\n\t_\r\n\t}\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) msg.sender.send(msg.value);\r\n        _\r\n    }\r\n\r\n//***//function to spin\r\n    function spinTheWheel()\r\n    checkWaitingForSpin\r\n    noEthSent\r\n    {\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired (200 blocks limit)\r\n\tuint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\r\n\tif (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\r\n    else\r\n\t{\r\n\t    uint8 wheelResult;\r\n        //Spin the wheel, Reset player status and record result\r\n\t\twheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\r\n\t\tupdateFirstActiveGamble(gambleIndex[msg.sender]);\r\n\t\tgambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\r\n        //check result against bet and pay if win\r\n\t\tcheckBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\r\n\t}\r\n    }\r\n\r\nfunction updateFirstActiveGamble(uint bet_id) private\r\n     {\r\n         if (bet_id==firstActiveGamble)\r\n         {   \r\n              uint index=firstActiveGamble;\r\n              while (true)\r\n              {\r\n                 if (index<gambles.length && gambles[index].spinned){\r\n                     index=index+1;\r\n                 }\r\n                 else {break; }\r\n               }\r\n              firstActiveGamble=index;\r\n              return;\r\n          }\r\n }\r\n\t\r\n//checks if there are expired gambles\r\nmodifier expireGambles{\r\n    if (  (gambles.length!=0 && gambles.length-1>=firstActiveGamble ) \r\n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number && !gambles[firstActiveGamble].spinned )  \r\n    { \r\n\tsolveBet(gambles[firstActiveGamble].player, 255, false, 0);\r\n        updateFirstActiveGamble(firstActiveGamble);\r\n    }\r\n        _\r\n}\r\n\t\r\n\r\n     //CHECK BETS FUNCTIONS private\r\n     function checkBetResult(uint8 result, BetTypes betType) private\r\n     {\r\n          //bet on Number\r\n          if (betType==BetTypes.number) checkBetNumber(result);\r\n          else if (betType==BetTypes.parity) checkBetParity(result);\r\n          else if (betType==BetTypes.color) checkBetColor(result);\r\n\t else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\r\n\t else if (betType==BetTypes.dozen) checkBetDozen(result);\r\n\telse if (betType==BetTypes.column) checkBetColumn(result);\r\n          updateMaxBet(); \r\n     }\r\n\r\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\r\n     {\r\n        playerStatus[msg.sender]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n            if (win)\r\n            {\r\n\t\t  gambles[gambleIndex[player]].win=true;\r\n\t\t  uint win_v = multiplier*bet_v;\r\n                  player.send(win_v);\r\n                  lossSinceChange+=win_v-bet_v;\r\n\t\t  Win(player, result, win_v);\r\n             }\r\n            else\r\n            {\r\n\t\tLoss(player, result, bet_v);\r\n                profitSinceChange+=bet_v;\r\n            }\r\n\r\n      }\r\n\r\n\r\n     // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n     function checkBetNumber(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result==gambles[gambleIndex[msg.sender]].input)\r\n\t    {\r\n                  win=true;  \r\n             }\r\n             solveBet(msg.sender, result,win,35);\r\n     }\r\n\r\n\r\n     // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n     function checkBetParity(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\r\n\t    {\r\n                  win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n        \r\n     }\r\n\t\r\n     // checkbet on lowhigh\r\n     // bet type : lowhigh\r\n     // input : 0 low, 1 high\r\n     function checkBetLowhigh(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t\t if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\r\n\t\t\t || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\r\n\t\t\t ) )\r\n\t    {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n     }\r\n\r\n     // checkbet on color\r\n     // bet type : color\r\n     // input : 0 red, 1 black\r\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n      function checkBetColor(uint8 result) private\r\n      {\r\n             bool red;\r\n             //check if red\r\n             for (uint8 k; k<18; k++)\r\n             { \r\n                    if (red_list[k]==result) \r\n                    { \r\n                          red=true; \r\n                          break;\r\n                    }\r\n             }\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n       }\r\n\r\n     // checkbet on dozen\r\n     // bet type : dozen\r\n     // input : 0 first, 1 second, 2 third\r\n     function checkBetDozen(uint8 result) private\r\n     { \r\n            bool win;\r\n            //win on first dozen\r\n     \t\t if ( result!=0 &&\r\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\r\n     \t\t\t||\r\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\r\n                    ||\r\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\r\n     \t    {\r\n                   win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n     }\r\n\r\n     // checkbet on column\r\n     // bet type : column\r\n     // input : 0 first, 1 second, 2 third\r\n      function checkBetColumn(uint8 result) private\r\n      {\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\r\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n      }\r\n\r\n\r\n//INVESTORS FUNCTIONS\r\n\r\n\r\n//total casino payroll\r\n    uint256 payroll;\r\n//Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n//investor struct array (hard capped to 150)\r\n    uint8 setting_maxInvestors = 50;\r\n    struct Investor\r\n    {\r\n\t    address investor;\r\n\t    uint256 time;\r\n    }\t\r\n\tInvestor[150] private investors ;\r\n    //Balances of the investors\r\n    mapping (address=>uint256) balance; \r\n    //Investor lockPeriod\r\n    //lock time to avoid invest and withdraw for refresh only\r\n    //also time during which you cannot be outbet by a new investor if it is full\r\n    uint256 setting_lockPeriod=604800 ; //1 week in sec\r\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\r\n    //if full and unlocked position, indicates the cheapest amount to outbid\r\n    //otherwise cheapestUnlockedPosition=255\r\n    uint8 cheapestUnlockedPosition; \r\n    uint256 minCurrentInvest; \r\n    //record open position index\r\n    // =255 if full\r\n    uint8 openPosition;\r\n\t\r\n    event newInvest(address player, uint invest_v);\r\n\r\n\r\n     function invest()\r\n     {\r\n          // check that min 10 ETH is sent (variable setting)\r\n          if (msg.value<setting_minInvestment) throw;\r\n          // check if already investor\r\n          bool alreadyInvestor;\r\n          // reset the position counters to values out of bounds\r\n          openPosition=255;\r\n          cheapestUnlockedPosition=255;\r\n          minCurrentInvest=10000000000000000000000000;//\r\n          // update balances before altering the investor shares\r\n          updateBalances();\r\n          // loop over investor's array to find if already investor, \r\n          // or openPosition and cheapest UnlockedPosition\r\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n          { \r\n               //captures an index of an open position\r\n               if (investors[k].investor==0) openPosition=k; \r\n               //captures if already an investor \r\n               else if (investors[k].investor==msg.sender)\r\n               {\r\n                    investors[k].time=now; //refresh time invest\r\n                    alreadyInvestor=true;\r\n                }\r\n               //captures the index of the investor with the min investment (after lock period)\r\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\r\n               {\r\n                    cheapestUnlockedPosition=k;\r\n                    minCurrentInvest=balance[investors[k].investor];\r\n                }\r\n           }\r\n           //case New investor\r\n           if (alreadyInvestor==false)\r\n           {\r\n                    //case : investor array not full, record new investor\r\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\r\n                    //case : investor array full\r\n                    else\r\n                    {\r\n                         //subcase : investor has not outbid or all positions under lock period\r\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\r\n                         //subcase : investor outbid, record investor change and refund previous\r\n                         else\r\n                         {\r\n                              address previous = investors[cheapestUnlockedPosition].investor;\r\n                              if (previous.send(balance[previous])==false) throw;\r\n                              balance[previous]=0;\r\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\r\n                          }\r\n                     }\r\n            }\r\n          //add investment to balance of investor and to payroll\r\n\r\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\r\n          uint256 netInvest=msg.value - maintenanceFees;\r\n          newInvest(msg.sender, netInvest);\r\n          balance[msg.sender]+=netInvest; //add invest to balance\r\n          payroll+=netInvest;\r\n          //send maintenance fees to developer \r\n          if (developer.send(maintenanceFees)==false) throw;\r\n          updateMaxBet();\r\n      }\r\n\r\n//***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min investment required,\r\n    // your balance is fully withdrawn\r\n\tevent withdraw(address player, uint withdraw_v);\r\n\t\r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve investor ID\r\n        uint8 investorID=255;\r\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n               if (investors[k].investor==msg.sender)\r\n               {\r\n                    investorID=k;\r\n                    break;\r\n               }\r\n        }\r\n           if (investorID==255) throw; //stop if not an investor\r\n           //check if investment lock period is over\r\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n           //if balance left after withdraw is still above min investment accept partial withdraw\r\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n           {\r\n               balance[msg.sender]-=amountToWithdrawInWei;\r\n               payroll-=amountToWithdrawInWei;\r\n               //send amount to investor (with security if transaction fails)\r\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t       withdraw(msg.sender, amountToWithdrawInWei);\r\n           }\r\n           else\r\n           //if amountToWithdraw=0 : user wants full withdraw\r\n           //if balance after withdraw is < min invest, withdraw all and delete investor\r\n           {\r\n               //send amount to investor (with security if transaction fails)\r\n               uint256 fullAmount=balance[msg.sender];\r\n               payroll-=fullAmount;\r\n               balance[msg.sender]=0;\r\n               if (msg.sender.send(fullAmount)==false) throw;\r\n               //delete investor\r\n               delete investors[investorID];\r\n   \t       withdraw(msg.sender, fullAmount);\r\n            }\r\n          updateMaxBet();\r\n     }\r\n\r\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\r\n\r\n\tfunction manualUpdateBalances()\r\n\texpireGambles\r\n\tnoEthSent\r\n\t{\r\n\t    updateBalances();\r\n\t}\r\n    function updateBalances() private\r\n    {\r\n         //split Profits\r\n         uint256 profitToSplit;\r\n         uint256 lossToSplit;\r\n         if (profitSinceChange==0 && lossSinceChange==0)\r\n         { return; }\r\n         \r\n         else\r\n         {\r\n             // Case : Global profit (more win than losses)\r\n             // 2% fees for developer on global profit (if profit>loss)\r\n             if (profitSinceChange>lossSinceChange)\r\n             {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*2/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n             }\r\n             else\r\n             {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n             }\r\n         \r\n         //share the loss and profits between all invest \r\n         //(proportionnaly. to each investor balance)\r\n         uint totalShared;\r\n             for (uint8 k=0; k<setting_maxInvestors; k++)\r\n             {\r\n                 address inv=investors[k].investor;\r\n                 if (inv==0) continue;\r\n                 else\r\n                 {\r\n                       if (profitToSplit!=0) \r\n                       {\r\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                           balance[inv]+=profitShare;\r\n                           totalShared+=profitShare;\r\n                       }\r\n                       if (lossToSplit!=0) \r\n                       {\r\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                           balance[inv]-=lossShare;\r\n                           totalShared+=lossShare;\r\n                           \r\n                       }\r\n                 }\r\n             }\r\n          // update payroll\r\n          if (profitToSplit !=0) \r\n          {\r\n              payroll+=profitToSplit;\r\n              balance[developer]+=profitToSplit-totalShared;\r\n          }\r\n          if (lossToSplit !=0) \r\n          {\r\n              payroll-=lossToSplit;\r\n              balance[developer]-=lossToSplit-totalShared;\r\n          }\r\n          profitSinceChange=0; //reset Profit;\r\n          lossSinceChange=0; //reset Loss ;\r\n          \r\n          }\r\n     }\r\n     \r\n     \r\n     //INFORMATION FUNCTIONS\r\n     \r\n     function checkProfitLossSinceInvestorChange() constant returns(uint profit, uint loss)\r\n     {\r\n        profit=profitSinceChange;\r\n        loss=lossSinceChange;\r\n        return;\r\n     }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n          balanceInWei=balance[investor];\r\n          return;\r\n     }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n          investor=investors[index].investor;\r\n          endLockPeriod=investors[index].time+setting_lockPeriod;\r\n          return;\r\n    }\r\n\t\r\n\r\n\tfunction investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\r\n\t{\r\n\t\tif (openPosition!=255) open_position=true;\r\n\t\tif (cheapestUnlockedPosition!=255) \r\n\t\t{\r\n\t\t\tunlocked_position=true;\r\n\t\t\tbuyout_amount=minCurrentInvest;\r\n\t\t}\r\n\t\tinvestLockPeriod=setting_lockPeriod;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfunction getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n\t{\r\n\t    maxBet=currentMaxGamble;\r\n\t    blockDelayBeforeSpin=blockDelay;\r\n\t    return ;\r\n\t}\r\n\t\r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\r\n    {\r\n          player_status=playerStatus[player];\r\n          bettype=gambles[gambleIndex[player]].betType;\r\n          input=gambles[gambleIndex[player]].input;\r\n          value=gambles[gambleIndex[player]].wager;\r\n          result=gambles[gambleIndex[player]].wheelResult;\r\n          wheelspinned=gambles[gambleIndex[player]].spinned;\r\n          win=gambles[gambleIndex[player]].win;\r\n\t\tblockNb=gambles[gambleIndex[player]].blockNumber;\r\n\t\t  return;\r\n     }\r\n\r\n} //end of contract","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amountToWithdrawInWei\",\"type\":\"uint256\"}],\"name\":\"withdrawInvestment\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkProfitLossSinceInvestorChange\",\"outputs\":[{\"name\":\"profit\",\"type\":\"uint256\"},{\"name\":\"loss\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_dev\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Red\",\"type\":\"bool\"},{\"name\":\"Black\",\"type\":\"bool\"}],\"name\":\"betOnColor\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableBetting\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCasinoStatLimit\",\"type\":\"uint256\"},{\"name\":\"newMaxBetsBlock\",\"type\":\"uint256\"},{\"name\":\"newMaxGamble\",\"type\":\"uint256\"},{\"name\":\"newMaxInvestor\",\"type\":\"uint8\"},{\"name\":\"newMinInvestment\",\"type\":\"uint256\"},{\"name\":\"newLockPeriod\",\"type\":\"uint256\"},{\"name\":\"newBlockDelay\",\"type\":\"uint8\"},{\"name\":\"newBlockExpiration\",\"type\":\"uint8\"}],\"name\":\"changeSettings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkMyBet\",\"outputs\":[{\"name\":\"player_status\",\"type\":\"uint8\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorList\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"endLockPeriod\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"name\":\"maxBet\",\"type\":\"uint256\"},{\"name\":\"blockDelayBeforeSpin\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Low\",\"type\":\"bool\"},{\"name\":\"High\",\"type\":\"bool\"}],\"name\":\"betOnLowHigh\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualUpdateBalances\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberChosen\",\"type\":\"uint8\"}],\"name\":\"betOnNumber\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Odd\",\"type\":\"bool\"},{\"name\":\"Even\",\"type\":\"bool\"}],\"name\":\"betOnOddEven\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"First\",\"type\":\"bool\"},{\"name\":\"Second\",\"type\":\"bool\"},{\"name\":\"Third\",\"type\":\"bool\"}],\"name\":\"betOnDozen\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBetting\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"spinTheWheel\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"First\",\"type\":\"bool\"},{\"name\":\"Second\",\"type\":\"bool\"},{\"name\":\"Third\",\"type\":\"bool\"}],\"name\":\"betOnColumn\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"checkInvestorBalance\",\"outputs\":[{\"name\":\"balanceInWei\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentEntryCost\",\"outputs\":[{\"name\":\"open_position\",\"type\":\"bool\"},{\"name\":\"unlocked_position\",\"type\":\"bool\"},{\"name\":\"buyout_amount\",\"type\":\"uint256\"},{\"name\":\"investLockPeriod\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_won\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_loss\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invest_v\",\"type\":\"uint256\"}],\"name\":\"newInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdraw_v\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"type\":\"event\"}]","ContractName":"Rouleth","CompilerVersion":"v0.3.1-2016-03-31-c492d9b","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}