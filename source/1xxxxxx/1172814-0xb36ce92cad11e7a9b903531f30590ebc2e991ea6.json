{"status":"1","message":"OK","result":[{"SourceCode":"contract Big{\r\n    function Big(){\r\n        Creator=msg.sender;\r\n    }\r\n\r\n    uint8 CategoriesLength=0;\r\n    mapping(uint8=>Category) Categories;//array representation\r\n    struct Category{\r\n        bytes4 Id;\r\n        uint Sum;//moneys sum for category\r\n\r\n        address Owner;\r\n        uint8 ProjectsFee;\r\n        uint8 OwnerFee;\r\n\r\n        uint24 VotesCount;\r\n        mapping(address=>uint24) Ranks;//small contract addr->rank\r\n        mapping(uint24=>Vote) Votes;//array representation\r\n    }\r\n    struct Vote{\r\n        address From;\r\n        address To;\r\n\t\tuint8 TransactionId;\r\n    }\r\n    uint24 SmallContractsLength=0; \r\n    mapping(uint24=>address) SmallContracts;//array of small contracts\r\n    \r\n    address private Creator;//addres of god\r\n    uint16 constant defaultRank=1000;\r\n    uint8 constant koef=2/1;\r\n\tuint constant ThanksCost = 10 finney;\r\n\r\n    function GetCategoryNumber(bytes4 categoryId) returns(uint8) {\r\n        for (uint8 i=0;i<CategoriesLength;i++){\r\n            if(Categories[i].Id==categoryId)\r\n                return i;\r\n        }\r\n        return 255;\r\n    }\r\n    function GetCategoryValue(uint8 categoryNumber) returns (uint){ \r\n        return Categories[categoryNumber].Sum;\r\n    }\r\n\tfunction CheckUserVote(uint8 categoryNumber,uint8 transactionId) returns (bool){\r\n\t\tfor (uint24 i = Categories[categoryNumber].VotesCount-1;i >0;i--){\r\n            if(Categories[categoryNumber].Votes[i].TransactionId==transactionId) \r\n                return true;     \r\n        }\r\n\t\tif(Categories[categoryNumber].Votes[0].TransactionId==transactionId){\r\n                return true;  \r\n        }\r\n\t\treturn false;\r\n\t}\r\n    function GetUserRank(uint8 categoryNumber,address user) returns (uint24){ \r\n        return Categories[categoryNumber].Ranks[user];\r\n    }\r\n    function GetSmallCotractIndex(address small) returns (uint24){\r\n        for (uint24 i=0;i<SmallContractsLength;i++){\r\n            if(SmallContracts[i]==small)\r\n                return i;\r\n        }\r\n        return 16777215;\r\n    }\r\n    \r\n    function AddNewSmallContract(address small){\r\n        if(msg.sender == Creator && GetSmallCotractIndex(small)==16777215){\r\n                SmallContracts[SmallContractsLength]=small;\r\n                SmallContractsLength++;\r\n        }\r\n    }\r\n    function AddNewCategory(bytes4 categoryId,uint8 projectsFee,uint8 ownerFee, address owner){\r\n        if(msg.sender == Creator && GetCategoryNumber(categoryId)==255){\r\n            Categories[CategoriesLength].Id= categoryId;\r\n            Categories[CategoriesLength].ProjectsFee= projectsFee;\r\n            Categories[CategoriesLength].OwnerFee= ownerFee;\r\n            Categories[CategoriesLength].Owner= owner;\r\n            Categories[CategoriesLength].Sum = 0;\r\n            CategoriesLength++;\r\n        }\r\n    }\r\n\r\n    \r\n\tstruct Calculation{\r\n\t\tuint16 totalVotes;\r\n\t\tuint24 rank;\r\n\t}\r\n    function CalcAll(){\r\n        if(msg.sender==Creator){//only god can call this method\r\n            uint24 i;//iterator variable\r\n\t\t\t\r\n            for(uint8 prC=0; prC<CategoriesLength; prC++){\r\n                Category category = Categories[prC];\r\n                \r\n                uint16 smallsCount = 0;//count of small contracts that got some rank\r\n                mapping(address=>Calculation) temporary;//who->votesCount  (tootal voes from address)\r\n                //calc users total votes          \r\n\t\t\t\t\r\n\t\t\t\tfor (i = 0;i < category.VotesCount;i++){\r\n                    temporary[category.Votes[i].From].totalVotes = 0; \r\n                }\t\r\n\t\t\t\t\r\n                for (i = 0;i < category.VotesCount;i++){\r\n\t\t\t\t\tif(temporary[category.Votes[i].From].totalVotes == 0) {\r\n\t\t\t\t\t\ttemporary[category.Votes[i].From].rank = category.Ranks[category.Votes[i].From];\r\n\t\t\t\t\t}\r\n                    temporary[category.Votes[i].From].totalVotes++; \r\n\t\t\t\t\t\r\n                }\t\t\t\r\n\t\t\t\t\r\n                // calculate new additional ranks\r\n                for (i = 0;i < category.VotesCount;i++){ //iterate for each vote in category\r\n                    Vote vote=category.Votes[i];\r\n                    category.Ranks[vote.To] += temporary[vote.From].rank / (temporary[vote.From].totalVotes * koef);//add this vote weight\r\n\t\t\t\t\t\t\t\t// weight of vote measures in the (voters rank/( count of voters total thanks * 2)\r\n                }                          \r\n            }\r\n        }\r\n    }\r\n    \r\n    function NormalizeMoney(){\r\n        if(msg.sender==Creator){\r\n            uint sumDifference=this.balance;\r\n            uint transactionCost = 5 finney;\r\n\t\t\tuint8 luckyCategoryIndex = 255;\r\n\t\t\t\r\n        \tfor (uint8 prC = 0;prC < CategoriesLength;prC++) {\r\n        \t    sumDifference -= Categories[prC].Sum;\r\n        \t    \r\n        \t    uint ownerFee = (Categories[prC].Sum * Categories[prC].OwnerFee) / 100;\r\n        \t    if (ownerFee >0) Categories[prC].Owner.send(ownerFee);\r\n        \t    Categories[prC].Sum -= ownerFee;\r\n        \t    \r\n            \tif (luckyCategoryIndex == 255 && Categories[prC].Sum > transactionCost){\r\n            \t    luckyCategoryIndex = prC;\r\n            \t}\r\n        \t}\r\n        \t\r\n        \tif (sumDifference > transactionCost){\r\n        \t    Creator.send(sumDifference - transactionCost);\r\n        \t}\r\n        \telse{\r\n        \t    if (luckyCategoryIndex != 255){\r\n        \t        Categories[luckyCategoryIndex].Sum -= (transactionCost - sumDifference);\r\n        \t    }\r\n        \t}\r\n        }\r\n    }\r\n    \r\n\tfunction NormalizeRanks(){\r\n\t\tif(msg.sender==Creator){\r\n\t\t\tuint32 accuracyKoef = 100000; //magic number 100000 is for accuracy\r\n\t\t\r\n\t\t\tuint24 i=0;\r\n\t\t\tfor(uint8 prC=0; prC<CategoriesLength; prC++){\r\n                Category category = Categories[prC];\r\n\t\t\t\tuint additionalRanksSum = 0; //sum of all computed additional ranks (rank - default rank) in category\r\n\t\t\t\tuint16 activeSmallContractsInCategoryCount = 0;\r\n\r\n\t\t\t\tfor(i = 0;i<SmallContractsLength;i++){\r\n\t\t\t\t\tif (category.Ranks[SmallContracts[i]] != 0){\r\n\t\t\t\t\t\tadditionalRanksSum += category.Ranks[SmallContracts[i]] - defaultRank;\r\n\t\t\t\t\t\tactiveSmallContractsInCategoryCount++;\r\n\t\t\t\t\t}\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (additionalRanksSum > activeSmallContractsInCategoryCount * defaultRank)//normalize ranks if addition of ranks is more than all users can have\r\n                {\r\n\t\t\t\t\tuint24 normKoef = uint24(additionalRanksSum / activeSmallContractsInCategoryCount);\r\n\t\t\t\t\tfor (i = 0;i < SmallContractsLength;i++){\r\n\t\t\t\t\t\tif (category.Ranks[SmallContracts[i]] > defaultRank){\r\n\t\t\t\t\t\t\tcategory.Ranks[SmallContracts[i]] = defaultRank + uint24(((uint)(category.Ranks[SmallContracts[i]] - defaultRank) * defaultRank)/ normKoef);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tadditionalRanksSum = activeSmallContractsInCategoryCount * defaultRank;\r\n                }\r\n\t\t\t\tif (category.Sum > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (i = 0;i < SmallContractsLength;i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (category.Ranks[SmallContracts[i]] > defaultRank)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//just split sum in deendence of what rank users have\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tsmallContractsIncoming[i] += accuracyKoef*(category.Sum / (accuracyKoef*additionalRanksSum / (category.Ranks[SmallContracts[i]] - defaultRank)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t}\r\n    mapping(uint24=> uint) smallContractsIncoming;//stores ether count per small contract\r\n    function SendAllMoney(){\r\n        if(msg.sender==Creator) { \r\n            for (uint24 i = 0;i < SmallContractsLength;i++){\r\n                if(smallContractsIncoming[i] > 0 ){//if more than 0.005 ether\r\n                    SmallContracts[i].send(smallContractsIncoming[i]);//send ether to wallet\r\n                    smallContractsIncoming[i]=0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function Reset(){\r\n        if(msg.sender==Creator) { \r\n            for(uint8 prC=0; prC<CategoriesLength; prC++){//in each contract\r\n              Categories[prC].VotesCount=0; //reset votes\r\n              Categories[prC].Sum=0; //reset ether sum \r\n            }\r\n        }\r\n    }\r\n\r\n    function GetMoney(uint weiAmount,address to){\r\n        if(msg.sender==Creator) { \r\n            to.send(weiAmount);\r\n        }\r\n    }\r\n    function SetRank(uint8 categoryNumber,address small,uint16 rank){\r\n        if(msg.sender == Creator){\r\n            Category category=Categories[categoryNumber];\r\n            category.Ranks[small]=rank;\r\n        }\r\n    }\r\n\t\r\n\tfunction SetNewBigContract(address newBigContractAddress){\r\n\t\tif(msg.sender == Creator){\r\n\t\t\tfor(uint24 i = 0;i<SmallContractsLength;i++){\r\n\t\t\t\tSmall s= Small(SmallContracts[i]);\t\r\n\t\t\t\ts.SetBigContract(newBigContractAddress);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n    \r\n\tfunction ThanksInternal (address from,address to, uint8 categoryNumber,uint8 transactionId) private {\r\n        if(categoryNumber==255||GetSmallCotractIndex(from)==16777215||GetSmallCotractIndex(to)==16777215) return;\r\n        \r\n        Category category=Categories[categoryNumber];\r\n\t\t\r\n\t\tSmall s= Small(from);\r\n        s.GetMoney(ThanksCost,this);\t\r\n        category.Sum+=ThanksCost;\r\n        \r\n        if(category.Ranks[from]==0){\r\n            category.Ranks[from]=defaultRank;\r\n        }      \r\n        if(category.Ranks[to]==0){\r\n            category.Ranks[to]=defaultRank;\r\n        }\r\n\r\n\t\tcategory.Votes[category.VotesCount].From=from;\r\n        category.Votes[category.VotesCount].To=to;\r\n\t\tcategory.Votes[category.VotesCount].TransactionId=transactionId;\r\n        category.VotesCount++;\r\n    }\t\r\n\tfunction Thanks (address from,address to,uint8 categoryNumber,uint8 transactionId){\r\n\t\tif(msg.sender != Creator) return;\t\r\n\t\tThanksInternal(from,to,categoryNumber,transactionId);\r\n\t}\r\n\t\r\n    function UniversalFunction(uint8 functionNumber,bytes32 p1,bytes32 p2,bytes32 p3,bytes32 p4,bytes32 p5){\r\n        if(GetSmallCotractIndex(msg.sender)==16777215) return;\r\n        \r\n        if(functionNumber == 1){\r\n            ThanksInternal(msg.sender,address(p1),uint8(p2),0);\r\n        }\r\n        if(functionNumber == 2){\r\n            Small s= Small(msg.sender);\r\n            s.GetMoney(uint(p1),address(p2));\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Small {\r\n    Big b;\r\n  \r\n    address private owner;\r\n\r\n    function Small(address bigAddress){\r\n        b=Big(bigAddress);\r\n        owner = msg.sender;\r\n    }\r\n    function GetOwner() returns (address){\r\n        return owner;\r\n    }\r\n    function SetOwner(address newOwner){\r\n        if(msg.sender == owner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function SetBigContract(address newAddress){\r\n        if(msg.sender==address(b)) { \r\n            b=Big(newAddress);\r\n        }\r\n    }\r\n    function GetMoney(uint weiAmount,address toAddress){\r\n        if(msg.sender==address(b)) { \r\n            toAddress.send(weiAmount);\r\n        }\r\n    }\r\n    function UniversalFunctionSecure(uint8 functionNumber,bytes32 p1,bytes32 p2,bytes32 p3,bytes32 p4,bytes32 p5){\r\n        if(msg.sender == owner) {\r\n            b.UniversalFunction(functionNumber,p1,p2,p3,p4,p5);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"categoryNumber\",\"type\":\"uint8\"},{\"name\":\"transactionId\",\"type\":\"uint8\"}],\"name\":\"Thanks\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"categoryNumber\",\"type\":\"uint8\"},{\"name\":\"transactionId\",\"type\":\"uint8\"}],\"name\":\"CheckUserVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"categoryId\",\"type\":\"bytes4\"},{\"name\":\"projectsFee\",\"type\":\"uint8\"},{\"name\":\"ownerFee\",\"type\":\"uint8\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AddNewCategory\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"NormalizeRanks\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"SendAllMoney\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"GetMoney\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBigContractAddress\",\"type\":\"address\"}],\"name\":\"SetNewBigContract\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CalcAll\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"functionNumber\",\"type\":\"uint8\"},{\"name\":\"p1\",\"type\":\"bytes32\"},{\"name\":\"p2\",\"type\":\"bytes32\"},{\"name\":\"p3\",\"type\":\"bytes32\"},{\"name\":\"p4\",\"type\":\"bytes32\"},{\"name\":\"p5\",\"type\":\"bytes32\"}],\"name\":\"UniversalFunction\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Reset\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"categoryNumber\",\"type\":\"uint8\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"GetUserRank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"categoryNumber\",\"type\":\"uint8\"}],\"name\":\"GetCategoryValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"small\",\"type\":\"address\"}],\"name\":\"AddNewSmallContract\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"categoryId\",\"type\":\"bytes4\"}],\"name\":\"GetCategoryNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"small\",\"type\":\"address\"}],\"name\":\"GetSmallCotractIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"NormalizeMoney\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"categoryNumber\",\"type\":\"uint8\"},{\"name\":\"small\",\"type\":\"address\"},{\"name\":\"rank\",\"type\":\"uint16\"}],\"name\":\"SetRank\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"Big","CompilerVersion":"v0.3.0-2016-03-18-e759a24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}