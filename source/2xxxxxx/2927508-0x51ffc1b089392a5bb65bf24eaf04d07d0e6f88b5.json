{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n/*\r\nThis vSlice token contract is based on the ERC20 token contract. Additional\r\nfunctionality has been integrated:\r\n* the contract Lockable, which is used as a parent of the Token contract\r\n* the function mintTokens(), which makes use of the currentSwapRate() and safeToAdd() helpers\r\n* the function disableTokenSwapLock()\r\n*/\r\n\r\ncontract Lockable {\r\n    uint public numOfCurrentEpoch;\r\n    uint public creationTime;\r\n    uint public constant UNLOCKED_TIME = 25 days;\r\n    uint public constant LOCKED_TIME = 5 days;\r\n    uint public constant EPOCH_LENGTH = 30 days;\r\n    bool public lock;\r\n    bool public tokenSwapLock;\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    // This modifier should prevent tokens transfers while the tokenswap\r\n    // is still ongoing\r\n    modifier isTokenSwapOn {\r\n        if (tokenSwapLock) throw;\r\n        _;\r\n    }\r\n\r\n    // This modifier checks and, if needed, updates the value of current\r\n    // token contract epoch, before executing a token transfer of any\r\n    // kind\r\n    modifier isNewEpoch {\r\n        if (numOfCurrentEpoch * EPOCH_LENGTH + creationTime < now ) {\r\n            numOfCurrentEpoch = (now - creationTime) / EPOCH_LENGTH + 1;\r\n        }\r\n        _;\r\n    }\r\n\r\n    // This modifier check whether the contract should be in a locked\r\n    // or unlocked state, then acts and updates accordingly if\r\n    // necessary\r\n    modifier checkLock {\r\n        if ((creationTime + numOfCurrentEpoch * UNLOCKED_TIME) +\r\n        (numOfCurrentEpoch - 1) * LOCKED_TIME < now) {\r\n            // avoids needless lock state change and event spamming\r\n            if (lock) throw;\r\n\r\n            lock = true;\r\n            Locked();\r\n            return;\r\n        }\r\n        else {\r\n            // only set to false if in a locked state, to avoid\r\n            // needless state change and event spam\r\n            if (lock) {\r\n                lock = false;\r\n                Unlocked();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    function Lockable() {\r\n        creationTime = now;\r\n        numOfCurrentEpoch = 1;\r\n        tokenSwapLock = true;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint);\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Token is ERC20, Lockable {\r\n\r\n  mapping( address => uint ) _balances;\r\n  mapping( address => mapping( address => uint ) ) _approvals;\r\n  uint _supply;\r\n  address public walletAddress;\r\n\r\n  event TokenMint(address newTokenHolder, uint amountOfTokens);\r\n  event TokenSwapOver();\r\n\r\n  modifier onlyFromWallet {\r\n      if (msg.sender != walletAddress) throw;\r\n      _;\r\n  }\r\n\r\n  function Token( uint initial_balance, address wallet) {\r\n    _balances[msg.sender] = initial_balance;\r\n    _supply = initial_balance;\r\n    walletAddress = wallet;\r\n  }\r\n\r\n  function totalSupply() constant returns (uint supply) {\r\n    return _supply;\r\n  }\r\n\r\n  function balanceOf( address who ) constant returns (uint value) {\r\n    return _balances[who];\r\n  }\r\n\r\n  function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n    return _approvals[owner][spender];\r\n  }\r\n\r\n  // A helper to notify if overflow occurs\r\n  function safeToAdd(uint a, uint b) internal returns (bool) {\r\n    return (a + b >= a && a + b >= b);\r\n  }\r\n\r\n  function transfer( address to, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n\r\n    if( _balances[msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n\r\n    _balances[msg.sender] -= value;\r\n    _balances[to] += value;\r\n    Transfer( msg.sender, to, value );\r\n    return true;\r\n  }\r\n\r\n  function transferFrom( address from, address to, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n    // if you don't have enough balance, throw\r\n    if( _balances[from] < value ) {\r\n        throw;\r\n    }\r\n    // if you don't have approval, throw\r\n    if( _approvals[from][msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n    // transfer and return true\r\n    _approvals[from][msg.sender] -= value;\r\n    _balances[from] -= value;\r\n    _balances[to] += value;\r\n    Transfer( from, to, value );\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n    _approvals[msg.sender][spender] = value;\r\n    Approval( msg.sender, spender, value );\r\n    return true;\r\n  }\r\n\r\n  // The function currentSwapRate() returns the current exchange rate\r\n  // between vSlice tokens and Ether during the token swap period\r\n  function currentSwapRate() constant returns(uint) {\r\n      if (creationTime + 1 weeks > now) {\r\n          return 130;\r\n      }\r\n      else if (creationTime + 2 weeks > now) {\r\n          return 120;\r\n      }\r\n      else if (creationTime + 4 weeks > now) {\r\n          return 100;\r\n      }\r\n      else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  // The function mintTokens is only usable by the chosen wallet\r\n  // contract to mint a number of tokens proportional to the\r\n  // amount of ether sent to the wallet contract. The function\r\n  // can only be called during the tokenswap period\r\n  function mintTokens(address newTokenHolder, uint etherAmount)\r\n    external\r\n    onlyFromWallet {\r\n\r\n        uint tokensAmount = currentSwapRate() * etherAmount;\r\n        if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw;\r\n        if(!safeToAdd(_supply,tokensAmount)) throw;\r\n\r\n        _balances[newTokenHolder] += tokensAmount;\r\n        _supply += tokensAmount;\r\n\r\n        TokenMint(newTokenHolder, tokensAmount);\r\n  }\r\n\r\n  // The function disableTokenSwapLock() is called by the wallet\r\n  // contract once the token swap has reached its end conditions\r\n  function disableTokenSwapLock()\r\n    external\r\n    onlyFromWallet {\r\n        tokenSwapLock = false;\r\n        TokenSwapOver();\r\n  }\r\n}\r\n\r\n\r\npragma solidity ^0.4.0;\r\n/*\r\nThe ProfitContainer contract receives profits from the vDice games and allows a\r\na fair distribution between token holders.\r\n*/\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner)\r\n      external\r\n      onlyOwner {\r\n      if (_newOwner == address(0x0)) throw;\r\n      owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ProfitContainer is Ownable {\r\n    uint public currentEpoch;\r\n    //This is to mitigate supersend and the possibility of\r\n    //different payouts for same token ownership during payout phase\r\n    uint public initEpochBalance;\r\n    mapping (address => uint) lastPaidOutEpoch;\r\n    Token public tokenCtr;\r\n\r\n    event WithdrawalEnabled();\r\n    event ProfitWithdrawn(address tokenHolder, uint amountPaidOut);\r\n    event TokenContractChanged(address newTokenContractAddr);\r\n\r\n    // The modifier onlyNotPaidOut prevents token holders who have\r\n    // already withdrawn their share of profits in the epoch, to cash\r\n    // out additional shares.\r\n    modifier onlyNotPaidOut {\r\n        if (lastPaidOutEpoch[msg.sender] == currentEpoch) throw;\r\n        _;\r\n    }\r\n\r\n    // The modifier onlyLocked prevents token holders from collecting\r\n    // their profits when the token contract is in an unlocked state\r\n    modifier onlyLocked {\r\n        if (!tokenCtr.lock()) throw;\r\n        _;\r\n    }\r\n\r\n    // The modifier resetPaidOut updates the currenct epoch, and\r\n    // enables the smart contract to track when a token holder\r\n    // has already received their fair share of profits or not\r\n    // and sets the balance for the epoch using current balance\r\n    modifier resetPaidOut {\r\n        if(currentEpoch < tokenCtr.numOfCurrentEpoch()) {\r\n            currentEpoch = tokenCtr.numOfCurrentEpoch();\r\n            initEpochBalance = this.balance;\r\n            WithdrawalEnabled();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function ProfitContainer(address _token) {\r\n        tokenCtr = Token(_token);\r\n    }\r\n\r\n    function ()\r\n        payable {\r\n\r\n    }\r\n\r\n    // The function withdrawalProfit() enables token holders\r\n    // to collect a fair share of profits from the ProfitContainer,\r\n    // proportional to the amount of tokens they own. Token holders\r\n    // will be able to collect their profits only once\r\n    function withdrawalProfit()\r\n        external\r\n        resetPaidOut\r\n        onlyLocked\r\n        onlyNotPaidOut {\r\n        uint currentEpoch = tokenCtr.numOfCurrentEpoch();\r\n        uint tokenBalance = tokenCtr.balanceOf(msg.sender);\r\n        uint totalSupply = tokenCtr.totalSupply();\r\n\r\n        if (tokenBalance == 0) throw;\r\n\r\n        lastPaidOutEpoch[msg.sender] = currentEpoch;\r\n\r\n        // Overflow risk only exists if balance is greater than\r\n        // 1e+33 ether, assuming max of 96M tokens minted.\r\n        // Functions throws, as such a state should never be reached\r\n        // Unless significantly more tokens are minted\r\n        if (!safeToMultiply(tokenBalance, initEpochBalance)) throw;\r\n        uint senderPortion = (tokenBalance * initEpochBalance);\r\n\r\n        uint amountToPayOut = senderPortion / totalSupply;\r\n\r\n        if(!msg.sender.send(amountToPayOut)) {\r\n            throw;\r\n        }\r\n\r\n        ProfitWithdrawn(msg.sender, amountToPayOut);\r\n    }\r\n\r\n    function changeTokenContract(address _newToken)\r\n        external\r\n        onlyOwner {\r\n\r\n        if (_newToken == address(0x0)) throw;\r\n\r\n        tokenCtr = Token(_newToken);\r\n        TokenContractChanged(_newToken);\r\n    }\r\n\r\n    // returns expected payout for tokenholder during lock phase\r\n    function expectedPayout(address _tokenHolder)\r\n        external\r\n        constant returns (uint) {\r\n\r\n        if (!tokenCtr.lock())\r\n            return 0;\r\n\r\n        return (tokenCtr.balanceOf(_tokenHolder) * initEpochBalance) / tokenCtr.totalSupply();\r\n    }\r\n\r\n    function safeToMultiply(uint _a, uint _b)\r\n        private\r\n        constant returns (bool) {\r\n\r\n        return (_b == 0 || ((_a * _b) / _b) == _a);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawalProfit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"expectedPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initEpochBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newToken\",\"type\":\"address\"}],\"name\":\"changeTokenContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCtr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"WithdrawalEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountPaidOut\",\"type\":\"uint256\"}],\"name\":\"ProfitWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newTokenContractAddr\",\"type\":\"address\"}],\"name\":\"TokenContractChanged\",\"type\":\"event\"}]","ContractName":"ProfitContainer","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c543e7ae0a1104f78406c340e9c64fd9fce5170","Library":"","SwarmSource":""}]}