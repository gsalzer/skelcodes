{"status":"1","message":"OK","result":[{"SourceCode":"contract Assertive {\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\ncontract MutexUser {\r\n    bool private lock;\r\n    modifier exclusive {\r\n        if (lock) throw;\r\n        lock = true;\r\n        _\r\n        lock = false;\r\n    }\r\n}\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint);\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract FallbackFailer {\r\n  function () {\r\n    throw;\r\n  }\r\n}\r\n\r\n// A simple direct exchange order manager.\r\n\r\ncontract EventfulMarket {\r\n    event ItemUpdate( uint id );\r\n    event Trade( uint sell_how_much, address indexed sell_which_token,\r\n                 uint buy_how_much, address indexed buy_which_token );\r\n}\r\ncontract SimpleMarket is EventfulMarket\r\n                       , Assertive\r\n                       , FallbackFailer\r\n                       , MutexUser\r\n{\r\n    struct OfferInfo {\r\n        uint sell_how_much;\r\n        ERC20 sell_which_token;\r\n        uint buy_how_much;\r\n        ERC20 buy_which_token;\r\n        address owner;\r\n        bool active;\r\n    }\r\n    mapping( uint => OfferInfo ) public offers;\r\n\r\n    uint public last_offer_id;\r\n\r\n    function next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _\r\n    }\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        _\r\n    }\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(getOwner(id) == msg.sender);\r\n        _\r\n    }\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\r\n      var offer = offers[id];\r\n      return (offer.sell_how_much, offer.sell_which_token,\r\n              offer.buy_how_much, offer.buy_which_token);\r\n    }\r\n\r\n    // non underflowing subtraction\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    // non overflowing multiplication\r\n    function safeMul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n\r\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\r\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\r\n        internal\r\n    {\r\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\r\n        assert(seller_paid_out);\r\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\r\n        assert(buyer_paid_out);\r\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer( uint sell_how_much, ERC20 sell_which_token\r\n                  , uint buy_how_much,  ERC20 buy_which_token )\r\n        can_offer\r\n        exclusive\r\n        returns (uint id)\r\n    {\r\n        assert(sell_how_much > 0);\r\n        assert(sell_which_token != ERC20(0x0));\r\n        assert(buy_how_much > 0);\r\n        assert(buy_which_token != ERC20(0x0));\r\n        assert(sell_which_token != buy_which_token);\r\n\r\n        OfferInfo memory info;\r\n        info.sell_how_much = sell_how_much;\r\n        info.sell_which_token = sell_which_token;\r\n        info.buy_how_much = buy_how_much;\r\n        info.buy_which_token = buy_which_token;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        id = next_id();\r\n        offers[id] = info;\r\n\r\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\r\n        assert(seller_paid);\r\n\r\n        ItemUpdate(id);\r\n    }\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy( uint id, uint quantity )\r\n        can_buy(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n\r\n        // inferred quantity that the buyer wishes to spend\r\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\r\n\r\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\r\n            // buyer wants more than is available\r\n            success = false;\r\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\r\n            // buyer wants exactly what is available\r\n            delete offers[id];\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                   msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else if ( spend > 0 && quantity > 0 ) {\r\n            // buyer wants a fraction of what is available\r\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\r\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                    msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else {\r\n            // buyer wants an unsatisfiable amount (less than 1 integer)\r\n            success = false;\r\n        }\r\n    }\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel( uint id )\r\n        can_cancel(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\r\n        assert(seller_refunded);\r\n\r\n        ItemUpdate(id);\r\n        success = true;\r\n    }\r\n}\r\n\r\n// Simple Market with a market lifetime. When the lifetime has elapsed,\r\n// offers can only be cancelled (offer and buy will throw).\r\n\r\ncontract ExpiringMarket is SimpleMarket {\r\n    uint public close_time;\r\n    function ExpiringMarket(uint lifetime) {\r\n        close_time = getTime() + lifetime;\r\n    }\r\n    function getTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n    function isClosed() constant returns (bool closed) {\r\n        return (getTime() > close_time);\r\n    }\r\n\r\n    // after market lifetime has elapsed, no new offers are allowed\r\n    modifier can_offer {\r\n        assert(!isClosed());\r\n        _\r\n    }\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        assert(!isClosed());\r\n        _\r\n    }\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(isClosed() || (msg.sender == getOwner(id)));\r\n        _\r\n    }\r\n}\r\n\r\n// Flat file implementation of `dappsys/token/base.sol::DSTokenBase`\r\n\r\n// Everything throws instead of returning false on failure.\r\n\r\ncontract ERC20Base is ERC20\r\n{\r\n    mapping( address => uint ) _balances;\r\n    mapping( address => mapping( address => uint ) ) _approvals;\r\n    uint _supply;\r\n    function ERC20Base( uint initial_balance ) {\r\n        _balances[msg.sender] = initial_balance;\r\n        _supply = initial_balance;\r\n    }\r\n    function totalSupply() constant returns (uint supply) {\r\n        return _supply;\r\n    }\r\n    function balanceOf( address who ) constant returns (uint value) {\r\n        return _balances[who];\r\n    }\r\n    function transfer( address to, uint value) returns (bool ok) {\r\n        if( _balances[msg.sender] < value ) {\r\n            throw;\r\n        }\r\n        if( !safeToAdd(_balances[to], value) ) {\r\n            throw;\r\n        }\r\n        _balances[msg.sender] -= value;\r\n        _balances[to] += value;\r\n        Transfer( msg.sender, to, value );\r\n        return true;\r\n    }\r\n    function transferFrom( address from, address to, uint value) returns (bool ok) {\r\n        // if you don't have enough balance, throw\r\n        if( _balances[from] < value ) {\r\n            throw;\r\n        }\r\n        // if you don't have approval, throw\r\n        if( _approvals[from][msg.sender] < value ) {\r\n            throw;\r\n        }\r\n        if( !safeToAdd(_balances[to], value) ) {\r\n            throw;\r\n        }\r\n        // transfer and return true\r\n        _approvals[from][msg.sender] -= value;\r\n        _balances[from] -= value;\r\n        _balances[to] += value;\r\n        Transfer( from, to, value );\r\n        return true;\r\n    }\r\n    function approve(address spender, uint value) returns (bool ok) {\r\n        _approvals[msg.sender][spender] = value;\r\n        Approval( msg.sender, spender, value );\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n        return _approvals[owner][spender];\r\n    }\r\n    function safeToAdd(uint a, uint b) internal returns (bool) {\r\n        return (a + b >= a);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"last_offer_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"close_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"name\":\"sell_how_much\",\"type\":\"uint256\"},{\"name\":\"sell_which_token\",\"type\":\"address\"},{\"name\":\"buy_how_much\",\"type\":\"uint256\"},{\"name\":\"buy_which_token\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"active\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isClosed\",\"outputs\":[{\"name\":\"closed\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sell_how_much\",\"type\":\"uint256\"},{\"name\":\"sell_which_token\",\"type\":\"address\"},{\"name\":\"buy_how_much\",\"type\":\"uint256\"},{\"name\":\"buy_which_token\",\"type\":\"address\"}],\"name\":\"offer\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"lifetime\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ItemUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sell_how_much\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sell_which_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buy_how_much\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buy_which_token\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"}]","ContractName":"ExpiringMarket","CompilerVersion":"v0.3.6-2016-08-10-e2a46b6","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000093a80","Library":"","SwarmSource":""}]}