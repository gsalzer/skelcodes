{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Manager smart contract is used for the management of accounts and tokens.\r\n *\r\n * Recipient is 0 for the Dao account manager and the address of\r\n * contractor's recipient for the contractors's mahagers.\r\n *\r\n*/\r\n\r\n/// @title Manager smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassManagerInterface {\r\n\r\n    struct proposal {\r\n        // Amount (in wei) of the proposal\r\n        uint amount;\r\n        // A description of the proposal\r\n        string description;\r\n        // The hash of the proposal's document\r\n        bytes32 hashOfTheDocument;\r\n        // A unix timestamp, denoting the date when the proposal was created\r\n        uint dateOfProposal;\r\n        // The index of the last approved client proposal\r\n        uint lastClientProposalID;\r\n        // The sum amount (in wei) ordered for this proposal \r\n        uint orderAmount;\r\n        // A unix timestamp, denoting the date of the last order for the approved proposal\r\n        uint dateOfOrder;\r\n    }\r\n        \r\n    // Proposals to work for the client\r\n    proposal[] public proposals;\r\n\r\n    struct fundingData {\r\n        // True if public funding without a main partner\r\n        bool publicCreation; \r\n        // The address which sets partners and manages the funding in case of private funding\r\n        address mainPartner;\r\n        // The maximum amount (in wei) of the funding\r\n        uint maxAmountToFund;\r\n        // The actual funded amount (in wei)\r\n        uint fundedAmount;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint startTime; \r\n        // A unix timestamp, denoting the closing time of the funding\r\n        uint closingTime;  \r\n        // The price multiplier for a share or a token without considering the inflation rate\r\n        uint initialPriceMultiplier;\r\n        // Rate per year in percentage applied to the share or token price \r\n        uint inflationRate; \r\n        // Index of the client proposal\r\n        uint proposalID;\r\n    } \r\n    \r\n    // Rules for the actual funding and the contractor token price\r\n    fundingData[2] public FundingRules;\r\n\r\n    // The address of the last Manager before cloning\r\n    address public clonedFrom;\r\n\r\n    // Address of the creator of the smart contract\r\n    address public creator;\r\n    // Address of the Dao (for the Dao manager)\r\n    address client;\r\n    // Address of the recipient;\r\n    address public recipient;\r\n    // Address of the Dao manager (for contractor managers)\r\n    PassManager public daoManager;\r\n    \r\n    // The token name for display purpose\r\n    string public name;\r\n    // The token symbol for display purpose\r\n    string public symbol;\r\n    // The quantity of decimals for display purpose\r\n    uint8 public decimals;\r\n\r\n    // End date of the setup procedure\r\n    uint public smartContractStartDate;\r\n    // Unix date when shares and tokens can be transferred after cloning (for the Dao manager)\r\n    uint closingTimeForCloning;\r\n    \r\n    // Total amount of tokens\r\n    uint256 totalTokenSupply;\r\n\r\n    // Array with all balances\r\n    mapping (address => uint256) balances;\r\n    // Array with all allowances\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Map of the result (in wei) of fundings\r\n    mapping (uint => uint) fundedAmount;\r\n\r\n    // Array of token or share holders\r\n    address[] holders;\r\n    // Map with the indexes of the holders\r\n    mapping (address => uint) public holderID;\r\n\r\n    // If true, the shares or tokens can be transfered\r\n    bool public transferable;\r\n    // Map of blocked Dao share accounts. Points to the date when the share holder can transfer shares\r\n    mapping (address => uint) public blockedDeadLine; \r\n\r\n    // @return The client of this manager\r\n    function Client() constant returns (address);\r\n    \r\n    // @return The unix date when shares and tokens can be transferred after cloning\r\n    function ClosingTimeForCloning() constant returns (uint);\r\n    \r\n    /// @return The total supply of shares or tokens \r\n    function totalSupply() constant external returns (uint256);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n     function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Quantity of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n\r\n    /// @param _proposalID The index of the Dao proposal\r\n    /// @return The result (in wei) of the funding\r\n    function FundedAmount(uint _proposalID) constant external returns (uint);\r\n\r\n    /// @param _saleDate in case of presale, the date of the presale\r\n    /// @return the share or token price divisor condidering the sale date and the inflation rate\r\n    function priceDivisor(uint _saleDate) constant internal returns (uint);\r\n    \r\n    /// @return the actual price divisor of a share or token\r\n    function actualPriceDivisor() constant external returns (uint);\r\n\r\n    /// @return The maximal amount a main partner can fund at this moment\r\n    /// @param _mainPartner The address of the main parner\r\n    function fundingMaxAmount(address _mainPartner) constant external returns (uint);\r\n    \r\n    /// @return The number of share or token holders \r\n    function numberOfHolders() constant returns (uint);\r\n\r\n    /// @param _index The index of the holder\r\n    /// @return the address of the an holder\r\n    function HolderAddress(uint _index) constant returns (address);\r\n\r\n    /// @return The number of Dao rules proposals     \r\n    function numberOfProposals() constant returns (uint);\r\n    \r\n    /// @dev The constructor function\r\n    /// @param _client The address of the Dao\r\n    /// @param _daoManager The address of the Dao manager (for contractor managers)\r\n    /// @param _recipient The address of the recipient. 0 for the Dao\r\n    /// @param _clonedFrom The address of the last Manager before cloning\r\n    /// @param _tokenName The token name for display purpose\r\n    /// @param _tokenSymbol The token symbol for display purpose\r\n    /// @param _tokenDecimals The quantity of decimals for display purpose\r\n    /// @param _transferable True if allows the transfer of tokens\r\n    //function PassManager(\r\n    //    address _client,\r\n    //    address _daoManager,\r\n    //    address _recipient,\r\n    //    address _clonedFrom,\r\n    //    string _tokenName,\r\n    //    string _tokenSymbol,\r\n    //    uint8 _tokenDecimals,\r\n    //    bool _transferable);\r\n    \r\n    /// @notice Function to clone a proposal from another manager contract\r\n    /// @param _amount Amount (in wei) of the proposal\r\n    /// @param _description A description of the proposal\r\n    /// @param _hashOfTheDocument The hash of the proposal's document\r\n    /// @param _dateOfProposal A unix timestamp, denoting the date when the proposal was created\r\n    /// @param _lastClientProposalID The index of the last approved client proposal\r\n    /// @param _orderAmount The sum amount (in wei) ordered for this proposal \r\n    /// @param _dateOfOrder A unix timestamp, denoting the date of the last order for the approved proposal\r\n    /// @return Whether the function was successful or not \r\n    function cloneProposal(\r\n        uint _amount,\r\n        string _description,\r\n        bytes32 _hashOfTheDocument,\r\n        uint _dateOfProposal,\r\n        uint _lastClientProposalID,\r\n        uint _orderAmount,\r\n        uint _dateOfOrder) returns (bool success);\r\n    \r\n    /// @dev Function to create initial tokens    \r\n    /// @param _recipient The beneficiary of the created tokens\r\n    /// @param _quantity The quantity of tokens to create    \r\n    /// @return Whether the function was successful or not     \r\n    function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity) returns (bool success);\r\n        \r\n    /// @notice Function to clone tokens from a manager\r\n    /// @param _from The index of the first holder\r\n    /// @param _to The index of the last holder\r\n    /// @return Whether the function was successful or not \r\n    function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success);\r\n    \r\n    /// @notice Function to close the setup procedure of this contract\r\n    function closeSetup();\r\n\r\n    /// @notice Function to update the recipent address\r\n    /// @param _newRecipient The adress of the recipient\r\n    function updateRecipient(address _newRecipient);\r\n\r\n    /// @notice Function to receive payments or deposits\r\n    function () payable;\r\n    \r\n    /// @notice Function to allow contractors to withdraw ethers\r\n    /// @param _amount The amount (in wei) to withdraw\r\n    function withdraw(uint _amount);\r\n\r\n    /// @notice Function to update the client address\r\n    function updateClient(address _newClient);\r\n    \r\n    /// @notice Function to make a proposal to work for the client\r\n    /// @param _amount The amount (in wei) of the proposal\r\n    /// @param _description String describing the proposal\r\n    /// @param _hashOfTheDocument The hash of the proposal document\r\n    /// @return The index of the contractor proposal\r\n    function newProposal(\r\n        uint _amount,\r\n        string _description, \r\n        bytes32 _hashOfTheDocument\r\n    ) returns (uint);\r\n        \r\n    /// @notice Function used by the client to order according to the contractor proposal\r\n    /// @param _clientProposalID The index of the last approved client proposal\r\n    /// @param _proposalID The index of the contractor proposal\r\n    /// @param _amount The amount (in wei) of the order\r\n    /// @return Whether the order was made or not\r\n    function order(\r\n        uint _clientProposalID,\r\n        uint _proposalID,\r\n        uint _amount\r\n    ) external returns (bool) ;\r\n    \r\n    /// @notice Function used by the client to send ethers from the Dao manager\r\n    /// @param _recipient The address to send to\r\n    /// @param _amount The amount (in wei) to send\r\n    /// @return Whether the transfer was successful or not\r\n    function sendTo(\r\n        address _recipient, \r\n        uint _amount\r\n    ) external returns (bool);\r\n    \r\n    /// @dev Internal function to add a new token or share holder\r\n    /// @param _holder The address of the token or share holder\r\n    function addHolder(address _holder) internal;\r\n    \r\n    /// @dev Internal function to create initial tokens    \r\n    /// @param _holder The beneficiary of the created tokens\r\n    /// @param _quantity The quantity of tokens to create\r\n    /// @return Whether the function was successful or not \r\n    function createInitialTokens(address _holder, uint _quantity) internal returns (bool success) ;\r\n    \r\n    /// @notice Function that allow the contractor to propose a token price\r\n    /// @param _initialPriceMultiplier The initial price multiplier of contractor tokens\r\n    /// @param _inflationRate If 0, the contractor token price doesn't change during the funding\r\n    /// @param _closingTime The initial price and inflation rate can be changed after this date\r\n    function setTokenPriceProposal(        \r\n        uint _initialPriceMultiplier, \r\n        uint _inflationRate,\r\n        uint _closingTime\r\n    );\r\n\r\n    /// @notice Function to set a funding. Can be private or public\r\n    /// @param _mainPartner The address of the smart contract to manage a private funding\r\n    /// @param _publicCreation True if public funding\r\n    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\r\n    /// @param _maxAmountToFund The maximum amount (in wei) of the funding\r\n    /// @param _minutesFundingPeriod Period in minutes of the funding\r\n    /// @param _inflationRate If 0, the token price doesn't change during the funding\r\n    /// @param _proposalID Index of the client proposal (not mandatory)\r\n    function setFundingRules(\r\n        address _mainPartner,\r\n        bool _publicCreation, \r\n        uint _initialPriceMultiplier, \r\n        uint _maxAmountToFund, \r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external;\r\n    \r\n    /// @dev Internal function for the creation of shares or tokens\r\n    /// @param _recipient The recipient address of shares or tokens\r\n    /// @param _amount The funded amount (in wei)\r\n    /// @param _saleDate In case of presale, the date of the presale\r\n    /// @return Whether the creation was successful or not\r\n    function createToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate\r\n    ) internal returns (bool success);\r\n\r\n    /// @notice Function used by the main partner to set the start time of the funding\r\n    /// @param _startTime The unix start date of the funding \r\n    function setFundingStartTime(uint _startTime) external;\r\n\r\n    /// @notice Function used by the main partner to reward shares or tokens\r\n    /// @param _recipient The address of the recipient of shares or tokens\r\n    /// @param _amount The amount (in Wei) to calculate the quantity of shares or tokens to create\r\n    /// @param _date The unix date to consider for the share or token price calculation\r\n    /// @return Whether the transfer was successful or not\r\n    function rewardToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _date\r\n        ) external;\r\n\r\n    /// @dev Internal function to close the actual funding\r\n    function closeFunding() internal;\r\n    \r\n    /// @notice Function used by the main partner to set the funding fueled\r\n    function setFundingFueled() external;\r\n\r\n    /// @notice Function to able the transfer of Dao shares or contractor tokens\r\n    function ableTransfer();\r\n\r\n    /// @notice Function to disable the transfer of Dao shares\r\n    /// @param _closingTime Date when shares or tokens can be transferred\r\n    function disableTransfer(uint _closingTime);\r\n\r\n    /// @notice Function used by the client to block the transfer of shares from and to a share holder\r\n    /// @param _shareHolder The address of the share holder\r\n    /// @param _deadLine When the account will be unblocked\r\n    function blockTransfer(address _shareHolder, uint _deadLine) external;\r\n\r\n    /// @notice Function to buy Dao shares according to the funding rules \r\n    /// with `msg.sender` as the beneficiary\r\n    function buyShares() payable;\r\n    \r\n    /// @notice Function to buy Dao shares according to the funding rules \r\n    /// @param _recipient The beneficiary of the created shares\r\n    function buySharesFor(address _recipient) payable;\r\n    \r\n    /// @dev Internal function to send `_value` token to `_to` from `_From`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    event FeesReceived(address indexed From, uint Amount);\r\n    event AmountReceived(address indexed From, uint Amount);\r\n    event paymentReceived(address indexed daoManager, uint Amount);\r\n    event ProposalCloned(uint indexed LastClientProposalID, uint indexed ProposalID, uint Amount, string Description, bytes32 HashOfTheDocument);\r\n    event ClientUpdated(address LastClient, address NewClient);\r\n    event RecipientUpdated(address LastRecipient, address NewRecipient);\r\n    event ProposalAdded(uint indexed ProposalID, uint Amount, string Description, bytes32 HashOfTheDocument);\r\n    event Order(uint indexed clientProposalID, uint indexed ProposalID, uint Amount);\r\n    event Withdawal(address indexed Recipient, uint Amount);\r\n    event TokenPriceProposalSet(uint InitialPriceMultiplier, uint InflationRate, uint ClosingTime);\r\n    event holderAdded(uint Index, address Holder);\r\n    event TokensCreated(address indexed Sender, address indexed TokenHolder, uint Quantity);\r\n    event FundingRulesSet(address indexed MainPartner, uint indexed FundingProposalId, uint indexed StartTime, uint ClosingTime);\r\n    event FundingFueled(uint indexed FundingProposalID, uint FundedAmount);\r\n    event TransferAble();\r\n    event TransferDisable(uint closingTime);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\r\n}    \r\n\r\ncontract PassManager is PassManagerInterface {\r\n\r\n// Constant functions\r\n\r\n    function Client() constant returns (address) {\r\n        if (recipient == 0) return client;\r\n        else return daoManager.Client();\r\n    }\r\n    \r\n    function ClosingTimeForCloning() constant returns (uint) {\r\n        if (recipient == 0) return closingTimeForCloning;\r\n        else return daoManager.ClosingTimeForCloning();\r\n    }\r\n    \r\n    function totalSupply() constant external returns (uint256) {\r\n        return totalTokenSupply;\r\n    }\r\n\r\n     function balanceOf(address _owner) constant external returns (uint256 balance) {\r\n        return balances[_owner];\r\n     }\r\n\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function FundedAmount(uint _proposalID) constant external returns (uint) {\r\n        return fundedAmount[_proposalID];\r\n    }\r\n\r\n    function priceDivisor(uint _saleDate) constant internal returns (uint) {\r\n        uint _date = _saleDate;\r\n        \r\n        if (_saleDate > FundingRules[0].closingTime) _date = FundingRules[0].closingTime;\r\n        if (_saleDate < FundingRules[0].startTime) _date = FundingRules[0].startTime;\r\n\r\n        return 100 + 100*FundingRules[0].inflationRate*(_date - FundingRules[0].startTime)/(100*365 days);\r\n    }\r\n    \r\n    function actualPriceDivisor() constant external returns (uint) {\r\n        return priceDivisor(now);\r\n    }\r\n\r\n    function fundingMaxAmount(address _mainPartner) constant external returns (uint) {\r\n        \r\n        if (now > FundingRules[0].closingTime\r\n            || now < FundingRules[0].startTime\r\n            || _mainPartner != FundingRules[0].mainPartner) {\r\n            return 0;   \r\n        } else {\r\n            return FundingRules[0].maxAmountToFund;\r\n        }\r\n        \r\n    }\r\n\r\n    function numberOfHolders() constant returns (uint) {\r\n        return holders.length - 1;\r\n    }\r\n    \r\n    function HolderAddress(uint _index) constant returns (address) {\r\n        return holders[_index];\r\n    }\r\n\r\n    function numberOfProposals() constant returns (uint) {\r\n        return proposals.length - 1;\r\n    }\r\n\r\n// Modifiers\r\n\r\n    // Modifier that allows only the client to manage this account manager\r\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\r\n    \r\n    // Modifier that allows only the main partner to manage the actual funding\r\n    modifier onlyMainPartner {if (msg.sender !=  FundingRules[0].mainPartner) throw; _;}\r\n    \r\n    // Modifier that allows only the contractor propose set the token price or withdraw\r\n    modifier onlyContractor {if (recipient == 0 || (msg.sender != recipient && msg.sender != creator)) throw; _;}\r\n    \r\n    // Modifier for Dao functions\r\n    modifier onlyDao {if (recipient != 0) throw; _;}\r\n    \r\n// Constructor function\r\n\r\n    function PassManager(\r\n        address _client,\r\n        address _daoManager,\r\n        address _recipient,\r\n        address _clonedFrom,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        bool _transferable\r\n    ) {\r\n\r\n        if ((_recipient == 0 && _client == 0)\r\n            || _client == _recipient) throw;\r\n\r\n        creator = msg.sender; \r\n        client = _client;\r\n        recipient = _recipient;\r\n        \r\n        if (_recipient !=0) daoManager = PassManager(_daoManager);\r\n\r\n        clonedFrom = _clonedFrom;            \r\n        \r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n          \r\n        if (_transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        } else {\r\n            transferable = false;\r\n            TransferDisable(0);\r\n        }\r\n\r\n        holders.length = 1;\r\n        proposals.length = 1;\r\n        \r\n    }\r\n\r\n// Setting functions\r\n\r\n    function cloneProposal(\r\n        uint _amount,\r\n        string _description,\r\n        bytes32 _hashOfTheDocument,\r\n        uint _dateOfProposal,\r\n        uint _lastClientProposalID,\r\n        uint _orderAmount,\r\n        uint _dateOfOrder\r\n    ) returns (bool success) {\r\n            \r\n        if (smartContractStartDate != 0 || recipient == 0\r\n        || msg.sender != creator) throw;\r\n        \r\n        uint _proposalID = proposals.length++;\r\n        proposal c = proposals[_proposalID];\r\n\r\n        c.amount = _amount;\r\n        c.description = _description;\r\n        c.hashOfTheDocument = _hashOfTheDocument; \r\n        c.dateOfProposal = _dateOfProposal;\r\n        c.lastClientProposalID = _lastClientProposalID;\r\n        c.orderAmount = _orderAmount;\r\n        c.dateOfOrder = _dateOfOrder;\r\n        \r\n        ProposalCloned(_lastClientProposalID, _proposalID, c.amount, c.description, c.hashOfTheDocument);\r\n        \r\n        return true;\r\n            \r\n    }\r\n\r\n    function initialTokenSupply(\r\n        address _recipient, \r\n        uint _quantity) returns (bool success) {\r\n\r\n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\r\n        \r\n        if (_recipient != 0 && _quantity != 0) {\r\n            return (createInitialTokens(_recipient, _quantity));\r\n        }\r\n            \r\n    }\r\n\r\n    function cloneTokens(\r\n        uint _from,\r\n        uint _to) returns (bool success) {\r\n        \r\n        if (smartContractStartDate != 0) throw;\r\n        \r\n        PassManager _clonedFrom = PassManager(clonedFrom);\r\n        \r\n        if (_from < 1 || _to > _clonedFrom.numberOfHolders()) throw;\r\n\r\n        address _holder;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n            _holder = _clonedFrom.HolderAddress(i);\r\n            if (balances[_holder] == 0) {\r\n                createInitialTokens(_holder, _clonedFrom.balanceOf(_holder));\r\n            }\r\n        }\r\n\r\n        return true;\r\n        \r\n    }\r\n\r\n    function closeSetup() {\r\n        \r\n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\r\n\r\n        smartContractStartDate = now;\r\n\r\n    }\r\n\r\n// Function to receive payments or deposits\r\n\r\n    function () payable {\r\n        AmountReceived(msg.sender, msg.value);\r\n    }\r\n    \r\n// Contractors Account Management\r\n\r\n    function updateRecipient(address _newRecipient) onlyContractor {\r\n\r\n        if (_newRecipient == 0 \r\n            || _newRecipient == client) throw;\r\n\r\n        RecipientUpdated(recipient, _newRecipient);\r\n        recipient = _newRecipient;\r\n\r\n    } \r\n\r\n    function withdraw(uint _amount) onlyContractor {\r\n        if (!recipient.send(_amount)) throw;\r\n        Withdawal(recipient, _amount);\r\n    }\r\n    \r\n// DAO Proposals Management\r\n\r\n    function updateClient(address _newClient) onlyClient {\r\n        \r\n        if (_newClient == 0 \r\n            || _newClient == recipient) throw;\r\n\r\n        ClientUpdated(client, _newClient);\r\n        client = _newClient;        \r\n\r\n    }\r\n\r\n    function newProposal(\r\n        uint _amount,\r\n        string _description, \r\n        bytes32 _hashOfTheDocument\r\n    ) onlyContractor returns (uint) {\r\n\r\n        uint _proposalID = proposals.length++;\r\n        proposal c = proposals[_proposalID];\r\n\r\n        c.amount = _amount;\r\n        c.description = _description;\r\n        c.hashOfTheDocument = _hashOfTheDocument; \r\n        c.dateOfProposal = now;\r\n        \r\n        ProposalAdded(_proposalID, c.amount, c.description, c.hashOfTheDocument);\r\n        \r\n        return _proposalID;\r\n        \r\n    }\r\n    \r\n    function order(\r\n        uint _clientProposalID,\r\n        uint _proposalID,\r\n        uint _orderAmount\r\n    ) external onlyClient returns (bool) {\r\n    \r\n        proposal c = proposals[_proposalID];\r\n        \r\n        uint _sum = c.orderAmount + _orderAmount;\r\n        if (_sum > c.amount\r\n            || _sum < c.orderAmount\r\n            || _sum < _orderAmount) return; \r\n\r\n        c.lastClientProposalID =  _clientProposalID;\r\n        c.orderAmount = _sum;\r\n        c.dateOfOrder = now;\r\n        \r\n        Order(_clientProposalID, _proposalID, _orderAmount);\r\n        \r\n        return true;\r\n\r\n    }\r\n\r\n    function sendTo(\r\n        address _recipient,\r\n        uint _amount\r\n    ) external onlyClient onlyDao returns (bool) {\r\n\r\n        if (_recipient.send(_amount)) return true;\r\n        else return false;\r\n\r\n    }\r\n    \r\n// Token Management\r\n    \r\n    function addHolder(address _holder) internal {\r\n        \r\n        if (holderID[_holder] == 0) {\r\n            \r\n            uint _holderID = holders.length++;\r\n            holders[_holderID] = _holder;\r\n            holderID[_holder] = _holderID;\r\n            holderAdded(_holderID, _holder);\r\n\r\n        }\r\n        \r\n    }\r\n    \r\n    function createInitialTokens(\r\n        address _holder, \r\n        uint _quantity\r\n    ) internal returns (bool success) {\r\n\r\n        if (_quantity > 0 && balances[_holder] == 0) {\r\n            addHolder(_holder);\r\n            balances[_holder] = _quantity; \r\n            totalTokenSupply += _quantity;\r\n            TokensCreated(msg.sender, _holder, _quantity);\r\n            return true;\r\n        }\r\n        \r\n    }\r\n    \r\n    function setTokenPriceProposal(        \r\n        uint _initialPriceMultiplier, \r\n        uint _inflationRate,\r\n        uint _closingTime\r\n    ) onlyContractor {\r\n        \r\n        if (_closingTime < now \r\n            || now < FundingRules[1].closingTime) throw;\r\n        \r\n        FundingRules[1].initialPriceMultiplier = _initialPriceMultiplier;\r\n        FundingRules[1].inflationRate = _inflationRate;\r\n        FundingRules[1].startTime = now;\r\n        FundingRules[1].closingTime = _closingTime;\r\n        \r\n        TokenPriceProposalSet(_initialPriceMultiplier, _inflationRate, _closingTime);\r\n    }\r\n    \r\n    function setFundingRules(\r\n        address _mainPartner,\r\n        bool _publicCreation, \r\n        uint _initialPriceMultiplier,\r\n        uint _maxAmountToFund, \r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external onlyClient {\r\n\r\n        if (now < FundingRules[0].closingTime\r\n            || _mainPartner == address(this)\r\n            || _mainPartner == client\r\n            || (!_publicCreation && _mainPartner == 0)\r\n            || (_publicCreation && _mainPartner != 0)\r\n            || (recipient == 0 && _initialPriceMultiplier == 0)\r\n            || (recipient != 0 \r\n                && (FundingRules[1].initialPriceMultiplier == 0\r\n                    || _inflationRate < FundingRules[1].inflationRate\r\n                    || now < FundingRules[1].startTime\r\n                    || FundingRules[1].closingTime < now + (_minutesFundingPeriod * 1 minutes)))\r\n            || _maxAmountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            ) throw;\r\n\r\n        FundingRules[0].startTime = now;\r\n        FundingRules[0].closingTime = now + _minutesFundingPeriod * 1 minutes;\r\n            \r\n        FundingRules[0].mainPartner = _mainPartner;\r\n        FundingRules[0].publicCreation = _publicCreation;\r\n        \r\n        if (recipient == 0) FundingRules[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        else FundingRules[0].initialPriceMultiplier = FundingRules[1].initialPriceMultiplier;\r\n        \r\n        if (recipient == 0) FundingRules[0].inflationRate = _inflationRate;\r\n        else FundingRules[0].inflationRate = FundingRules[1].inflationRate;\r\n        \r\n        FundingRules[0].fundedAmount = 0;\r\n        FundingRules[0].maxAmountToFund = _maxAmountToFund;\r\n\r\n        FundingRules[0].proposalID = _proposalID;\r\n\r\n        FundingRulesSet(_mainPartner, _proposalID, FundingRules[0].startTime, FundingRules[0].closingTime);\r\n            \r\n    } \r\n    \r\n    function createToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate\r\n    ) internal returns (bool success) {\r\n\r\n        if (now > FundingRules[0].closingTime\r\n            || now < FundingRules[0].startTime\r\n            ||_saleDate > FundingRules[0].closingTime\r\n            || _saleDate < FundingRules[0].startTime\r\n            || FundingRules[0].fundedAmount + _amount > FundingRules[0].maxAmountToFund) return;\r\n\r\n        uint _a = _amount*FundingRules[0].initialPriceMultiplier;\r\n        uint _multiplier = 100*_a;\r\n        uint _quantity = _multiplier/priceDivisor(_saleDate);\r\n        if (_a/_amount != FundingRules[0].initialPriceMultiplier\r\n            || _multiplier/100 != _a\r\n            || totalTokenSupply + _quantity <= totalTokenSupply \r\n            || totalTokenSupply + _quantity <= _quantity) return;\r\n\r\n        addHolder(_recipient);\r\n        balances[_recipient] += _quantity;\r\n        totalTokenSupply += _quantity;\r\n        FundingRules[0].fundedAmount += _amount;\r\n\r\n        TokensCreated(msg.sender, _recipient, _quantity);\r\n        \r\n        if (FundingRules[0].fundedAmount == FundingRules[0].maxAmountToFund) closeFunding();\r\n        \r\n        return true;\r\n\r\n    }\r\n\r\n    function setFundingStartTime(uint _startTime) external onlyMainPartner {\r\n        if (now > FundingRules[0].closingTime) throw;\r\n        FundingRules[0].startTime = _startTime;\r\n    }\r\n    \r\n    function rewardToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _date\r\n        ) external onlyMainPartner {\r\n\r\n        uint _saleDate;\r\n        if (_date == 0) _saleDate = now; else _saleDate = _date;\r\n\r\n        if (!createToken(_recipient, _amount, _saleDate)) throw;\r\n\r\n    }\r\n\r\n    function closeFunding() internal {\r\n        if (recipient == 0) fundedAmount[FundingRules[0].proposalID] = FundingRules[0].fundedAmount;\r\n        FundingRules[0].closingTime = now;\r\n    }\r\n    \r\n    function setFundingFueled() external onlyMainPartner {\r\n        if (now > FundingRules[0].closingTime) throw;\r\n        closeFunding();\r\n        if (recipient == 0) FundingFueled(FundingRules[0].proposalID, FundingRules[0].fundedAmount);\r\n    }\r\n    \r\n    function ableTransfer() onlyClient {\r\n        if (!transferable) {\r\n            transferable = true;\r\n            closingTimeForCloning = 0;\r\n            TransferAble();\r\n        }\r\n    }\r\n\r\n    function disableTransfer(uint _closingTime) onlyClient {\r\n        if (transferable && _closingTime == 0) transferable = false;\r\n        else closingTimeForCloning = _closingTime;\r\n            \r\n        TransferDisable(_closingTime);\r\n    }\r\n    \r\n    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyDao {\r\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }\r\n    }\r\n    \r\n    function buyShares() payable {\r\n        buySharesFor(msg.sender);\r\n    } \r\n    \r\n    function buySharesFor(address _recipient) payable onlyDao {\r\n        \r\n        if (!FundingRules[0].publicCreation \r\n            || !createToken(_recipient, msg.value, now)) throw;\r\n\r\n    }\r\n    \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool success) {  \r\n\r\n        if ((transferable && now > ClosingTimeForCloning())\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]\r\n            && balances[_to] + _value >= _value\r\n        ) {\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            addHolder(_to);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {  \r\n        if (!transferFromTo(msg.sender, _to, _value)) throw;\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success) { \r\n        \r\n        if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw;\r\n            \r\n        allowed[_from][msg.sender] -= _value;\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n    \r\n}    \r\n\r\npragma solidity ^0.4.6;\r\n\r\n/*\r\nThis file is part of Pass DAO.\r\n\r\nPass DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nPass DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with Pass DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/*\r\nSmart contract for a Decentralized Autonomous Organization (DAO)\r\nto automate organizational governance and decision-making.\r\n*/\r\n\r\n/// @title Pass Decentralized Autonomous Organisation\r\ncontract PassDaoInterface {\r\n\r\n    struct BoardMeeting {        \r\n        // Address of the creator of the board meeting for a proposal\r\n        address creator;  \r\n        // Index to identify the proposal to pay a contractor or fund the Dao\r\n        uint proposalID;\r\n        // Index to identify the proposal to update the Dao rules \r\n        uint daoRulesProposalID; \r\n        // unix timestamp, denoting the end of the set period of a proposal before the board meeting \r\n        uint setDeadline;\r\n        // Fees (in wei) paid by the creator of the board meeting\r\n        uint fees;\r\n        // Total of fees (in wei) rewarded to the voters or to the Dao account manager for the balance\r\n        uint totalRewardedAmount;\r\n        // A unix timestamp, denoting the end of the voting period\r\n        uint votingDeadline;\r\n        // True if the proposal's votes have yet to be counted, otherwise False\r\n        bool open; \r\n        // A unix timestamp, denoting the date of the execution of the approved proposal\r\n        uint dateOfExecution;\r\n        // Number of shares in favor of the proposal\r\n        uint yea; \r\n        // Number of shares opposed to the proposal\r\n        uint nay; \r\n        // mapping to indicate if a shareholder has voted\r\n        mapping (address => bool) hasVoted;  \r\n    }\r\n\r\n    struct Contractor {\r\n        // The address of the contractor manager smart contract\r\n        address contractorManager;\r\n        // The date of the first order for the contractor\r\n        uint creationDate;\r\n    }\r\n        \r\n    struct Proposal {\r\n        // Index to identify the board meeting of the proposal\r\n        uint boardMeetingID;\r\n        // The contractor manager smart contract\r\n        PassManager contractorManager;\r\n        // The index of the contractor proposal\r\n        uint contractorProposalID;\r\n        // The amount (in wei) of the proposal\r\n        uint amount; \r\n        // True if the proposal foresees a contractor token creation\r\n        bool tokenCreation;\r\n        // True if public funding without a main partner\r\n        bool publicShareCreation; \r\n        // The address which sets partners and manages the funding in case of private funding\r\n        address mainPartner;\r\n        // The initial price multiplier of Dao shares at the beginning of the funding\r\n        uint initialSharePriceMultiplier; \r\n        // The inflation rate to calculate the actual contractor share price\r\n        uint inflationRate;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint minutesFundingPeriod;\r\n        // True if the proposal is closed\r\n        bool open; \r\n    }\r\n\r\n    struct Rules {\r\n        // Index to identify the board meeting that decides to apply or not the Dao rules\r\n        uint boardMeetingID;  \r\n        // The quorum needed for each proposal is calculated by totalSupply / minQuorumDivisor\r\n        uint minQuorumDivisor;  \r\n        // Minimum fees (in wei) to create a proposal\r\n        uint minBoardMeetingFees; \r\n        // Period in minutes to consider or set a proposal before the voting procedure\r\n        uint minutesSetProposalPeriod; \r\n        // The minimum debate period in minutes that a generic proposal can have\r\n        uint minMinutesDebatePeriod;\r\n        // The inflation rate to calculate the reward of fees to voters during a board meeting \r\n        uint feesRewardInflationRate;\r\n        // True if the dao rules allow the transfer of shares\r\n        bool transferable;\r\n        // Address of the new Dao smart contract after an upgrade\r\n        address newdao;\r\n        // The period in minutes for the cloning procedure of shares and tokens\r\n        uint minutesForTokensCloning;\r\n    } \r\n    \r\n    // The creator of the Dao\r\n    address public creator;\r\n    // The name of the project\r\n    string public projectName;\r\n    // The address of the last Dao before upgrade (not mandatory)\r\n    address public lastDao;\r\n    // End date of the setup procedure\r\n    uint public smartContractStartDate;\r\n    // The Dao manager smart contract\r\n    PassManager public daoManager;\r\n    // The minimum periods in minutes \r\n    uint public minMinutesPeriods;\r\n    // The maximum period in minutes for proposals (set+debate)\r\n    uint public maxMinutesProposalPeriod;\r\n    // The maximum funding period in minutes for funding proposals\r\n    uint public maxMinutesFundingPeriod;\r\n    // The maximum inflation rate for share price or rewards to voters\r\n    uint public maxInflationRate;\r\n    \r\n    // Map to allow the share holders to withdraw board meeting fees\r\n    mapping (address => uint) pendingFees;\r\n\r\n    // Board meetings to vote for or against a proposal\r\n    BoardMeeting[] public BoardMeetings; \r\n    // Contractors of the Dao\r\n    Contractor[] public Contractors;\r\n    // Map with the indexes of the contractors\r\n    mapping (address => uint) contractorID;\r\n    // Proposals to pay a contractor or fund the Dao\r\n    Proposal[] public Proposals;\r\n    // Proposals to update the Dao rules\r\n    Rules[] public DaoRulesProposals;\r\n    // The current Dao rules\r\n    Rules public DaoRules; \r\n    \r\n    // Date when shares and tokens can be transferred after cloning\r\n    uint public closingTimeForCloning;\r\n    \r\n    /// @dev The constructor function\r\n    /// @param _projectName The name of the Dao\r\n    /// @param _lastDao The address of the last Dao before upgrade (not mandatory)\r\n    //function PassDao(\r\n    //    string _projectName,\r\n    //    address _lastDao);\r\n    \r\n    /// @dev Internal function to add a new contractor\r\n    /// @param _contractorManager The address of the contractor manager\r\n    /// @param _creationDate The date of the first order\r\n    function addContractor(address _contractorManager, uint _creationDate) internal;\r\n\r\n    /// @dev Function to clone a contractor from the last Dao in case of upgrade \r\n    /// @param _contractorManager The address of the contractor manager\r\n    /// @param _creationDate The date of the first order\r\n    function cloneContractor(address _contractorManager, uint _creationDate);\r\n    \r\n    /// @dev Function to initialize the Dao\r\n    /// @param _daoManager Address of the Dao manager smart contract\r\n    /// @param _maxInflationRate The maximum inflation rate for contractor and funding proposals\r\n    /// @param _minMinutesPeriods The minimum periods in minutes\r\n    /// @param _maxMinutesFundingPeriod The maximum funding period in minutes for funding proposals\r\n    /// @param _maxMinutesProposalPeriod The maximum period in minutes for proposals (set+debate)\r\n    /// @param _minQuorumDivisor The initial minimum quorum divisor for the proposals\r\n    /// @param _minBoardMeetingFees The amount (in wei) to make a proposal and ask for a board meeting\r\n    /// @param _minutesSetProposalPeriod The minimum period in minutes before a board meeting\r\n    /// @param _minMinutesDebatePeriod The minimum period in minutes of the board meetings\r\n    /// @param _feesRewardInflationRate The inflation rate to calculate the reward of fees to voters during a board meeting\r\n    function initDao(\r\n        address _daoManager,\r\n        uint _maxInflationRate,\r\n        uint _minMinutesPeriods,\r\n        uint _maxMinutesFundingPeriod,\r\n        uint _maxMinutesProposalPeriod,\r\n        uint _minQuorumDivisor,\r\n        uint _minBoardMeetingFees,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate\r\n        );\r\n        \r\n    /// @dev Internal function to create a board meeting\r\n    /// @param _proposalID The index of the proposal if for a contractor or for a funding\r\n    /// @param _daoRulesProposalID The index of the proposal if Dao rules\r\n    /// @param _minutesDebatingPeriod The duration in minutes of the meeting\r\n    /// @return the index of the board meeting\r\n    function newBoardMeeting(\r\n        uint _proposalID, \r\n        uint _daoRulesProposalID, \r\n        uint _minutesDebatingPeriod\r\n    ) internal returns (uint);\r\n    \r\n    /// @notice Function to make a proposal to pay a contractor or fund the Dao\r\n    /// @param _contractorManager Address of the contractor manager smart contract\r\n    /// @param _contractorProposalID Index of the contractor proposal of the contractor manager\r\n    /// @param _amount The amount (in wei) of the proposal\r\n    /// @param _tokenCreation True if the proposal foresees a contractor token creation\r\n    /// @param _publicShareCreation True if public funding without a main partner\r\n    /// @param _mainPartner The address which sets partners and manage the funding \r\n    /// in case of private funding (not mandatory)\r\n    /// @param _initialSharePriceMultiplier The initial price multiplier of shares\r\n    /// @param _inflationRate If 0, the share price doesn't change during the funding (not mandatory)\r\n    /// @param _minutesFundingPeriod Period in minutes of the funding\r\n    /// @param _minutesDebatingPeriod Period in minutes of the board meeting to vote on the proposal\r\n    /// @return The index of the proposal\r\n    function newProposal(\r\n        address _contractorManager,\r\n        uint _contractorProposalID,\r\n        uint _amount, \r\n        bool _publicShareCreation,\r\n        bool _tokenCreation,\r\n        address _mainPartner,\r\n        uint _initialSharePriceMultiplier, \r\n        uint _inflationRate,\r\n        uint _minutesFundingPeriod,\r\n        uint _minutesDebatingPeriod\r\n    ) payable returns (uint);\r\n\r\n    /// @notice Function to make a proposal to change the Dao rules \r\n    /// @param _minQuorumDivisor If 5, the minimum quorum is 20%\r\n    /// @param _minBoardMeetingFees The amount (in wei) to make a proposal and ask for a board meeting\r\n    /// @param _minutesSetProposalPeriod Minimum period in minutes before a board meeting\r\n    /// @param _minMinutesDebatePeriod The minimum period in minutes of the board meetings\r\n    /// @param _feesRewardInflationRate The inflation rate to calculate the reward of fees to voters during a board meeting\r\n    /// @param _transferable True if the proposal foresees to allow the transfer of Dao shares\r\n    /// @param _newdao Address of a new Dao smart contract in case of upgrade (not mandatory)   \r\n    /// @param _minutesForTokensCloning The period in minutes for the cloning procedure of shares and tokens\r\n    /// @param _minutesDebatingPeriod Period in minutes of the board meeting to vote on the proposal\r\n    function newDaoRulesProposal(\r\n        uint _minQuorumDivisor, \r\n        uint _minBoardMeetingFees,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate,\r\n        bool _transferable,\r\n        address _newdao,\r\n        uint _minutesForTokensCloning,\r\n        uint _minutesDebatingPeriod\r\n    ) payable returns (uint);\r\n    \r\n    /// @notice Function to vote during a board meeting\r\n    /// @param _boardMeetingID The index of the board meeting\r\n    /// @param _supportsProposal True if the proposal is supported\r\n    function vote(\r\n        uint _boardMeetingID, \r\n        bool _supportsProposal\r\n    );\r\n\r\n    /// @notice Function to execute a board meeting decision and close the board meeting\r\n    /// @param _boardMeetingID The index of the board meeting\r\n    /// @return Whether the proposal was executed or not\r\n    function executeDecision(uint _boardMeetingID) returns (bool);\r\n    \r\n    /// @notice Function to order a contractor proposal\r\n    /// @param _proposalID The index of the proposal\r\n    /// @return Whether the proposal was ordered and the proposal amount sent or not\r\n    function orderContractorProposal(uint _proposalID) returns (bool);   \r\n\r\n    /// @notice Function to withdraw the rewarded board meeting fees\r\n    /// @return Whether the withdraw was successful or not    \r\n    function withdrawBoardMeetingFees() returns (bool);\r\n\r\n    /// @param _shareHolder Address of the shareholder\r\n    /// @return The amount in wei the shareholder can withdraw    \r\n    function PendingFees(address _shareHolder) constant returns (uint);\r\n    \r\n    /// @return The minimum quorum for proposals to pass \r\n    function minQuorum() constant returns (uint);\r\n\r\n    /// @return The number of contractors \r\n   function numberOfContractors() constant returns (uint);\r\n\r\n    /// @return The number of board meetings (or proposals) \r\n    function numberOfBoardMeetings() constant returns (uint);\r\n\r\n    event ContractorAdded(uint indexed ContractorID, address ContractorManager, uint CreationDate);\r\n    event ContractorProposalAdded(uint indexed ProposalID, uint boardMeetingID, address indexed ContractorManager, \r\n        uint indexed ContractorProposalID, uint amount);\r\n    event FundingProposalAdded(uint indexed ProposalID, uint boardMeetingID, bool indexed LinkedToContractorProposal, \r\n        uint amount, address MainPartner, uint InitialSharePriceMultiplier, uint InflationRate, uint MinutesFundingPeriod);\r\n    event DaoRulesProposalAdded(uint indexed DaoRulesProposalID, uint boardMeetingID, uint MinQuorumDivisor, \r\n        uint MinBoardMeetingFees, uint MinutesSetProposalPeriod, uint MinMinutesDebatePeriod, uint FeesRewardInflationRate, \r\n        bool Transferable, address NewDao, uint MinutesForTokensCloning);\r\n    event Voted(uint indexed boardMeetingID, uint ProposalID, uint DaoRulesProposalID, bool position, address indexed voter);\r\n    event ProposalClosed(uint indexed ProposalID, uint indexed DaoRulesProposalID, uint boardMeetingID, \r\n        uint FeesGivenBack, bool ProposalExecuted, uint BalanceSentToDaoManager);\r\n    event SentToContractor(uint indexed ProposalID, uint indexed ContractorProposalID, address indexed ContractorManagerAddress, uint AmountSent);\r\n    event Withdrawal(address indexed Recipient, uint Amount);\r\n    event DaoUpgraded(address NewDao);\r\n    \r\n}\r\n\r\ncontract PassDao is PassDaoInterface {\r\n\r\n    function PassDao(\r\n        string _projectName,\r\n        address _lastDao) {\r\n\r\n        lastDao = _lastDao;\r\n        creator = msg.sender;\r\n        projectName =_projectName;\r\n\r\n        Contractors.length = 1;\r\n        BoardMeetings.length = 1;\r\n        Proposals.length = 1;\r\n        DaoRulesProposals.length = 1; \r\n        \r\n    }\r\n    \r\n    function addContractor(address _contractorManager, uint _creationDate) internal {\r\n        \r\n        if (contractorID[_contractorManager] == 0) {\r\n\r\n            uint _contractorID = Contractors.length++;\r\n            Contractor c = Contractors[_contractorID];\r\n            \r\n            contractorID[_contractorManager] = _contractorID;\r\n            c.contractorManager = _contractorManager;\r\n            c.creationDate = _creationDate;\r\n            \r\n            ContractorAdded(_contractorID, c.contractorManager, c.creationDate);\r\n        }\r\n        \r\n    }\r\n    \r\n    function cloneContractor(address _contractorManager, uint _creationDate) {\r\n        \r\n        if (DaoRules.minQuorumDivisor != 0 || msg.sender != creator) throw;\r\n\r\n        addContractor(_contractorManager, _creationDate);\r\n        \r\n    }\r\n    \r\n    function initDao(\r\n        address _daoManager,\r\n        uint _maxInflationRate,\r\n        uint _minMinutesPeriods,\r\n        uint _maxMinutesFundingPeriod,\r\n        uint _maxMinutesProposalPeriod,\r\n        uint _minQuorumDivisor,\r\n        uint _minBoardMeetingFees,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate\r\n        ) {\r\n            \r\n        \r\n        if (smartContractStartDate != 0) throw;\r\n\r\n        maxInflationRate = _maxInflationRate;\r\n        minMinutesPeriods = _minMinutesPeriods;\r\n        maxMinutesFundingPeriod = _maxMinutesFundingPeriod;\r\n        maxMinutesProposalPeriod = _maxMinutesProposalPeriod;\r\n        \r\n        DaoRules.minQuorumDivisor = _minQuorumDivisor;\r\n        DaoRules.minBoardMeetingFees = _minBoardMeetingFees;\r\n        DaoRules.minutesSetProposalPeriod = _minutesSetProposalPeriod;\r\n        DaoRules.minMinutesDebatePeriod = _minMinutesDebatePeriod;\r\n        DaoRules.feesRewardInflationRate = _feesRewardInflationRate;\r\n        daoManager = PassManager(_daoManager);\r\n        \r\n        smartContractStartDate = now;\r\n        \r\n    }\r\n    \r\n    function newBoardMeeting(\r\n        uint _proposalID, \r\n        uint _daoRulesProposalID, \r\n        uint _minutesDebatingPeriod\r\n    ) internal returns (uint) {\r\n\r\n        if (msg.value < DaoRules.minBoardMeetingFees\r\n            || DaoRules.minutesSetProposalPeriod + _minutesDebatingPeriod > maxMinutesProposalPeriod\r\n            || now + ((DaoRules.minutesSetProposalPeriod + _minutesDebatingPeriod) * 1 minutes) < now\r\n            || _minutesDebatingPeriod < DaoRules.minMinutesDebatePeriod\r\n            || msg.sender == address(this)) throw;\r\n\r\n        uint _boardMeetingID = BoardMeetings.length++;\r\n        BoardMeeting b = BoardMeetings[_boardMeetingID];\r\n\r\n        b.creator = msg.sender;\r\n\r\n        b.proposalID = _proposalID;\r\n        b.daoRulesProposalID = _daoRulesProposalID;\r\n\r\n        b.fees = msg.value;\r\n        \r\n        b.setDeadline = now + (DaoRules.minutesSetProposalPeriod * 1 minutes);        \r\n        b.votingDeadline = b.setDeadline + (_minutesDebatingPeriod * 1 minutes); \r\n\r\n        b.open = true; \r\n\r\n        return _boardMeetingID;\r\n\r\n    }\r\n\r\n    function newProposal(\r\n        address _contractorManager,\r\n        uint _contractorProposalID,\r\n        uint _amount, \r\n        bool _tokenCreation,\r\n        bool _publicShareCreation,\r\n        address _mainPartner,\r\n        uint _initialSharePriceMultiplier, \r\n        uint _inflationRate,\r\n        uint _minutesFundingPeriod,\r\n        uint _minutesDebatingPeriod\r\n    ) payable returns (uint) {\r\n\r\n        if ((_contractorManager != 0 && _contractorProposalID == 0)\r\n            || (_contractorManager == 0 \r\n                && (_initialSharePriceMultiplier == 0\r\n                    || _contractorProposalID != 0)\r\n            || (_tokenCreation && _publicShareCreation)\r\n            || (_initialSharePriceMultiplier != 0\r\n                && (_minutesFundingPeriod < minMinutesPeriods\r\n                    || _inflationRate > maxInflationRate\r\n                    || _minutesFundingPeriod > maxMinutesFundingPeriod)))) throw;\r\n\r\n        uint _proposalID = Proposals.length++;\r\n        Proposal p = Proposals[_proposalID];\r\n\r\n        p.contractorManager = PassManager(_contractorManager);\r\n        p.contractorProposalID = _contractorProposalID;\r\n        \r\n        p.amount = _amount;\r\n        p.tokenCreation = _tokenCreation;\r\n\r\n        p.publicShareCreation = _publicShareCreation;\r\n        p.mainPartner = _mainPartner;\r\n        p.initialSharePriceMultiplier = _initialSharePriceMultiplier;\r\n        p.inflationRate = _inflationRate;\r\n        p.minutesFundingPeriod = _minutesFundingPeriod;\r\n\r\n        p.boardMeetingID = newBoardMeeting(_proposalID, 0, _minutesDebatingPeriod);   \r\n\r\n        p.open = true;\r\n        \r\n        if (_contractorProposalID != 0) {\r\n            ContractorProposalAdded(_proposalID, p.boardMeetingID, p.contractorManager, p.contractorProposalID, p.amount);\r\n            if (_initialSharePriceMultiplier != 0) {\r\n                FundingProposalAdded(_proposalID, p.boardMeetingID, true, p.amount, p.mainPartner, \r\n                    p.initialSharePriceMultiplier, _inflationRate, _minutesFundingPeriod);\r\n            }\r\n        }\r\n        else if (_initialSharePriceMultiplier != 0) {\r\n                FundingProposalAdded(_proposalID, p.boardMeetingID, false, p.amount, p.mainPartner, \r\n                    p.initialSharePriceMultiplier, _inflationRate, _minutesFundingPeriod);\r\n        }\r\n\r\n        return _proposalID;\r\n        \r\n    }\r\n\r\n    function newDaoRulesProposal(\r\n        uint _minQuorumDivisor, \r\n        uint _minBoardMeetingFees,\r\n        uint _minutesSetProposalPeriod,\r\n        uint _minMinutesDebatePeriod,\r\n        uint _feesRewardInflationRate,\r\n        bool _transferable,\r\n        address _newDao,\r\n        uint _minutesForTokensCloning,\r\n        uint _minutesDebatingPeriod\r\n    ) payable returns (uint) {\r\n    \r\n        if (_minQuorumDivisor <= 1\r\n            || _minQuorumDivisor > 10\r\n            || _minutesSetProposalPeriod < minMinutesPeriods\r\n            || _minMinutesDebatePeriod < minMinutesPeriods\r\n            || _minutesSetProposalPeriod + _minMinutesDebatePeriod > maxMinutesProposalPeriod\r\n            || _feesRewardInflationRate > maxInflationRate\r\n            ) throw; \r\n        \r\n        uint _DaoRulesProposalID = DaoRulesProposals.length++;\r\n        Rules r = DaoRulesProposals[_DaoRulesProposalID];\r\n\r\n        r.minQuorumDivisor = _minQuorumDivisor;\r\n        r.minBoardMeetingFees = _minBoardMeetingFees;\r\n        r.minutesSetProposalPeriod = _minutesSetProposalPeriod;\r\n        r.minMinutesDebatePeriod = _minMinutesDebatePeriod;\r\n        r.feesRewardInflationRate = _feesRewardInflationRate;\r\n        r.transferable = _transferable;\r\n        r.newdao = _newDao;\r\n        r.minutesForTokensCloning = _minutesForTokensCloning;\r\n\r\n        r.boardMeetingID = newBoardMeeting(0, _DaoRulesProposalID, _minutesDebatingPeriod);     \r\n\r\n        DaoRulesProposalAdded(_DaoRulesProposalID, r.boardMeetingID, _minQuorumDivisor, _minBoardMeetingFees, \r\n            _minutesSetProposalPeriod, _minMinutesDebatePeriod, _feesRewardInflationRate ,_transferable, _newDao ,_minutesForTokensCloning);\r\n\r\n        return _DaoRulesProposalID;\r\n        \r\n    }\r\n    \r\n    function vote(\r\n        uint _boardMeetingID, \r\n        bool _supportsProposal\r\n    ) {\r\n        \r\n        BoardMeeting b = BoardMeetings[_boardMeetingID];\r\n\r\n        if (b.hasVoted[msg.sender] \r\n            || now < b.setDeadline\r\n            || now > b.votingDeadline) throw;\r\n\r\n        uint _balance = uint(daoManager.balanceOf(msg.sender));\r\n        if (_balance == 0) throw;\r\n        \r\n        b.hasVoted[msg.sender] = true;\r\n\r\n        if (_supportsProposal) b.yea += _balance;\r\n        else b.nay += _balance; \r\n\r\n        if (b.fees > 0 && b.proposalID != 0 && Proposals[b.proposalID].contractorProposalID != 0) {\r\n\r\n            uint _a = 100*b.fees;\r\n            if ((_a/100 != b.fees) || ((_a*_balance)/_a != _balance)) throw;\r\n            uint _multiplier = (_a*_balance)/uint(daoManager.totalSupply());\r\n\r\n            uint _divisor = 100 + 100*DaoRules.feesRewardInflationRate*(now - b.setDeadline)/(100*365 days);\r\n\r\n            uint _rewardedamount = _multiplier/_divisor;\r\n            \r\n            if (b.totalRewardedAmount + _rewardedamount > b.fees) _rewardedamount = b.fees - b.totalRewardedAmount;\r\n            b.totalRewardedAmount += _rewardedamount;\r\n            pendingFees[msg.sender] += _rewardedamount;\r\n        }\r\n\r\n        Voted(_boardMeetingID, b.proposalID, b.daoRulesProposalID, _supportsProposal, msg.sender);\r\n        \r\n        daoManager.blockTransfer(msg.sender, b.votingDeadline);\r\n\r\n    }\r\n\r\n    function executeDecision(uint _boardMeetingID) returns (bool) {\r\n\r\n        BoardMeeting b = BoardMeetings[_boardMeetingID];\r\n        Proposal p = Proposals[b.proposalID];\r\n        \r\n        if (now < b.votingDeadline || !b.open) throw;\r\n        \r\n        b.open = false;\r\n        if (p.contractorProposalID == 0) p.open = false;\r\n\r\n        uint _fees;\r\n        uint _minQuorum = minQuorum();\r\n\r\n        if (b.fees > 0\r\n            && (b.proposalID == 0 || p.contractorProposalID == 0)\r\n            && b.yea + b.nay >= _minQuorum) {\r\n                    _fees = b.fees;\r\n                    b.fees = 0;\r\n                    pendingFees[b.creator] += _fees;\r\n        }        \r\n\r\n        uint _balance = b.fees - b.totalRewardedAmount;\r\n        if (_balance > 0) {\r\n            if (!daoManager.send(_balance)) throw;\r\n        }\r\n        \r\n        if (b.yea + b.nay < _minQuorum || b.yea <= b.nay) {\r\n            p.open = false;\r\n            ProposalClosed(b.proposalID, b.daoRulesProposalID, _boardMeetingID, _fees, false, _balance);\r\n            return;\r\n        }\r\n\r\n        b.dateOfExecution = now;\r\n\r\n        if (b.proposalID != 0) {\r\n            \r\n            if (p.initialSharePriceMultiplier != 0) {\r\n\r\n                daoManager.setFundingRules(p.mainPartner, p.publicShareCreation, p.initialSharePriceMultiplier, \r\n                    p.amount, p.minutesFundingPeriod, p.inflationRate, b.proposalID);\r\n\r\n                if (p.contractorProposalID != 0 && p.tokenCreation) {\r\n                    p.contractorManager.setFundingRules(p.mainPartner, p.publicShareCreation, 0, \r\n                        p.amount, p.minutesFundingPeriod, maxInflationRate, b.proposalID);\r\n                }\r\n\r\n            }\r\n            \r\n        } else {\r\n\r\n            Rules r = DaoRulesProposals[b.daoRulesProposalID];\r\n            DaoRules.boardMeetingID = r.boardMeetingID;\r\n\r\n            DaoRules.minQuorumDivisor = r.minQuorumDivisor;\r\n            DaoRules.minMinutesDebatePeriod = r.minMinutesDebatePeriod; \r\n            DaoRules.minBoardMeetingFees = r.minBoardMeetingFees;\r\n            DaoRules.minutesSetProposalPeriod = r.minutesSetProposalPeriod;\r\n            DaoRules.feesRewardInflationRate = r.feesRewardInflationRate;\r\n\r\n            DaoRules.transferable = r.transferable;\r\n            if (r.transferable) daoManager.ableTransfer();\r\n            else daoManager.disableTransfer(0);\r\n            \r\n            if (r.minutesForTokensCloning != 0) {\r\n                closingTimeForCloning = now + (r.minutesForTokensCloning * 1 minutes);\r\n                daoManager.disableTransfer(closingTimeForCloning);\r\n            }\r\n\r\n            if ((r.newdao != 0) && (r.newdao != address(this))) {\r\n                DaoRules.newdao = r.newdao;\r\n                daoManager.updateClient(r.newdao);\r\n                DaoUpgraded(r.newdao);\r\n            }\r\n            \r\n        }\r\n\r\n        ProposalClosed(b.proposalID, b.daoRulesProposalID, _boardMeetingID ,_fees, true, _balance);\r\n            \r\n        return true;\r\n        \r\n    }\r\n    \r\n    function orderContractorProposal(uint _proposalID) returns (bool) {\r\n        \r\n        Proposal p = Proposals[_proposalID];\r\n        BoardMeeting b = BoardMeetings[p.boardMeetingID];\r\n\r\n        if (b.open || !p.open) throw;\r\n        \r\n        uint _amount = p.amount;\r\n\r\n        if (p.initialSharePriceMultiplier != 0) {\r\n            _amount = daoManager.FundedAmount(_proposalID);\r\n            if (_amount == 0 && now < b.dateOfExecution + (p.minutesFundingPeriod * 1 minutes)) return;\r\n        }\r\n        \r\n        p.open = false;   \r\n\r\n        if (_amount == 0 || !p.contractorManager.order(_proposalID, p.contractorProposalID, _amount)) return;\r\n        \r\n        if (!daoManager.sendTo(p.contractorManager, _amount)) throw;\r\n        SentToContractor(_proposalID, p.contractorProposalID, address(p.contractorManager), _amount);\r\n        \r\n        addContractor(address(p.contractorManager), now);\r\n        \r\n        return true;\r\n\r\n    }\r\n    \r\n    function withdrawBoardMeetingFees() returns (bool) {\r\n\r\n        uint _amount = pendingFees[msg.sender];\r\n\r\n        pendingFees[msg.sender] = 0;\r\n\r\n        if (msg.sender.send(_amount)) {\r\n            Withdrawal(msg.sender, _amount);\r\n            return true;\r\n        } else {\r\n            pendingFees[msg.sender] = _amount;\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    function PendingFees(address _shareHolder) constant returns (uint) {\r\n        return (pendingFees[_shareHolder]);\r\n    }\r\n    \r\n    function minQuorum() constant returns (uint) {\r\n        return (uint(daoManager.totalSupply()) / DaoRules.minQuorumDivisor);\r\n    }\r\n\r\n    function numberOfContractors() constant returns (uint) {\r\n        return Contractors.length - 1;\r\n    }\r\n    \r\n    function numberOfBoardMeetings() constant returns (uint) {\r\n        return BoardMeetings.length - 1;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTimeForCloning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BoardMeetings\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"proposalID\",\"type\":\"uint256\"},{\"name\":\"daoRulesProposalID\",\"type\":\"uint256\"},{\"name\":\"setDeadline\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"totalRewardedAmount\",\"type\":\"uint256\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"dateOfExecution\",\"type\":\"uint256\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_boardMeetingID\",\"type\":\"uint256\"}],\"name\":\"executeDecision\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shareHolder\",\"type\":\"address\"}],\"name\":\"PendingFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBoardMeetings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smartContractStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractorManager\",\"type\":\"address\"},{\"name\":\"_creationDate\",\"type\":\"uint256\"}],\"name\":\"cloneContractor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minMinutesPeriods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxInflationRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Contractors\",\"outputs\":[{\"name\":\"contractorManager\",\"type\":\"address\"},{\"name\":\"creationDate\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractorManager\",\"type\":\"address\"},{\"name\":\"_contractorProposalID\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_tokenCreation\",\"type\":\"bool\"},{\"name\":\"_publicShareCreation\",\"type\":\"bool\"},{\"name\":\"_mainPartner\",\"type\":\"address\"},{\"name\":\"_initialSharePriceMultiplier\",\"type\":\"uint256\"},{\"name\":\"_inflationRate\",\"type\":\"uint256\"},{\"name\":\"_minutesFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_minutesDebatingPeriod\",\"type\":\"uint256\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DaoRules\",\"outputs\":[{\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"name\":\"minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"minBoardMeetingFees\",\"type\":\"uint256\"},{\"name\":\"minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"feesRewardInflationRate\",\"type\":\"uint256\"},{\"name\":\"transferable\",\"type\":\"bool\"},{\"name\":\"newdao\",\"type\":\"address\"},{\"name\":\"minutesForTokensCloning\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMinutesProposalPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBoardMeetingFees\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_daoManager\",\"type\":\"address\"},{\"name\":\"_maxInflationRate\",\"type\":\"uint256\"},{\"name\":\"_minMinutesPeriods\",\"type\":\"uint256\"},{\"name\":\"_maxMinutesFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_maxMinutesProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"_minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"_minBoardMeetingFees\",\"type\":\"uint256\"},{\"name\":\"_minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"_minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"_feesRewardInflationRate\",\"type\":\"uint256\"}],\"name\":\"initDao\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMinutesFundingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"_minBoardMeetingFees\",\"type\":\"uint256\"},{\"name\":\"_minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"_minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"_feesRewardInflationRate\",\"type\":\"uint256\"},{\"name\":\"_transferable\",\"type\":\"bool\"},{\"name\":\"_newDao\",\"type\":\"address\"},{\"name\":\"_minutesForTokensCloning\",\"type\":\"uint256\"},{\"name\":\"_minutesDebatingPeriod\",\"type\":\"uint256\"}],\"name\":\"newDaoRulesProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_boardMeetingID\",\"type\":\"uint256\"},{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DaoRulesProposals\",\"outputs\":[{\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"name\":\"minQuorumDivisor\",\"type\":\"uint256\"},{\"name\":\"minBoardMeetingFees\",\"type\":\"uint256\"},{\"name\":\"minutesSetProposalPeriod\",\"type\":\"uint256\"},{\"name\":\"minMinutesDebatePeriod\",\"type\":\"uint256\"},{\"name\":\"feesRewardInflationRate\",\"type\":\"uint256\"},{\"name\":\"transferable\",\"type\":\"bool\"},{\"name\":\"newdao\",\"type\":\"address\"},{\"name\":\"minutesForTokensCloning\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Proposals\",\"outputs\":[{\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"name\":\"contractorManager\",\"type\":\"address\"},{\"name\":\"contractorProposalID\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"tokenCreation\",\"type\":\"bool\"},{\"name\":\"publicShareCreation\",\"type\":\"bool\"},{\"name\":\"mainPartner\",\"type\":\"address\"},{\"name\":\"initialSharePriceMultiplier\",\"type\":\"uint256\"},{\"name\":\"inflationRate\",\"type\":\"uint256\"},{\"name\":\"minutesFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"orderContractorProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daoManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfContractors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_projectName\",\"type\":\"string\"},{\"name\":\"_lastDao\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ContractorID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ContractorManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"CreationDate\",\"type\":\"uint256\"}],\"name\":\"ContractorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ContractorManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ContractorProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContractorProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"LinkedToContractorProposal\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MainPartner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"InitialSharePriceMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"InflationRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinutesFundingPeriod\",\"type\":\"uint256\"}],\"name\":\"FundingProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"DaoRulesProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinQuorumDivisor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinBoardMeetingFees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinutesSetProposalPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinMinutesDebatePeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"FeesRewardInflationRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Transferable\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"NewDao\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"MinutesForTokensCloning\",\"type\":\"uint256\"}],\"name\":\"DaoRulesProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"DaoRulesProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"DaoRulesProposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"boardMeetingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"FeesGivenBack\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ProposalExecuted\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"BalanceSentToDaoManager\",\"type\":\"uint256\"}],\"name\":\"ProposalClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ContractorProposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ContractorManagerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"AmountSent\",\"type\":\"uint256\"}],\"name\":\"SentToContractor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"NewDao\",\"type\":\"address\"}],\"name\":\"DaoUpgraded\",\"type\":\"event\"}]","ContractName":"PassDao","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000003730117f77ac04eec364bf72a656010fa4703d76000000000000000000000000000000000000000000000000000000000000001d412064697374726962757465642064656c69766572792073797374656d000000","Library":"","SwarmSource":""}]}