{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n/**\r\n * ----------------\r\n * Application-agnostic user permission (owner, manager) contract\r\n * ----------------\r\n */\r\ncontract withOwners {\r\n  uint public ownersCount = 0;\r\n  uint public managersCount = 0;\r\n\r\n  /**\r\n   * Owner: full privilege\r\n   * Manager: lower privilege (set status, but not withdraw)\r\n   */\r\n  mapping (address => bool) public owners;\r\n  mapping (address => bool) public managers;\r\n\r\n  modifier onlyOwners {\r\n    if (owners[msg.sender] != true) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyManagers {\r\n    if (owners[msg.sender] != true && managers[msg.sender] != true) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function addOwner(address _candidate) public onlyOwners {\r\n    if (owners[_candidate] == true) {\r\n      throw; // already owner\r\n    }\r\n\r\n    owners[_candidate] = true;\r\n    ++ownersCount;\r\n  }\r\n\r\n  function removeOwner(address _candidate) public onlyOwners {\r\n    // Stop removing the only/last owner\r\n    if (ownersCount <= 1 || owners[_candidate] == false) {\r\n      throw;\r\n    }\r\n\r\n    owners[_candidate] = false;\r\n    --ownersCount;\r\n  }\r\n\r\n  function addManager(address _candidate) public onlyOwners {\r\n    if (managers[_candidate] == true) {\r\n      throw; // already manager\r\n    }\r\n\r\n    managers[_candidate] = true;\r\n    ++managersCount;\r\n  }\r\n\r\n  function removeManager(address _candidate) public onlyOwners {\r\n    if (managers[_candidate] == false) {\r\n      throw;\r\n    }\r\n\r\n    managers[_candidate] = false;\r\n    --managersCount;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * ----------------\r\n * Application-agnostic user account contract\r\n * ----------------\r\n */\r\ncontract withAccounts is withOwners {\r\n  uint defaultTimeoutPeriod = 2 days; // if locked fund is not settled within timeout period, account holders can refund themselves\r\n\r\n  struct AccountTx {\r\n    uint timeCreated;\r\n    address user;\r\n    uint amountHeld;\r\n    uint amountSpent;\r\n    uint8 state; // 1: on-hold/locked; 2: processed and refunded;\r\n  }\r\n\r\n  uint public txCount = 0;\r\n  mapping (uint => AccountTx) public accountTxs;\r\n  //mapping (address => uint) public userTxs;\r\n\r\n  /**\r\n   * Handling user account funds\r\n   */\r\n  uint public availableBalance = 0;\r\n  uint public onholdBalance = 0;\r\n  uint public spentBalance = 0; // total withdrawal balance by owner (service provider)\r\n\r\n  mapping (address => uint) public availableBalances;\r\n  mapping (address => uint) public onholdBalances;\r\n  mapping (address => bool) public doNotAutoRefund;\r\n\r\n  modifier handleDeposit {\r\n    deposit(msg.sender, msg.value);\r\n    _;\r\n  }\r\n\r\n/**\r\n * ----------------------\r\n * PUBLIC FUNCTIONS\r\n * ----------------------\r\n */\r\n\r\n  /**\r\n   * Deposit into other's account\r\n   * Useful for services that you wish to not hold funds and not having to keep refunding after every tx and wasting gas\r\n   */\r\n  function depositFor(address _address) public payable {\r\n    deposit(_address, msg.value);\r\n  }\r\n\r\n  /**\r\n   * Account owner withdraw funds\r\n   * leave blank at _amount to collect all funds on user's account\r\n   */\r\n  function withdraw(uint _amount) public {\r\n    if (_amount == 0) {\r\n      _amount = availableBalances[msg.sender];\r\n    }\r\n    if (_amount > availableBalances[msg.sender]) {\r\n      throw;\r\n    }\r\n\r\n    incrUserAvailBal(msg.sender, _amount, false);\r\n    if (!msg.sender.call.value(_amount)()) {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if an AccountTx is timed out\r\n   * can be called by anyone, not only account owner or provider\r\n   * If an AccountTx is already timed out, return balance to the user's available balance.\r\n   */\r\n  function checkTimeout(uint _id) public {\r\n    if (\r\n      accountTxs[_id].state != 1 ||\r\n      (now - accountTxs[_id].timeCreated) < defaultTimeoutPeriod\r\n    ) {\r\n      throw;\r\n    }\r\n\r\n    settle(_id, 0); // no money is spent, settle the tx\r\n\r\n    // Specifically for Notification contract\r\n    // updateState(_id, 60, 0);\r\n  }\r\n\r\n  /**\r\n   * Sets doNotAutoRefundTo of caller's account to:\r\n   * true: stops auto refund after every single transaction\r\n   * false: proceeds with auto refund after every single transaction\r\n   *\r\n   * Manually use withdraw() to withdraw available funds\r\n   */\r\n  function setDoNotAutoRefundTo(bool _option) public {\r\n    doNotAutoRefund[msg.sender] = _option;\r\n  }\r\n\r\n  /**\r\n   * Update defaultTimeoutPeriod\r\n   */\r\n  function updateDefaultTimeoutPeriod(uint _defaultTimeoutPeriod) public onlyOwners {\r\n    if (_defaultTimeoutPeriod < 1 hours) {\r\n      throw;\r\n    }\r\n\r\n    defaultTimeoutPeriod = _defaultTimeoutPeriod;\r\n  }\r\n\r\n  /**\r\n   * Owner - collect spentBalance\r\n   */\r\n  function collectRev() public onlyOwners {\r\n    uint amount = spentBalance;\r\n    spentBalance = 0;\r\n\r\n    if (!msg.sender.call.value(amount)()) {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Owner: release availableBalance to account holder\r\n   * leave blank at _amount to release all\r\n   * set doNotAutoRefund to true to stop auto funds returning (keep funds on user's available balance account)\r\n   */\r\n  function returnFund(address _user, uint _amount) public onlyManagers {\r\n    if (doNotAutoRefund[_user] || _amount > availableBalances[_user]) {\r\n      throw;\r\n    }\r\n    if (_amount == 0) {\r\n      _amount = availableBalances[_user];\r\n    }\r\n\r\n    incrUserAvailBal(_user, _amount, false);\r\n    if (!_user.call.value(_amount)()) {\r\n      throw;\r\n    }\r\n  }\r\n\r\n/**\r\n * ----------------------\r\n * INTERNAL FUNCTIONS\r\n * ----------------------\r\n */\r\n\r\n  /**\r\n   * Deposit funds into account\r\n   */\r\n  function deposit(address _user, uint _amount) internal {\r\n    if (_amount > 0) {\r\n      incrUserAvailBal(_user, _amount, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a transaction\r\n   */\r\n  function createTx(uint _id, address _user, uint _amount) internal {\r\n    if (_amount > availableBalances[_user]) {\r\n      throw;\r\n    }\r\n\r\n    accountTxs[_id] = AccountTx({\r\n      timeCreated: now,\r\n      user: _user,\r\n      amountHeld: _amount,\r\n      amountSpent: 0,\r\n      state: 1 // on hold\r\n    });\r\n\r\n    incrUserAvailBal(_user, _amount, false);\r\n    incrUserOnholdBal(_user, _amount, true);\r\n  }\r\n\r\n  function settle(uint _id, uint _amountSpent) internal {\r\n    if (accountTxs[_id].state != 1 || _amountSpent > accountTxs[_id].amountHeld) {\r\n      throw;\r\n    }\r\n\r\n    // Deliberately not checking for timeout period\r\n    // because if provider has actual update, it should stand\r\n\r\n    accountTxs[_id].amountSpent = _amountSpent;\r\n    accountTxs[_id].state = 2; // processed and refunded;\r\n\r\n    spentBalance += _amountSpent;\r\n    uint changeAmount = accountTxs[_id].amountHeld - _amountSpent;\r\n\r\n    incrUserOnholdBal(accountTxs[_id].user, accountTxs[_id].amountHeld, false);\r\n    incrUserAvailBal(accountTxs[_id].user, changeAmount, true);\r\n  }\r\n\r\n  function incrUserAvailBal(address _user, uint _by, bool _increase) internal {\r\n    if (_increase) {\r\n      availableBalances[_user] += _by;\r\n      availableBalance += _by;\r\n    } else {\r\n      availableBalances[_user] -= _by;\r\n      availableBalance -= _by;\r\n    }\r\n  }\r\n\r\n  function incrUserOnholdBal(address _user, uint _by, bool _increase) internal {\r\n    if (_increase) {\r\n      onholdBalances[_user] += _by;\r\n      onholdBalance += _by;\r\n    } else {\r\n      onholdBalances[_user] -= _by;\r\n      onholdBalance -= _by;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract Notifier is withOwners, withAccounts {\r\n  string public xIPFSPublicKey;\r\n  uint public minEthPerNotification = 0.02 ether;\r\n\r\n  struct Task {\r\n    address sender;\r\n    uint8 state; // 10: pending\r\n                 // 20: processed, but tx still open\r\n                 // [ FINAL STATES >= 50 ]\r\n                 // 50: processed, costing done, tx settled\r\n                 // 60: rejected or error-ed, costing done, tx settled\r\n\r\n    bool isxIPFS;  // true: IPFS-augmented call (xIPFS); false: on-chain call\r\n  }\r\n\r\n  struct Notification {\r\n    uint8 transport; // 1: sms, 2: email\r\n    string destination;\r\n    string message;\r\n  }\r\n\r\n  mapping(uint => Task) public tasks;\r\n  mapping(uint => Notification) public notifications;\r\n  mapping(uint => string) public xnotifications; // IPFS-augmented Notification (hash)\r\n  uint public tasksCount = 0;\r\n\r\n  /**\r\n   * Events to be picked up by API\r\n   */\r\n  event TaskUpdated(uint id, uint8 state);\r\n\r\n  function Notifier(string _xIPFSPublicKey) public {\r\n    xIPFSPublicKey = _xIPFSPublicKey;\r\n    ownersCount++;\r\n    owners[msg.sender] = true;\r\n  }\r\n\r\n/**\r\n * --------------\r\n * Main functions\r\n * --------------\r\n */\r\n\r\n  /**\r\n   * Sends notification\r\n   */\r\n  function notify(uint8 _transport, string _destination, string _message) public payable handleDeposit {\r\n    if (_transport != 1 && _transport != 2) {\r\n      throw;\r\n    }\r\n\r\n    uint id = tasksCount;\r\n    uint8 state = 10; // pending\r\n\r\n    createTx(id, msg.sender, minEthPerNotification);\r\n    notifications[id] = Notification({\r\n      transport: _transport,\r\n      destination: _destination,\r\n      message: _message\r\n    });\r\n    tasks[id] = Task({\r\n      sender: msg.sender,\r\n      state: state,\r\n      isxIPFS: false // on-chain\r\n    });\r\n\r\n    TaskUpdated(id, state);\r\n    ++tasksCount;\r\n  }\r\n\r\n/**\r\n * --------------\r\n * Extended functions, for\r\n * - IPFS-augmented calls\r\n * - Encrypted calls\r\n * --------------\r\n */\r\n\r\n  function xnotify(string _hash) public payable handleDeposit {\r\n    uint id = tasksCount;\r\n    uint8 state = 10; // pending\r\n\r\n    createTx(id, msg.sender, minEthPerNotification);\r\n    xnotifications[id] = _hash;\r\n    tasks[id] = Task({\r\n      sender: msg.sender,\r\n      state: state,\r\n      isxIPFS: true\r\n    });\r\n\r\n    TaskUpdated(id, state);\r\n    ++tasksCount;\r\n  }\r\n\r\n/**\r\n * --------------\r\n * Owner-only functions\r\n * ---------------\r\n */\r\n\r\n  function updateMinEthPerNotification(uint _newMin) public onlyManagers {\r\n    minEthPerNotification = _newMin;\r\n  }\r\n\r\n  /**\r\n   * Mark task as processed, but no costing yet\r\n   * This is an optional state\r\n   */\r\n  function taskProcessedNoCosting(uint _id) public onlyManagers {\r\n    updateState(_id, 20, 0);\r\n  }\r\n\r\n  /**\r\n   * Mark task as processed, and process funds + costings\r\n   * This is a FINAL state\r\n   */\r\n  function taskProcessedWithCosting(uint _id, uint _cost) public onlyManagers {\r\n    updateState(_id, 50, _cost);\r\n  }\r\n\r\n  /**\r\n   * Mark task as rejected or error-ed,  and processed funds + costings\r\n   * This is a FINAL state\r\n   */\r\n  function taskRejected(uint _id, uint _cost) public onlyManagers {\r\n    updateState(_id, 60, _cost);\r\n  }\r\n\r\n  /**\r\n   * Update public key for xIPFS\r\n   */\r\n  function updateXIPFSPublicKey(string _publicKey) public onlyOwners {\r\n    xIPFSPublicKey = _publicKey;\r\n  }\r\n\r\n  function updateState(uint _id, uint8 _state, uint _cost) internal {\r\n    if (tasks[_id].state == 0 || tasks[_id].state >= 50) {\r\n      throw;\r\n    }\r\n\r\n    tasks[_id].state = _state;\r\n\r\n    // Cost settlement is done only for final states (>= 50)\r\n    if (_state >= 50) {\r\n      settle(_id, _cost);\r\n    }\r\n    TaskUpdated(_id, _state);\r\n  }\r\n\r\n  /**\r\n   * Handle deposits\r\n   */\r\n  function () payable handleDeposit {\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"returnFund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_publicKey\",\"type\":\"string\"}],\"name\":\"updateXIPFSPublicKey\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"notifications\",\"outputs\":[{\"name\":\"transport\",\"type\":\"uint8\"},{\"name\":\"destination\",\"type\":\"string\"},{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_cost\",\"type\":\"uint256\"}],\"name\":\"taskProcessedWithCosting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_option\",\"type\":\"bool\"}],\"name\":\"setDoNotAutoRefundTo\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectRev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEthPerNotification\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"checkTimeout\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"xnotify\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"doNotAutoRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"xnotifications\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"isxIPFS\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"taskProcessedNoCosting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_cost\",\"type\":\"uint256\"}],\"name\":\"taskRejected\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultTimeoutPeriod\",\"type\":\"uint256\"}],\"name\":\"updateDefaultTimeoutPeriod\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tasksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"onholdBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spentBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"availableBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xIPFSPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountTxs\",\"outputs\":[{\"name\":\"timeCreated\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amountHeld\",\"type\":\"uint256\"},{\"name\":\"amountSpent\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMin\",\"type\":\"uint256\"}],\"name\":\"updateMinEthPerNotification\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onholdBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transport\",\"type\":\"uint8\"},{\"name\":\"_destination\",\"type\":\"string\"},{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"notify\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_xIPFSPublicKey\",\"type\":\"string\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"TaskUpdated\",\"type\":\"event\"}]","ContractName":"Notifier","CompilerVersion":"v0.4.4-nightly.2016.10.28+commit.e85390cc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}