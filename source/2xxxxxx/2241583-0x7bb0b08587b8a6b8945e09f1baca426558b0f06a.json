{"status":"1","message":"OK","result":[{"SourceCode":"contract DSFalseFallback {\r\n    function() returns (bool) {\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract DSTrueFallback {\r\n    function() returns (bool) {\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract DSAuthModesEnum {\r\n    enum DSAuthModes {\r\n        Owner,\r\n        Authority\r\n    }\r\n}\r\n\r\ncontract DSAuthUtils is DSAuthModesEnum {\r\n    function setOwner( DSAuthorized what, address owner ) internal {\r\n        what.updateAuthority( owner, DSAuthModes.Owner );\r\n    }\r\n    function setAuthority( DSAuthorized what, DSAuthority authority ) internal {\r\n        what.updateAuthority( authority, DSAuthModes.Authority );\r\n    }\r\n}\r\ncontract DSAuthorizedEvents is DSAuthModesEnum {\r\n    event DSAuthUpdate( address indexed auth, DSAuthModes indexed mode );\r\n}\r\n\r\n\r\n// `DSAuthority` is the interface which `DSAuthorized` (`DSAuth`) contracts expect\r\n// their authority to be when they are in the remote auth mode.\r\ncontract DSAuthority {\r\n    // `can_call` will be called with these arguments in the caller's\r\n    // scope if it is coming from an `auth()` call:\r\n    // `DSAuthority(_ds_authority).can_call(msg.sender, address(this), msg.sig);`\r\n    function canCall( address caller\r\n                    , address callee\r\n                    , bytes4 sig )\r\n             constant\r\n             returns (bool);\r\n}\r\n\r\n\r\ncontract AcceptingAuthority is DSTrueFallback {}\r\ncontract RejectingAuthority is DSFalseFallback {}\r\n\r\n// `DSAuthorized` is a mixin contract which enables standard authorization patterns.\r\n// It has a shorter alias `auth/auth.sol: DSAuth` because it is so common.\r\ncontract DSAuthorized is DSAuthModesEnum, DSAuthorizedEvents\r\n{\r\n    // There are two \"modes\":\r\n    // * \"owner mode\", where `auth()` simply checks if the sender is `_authority`.\r\n    //   This is the default mode, when `_auth_mode` is false.\r\n    // * \"authority mode\", where `auth()` makes a call to\r\n    // `DSAuthority(_authority).canCall(sender, this, sig)` to ask if the\r\n    // call should be allowed.\r\n    DSAuthModes  public _auth_mode;\r\n    DSAuthority  public _authority;\r\n\r\n    function DSAuthorized() {\r\n        _authority = DSAuthority(msg.sender);\r\n        _auth_mode = DSAuthModes.Owner;\r\n        DSAuthUpdate( msg.sender, DSAuthModes.Owner );\r\n    }\r\n\r\n    // Attach the `auth()` modifier to functions to protect them.\r\n    modifier auth() {\r\n        if( isAuthorized() ) {\r\n            _\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    // A version of `auth()` which implicitly returns garbage instead of throwing.\r\n    modifier try_auth() {\r\n        if( isAuthorized() ) {\r\n            _\r\n        }\r\n    }\r\n\r\n    // An internal helper function for if you want to use the `auth()` logic\r\n    // someplace other than the modifier (like in a fallback function).\r\n    function isAuthorized() internal returns (bool is_authorized) {\r\n        if( _auth_mode == DSAuthModes.Owner ) {\r\n            return msg.sender == address(_authority);\r\n        }\r\n        if( _auth_mode == DSAuthModes.Authority ) { // use `canCall` in \"authority\" mode\r\n            return _authority.canCall( msg.sender, address(this), msg.sig );\r\n        }\r\n        throw;\r\n    }\r\n\r\n    // This function is used to both transfer the authority and update the mode.\r\n    // Be extra careful about setting *both* correctly every time.\r\n    function updateAuthority( address new_authority, DSAuthModes mode )\r\n             auth()\r\n    {\r\n        _authority = DSAuthority(new_authority);\r\n        _auth_mode = mode;\r\n        DSAuthUpdate( new_authority, mode );\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DSAuth is DSAuthorized {} //, is DSAuthorizedEvents, DSAuthModesEnum\r\ncontract DSAuthUser is DSAuthUtils {} //, is DSAuthModesEnum {}\r\n\r\ncontract DSActionStructUser {\r\n    struct Action {\r\n        address target;\r\n        uint value;\r\n        bytes calldata;\r\n        // bool triggered;\r\n    }\r\n    // todo store call_ret by default?\r\n}\r\n// A base contract used by governance contracts in `gov` and by the generic `DSController`.\r\ncontract DSBaseActor is DSActionStructUser {\r\n    // todo gas???\r\n    function tryExec(Action a) internal returns (bool call_ret) {\r\n        return a.target.call.value(a.value)(a.calldata);\r\n    }\r\n    function exec(Action a) internal {\r\n        if(!tryExec(a)) {\r\n            throw;\r\n        }\r\n    }\r\n    function tryExec( address target, bytes calldata, uint value)\r\n             internal\r\n             returns (bool call_ret)\r\n    {\r\n        return target.call.value(value)(calldata);\r\n    }\r\n    function exec( address target, bytes calldata, uint value)\r\n             internal\r\n    {\r\n        if(!tryExec(target, calldata, value)) {\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSEasyMultisigEvents {\r\n    event MemberAdded(address who);\r\n    event Proposed(uint indexed action_id, bytes calldata);\r\n    event Confirmed(uint indexed action_id, address who);\r\n    event Triggered(uint indexed action_id);\r\n}\r\n\r\n/* A multisig actor optimized for ease of use.\r\n * The user never has to pack their own calldata. Instead, use `easyPropose`.\r\n * This eliminates the need for UI support or helper contracts.\r\n *\r\n * To set up the multisig, specify the arguments, then add members\r\n *\r\n * First, call the multisig contract itself as if it were your target contract,\r\n * with the correct calldata. You can make Solidity and web3.js to do this for\r\n * you very easily by casting the multisig address as the target type.\r\n * Then, you call `easyPropose` with the missing arguments. This calls `propose`.\r\n *\r\n * \"last calldata\" is \"local\" to the `msg.sender`. This makes it usable directly\r\n * from keys (but still not as secure as if it were atomic using a helper contract).\r\n *\r\n * In Soldity:\r\n * 1) `TargetType(address(multisig)).doAction(arg1, arg2);`\r\n * 2) `multisig.easyPropose(address(target), value);`\r\n *\r\n * This is equivalent to `propose(address(my_target), <calldata>, value);`,\r\n * where calldata is correctly formatted for `TargetType(target).doAction(arg1, arg2)`\r\n */\r\ncontract DSEasyMultisig is DSBaseActor\r\n                         , DSEasyMultisigEvents\r\n                         , DSAuthUser\r\n                         , DSAuth\r\n{\r\n    // How many confirmations an action needs to execute.\r\n    uint _required;\r\n    // How many members this multisig has. Members must be distinct addresses.\r\n    uint _member_count;\r\n    // Auto-locks once this reaches zero - easy setup phase.\r\n    uint _members_remaining;\r\n    // Maximum time between proposal time and trigger time.\r\n    uint _expiration;\r\n    // Action counter\r\n    uint _last_action_id;\r\n\r\n\r\n    struct action {\r\n        address target;\r\n        bytes calldata;\r\n        uint value;\r\n\r\n        uint confirmations; // If this number reaches `required`, you can trigger\r\n        uint expiration; // Last timestamp this action can execute\r\n        bool triggered; // Was this action successfully triggered (multisig does not catch exceptions)\r\n    }\r\n\r\n    mapping( uint => action ) actions;\r\n\r\n    // action_id -> member -> confirmed\r\n    mapping( uint => mapping( address => bool ) ) confirmations;\r\n    // A record of the last fallback calldata recorded for this sender.\r\n    // This is an easy way to create proposals for most actions.\r\n    mapping( address => bytes ) easy_calldata;\r\n    // Only these addresses can add confirmations\r\n    mapping( address => bool ) is_member;\r\n\r\n    function DSEasyMultisig( uint required, uint member_count, uint expiration ) {\r\n        _required = required;\r\n        _member_count = member_count;\r\n        _members_remaining = member_count;\r\n        _expiration = expiration;\r\n    }\r\n    // The authority can add members until they reach `member_count`, and then\r\n    // the contract is finalized (`updateAuthority(0, DSAuthModes.Owner)`),\r\n    // meaning addMember will always throw.\r\n    function addMember( address who ) auth()\r\n    {\r\n        if( is_member[who] ) {\r\n            throw;\r\n        }\r\n        is_member[who] = true;\r\n        MemberAdded(who);\r\n        _members_remaining--;\r\n        if( _members_remaining == 0 ) {\r\n            updateAuthority( address(0x0), DSAuthModes.Owner );\r\n        }\r\n    }\r\n    function isMember( address who ) constant returns (bool) {\r\n        return is_member[who];\r\n    }\r\n\r\n    // Some constant getters\r\n    function getInfo()\r\n             constant\r\n             returns ( uint required, uint members, uint expiration, uint last_proposed_action)\r\n    {\r\n        return (_required, _member_count, _expiration, _last_action_id);\r\n    }\r\n    // Public getter for the action mapping doesn't work in web3.js yet\r\n    function getActionStatus(uint action_id)\r\n             constant\r\n             returns (uint confirmations, uint expiration, bool triggered, address target, uint eth_value)\r\n    {\r\n        var a = actions[action_id];\r\n        return (a.confirmations, a.expiration, a.triggered, a.target, a.value);\r\n    }\r\n\r\n    // `propose` an action using the calldata from this sender's last call.\r\n    function easyPropose( address target, uint value ) returns (uint action_id) {\r\n        return propose( target, easy_calldata[msg.sender], value );\r\n    }\r\n    function() {\r\n        easy_calldata[msg.sender] = msg.data;\r\n    }\r\n\r\n    // Propose an action.\r\n    // Anyone can propose an action.\r\n    // Only members can confirm actions.\r\n    function propose( address target, bytes calldata, uint value )\r\n             returns (uint action_id)\r\n    {\r\n        action memory a;\r\n        a.target = target;\r\n        a.calldata = calldata;\r\n        a.value = value;\r\n        a.expiration = block.timestamp + _expiration;\r\n        // Increment first because, 0 is not a valid ID.\r\n        _last_action_id++;\r\n        actions[_last_action_id] = a;\r\n        Proposed(_last_action_id, calldata);\r\n        return _last_action_id;\r\n    }\r\n\r\n    // Attempts to confirm the action.\r\n    // Only members can confirm actions.\r\n    function confirm( uint action_id ) returns (bool confirmed) {\r\n        if( !is_member[msg.sender] ) {\r\n            throw;\r\n        }\r\n        if( confirmations[action_id][msg.sender] ) {\r\n            throw;\r\n        }\r\n        if( action_id > _last_action_id ) {\r\n            throw;\r\n        }\r\n        var a = actions[action_id];\r\n        if( block.timestamp > a.expiration ) {\r\n            throw;\r\n        }\r\n        if( a.triggered ) {\r\n            throw;\r\n        }\r\n        confirmations[action_id][msg.sender] = true;\r\n        a.confirmations = a.confirmations + 1;\r\n        actions[action_id] = a;\r\n        Confirmed(action_id, msg.sender);\r\n    }\r\n\r\n    // Attempts to trigger the action.\r\n    // Fails if there are not enough confirmations or if the action has expired.\r\n    function trigger( uint action_id ) {\r\n        var a = actions[action_id];\r\n        if( a.confirmations < _required ) {\r\n            throw;\r\n        }\r\n        if( block.timestamp > a.expiration ) {\r\n            throw;\r\n        }\r\n        if( a.triggered ) {\r\n            throw;\r\n        }\r\n        if( this.balance < a.value ) {\r\n            throw;\r\n        }\r\n        a.triggered = true;\r\n        exec( a.target, a.calldata, a.value );\r\n        actions[action_id] = a;\r\n        Triggered(action_id);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"propose\",\"outputs\":[{\"name\":\"action_id\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"required\",\"type\":\"uint256\"},{\"name\":\"members\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"last_proposed_action\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_authority\",\"type\":\"address\"},{\"name\":\"mode\",\"type\":\"uint8\"}],\"name\":\"updateAuthority\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"action_id\",\"type\":\"uint256\"}],\"name\":\"confirm\",\"outputs\":[{\"name\":\"confirmed\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"easyPropose\",\"outputs\":[{\"name\":\"action_id\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_auth_mode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"action_id\",\"type\":\"uint256\"}],\"name\":\"trigger\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"action_id\",\"type\":\"uint256\"}],\"name\":\"getActionStatus\",\"outputs\":[{\"name\":\"confirmations\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"triggered\",\"type\":\"bool\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"eth_value\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"required\",\"type\":\"uint256\"},{\"name\":\"member_count\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"auth\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"mode\",\"type\":\"DSAuthModesEnum.DSAuthModes\"}],\"name\":\"DSAuthUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"action_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"calldata\",\"type\":\"bytes\"}],\"name\":\"Proposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"action_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Confirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"action_id\",\"type\":\"uint256\"}],\"name\":\"Triggered\",\"type\":\"event\"}]","ContractName":"DSEasyMultisig","CompilerVersion":"v0.3.6+commit.3fc68da","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000003f480","Library":"","SwarmSource":""}]}