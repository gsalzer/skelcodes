{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Token Manager smart contract is used for the management of tokens\r\n * by a client smart contract (the Dao). Defines the functions to set new funding rules,\r\n * create or reward tokens, check token balances, send tokens and send\r\n * tokens on behalf of a 3rd party and the corresponding approval process.\r\n *\r\n*/\r\n\r\n/// @title Token Manager smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassTokenManagerInterface {\r\n    \r\n    struct fundingData {\r\n        // True if public funding without a main partner\r\n        bool publicCreation; \r\n        // The address which sets partners and manages the funding in case of private funding\r\n        address mainPartner;\r\n        // The maximum amount (in wei) of the funding\r\n        uint maxAmountToFund;\r\n        // The actual funded amount (in wei)\r\n        uint fundedAmount;\r\n        // A unix timestamp, denoting the start time of the funding\r\n        uint startTime; \r\n        // A unix timestamp, denoting the closing time of the funding\r\n        uint closingTime;  \r\n        // The price multiplier for a share or a token without considering the inflation rate\r\n        uint initialPriceMultiplier;\r\n        // Rate per year in percentage applied to the share or token price \r\n        uint inflationRate; \r\n        // Index of the client proposal\r\n        uint proposalID;\r\n    } \r\n\r\n    // Address of the creator of the smart contract\r\n    address public creator;\r\n    // Address of the Dao    \r\n    address public client;\r\n    // Address of the recipient;\r\n    address public recipient;\r\n    \r\n    // The token name for display purpose\r\n    string public name;\r\n    // The token symbol for display purpose\r\n    string public symbol;\r\n    // The quantity of decimals for display purpose\r\n    uint8 public decimals;\r\n\r\n    // Total amount of tokens\r\n    uint256 totalSupply;\r\n\r\n    // Array with all balances\r\n    mapping (address => uint256) balances;\r\n    // Array with all allowances\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Map of the result (in wei) of fundings\r\n    mapping (uint => uint) fundedAmount;\r\n    \r\n    // If true, the shares or tokens can be transfered\r\n    bool public transferable;\r\n    // Map of blocked Dao share accounts. Points to the date when the share holder can transfer shares\r\n    mapping (address => uint) public blockedDeadLine; \r\n\r\n    // Rules for the actual funding and the contractor token price\r\n    fundingData[2] public FundingRules;\r\n    \r\n    /// @return The total supply of shares or tokens \r\n    function TotalSupply() constant external returns (uint256);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n     function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Quantity of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n\r\n    /// @param _proposalID The index of the Dao proposal\r\n    /// @return The result (in wei) of the funding\r\n    function FundedAmount(uint _proposalID) constant external returns (uint);\r\n\r\n    /// @param _saleDate in case of presale, the date of the presale\r\n    /// @return the share or token price divisor condidering the sale date and the inflation rate\r\n    function priceDivisor(uint _saleDate) constant internal returns (uint);\r\n    \r\n    /// @return the actual price divisor of a share or token\r\n    function actualPriceDivisor() constant external returns (uint);\r\n\r\n    /// @return The maximal amount a main partner can fund at this moment\r\n    /// @param _mainPartner The address of the main parner\r\n    function fundingMaxAmount(address _mainPartner) constant external returns (uint);\r\n\r\n    // Modifier that allows only the client to manage this account manager\r\n    modifier onlyClient {if (msg.sender != client) throw; _;}\r\n\r\n    // Modifier that allows only the main partner to manage the actual funding\r\n    modifier onlyMainPartner {if (msg.sender !=  FundingRules[0].mainPartner) throw; _;}\r\n    \r\n    // Modifier that allows only the contractor propose set the token price or withdraw\r\n    modifier onlyContractor {if (recipient == 0 || (msg.sender != recipient && msg.sender != creator)) throw; _;}\r\n    \r\n    // Modifier for Dao functions\r\n    modifier onlyDao {if (recipient != 0) throw; _;}\r\n    \r\n    /// @dev The constructor function\r\n    /// @param _creator The address of the creator of the smart contract\r\n    /// @param _client The address of the client or Dao\r\n    /// @param _recipient The recipient of this manager\r\n    //function TokenManager(\r\n        //address _creator,\r\n        //address _client,\r\n        //address _recipient\r\n    //);\r\n\r\n    /// @param _tokenName The token name for display purpose\r\n    /// @param _tokenSymbol The token symbol for display purpose\r\n    /// @param _tokenDecimals The quantity of decimals for display purpose\r\n    /// @param _initialSupplyRecipient The recipient of the initial supply (not mandatory)\r\n    /// @param _initialSupply The initial supply of tokens for the recipient (not mandatory)\r\n    /// @param _transferable True if allows the transfer of tokens\r\n    function initToken(\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        address _initialSupplyRecipient,\r\n        uint256 _initialSupply,\r\n        bool _transferable\r\n       );\r\n\r\n    /// @param _initialPriceMultiplier The initial price multiplier of contractor tokens\r\n    /// @param _inflationRate If 0, the contractor token price doesn't change during the funding\r\n    /// @param _closingTime The initial price and inflation rate can be changed after this date\r\n    function setTokenPriceProposal(        \r\n        uint _initialPriceMultiplier, \r\n        uint _inflationRate,\r\n        uint _closingTime\r\n    );\r\n\r\n    /// @notice Function to set a funding. Can be private or public\r\n    /// @param _mainPartner The address of the smart contract to manage a private funding\r\n    /// @param _publicCreation True if public funding\r\n    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\r\n    /// @param _maxAmountToFund The maximum amount (in wei) of the funding\r\n    /// @param _minutesFundingPeriod Period in minutes of the funding\r\n    /// @param _inflationRate If 0, the token price doesn't change during the funding\r\n    /// @param _proposalID Index of the client proposal (not mandatory)\r\n    function setFundingRules(\r\n        address _mainPartner,\r\n        bool _publicCreation, \r\n        uint _initialPriceMultiplier, \r\n        uint _maxAmountToFund, \r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external;\r\n    \r\n    /// @dev Internal function for the creation of shares or tokens\r\n    /// @param _recipient The recipient address of shares or tokens\r\n    /// @param _amount The funded amount (in wei)\r\n    /// @param _saleDate In case of presale, the date of the presale\r\n    /// @return Whether the creation was successful or not\r\n    function createToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate\r\n    ) internal returns (bool success);\r\n\r\n    /// @notice Function used by the main partner to set the start time of the funding\r\n    /// @param _startTime The unix start date of the funding \r\n    function setFundingStartTime(uint _startTime) external;\r\n\r\n    /// @notice Function used by the main partner to reward shares or tokens\r\n    /// @param _recipient The address of the recipient of shares or tokens\r\n    /// @param _amount The amount (in Wei) to calculate the quantity of shares or tokens to create\r\n    /// @param _date The unix date to consider for the share or token price calculation\r\n    /// @return Whether the transfer was successful or not\r\n    function rewardToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _date\r\n        ) external;\r\n\r\n    /// @dev Internal function to close the actual funding\r\n    function closeFunding() internal;\r\n    \r\n    /// @notice Function used by the main partner to set the funding fueled\r\n    function setFundingFueled() external;\r\n\r\n    /// @notice Function to able the transfer of Dao shares or contractor tokens\r\n    function ableTransfer();\r\n\r\n    /// @notice Function to disable the transfer of Dao shares\r\n    function disableTransfer();\r\n\r\n    /// @notice Function used by the client to block the transfer of shares from and to a share holder\r\n    /// @param _shareHolder The address of the share holder\r\n    /// @param _deadLine When the account will be unblocked\r\n    function blockTransfer(address _shareHolder, uint _deadLine) external;\r\n\r\n    /// @dev Internal function to send `_value` token to `_to` from `_From`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    /// @return Whether the function was successful or not \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    function transfer(address _to, uint256 _value);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The quantity of shares or tokens to be transferred\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    event TokensCreated(address indexed Sender, address indexed TokenHolder, uint Quantity);\r\n    event FundingRulesSet(address indexed MainPartner, uint indexed FundingProposalId, uint indexed StartTime, uint ClosingTime);\r\n    event FundingFueled(uint indexed FundingProposalID, uint FundedAmount);\r\n    event TransferAble();\r\n    event TransferDisable();\r\n\r\n}    \r\n\r\ncontract PassTokenManager is PassTokenManagerInterface {\r\n    \r\n    function TotalSupply() constant external returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n     function balanceOf(address _owner) constant external returns (uint256 balance) {\r\n        return balances[_owner];\r\n     }\r\n\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function FundedAmount(uint _proposalID) constant external returns (uint) {\r\n        return fundedAmount[_proposalID];\r\n    }\r\n\r\n    function priceDivisor(uint _saleDate) constant internal returns (uint) {\r\n        uint _date = _saleDate;\r\n        \r\n        if (_saleDate > FundingRules[0].closingTime) _date = FundingRules[0].closingTime;\r\n        if (_saleDate < FundingRules[0].startTime) _date = FundingRules[0].startTime;\r\n\r\n        return 100 + 100*FundingRules[0].inflationRate*(_date - FundingRules[0].startTime)/(100*365 days);\r\n    }\r\n    \r\n    function actualPriceDivisor() constant external returns (uint) {\r\n        return priceDivisor(now);\r\n    }\r\n\r\n    function fundingMaxAmount(address _mainPartner) constant external returns (uint) {\r\n        \r\n        if (now > FundingRules[0].closingTime\r\n            || now < FundingRules[0].startTime\r\n            || _mainPartner != FundingRules[0].mainPartner) {\r\n            return 0;   \r\n        } else {\r\n            return FundingRules[0].maxAmountToFund;\r\n        }\r\n        \r\n    }\r\n\r\n    function PassTokenManager(\r\n        address _creator,\r\n        address _client,\r\n        address _recipient\r\n    ) {\r\n        \r\n        if (_creator == 0 \r\n            || _client == 0 \r\n            || _client == _recipient \r\n            || _client == address(this) \r\n            || _recipient == address(this)) throw;\r\n\r\n        creator = _creator; \r\n        client = _client;\r\n        recipient = _recipient;\r\n        \r\n    }\r\n   \r\n    function initToken(\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        address _initialSupplyRecipient,\r\n        uint256 _initialSupply,\r\n        bool _transferable) {\r\n           \r\n        if (_initialSupplyRecipient == address(this)\r\n            || decimals != 0\r\n            || msg.sender != creator\r\n            || totalSupply != 0) throw;\r\n            \r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n          \r\n        if (_transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        } else {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }\r\n        \r\n        balances[_initialSupplyRecipient] = _initialSupply; \r\n        totalSupply = _initialSupply;\r\n        TokensCreated(msg.sender, _initialSupplyRecipient, _initialSupply);\r\n           \r\n    }\r\n    \r\n    function setTokenPriceProposal(        \r\n        uint _initialPriceMultiplier, \r\n        uint _inflationRate,\r\n        uint _closingTime\r\n    ) onlyContractor {\r\n        \r\n        if (_closingTime < now \r\n            || now < FundingRules[1].closingTime) throw;\r\n        \r\n        FundingRules[1].initialPriceMultiplier = _initialPriceMultiplier;\r\n        FundingRules[1].inflationRate = _inflationRate;\r\n        FundingRules[1].startTime = now;\r\n        FundingRules[1].closingTime = _closingTime;\r\n        \r\n    }\r\n    \r\n    function setFundingRules(\r\n        address _mainPartner,\r\n        bool _publicCreation, \r\n        uint _initialPriceMultiplier,\r\n        uint _maxAmountToFund, \r\n        uint _minutesFundingPeriod, \r\n        uint _inflationRate,\r\n        uint _proposalID\r\n    ) external onlyClient {\r\n\r\n        if (now < FundingRules[0].closingTime\r\n            || _mainPartner == address(this)\r\n            || _mainPartner == client\r\n            || (!_publicCreation && _mainPartner == 0)\r\n            || (_publicCreation && _mainPartner != 0)\r\n            || (recipient == 0 && _initialPriceMultiplier == 0)\r\n            || (recipient != 0 \r\n                && (FundingRules[1].initialPriceMultiplier == 0\r\n                    || _inflationRate < FundingRules[1].inflationRate\r\n                    || now < FundingRules[1].startTime\r\n                    || FundingRules[1].closingTime < now + (_minutesFundingPeriod * 1 minutes)))\r\n            || _maxAmountToFund == 0\r\n            || _minutesFundingPeriod == 0\r\n            ) throw;\r\n\r\n        FundingRules[0].startTime = now;\r\n        FundingRules[0].closingTime = now + _minutesFundingPeriod * 1 minutes;\r\n            \r\n        FundingRules[0].mainPartner = _mainPartner;\r\n        FundingRules[0].publicCreation = _publicCreation;\r\n        \r\n        if (recipient == 0) FundingRules[0].initialPriceMultiplier = _initialPriceMultiplier;\r\n        else FundingRules[0].initialPriceMultiplier = FundingRules[1].initialPriceMultiplier;\r\n        \r\n        if (recipient == 0) FundingRules[0].inflationRate = _inflationRate;\r\n        else FundingRules[0].inflationRate = FundingRules[1].inflationRate;\r\n        \r\n        FundingRules[0].fundedAmount = 0;\r\n        FundingRules[0].maxAmountToFund = _maxAmountToFund;\r\n\r\n        FundingRules[0].proposalID = _proposalID;\r\n\r\n        FundingRulesSet(_mainPartner, _proposalID, FundingRules[0].startTime, FundingRules[0].closingTime);\r\n            \r\n    } \r\n    \r\n    function createToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _saleDate\r\n    ) internal returns (bool success) {\r\n\r\n        if (now > FundingRules[0].closingTime\r\n            || now < FundingRules[0].startTime\r\n            ||_saleDate > FundingRules[0].closingTime\r\n            || _saleDate < FundingRules[0].startTime\r\n            || FundingRules[0].fundedAmount + _amount > FundingRules[0].maxAmountToFund) return;\r\n\r\n        uint _a = _amount*FundingRules[0].initialPriceMultiplier;\r\n        uint _multiplier = 100*_a;\r\n        uint _quantity = _multiplier/priceDivisor(_saleDate);\r\n        if (_a/_amount != FundingRules[0].initialPriceMultiplier\r\n            || _multiplier/100 != _a\r\n            || totalSupply + _quantity <= totalSupply \r\n            || totalSupply + _quantity <= _quantity) return;\r\n\r\n        balances[_recipient] += _quantity;\r\n        totalSupply += _quantity;\r\n        FundingRules[0].fundedAmount += _amount;\r\n\r\n        TokensCreated(msg.sender, _recipient, _quantity);\r\n        \r\n        if (FundingRules[0].fundedAmount == FundingRules[0].maxAmountToFund) closeFunding();\r\n        \r\n        return true;\r\n\r\n    }\r\n\r\n    function setFundingStartTime(uint _startTime) external onlyMainPartner {\r\n        if (now > FundingRules[0].closingTime) throw;\r\n        FundingRules[0].startTime = _startTime;\r\n    }\r\n    \r\n    function rewardToken(\r\n        address _recipient, \r\n        uint _amount,\r\n        uint _date\r\n        ) external onlyMainPartner {\r\n\r\n        uint _saleDate;\r\n        if (_date == 0) _saleDate = now; else _saleDate = _date;\r\n\r\n        if (!createToken(_recipient, _amount, _saleDate)) throw;\r\n\r\n    }\r\n\r\n    function closeFunding() internal {\r\n        if (recipient == 0) fundedAmount[FundingRules[0].proposalID] = FundingRules[0].fundedAmount;\r\n        FundingRules[0].closingTime = now;\r\n    }\r\n    \r\n    function setFundingFueled() external onlyMainPartner {\r\n        if (now > FundingRules[0].closingTime) throw;\r\n        closeFunding();\r\n        if (recipient == 0) FundingFueled(FundingRules[0].proposalID, FundingRules[0].fundedAmount);\r\n    }\r\n    \r\n    function ableTransfer() onlyClient {\r\n        if (!transferable) {\r\n            transferable = true;\r\n            TransferAble();\r\n        }\r\n    }\r\n\r\n    function disableTransfer() onlyClient {\r\n        if (transferable) {\r\n            transferable = false;\r\n            TransferDisable();\r\n        }\r\n    }\r\n    \r\n    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyDao {\r\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\r\n            blockedDeadLine[_shareHolder] = _deadLine;\r\n        }\r\n    }\r\n    \r\n    function transferFromTo(\r\n        address _from,\r\n        address _to, \r\n        uint256 _value\r\n        ) internal returns (bool) {  \r\n\r\n        if (transferable\r\n            && now > blockedDeadLine[_from]\r\n            && now > blockedDeadLine[_to]\r\n            && _to != address(this)\r\n            && balances[_from] >= _value\r\n            && balances[_to] + _value > balances[_to]\r\n            && balances[_to] + _value >= _value\r\n        ) {\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) {  \r\n        if (!transferFromTo(msg.sender, _to, _value)) throw;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n        ) returns (bool success) { \r\n        \r\n        if (allowed[_from][msg.sender] < _value\r\n            || !transferFromTo(_from, _to, _value)) throw;\r\n            \r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n}    \r\n  \r\n\r\npragma solidity ^0.4.2;\r\n\r\n/*\r\n *\r\n * This file is part of Pass DAO.\r\n *\r\n * The Manager smart contract is used for the management of accounts and tokens.\r\n * Allows to receive or withdraw ethers and to buy Dao shares.\r\n * The contract derives to the Token Manager smart contract for the management of tokens.\r\n *\r\n * Recipient is 0 for the Dao account manager and the address of\r\n * contractor's recipient for the contractors's mahagers.\r\n *\r\n*/\r\n\r\n/// @title Manager smart contract of the Pass Decentralized Autonomous Organisation\r\ncontract PassManagerInterface is PassTokenManagerInterface {\r\n\r\n    struct proposal {\r\n        // Amount (in wei) of the proposal\r\n        uint amount;\r\n        // A description of the proposal\r\n        string description;\r\n        // The hash of the proposal's document\r\n        bytes32 hashOfTheDocument;\r\n        // A unix timestamp, denoting the date when the proposal was created\r\n        uint dateOfProposal;\r\n        // The sum amount (in wei) ordered for this proposal \r\n        uint orderAmount;\r\n        // A unix timestamp, denoting the date of the last order for the approved proposal\r\n        uint dateOfOrder;\r\n    }\r\n        \r\n    // Proposals to work for the client\r\n    proposal[] public proposals;\r\n    \r\n    /// @dev The constructor function\r\n    /// @param _creator The address of the creator\r\n    /// @param _client The address of the Dao\r\n    /// @param _recipient The address of the recipient. 0 for the Dao\r\n    //function PassManager(\r\n        //address _creator,\r\n        //address _client,\r\n        //address _recipient\r\n    //) PassTokenManager(\r\n        //_creator,\r\n        //_client,\r\n        //_recipient);\r\n\r\n    /// @notice Fallback function to allow sending ethers to this smart contract\r\n    function () payable;\r\n    \r\n    /// @notice Function to update the recipent address\r\n    /// @param _newRecipient The adress of the recipient\r\n    function updateRecipient(address _newRecipient);\r\n\r\n    /// @notice Function to buy Dao shares according to the funding rules \r\n    /// with `msg.sender` as the beneficiary\r\n    function buyShares() payable;\r\n    \r\n    /// @notice Function to buy Dao shares according to the funding rules \r\n    /// @param _recipient The beneficiary of the created shares\r\n    function buySharesFor(address _recipient) payable;\r\n\r\n    /// @notice Function to make a proposal to work for the client\r\n    /// @param _amount The amount (in wei) of the proposal\r\n    /// @param _description String describing the proposal\r\n    /// @param _hashOfTheDocument The hash of the proposal document\r\n    /// @return The index of the contractor proposal\r\n    function newProposal(\r\n        uint _amount,\r\n        string _description, \r\n        bytes32 _hashOfTheDocument\r\n    ) returns (uint);\r\n    \r\n    /// @notice Function used by the client to order according to the contractor proposal\r\n    /// @param _proposalID The index of the contractor proposal\r\n    /// @param _amount The amount (in wei) of the order\r\n    /// @return Whether the order was made or not\r\n    function order(\r\n        uint _proposalID,\r\n        uint _amount\r\n    ) external returns (bool) ;\r\n    \r\n    /// @notice Function used by the client to send ethers from the Dao manager\r\n    /// @param _recipient The address to send to\r\n    /// @param _amount The amount (in wei) to send\r\n    /// @return Whether the transfer was successful or not\r\n    function sendTo(\r\n        address _recipient, \r\n        uint _amount\r\n    ) external returns (bool);\r\n\r\n    /// @notice Function to allow contractors to withdraw ethers\r\n    /// @param _amount The amount (in wei) to withdraw\r\n    function withdraw(uint _amount);\r\n    \r\n    event ProposalAdded(uint indexed ProposalID, uint Amount, string Description);\r\n    event Order(uint indexed ProposalID, uint Amount);\r\n    event Withdawal(address indexed Recipient, uint Amount);\r\n\r\n}    \r\n\r\ncontract PassManager is PassManagerInterface, PassTokenManager {\r\n\r\n    function PassManager(\r\n        address _creator,\r\n        address _client,\r\n        address _recipient\r\n    ) PassTokenManager(\r\n        _creator,\r\n        _client,\r\n        _recipient\r\n        ) {\r\n        proposals.length = 1;\r\n    }\r\n\r\n    function () payable {}\r\n\r\n    function updateRecipient(address _newRecipient) onlyContractor {\r\n\r\n        if (_newRecipient == 0 \r\n            || _newRecipient == client) throw;\r\n\r\n        recipient = _newRecipient;\r\n    } \r\n\r\n    function buyShares() payable {\r\n        buySharesFor(msg.sender);\r\n    } \r\n    \r\n    function buySharesFor(address _recipient) payable onlyDao {\r\n        \r\n        if (!FundingRules[0].publicCreation \r\n            || !createToken(_recipient, msg.value, now)) throw;\r\n\r\n    }\r\n   \r\n    function newProposal(\r\n        uint _amount,\r\n        string _description, \r\n        bytes32 _hashOfTheDocument\r\n    ) onlyContractor returns (uint) {\r\n\r\n        uint _proposalID = proposals.length++;\r\n        proposal c = proposals[_proposalID];\r\n\r\n        c.amount = _amount;\r\n        c.description = _description;\r\n        c.hashOfTheDocument = _hashOfTheDocument; \r\n        c.dateOfProposal = now;\r\n        \r\n        ProposalAdded(_proposalID, c.amount, c.description);\r\n        \r\n        return _proposalID;\r\n        \r\n    }\r\n    \r\n    function order(\r\n        uint _proposalID,\r\n        uint _orderAmount\r\n    ) external onlyClient returns (bool) {\r\n    \r\n        proposal c = proposals[_proposalID];\r\n        \r\n        uint _sum = c.orderAmount + _orderAmount;\r\n        if (_sum > c.amount\r\n            || _sum < c.orderAmount\r\n            || _sum < _orderAmount) return; \r\n\r\n        c.orderAmount = _sum;\r\n        c.dateOfOrder = now;\r\n        \r\n        Order(_proposalID, _orderAmount);\r\n        \r\n        return true;\r\n\r\n    }\r\n\r\n    function sendTo(\r\n        address _recipient,\r\n        uint _amount\r\n    ) external onlyClient onlyDao returns (bool) {\r\n    \r\n        if (_recipient.send(_amount)) return true;\r\n        else return false;\r\n\r\n    }\r\n   \r\n    function withdraw(uint _amount) onlyContractor {\r\n        if (!recipient.send(_amount)) throw;\r\n        Withdawal(recipient, _amount);\r\n    }\r\n    \r\n}    \r\n\r\ncontract PassManagerCreator {\r\n    event NewPassManager(address Creator, address Client, address Recipient, address PassManager);\r\n    function createManager(\r\n        address _client,\r\n        address _recipient\r\n        ) returns (PassManager) {\r\n        PassManager _passManager = new PassManager(\r\n            msg.sender,\r\n            _client,\r\n            _recipient\r\n        );\r\n        NewPassManager(msg.sender, _client, _recipient, _passManager);\r\n        return _passManager;\r\n    }\r\n}\r\n\r\npragma solidity ^0.4.2;\r\n\r\n/*\r\n *\r\n * This file is part of the DAO.\r\n *\r\n * Smart contract used for the funding of Pass Dao.\r\n *\r\n*/\r\n\r\n/// @title Funding smart contract for the Pass Decentralized Autonomous Organisation\r\ncontract PassFundingInterface {\r\n\r\n    struct Partner {\r\n        // The address of the partner\r\n        address partnerAddress; \r\n        // The amount (in wei) that the partner wish to fund\r\n        uint presaleAmount;\r\n        // The unix timestamp denoting the average date of the presale of the partner \r\n        uint presaleDate;\r\n        // The funding amount (in wei) according to the set limits\r\n        uint fundingAmountLimit;\r\n        // The amount (in wei) that the partner funded to the Dao\r\n        uint fundedAmount;\r\n        // True if the partner can fund the dao\r\n        bool valid;\r\n    }\r\n\r\n    // Address of the creator of this contract\r\n    address public creator;\r\n    // The manager smart contract to fund\r\n    PassManager public DaoManager;\r\n    // True if contractor token creation\r\n    bool tokenCreation;            \r\n    // The manager smart contract for the reward of contractor tokens\r\n    PassManager public contractorManager;\r\n    // Minimum amount (in wei) to fund\r\n    uint public minFundingAmount;\r\n    // Minimum amount (in wei) that partners can send to this smart contract\r\n    uint public minPresaleAmount;\r\n    // Maximum amount (in wei) that partners can send to this smart contract\r\n    uint public maxPresaleAmount;\r\n    // The unix start time of the presale\r\n    uint public startTime;\r\n    // The unix closing time of the funding\r\n    uint public closingTime;\r\n    /// The amount (in wei) below this limit can fund the dao\r\n    uint minAmountLimit;\r\n    /// Maximum amount (in wei) a partner can fund\r\n    uint maxAmountLimit; \r\n    /// The partner can fund below the minimum amount limit or a set percentage of his ether balance \r\n    uint divisorBalanceLimit;\r\n    /// The partner can fund below the minimum amount limit or a set percentage of his shares balance in the Dao\r\n    uint multiplierSharesLimit;\r\n    /// The partner can fund below the minimum amount limit or a set percentage of his shares balance in the Dao \r\n    uint divisorSharesLimit;\r\n    // True if the amount and divisor balance limits for the funding are set\r\n    bool public limitSet;\r\n    // True if all the partners are set by the creator and the funding can be completed \r\n    bool public allSet;\r\n    // Array of partners who wish to fund the dao\r\n    Partner[] public partners;\r\n    // Map with the indexes of the partners\r\n    mapping (address => uint) public partnerID; \r\n    // The total funded amount (in wei)\r\n    uint public totalFunded; \r\n    // The calculated sum of funding amout limits (in wei) according to the set limits\r\n    uint sumOfFundingAmountLimits;\r\n    \r\n    // To allow the creator to pause during the presale\r\n    uint public pauseClosingTime;\r\n    // To allow the creator to abort the funding before the closing time\r\n    bool IsfundingAborted;\r\n    \r\n    // To allow the set of partners in several times\r\n    uint setFromPartner;\r\n    // To allow the refund for partners in several times\r\n    uint refundFromPartner;\r\n\r\n    // The manager of this funding is the creator of this contract\r\n    modifier onlyCreator {if (msg.sender != creator) throw; _ ;}\r\n\r\n    /// @dev Constructor function\r\n    /// @param _creator The creator of the smart contract\r\n    /// @param _DaoManager The Dao manager smart contract\r\n    /// for the reward of tokens (not mandatory)\r\n    /// @param _minAmount Minimum amount (in wei) of the funding to be fueled \r\n    /// @param _startTime The unix start time of the presale\r\n    /// @param _closingTime The unix closing time of the funding\r\n    //function PassFunding (\r\n        //address _creator,\r\n        //address _DaoManager,\r\n        //uint _minAmount,\r\n        //uint _startTime,\r\n        //uint _closingTime\r\n    //);\r\n\r\n    /// @notice Function used by the creator to set the contractor manager smart contract\r\n    /// @param _contractorManager The address of the contractor manager smart contract\r\n    function SetContractorManager(address _contractorManager);\r\n    \r\n    /// @notice Function used by the creator to set the presale limits\r\n    /// @param _minPresaleAmount Minimum amount (in wei) that partners can send\r\n    /// @param _maxPresaleAmount Maximum amount (in wei) that partners can send\r\n    function SetPresaleAmountLimits(\r\n        uint _minPresaleAmount,\r\n        uint _maxPresaleAmount\r\n        );\r\n\r\n    /// @dev Fallback function\r\n    function () payable;\r\n\r\n    /// @notice Function to participate in the presale of the funding\r\n    /// @return Whether the presale was successful or not\r\n    function presale() payable returns (bool);\r\n    \r\n    /// @notice Function used by the creator to set addresses that can fund the dao\r\n    /// @param _valid True if the address can fund the Dao\r\n    /// @param _from The index of the first partner to set\r\n    /// @param _to The index of the last partner to set\r\n    function setPartners(\r\n            bool _valid,\r\n            uint _from,\r\n            uint _to\r\n        );\r\n\r\n    /// @notice Function used by the creator to set the addresses of Dao share holders\r\n    /// @param _valid True if the address can fund the Dao\r\n    /// @param _from The index of the first partner to set\r\n    /// @param _to The index of the last partner to set\r\n    function setShareHolders(\r\n            bool _valid,\r\n            uint _from,\r\n            uint _to\r\n        );\r\n    \r\n    /// @notice Function to allow the creator to abort the funding before the closing time\r\n    function abortFunding();\r\n    \r\n    /// @notice Function To allow the creator to pause during the presale\r\n    function pause(uint _pauseClosingTime) {\r\n        pauseClosingTime = _pauseClosingTime;\r\n    }\r\n\r\n    /// @notice Function used by the creator to set the funding limits for the funding\r\n    /// @param _minAmountLimit The amount below this limit (in wei) can fund the dao\r\n    /// @param _maxAmountLimit Maximum amount (in wei) a partner can fund\r\n    /// @param _divisorBalanceLimit The creator can set a limit in percentage of Eth balance (not mandatory)\r\n    /// @param _multiplierSharesLimit The creator can set a limit in percentage of shares balance in the Dao (not mandatory)\r\n    /// @param _divisorSharesLimit The creator can set a limit in percentage of shares balance in the Dao (not mandatory) \r\n    function setLimits(\r\n            uint _minAmountLimit,\r\n            uint _maxAmountLimit, \r\n            uint _divisorBalanceLimit,\r\n            uint _multiplierSharesLimit,\r\n            uint _divisorSharesLimit\r\n    );\r\n\r\n    /// @notice Function used to set the funding limits for partners\r\n    /// @param _to The index of the last partner to set\r\n    /// @return Whether the set was successful or not\r\n    function setFunding(uint _to) returns (bool _success);\r\n\r\n    /// @notice Function for the funding of the Dao by a group of partners\r\n    /// @param _from The index of the first partner\r\n    /// @param _to The index of the last partner\r\n    /// @return Whether the Dao was funded or not\r\n    function fundDaoFor(\r\n            uint _from,\r\n            uint _to\r\n        ) returns (bool);\r\n    \r\n    /// @notice Function to fund the Dao with 'msg.sender' as 'beneficiary'\r\n    /// @return Whether the Dao was funded or not \r\n    function fundDao() returns (bool);\r\n    \r\n    /// @notice Function to refund for a partner\r\n    /// @param _partnerID The index of the partner\r\n    /// @return Whether the refund was successful or not \r\n    function refundFor(uint _partnerID) internal returns (bool);\r\n\r\n    /// @notice Function to refund for valid partners before the closing time\r\n    /// @param _to The index of the last partner\r\n    function refundForValidPartners(uint _to);\r\n\r\n    /// @notice Function to refund for a group of partners after the closing time\r\n    /// @param _from The index of the first partner\r\n    /// @param _to The index of the last partner\r\n    function refundForAll(\r\n        uint _from,\r\n        uint _to);\r\n\r\n    /// @notice Function to refund after the closing time with 'msg.sender' as 'beneficiary'\r\n    function refund();\r\n\r\n    /// @param _minAmountLimit The amount (in wei) below this limit can fund the dao\r\n    /// @param _maxAmountLimit Maximum amount (in wei) a partner can fund\r\n    /// @param _divisorBalanceLimit The partner can fund \r\n    /// only under a defined percentage of his ether balance\r\n    /// @param _multiplierSharesLimit The partner can fund \r\n    /// only under a defined percentage of his shares balance in the Dao \r\n    /// @param _divisorSharesLimit The partner can fund \r\n    /// only under a defined percentage of his shares balance in the Dao \r\n    /// @param _from The index of the first partner\r\n    /// @param _to The index of the last partner\r\n    /// @return The result of the funding procedure (in wei) at present time\r\n    function estimatedFundingAmount(\r\n        uint _minAmountLimit,\r\n        uint _maxAmountLimit, \r\n        uint _divisorBalanceLimit,\r\n        uint _multiplierSharesLimit,\r\n        uint _divisorSharesLimit,\r\n        uint _from,\r\n        uint _to\r\n        ) constant external returns (uint);\r\n\r\n    /// @param _index The index of the partner\r\n    /// @param _minAmountLimit The amount (in wei) below this limit can fund the dao\r\n    /// @param _maxAmountLimit Maximum amount (in wei) a partner can fund\r\n    /// @param _divisorBalanceLimit The partner can fund \r\n    /// only under a defined percentage of his ether balance \r\n    /// @param _multiplierSharesLimit The partner can fund \r\n    /// only under a defined percentage of his shares balance in the Dao \r\n    /// @param _divisorSharesLimit The partner can fund \r\n    /// only under a defined percentage of his shares balance in the Dao \r\n    /// @return The maximum amount (in wei) a partner can fund\r\n    function partnerFundingLimit(\r\n        uint _index, \r\n        uint _minAmountLimit,\r\n        uint _maxAmountLimit, \r\n        uint _divisorBalanceLimit,\r\n        uint _multiplierSharesLimit,\r\n        uint _divisorSharesLimit\r\n        ) internal returns (uint);\r\n        \r\n    /// @return the number of partners\r\n    function numberOfPartners() constant external returns (uint);\r\n    \r\n    /// @param _from The index of the first partner\r\n    /// @param _to The index of the last partner\r\n    /// @return The number of valid partners\r\n    function numberOfValidPartners(\r\n        uint _from,\r\n        uint _to\r\n        ) constant external returns (uint);\r\n\r\n    event ContractorManagerSet(address ContractorManagerAddress);\r\n    event IntentionToFund(address indexed partner, uint amount);\r\n    event Fund(address indexed partner, uint amount);\r\n    event Refund(address indexed partner, uint amount);\r\n    event LimitSet(uint minAmountLimit, uint maxAmountLimit, uint divisorBalanceLimit, \r\n        uint _multiplierSharesLimit, uint divisorSharesLimit);\r\n    event PartnersNotSet(uint sumOfFundingAmountLimits);\r\n    event AllPartnersSet(uint fundingAmount);\r\n    event Fueled();\r\n    event FundingClosed();\r\n    \r\n}\r\n\r\ncontract PassFunding is PassFundingInterface {\r\n\r\n    function PassFunding (\r\n        address _creator,\r\n        address _DaoManager,\r\n        uint _minFundingAmount,\r\n        uint _startTime,\r\n        uint _closingTime\r\n        ) {\r\n\r\n        if (_creator == _DaoManager\r\n            || _creator == 0\r\n            || _DaoManager == 0\r\n            || (_startTime < now && _startTime != 0)) throw;\r\n            \r\n        creator = _creator;\r\n        DaoManager = PassManager(_DaoManager);\r\n\r\n        minFundingAmount = _minFundingAmount;\r\n\r\n        if (_startTime == 0) {startTime = now;} else {startTime = _startTime;}\r\n\r\n        if (_closingTime <= startTime) throw;\r\n        closingTime = _closingTime;\r\n        \r\n        setFromPartner = 1;\r\n        refundFromPartner = 1;\r\n\r\n        partners.length = 1; \r\n        \r\n    }\r\n    \r\n    function SetContractorManager(address _contractorManager) onlyCreator {\r\n        \r\n        if (_contractorManager == 0\r\n            || limitSet\r\n            || address(contractorManager) != 0\r\n            || creator == _contractorManager\r\n            || _contractorManager == address(DaoManager)) throw;\r\n            \r\n        tokenCreation = true;            \r\n        contractorManager = PassManager(_contractorManager);\r\n        ContractorManagerSet(_contractorManager);\r\n        \r\n    }\r\n\r\n    function SetPresaleAmountLimits(\r\n        uint _minPresaleAmount,\r\n        uint _maxPresaleAmount\r\n        ) onlyCreator {\r\n\r\n        if (limitSet) throw;\r\n        \r\n        minPresaleAmount = _minPresaleAmount;\r\n        maxPresaleAmount = _maxPresaleAmount;\r\n\r\n    }\r\n\r\n    function () payable {\r\n        if (!presale()) throw;\r\n    }\r\n\r\n    function presale() payable returns (bool) {\r\n\r\n        if (msg.value <= 0\r\n            || now < startTime\r\n            || now > closingTime\r\n            || now < pauseClosingTime\r\n            || limitSet\r\n            || msg.value < minPresaleAmount\r\n            || msg.value > maxPresaleAmount\r\n            || msg.sender == creator\r\n        ) throw;\r\n        \r\n        if (partnerID[msg.sender] == 0) {\r\n\r\n            uint _partnerID = partners.length++;\r\n            Partner t = partners[_partnerID];\r\n             \r\n            partnerID[msg.sender] = _partnerID;\r\n            t.partnerAddress = msg.sender;\r\n            \r\n            t.presaleAmount += msg.value;\r\n            t.presaleDate = now;\r\n\r\n        } else {\r\n\r\n            Partner p = partners[partnerID[msg.sender]];\r\n            if (p.presaleAmount + msg.value > maxPresaleAmount) throw;\r\n\r\n            p.presaleDate = (p.presaleDate*p.presaleAmount + now*msg.value)/(p.presaleAmount + msg.value);\r\n            p.presaleAmount += msg.value;\r\n\r\n        }    \r\n        \r\n        IntentionToFund(msg.sender, msg.value);\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n    function setPartners(\r\n            bool _valid,\r\n            uint _from,\r\n            uint _to\r\n        ) onlyCreator {\r\n\r\n        if (limitSet\r\n            ||_from < 1 \r\n            || _to > partners.length - 1) throw;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n            Partner t = partners[i];\r\n            t.valid = _valid;\r\n        }\r\n        \r\n    }\r\n\r\n    function setShareHolders(\r\n            bool _valid,\r\n            uint _from,\r\n            uint _to\r\n        ) onlyCreator {\r\n\r\n        if (limitSet\r\n            ||_from < 1 \r\n            || _to > partners.length - 1) throw;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n            Partner t = partners[i];\r\n            if (DaoManager.balanceOf(t.partnerAddress) != 0) t.valid = _valid;\r\n        }\r\n        \r\n    }\r\n    \r\n    function abortFunding() onlyCreator {\r\n        limitSet = true;\r\n        maxPresaleAmount = 0;\r\n        IsfundingAborted = true; \r\n    }\r\n    \r\n    function pause(uint _pauseClosingTime) onlyCreator {\r\n        pauseClosingTime = _pauseClosingTime;\r\n    }\r\n    \r\n    function setLimits(\r\n            uint _minAmountLimit,\r\n            uint _maxAmountLimit, \r\n            uint _divisorBalanceLimit,\r\n            uint _multiplierSharesLimit,\r\n            uint _divisorSharesLimit\r\n    ) onlyCreator {\r\n        \r\n        if (limitSet) throw;\r\n        \r\n        minAmountLimit = _minAmountLimit;\r\n        maxAmountLimit = _maxAmountLimit;\r\n        divisorBalanceLimit = _divisorBalanceLimit;\r\n        multiplierSharesLimit = _multiplierSharesLimit;\r\n        divisorSharesLimit = _divisorSharesLimit;\r\n\r\n        limitSet = true;\r\n        \r\n        LimitSet(_minAmountLimit, _maxAmountLimit, _divisorBalanceLimit, _multiplierSharesLimit, _divisorSharesLimit);\r\n    \r\n    }\r\n\r\n    function setFunding(uint _to) onlyCreator returns (bool _success) {\r\n\r\n        uint _fundingMaxAmount = DaoManager.fundingMaxAmount(address(this));\r\n\r\n        if (!limitSet \r\n            || _fundingMaxAmount < minFundingAmount\r\n            || setFromPartner > _to \r\n            || _to > partners.length - 1) throw;\r\n\r\n        DaoManager.setFundingStartTime(startTime);\r\n        if (tokenCreation) contractorManager.setFundingStartTime(startTime);\r\n\r\n        if (setFromPartner == 1) sumOfFundingAmountLimits = 0;\r\n        \r\n        for (uint i = setFromPartner; i <= _to; i++) {\r\n\r\n            partners[i].fundingAmountLimit = partnerFundingLimit(i, minAmountLimit, maxAmountLimit, \r\n                divisorBalanceLimit, multiplierSharesLimit, divisorSharesLimit);\r\n\r\n            sumOfFundingAmountLimits += partners[i].fundingAmountLimit;\r\n\r\n        }\r\n        \r\n        setFromPartner = _to + 1;\r\n        \r\n        if (setFromPartner >= partners.length) {\r\n\r\n            setFromPartner = 1;\r\n\r\n            if (sumOfFundingAmountLimits < minFundingAmount \r\n                || sumOfFundingAmountLimits > _fundingMaxAmount) {\r\n\r\n                maxPresaleAmount = 0;\r\n                IsfundingAborted = true; \r\n                PartnersNotSet(sumOfFundingAmountLimits);\r\n                return;\r\n\r\n            }\r\n            else {\r\n                allSet = true;\r\n                AllPartnersSet(sumOfFundingAmountLimits);\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function fundDaoFor(\r\n            uint _from,\r\n            uint _to\r\n        ) returns (bool) {\r\n\r\n        if (!allSet) throw;\r\n        \r\n        if (_from < 1 || _to > partners.length - 1) throw;\r\n        \r\n        address _partner;\r\n        uint _amountToFund;\r\n        uint _sumAmountToFund = 0;\r\n\r\n        for (uint i = _from; i <= _to; i++) {\r\n            \r\n            _partner = partners[i].partnerAddress;\r\n            _amountToFund = partners[i].fundingAmountLimit - partners[i].fundedAmount;\r\n        \r\n            if (_amountToFund > 0) {\r\n\r\n                partners[i].fundedAmount += _amountToFund;\r\n                _sumAmountToFund += _amountToFund;\r\n\r\n                DaoManager.rewardToken(_partner, _amountToFund, partners[i].presaleDate);\r\n\r\n                if (tokenCreation) {\r\n                    contractorManager.rewardToken(_partner, _amountToFund, partners[i].presaleDate);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (_sumAmountToFund == 0) return;\r\n        \r\n        if (!DaoManager.send(_sumAmountToFund)) throw;\r\n\r\n        totalFunded += _sumAmountToFund;\r\n\r\n        if (totalFunded == sumOfFundingAmountLimits) {\r\n            DaoManager.setFundingFueled(); \r\n            if (tokenCreation) contractorManager.setFundingFueled(); \r\n            Fueled();\r\n        }\r\n        \r\n        return true;\r\n\r\n    }\r\n    \r\n    function fundDao() returns (bool) {\r\n        return fundDaoFor(partnerID[msg.sender], partnerID[msg.sender]);\r\n    }\r\n\r\n    function refundFor(uint _partnerID) internal returns (bool) {\r\n\r\n        Partner t = partners[_partnerID];\r\n        uint _amountnotToRefund = t.presaleAmount;\r\n        uint _amountToRefund;\r\n        \r\n        if (t.presaleAmount > maxPresaleAmount && t.valid) {\r\n            _amountnotToRefund = maxPresaleAmount;\r\n        }\r\n        \r\n        if (t.fundedAmount > 0 || now > closingTime) {\r\n            _amountnotToRefund = t.fundedAmount;\r\n        }\r\n\r\n        _amountToRefund = t.presaleAmount - _amountnotToRefund;\r\n        if (_amountToRefund <= 0) return true;\r\n\r\n        t.presaleAmount = _amountnotToRefund;\r\n        if (t.partnerAddress.send(_amountToRefund)) {\r\n            Refund(t.partnerAddress, _amountToRefund);\r\n            return true;\r\n        } else {\r\n            t.presaleAmount = _amountnotToRefund + _amountToRefund;\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    function refundForValidPartners(uint _to) {\r\n\r\n        if (refundFromPartner > _to || _to > partners.length - 1) throw;\r\n        \r\n        for (uint i = refundFromPartner; i <= _to; i++) {\r\n            if (partners[i].valid) {\r\n                if (!refundFor(i)) throw;\r\n            }\r\n        }\r\n\r\n        refundFromPartner = _to + 1;\r\n        \r\n        if (refundFromPartner >= partners.length) {\r\n            refundFromPartner = 1;\r\n\r\n            if ((totalFunded >= sumOfFundingAmountLimits && allSet && closingTime > now)\r\n                || IsfundingAborted) {\r\n\r\n                closingTime = now; \r\n                FundingClosed(); \r\n\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    function refundForAll(\r\n        uint _from,\r\n        uint _to) {\r\n\r\n        if (_from < 1 || _to > partners.length - 1) throw;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n            if (!refundFor(i)) throw;\r\n        }\r\n\r\n    }\r\n\r\n    function refund() {\r\n        refundForAll(partnerID[msg.sender], partnerID[msg.sender]);\r\n    }\r\n\r\n    function estimatedFundingAmount(\r\n        uint _minAmountLimit,\r\n        uint _maxAmountLimit, \r\n        uint _divisorBalanceLimit,\r\n        uint _multiplierSharesLimit,\r\n        uint _divisorSharesLimit,\r\n        uint _from,\r\n        uint _to\r\n        ) constant external returns (uint) {\r\n\r\n        if (_from < 1 || _to > partners.length - 1) throw;\r\n\r\n        uint _total = 0;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n            _total += partnerFundingLimit(i, _minAmountLimit, _maxAmountLimit, \r\n                _divisorBalanceLimit, _multiplierSharesLimit, _divisorSharesLimit);\r\n        }\r\n\r\n        return _total;\r\n\r\n    }\r\n\r\n    function partnerFundingLimit(\r\n        uint _index, \r\n        uint _minAmountLimit,\r\n        uint _maxAmountLimit, \r\n        uint _divisorBalanceLimit,\r\n        uint _multiplierSharesLimit,\r\n        uint _divisorSharesLimit\r\n        ) internal returns (uint) {\r\n\r\n        uint _amount;\r\n        uint _amount1;\r\n\r\n        Partner t = partners[_index];\r\n            \r\n        if (t.valid) {\r\n\r\n            _amount = t.presaleAmount;\r\n            \r\n            if (_divisorBalanceLimit > 0) {\r\n                _amount1 = uint(t.partnerAddress.balance)/uint(_divisorBalanceLimit);\r\n                if (_amount > _amount1) _amount = _amount1; \r\n                }\r\n\r\n            if (_multiplierSharesLimit > 0 && _divisorSharesLimit > 0) {\r\n\r\n                uint _balance = uint(DaoManager.balanceOf(t.partnerAddress));\r\n\r\n                uint _multiplier = _balance*_multiplierSharesLimit;\r\n                if (_multiplier/_balance != _multiplierSharesLimit) throw;\r\n\r\n                _amount1 = _multiplier/_divisorSharesLimit;\r\n                if (_amount > _amount1) _amount = _amount1; \r\n\r\n                }\r\n\r\n            if (_amount > _maxAmountLimit) _amount = _maxAmountLimit;\r\n            \r\n            if (_amount < _minAmountLimit) _amount = _minAmountLimit;\r\n\r\n            if (_amount > t.presaleAmount) _amount = t.presaleAmount;\r\n            \r\n        }\r\n        \r\n        return _amount;\r\n        \r\n    }\r\n\r\n    function numberOfPartners() constant external returns (uint) {\r\n        return partners.length - 1;\r\n    }\r\n    \r\n    function numberOfValidPartners(\r\n        uint _from,\r\n        uint _to\r\n        ) constant external returns (uint) {\r\n        \r\n        if (_from < 1 || _to > partners.length-1) throw;\r\n\r\n        uint _total = 0;\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n            if (partners[i].valid) _total += 1;\r\n        }\r\n\r\n        return _total;\r\n        \r\n    }\r\n\r\n}\r\n\r\ncontract PassFundingCreator {\r\n    event NewFunding(address creator, address DaoManager, \r\n        uint MinFundingAmount, uint StartTime, uint ClosingTime, address FundingContractAddress);\r\n    function createFunding(\r\n        address _DaoManager,\r\n        uint _minFundingAmount,\r\n        uint _startTime,\r\n        uint _closingTime\r\n        ) returns (PassFunding) {\r\n        PassFunding _newFunding = new PassFunding(\r\n            msg.sender,\r\n            _DaoManager,        \r\n            _minFundingAmount,\r\n            _startTime,\r\n            _closingTime\r\n        );\r\n        NewFunding(msg.sender, _DaoManager,  \r\n            _minFundingAmount, _startTime, _closingTime, address(_newFunding));\r\n        return _newFunding;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_DaoManager\",\"type\":\"address\"},{\"name\":\"_minFundingAmount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"}],\"name\":\"createFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"DaoManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"MinFundingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"StartTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ClosingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"FundingContractAddress\",\"type\":\"address\"}],\"name\":\"NewFunding\",\"type\":\"event\"}]","ContractName":"PassFundingCreator","CompilerVersion":"v0.4.2+commit.af6afb04","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}