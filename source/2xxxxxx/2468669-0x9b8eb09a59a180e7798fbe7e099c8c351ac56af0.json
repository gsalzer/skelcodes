{"status":"1","message":"OK","result":[{"SourceCode":"//! BasicCoin ECR20-compliant token contract\r\n//! By Parity Team (Ethcore), 2016.\r\n//! Released under the Apache Licence 2.\r\n\r\npragma solidity ^0.4.1;\r\n\r\n// ECR20 standard token interface\r\ncontract Token {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n  function approve(address _spender, uint256 _value) returns (bool success);\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n// Owner-specific contract interface\r\ncontract Owned {\r\n  event NewOwner(address indexed old, address indexed current);\r\n\r\n  modifier only_owner {\r\n    if (msg.sender != owner) throw;\r\n    _;\r\n  }\r\n\r\n  address public owner = msg.sender;\r\n\r\n  function setOwner(address _new) only_owner {\r\n    NewOwner(owner, _new);\r\n    owner = _new;\r\n  }\r\n}\r\n\r\n// TokenReg interface\r\ncontract TokenReg {\r\n  function register(address _addr, string _tla, uint _base, string _name) payable returns (bool);\r\n  function registerAs(address _addr, string _tla, uint _base, string _name, address _owner) payable returns (bool);\r\n  function unregister(uint _id);\r\n  function setFee(uint _fee);\r\n  function tokenCount() constant returns (uint);\r\n  function token(uint _id) constant returns (address addr, string tla, uint base, string name, address owner);\r\n  function fromAddress(address _addr) constant returns (uint id, string tla, uint base, string name, address owner);\r\n  function fromTLA(string _tla) constant returns (uint id, address addr, uint base, string name, address owner);\r\n  function meta(uint _id, bytes32 _key) constant returns (bytes32);\r\n  function setMeta(uint _id, bytes32 _key, bytes32 _value);\r\n  function transferTLA(string _tla, address _to) returns (bool success);\r\n  function drain();\r\n  uint public fee;\r\n}\r\n\r\n// BasicCoin, ECR20 tokens that all belong to the owner for sending around\r\ncontract BasicCoin is Owned, Token {\r\n  // this is as basic as can be, only the associated balance & allowances\r\n  struct Account {\r\n    uint balance;\r\n    mapping (address => uint) allowanceOf;\r\n  }\r\n\r\n  // the balance should be available\r\n  modifier when_owns(address _owner, uint _amount) {\r\n    if (accounts[_owner].balance < _amount) throw;\r\n    _;\r\n  }\r\n\r\n  // an allowance should be available\r\n  modifier when_has_allowance(address _owner, address _spender, uint _amount) {\r\n    if (accounts[_owner].allowanceOf[_spender] < _amount) throw;\r\n    _;\r\n  }\r\n\r\n  // no ETH should be sent with the transaction\r\n  modifier when_no_eth {\r\n    if (msg.value > 0) throw;\r\n    _;\r\n  }\r\n\r\n  // a value should be > 0\r\n  modifier when_non_zero(uint _value) {\r\n    if (_value == 0) throw;\r\n    _;\r\n  }\r\n\r\n  // the base, tokens denoted in micros\r\n  uint constant public base = 1000000;\r\n\r\n  // available token supply\r\n  uint public totalSupply;\r\n\r\n  // storage and mapping of all balances & allowances\r\n  mapping (address => Account) accounts;\r\n\r\n  // constructor sets the parameters of execution, _totalSupply is all units\r\n  function BasicCoin(uint _totalSupply, address _owner) when_no_eth when_non_zero(_totalSupply) {\r\n    totalSupply = _totalSupply;\r\n    owner = _owner;\r\n    accounts[_owner].balance = totalSupply;\r\n  }\r\n\r\n  // balance of a specific address\r\n  function balanceOf(address _who) constant returns (uint256) {\r\n    return accounts[_who].balance;\r\n  }\r\n\r\n  // transfer\r\n  function transfer(address _to, uint256 _value) when_no_eth when_owns(msg.sender, _value) returns (bool) {\r\n    Transfer(msg.sender, _to, _value);\r\n    accounts[msg.sender].balance -= _value;\r\n    accounts[_to].balance += _value;\r\n\r\n    return true;\r\n  }\r\n\r\n  // transfer via allowance\r\n  function transferFrom(address _from, address _to, uint256 _value) when_no_eth when_owns(_from, _value) when_has_allowance(_from, msg.sender, _value) returns (bool) {\r\n    Transfer(_from, _to, _value);\r\n    accounts[_from].allowanceOf[msg.sender] -= _value;\r\n    accounts[_from].balance -= _value;\r\n    accounts[_to].balance += _value;\r\n\r\n    return true;\r\n  }\r\n\r\n  // approve allowances\r\n  function approve(address _spender, uint256 _value) when_no_eth returns (bool) {\r\n    Approval(msg.sender, _spender, _value);\r\n    accounts[msg.sender].allowanceOf[_spender] += _value;\r\n\r\n    return true;\r\n  }\r\n\r\n  // available allowance\r\n  function allowance(address _owner, address _spender) constant returns (uint256) {\r\n    return accounts[_owner].allowanceOf[_spender];\r\n  }\r\n\r\n  // no default function, simple contract only, entry-level users\r\n  function() {\r\n    throw;\r\n  }\r\n}\r\n\r\n// Manages BasicCoin instances, including the deployment & registration\r\ncontract BasicCoinManager is Owned {\r\n  // a structure wrapping a deployed BasicCoin\r\n  struct Coin {\r\n    address coin;\r\n    address owner;\r\n    address tokenreg;\r\n  }\r\n\r\n  // a new BasicCoin has been deployed\r\n  event Created(address indexed owner, address indexed tokenreg, address indexed coin);\r\n\r\n  // a list of all the deployed BasicCoins\r\n  Coin[] coins;\r\n\r\n  // all BasicCoins for a specific owner\r\n  mapping (address => uint[]) ownedCoins;\r\n\r\n  // the base, tokens denoted in micros (matches up with BasicCoin interface above)\r\n  uint constant public base = 1000000;\r\n\r\n  // return the number of deployed\r\n  function count() constant returns (uint) {\r\n    return coins.length;\r\n  }\r\n\r\n  // get a specific deployment\r\n  function get(uint _index) constant returns (address coin, address owner, address tokenreg) {\r\n    Coin c = coins[_index];\r\n\r\n    coin = c.coin;\r\n    owner = c.owner;\r\n    tokenreg = c.tokenreg;\r\n  }\r\n\r\n  // returns the number of coins for a specific owner\r\n  function countByOwner(address _owner) constant returns (uint) {\r\n    return ownedCoins[_owner].length;\r\n  }\r\n\r\n  // returns a specific index by owner\r\n  function getByOwner(address _owner, uint _index) constant returns (address coin, address owner, address tokenreg) {\r\n    return get(ownedCoins[_owner][_index]);\r\n  }\r\n\r\n  // deploy a new BasicCoin on the blockchain\r\n  function deploy(uint _totalSupply, string _tla, string _name, address _tokenreg) payable returns (bool) {\r\n    TokenReg tokenreg = TokenReg(_tokenreg);\r\n    BasicCoin coin = new BasicCoin(_totalSupply, msg.sender);\r\n\r\n    uint ownerCount = countByOwner(msg.sender);\r\n    uint fee = tokenreg.fee();\r\n\r\n    ownedCoins[msg.sender].length = ownerCount + 1;\r\n    ownedCoins[msg.sender][ownerCount] = coins.length;\r\n    coins.push(Coin(coin, msg.sender, tokenreg));\r\n    tokenreg.registerAs.value(fee)(coin, _tla, base, _name, msg.sender);\r\n\r\n    Created(msg.sender, tokenreg, coin);\r\n\r\n    return true;\r\n  }\r\n\r\n  // owner can withdraw all collected funds\r\n  function drain() only_owner {\r\n    if (!msg.sender.send(this.balance)) {\r\n      throw;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"countByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"coin\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenreg\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_tla\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_tokenreg\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getByOwner\",\"outputs\":[{\"name\":\"coin\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenreg\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenreg\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"current\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"}]","ContractName":"BasicCoinManager","CompilerVersion":"v0.4.2+commit.af6afb04","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}