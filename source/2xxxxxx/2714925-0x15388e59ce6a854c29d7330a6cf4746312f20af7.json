{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\ncontract SpiceMembers {\r\n    enum MemberLevel { None, Member, Manager, Director }\r\n    struct Member {\r\n        uint id;\r\n        MemberLevel level;\r\n        bytes32 info;\r\n    }\r\n\r\n    mapping (address => Member) member;\r\n\r\n    address public owner;\r\n    mapping (uint => address) public memberAddress;\r\n    uint public memberCount;\r\n\r\n    event TransferOwnership(address indexed sender, address indexed owner);\r\n    event AddMember(address indexed sender, address indexed member);\r\n    event RemoveMember(address indexed sender, address indexed member);\r\n    event SetMemberLevel(address indexed sender, address indexed member, MemberLevel level);\r\n    event SetMemberInfo(address indexed sender, address indexed member, bytes32 info);\r\n\r\n    function SpiceMembers() {\r\n        owner = msg.sender;\r\n\r\n        memberCount = 1;\r\n        memberAddress[memberCount] = owner;\r\n        member[owner] = Member(memberCount, MemberLevel.None, 0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        if (msg.sender != owner && memberLevel(msg.sender) < MemberLevel.Manager) throw;\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _target) onlyOwner {\r\n        // If new owner has no memberId, create one\r\n        if (member[_target].id == 0) {\r\n            memberCount++;\r\n            memberAddress[memberCount] = _target;\r\n            member[_target] = Member(memberCount, MemberLevel.None, 0);\r\n        }\r\n        owner = _target;\r\n        TransferOwnership(msg.sender, owner);\r\n    }\r\n\r\n    function addMember(address _target) onlyManager {\r\n        // Make sure trying to add an existing member throws an error\r\n        if (memberLevel(_target) != MemberLevel.None) throw;\r\n\r\n        // If added member has no memberId, create one\r\n        if (member[_target].id == 0) {\r\n            memberCount++;\r\n            memberAddress[memberCount] = _target;\r\n            member[_target] = Member(memberCount, MemberLevel.None, 0);\r\n        }\r\n\r\n        // Set memberLevel to initial value with basic access\r\n        member[_target].level = MemberLevel.Member;\r\n        AddMember(msg.sender, _target);\r\n    }\r\n\r\n    function removeMember(address _target) {\r\n        // Make sure trying to remove a non-existing member throws an error\r\n        if (memberLevel(_target) == MemberLevel.None) throw;\r\n        // Make sure members are only allowed to delete members lower than their level\r\n        if (msg.sender != owner && memberLevel(msg.sender) <= memberLevel(_target)) throw;\r\n\r\n        member[_target].level = MemberLevel.None;\r\n        RemoveMember(msg.sender, _target);\r\n    }\r\n\r\n    function setMemberLevel(address _target, MemberLevel level) {\r\n        // Make sure all levels are larger than None but not higher than Director\r\n        if (level == MemberLevel.None || level > MemberLevel.Director) throw;\r\n        // Make sure the _target is currently already a member\r\n        if (memberLevel(_target) == MemberLevel.None) throw;\r\n        // Make sure the new level is lower level than we are (we cannot overpromote)\r\n        if (msg.sender != owner && memberLevel(msg.sender) <= level) throw;\r\n        // Make sure the member is currently on lower level than we are\r\n        if (msg.sender != owner && memberLevel(msg.sender) <= memberLevel(_target)) throw;\r\n\r\n        member[_target].level = level;\r\n        SetMemberLevel(msg.sender, _target, level);\r\n    }\r\n\r\n    function setMemberInfo(address _target, bytes32 info) {\r\n        // Make sure the target is currently already a member\r\n        if (memberLevel(_target) == MemberLevel.None) throw;\r\n        // Make sure the member is currently on lower level than we are\r\n        if (msg.sender != owner && msg.sender != _target && memberLevel(msg.sender) <= memberLevel(_target)) throw;\r\n\r\n        member[_target].info = info;\r\n        SetMemberInfo(msg.sender, _target, info);\r\n    }\r\n\r\n    function memberId(address _target) constant returns (uint) {\r\n        return member[_target].id;\r\n    }\r\n\r\n    function memberLevel(address _target) constant returns (MemberLevel) {\r\n        return member[_target].level;\r\n    }\r\n\r\n    function memberInfo(address _target) constant returns (bytes32) {\r\n        return member[_target].info;\r\n    }\r\n}\r\n\r\ncontract SpiceControlled {\r\n    SpiceMembers members;\r\n\r\n    modifier onlyOwner {\r\n        if (!hasOwnerAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyDirector {\r\n        if (!hasDirectorAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        if (!hasManagerAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMember {\r\n        if (!hasMemberAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    function SpiceControlled(address membersAddress) {\r\n        members = SpiceMembers(membersAddress);\r\n    }\r\n\r\n    function hasOwnerAccess(address _target) internal returns (bool) {\r\n        return (_target == members.owner());\r\n    }\r\n\r\n    function hasDirectorAccess(address _target) internal returns (bool) {\r\n        return (members.memberLevel(_target) >= SpiceMembers.MemberLevel.Director || hasOwnerAccess(_target));\r\n    }\r\n\r\n    function hasManagerAccess(address _target) internal returns (bool) {\r\n        return (members.memberLevel(_target) >= SpiceMembers.MemberLevel.Manager || hasOwnerAccess(_target));\r\n    }\r\n\r\n    function hasMemberAccess(address _target) internal returns (bool) {\r\n        return (members.memberLevel(_target) >= SpiceMembers.MemberLevel.Member || hasOwnerAccess(_target));\r\n    }\r\n}\r\n\r\ncontract IPayoutCalculator {\r\n    function calculatePayout(bytes32 _info, uint _duration) returns (uint);\r\n}\r\n\r\ncontract SpiceRates is SpiceControlled, IPayoutCalculator {\r\n    struct RatesEntry {\r\n        bool available;\r\n        uint8 unpaidPercentage;\r\n    }\r\n\r\n    uint public hourlyRate;\r\n    mapping(bytes32 => RatesEntry) entries;\r\n    bytes32[] infos;\r\n\r\n    event SetHourlyRate(uint hourlyRate);\r\n    event SetUnpaidPercentage(bytes32 indexed info, uint8 unpaidPercentage);\r\n    event CalculatePayout(bytes32 indexed info, uint duration, uint hourlyRate, uint8 unpaidPercentage);\r\n\r\n    function SpiceRates(\r\n        address _members,\r\n        uint _hourlyRate\r\n    ) SpiceControlled(_members) {\r\n        hourlyRate = _hourlyRate;\r\n        SetHourlyRate(hourlyRate);\r\n    }\r\n\r\n    function setHourlyRate(uint _hourlyRate) onlyDirector {\r\n        hourlyRate = _hourlyRate;\r\n    }\r\n\r\n    function setUnpaidPercentage(bytes32 _info, uint8 _percentage) onlyManager {\r\n        if (_percentage > 100) throw;\r\n        if (_info == 0) throw;\r\n\r\n        RatesEntry entry = entries[_info];\r\n        if (!entry.available) {\r\n            entry.available = true;\r\n            infos.push(_info);\r\n        }\r\n        entry.unpaidPercentage = _percentage;\r\n        SetUnpaidPercentage(_info, _percentage);\r\n    }\r\n\r\n    function unpaidPercentage(bytes32 _info) constant returns (uint8) {\r\n        return entries[_info].unpaidPercentage;\r\n    }\r\n\r\n    function entryInfo(uint _index) constant returns (bytes32) {\r\n        return infos[_index];\r\n    }\r\n\r\n    function entryCount() constant returns (uint) {\r\n        return infos.length;\r\n    }\r\n\r\n    // This is the main function implementing IPayoutCalculator\r\n    function calculatePayout(bytes32 _info, uint _duration) returns (uint) {\r\n        uint8 unpaid = unpaidPercentage(_info);\r\n        CalculatePayout(_info, _duration, hourlyRate, unpaid);\r\n\r\n        uint fullTimeOutput = _duration * hourlyRate / 3600;\r\n        return (fullTimeOutput * (100 - unpaid)) / 100;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"entryCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"entryInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hourlyRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_info\",\"type\":\"bytes32\"}],\"name\":\"unpaidPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_info\",\"type\":\"bytes32\"},{\"name\":\"_percentage\",\"type\":\"uint8\"}],\"name\":\"setUnpaidPercentage\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hourlyRate\",\"type\":\"uint256\"}],\"name\":\"setHourlyRate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_info\",\"type\":\"bytes32\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"calculatePayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_members\",\"type\":\"address\"},{\"name\":\"_hourlyRate\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hourlyRate\",\"type\":\"uint256\"}],\"name\":\"SetHourlyRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"info\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"unpaidPercentage\",\"type\":\"uint8\"}],\"name\":\"SetUnpaidPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"info\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hourlyRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unpaidPercentage\",\"type\":\"uint8\"}],\"name\":\"CalculatePayout\",\"type\":\"event\"}]","ContractName":"SpiceRates","CompilerVersion":"v0.4.4+commit.4633f3de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004ed985e2da341e276bbf7782f2e1e30689d33c890000000000000000000000000000000000000000000000000000000000e4e1c0","Library":"","SwarmSource":""}]}