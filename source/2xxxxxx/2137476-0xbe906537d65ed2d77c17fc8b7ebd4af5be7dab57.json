{"status":"1","message":"OK","result":[{"SourceCode":"contract MyTokenShr {\r\n\t\r\n    Company public myCompany;\r\n\tbool active = false;\r\n\t\r\n\tmodifier onlyActive {if(active) _ }\r\n    modifier onlyfromcompany {if(msg.sender == address(myCompany)) _ }\r\n\t\r\n\tfunction initContract(string _name, string _symbol, uint _firstTender, \r\n\t\t\t\t\t\t  uint _startPrice )  {\r\n\t\tif(active) throw;\r\n\t\tname = _name;\r\n\t\tsymbol =  _symbol;\r\n\t\tmyCompany = Company(msg.sender);\r\n\t\taddTender(1,_firstTender, 0, _startPrice);\r\n\t\tactive = true;\r\n\t}\r\n\r\n\r\n    // Tender Mechanism..\r\n\t// Issue New Tokens only in tender\r\n\t//\r\n  \tstruct Tender { uint id;\r\n                  uint maxstake;\r\n                  uint usedstake;\r\n                  address reservedFor;\r\n                  uint priceOfStake;\r\n  \t}\r\n \tTender[] activeTenders;\r\n  \r\n  \tfunction addTender(uint nid, uint nmaxstake, address nreservedFor,uint _priceOfStake) {\r\n\r\n\t\t//ToDo: freigabe durch Board\r\n    \r\n     \tTender memory newt;\r\n      \tnewt.id = nid;\r\n      \tnewt.maxstake = nmaxstake;\r\n      \tnewt.usedstake = 0;\r\n      \tnewt.reservedFor = nreservedFor;\r\n      \tnewt.priceOfStake = _priceOfStake;\r\n      \r\n      \tactiveTenders.push(newt);\r\n  \t}\r\n\r\n    function issuetender(address _to, uint tender, uint256 _value) onlyfromcompany {\r\n\r\n        for(uint i=0;i<activeTenders.length;i++){\r\n            if(activeTenders[i].id == tender){\r\n                if(activeTenders[i].reservedFor == 0 ||\r\n                    activeTenders[i].reservedFor == _to ){\r\n                        uint stake = _value / activeTenders[i].priceOfStake;\r\n                        if(activeTenders[i].maxstake-activeTenders[i].usedstake >= stake){\r\n                            if (balanceOf[_to] + stake < balanceOf[_to]) throw; // Check for overflows\r\n                            balanceOf[_to] += stake;                            // Add the same to the recipient\r\n\t\t\t\t\t\t\ttotalSupply += stake;\r\n\t\t\t\t\t\t\tupdateBalance(_to,balanceOf[_to]);\r\n                            Transfer(this, _to, stake); \r\n                            activeTenders[i].usedstake += stake; // Notify anyone listening that this transfer took place\r\n                            \r\n                        }\r\n                        \r\n                    }\r\n            }\r\n        }\r\n    }\r\n\tfunction destroyToken(address _from, uint _amo) {\r\n\t\tif(balanceOf[_from] < _amo) throw;\r\n\t\tbalanceOf[_from] -= _amo;\r\n\t\tupdateBalance(_from,balanceOf[_from]);\r\n\t\ttotalSupply -= _amo;\r\n \t}\r\n\t\r\n\t\r\n\tuint public pricePerStake = 1;\r\n\r\n\r\n\tfunction registerEarnings (uint _stake) {\r\n\r\n\t\t//_stake zu verteilen..\r\n\t\t//totalSupply  anteile..\r\n\t\t//balanceOf  ... mein stake..\r\n\t\tfor(uint i;i<userCnt;i++){\r\n\t\t\tuint earning = _stake * balanceByID[i].balamce / totalSupply;\r\n\t\t\tbalanceByID[i].earning += earning;\r\n\t\t}\r\n\t}\r\n\tfunction queryEarnings(address _addr) returns (uint){\r\n\t\treturn balanceByAd[_addr].earning;\r\n\t}\r\n\tfunction bookEarnings(address _addr, uint _amo){\r\n\t\tbalanceByAd[_addr].earning -=  _amo;\r\n\t}\r\n\r\n\tfunction setPricePerStake(uint _price)  {\r\n        //ToDo: vote mechanismus..  Boarddecission\r\n        pricePerStake = _price;\r\n    }\r\n\r\n\t//\r\n\t// The Real Token Code..\r\n    /* Public variables of the token */\r\n    string public standard = 'Token 0.1';\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 8;\r\n    uint256 public totalSupply = 0;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n\r\n\r\n\tstruct balance {\r\n\t\tuint id;\r\n\t\taddress ad;\r\n\t\tuint earning;\r\n\t\tuint balamce;\r\n\r\n\t}\t\r\n\tmapping (address  => balance) public balanceByAd;\r\n\tmapping (uint => balance) public balanceByID;\r\n\tuint userCnt=0;\r\n\t\r\n\tfunction updateBalance(address _addr, uint _bal){\r\n\t\tif(balanceByAd[_addr].id == 0){\r\n\t\t\tuserCnt++;\r\n\t\t\tbalanceByAd[_addr] = balance(userCnt, _addr, 0,_bal);\r\n\t\t\tbalanceByID[userCnt] = balanceByAd[_addr];\r\n\t\t} else {\r\n\t\t\tbalanceByAd[_addr].balamce = _bal;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n\r\n    \r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n\t\tupdateBalance(_to,balanceOf[_to]);\r\n\t\tupdateBalance(msg.sender,balanceOf[msg.sender]);\r\n\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether\r\n    }\r\n\t\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Project {\r\n\tfunction setCompany(){\r\n\t\t\r\n\t}\r\n\r\n\r\n\r\n\t\r\n}\r\n\r\ncontract SlotMachine {\r\n\r\n\taddress CompanyAddress = 0;\r\n\t\r\n\tuint256 maxEinsatz = 1 ether;\r\n\tuint256 winFaktor = 2000;\r\n\tuint256 maxWin=maxEinsatz * winFaktor;\r\n\tuint public minReserve=maxWin ;\r\n\tuint public maxReserve=maxWin * 2;\r\n\tuint public sollReserve=maxWin+(maxWin * 2 / 10);\r\n\t\r\n//1 ether * 2000 + (1 ether * 2000 *2/10)\r\n//\tuint256 percOfBuffer=100;\r\n\t\r\n\tint earnings = 0;\r\n\tuint public gamerun=0;\r\n\tuint[4] public wins;\r\n\r\n\t//Constructor\r\n\tfunction SlotMachine(){\r\n\t\t\r\n\t}\r\n\tfunction setCompany(){\r\n\t\tif(CompanyAddress != 0) throw;\r\n\t\tCompanyAddress=msg.sender; //Nail to Company..\r\n\t}\r\n\t\r\n\t//Load/Unload Calls for Company..\r\n\tfunction closeBooks() {\r\n\t\tif(msg.sender != CompanyAddress) throw; //Only Internal Call..\r\n\t\tif(earnings <= 0) throw;\r\n\t\tif(this.balance < maxReserve) return;\r\n\t\tuint inc=this.balance-maxReserve;\r\n\t\tbool res = Company(CompanyAddress).send(inc);\r\n\t}\r\n\tfunction dumpOut() {\r\n\t\tif(msg.sender != CompanyAddress) throw; //Only Internal Call..\t\r\n\t\tbool result = msg.sender.send(this.balance);\r\n\t}\r\n\t\r\n\tuint _nr ;\r\n\tuint _y;\r\n\tuint _win;\r\n\tfunction(){\r\n\t\t\r\n\t\tif(msg.sender == CompanyAddress) {\r\n\t\t\t//just a fill up..\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t//ok here goes the game..\r\n\t\tuint einsatz=msg.value;\r\n\t\tif(einsatz * winFaktor > this.balance) throw; //cant do this game..\r\n\t\t\r\n\t\t//Play the game..\r\n\t\tuint nr = now; //block.number;\r\n\t\tuint y = nr & 3;\r\n\t\t\r\n\t\tuint win = 0;\r\n\t\tif(y==0) wins[0]++;\r\n\t\tif(y==1) {wins[1]++; win = (msg.value * 2)  + (msg.value / 2);}\r\n\t\tif(y==2) wins[2]++;\r\n\t\t\r\n\t\tearnings += int(msg.value);\r\n\r\n\t\tif(win > 0) { // half win..\r\n\t\t\tbool res = msg.sender.send(win);\r\n\t\t\tearnings -= int(win);\t\t\r\n\t\t}\r\n\t\tgamerun++;\r\n\t\t_nr=nr;\r\n\t\t_win=win;\r\n\t\t_y=y;\r\n\t\t\r\n\t\t//Final.. Cleanup.. and so on..\r\n\t\tif(this.balance < minReserve){\r\n\t\t\tCompany(CompanyAddress).requestFillUp(sollReserve-this.balance);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n/////////////\r\n//\r\n// contract Globals\r\n//\r\n// wird in Company eingebunden..\r\n// speichert globale Variablen..\r\n//\r\ncontract Globals {\r\n\tMyTokenShr public myBackerToken;\r\n    MyTokenShr public myShareToken;\r\n\t\t\r\n\tuint public startSlotAt = 1 ether * 2000 + (1 ether * 2000 *2/10);//100 ether; \r\n\t\r\n\tuint BudgetSlot = 0;\r\n\tuint BudgetProject = 0;\r\n\tuint BudgetReserve = 0;\r\n\t\r\n\tuint IncomeShare =0;\r\n\tuint IncomeBacker =0;\r\n\r\n}\r\n\r\n/////////////\r\n//\r\n// contract Board\r\n//\r\n// wird in Company eingebunden..\r\n// verwaltet das Board.. das Board besteht aus 3 Adressen,\r\n// die mit einem Voting mechanismus von den ShareHolden (MyShareToken)\r\n// gewÃÂÃÂÃÂÃÂ¤hlt und ausgetauscht werden\r\n// \r\n// Board Member kÃÂÃÂÃÂÃÂ¶nnen verschiedene Tasks auslÃÂÃÂÃÂÃÂ¶sen\r\n// und Parameter einstellen.\r\ncontract Board is Globals{\r\n\t\r\n\r\n    address[3] public Board;\r\n\t    \r\n    function _isBoardMember(address c) returns(bool){\r\n        for(uint i=0;i<Board.length;i++){\r\n            if(Board[i] == c) return true;\r\n        }\r\n        return false;\r\n    }\r\n\t\r\n\t    modifier onlybyboardmember {if(_isBoardMember(tx.origin)) _ }\r\n\r\n\t\t// Voting Process..\r\n\t// Vote for an BoardMember,\r\n\t//\r\n\t//\t   \tfunction startBoardProposal(uint _place, address _nmbr)\r\n\t//\t\tfunction killBoardProposal(uint _place, address _nmbr) \r\n\t//\t\tfunction vote(uint _place, address _nmbr, bool pro)\r\n\t//\r\n\tstruct Proposal {\r\n\t\taddress newBoardMember;\r\n    \tuint placeInBoard;\r\n        uint givenstakes;\r\n    \tint ergebnis;\r\n\t\tbool active;\r\n        mapping (address => bool)  voted;\r\n\t}\r\n    \r\n    Proposal[] Proposals;\r\n\t\tuint Abalance;\r\n\t\tuint Asupply ;\r\n\t\tbool Abmb;\r\n\r\n    function startBoardProposal(uint _place, address _nmbr) public{\r\n\r\n\t\tAbalance = myShareToken.balanceOf(msg.sender);\r\n\t\t Asupply = myShareToken.totalSupply();\r\n\t\t Abmb = _isBoardMember(msg.sender);\r\n\t\t\r\n\t\tif(( Abalance > ( Asupply / 1000 )) || \r\n                _isBoardMember(msg.sender)){\r\n                   \tProposals.push(Proposal(_nmbr, _place, 0, 0, true));\r\n        }\r\n    }      \r\n\t\r\n\tfunction killBoardProposal(uint _place, address _nmbr) public{\r\n\t\tif(  _isBoardMember(msg.sender)){\r\n \t\t\tfor(var i=0;i<Proposals.length;i++){\r\n\t\t\t\tif((Proposals[i].placeInBoard == _place) && \r\n\t\t\t   \t\t(Proposals[i].newBoardMember == _nmbr) ){\r\n\t\t\t\t\tdelete Proposals[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t   \t}\r\n\t}\r\n     \r\n    function voteBoardProposal(uint _place, address _nmbr, bool pro) public {\r\n\t\tfor(var i=0;i<Proposals.length;i++){\r\n\t\t\tif((Proposals[i].placeInBoard == _place) && \r\n\t\t\t   (Proposals[i].newBoardMember == _nmbr) && \r\n\t\t\t   (Proposals[i].active == true) ){\r\n\t\t\t\t\r\n        \t\tif(Proposals[i].voted[msg.sender]) throw; //already voted..\r\n        \t\t\r\n\t\t\t\tProposals[i].givenstakes += myShareToken.balanceOf(msg.sender);\r\n\r\n\t\t\t\tif( pro) Proposals[i].ergebnis += int(myShareToken.balanceOf(msg.sender));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\telse Proposals[i].ergebnis -= int(myShareToken.balanceOf(msg.sender));\r\n        \t\t\r\n        \t\tProposals[i].voted[msg.sender] = true;\r\n       \r\n        \t\t//finale checks..\r\n\t\t\t\tif( myShareToken.totalSupply() / 2 < Proposals[i].givenstakes) { //more then 50% voted.. finish..\r\n            \t\tif(Proposals[i].ergebnis > 0)      { // ergebnis positiv.. tausche boardmember aus..\r\n\r\n\t\t\t\t\t\tBoard[_place] = _nmbr;\r\n\r\n\t\t\t\t\t\tProposals[i].active = false;\r\n            \t\t}\r\n        \t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\r\n\r\n}\r\n\r\n/////////////\r\n//\r\n// contract SlotMachineMngr\r\n//\r\n// wird in Company eingebunden..\r\n// verwaltet das SlotMachines.. \r\n/*\tuint256 maxEinsatz = 1 ether;\r\n\tuint256 winFaktor = 2000;\r\n\tuint256 maxWin=maxEinsatz * winFaktor;\r\n\tuint public minReserve=maxWin ;\r\n\tuint public maxReserve=maxWin * 2;\r\n\tuint public sollReserve=1 ether * 2000 * 2 / 10;\r\n*/\r\ncontract SlotMachineMngr is Board{\t//\r\n\t//adding SlotMachines...\r\n\t//  and managing SlotMachines...\r\n\taddress private addSlotBy = 0;\r\n\taddress private newSlotAddr;\r\n\tSlotMachine[] public Slots;\r\n\t\r\n\tfunction _slotAddNew(address _addr) public onlybyboardmember {\r\n\t\tif(addSlotBy != 0) throw;\r\n\t\t\r\n\t\tif(BudgetSlot < startSlotAt) return;\r\n\t\t\t\t\r\n\t\taddSlotBy = msg.sender;\r\n\t\tnewSlotAddr = _addr;\r\n\t}\r\n\tfunction _slotCommitNew(address _addr) public onlybyboardmember {\r\n\t\tif(msg.sender==addSlotBy) throw; //no self commit\r\n\t\tif(newSlotAddr != _addr) throw;\r\n\t\t\r\n\t\tSlotMachine Slot = SlotMachine(newSlotAddr);\r\n\t\tSlot.setCompany();\r\n\t\tbool res = Slot.send(startSlotAt);\r\n\t\tSlots.push(Slot);\t\r\n\t\taddSlotBy = 0;\t\t\r\n\t}\r\n\tfunction _slotCancelNew() public onlybyboardmember {\r\n\t\taddSlotBy = 0;\r\n\t}\r\n}\r\n/////////////\r\n//\r\n// contract ProjectMngr\r\n//\r\n// wird in Company eingebunden..\r\n// verwaltet das Projekte..\r\n// Projekte sind einmalige Budget Contracts die zum erledigen \r\n// diverser Aufgaben angelegt werden. \r\ncontract ProjectMngr is Board {\r\n\t\t//\r\n\t//adding Projects...\r\n\t// \r\n\taddress private addProjectBy = 0;\r\n\taddress private newProjectAddr;\r\n\tuint private newProjectBudget;\r\n\tProject[] public Projects;\r\n\t\r\n\tfunction _projectAddNew(address _addr, uint _budget) public onlybyboardmember {\r\n\t\tif(addProjectBy != 0) throw;\r\n\t\t\r\n\t\tif(BudgetProject < _budget) return;\r\n\t\t\r\n\t\tnewProjectBudget = _budget;\r\n\t\taddProjectBy = msg.sender;\r\n\t\tnewProjectAddr = _addr;\r\n\t}\r\n\tfunction _projectCommitNew(address _addr) public onlybyboardmember {\r\n\t\tif(msg.sender==addProjectBy) throw; //no self commit\r\n\t\tif(newProjectAddr != _addr) throw;\r\n\t\t\r\n\t\tProject myProject = Project(newProjectAddr);\r\n\t\tmyProject.setCompany();\r\n\t\tbool res = myProject.send(newProjectBudget);\r\n\t\tProjects.push(myProject);\t\r\n\t\taddProjectBy = 0;\t\t\r\n\t}\r\n\tfunction _projectCancelNew() public onlybyboardmember {\r\n\t\taddProjectBy = 0;\r\n\t}\r\n\r\n}\r\n\r\n/////////////\r\n//\r\n// contract Company\r\n//\r\ncontract Company  is Globals, Board, SlotMachineMngr, ProjectMngr {//, managedbycompany {\r\n\r\n\t    \r\n\tfunction fillUpSlot(uint _id, uint _amo){\r\n\t\tuint ts = _amo;\r\n\t\tif(ts<=BudgetSlot){BudgetSlot -= ts; ts=0;}\r\n\t\telse {ts -= BudgetSlot; BudgetSlot = 0;}\r\n\r\n\t\tif(ts>0){\r\n\t\t\tif(ts<=BudgetReserve){BudgetReserve -= ts; ts=0;}\r\n\t\t\telse {ts -= BudgetReserve; BudgetReserve = 0;}\r\n\t\t}\r\n\t\t\r\n\t\tif(ts>0){\r\n\t\t\tif(ts<=BudgetProject){BudgetProject -= ts; ts=0;}\r\n\t\t\telse {ts -= BudgetProject; BudgetProject = 0;}\r\n\t\t}\r\n\t}\r\n\tfunction fillUpProject(uint _id, uint _amo){\r\n\t\tthrow; //No Refill for Project..\r\n\t}\r\n\tfunction requestFillUp(uint _amo){\r\n\t\t//From SlotMachine?\r\n\t\tfor(uint i=0;i<Slots.length;i++){\r\n\t\t\tif(Slots[i] == msg.sender){\r\n\t\t\t\tfillUpSlot(i, _amo);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(uint x=0;x<Projects.length;x++){\r\n\t\t\tif(Projects[x] == msg.sender){\r\n\t\t\t\tfillUpProject(x, _amo);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// \r\n\t// Taks fuer Initialisierung..\r\n\t//\t\t\t\t\t\t\t\r\n\tfunction _addPools(address _backer, address _share){\r\n\r\n\t\tmyShareToken = MyTokenShr(_share);\r\n\t\tmyShareToken.initContract(\"SMShares\",\"XXSMS\", 0.1 ether, 1);\r\n\r\n        myBackerToken = MyTokenShr(_backer);\r\n\t\tmyBackerToken.initContract(\"SMBShares\",\"XXSMBS\", 12000000 ether, 1);\r\n\t\t\r\n\t}\r\n\t\r\n\t// \r\n\t// Taks fuer Abrechnung..\r\n\t//\t\t\t\t\t\t\t\r\n\tfunction _dispatchEarnings() {\r\n\t\tif(IncomeShare > 0) {\r\n\t\t\tmyShareToken.registerEarnings(IncomeShare);\r\n\t\t\tIncomeShare=0;\r\n\t\t}\r\n\t\tif(IncomeBacker > 0 ) {\r\n\t\t\tmyBackerToken.registerEarnings(IncomeBacker);\r\n\t\t\tIncomeBacker=0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction _closeBooks() {\r\n\t\tfor(var i=0;i<Slots.length;i++){\r\n\t\t\tSlots[i].closeBooks();\r\n\t\t}\r\n\t}\r\n\tfunction _dumpToCompany() {\r\n\t\tfor(var i=0;i<Slots.length;i++){\r\n\t\t\tSlots[i].dumpOut();\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t// auszahlen\r\n\t//\r\n\tenum pool {backer_token,backer_earn, share_earn}\r\n\r\n\tfunction payOut(pool _what, uint _amo){\r\n\t\tuint earn;\r\n\t\tif(_what == pool.backer_token){\r\n\t\t\t earn = myBackerToken.balanceOf(msg.sender);\r\n\t\t\tif(earn<_amo)throw;\r\n\t\t\tif(msg.sender.send(_amo)) myBackerToken.destroyToken(msg.sender,_amo);\r\n\t\t}\r\n\t\tif(_what == pool.backer_earn){\r\n\t\t\t earn = myBackerToken.queryEarnings(msg.sender);\r\n\t\t\tif(earn<_amo)throw;\r\n\t\t\tif(msg.sender.send(_amo)) myBackerToken.bookEarnings(msg.sender, _amo);\r\n\t\t}\r\n\t\tif(_what == pool.share_earn){\r\n\t\t\t earn = myBackerToken.queryEarnings(msg.sender);\r\n\t\t\tif(earn<_amo)throw;\r\n\t\t\tif(msg.sender.send(_amo)) myBackerToken.bookEarnings(msg.sender, _amo);\r\n\t\t}\r\n\t\t\r\n\t}\r\n    \r\n\t//\r\n\t// Geldeingang verbuchen..\r\n\t//\r\n    function buyShare(uint tender,bool _share){\r\n\t\tif(!_share)\r\n\t        myShareToken.issuetender(msg.sender,tender, msg.value);\r\n\t\telse\r\n\t       myBackerToken.issuetender(msg.sender,tender, msg.value);\r\n\t\t\t\r\n\t\tBudgetSlot += (msg.value * 90 / 100);\r\n\t\tBudgetProject += (msg.value * 5 / 100);\r\n\t\tBudgetReserve += (msg.value * 5 / 100);\r\n    }\r\n    function bookEarnings(){\r\n\t\t\t\tIncomeShare += (msg.value * 33 / 100);\r\n\t\t\t\tIncomeBacker += (msg.value * 33 / 100);\r\n\t\t\t\tBudgetSlot += (msg.value * 90 / 100 / 3);\r\n\t\t\t\tBudgetProject += (msg.value * 2 / 100 / 3);\r\n\t\t\t\tBudgetReserve += (msg.value * 2 / 100);\r\n    }\r\n    \r\n\t// Geldeingang ohne weitere Parameter..\r\n\tfunction(){ \r\n\t\tfor(uint i=0;i<Slots.length;i++){\r\n\t\t\tif(Slots[i] == msg.sender){\r\n\t\t\t\tbookEarnings();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\t\t\r\n        buyShare(1, true);\r\n    }\r\n\r\n}\r\n\r\n//EOF","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Slots\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_closeBooks\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myShareToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_slotCommitNew\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_place\",\"type\":\"uint256\"},{\"name\":\"_nmbr\",\"type\":\"address\"}],\"name\":\"killBoardProposal\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startSlotAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Projects\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amo\",\"type\":\"uint256\"}],\"name\":\"requestFillUp\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"},{\"name\":\"_share\",\"type\":\"address\"}],\"name\":\"_addPools\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_dispatchEarnings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_place\",\"type\":\"uint256\"},{\"name\":\"_nmbr\",\"type\":\"address\"},{\"name\":\"pro\",\"type\":\"bool\"}],\"name\":\"voteBoardProposal\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_projectCancelNew\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_place\",\"type\":\"uint256\"},{\"name\":\"_nmbr\",\"type\":\"address\"}],\"name\":\"startBoardProposal\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_amo\",\"type\":\"uint256\"}],\"name\":\"fillUpProject\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_slotAddNew\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myBackerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_projectCommitNew\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bookEarnings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_amo\",\"type\":\"uint256\"}],\"name\":\"fillUpSlot\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_what\",\"type\":\"uint8\"},{\"name\":\"_amo\",\"type\":\"uint256\"}],\"name\":\"payOut\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tender\",\"type\":\"uint256\"},{\"name\":\"_share\",\"type\":\"bool\"}],\"name\":\"buyShare\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Board\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"_projectAddNew\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_slotCancelNew\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_dumpToCompany\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"c\",\"type\":\"address\"}],\"name\":\"_isBoardMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"}]","ContractName":"Company","CompilerVersion":"v0.3.5-2016-06-10-5f97274","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}