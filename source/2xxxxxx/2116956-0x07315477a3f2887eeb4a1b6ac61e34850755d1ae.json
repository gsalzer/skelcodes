{"status":"1","message":"OK","result":[{"SourceCode":"// Copyright (c) 2016 Chronicled, Inc. All rights reserved.\r\n// http://explorer.chronicled.org\r\n// http://demo.chronicled.org\r\n// http://chronicled.org\r\n\r\ncontract Registrar {\r\n    address public registrar;\r\n\r\n    /**\r\n\r\n    * Created event, gets triggered when a new registrant gets created\r\n    * event\r\n    * @param registrant - The registrant address.\r\n    * @param registrar - The registrar address.\r\n    * @param data - The data of the registrant.\r\n    */\r\n    event Created(address indexed registrant, address registrar, bytes data);\r\n\r\n    /**\r\n    * Updated event, gets triggered when a new registrant id Updated\r\n    * event\r\n    * @param registrant - The registrant address.\r\n    * @param registrar - The registrar address.\r\n    * @param data - The data of the registrant.\r\n    */\r\n    event Updated(address indexed registrant, address registrar, bytes data, bool active);\r\n\r\n    /**\r\n    * Error event.\r\n    * event\r\n    * @param code - The error code.\r\n    * 1: Permission denied.\r\n    * 2: Duplicate Registrant address.\r\n    * 3: No such Registrant.\r\n    */\r\n    event Error(uint code);\r\n\r\n    struct Registrant {\r\n        address addr;\r\n        bytes data;\r\n        bool active;\r\n    }\r\n\r\n    mapping(address => uint) public registrantIndex;\r\n    Registrant[] public registrants;\r\n\r\n    /**\r\n    * Function can't have ether.\r\n    * modifier\r\n    */\r\n    modifier noEther() {\r\n        if (msg.value > 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier isRegistrar() {\r\n      if (msg.sender != registrar) {\r\n        Error(1);\r\n        return;\r\n      }\r\n      else {\r\n        _\r\n      }\r\n    }\r\n\r\n    /**\r\n    * Construct registry with and starting registrants lenght of one, and registrar as msg.sender\r\n    * constructor\r\n    */\r\n    function Registrar() {\r\n        registrar = msg.sender;\r\n        registrants.length++;\r\n    }\r\n\r\n    /**\r\n    * Add a registrant, only registrar allowed\r\n    * public_function\r\n    * @param _registrant - The registrant address.\r\n    * @param _data - The registrant data string.\r\n    */\r\n    function add(address _registrant, bytes _data) isRegistrar noEther returns (bool) {\r\n        if (registrantIndex[_registrant] > 0) {\r\n            Error(2); // Duplicate registrant\r\n            return false;\r\n        }\r\n        uint pos = registrants.length++;\r\n        registrants[pos] = Registrant(_registrant, _data, true);\r\n        registrantIndex[_registrant] = pos;\r\n        Created(_registrant, msg.sender, _data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Edit a registrant, only registrar allowed\r\n    * public_function\r\n    * @param _registrant - The registrant address.\r\n    * @param _data - The registrant data string.\r\n    */\r\n    function edit(address _registrant, bytes _data, bool _active) isRegistrar noEther returns (bool) {\r\n        if (registrantIndex[_registrant] == 0) {\r\n            Error(3); // No such registrant\r\n            return false;\r\n        }\r\n        Registrant registrant = registrants[registrantIndex[_registrant]];\r\n        registrant.data = _data;\r\n        registrant.active = _active;\r\n        Updated(_registrant, msg.sender, _data, _active);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Set new registrar address, only registrar allowed\r\n    * public_function\r\n    * @param _registrar - The new registrar address.\r\n    */\r\n    function setNextRegistrar(address _registrar) isRegistrar noEther returns (bool) {\r\n        registrar = _registrar;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Get if a regsitrant is active or not.\r\n    * constant_function\r\n    * @param _registrant - The registrant address.\r\n    */\r\n    function isActiveRegistrant(address _registrant) constant returns (bool) {\r\n        uint pos = registrantIndex[_registrant];\r\n        return (pos > 0 && registrants[pos].active);\r\n    }\r\n\r\n    /**\r\n    * Get all the registrants.\r\n    * constant_function\r\n    */\r\n    function getRegistrants() constant returns (address[]) {\r\n        address[] memory result = new address[](registrants.length-1);\r\n        for (uint j = 1; j < registrants.length; j++) {\r\n            result[j-1] = registrants[j].addr;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * Function to reject value sends to the contract.\r\n    * fallback_function\r\n    */\r\n    function () noEther {}\r\n\r\n    /**\r\n    * Desctruct the smart contract. Since this is first, alpha release of Open Registry for IoT, updated versions will follow.\r\n    * Registry's discontinue must be executed first.\r\n    */\r\n    function discontinue() isRegistrar noEther {\r\n      selfdestruct(msg.sender);\r\n    }\r\n}\r\n\r\n\r\ncontract Registry {\r\n    // Address of the Registrar contract which holds all the Registrants\r\n    address public registrarAddress;\r\n    // Address of the account which deployed the contract. Used only to configure contract.\r\n    address public deployerAddress;\r\n\r\n    /**\r\n    * Creation event that gets triggered when a thing is created.\r\n    * event\r\n    * @param ids - The identity of the thing.\r\n    * @param owner - The owner address.\r\n    */\r\n    event Created(bytes32[] ids, address indexed owner);\r\n\r\n    /**\r\n    * Update event that gets triggered when a thing is updated.\r\n    * event\r\n    * @param ids - The identity of the thing.\r\n    * @param owner - The owner address.\r\n    * @param isValid - The validity of the thing.\r\n    */\r\n    event Updated(bytes32[] ids, address indexed owner, bool isValid);\r\n\r\n    /**\r\n    * Delete event, triggered when Thing is deleted.\r\n    * event\r\n    * @param ids - The identity of the thing.\r\n    * @param owner - The owner address.\r\n    */\r\n    event Deleted(bytes32[] ids, address indexed owner);\r\n\r\n    /**\r\n    * Generic error event.\r\n    * event\r\n    * @param code - The error code.\r\n    * @param reference - Related references data for the Error event, e.g.: Identity, Address, etc.\r\n    * 1: Identity collision, already assigned to another Thing.\r\n    * 2: Not found, identity does not exist.\r\n    * 3: Unauthorized, modification only by owner.\r\n    * 4: Unknown schema specified.\r\n    * 5: Incorrect input, at least one identity is required.\r\n    * 6: Incorrect input, data is required.\r\n    * 7: Incorrect format of the identity, schema length and identity length cannot be empty.\r\n    * 8: Incorrect format of the identity, identity must be padded with trailing 0s.\r\n    * 9: Contract already configured\r\n    */\r\n    event Error(uint code, bytes32[] reference);\r\n\r\n    struct Thing {\r\n      // All identities of a Thing. e.g.: BLE ID, public key, etc.\r\n      bytes32[] identities;\r\n      // Metadata of the Thing. Hex of ProtoBuffer structure.\r\n      bytes32[] data;\r\n      // Registrant address, who have added the thing.\r\n      address ownerAddress;\r\n      // Index of ProtoBuffer schema used. Optimized to fit in one bytes32.\r\n      uint88 schemaIndex;\r\n      // Status of the Thing. false if compromised, revoked, etc.\r\n      bool isValid;\r\n    }\r\n\r\n    // Things are stored in the array\r\n    Thing[] public things;\r\n\r\n    // Identity to Thing index pointer for lookups and duplicates prevention.\r\n    mapping(bytes32 => uint) public idToThing;\r\n\r\n    // Content of ProtoBuffer schema.\r\n    bytes[] public schemas;\r\n\r\n    /**\r\n    * Function can't contain Ether value.\r\n    * modifier\r\n    */\r\n    modifier noEther() {\r\n        if (msg.value > 0) throw;\r\n        _\r\n    }\r\n\r\n    /**\r\n    * Allow only registrants to exec the function.\r\n    * modifier\r\n    */\r\n    modifier isRegistrant() {\r\n        Registrar registrar = Registrar(registrarAddress);\r\n        if (registrar.isActiveRegistrant(msg.sender)) {\r\n            _\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow only registrar to exec the function.\r\n    * modifier\r\n    */\r\n    modifier isRegistrar() {\r\n        Registrar registrar = Registrar(registrarAddress);\r\n        if (registrar.registrar() == msg.sender) {\r\n            _\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Initialization of the contract\r\n    * constructor\r\n    */\r\n    function Registry() {\r\n        // Initialize arrays. Leave first element empty, since mapping points non-existent keys to 0.\r\n        things.length++;\r\n        schemas.length++;\r\n        deployerAddress = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * Add Identities to already existing Thing.\r\n    * internal_function\r\n    * @param _thingIndex - The position of the Thing in the array.\r\n    * @param _ids - Identities of the Thing in chunked format. Maximum size of one Identity is 2057 bytes32 elements.\r\n    */\r\n    function _addIdentities(uint _thingIndex, bytes32[] _ids) internal returns(bool){\r\n        // Checks if there's duplicates and creates references\r\n        if (false == _rewireIdentities(_ids, 0, _thingIndex, 0)) {\r\n            return false;\r\n        }\r\n\r\n        // Thing don't have Identities yet.\r\n        if (things[_thingIndex].identities.length == 0) {\r\n            // Copy directly. Cheaper than one by one.\r\n            things[_thingIndex].identities = _ids;\r\n        }\r\n        else {\r\n            // _ids array current element pointer.\r\n            // uint32 technically allows to put 128Gb of Identities into one Thing.\r\n            uint32 cell = uint32(things[_thingIndex].identities.length);\r\n            // Copy new IDs to the end of array one by one\r\n            things[_thingIndex].identities.length += _ids.length;\r\n            // If someone will provide _ids array with more than 2^32, it will go into infinite loop at a caller's expense.\r\n            for (uint32 k = 0; k < _ids.length; k++) {\r\n                things[_thingIndex].identities[cell++] = _ids[k];\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Point provided Identities to the desired \"things\" array index in the lookup hash table idToThing.\r\n    * internal_function\r\n    * @param _ids - Identities of the Thing.\r\n    * @param _oldIndex - Previous index that this Identities pointed to, prevents accidental rewiring and duplicate Identities.\r\n    * @param _newIndex - things array index the Identities should point to.\r\n    * @param _newIndex - things array index the Identities should point to.\r\n    * @param _idsForcedLength — Internal use only. Zero by default. Used to revert side effects if execution fails at any point.\r\n    *       Prevents infinity loop in recursion. Though recursion is not desirable, it's used to avoid over-complication of the code.\r\n    */\r\n    function _rewireIdentities(bytes32[] _ids, uint _oldIndex, uint _newIndex, uint32 _idsForcedLength) internal returns(bool) {\r\n        // Current ID cell pointer\r\n        uint32 cell = 0;\r\n        // Length of namespace part of the Identity in URN format\r\n        uint16 urnNamespaceLength;\r\n        // Length of ID part of the Identity, though only uint16 needed but extended to uint24 for correct calculations.\r\n        uint24 idLength;\r\n        // Array cells used for current ID. uint24 to match idLength type, so no conversions needed.\r\n        uint24 cellsPerId;\r\n        // Hash of current ID\r\n        bytes32 idHash;\r\n        // How many bytes of payload are there in the last cell of single ID.\r\n        uint8 lastCellBytesCnt;\r\n        // Number of elements that needs to be processed in _ids array\r\n        uint32 idsLength = _idsForcedLength > 0 ? _idsForcedLength : uint32(_ids.length);\r\n\r\n        // No Identities provided\r\n        if (idsLength == 0) {\r\n            Error(5, _ids);\r\n            return false;\r\n        }\r\n\r\n        // Each ID\r\n        while (cell < idsLength) {\r\n            // Get length of schema. First byte of packed ID.\r\n            // Means that next urnNamespaceLength bytes is the schema definition.\r\n            urnNamespaceLength = uint8(_ids[cell][0]);\r\n            // Length of ID part of this URN Identity.\r\n            idLength =\r\n                // First byte\r\n                uint16(_ids[cell + (urnNamespaceLength + 1) / 32][(urnNamespaceLength + 1) % 32]) * 2 ** 8 |\r\n                // Second byte\r\n                uint8(_ids[cell + (urnNamespaceLength + 2) / 32][(urnNamespaceLength + 2) % 32]);\r\n\r\n            // We deal with the new Identity (instead rewiring after deletion)\r\n            if (_oldIndex == 0 && (urnNamespaceLength == 0 || idLength == 0)) {\r\n                // Incorrect Identity structure.\r\n                Error(7, _ids);\r\n\r\n                // If at least one Identity already wired. And if this is not a recursive call.\r\n                if (cell > 0 && _idsForcedLength == 0) {\r\n                    _rewireIdentities(_ids, _newIndex, _oldIndex, cell); // Revert changes made so far\r\n                }\r\n                return false;\r\n            }\r\n\r\n            // Total bytes32 cells devoted for this ID. Maximum 2057 is possible.\r\n            cellsPerId = (idLength + urnNamespaceLength + 3) / 32;\r\n            if ((idLength + urnNamespaceLength + 3) % 32 != 0) {\r\n                // Identity uses one more cell partially\r\n                cellsPerId++;\r\n                // For new identity, ensure that complies with the format, specifically padding is done with 0s.\r\n                // This prevents from adding duplicated identities, which might be accepted because generate a different hash.\r\n                if (_oldIndex == 0) {\r\n                    // How many bytes the ID occupies in the last cell.\r\n                    lastCellBytesCnt = uint8((idLength + urnNamespaceLength + 3) % 32);\r\n\r\n                    // Check if padded with zeros. Explicitly converting 2 into uint256 for correct calculations.\r\n                    if (uint256(_ids[cell + cellsPerId - 1]) * (uint256(2) ** (lastCellBytesCnt * 8)) > 0) {  // Bitwise left shift, result have to be 0\r\n                        // Identity is not padded with 0s\r\n                        Error(8, _ids);\r\n                        // If at least one Identity already wired. And if this is not a recursive call.\r\n                        if (cell > 0 && _idsForcedLength == 0) {\r\n                            _rewireIdentities(_ids, _newIndex, _oldIndex, cell); // Revert changes made so far\r\n                        }\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Single Identity array\r\n            bytes32[] memory id = new bytes32[](cellsPerId);\r\n\r\n            for (uint8 j = 0; j < cellsPerId; j++) {\r\n                id[j] = _ids[cell++];\r\n            }\r\n\r\n            // Uniqueness check and reference for lookups\r\n            idHash = sha3(id);\r\n\r\n            // If it points to where it's expected.\r\n            if (idToThing[idHash] == _oldIndex) {\r\n                // Wire Identity\r\n                idToThing[idHash] = _newIndex;\r\n            } else {\r\n                // References to a wrong Thing, e.g. Identity already exists, etc.\r\n                Error(1, _ids);\r\n                // If at least one Identity already wired. And if this is not a recursive call.\r\n                if (cell - cellsPerId > 0 && _idsForcedLength == 0) {\r\n                    _rewireIdentities(_ids, _newIndex, _oldIndex, cell - cellsPerId); // Revert changes made so far\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //\r\n    // Public Functions\r\n    //\r\n\r\n\r\n    /**\r\n    * Set the registrar address for the contract, (This function can be called only once).\r\n    * public_function\r\n    * @param _registrarAddress - The Registrar contract address.\r\n    */\r\n    function configure(address _registrarAddress) noEther returns(bool) {\r\n        // Convert into array to properly generate Error event\r\n        bytes32[] memory ref = new bytes32[](1);\r\n        ref[0] = bytes32(registrarAddress);\r\n\r\n        if (msg.sender != deployerAddress) {\r\n            Error(3, ref);\r\n            return false;\r\n        }\r\n\r\n        if (registrarAddress != 0x0) {\r\n            Error(9, ref);\r\n            return false;\r\n        }\r\n\r\n        registrarAddress = _registrarAddress;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Create a new Thing in the Registry, only for registrants.\r\n    * public_function\r\n    * @param _ids - The chunked identities array.\r\n    * @param _data - Thing chunked data array.\r\n    * @param _schemaIndex - Index of the schema to parse Thing's data.\r\n    */\r\n    function createThing(bytes32[] _ids, bytes32[] _data, uint88 _schemaIndex) isRegistrant returns(bool) {\r\n        // No data provided\r\n        if (_data.length == 0) {\r\n            Error(6, _ids);\r\n            return false;\r\n        }\r\n\r\n        if (_schemaIndex >= schemas.length || _schemaIndex == 0) {\r\n            Error(4, _ids);\r\n            return false;\r\n        }\r\n\r\n        // Wiring identities to non-existent Thing.\r\n        // This optimization reduces transaction cost by 100k of gas on avg (or by 3x), in case if _rewireIdentities will fail.\r\n        // Which leads to less damage to the caller, who provided incorrect data.\r\n        if (false == _rewireIdentities(_ids, 0, things.length, 0)) {\r\n            // Incorrect IDs format or duplicate Identities provided.\r\n            return false;\r\n        }\r\n\r\n        // Now after all verifications passed we can add a the Thing.\r\n        things.length++;\r\n        // Creating structure in-place is 11k gas cheaper than assigning parameters separately.\r\n        // That's why methods like updateThingData, addIdentities are not reused here.\r\n        things[things.length - 1] = Thing(_ids, _data, msg.sender, _schemaIndex, true);\r\n\r\n        // \"Broadcast\" event\r\n        Created(_ids, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Create multiple Things at once.\r\n    * Review: user should be aware that if there will be not enough identities transaction will run out of gas.\r\n    * Review: user should be aware that providing too many identities will result in some of them not being used.\r\n    * public_function\r\n    * @param _ids - The Thing's IDs to be added in bytes32 chunks\r\n    * @param _idsPerThing — number of IDs per thing, in relevant order\r\n    * @param _data - The data chunks\r\n    * @param _dataLength - The data length of every Thing to add, in relevant order\r\n    * @param _schemaIndex -Index of the schema to parse Thing's data\r\n    */\r\n    function createThings(bytes32[] _ids, uint16[] _idsPerThing, bytes32[] _data, uint16[] _dataLength, uint88 _schemaIndex) isRegistrant noEther  {\r\n        // Current _id array index\r\n        uint16 idIndex = 0;\r\n        // Current _data array index\r\n        uint16 dataIndex = 0;\r\n        // Counter of total id cells per one thing\r\n        uint24 idCellsPerThing = 0;\r\n        // Length of namespace part of the Identity in URN format\r\n        uint16 urnNamespaceLength;\r\n        // Length of ID part of the Identity, though only uint16 needed but extended to uint24 for correct calculations.\r\n        uint24 idLength;\r\n\r\n        // Each Thing\r\n        for (uint16 i = 0; i < _idsPerThing.length; i++) {\r\n            // Reset for each thing\r\n            idCellsPerThing = 0;\r\n            // Calculate number of cells for current Thing\r\n            for (uint16 j = 0; j < _idsPerThing[i]; j++) {\r\n                urnNamespaceLength = uint8(_ids[idIndex + idCellsPerThing][0]);\r\n                idLength =\r\n                    // First byte\r\n                    uint16(_ids[idIndex + idCellsPerThing + (urnNamespaceLength + 1) / 32][(urnNamespaceLength + 1) % 32]) * 2 ** 8 |\r\n                    // Second byte\r\n                    uint8(_ids[idIndex + idCellsPerThing + (urnNamespaceLength + 2) / 32][(urnNamespaceLength + 2) % 32]);\r\n\r\n                idCellsPerThing += (idLength + urnNamespaceLength + 3) / 32;\r\n                if ((idLength + urnNamespaceLength + 3) % 32 != 0) {\r\n                    idCellsPerThing++;\r\n                }\r\n            }\r\n\r\n            // Extract ids for a single Thing\r\n            bytes32[] memory ids = new bytes32[](idCellsPerThing);\r\n            // Reusing var name to maintain stack size in limits\r\n            for (j = 0; j < idCellsPerThing; j++) {\r\n                ids[j] = _ids[idIndex++];\r\n            }\r\n\r\n            bytes32[] memory data = new bytes32[](_dataLength[i]);\r\n            for (j = 0; j < _dataLength[i]; j++) {\r\n                data[j] = _data[dataIndex++];\r\n            }\r\n\r\n            createThing(ids, data, _schemaIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Add new IDs to the Thing, only registrants allowed.\r\n    * public_function\r\n    * @param _id - ID of the existing Thing\r\n    * @param _newIds - IDs to be added.\r\n    */\r\n    function addIdentities(bytes32[] _id, bytes32[] _newIds) isRegistrant noEther returns(bool) {\r\n        var index = idToThing[sha3(_id)];\r\n\r\n        // There no Thing with such ID\r\n        if (index == 0) {\r\n            Error(2, _id);\r\n            return false;\r\n        }\r\n\r\n        if (_newIds.length == 0) {\r\n            Error(5, _id);\r\n            return false;\r\n        }\r\n\r\n        if (things[index].ownerAddress != 0x0 && things[index].ownerAddress != msg.sender) {\r\n            Error(3, _id);\r\n            return false;\r\n        }\r\n\r\n        if (_addIdentities(index, _newIds)) {\r\n            Updated(_id, things[index].ownerAddress, things[index].isValid);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Update Thing's data.\r\n    * public_function\r\n    * @param _id - The identity array.\r\n    * @param _data - Thing data array.\r\n    * @param _schemaIndex - The schema index of the schema to parse the thing.\r\n    */\r\n    function updateThingData(bytes32[] _id, bytes32[] _data, uint88 _schemaIndex) isRegistrant noEther returns(bool) {\r\n        uint index = idToThing[sha3(_id)];\r\n\r\n        if (index == 0) {\r\n            Error(2, _id);\r\n            return false;\r\n        }\r\n\r\n        if (things[index].ownerAddress != 0x0 && things[index].ownerAddress != msg.sender) {\r\n            Error(3, _id);\r\n            return false;\r\n        }\r\n\r\n        if (_schemaIndex > schemas.length || _schemaIndex == 0) {\r\n            Error(4, _id);\r\n            return false;\r\n        }\r\n\r\n        if (_data.length == 0) {\r\n            Error(6, _id);\r\n            return false;\r\n        }\r\n\r\n        things[index].schemaIndex = _schemaIndex;\r\n        things[index].data = _data;\r\n        Updated(_id, things[index].ownerAddress, things[index].isValid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Set validity of a thing, only registrants allowed.\r\n    * public_function\r\n    * @param _id - The identity to change.\r\n    * @param _isValid - The new validity of the thing.\r\n    */\r\n    function setThingValid(bytes32[] _id, bool _isValid) isRegistrant noEther returns(bool) {\r\n        uint index = idToThing[sha3(_id)];\r\n\r\n        if (index == 0) {\r\n            Error(2, _id);\r\n            return false;\r\n        }\r\n\r\n        if (things[index].ownerAddress != msg.sender) {\r\n            Error(3, _id);\r\n            return false;\r\n        }\r\n\r\n        things[index].isValid = _isValid;\r\n        // Broadcast event\r\n        Updated(_id, things[index].ownerAddress, things[index].isValid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Delete previously added Thing\r\n    * public_function\r\n    * @param _id - One of Thing's Identities.\r\n    */\r\n    function deleteThing(bytes32[] _id) isRegistrant noEther returns(bool) {\r\n        uint index = idToThing[sha3(_id)];\r\n\r\n        if (index == 0) {\r\n            Error(2, _id);\r\n            return false;\r\n        }\r\n\r\n        if (things[index].ownerAddress != msg.sender) {\r\n            Error(3, _id);\r\n            return false;\r\n        }\r\n\r\n        // Rewire Thing's identities to index 0, e.g. delete.\r\n        if (false == _rewireIdentities(things[index].identities, index, 0, 0)) {\r\n            // Cannot rewire, should never happen\r\n            return false;\r\n        }\r\n\r\n        // Put last element in place of deleted one\r\n        if (index != things.length - 1) {\r\n            // Rewire identities of the last Thing to the new prospective index.\r\n            if (false == _rewireIdentities(things[things.length - 1].identities, things.length - 1, index, 0)) {\r\n                // Cannot rewire, should never happen\r\n                _rewireIdentities(things[index].identities, 0, index, 0); // Rollback\r\n                return false;\r\n            }\r\n\r\n            // \"Broadcast\" event with identities before they're lost.\r\n            Deleted(things[index].identities, things[index].ownerAddress);\r\n\r\n            // Move last Thing to the place of deleted one.\r\n            things[index] = things[things.length - 1];\r\n        }\r\n\r\n        // Delete last Thing\r\n        things.length--;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Get length of the schemas array\r\n    * constant_function\r\n    */\r\n    function getSchemasLenght() constant returns(uint) {\r\n        return schemas.length;\r\n    }\r\n\r\n    /**\r\n    * Get Thing's information\r\n    * constant_function\r\n    * @param _id - identity of the thing.\r\n    */\r\n    function getThing(bytes32[] _id) constant returns(bytes32[], bytes32[], uint88, bytes, address, bool) {\r\n        var index = idToThing[sha3(_id)];\r\n        // No such Thing\r\n        if (index == 0) {\r\n            Error(2, _id);\r\n            return;\r\n        }\r\n        Thing thing = things[index];\r\n        return (thing.identities, thing.data, thing.schemaIndex, schemas[thing.schemaIndex], thing.ownerAddress, thing.isValid);\r\n    }\r\n\r\n    /**\r\n    * Check if Thing is present in the registry by it's ID\r\n    * constant_function\r\n    * @param _id - identity for lookup.\r\n    */\r\n\r\n    // Todo: reevaluate this method. Do we need it?\r\n    function thingExist(bytes32[] _id) constant returns(bool) {\r\n        return idToThing[sha3(_id)] > 0;\r\n    }\r\n\r\n    /**\r\n    * Create a new schema. Provided as hex of ProtoBuf-encoded schema data.\r\n    * public_function\r\n    * @param _schema - New schema string to add.\r\n    */\r\n    function createSchema(bytes _schema) isRegistrar noEther returns(uint) {\r\n        uint pos = schemas.length++;\r\n        schemas[pos] = _schema;\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n    * Fallback\r\n    */\r\n    function () noEther {}\r\n\r\n\r\n    /**\r\n    * Desctruct the smart contract. Since this is first, alpha release of Open Registry for IoT, updated versions will follow.\r\n    * Execute this prior to Registrar's contract discontinue()\r\n    */\r\n    function discontinue() isRegistrar noEther returns(bool) {\r\n      selfdestruct(msg.sender);\r\n      return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"registrarAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"bytes32[]\"},{\"name\":\"_data\",\"type\":\"bytes32[]\"},{\"name\":\"_schemaIndex\",\"type\":\"uint88\"}],\"name\":\"createThing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32[]\"}],\"name\":\"thingExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"schemas\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"discontinue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_schema\",\"type\":\"bytes\"}],\"name\":\"createSchema\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"idToThing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32[]\"},{\"name\":\"_newIds\",\"type\":\"bytes32[]\"}],\"name\":\"addIdentities\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registrarAddress\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"bytes32[]\"},{\"name\":\"_idsPerThing\",\"type\":\"uint16[]\"},{\"name\":\"_data\",\"type\":\"bytes32[]\"},{\"name\":\"_dataLength\",\"type\":\"uint16[]\"},{\"name\":\"_schemaIndex\",\"type\":\"uint88\"}],\"name\":\"createThings\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32[]\"},{\"name\":\"_isValid\",\"type\":\"bool\"}],\"name\":\"setThingValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32[]\"},{\"name\":\"_data\",\"type\":\"bytes32[]\"},{\"name\":\"_schemaIndex\",\"type\":\"uint88\"}],\"name\":\"updateThingData\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32[]\"}],\"name\":\"deleteThing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSchemasLenght\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32[]\"}],\"name\":\"getThing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"uint88\"},{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"things\",\"outputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"},{\"name\":\"schemaIndex\",\"type\":\"uint88\"},{\"name\":\"isValid\",\"type\":\"bool\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isValid\",\"type\":\"bool\"}],\"name\":\"Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Deleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reference\",\"type\":\"bytes32[]\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"Registry","CompilerVersion":"v0.3.5-2016-07-21-6610add","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}