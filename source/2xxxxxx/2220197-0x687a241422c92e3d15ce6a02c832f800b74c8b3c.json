{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.3.5;\r\n\r\ncontract DepositHolder {\r\n    uint constant GUARANTEE_PERIOD = 365 days;\r\n    \r\n    event Claim(address addr, uint amount);\r\n    \r\n    struct Entry {\r\n        bytes16 next;\r\n        uint64 deposit;\r\n        uint64 expires;\r\n    }\r\n\r\n    address owner;\r\n    address auditor;\r\n    \r\n    mapping(bytes16=>Entry) entries;\r\n    bytes16 oldestHash;\r\n    bytes16 newestHash;\r\n    \r\n    uint public paidOut;\r\n    uint public totalPaidOut;\r\n    uint public depositCount;\r\n    \r\n    function DepositHolder() {\r\n        owner = msg.sender;\r\n        auditor = owner;\r\n    }\r\n    \r\n    modifier owner_only {\r\n        if(msg.sender != owner) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier auditor_only {\r\n        if(msg.sender != auditor) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Lodge deposits for a set of address hashes. Automatically uses\r\n     *      expired deposits to pay for new ones.\r\n     * @param values A list of hashes of addresses to place deposits for.\r\n     *        Each value is the first 16 bytes of the keccak-256 hash of the\r\n     *        address the deposit is for.\r\n     * @param deposit The amount of the deposit on each address.\r\n     */\r\n    function deposit(bytes16[] values, uint64 deposit) owner_only {\r\n        uint required = values.length * deposit;\r\n        if(msg.value < required) {\r\n            throw;\r\n        } else if(msg.value > required) {\r\n            if(!msg.sender.send(msg.value - required))\r\n                throw;\r\n        }\r\n\r\n        extend(values, uint64(deposit));\r\n    }\r\n\r\n    function extend(bytes16[] values, uint64 deposit) private {\r\n        uint64 expires = uint64(now + GUARANTEE_PERIOD);\r\n\r\n        if(oldestHash == 0) {\r\n            oldestHash = values[0];\r\n            newestHash = values[0];\r\n        } else {\r\n            entries[newestHash].next = values[0];\r\n        }\r\n        \r\n        for(uint i = 0; i < values.length - 1; i++) {\r\n            if(entries[values[i]].expires != 0)\r\n                throw;\r\n            entries[values[i]] = Entry(values[i + 1], deposit, expires);\r\n        }\r\n        \r\n        newestHash = values[values.length - 1];\r\n        if(entries[newestHash].expires != 0)\r\n            throw;\r\n        entries[newestHash] = Entry(0, deposit, expires);\r\n        \r\n        depositCount += values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw funds held for expired deposits.\r\n     * @param max Maximum number of deposits to claim.\r\n     */\r\n    function withdraw(uint max) owner_only {\r\n        uint recovered = recover(max);\r\n        if(!msg.sender.send(recovered))\r\n            throw;\r\n    }\r\n\r\n    function recover(uint max) private returns(uint recovered) {\r\n        // Iterate through entries deleting them, until we find one\r\n        // that's new enough, or hit the limit.\r\n        bytes16 ptr = oldestHash;\r\n        uint count;\r\n        for(uint i = 0; i < max && ptr != 0 && entries[ptr].expires < now; i++) {\r\n            recovered += entries[ptr].deposit;\r\n            ptr = entries[ptr].next;\r\n            count += 1;\r\n        }\r\n\r\n        oldestHash = ptr;\r\n        if(oldestHash == 0)\r\n            newestHash = 0;\r\n        \r\n        // Deduct any outstanding payouts from the recovered funds\r\n        if(paidOut > 0) {\r\n            if(recovered > paidOut) {\r\n                recovered -= paidOut;\r\n                paidOut = 0;\r\n            } else {\r\n                paidOut -= recovered;\r\n                recovered = 0;\r\n            }\r\n        }\r\n        \r\n        depositCount -= count;\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches information on a future withdrawal event\r\n     * @param hash The point at which to start scanning; 0 for the first event.\r\n     * @return when Unix timestamp at which a withdrawal can next happen.\r\n     * @return count Number of addresses expiring at this time\r\n     * @return value Total amount withdrawable at this time\r\n     * @return next Hash of the start of the next withdrawal event, if any.\r\n     */\r\n    function nextWithdrawal(bytes16 hash) constant returns(uint when, uint count, uint value, bytes16 next) {\r\n        if(hash == 0) {\r\n            hash = oldestHash;\r\n        }\r\n        next = hash;\r\n        when = entries[hash].expires;\r\n        while(next != 0 && entries[next].expires == when) {\r\n            count += 1;\r\n            value += entries[next].deposit;\r\n            next = entries[next].next;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a deposit is held for the provided address.\r\n     * @param addr The address to check.\r\n     * @return expires The unix timestamp at which the deposit on this address\r\n     *         expires, or 0 if there is no deposit.\r\n     * @return deposit The amount deposited against this address.\r\n     */\r\n    function check(address addr) constant returns (uint expires, uint deposit) {\r\n        Entry storage entry = entries[bytes16(sha3(addr))];\r\n        expires = entry.expires;\r\n        deposit = entry.deposit;\r\n    }\r\n    \r\n    /**\r\n     * @dev Pays out a claim.\r\n     * @param addr The address to pay.\r\n     * @param amount The amount to send.\r\n     */\r\n    function disburse(address addr, uint amount) auditor_only {\r\n        paidOut += amount;\r\n        totalPaidOut += amount;\r\n        Claim(addr, amount);\r\n        if(!addr.send(amount))\r\n            throw;\r\n    }\r\n    \r\n    /**\r\n     * @dev Deletes the contract, if no deposits are held.\r\n     */\r\n    function destroy() owner_only {\r\n        if(depositCount > 0)\r\n            throw;\r\n        selfdestruct(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPaidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"disburse\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes16\"}],\"name\":\"nextWithdrawal\",\"outputs\":[{\"name\":\"when\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"next\",\"type\":\"bytes16\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"check\",\"outputs\":[{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"values\",\"type\":\"bytes16[]\"},{\"name\":\"deposit\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"}]","ContractName":"DepositHolder","CompilerVersion":"v0.3.6-2016-09-06-114502f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}