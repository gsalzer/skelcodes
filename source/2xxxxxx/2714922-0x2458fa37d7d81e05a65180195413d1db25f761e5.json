{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\ncontract SpiceMembers {\r\n    enum MemberLevel { None, Member, Manager, Director }\r\n    struct Member {\r\n        uint id;\r\n        MemberLevel level;\r\n        bytes32 info;\r\n    }\r\n\r\n    mapping (address => Member) member;\r\n\r\n    address public owner;\r\n    mapping (uint => address) public memberAddress;\r\n    uint public memberCount;\r\n\r\n    event TransferOwnership(address indexed sender, address indexed owner);\r\n    event AddMember(address indexed sender, address indexed member);\r\n    event RemoveMember(address indexed sender, address indexed member);\r\n    event SetMemberLevel(address indexed sender, address indexed member, MemberLevel level);\r\n    event SetMemberInfo(address indexed sender, address indexed member, bytes32 info);\r\n\r\n    function SpiceMembers() {\r\n        owner = msg.sender;\r\n\r\n        memberCount = 1;\r\n        memberAddress[memberCount] = owner;\r\n        member[owner] = Member(memberCount, MemberLevel.None, 0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        if (msg.sender != owner && memberLevel(msg.sender) < MemberLevel.Manager) throw;\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address _target) onlyOwner {\r\n        // If new owner has no memberId, create one\r\n        if (member[_target].id == 0) {\r\n            memberCount++;\r\n            memberAddress[memberCount] = _target;\r\n            member[_target] = Member(memberCount, MemberLevel.None, 0);\r\n        }\r\n        owner = _target;\r\n        TransferOwnership(msg.sender, owner);\r\n    }\r\n\r\n    function addMember(address _target) onlyManager {\r\n        // Make sure trying to add an existing member throws an error\r\n        if (memberLevel(_target) != MemberLevel.None) throw;\r\n\r\n        // If added member has no memberId, create one\r\n        if (member[_target].id == 0) {\r\n            memberCount++;\r\n            memberAddress[memberCount] = _target;\r\n            member[_target] = Member(memberCount, MemberLevel.None, 0);\r\n        }\r\n\r\n        // Set memberLevel to initial value with basic access\r\n        member[_target].level = MemberLevel.Member;\r\n        AddMember(msg.sender, _target);\r\n    }\r\n\r\n    function removeMember(address _target) {\r\n        // Make sure trying to remove a non-existing member throws an error\r\n        if (memberLevel(_target) == MemberLevel.None) throw;\r\n        // Make sure members are only allowed to delete members lower than their level\r\n        if (msg.sender != owner && memberLevel(msg.sender) <= memberLevel(_target)) throw;\r\n\r\n        member[_target].level = MemberLevel.None;\r\n        RemoveMember(msg.sender, _target);\r\n    }\r\n\r\n    function setMemberLevel(address _target, MemberLevel level) {\r\n        // Make sure all levels are larger than None but not higher than Director\r\n        if (level == MemberLevel.None || level > MemberLevel.Director) throw;\r\n        // Make sure the _target is currently already a member\r\n        if (memberLevel(_target) == MemberLevel.None) throw;\r\n        // Make sure the new level is lower level than we are (we cannot overpromote)\r\n        if (msg.sender != owner && memberLevel(msg.sender) <= level) throw;\r\n        // Make sure the member is currently on lower level than we are\r\n        if (msg.sender != owner && memberLevel(msg.sender) <= memberLevel(_target)) throw;\r\n\r\n        member[_target].level = level;\r\n        SetMemberLevel(msg.sender, _target, level);\r\n    }\r\n\r\n    function setMemberInfo(address _target, bytes32 info) {\r\n        // Make sure the target is currently already a member\r\n        if (memberLevel(_target) == MemberLevel.None) throw;\r\n        // Make sure the member is currently on lower level than we are\r\n        if (msg.sender != owner && msg.sender != _target && memberLevel(msg.sender) <= memberLevel(_target)) throw;\r\n\r\n        member[_target].info = info;\r\n        SetMemberInfo(msg.sender, _target, info);\r\n    }\r\n\r\n    function memberId(address _target) constant returns (uint) {\r\n        return member[_target].id;\r\n    }\r\n\r\n    function memberLevel(address _target) constant returns (MemberLevel) {\r\n        return member[_target].level;\r\n    }\r\n\r\n    function memberInfo(address _target) constant returns (bytes32) {\r\n        return member[_target].info;\r\n    }\r\n}\r\n\r\ncontract SpiceControlled {\r\n    SpiceMembers members;\r\n\r\n    modifier onlyOwner {\r\n        if (!hasOwnerAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyDirector {\r\n        if (!hasDirectorAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        if (!hasManagerAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMember {\r\n        if (!hasMemberAccess(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    function SpiceControlled(address membersAddress) {\r\n        members = SpiceMembers(membersAddress);\r\n    }\r\n\r\n    function hasOwnerAccess(address _target) internal returns (bool) {\r\n        return (_target == members.owner());\r\n    }\r\n\r\n    function hasDirectorAccess(address _target) internal returns (bool) {\r\n        return (members.memberLevel(_target) >= SpiceMembers.MemberLevel.Director || hasOwnerAccess(_target));\r\n    }\r\n\r\n    function hasManagerAccess(address _target) internal returns (bool) {\r\n        return (members.memberLevel(_target) >= SpiceMembers.MemberLevel.Manager || hasOwnerAccess(_target));\r\n    }\r\n    \r\n    function hasMemberAccess(address _target) internal returns (bool) {\r\n        return (members.memberLevel(_target) >= SpiceMembers.MemberLevel.Member || hasOwnerAccess(_target));\r\n    }\r\n}\r\n\r\ncontract IPayoutCalculator {\r\n    function calculatePayout(bytes32 _info, uint _duration) returns (uint);\r\n}\r\n\r\ncontract SpicePayroll is SpiceControlled {\r\n    struct PayrollEntry {\r\n        bool available;\r\n        uint duration;\r\n        bool processed;\r\n        uint payout;\r\n    }\r\n\r\n    address creator;\r\n\r\n    uint public fromBlock;\r\n    uint public toBlock;\r\n\r\n    mapping (bytes32 => PayrollEntry) entries;\r\n    bytes32[] infos;\r\n\r\n    address calculator;\r\n    bool public locked;\r\n\r\n    event NewPayroll(address indexed creator);\r\n    event FailedMarking(bytes32 indexed info, bytes32 indexed description, uint total, int duration);\r\n    event AddMarking(bytes32 indexed info, bytes32 indexed description, int duration, uint total);\r\n    event ProcessMarkings(bytes32 indexed info, uint total, uint duration, uint payout);\r\n    event AllMarkingsProcessed(address indexed calculator, uint maxDuration, uint fromBlock, uint toBlock);\r\n\r\n    event ModifyMarking(bytes32 indexed info, uint duration, uint payout);\r\n    event SetPayrollLocked(bool locked);\r\n\r\n    modifier onlyCreator {\r\n        if (msg.sender != creator) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnprocessed {\r\n        if (calculator != 0) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier onlyProcessed {\r\n        if (calculator == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnlocked {\r\n        if (locked) throw;\r\n        _;\r\n    }\r\n\r\n    function SpicePayroll(address _members) SpiceControlled(_members) {\r\n        creator = msg.sender;\r\n        fromBlock = block.number;\r\n        NewPayroll(msg.sender);\r\n    }\r\n\r\n    function addMarking(bytes32 _info, bytes32 _description, int _duration) onlyCreator onlyUnprocessed returns(bool) {\r\n        // Check if the duration would become negative as a result of this marking\r\n        // and if it does, mark this as failed and return false to indicate failure.\r\n        if (_duration < 0 && entries[_info].duration < uint(-_duration)) {\r\n          FailedMarking(_info, _description, entries[_info].duration, _duration);\r\n          return false;\r\n        }\r\n\r\n        // If info not added yet, add it to the infos array\r\n        PayrollEntry entry = entries[_info];\r\n        if (!entry.available) {\r\n            entry.available = true;\r\n            infos.push(_info);\r\n        }\r\n\r\n        // Modify entry duration and send marking event\r\n        if (_duration < 0) {\r\n            entry.duration -= uint(-_duration);\r\n        } else {\r\n            entry.duration += uint(_duration);\r\n        }\r\n        AddMarking(_info, _description, _duration, entry.duration);\r\n        return true;\r\n    }\r\n\r\n    function processMarkings(address _calculator, uint _maxDuration) onlyCreator onlyUnprocessed {\r\n        calculator = _calculator;\r\n        for (uint i = 0; i < infos.length; i++) {\r\n            bytes32 info = infos[i];\r\n            PayrollEntry entry = entries[info];\r\n\r\n            uint originalDuration = entry.duration;\r\n            entry.duration = (originalDuration <= _maxDuration) ? originalDuration : _maxDuration;\r\n            entry.payout = IPayoutCalculator(calculator).calculatePayout(info, entry.duration);\r\n            ProcessMarkings(info, originalDuration, entry.duration, entry.payout);\r\n        }\r\n        toBlock = block.number;\r\n        AllMarkingsProcessed(_calculator, _maxDuration, fromBlock, toBlock);\r\n    }\r\n\r\n    function modifyMarking(bytes32 _info, uint _duration) onlyDirector onlyProcessed onlyUnlocked {\r\n        if (!entries[_info].available) throw;\r\n\r\n        PayrollEntry entry = entries[_info];\r\n        entry.duration = _duration;\r\n        entry.payout = IPayoutCalculator(calculator).calculatePayout(_info, _duration);\r\n        ModifyMarking(_info, entry.duration, entry.payout);\r\n    }\r\n\r\n    function lock() onlyDirector {\r\n        locked = true;\r\n        SetPayrollLocked(locked);\r\n    }\r\n\r\n    function unlock() onlyOwner {\r\n        locked = false;\r\n        SetPayrollLocked(locked);\r\n    }\r\n\r\n    function processed() constant returns (bool) {\r\n        return (calculator != 0);\r\n    }\r\n\r\n    function duration(bytes32 _info) constant returns (uint) {\r\n        return entries[_info].duration;\r\n    }\r\n\r\n    function payout(bytes32 _info) constant returns (uint) {\r\n        return entries[_info].payout;\r\n    }\r\n\r\n    function entryInfo(uint _index) constant returns (bytes32) {\r\n        return infos[_index];\r\n    }\r\n\r\n    function entryCount() constant returns (uint) {\r\n        return infos.length;\r\n    }\r\n}\r\n\r\ncontract SpiceHours is SpiceControlled {\r\n    address[] public payrolls;\r\n\r\n    event MarkHours(bytes32 indexed info, bytes32 indexed description, int duration, bool success);\r\n    event ProcessPayroll(address indexed payroll, uint maxDuration);\r\n    event CreatePayroll(address indexed payroll);\r\n\r\n    function SpiceHours(address _members) SpiceControlled(_members) {\r\n        payrolls[payrolls.length++] = new SpicePayroll(members);\r\n        CreatePayroll(payrolls[payrolls.length-1]);\r\n    }\r\n\r\n    function markHours(bytes32 _info, bytes32 _description, int _duration) onlyMember {\r\n        if (!hasManagerAccess(msg.sender) && members.memberInfo(msg.sender) != _info) throw;\r\n        if (_duration == 0) throw;\r\n        if (_info == 0) throw;\r\n\r\n        SpicePayroll payroll = SpicePayroll(payrolls[payrolls.length-1]);\r\n        bool success = payroll.addMarking(_info, _description, _duration);\r\n        MarkHours(_info, _description, _duration, success);\r\n    }\r\n\r\n    function markHours(bytes32 _description, int _duration) {\r\n        markHours(members.memberInfo(msg.sender), _description, _duration);\r\n    }\r\n\r\n    function processPayroll(address _calculator, uint _maxDuration) onlyDirector {\r\n        SpicePayroll payroll = SpicePayroll(payrolls[payrolls.length-1]);\r\n        payroll.processMarkings(_calculator, _maxDuration);\r\n        ProcessPayroll(payroll, _maxDuration);\r\n\r\n        payrolls[payrolls.length++] = new SpicePayroll(members);\r\n        CreatePayroll(payrolls[payrolls.length-1]);\r\n    }\r\n\r\n    function hasPayroll(address _address) constant returns (bool) {\r\n        for (uint i; i < payrolls.length; i++) {\r\n            if (payrolls[i] == _address) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function payrollCount() constant returns (uint) {\r\n        return payrolls.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"payrollCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_info\",\"type\":\"bytes32\"},{\"name\":\"_description\",\"type\":\"bytes32\"},{\"name\":\"_duration\",\"type\":\"int256\"}],\"name\":\"markHours\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payrolls\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasPayroll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_description\",\"type\":\"bytes32\"},{\"name\":\"_duration\",\"type\":\"int256\"}],\"name\":\"markHours\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_calculator\",\"type\":\"address\"},{\"name\":\"_maxDuration\",\"type\":\"uint256\"}],\"name\":\"processPayroll\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_members\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"info\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"description\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"MarkHours\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payroll\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"maxDuration\",\"type\":\"uint256\"}],\"name\":\"ProcessPayroll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payroll\",\"type\":\"address\"}],\"name\":\"CreatePayroll\",\"type\":\"event\"}]","ContractName":"SpiceHours","CompilerVersion":"v0.4.4+commit.4633f3de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004ed985e2da341e276bbf7782f2e1e30689d33c89","Library":"","SwarmSource":""}]}