{"status":"1","message":"OK","result":[{"SourceCode":"library TokenLib {\r\n    struct Token {\r\n        string identity;\r\n        address owner;\r\n    }\r\n\r\n    function id(Token storage self) returns (bytes32) {\r\n        return sha3(self.identity);\r\n    }\r\n\r\n    function generateId(string identity) returns (bytes32) {\r\n        return sha3(identity);\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, bytes32 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, bytes32 _value);\r\n\r\n    function logApproval(address _owner, address _spender, bytes32 _value) {\r\n        Approval(_owner, _spender, _value);\r\n    }\r\n\r\n    function logTransfer(address _from, address _to, bytes32 _value) {\r\n        Transfer(_from, _to, _value);\r\n    }\r\n}\r\n\r\ncontract TokenInterface {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Mint(address indexed _to, bytes32 _id);\r\n    event Destroy(bytes32 _id);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event MinterAdded(address who);\r\n    event MinterRemoved(address who);\r\n\r\n    /*\r\n     *  Minting\r\n     */\r\n    /// @dev Mints a new token.\r\n    /// @param _to Address of token owner.\r\n    /// @param _identity String for owner identity.\r\n    function mint(address _to, string _identity) returns (bool success);\r\n\r\n    /// @dev Destroy a token\r\n    /// @param _id Bytes32 id of the token to destroy.\r\n    function destroy(bytes32 _id) returns (bool success);\r\n\r\n    /// @dev Add a new minter\r\n    /// @param who Address the address that can now mint tokens.\r\n    function addMinter(address who) returns (bool);\r\n\r\n    /// @dev Remove a minter\r\n    /// @param who Address the address that will no longer be a minter.\r\n    function removeMinter(address who) returns (bool);\r\n\r\n    /*\r\n     *  Read and write storage functions\r\n     */\r\n\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() returns (uint supply);\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transfer(address _to, bytes32 _value) returns (bool success);\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, bytes32 _value) returns (bool success);\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function approve(address _spender, bytes32 _value) returns (bool success);\r\n\r\n    /*\r\n     * Read storage functions\r\n     */\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool);\r\n\r\n    /// @dev Returns the identity of the given token id.\r\n    /// @param _id Bytes32 id of token to lookup.\r\n    function identityOf(bytes32 _id) constant returns (string identity);\r\n\r\n    /// @dev Returns the address of the owner of the given token id.\r\n    /// @param _id Bytes32 id of token to lookup.\r\n    function ownerOf(bytes32 _id) constant returns (address owner);\r\n}\r\n\r\ncontract Devcon2Token is TokenInterface {\r\n    using TokenLib for TokenLib.Token;\r\n\r\n    /*\r\n     *  +----------------+\r\n     *  | Administrative |\r\n     *  +----------------+\r\n     */\r\n    mapping (address => bool) public minters;\r\n    uint constant _END_MINTING = 1474502400;  // UTC (2016/09/22 - 00:00:00)\r\n\r\n    function END_MINTING() constant returns (uint) {\r\n        return _END_MINTING;\r\n    }\r\n\r\n    function Devcon2Token() {\r\n        minters[msg.sender] = true;\r\n        MinterAdded(msg.sender);\r\n    }\r\n\r\n    /*\r\n     *  +------------+\r\n     *  | Token Data |\r\n     *  +------------+\r\n     */\r\n    uint numTokens;\r\n\r\n    // id => Token\r\n    mapping (bytes32 => TokenLib.Token) tokens;\r\n\r\n    // owner => ownedToken.id\r\n    mapping (address => bytes32) public ownedToken;\r\n\r\n    // owner => spender => ownedToken.id\r\n    mapping (address => mapping (address => bytes32)) approvals;\r\n\r\n    /*\r\n     *  Read and write storage functions\r\n     */\r\n    /// @dev Mints a new token\r\n    /// @param _to Address of token owner.\r\n    /// @param _identity String for owner identity.\r\n    function mint(address _to, string _identity) returns (bool success) {\r\n        // only mintable till end of conference\r\n        if (now >= _END_MINTING) throw;\r\n\r\n        // ensure the msg.sender is allowed to mint.\r\n        if (!minters[msg.sender]) return false;\r\n\r\n        // ensure that the token owner doesn't already own a token.\r\n        if (ownedToken[_to] != 0x0) return false;\r\n\r\n        // generate the token id and get the token.\r\n        bytes32 id = TokenLib.generateId(_identity);\r\n        var token = tokens[id];\r\n\r\n        // don't allow re-minting of a given identity.\r\n        if (id == token.id()) return false;\r\n\r\n        // set the token data\r\n        token.owner = _to;\r\n        token.identity = _identity;\r\n        ownedToken[_to] = id;\r\n\r\n        // log the minting of this token.\r\n        Mint(_to, id);\r\n\r\n        // increase the supply.\r\n        numTokens += 1;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Destroy a token\r\n    /// @param _id Bytes32 id of the token to be destroyed\r\n    function destroy(bytes32 _id) returns (bool success) {\r\n        // only mintable till end of conference\r\n        if (now >= _END_MINTING) throw;\r\n\r\n        // ensure the msg.sender is allowed to mint.\r\n        if (!minters[msg.sender]) return false;\r\n\r\n        // pull the token to destroy\r\n        var tokenToDestroy = tokens[_id];\r\n\r\n        // Remove any ownership data\r\n        ownedToken[tokenToDestroy.owner] = 0x0;\r\n\r\n        // Zero out the actual token data\r\n        tokenToDestroy.identity = '';\r\n        tokenToDestroy.owner = 0x0;\r\n\r\n        // Log the destruction\r\n        Destroy(_id);\r\n\r\n        // decrease the supply.\r\n        numTokens -= 1;\r\n        \r\n        return true;\r\n    }\r\n\r\n    /// @dev Add a new minter\r\n    /// @param who Address the address that can now mint tokens.\r\n    function addMinter(address who) returns (bool) {\r\n        // only mintable till end of conference\r\n        if (now >= _END_MINTING) throw;\r\n\r\n        // ensure the msg.sender is allowed\r\n        if (!minters[msg.sender]) return false;\r\n\r\n        minters[who] = true;\r\n\r\n        // Log it\r\n        MinterAdded(who);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Remove a minter\r\n    /// @param who Address the address that will no longer be a minter.\r\n    function removeMinter(address who) returns (bool) {\r\n        // ensure the msg.sender is allowed\r\n        if (!minters[msg.sender]) return false;\r\n\r\n        minters[who] = false;\r\n\r\n        // Log it\r\n        MinterRemoved(who);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        return transfer(_to, bytes32(_value));\r\n    }\r\n\r\n    function transfer(address _to, bytes32 _value) returns (bool success) {\r\n        // dont allow the null token.\r\n        if (_value == 0x0) return false;\r\n\r\n        // ensure it is actually a token\r\n        if (tokens[_value].id() != _value) return false;\r\n\r\n        // ensure that the new owner doesn't already own a token.\r\n        if (ownedToken[_to] != 0x0) return false;\r\n\r\n        // get the token\r\n        var tokenToTransfer = tokens[_value];\r\n\r\n        // ensure msg.sender is the token owner.\r\n        if (tokenToTransfer.owner != msg.sender) return false;\r\n\r\n        // set the new owner.\r\n        tokenToTransfer.owner = _to;\r\n        ownedToken[msg.sender] = 0x0;\r\n        ownedToken[_to] = _value;\r\n\r\n        // log the transfer\r\n        //Transfer(msg.sender, _to, uint(_value));\r\n        TokenLib.logTransfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        return transferFrom(_from, _to, bytes32(_value));\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, bytes32 _value) returns (bool success) {\r\n        // dont allow the null token.\r\n        if (_value == 0x0) return false;\r\n\r\n        // ensure it is actually a token\r\n        if (tokens[_value].id() != _value) return false;\r\n\r\n        // ensure that the new owner doesn't already own a token.\r\n        if (ownedToken[_to] != 0x0) return false;\r\n\r\n        // get the token\r\n        var tokenToTransfer = tokens[_value];\r\n\r\n        // ensure that _from actually owns this token.\r\n        if (tokenToTransfer.owner != _from) return false;\r\n        if (ownedToken[_from] != _value) return false;\r\n\r\n        // ensure that they are approved to transfer this token.\r\n        if (approvals[_from][msg.sender] != _value) return false;\r\n\r\n        // do the transfer\r\n        tokenToTransfer.owner = _to;\r\n        ownedToken[_from] = 0x0;\r\n        ownedToken[_to] = _value;\r\n        approvals[_from][msg.sender] = 0x0;\r\n\r\n        // log the transfer\r\n        Transfer(_from, _to, uint(_value));\r\n        TokenLib.logTransfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        return approve(_spender, bytes32(_value));\r\n    }\r\n\r\n    function approve(address _spender, bytes32 _value) returns (bool success) {\r\n        // dont allow the null token.\r\n        if (_value == 0x0) return false;\r\n\r\n        // ensure it is actually a token\r\n        if (tokens[_value].id() != _value) return false;\r\n\r\n        // get the token that is being approved.\r\n        var tokenToApprove = tokens[_value];\r\n\r\n        // ensure they own this token.\r\n        if (tokenToApprove.owner != msg.sender) return false;\r\n        if (ownedToken[msg.sender] != _value) return false;\r\n\r\n        // set the approval\r\n        approvals[msg.sender][_spender] = _value;\r\n\r\n        // Log the approval\r\n        Approval(msg.sender, _spender, uint(_value));\r\n        TokenLib.logApproval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Read storage functions\r\n     */\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() returns (uint supply) {\r\n        return numTokens;\r\n    }\r\n\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return uint(ownedToken[_owner]);\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return uint(approvals[_owner][_spender]);\r\n    }\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool) {\r\n        return (ownedToken[_owner] != 0x0 && tokens[ownedToken[_owner]].owner == _owner);\r\n    }\r\n\r\n    /// @dev Returns the identity of the given token id.\r\n    /// @param _id Bytes32 id of token to lookup.\r\n    function identityOf(bytes32 _id) constant returns (string identity) {\r\n        return tokens[_id].identity;\r\n    }\r\n\r\n    /// @dev Returns the address of the owner of the given token id.\r\n    /// @param _id Bytes32 id of token to lookup.\r\n    function ownerOf(bytes32 _id) constant returns (address owner) {\r\n        return tokens[_id].owner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_MINTING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"identityOf\",\"outputs\":[{\"name\":\"identity\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"destroy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_identity\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"}]","ContractName":"Devcon2Token","CompilerVersion":"v0.3.6+commit.3fc68da","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}