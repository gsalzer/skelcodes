{"status":"1","message":"OK","result":[{"SourceCode":"/* Copyright (C) Etherplay <contact@etherplay.io> - All Rights Reserved */\r\npragma solidity 0.4.4;\r\n\r\ncontract CompetitionStore {\r\n\t\r\n/////////////////////////////////////////////////////////////////// DATA /////////////////////////////////////////////////////////////\r\n\t\r\n\t//player's submission store the info required to verify its accuracy\r\n\tstruct Submission{\r\n\t\tuint32 score; \r\n\t\tuint32 durationRoundedDown; // duration in second of the game session\r\n\t\tuint32 version; // version of the game used\r\n\t\tuint64 seed; //seed used\r\n\t\tuint64 submitBlockNumber; // blockNumber at which the submission is processed\r\n\t\tbytes32 proofHash;//sha256 of proof : to save gas, the proof is not saved directly in the contract. Instead its hash is saved. The actual proof will be saved on a server. The player could potentially save it too. \r\n\t}\r\n\t\r\n\t//player start game parameter\r\n\tstruct Start{\r\n\t\tuint8 competitionIndex; //competition index (0 or 1) there is only 2 current competition per game, one is active, the other one being the older one which might have pending verification\r\n\t\tuint32 version;  //version of the game that the player score is based on\r\n\t\tuint64 seed; // the seed used for the game session\r\n\t\tuint64 time; // start time , used to check if the player is not taking too long to submit its score\r\n\t}\r\n\t\r\n\t// the values representing each competition\r\n\tstruct Competition{\r\n\t\tuint8 numPastBlocks;// number of past block allowed, 1 is the minimum since you can only get the hash of a past block. Allow player to start play instantunously\r\n\t\tuint8 houseDivider; // how much the house takes : 4 means house take 1/4 (25%)\r\n\t\tuint16 lag; // define how much extra time is allowed to submit a score (to accomodate block time and delays)\r\n\t\tuint32 verificationWaitTime;// wait time allowed for submission past competition's end time \r\n\t\tuint32 numPlayers;//current number of player that submited a score\r\n\t\tuint32 version; //the version of the game used for that competition, a hash of the code is published in the log upon changing\r\n\t\tuint32 previousVersion; // previousVersion to allow smooth update upon version change\r\n\t\tuint64 versionChangeBlockNumber; \r\n\t\tuint64 switchBlockNumber; // the blockNumber at which the competition started\r\n\t\tuint64 endTime;//The time at which the competition is set to finish. No start can happen after that and the competition cannot be aborted before that\r\n\t\tuint88 price;  // the price for that competition, do not change \r\n\t\tuint128 jackpot; // the current jackpot for that competition, this jackpot is then shared among the developer (in the deposit account for  funding development) and the winners (see houseDivider))\r\n\t\tuint32[] rewardsDistribution; // the length of it define how many winners there is and the distribution of the reward is the value for each index divided by the total\r\n\t\tmapping (address => Submission) submissions;  //only one submission per player per competition\r\n\t\taddress[] players; // contain the list of players that submited a score for that competition\r\n\t}\r\n\t\t\r\n\tstruct Game{\r\n\t\tmapping (address => Start) starts; // only 1 start per player, further override the current\r\n\t\tCompetition[2] competitions; // 2 competitions only to save gas, overrite each other upon going to next competition\r\n\t\tuint8 currentCompetitionIndex; //can only be 1 or 0 (switch operation : 1 - currentCompetitionIndex)\r\n\t}\r\n\r\n\tmapping (string => Game) games;\r\n\t\r\n\taddress organiser; // admin having control of the reward \r\n\taddress depositAccount;\t // is the receiver of the house part of the jackpot (see houseDivider) Can only be changed by the depositAccount.\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////// EVENTS /////////////////////////////////////////////////////////////\r\n\r\n\t//event logging the hash of the game code for a particular version\r\n\tevent VersionChange(\r\n\t\tstring indexed gameID,\r\n\t\tuint32 indexed version,\r\n\t\tbytes32 codeHash // the sha256 of the game code as used by the player\r\n\t);\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////// PLAYERS ACTIONS /////////////////////////////////////////////////////////////\r\n\t\r\n\t/*\r\n\tThe seed is computed from the block hash and the sender address\r\n\tWhile the seed can be predicted for few block away (see : numPastBlocks) this is has no much relevance since a game session have a bigger duration,\r\n\tRemember this is not gambling game, this is a skill game, seed is only a small part of the game outcome\r\n\t*/\r\n\tfunction computeSeed(uint64 blockNumber, address player) internal constant returns(uint64 seed){ \r\n\t\treturn uint64(sha3(block.blockhash(blockNumber),block.blockhash(blockNumber-1),block.blockhash(blockNumber-2),block.blockhash(blockNumber-3),block.blockhash(blockNumber-4),block.blockhash(blockNumber-5),player)); \r\n\t}\r\n\t\r\n\t/*\r\n\t\tprobe the current state of the competition so player can start playing right away (need to commit a tx too to ensure its play will be considered though)\r\n\t*/\r\n\tfunction getSeedAndState(string gameID, address player) constant returns(uint64 seed, uint64 blockNumber, uint8 competitionIndex, uint32 version, uint64 endTime, uint88 price, uint32 myBestScore, uint64 competitionBlockNumber, uint64 registeredSeed){\r\n\t\tvar game = games[gameID];\r\n\r\n\t\tcompetitionIndex = game.currentCompetitionIndex;\r\n\t\tvar competition = game.competitions[competitionIndex];\r\n\r\n\t\tblockNumber = uint64(block.number-1);\r\n\t\tseed = computeSeed(blockNumber, player);\r\n\t\tversion = competition.version;\r\n\t\tendTime = competition.endTime;\r\n\t\tprice = competition.price;\r\n\t\tcompetitionBlockNumber = competition.switchBlockNumber;\r\n\t\t\r\n\t\tif (competition.submissions[player].submitBlockNumber >= competition.switchBlockNumber){\r\n\t\t\tmyBestScore = competition.submissions[player].score;\r\n\t\t}else{\r\n\t\t\tmyBestScore = 0;\r\n\t\t}\r\n\t\t\r\n\t\tregisteredSeed = game.starts[player].seed;\r\n\t}\r\n\t\r\n\t\r\n\t\t\r\n\tfunction start(string gameID, uint64 blockNumber,uint8 competitionIndex, uint32 version) payable {\r\n\t\tvar game = games[gameID];\r\n\t\tvar competition = game.competitions[competitionIndex];\r\n\r\n\t\tif(msg.value != competition.price){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tcompetition.endTime <= now || //block play when time is up \r\n\t\t\tcompetitionIndex != game.currentCompetitionIndex || //start happen just after a switch // should not be possible since endTime already ensure that a new competition cannot start before the end of the first\r\n\t\t\tversion != competition.version && (version != competition.previousVersion || block.number > competition.versionChangeBlockNumber) || //ensure version is same as current (or previous if versionChangeBlockNumber is recent)\r\n\t\t\tblock.number >= competition.numPastBlocks && block.number - competition.numPastBlocks > blockNumber //ensure start is not too old   \r\n\t\t\t){\r\n\t\t\t\t//if ether was sent, send it back if possible, else throw\r\n\t\t\t\tif(msg.value != 0 && !msg.sender.send(msg.value)){\r\n\t\t\t\t\tthrow;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tcompetition.jackpot += uint128(msg.value); //increase the jackpot\r\n\t\t\r\n\t\t//save the start params\r\n\t\tgame.starts[msg.sender] = Start({\r\n\t\t\tseed: computeSeed(blockNumber,msg.sender)\r\n\t\t\t, time : uint64(now)\r\n\t\t\t, competitionIndex : competitionIndex\r\n\t\t\t, version : version\r\n\t\t}); \r\n\t}\r\n\t\t\r\n\tfunction submit(string gameID, uint64 seed, uint32 score, uint32 durationRoundedDown, bytes32 proofHash){ \r\n\t\tvar game = games[gameID];\r\n\r\n\t\tvar gameStart = game.starts[msg.sender];\r\n\t\t\t\r\n\t\t//seed should be same, else it means double start and this one executing is from the old one \r\n\t\tif(gameStart.seed != seed){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tvar competition = game.competitions[gameStart.competitionIndex];\r\n\t\t\r\n\t\t// game should not take too long to be submited\r\n\t\tif(now - gameStart.time > durationRoundedDown + competition.lag){ \r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(now >= competition.endTime + competition.verificationWaitTime){\r\n\t\t\treturn; //this ensure verifier to get all the score at that time (should never be there though as game should ensure a maximumTime < verificationWaitTime)\r\n\t\t}\r\n\t\t\r\n\t\tvar submission = competition.submissions[msg.sender];\r\n\t\tif(submission.submitBlockNumber < competition.switchBlockNumber){\r\n\t\t\tif(competition.numPlayers >= 4294967295){ //unlikely but if that happen this is for now the best place to stop\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}else if (score <= submission.score){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tvar players = competition.players;\r\n\t\t//if player did not submit score yet => add player to list\r\n\t\tif(submission.submitBlockNumber < competition.switchBlockNumber){\r\n\t\t\tvar currentNumPlayer = competition.numPlayers;\r\n\t\t\tif(currentNumPlayer >= players.length){\r\n\t\t\t\tplayers.push(msg.sender);\r\n\t\t\t}else{\r\n\t\t\t\tplayers[currentNumPlayer] = msg.sender;\r\n\t\t\t}\r\n\t\t\tcompetition.numPlayers = currentNumPlayer + 1;\r\n\t\t}\r\n\t\t\r\n\t\tcompetition.submissions[msg.sender] = Submission({\r\n\t\t\tproofHash:proofHash,\r\n\t\t\tseed:gameStart.seed,\r\n\t\t\tscore:score,\r\n\t\t\tdurationRoundedDown:durationRoundedDown,\r\n\t\t\tsubmitBlockNumber:uint64(block.number),\r\n\t\t\tversion:gameStart.version\r\n\t\t});\r\n\t\t\r\n\t}\r\n\t\r\n\t/*\r\n\t\taccept donation payment : this increase the jackpot of the currentCompetition of the specified game\r\n\t*/\r\n\tfunction increaseJackpot(string gameID) payable{\r\n\t\tvar game = games[gameID];\r\n\t\tgame.competitions[game.currentCompetitionIndex].jackpot += uint128(msg.value); //extra ether is lost but this is not going to happen :)\r\n\t}\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t\r\n/////////////////////////////////////// PRIVATE ///////////////////////////////////////////\r\n\t\t\r\n\tfunction CompetitionStore(){\r\n\t\torganiser = msg.sender;\r\n\t\tdepositAccount = msg.sender;\r\n\t}\r\n\r\n\t\r\n\t//give a starting jackpot by sending ether to the transaction\r\n\tfunction _startNextCompetition(string gameID, uint32 version, uint88 price, uint8 numPastBlocks, uint8 houseDivider, uint16 lag, uint64 duration, uint32 verificationWaitTime, bytes32 codeHash, uint32[] rewardsDistribution) payable{\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\tvar game = games[gameID];\r\n\t\tvar newCompetition = game.competitions[1 - game.currentCompetitionIndex]; \r\n\t\tvar currentCompetition = game.competitions[game.currentCompetitionIndex];\r\n\t\t//do not allow to switch if endTime is not over\r\n\t\tif(currentCompetition.endTime >= now){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\t//block switch if reward was not called (numPlayers > 0)\r\n\t\tif(newCompetition.numPlayers > 0){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(houseDivider == 0){ \r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(numPastBlocks < 1){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(rewardsDistribution.length == 0 || rewardsDistribution.length > 64){ // do not risk gas shortage on reward\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t//ensure rewardsDistribution give always something and do not give more to a lower scoring player\r\n\t\tuint32 prev = 0;\r\n\t\tfor(uint8 i = 0; i < rewardsDistribution.length; i++){\r\n\t\t\tif(rewardsDistribution[i] == 0 ||  (prev != 0 && rewardsDistribution[i] > prev)){\r\n\t\t\t\tthrow;\r\n\t\t\t}\r\n\t\t\tprev = rewardsDistribution[i];\r\n\t\t}\r\n\r\n\t\tif(version != currentCompetition.version){\r\n\t\t\tVersionChange(gameID,version,codeHash); \r\n\t\t}\r\n\t\t\r\n\t\tgame.currentCompetitionIndex = 1 - game.currentCompetitionIndex;\r\n\t\t\r\n\t\tnewCompetition.switchBlockNumber = uint64(block.number);\r\n\t\tnewCompetition.previousVersion = 0;\r\n\t\tnewCompetition.versionChangeBlockNumber = 0;\r\n\t\tnewCompetition.version = version;\r\n\t\tnewCompetition.price = price; \r\n\t\tnewCompetition.numPastBlocks = numPastBlocks;\r\n\t\tnewCompetition.rewardsDistribution = rewardsDistribution;\r\n\t\tnewCompetition.houseDivider = houseDivider;\r\n\t\tnewCompetition.lag = lag;\r\n\t\tnewCompetition.jackpot += uint128(msg.value); //extra ether is lost but this is not going to happen :)\r\n\t\tnewCompetition.endTime = uint64(now) + duration;\r\n\t\tnewCompetition.verificationWaitTime = verificationWaitTime;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\tfunction _setBugFixVersion(string gameID, uint32 version, bytes32 codeHash, uint32 numBlockAllowedForPastVersion){\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\tvar game = games[gameID];\r\n\t\tvar competition = game.competitions[game.currentCompetitionIndex];\r\n\t\t\r\n\t\tif(version <= competition.version){ // a bug fix should be a new version (greater than previous version)\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(competition.endTime <= now){ // cannot bugFix a competition that already ended\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tcompetition.previousVersion = competition.version;\r\n\t\tcompetition.versionChangeBlockNumber = uint64(block.number + numBlockAllowedForPastVersion);\r\n\t\tcompetition.version = version;\r\n\t\tVersionChange(gameID,version,codeHash);\r\n\t}\r\n\r\n\tfunction _setLagParams(string gameID, uint16 lag, uint8 numPastBlocks){\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(numPastBlocks < 1){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\tvar game = games[gameID];\r\n\t\tvar competition = game.competitions[game.currentCompetitionIndex];\r\n\t\tcompetition.numPastBlocks = numPastBlocks;\r\n\t\tcompetition.lag = lag;\r\n\t}\r\n\r\n\tfunction _rewardWinners(string gameID, uint8 competitionIndex, address[] winners){\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tvar competition = games[gameID].competitions[competitionIndex];\r\n\r\n\t\t//ensure time has passed so that players who started near the end can finish their session \r\n\t\t//game should be made to ensure termination before verificationWaitTime, it is the game responsability\r\n\t\tif(int(now) - competition.endTime < competition.verificationWaitTime){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\t\r\n\t\tif( competition.jackpot > 0){ // if there is no jackpot skip\r\n\r\n\t\t\t\r\n\t\t\tvar rewardsDistribution = competition.rewardsDistribution;\r\n\r\n\t\t\tuint8 numWinners = uint8(rewardsDistribution.length);\r\n\r\n\t\t\tif(numWinners > uint8(winners.length)){\r\n\t\t\t\tnumWinners = uint8(winners.length);\r\n\t\t\t}\r\n\r\n\t\t\tuint128 forHouse = competition.jackpot;\r\n\t\t\tif(numWinners > 0 && competition.houseDivider > 1){ //in case there is no winners (no players or only cheaters), the house takes all\r\n\t\t\t\tforHouse = forHouse / competition.houseDivider;\r\n\t\t\t\tuint128 forWinners = competition.jackpot - forHouse;\r\n\r\n\t\t\t\tuint64 total = 0;\r\n\t\t\t\tfor(uint8 i=0; i<numWinners; i++){ // distribute all the winning even if there is not all the winners\r\n\t\t\t\t\ttotal += rewardsDistribution[i];\r\n\t\t\t\t}\r\n\t\t\t\tfor(uint8 j=0; j<numWinners; j++){\r\n\t\t\t\t\tuint128 value = (forWinners * rewardsDistribution[j]) / total;\r\n\t\t\t\t\tif(!winners[j].send(value)){ // if fail give to house\r\n\t\t\t\t\t\tforHouse = forHouse + value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!depositAccount.send(forHouse)){\r\n\t\t\t\t//in case sending to house failed \r\n\t\t\t\tvar nextCompetition = games[gameID].competitions[1 - competitionIndex];\r\n\t\t\t\tnextCompetition.jackpot = nextCompetition.jackpot + forHouse;\t\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\tcompetition.jackpot = 0;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tcompetition.numPlayers = 0;\r\n\t}\r\n\r\n\t\r\n\t/*\r\n\t\tallow to change the depositAccount of the house share, only the depositAccount can change it, depositAccount == organizer at creation\r\n\t*/\r\n\tfunction _setDepositAccount(address newDepositAccount){\r\n\t\tif(depositAccount != msg.sender){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\tdepositAccount = newDepositAccount;\r\n\t}\r\n\t\r\n\t/*\r\n\t\tallow to change the organiser, in case this need be \r\n\t*/\r\n\tfunction _setOrganiser(address newOrganiser){\r\n\t\tif(organiser != msg.sender){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\torganiser = newOrganiser;\r\n\t}\r\n\t\r\n\t\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/////////////////////////////////////////////// OTHER CONSTANT CALLS TO PROBE VALUES ////////////////////////////////////////////////////\r\n\r\n\tfunction getPlayerSubmissionFromCompetition(string gameID, uint8 competitionIndex, address playerAddress) constant returns(uint32 score, uint64 seed, uint32 duration, bytes32 proofHash, uint32 version, uint64 submitBlockNumber){\r\n\t\tvar submission = games[gameID].competitions[competitionIndex].submissions[playerAddress];\r\n\t\tscore = submission.score;\r\n\t\tseed = submission.seed;\t\t\r\n\t\tduration = submission.durationRoundedDown;\r\n\t\tproofHash = submission.proofHash;\r\n\t\tversion = submission.version;\r\n\t\tsubmitBlockNumber =submission.submitBlockNumber;\r\n\t}\r\n\t\r\n\tfunction getPlayersFromCompetition(string gameID, uint8 competitionIndex) constant returns(address[] playerAddresses, uint32 num){\r\n\t\tvar competition = games[gameID].competitions[competitionIndex];\r\n\t\tplayerAddresses = competition.players;\r\n\t\tnum = competition.numPlayers;\r\n\t}\r\n\r\n\tfunction getCompetitionValues(string gameID, uint8 competitionIndex) constant returns (\r\n\t\tuint128 jackpot,\r\n\t\tuint88 price,\r\n\t\tuint32 version,\r\n\t\tuint8 numPastBlocks,\r\n\t\tuint64 switchBlockNumber,\r\n\t\tuint32 numPlayers,\r\n\t\tuint32[] rewardsDistribution,\r\n\t\tuint8 houseDivider,\r\n\t\tuint16 lag,\r\n\t\tuint64 endTime,\r\n\t\tuint32 verificationWaitTime,\r\n\t\tuint8 _competitionIndex\r\n\t){\r\n\t\tvar competition = games[gameID].competitions[competitionIndex];\r\n\t\tjackpot = competition.jackpot;\r\n\t\tprice = competition.price;\r\n\t\tversion = competition.version;\r\n\t\tnumPastBlocks = competition.numPastBlocks;\r\n\t\tswitchBlockNumber = competition.switchBlockNumber;\r\n\t\tnumPlayers = competition.numPlayers;\r\n\t\trewardsDistribution = competition.rewardsDistribution;\r\n\t\thouseDivider = competition.houseDivider;\r\n\t\tlag = competition.lag;\r\n\t\tendTime = competition.endTime;\r\n\t\tverificationWaitTime = competition.verificationWaitTime;\r\n\t\t_competitionIndex = competitionIndex;\r\n\t}\r\n\t\r\n\tfunction getCurrentCompetitionValues(string gameID) constant returns (\r\n\t\tuint128 jackpot,\r\n\t\tuint88 price,\r\n\t\tuint32 version,\r\n\t\tuint8 numPastBlocks,\r\n\t\tuint64 switchBlockNumber,\r\n\t\tuint32 numPlayers,\r\n\t\tuint32[] rewardsDistribution,\r\n\t\tuint8 houseDivider,\r\n\t\tuint16 lag,\r\n\t\tuint64 endTime,\r\n\t\tuint32 verificationWaitTime,\r\n\t\tuint8 _competitionIndex\r\n\t)\r\n\t{\r\n\t\treturn getCompetitionValues(gameID,games[gameID].currentCompetitionIndex);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"codeHash\",\"type\":\"bytes32\"},{\"name\":\"numBlockAllowedForPastVersion\",\"type\":\"uint32\"}],\"name\":\"_setBugFixVersion\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDepositAccount\",\"type\":\"address\"}],\"name\":\"_setDepositAccount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"lag\",\"type\":\"uint16\"},{\"name\":\"numPastBlocks\",\"type\":\"uint8\"}],\"name\":\"_setLagParams\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"seed\",\"type\":\"uint64\"},{\"name\":\"score\",\"type\":\"uint32\"},{\"name\":\"durationRoundedDown\",\"type\":\"uint32\"},{\"name\":\"proofHash\",\"type\":\"bytes32\"}],\"name\":\"submit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"competitionIndex\",\"type\":\"uint8\"},{\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerSubmissionFromCompetition\",\"outputs\":[{\"name\":\"score\",\"type\":\"uint32\"},{\"name\":\"seed\",\"type\":\"uint64\"},{\"name\":\"duration\",\"type\":\"uint32\"},{\"name\":\"proofHash\",\"type\":\"bytes32\"},{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"submitBlockNumber\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOrganiser\",\"type\":\"address\"}],\"name\":\"_setOrganiser\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"name\":\"competitionIndex\",\"type\":\"uint8\"},{\"name\":\"version\",\"type\":\"uint32\"}],\"name\":\"start\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"price\",\"type\":\"uint88\"},{\"name\":\"numPastBlocks\",\"type\":\"uint8\"},{\"name\":\"houseDivider\",\"type\":\"uint8\"},{\"name\":\"lag\",\"type\":\"uint16\"},{\"name\":\"duration\",\"type\":\"uint64\"},{\"name\":\"verificationWaitTime\",\"type\":\"uint32\"},{\"name\":\"codeHash\",\"type\":\"bytes32\"},{\"name\":\"rewardsDistribution\",\"type\":\"uint32[]\"}],\"name\":\"_startNextCompetition\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getSeedAndState\",\"outputs\":[{\"name\":\"seed\",\"type\":\"uint64\"},{\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"name\":\"competitionIndex\",\"type\":\"uint8\"},{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"endTime\",\"type\":\"uint64\"},{\"name\":\"price\",\"type\":\"uint88\"},{\"name\":\"myBestScore\",\"type\":\"uint32\"},{\"name\":\"competitionBlockNumber\",\"type\":\"uint64\"},{\"name\":\"registeredSeed\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"competitionIndex\",\"type\":\"uint8\"}],\"name\":\"getCompetitionValues\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"uint128\"},{\"name\":\"price\",\"type\":\"uint88\"},{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"numPastBlocks\",\"type\":\"uint8\"},{\"name\":\"switchBlockNumber\",\"type\":\"uint64\"},{\"name\":\"numPlayers\",\"type\":\"uint32\"},{\"name\":\"rewardsDistribution\",\"type\":\"uint32[]\"},{\"name\":\"houseDivider\",\"type\":\"uint8\"},{\"name\":\"lag\",\"type\":\"uint16\"},{\"name\":\"endTime\",\"type\":\"uint64\"},{\"name\":\"verificationWaitTime\",\"type\":\"uint32\"},{\"name\":\"_competitionIndex\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"competitionIndex\",\"type\":\"uint8\"}],\"name\":\"getPlayersFromCompetition\",\"outputs\":[{\"name\":\"playerAddresses\",\"type\":\"address[]\"},{\"name\":\"num\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"}],\"name\":\"getCurrentCompetitionValues\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"uint128\"},{\"name\":\"price\",\"type\":\"uint88\"},{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"numPastBlocks\",\"type\":\"uint8\"},{\"name\":\"switchBlockNumber\",\"type\":\"uint64\"},{\"name\":\"numPlayers\",\"type\":\"uint32\"},{\"name\":\"rewardsDistribution\",\"type\":\"uint32[]\"},{\"name\":\"houseDivider\",\"type\":\"uint8\"},{\"name\":\"lag\",\"type\":\"uint16\"},{\"name\":\"endTime\",\"type\":\"uint64\"},{\"name\":\"verificationWaitTime\",\"type\":\"uint32\"},{\"name\":\"_competitionIndex\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameID\",\"type\":\"string\"},{\"name\":\"competitionIndex\",\"type\":\"uint8\"},{\"name\":\"winners\",\"type\":\"address[]\"}],\"name\":\"_rewardWinners\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameID\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"version\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"VersionChange\",\"type\":\"event\"}]","ContractName":"CompetitionStore","CompilerVersion":"v0.4.4+commit.4633f3de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}