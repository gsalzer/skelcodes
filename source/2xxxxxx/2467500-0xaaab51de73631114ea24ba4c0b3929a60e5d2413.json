{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n/**\r\n * @title Contract for object that have an owner\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev Store owner on creation\r\n     */\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    /**\r\n     * @dev Delegate contract to another person\r\n     * @param _owner is another person address\r\n     */\r\n    function delegate(address _owner) onlyOwner\r\n    { owner = _owner; }\r\n\r\n    /**\r\n     * @dev Owner check modifier\r\n     */\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\n}\r\n/**\r\n * @title Token contract represents any asset in digital economy\r\n */\r\ncontract Token is Owned {\r\n    event Transfer(address indexed _from,  address indexed _to,      uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /* Short description of token */\r\n    string public name;\r\n    string public symbol;\r\n\r\n    /* Total count of tokens exist */\r\n    uint public totalSupply;\r\n\r\n    /* Fixed point position */\r\n    uint8 public decimals;\r\n    \r\n    /* Token approvement system */\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n \r\n    /**\r\n     * @return available balance of `sender` account (self balance)\r\n     */\r\n    function getBalance() constant returns (uint)\r\n    { return balanceOf[msg.sender]; }\r\n \r\n    /**\r\n     * @dev This method returns non zero result when sender is approved by\r\n     *      argument address and target address have non zero self balance\r\n     * @param _address target address \r\n     * @return available for `sender` balance of given address\r\n     */\r\n    function getBalance(address _address) constant returns (uint) {\r\n        return allowance[_address][msg.sender]\r\n             > balanceOf[_address] ? balanceOf[_address]\r\n                                   : allowance[_address][msg.sender];\r\n    }\r\n \r\n    /* Token constructor */\r\n    function Token(string _name, string _symbol, uint8 _decimals, uint _count) {\r\n        name     = _name;\r\n        symbol   = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply           = _count;\r\n        balanceOf[msg.sender] = _count;\r\n    }\r\n \r\n    /**\r\n     * @dev Transfer self tokens to given address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice `_value` tokens will be sended to `_to`\r\n     * @return `true` when transfer done\r\n     */\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        if (balanceOf[msg.sender] >= _value) {\r\n            balanceOf[msg.sender] -= _value;\r\n            balanceOf[_to]        += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer with approvement mechainsm\r\n     * @param _from source address, `_value` tokens shold be approved for `sender`\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send \r\n     * @notice from `_from` will be sended `_value` tokens to `_to`\r\n     * @return `true` when transfer is done\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        var avail = allowance[_from][msg.sender]\r\n                  > balanceOf[_from] ? balanceOf[_from]\r\n                                     : allowance[_from][msg.sender];\r\n        if (avail >= _value) {\r\n            allowance[_from][msg.sender] -= _value;\r\n            balanceOf[_from] -= _value;\r\n            balanceOf[_to]   += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Give to target address ability for self token manipulation without sending\r\n     * @param _address target address\r\n     * @param _value amount of token values for approving\r\n     */\r\n    function approve(address _address, uint _value) {\r\n        allowance[msg.sender][_address] += _value;\r\n        Approval(msg.sender, _address, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Reset count of tokens approved for given address\r\n     * @param _address target address\r\n     */\r\n    function unapprove(address _address)\r\n    { allowance[msg.sender][_address] = 0; }\r\n}\r\n/**\r\n * @title Ethereum crypto currency extention for Token contract\r\n */\r\ncontract TokenEther is Token {\r\n    function TokenEther(string _name, string _symbol)\r\n             Token(_name, _symbol, 18, 0)\r\n    {}\r\n\r\n    /**\r\n     * @dev This is the way to withdraw money from token\r\n     * @param _value how many tokens withdraw from balance\r\n     */\r\n    function withdraw(uint _value) {\r\n        if (balanceOf[msg.sender] >= _value) {\r\n            balanceOf[msg.sender] -= _value;\r\n            totalSupply           -= _value;\r\n            if(!msg.sender.send(_value)) throw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is the way to refill your token balance by ethers\r\n     */\r\n    function refill() payable returns (bool) {\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev This method is called when money sended to contract address,\r\n     *      a synonym for refill()\r\n     */\r\n    function () payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n    }\r\n}\r\ncontract AiraEtherFunds is TokenEther {\r\n    function AiraEtherFunds(string _name, string _symbol) TokenEther(_name, _symbol) {}\r\n\r\n    /**\r\n     * @dev Event spawned when activation request received\r\n     */\r\n    event ActivationRequest(address indexed sender, bytes32 indexed code);\r\n\r\n    /**\r\n     * @dev String to bytes32 conversion helper\r\n     */\r\n    function stringToBytes32(string memory source) constant returns (bytes32 result)\r\n    { assembly { result := mload(add(source, 32)) } }\r\n\r\n    // Balance limit\r\n    uint public limit;\r\n    \r\n    function setLimit(uint _limit) onlyOwner\r\n    { limit = _limit; }\r\n\r\n    // Account activation fee\r\n    uint public fee;\r\n    \r\n    function setFee(uint _fee) onlyOwner\r\n    { fee = _fee; }\r\n\r\n    // AiraEtherBot\r\n    address public bot;\r\n\r\n    function setBot(address _bot) onlyOwner\r\n    { bot = _bot; }\r\n\r\n    modifier onlyBot { if (msg.sender != bot) throw; _; }\r\n\r\n    /**\r\n     * @dev Refill balance and activate it by code\r\n     * @param _code is activation code\r\n     */\r\n    function activate(string _code) payable {\r\n        var value = msg.value;\r\n \r\n        // Get a fee\r\n        if (fee > 0) {\r\n            if (value < fee) throw;\r\n            balanceOf[owner] += fee;\r\n            value            -= fee;\r\n        }\r\n\r\n        // Refund over limit\r\n        if (limit > 0 && value > limit) {\r\n            var refund = value - limit;\r\n            if (!msg.sender.send(refund)) throw;\r\n            value = limit;\r\n        }\r\n\r\n        // Refill account balance\r\n        balanceOf[msg.sender] += value;\r\n        totalSupply           += value;\r\n\r\n        // Activation event\r\n        ActivationRequest(msg.sender, stringToBytes32(_code));\r\n    }\r\n\r\n    /**\r\n     * @dev This is the way to refill your token balance by ethers\r\n     */\r\n    function refill() payable returns (bool) {\r\n        // Throw when over limit\r\n        if (balanceOf[msg.sender] + msg.value > limit) throw;\r\n\r\n        // Refill\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev This method is called when money sended to contract address,\r\n     *      a synonym for refill()\r\n     */\r\n    function () payable {\r\n        // Throw when over limit\r\n        if (balanceOf[msg.sender] + msg.value > limit) throw;\r\n\r\n        // Refill\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal transfer for AIRA\r\n     * @param _from source address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send \r\n     */\r\n    function airaTransfer(address _from, address _to, uint _value) onlyBot {\r\n        if (balanceOf[_from] >= _value) {\r\n            balanceOf[_from] -= _value;\r\n            balanceOf[_to]   += _value;\r\n            Transfer(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Outgoing transfer for AIRA\r\n     * @param _from source address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send \r\n     */\r\n    function airaSend(address _from, address _to, uint _value) onlyBot {\r\n        if (balanceOf[_from] >= _value) {\r\n            balanceOf[_from] -= _value;\r\n            totalSupply      -= _value;\r\n            Transfer(_from, _to, _value);\r\n            if (!_to.send(_value)) throw;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refill\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bot\",\"type\":\"address\"}],\"name\":\"setBot\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"airaTransfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"airaSend\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"unapprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"ActivationRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"AiraEtherFunds","CompilerVersion":"v0.4.2+commit.af6afb04","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}