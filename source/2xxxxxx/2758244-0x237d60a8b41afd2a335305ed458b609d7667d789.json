{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n/**\r\n * @title Contract for object that have an owner\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev Store owner on creation\r\n     */\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    /**\r\n     * @dev Delegate contract to another person\r\n     * @param _owner is another person address\r\n     */\r\n    function delegate(address _owner) onlyOwner\r\n    { owner = _owner; }\r\n\r\n    /**\r\n     * @dev Owner check modifier\r\n     */\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\n}\r\n/**\r\n * @title Contract for objects that can be morder\r\n */\r\ncontract Mortal is Owned {\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can kill me\r\n     */\r\n    function kill() onlyOwner\r\n    { suicide(owner); }\r\n}\r\n\r\n// Standard token interface (ERC 20)\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 \r\n{\r\n// Functions:\r\n    /// @return total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256);\r\n\r\n// Events:\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title Token compatible contract represents any asset in digital economy\r\n * @dev Accounting based on sha3 hashed identifiers\r\n */\r\ncontract TokenHash is Mortal, ERC20 {\r\n    /* Short description of token */\r\n    string public name;\r\n    string public symbol;\r\n\r\n    /* Fixed point position */\r\n    uint8 public decimals;\r\n\r\n    /* Token approvement system */\r\n    mapping(bytes32 => uint256) balances;\r\n    mapping(bytes32 => mapping(bytes32 => uint256)) allowances;\r\n \r\n    /**\r\n     * @dev Get balance of plain address\r\n     * @param _owner is a target address\r\n     * @return amount of tokens on balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint256)\r\n    { return balances[sha3(_owner)]; }\r\n\r\n    /**\r\n     * @dev Get balance of ident\r\n     * @param _owner is a target ident\r\n     * @return amount of tokens on balance\r\n     */\r\n    function balanceOf(bytes32 _owner) constant returns (uint256)\r\n    { return balances[_owner]; }\r\n\r\n    /**\r\n     * @dev Take allowed tokens\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256)\r\n    { return allowances[sha3(_owner)][sha3(_spender)]; }\r\n\r\n    /**\r\n     * @dev Take allowed tokens\r\n     * @param _owner The ident of the account owning tokens\r\n     * @param _spender The ident of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(bytes32 _owner, bytes32 _spender) constant returns (uint256)\r\n    { return allowances[_owner][_spender]; }\r\n\r\n    /* Token constructor */\r\n    function TokenHash(string _name, string _symbol, uint8 _decimals, uint256 _count) {\r\n        name        = _name;\r\n        symbol      = _symbol;\r\n        decimals    = _decimals;\r\n        totalSupply = _count;\r\n        balances[sha3(msg.sender)] = _count;\r\n    }\r\n \r\n    /**\r\n     * @dev Transfer self tokens to given address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice `_value` tokens will be sended to `_to`\r\n     * @return `true` when transfer done\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        var sender = sha3(msg.sender);\r\n\r\n        if (balances[sender] >= _value) {\r\n            balances[sender]    -= _value;\r\n            balances[sha3(_to)] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer self tokens to given address\r\n     * @param _to destination ident\r\n     * @param _value amount of token values to send\r\n     * @notice `_value` tokens will be sended to `_to`\r\n     * @return `true` when transfer done\r\n     */\r\n    function transfer(bytes32 _to, uint256 _value) returns (bool) {\r\n        var sender = sha3(msg.sender);\r\n\r\n        if (balances[sender] >= _value) {\r\n            balances[sender] -= _value;\r\n            balances[_to]    += _value;\r\n            TransferHash(sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfer with approvement mechainsm\r\n     * @param _from source address, `_value` tokens shold be approved for `sender`\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send \r\n     * @notice from `_from` will be sended `_value` tokens to `_to`\r\n     * @return `true` when transfer is done\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        var to    = sha3(_to);\r\n        var from  = sha3(_from);\r\n        var sender= sha3(msg.sender);\r\n        var avail = allowances[from][sender]\r\n                  > balances[from] ? balances[from]\r\n                                   : allowances[from][sender];\r\n        if (avail >= _value) {\r\n            allowances[from][sender] -= _value;\r\n            balances[from] -= _value;\r\n            balances[to]   += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer with approvement mechainsm\r\n     * @param _from source ident, `_value` tokens shold be approved for `sender`\r\n     * @param _to destination ident\r\n     * @param _value amount of token values to send \r\n     * @notice from `_from` will be sended `_value` tokens to `_to`\r\n     * @return `true` when transfer is done\r\n     */\r\n    function transferFrom(bytes32 _from, bytes32 _to, uint256 _value) returns (bool) {\r\n        var sender= sha3(msg.sender);\r\n        var avail = allowances[_from][sender]\r\n                  > balances[_from] ? balances[_from]\r\n                                    : allowances[_from][sender];\r\n        if (avail >= _value) {\r\n            allowances[_from][sender] -= _value;\r\n            balances[_from] -= _value;\r\n            balances[_to]   += _value;\r\n            TransferHash(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Give to target address ability for self token manipulation without sending\r\n     * @param _spender target address (future requester)\r\n     * @param _value amount of token values for approving\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool) {\r\n        allowances[sha3(msg.sender)][sha3(_spender)] += _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n \r\n    /**\r\n     * @dev Give to target ident ability for self token manipulation without sending\r\n     * @param _spender target ident (future requester)\r\n     * @param _value amount of token values for approving\r\n     */\r\n    function approve(bytes32 _spender, uint256 _value) returns (bool) {\r\n        allowances[sha3(msg.sender)][_spender] += _value;\r\n        ApprovalHash(sha3(msg.sender), _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Reset count of tokens approved for given address\r\n     * @param _spender target address\r\n     */\r\n    function unapprove(address _spender)\r\n    { allowances[sha3(msg.sender)][sha3(_spender)] = 0; }\r\n \r\n    /**\r\n     * @dev Reset count of tokens approved for given ident\r\n     * @param _spender target ident\r\n     */\r\n    function unapprove(bytes32 _spender)\r\n    { allowances[sha3(msg.sender)][_spender] = 0; }\r\n \r\n    /* Hash driven events */\r\n    event TransferHash(bytes32 indexed _from,  bytes32 indexed _to,      uint256 _value);\r\n    event ApprovalHash(bytes32 indexed _owner, bytes32 indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n//sol Registrar\r\n// Simple global registrar.\r\n// @authors:\r\n//   Gav Wood <g@ethdev.com>\r\n\r\ncontract Registrar {\r\n\tevent Changed(string indexed name);\r\n\r\n\tfunction owner(string _name) constant returns (address o_owner);\r\n\tfunction addr(string _name) constant returns (address o_address);\r\n\tfunction subRegistrar(string _name) constant returns (address o_subRegistrar);\r\n\tfunction content(string _name) constant returns (bytes32 o_content);\r\n}\r\n\r\n//sol OwnedRegistrar\r\n// Global registrar with single authoritative owner.\r\n// @authors:\r\n//   Gav Wood <g@ethdev.com>\r\n\r\ncontract AiraRegistrarService is Registrar, Mortal {\r\n\tstruct Record {\r\n\t\taddress addr;\r\n\t\taddress subRegistrar;\r\n\t\tbytes32 content;\r\n\t}\r\n\t\r\n    function owner(string _name) constant returns (address o_owner)\r\n    { return 0; }\r\n\r\n\tfunction disown(string _name) onlyOwner {\r\n\t\tdelete m_toRecord[_name];\r\n\t\tChanged(_name);\r\n\t}\r\n\r\n\tfunction setAddr(string _name, address _a) onlyOwner {\r\n\t\tm_toRecord[_name].addr = _a;\r\n\t\tChanged(_name);\r\n\t}\r\n\tfunction setSubRegistrar(string _name, address _registrar) onlyOwner {\r\n\t\tm_toRecord[_name].subRegistrar = _registrar;\r\n\t\tChanged(_name);\r\n\t}\r\n\tfunction setContent(string _name, bytes32 _content) onlyOwner {\r\n\t\tm_toRecord[_name].content = _content;\r\n\t\tChanged(_name);\r\n\t}\r\n\tfunction record(string _name) constant returns (address o_addr, address o_subRegistrar, bytes32 o_content) {\r\n\t\to_addr = m_toRecord[_name].addr;\r\n\t\to_subRegistrar = m_toRecord[_name].subRegistrar;\r\n\t\to_content = m_toRecord[_name].content;\r\n\t}\r\n\tfunction addr(string _name) constant returns (address) { return m_toRecord[_name].addr; }\r\n\tfunction subRegistrar(string _name) constant returns (address) { return m_toRecord[_name].subRegistrar; }\r\n\tfunction content(string _name) constant returns (bytes32) { return m_toRecord[_name].content; }\r\n\r\n\tmapping (string => Record) m_toRecord;\r\n}\r\n\r\ncontract AiraEtherFunds is TokenHash {\r\n    function AiraEtherFunds(address _bot_reg, string _name, string _symbol)\r\n            TokenHash(_name, _symbol, 18, 0) {\r\n        reg = AiraRegistrarService(_bot_reg);\r\n    }\r\n\r\n    /**\r\n     * @dev Event spawned when activation request received\r\n     */\r\n    event ActivationRequest(address indexed ident, bytes32 indexed code);\r\n\r\n    // Balance limit\r\n    uint256 public limit;\r\n    \r\n    function setLimit(uint256 _limit) onlyOwner\r\n    { limit = _limit; }\r\n\r\n    // Account activation fee\r\n    uint256 public fee;\r\n    \r\n    function setFee(uint256 _fee) onlyOwner\r\n    { fee = _fee; }\r\n\r\n    /**\r\n     * @dev Refill balance and activate it by code\r\n     * @param _code is activation code\r\n     */\r\n    function activate(string _code) payable {\r\n        var value = msg.value;\r\n \r\n        // Get a fee\r\n        if (fee > 0) {\r\n            if (value < fee) throw;\r\n            balances[sha3(owner)] += fee;\r\n            value                 -= fee;\r\n        }\r\n\r\n        // Refund over limit\r\n        if (limit > 0 && value > limit) {\r\n            var refund = value - limit;\r\n            if (!msg.sender.send(refund)) throw;\r\n            value = limit;\r\n        }\r\n\r\n        // Refill account balance\r\n        balances[sha3(msg.sender)] += value;\r\n        totalSupply                += value;\r\n\r\n        // Activation event\r\n        ActivationRequest(msg.sender, stringToBytes32(_code));\r\n    }\r\n\r\n    /**\r\n     * @dev String to bytes32 conversion helper\r\n     */\r\n    function stringToBytes32(string memory source) constant returns (bytes32 result)\r\n    { assembly { result := mload(add(source, 32)) } }\r\n\r\n    /**\r\n     * @dev This is the way to refill token balance by ethers\r\n     * @param _dest is destination address\r\n     */\r\n    function refill(address _dest) payable returns (bool)\r\n    { return refill(sha3(_dest)); }\r\n\r\n    /**\r\n     * @dev This method is called when money sended to contract address,\r\n     *      a synonym for refill()\r\n     */\r\n    function () payable\r\n    { refill(msg.sender); }\r\n\r\n    /**\r\n     * @dev This is the way to refill token balance by ethers\r\n     * @param _dest is destination identifier\r\n     */\r\n    function refill(bytes32 _dest) payable returns (bool) {\r\n        // Throw when over limit\r\n        if (balances[_dest] + msg.value > limit) throw;\r\n\r\n        // Refill\r\n        balances[_dest] += msg.value;\r\n        totalSupply     += msg.value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Outgoing transfer (send) with allowance\r\n     * @param _from source identifier\r\n     * @param _to external destination address\r\n     * @param _value amount of token values to send \r\n     */\r\n    function sendFrom(bytes32 _from, address _to, uint256 _value) {\r\n        var sender = sha3(msg.sender);\r\n        var avail = allowances[_from][sender]\r\n                  > balances[_from] ? balances[_from]\r\n                                    : allowances[_from][sender];\r\n        if (avail >= _value) {\r\n            allowances[_from][sender] -= _value;\r\n            balances[_from]           -= _value;\r\n            totalSupply               -= _value;\r\n            if (!_to.send(_value)) throw;\r\n        }\r\n    }\r\n\r\n    AiraRegistrarService public reg;\r\n    modifier onlySecure { if (msg.sender != reg.addr(\"AiraSecure\")) throw; _; }\r\n\r\n    /**\r\n     * @dev Increase approved token values for AiraEthBot\r\n     * @param _client is a client ident\r\n     * @param _value is amount of tokens\r\n     */\r\n    function secureApprove(bytes32 _client, uint256 _value) onlySecure {\r\n        var ethBot = reg.addr(\"AiraEth\");\r\n        if (ethBot != 0) {\r\n            allowances[_client][sha3(ethBot)] += _value;\r\n            ApprovalHash(_client, sha3(ethBot), _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Close allowance for AiraEthBot\r\n     * @param _client is a client ident\r\n     */\r\n    function secureUnapprove(bytes32 _client) onlySecure {\r\n        var ethBot = reg.addr(\"AiraEth\");\r\n        if (ethBot != 0)\r\n            allowances[_client][sha3(ethBot)] = 0;\r\n    }\r\n\r\n    // By security issues deny to kill this by owner\r\n    function kill() onlyOwner { throw; }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"bytes32\"}],\"name\":\"unapprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"bytes32\"}],\"name\":\"secureUnapprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sendFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"bytes32\"}],\"name\":\"refill\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"bytes32\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reg\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"}],\"name\":\"refill\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"secureApprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"bytes32\"},{\"name\":\"_spender\",\"type\":\"bytes32\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"unapprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bot_reg\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ident\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"ActivationRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ApprovalHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"AiraEtherFunds","CompilerVersion":"v0.4.4+commit.4633f3de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d9f66e1e1dc316728d63c027e2597a33de4fe19b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000e41697261457468657246756e647300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034145460000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":""}]}