{"status":"1","message":"OK","result":[{"SourceCode":"contract Etherization {\r\n    \r\n    // 1 eth starting price\r\n    uint public START_PRICE = 1000000000000000000;\r\n    // 0.8 eth city build price\r\n    uint public CITY_PRICE = 800000000000000000;\r\n    // 0.5 eth building build price\r\n    uint public BUILDING_PRICE = 500000000000000000;\r\n    // 0.2 eth unit build price\r\n    uint public UNIT_PRICE = 200000000000000000;\r\n    // 0.02 eth unit maintenance price\r\n    uint public MAINT_PRICE = 20000000000000000;\r\n    // 0.1 eth min withdraw amount to prevent spam\r\n    uint public MIN_WTH = 100000000000000000;\r\n    \r\n    // minimum time to wait between moves in seconds\r\n    uint public WAIT_TIME = 14400;\r\n    uint MAP_ROWS = 34;\r\n    uint MAP_COLS = 34;\r\n    \r\n    \r\n    struct City {\r\n        uint owner;\r\n        string name;\r\n        // 0 - quarry, 1 - farm, 2 - woodworks, 3 - metalworks, 4 -stables\r\n        bool[5] buildings;\r\n        // 1 - pikemen, 2 - swordsmen, 3 - horsemen\r\n        uint[10] units; //maximum num of units per city 10\r\n        uint[2] rowcol;\r\n        int previousID;\r\n        int nextID;\r\n    }\r\n    \r\n    struct Player {\r\n        // Player address\r\n        address etherAddress;\r\n        // Their name\r\n        string name;\r\n        // Their treasury balance\r\n        uint treasury;\r\n        // Their capitol\r\n        uint capitol;\r\n        // Number of cities the player has under control\r\n        uint numCities;\r\n        uint numUnits;\r\n        // When was their last move (based on block.timestamp)\r\n        uint lastTimestamp;\r\n    }\r\n    \r\n    Player player;\r\n    Player[] public players;\r\n    uint public numPlayers = 0;\r\n    \r\n    mapping(address => uint) playerIDs;\r\n    mapping(uint => uint) public playerMsgs;\r\n    \r\n    City city;\r\n    City[] public cities;\r\n    uint public numCities = 0;\r\n    \r\n    uint[] public quarryCities;\r\n    uint[] public farmCities;\r\n    uint[] public woodworksCities;\r\n    uint[] public metalworksCities;\r\n    uint[] public stablesCities;\r\n    \r\n    uint[34][34] public map;\r\n\r\n    address wizardAddress;\r\n    \r\n    address utilsAddress;\r\n    address utilsAddress2;\r\n    \r\n    // Sum of all players' balances\r\n    uint public totalBalances = 0;\r\n\r\n    // Used to ensure only the owner can do some things.\r\n    modifier onlywizard { if (msg.sender == wizardAddress) _ }\r\n    \r\n    // Used to ensure only the utils contract can do some things.\r\n    modifier onlyutils { if (msg.sender == utilsAddress || msg.sender == utilsAddress2) _ }\r\n\r\n\r\n\r\n    // Sets up defaults.\r\n    function Etherization() {\r\n        wizardAddress = msg.sender;\r\n    }\r\n\r\n    function start(string playerName, string cityName, uint row, uint col, uint rowref, uint colref) {\r\n        \r\n        \r\n        // If they paid too little, reject and refund their money.\r\n        if (msg.value < START_PRICE) {\r\n            //msg.sender.send(msg.value);\r\n            //playerMsgs[msg.sender] = \"Not enough ether sent to found a city and start playing. Sending back any eth sent...\";\r\n            return;\r\n        }\r\n        // If the player already exists\r\n        if (playerIDs[msg.sender] > 0) {\r\n            //msg.sender.send(msg.value);\r\n            //playerMsgs[msg.sender] =  \"You already founded an etherization. Lookup your player ID by calling getMyPlayerID(). Sending back any eth sent...\";\r\n            return;\r\n        }\r\n        \r\n        player.etherAddress = msg.sender;\r\n        player.name = playerName;\r\n        player.treasury = msg.value;\r\n        totalBalances += msg.value;\r\n        player.capitol = numCities;\r\n        player.numCities = 1;\r\n        player.numUnits = 1;\r\n\r\n        players.push(player);\r\n        \r\n        city.owner = numPlayers;\r\n        city.name = cityName;\r\n        // the first city in the game has a quarry and a farm by default\r\n        if(numCities <= 0) {\r\n            city.buildings[0] = true;\r\n            quarryCities.push(0);\r\n            city.buildings[1] = true;\r\n            farmCities.push(0);\r\n            city.rowcol[0] = 10;\r\n            city.rowcol[1] = 10;\r\n            map[10][10] = numPlayers+1;\r\n        } else {\r\n            city.buildings[0] = false;\r\n            city.buildings[1] = false;\r\n            if(row>33 || col>33 || rowref>33 || colref>33 || int(row)-int(rowref) > int(1) || int(row)-int(rowref) < int(-1) || int(col)-int(colref) > int(1) || int(col)-int(colref) < int(-1) || map[row][col]>0 || map[rowref][colref]<=0) {\r\n                throw;\r\n            }\r\n            city.rowcol[0] = row;\r\n            city.rowcol[1] = col;\r\n            map[row][col] = numPlayers+1;\r\n            \r\n            players[numPlayers].treasury -= START_PRICE;\r\n            // distribute build funds to production type building owners\r\n            uint productionCut;\r\n            uint i;\r\n            productionCut = START_PRICE / quarryCities.length;\r\n            for(i=0; i < quarryCities.length; i++) {\r\n                players[cities[quarryCities[i]].owner].treasury += productionCut;\r\n            }\r\n        }\r\n        city.units[0] = 1;  //pikemen guards a city by default\r\n        city.previousID = -1;\r\n        city.nextID = -1;\r\n        \r\n        cities.push(city);\r\n        \r\n        playerIDs[msg.sender] = numPlayers+1; //to distinguish it from the default 0\r\n        numPlayers++;\r\n        numCities++;\r\n        \r\n        playerMsgs[playerIDs[msg.sender]-1] = 1 + row*100 + col*10000;\r\n        players[numPlayers-1].lastTimestamp = now;\r\n    }\r\n    \r\n    function deposit() {\r\n        players[playerIDs[msg.sender]-1].treasury += msg.value;\r\n        totalBalances += msg.value;\r\n    }\r\n    \r\n    function withdraw(uint amount) {\r\n        if(int(playerIDs[msg.sender])-1 < 0) {\r\n            throw;\r\n        }\r\n        uint playerID = playerIDs[msg.sender]-1;\r\n        if(timePassed(playerID) < WAIT_TIME) {\r\n            playerMsgs[playerIDs[msg.sender]-1] = 2;\r\n            return;        \r\n        }\r\n        if(amount < players[playerID].treasury && amount > MIN_WTH) {\r\n            players[playerID].treasury -= amount;\r\n            totalBalances -= amount;\r\n            players[playerID].etherAddress.send((amount*99)/100); //keep 1% as commission\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    function getMyPlayerID() constant returns (int ID) {\r\n        return int(playerIDs[msg.sender])-1;\r\n    }\r\n    \r\n    function getMyMsg() constant returns (uint s) {\r\n        return playerMsgs[playerIDs[msg.sender]-1];\r\n    }\r\n    \r\n    function getCity(uint cityID) constant returns (uint owner, string cityName, bool[5] buildings, uint[10] units, uint[2] rowcol, int previousID, int nextID) {\r\n        return (cities[cityID].owner, cities[cityID].name, cities[cityID].buildings, cities[cityID].units, cities[cityID].rowcol, cities[cityID].previousID, cities[cityID].nextID);\r\n    }\r\n    \r\n    \r\n    function timePassed(uint playerID) constant returns (uint tp) {\r\n        return (now - players[playerID].lastTimestamp);\r\n    }\r\n\r\n\r\n    // Used only by the wizard to check his commission.\r\n    function getCommission() onlywizard constant returns (uint com) {\r\n        return this.balance-totalBalances;\r\n    }\r\n\r\n    // Used only by the wizard to collect his commission.\r\n    function sweepCommission(uint amount) onlywizard {\r\n        if(amount < this.balance-totalBalances) {\r\n            wizardAddress.send(amount);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    function setUtils(address a) onlywizard {\r\n        utilsAddress = a;\r\n    }\r\n    \r\n    function setUtils2(address a) onlywizard {\r\n        utilsAddress2 = a;\r\n    }\r\n    \r\n    function getPlayerID(address sender) onlyutils constant returns (uint playerID) {\r\n        if(int(playerIDs[sender])-1 < 0) {\r\n            throw;\r\n        }\r\n        return playerIDs[sender]-1;\r\n    }\r\n    \r\n    function getWwLength() constant returns (uint length) {\r\n        return woodworksCities.length;\r\n    }\r\n    \r\n    function getMwLength() constant returns (uint length) {\r\n        return metalworksCities.length;\r\n    }\r\n    \r\n    function getStLength() constant returns (uint length) {\r\n        return stablesCities.length;\r\n    }\r\n    \r\n    function getFmLength() constant returns (uint length) {\r\n        return farmCities.length;\r\n    }\r\n    \r\n    function getQrLength() constant returns (uint length) {\r\n        return quarryCities.length;\r\n    }\r\n    \r\n    \r\n    function setMsg(address sender, uint s) onlyutils {\r\n        playerMsgs[playerIDs[sender]-1] = s;\r\n    }\r\n    \r\n    function setNumCities(uint nc) onlyutils {\r\n        numCities = nc;\r\n    }\r\n    \r\n    function setUnit(uint cityID, uint i, uint unitType) onlyutils {\r\n        cities[cityID].units[i] = unitType;\r\n    }\r\n    \r\n    function setOwner(uint cityID, uint owner) onlyutils {\r\n        cities[cityID].owner = owner;\r\n    }\r\n    \r\n    function setName(uint cityID, string name) onlyutils {\r\n        cities[cityID].name = name;\r\n    }\r\n    \r\n    function setPreviousID(uint cityID, int previousID) onlyutils {\r\n        cities[cityID].previousID = previousID;\r\n    }\r\n    \r\n    function setNextID(uint cityID, int nextID) onlyutils {\r\n        cities[cityID].nextID = nextID;\r\n    }\r\n    \r\n    function setRowcol(uint cityID, uint[2] rowcol) onlyutils {\r\n        cities[cityID].rowcol = rowcol;\r\n    }\r\n    \r\n    function setMap(uint row, uint col, uint ind) onlyutils {\r\n        map[row][col] = ind;\r\n    }\r\n    \r\n    function setCapitol(uint playerID, uint capitol) onlyutils {\r\n        players[playerID].capitol = capitol;\r\n    }\r\n\r\n    function setNumUnits(uint playerID, uint numUnits) onlyutils {\r\n        players[playerID].numUnits = numUnits;\r\n    }\r\n    \r\n    function setNumCities(uint playerID, uint numCities) onlyutils {\r\n        players[playerID].numCities = numCities;\r\n    }\r\n    \r\n    function setTreasury(uint playerID, uint treasury) onlyutils {\r\n        players[playerID].treasury = treasury;\r\n    }\r\n    \r\n    function setLastTimestamp(uint playerID, uint timestamp) onlyutils {\r\n        players[playerID].lastTimestamp = timestamp;\r\n    }\r\n    \r\n    function setBuilding(uint cityID, uint buildingType) onlyutils {\r\n        cities[cityID].buildings[buildingType] = true;\r\n        if(buildingType == 0) {\r\n            quarryCities.push(cityID);\r\n        } else if(buildingType == 1) {\r\n            farmCities.push(cityID);\r\n        } else if(buildingType == 2) {\r\n            woodworksCities.push(cityID);\r\n        } else if(buildingType == 3) {\r\n            metalworksCities.push(cityID);\r\n        } else if(buildingType == 4) {\r\n            stablesCities.push(cityID);\r\n        }\r\n    }\r\n    \r\n    function pushCity() onlyutils {\r\n        city.buildings[0] = false;\r\n        city.buildings[1] = false;\r\n        cities.push(city);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract EtherizationUtils {\r\n    \r\n    //uint[2] sRowcol;\r\n    //uint[2] tRowcol;\r\n    \r\n    Etherization public e;\r\n    \r\n    address wizardAddress;\r\n    \r\n    // Used to ensure only the owner can do some things.\r\n    modifier onlywizard { if (msg.sender == wizardAddress) _ }\r\n    \r\n    \r\n    function EtherizationUtils() {\r\n        wizardAddress = msg.sender;\r\n    }\r\n    \r\n    function sete(address a) onlywizard {\r\n        e = Etherization(a);\r\n    }\r\n    \r\n    \r\n    function buyBuilding(uint cityID, uint buildingType) {\r\n        uint playerID = e.getPlayerID(msg.sender);\r\n        \r\n        if(e.timePassed(playerID) < e.WAIT_TIME()) {\r\n            e.setMsg(msg.sender, 2);\r\n            return;        \r\n        }\r\n        \r\n        uint owner;\r\n        (owner,) = e.cities(cityID);\r\n        if(playerID != owner || cityID > e.numCities()-1) {\r\n            e.setMsg(msg.sender, 3);\r\n            return;\r\n        }\r\n        if(buildingType<0 || buildingType>4) {\r\n            e.setMsg(msg.sender, 4);\r\n            return;            \r\n        }\r\n        bool[5] memory buildings;\r\n        uint[2] memory rowcol;\r\n        (,,buildings,,rowcol,,) = e.getCity(cityID);\r\n        if(buildings[buildingType]) {\r\n            e.setMsg(msg.sender, 5);\r\n            return; \r\n        }\r\n        uint treasury;\r\n        (,,treasury,,,,) = e.players(owner);\r\n        if(treasury < e.BUILDING_PRICE()) {\r\n            e.setMsg(msg.sender, 6);\r\n            return;\r\n        }\r\n\r\n        e.setTreasury(playerID, treasury-e.BUILDING_PRICE());\r\n        \r\n        // distribute build funds to production type building owners\r\n        uint productionCut;\r\n        uint i;\r\n        productionCut = e.BUILDING_PRICE() / e.getQrLength();\r\n        for(i=0; i < e.getQrLength(); i++) {\r\n           (owner,) = e.cities(e.quarryCities(i));\r\n           (,,treasury,,,,) = e.players(owner);\r\n           e.setTreasury(owner, treasury+productionCut);\r\n        }\r\n\r\n        e.setBuilding(cityID, buildingType);\r\n        \r\n        e.setMsg(msg.sender, 7 + rowcol[0]*100 + rowcol[1]*10000);\r\n        e.setLastTimestamp(playerID, now);\r\n    }\r\n    \r\n    function buyUnit(uint cityID, uint unitType) {\r\n        uint playerID = e.getPlayerID(msg.sender);\r\n        \r\n        if(e.timePassed(playerID) < e.WAIT_TIME()) {\r\n            e.setMsg(msg.sender, 2);\r\n            return;        \r\n        }\r\n        \r\n        uint owner;\r\n        (owner,) = e.cities(cityID);\r\n        if(playerID != owner || cityID > e.numCities()-1) {\r\n            e.setMsg(msg.sender, 8);\r\n            return;\r\n        }\r\n        if(unitType<1 || unitType>3) {\r\n            e.setMsg(msg.sender, 9);\r\n            return;            \r\n        }\r\n        uint numUnits;\r\n        uint treasury;\r\n        (,,treasury,,,numUnits,) = e.players(owner);\r\n        uint maint = numUnits*e.MAINT_PRICE();\r\n        if(treasury < e.UNIT_PRICE() + maint) {\r\n            e.setMsg(msg.sender, 10);\r\n            return;\r\n        }\r\n        if(unitType==1&&e.getWwLength()==0 || unitType==2&&e.getMwLength()==0 || unitType==3&&e.getStLength()==0) {\r\n            e.setMsg(msg.sender, 11);\r\n            return;\r\n        }\r\n        // try to add the unit at the last empty garrison spot\r\n        uint[10] memory units;\r\n        uint[2] memory rowcol;\r\n        (,,,units,rowcol,,) = e.getCity(cityID);\r\n        for(uint i=0; i < units.length; i++) {\r\n            if(units[i] < 1) {\r\n               e.setUnit(cityID, i, unitType);\r\n               e.setNumUnits(playerID, numUnits+1);\r\n               e.setTreasury(playerID, treasury-e.UNIT_PRICE()-maint);\r\n               // distribute build funds to production type building owners\r\n               uint productionCut;\r\n               uint j;\r\n               // pikemen\r\n               if(unitType == 1) {\r\n                   productionCut = e.UNIT_PRICE() / e.getWwLength();\r\n                   for(j=0; j < e.getWwLength(); j++) {\r\n                       (owner,) = e.cities(e.woodworksCities(j));\r\n                       (,,treasury,,,,) = e.players(owner);\r\n                       e.setTreasury(owner, treasury+productionCut);\r\n                   }\r\n               }\r\n               else if(unitType == 2) {\r\n                   productionCut = e.UNIT_PRICE() / e.getMwLength();\r\n                   for(j=0; j < e.getMwLength(); j++) {\r\n                       (owner,) = e.cities(e.metalworksCities(j));\r\n                       (,,treasury,,,,) = e.players(owner);\r\n                       e.setTreasury(owner, treasury+productionCut);\r\n                   }\r\n               }\r\n               else if(unitType == 3) {\r\n                   productionCut = e.UNIT_PRICE() / e.getStLength();\r\n                   for(j=0; j < e.getStLength(); j++) {\r\n                       (owner,) = e.cities(e.stablesCities(j));\r\n                       (,,treasury,,,,) = e.players(owner);\r\n                       e.setTreasury(owner, treasury+productionCut);\r\n                   }\r\n               }\r\n               // pay maintenance for all other units to farm owners\r\n               uint maintCut = maint / e.getFmLength();\r\n               for(j=0; j < e.getFmLength(); j++) {\r\n                   (owner,) = e.cities(e.farmCities(j));\r\n                   (,,treasury,,,,) = e.players(owner);\r\n                   e.setTreasury(owner, treasury+maintCut);\r\n               }\r\n               e.setMsg(msg.sender, 12 + rowcol[0]*100 + rowcol[1]*10000);\r\n               e.setLastTimestamp(playerID, now);\r\n               return;\r\n            }\r\n        }\r\n        e.setMsg(msg.sender, 13);\r\n    }\r\n    \r\n    function moveUnits(uint source, uint target, uint[] unitIndxs) {\r\n        uint[2] memory sRowcol;\r\n        uint[2] memory tRowcol;\r\n        uint[10] memory unitsS;\r\n        uint[10] memory unitsT;\r\n        \r\n        uint playerID = e.getPlayerID(msg.sender);\r\n        \r\n        if(e.timePassed(playerID) < e.WAIT_TIME()) {\r\n            e.setMsg(msg.sender, 2);\r\n            return;        \r\n        }\r\n\r\n        uint ownerS;\r\n        uint ownerT;\r\n        (ownerS,,,unitsS,sRowcol,,) = e.getCity(source);\r\n        (ownerT,,,unitsT,tRowcol,,) = e.getCity(target);\r\n        if(playerID != ownerS || playerID != ownerT || int(sRowcol[0])-int(tRowcol[0]) > int(1) || int(sRowcol[0])-int(tRowcol[0]) < int(-1) || int(sRowcol[1])-int(tRowcol[1]) > int(1) || int(sRowcol[1])-int(tRowcol[1]) < int(-1)) {\r\n        //if(playerID != ownerS || playerID != ownerT || source > e.numCities()-1 || target > e.numCities()-1) {\r\n        //if(playerID != ownerS || playerID != ownerT) {    \r\n            e.setMsg(msg.sender, 14);\r\n            return;\r\n        }\r\n        \r\n        uint j = 0;\r\n        for(uint i=0; i<unitIndxs.length; i++) {\r\n            if(unitsS[unitIndxs[i]] < 1) {\r\n                continue;   //skip for non-unit\r\n            }\r\n            for(; j<unitsT.length; j++) {\r\n                if(unitsT[j] == 0) {\r\n                    e.setUnit(target, j, unitsS[unitIndxs[i]]);\r\n                    unitsS[unitIndxs[i]] = 0;\r\n                    e.setUnit(source, unitIndxs[i], 0);\r\n                    j++;\r\n                    break;\r\n                }\r\n            }\r\n            if(j == unitsT.length) {\r\n                e.setMsg(msg.sender, 15);\r\n                e.setLastTimestamp(playerID, now);\r\n                return; //target city garrison filled\r\n            }\r\n        }\r\n        e.setMsg(msg.sender, 16);\r\n        e.setLastTimestamp(playerID, now);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"uint256\"},{\"name\":\"target\",\"type\":\"uint256\"},{\"name\":\"unitIndxs\",\"type\":\"uint256[]\"}],\"name\":\"moveUnits\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cityID\",\"type\":\"uint256\"},{\"name\":\"unitType\",\"type\":\"uint256\"}],\"name\":\"buyUnit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"sete\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cityID\",\"type\":\"uint256\"},{\"name\":\"buildingType\",\"type\":\"uint256\"}],\"name\":\"buyBuilding\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"e\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"EtherizationUtils","CompilerVersion":"v0.3.5-nightly.2016.8.8+commit.c3ed550","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}