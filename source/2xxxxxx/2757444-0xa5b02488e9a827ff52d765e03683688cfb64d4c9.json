{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n        \r\n    // total amount of tokens\r\n    uint totalSupply;\r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how much is \r\n     *               permitted to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permitted to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    // events notifications\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n    // token ownership\r\n    mapping (address => uint256) balances;\r\n\r\n    // spending permision management\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    \r\n    \r\n    function StandardToken(){\r\n    }\r\n    \r\n    \r\n    /**\r\n     * transfer() - transfer tokens from msg.sender balance \r\n     *              to requested account\r\n     *\r\n     *  @param to    - target address to transfer tokens\r\n     *  @param value - ammount of tokens to transfer\r\n     *\r\n     *  @return - success / failure of the transaction\r\n     */    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**\r\n     * transferFrom() - \r\n     *\r\n     *  @param from  - \r\n     *  @param to    - \r\n     *  @param value - \r\n     *\r\n     *  @return \r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how mouch is \r\n     *               permited to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permited to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n    // Name of the token    \r\n    string public name = \"HackerGold\";\r\n\r\n    // Decimal places\r\n    uint8  public decimals = 3;\r\n    // Token abbreviation        \r\n    string public symbol = \"HKG\";\r\n    \r\n    // 1 ether = 200 hkg\r\n    uint BASE_PRICE = 200;\r\n    // 1 ether = 150 hkg\r\n    uint MID_PRICE = 150;\r\n    // 1 ether = 100 hkg\r\n    uint FIN_PRICE = 100;\r\n    // Safety cap\r\n    uint SAFETY_LIMIT = 4000000 ether;\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    \r\n    // Total value in wei\r\n    uint totalValue;\r\n    \r\n    // Address of multisig wallet holding ether from sale\r\n    address wallet;\r\n\r\n    // Structure of sale increase milestones\r\n    struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }\r\n    // Milestones instance\r\n    milestones_struct milestones;\r\n    \r\n    /**\r\n     * Constructor of the contract.\r\n     * \r\n     * Passes address of the account holding the value.\r\n     * HackerGold contract itself does not hold any value\r\n     * \r\n     * @param multisig address of MultiSig wallet which will hold the value\r\n     */\r\n    function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function: called on ether sent.\r\n     * \r\n     * It calls to createHKG function with msg.sender \r\n     * as a value for holder argument\r\n     */\r\n    function () payable {\r\n        createHKG(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Creates HKG tokens.\r\n     * \r\n     * Runs sanity checks including safety cap\r\n     * Then calculates current price by getPrice() function, creates HKG tokens\r\n     * Finally sends a value of transaction to the wallet\r\n     * \r\n     * Note: due to lack of floating point types in Solidity,\r\n     * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n     * \r\n     * @param holder token holder\r\n     */\r\n    function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n    \r\n    /**\r\n     * Denotes complete price structure during the sale.\r\n     *\r\n     * @return HKG amount per 1 ETH for the current moment in time\r\n     */\r\n    function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }\r\n    \r\n    /**\r\n     * Returns total stored HKG amount.\r\n     * \r\n     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n     * Thus, result of this function should be divided by 1000 to get HKG value\r\n     * \r\n     * @return result stored HKG amount\r\n     */\r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n\r\n    /**\r\n     * It is used for test purposes.\r\n     * \r\n     * Returns the result of 'now' statement of Solidity language\r\n     * \r\n     * @return unix timestamp for current moment in time\r\n     */\r\n    function getNow() constant returns (uint result) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * Returns total value passed through the contract\r\n     * \r\n     * @return result total value in wei\r\n     */\r\n    function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * EventInfo - imutable class that denotes\r\n * the time of the virtual accelerator hack\r\n * event\r\n * \r\n */\r\ncontract EventInfo{\r\n    \r\n    \r\n    uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5;\r\n    uint constant T_1_WEEK = 60 * 60 * 24 * 7;\r\n\r\n    uint eventStart = 1479391200; // Thu, 17 Nov 2016 14:00:00 GMT\r\n    uint eventEnd = eventStart + HACKATHON_5_WEEKS;\r\n    \r\n    \r\n    /**\r\n     * getEventStart - return the start of the event time\r\n     */ \r\n    function getEventStart() constant returns (uint result){        \r\n       return eventStart;\r\n    } \r\n    \r\n    /**\r\n     * getEventEnd - return the end of the event time\r\n     */ \r\n    function getEventEnd() constant returns (uint result){        \r\n       return eventEnd;\r\n    } \r\n    \r\n    \r\n    /**\r\n     * getVotingStart - the voting starts 1 week after the \r\n     *                  event starts\r\n     */ \r\n    function getVotingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getTradingStart - the DST tokens trading starts 1 week \r\n     *                   after the event starts\r\n     */ \r\n    function getTradingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getNow - helper class to check what time the contract see\r\n     */\r\n    function getNow() constant returns (uint result){        \r\n       return now;\r\n    } \r\n    \r\n}\r\n\r\n/*\r\n * DSTContract - DST stands for decentralized startup team.\r\n *               the contract ensures funding for a decentralized\r\n *               team in 2 phases: \r\n *\r\n *                +. Funding by HKG during the hackathon event. \r\n *                +. Funding by Ether after the event is over. \r\n *\r\n *               After the funds been collected there is a governence\r\n *               mechanism managed by proposition to withdraw funds\r\n *               for development usage. \r\n *\r\n *               The DST ensures that backers of the projects keeps\r\n *               some influence on the project by ability to reject\r\n *               propositions they find as non effective. \r\n *\r\n *               In very radical occasions the backers may loose \r\n *               the trust in the team completelly, in that case \r\n *               there is an option to propose impeachment process\r\n *               completelly removing the execute and assigning new\r\n *               person to manage the funds. \r\n *\r\n */\r\ncontract DSTContract is StandardToken{\r\n\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    // Proposal lifetime\r\n    uint PROPOSAL_LIFETIME = 10 days;\r\n    // Proposal funds threshold, in percents\r\n    uint PROPOSAL_FUNDS_TH = 20;\r\n\r\n    address   executive; \r\n        \r\n    EventInfo eventInfo;\r\n    \r\n    // Indicated where the DST is traded\r\n    address virtualExchangeAddress;\r\n    \r\n    HackerGold hackerGold;\r\n        \r\n    mapping (address => uint256) votingRights;\r\n\r\n\r\n    // 1 - HKG => DST qty; tokens for 1 HKG\r\n    uint hkgPrice;\r\n    \r\n    // 1 - Ether => DST qty; tokens for 1 Ether\r\n    uint etherPrice;\r\n    \r\n    string public name = \"...\";                   \r\n    uint8  public decimals = 3;                 \r\n    string public symbol = \"...\";\r\n    \r\n    bool ableToIssueTokens = true; \r\n    \r\n    uint preferedQtySold;\r\n\r\n    uint collectedHKG; \r\n    uint collectedEther;    \r\n    \r\n    // Proposal of the funds spending\r\n    mapping (bytes32 => Proposal) proposals;\r\n\r\n    enum ProposalCurrency { HKG, ETHER }\r\n    ProposalCurrency enumDeclaration;\r\n                  \r\n       \r\n    struct Proposal{\r\n        \r\n        bytes32 id;\r\n        uint value;\r\n\r\n        string urlDetails;\r\n\r\n        uint votindEndTS;\r\n                \r\n        uint votesObjecting;\r\n        \r\n        address submitter;\r\n        bool redeemed;\r\n\r\n        ProposalCurrency proposalCurrency;\r\n        \r\n        mapping (address => bool) voted;\r\n    }\r\n    uint counterProposals;\r\n    uint timeOfLastProposal;\r\n    \r\n    Proposal[] listProposals;\r\n    \r\n\r\n    /**\r\n     * Impeachment process proposals\r\n     */    \r\n    struct ImpeachmentProposal{\r\n        \r\n        string urlDetails;\r\n        \r\n        address newExecutive;\r\n\r\n        uint votindEndTS;        \r\n        uint votesSupporting;\r\n        \r\n        mapping (address => bool) voted;        \r\n    }\r\n    ImpeachmentProposal lastImpeachmentProposal;\r\n\r\n        \r\n    /**\r\n     * \r\n     *  DSTContract: ctor for DST token and governence contract\r\n     *\r\n     *  @param eventInfoAddr EventInfo: address of object denotes events \r\n     *                                  milestones      \r\n     *  @param hackerGoldAddr HackerGold: address of HackerGold token\r\n     *\r\n     *  @param dstName string: dstName: real name of the team\r\n     *\r\n     *  @param dstSymbol string: 3 letter symbold of the team\r\n     *\r\n     */ \r\n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\r\n    \r\n      executive   = msg.sender;  \r\n      name        = dstName;\r\n      symbol      = dstSymbol;\r\n\r\n      hackerGold = HackerGold(hackerGoldAddr);\r\n      eventInfo  = EventInfo(eventInfoAddr);\r\n    }\r\n    \r\n\r\n    function() payable\r\n               onlyAfterEnd {\r\n        \r\n        // there is tokens left from hackathon \r\n        if (etherPrice == 0) throw;\r\n        \r\n        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\r\n        \r\n        // check if demand of tokens is \r\n        // overflow the supply \r\n        uint retEther = 0;\r\n        if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }\r\n        \r\n        \r\n        // do transfer\r\n        balances[msg.sender] += tokens;\r\n        balances[this] -= tokens;\r\n        \r\n        // count collected ether \r\n        collectedEther += msg.value - retEther; \r\n        \r\n        // rise event\r\n        BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens);\r\n        \r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     * setHKGPrice - set price: 1HKG => DST tokens qty\r\n     *\r\n     *  @param qtyForOneHKG uint: DST tokens for 1 HKG\r\n     * \r\n     */    \r\n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive  {\r\n         \r\n         hkgPrice = qtyForOneHKG;\r\n         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply);\r\n     }\r\n     \r\n     \r\n    \r\n    /**\r\n     * \r\n     * issuePreferedTokens - prefered tokens issued on the hackathon event\r\n     *                       grant special rights\r\n     *\r\n     *  @param qtyForOneHKG uint: price DST tokens for one 1 HKG\r\n     *  @param qtyToEmit uint: new supply of tokens \r\n     * \r\n     */\r\n    function issuePreferedTokens(uint qtyForOneHKG, \r\n                                 uint qtyToEmit) onlyExecutive \r\n                                                 onlyIfAbleToIssueTokens\r\n                                                 onlyBeforeEnd\r\n                                                 onlyAfterTradingStart {\r\n                \r\n        // no issuence is allowed before enlisted on the\r\n        // exchange \r\n        if (virtualExchangeAddress == 0x0) throw;\r\n            \r\n        totalSupply    += qtyToEmit;\r\n        balances[this] += qtyToEmit;\r\n        hkgPrice = qtyForOneHKG;\r\n        \r\n        \r\n        // now spender can use balance in \r\n        // amount of value from owner balance\r\n        allowed[this][virtualExchangeAddress] += qtyToEmit;\r\n        \r\n        // rise event about the transaction\r\n        Approval(this, virtualExchangeAddress, qtyToEmit);\r\n        \r\n        // rise event \r\n        DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    /**\r\n     * \r\n     * buyForHackerGold - on the hack event this function is available \r\n     *                    the buyer for hacker gold will gain votes to \r\n     *                    influence future proposals on the DST\r\n     *    \r\n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \r\n     * \r\n     */\r\n    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \r\n                                             returns (bool success) {\r\n    \r\n      // validate that the caller is official accelerator HKG Exchange\r\n      if (msg.sender != virtualExchangeAddress) throw;\r\n      \r\n      \r\n      // transfer token \r\n      address sender = tx.origin;\r\n      uint tokensQty = hkgValue * hkgPrice;\r\n\r\n      // gain voting rights\r\n      votingRights[sender] +=tokensQty;\r\n      preferedQtySold += tokensQty;\r\n      collectedHKG += hkgValue;\r\n\r\n      // do actual transfer\r\n      transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty);\r\n      transfer(sender, tokensQty);        \r\n            \r\n      // rise event       \r\n      BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty);\r\n        \r\n      return true;\r\n    }\r\n        \r\n    \r\n    /**\r\n     * \r\n     * issueTokens - function will issue tokens after the \r\n     *               event, able to sell for 1 ether \r\n     * \r\n     *  @param qtyForOneEther uint: DST tokens for 1 ETH\r\n     *  @param qtyToEmit uint: new tokens supply\r\n     *\r\n     */\r\n    function issueTokens(uint qtyForOneEther, \r\n                         uint qtyToEmit) onlyAfterEnd \r\n                                         onlyExecutive\r\n                                         onlyIfAbleToIssueTokens {\r\n         \r\n         balances[this] += qtyToEmit;\r\n         etherPrice = qtyForOneEther;\r\n         totalSupply    += qtyToEmit;\r\n         \r\n         // rise event  \r\n         DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit);\r\n    }\r\n     \r\n    \r\n    /**\r\n     * setEtherPrice - change the token price\r\n     *\r\n     *  @param qtyForOneEther uint: new price - DST tokens for 1 ETH\r\n     */     \r\n    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\r\n                                                onlyExecutive {\r\n         etherPrice = qtyForOneEther; \r\n\r\n         // rise event for this\r\n         NewEtherPrice(qtyForOneEther);\r\n    }    \r\n    \r\n\r\n    /**\r\n     *  disableTokenIssuance - function will disable any \r\n     *                         option for future token \r\n     *                         issuence\r\n     */\r\n    function disableTokenIssuance() onlyExecutive {\r\n        ableToIssueTokens = false;\r\n        \r\n        DisableTokenIssuance();\r\n    }\r\n\r\n    \r\n    /**\r\n     *  burnRemainToken -  eliminated all available for sale\r\n     *                     tokens. \r\n     */\r\n    function burnRemainToken() onlyExecutive {\r\n    \r\n        totalSupply -= balances[this];\r\n        balances[this] = 0;\r\n        \r\n        // rise event for this\r\n        BurnedAllRemainedTokens();\r\n    }\r\n    \r\n    /**\r\n     *  submitEtherProposal: submit proposal to use part of the \r\n     *                       collected ether funds\r\n     *\r\n     *   @param requestValue uint: value in wei \r\n     *   @param url string: details of the proposal \r\n     */ \r\n    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \r\n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \r\n    \r\n        // ensure there is no more issuence available \r\n        if (ableToIssueTokens) throw;\r\n            \r\n        // ensure there is no more tokens available \r\n        if (balanceOf(this) > 0) throw;\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n            \r\n        uint percent = collectedEther / 100;\r\n            \r\n        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\r\n\r\n        // if remained value is less than requested gain all.\r\n        if (requestValue > this.balance) \r\n            requestValue = this.balance;    \r\n            \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n            \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n            \r\n        timeOfLastProposal = now;                        \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);\r\n    }\r\n    \r\n    \r\n     \r\n    /**\r\n     * \r\n     * submitHKGProposal - submit proposal to request for \r\n     *                     partial HKG funds collected \r\n     * \r\n     *  @param requestValue uint: value in HKG to request. \r\n     *  @param url string: url with details on the proposition \r\n     */\r\n    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\r\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\r\n        \r\n\r\n        // If there is no 2 months over since the last event.\r\n        // There is no posible to get any HKG. After 2 months\r\n        // all the HKG is available. \r\n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n\r\n        uint percent = preferedQtySold / 100;\r\n        \r\n        // validate the amount is legit\r\n        // first 5 proposals should be less than 20% \r\n        if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\r\n                \r\n        // if remained value is less than requested \r\n        // gain all.\r\n        if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned();\r\n        \r\n        \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n        \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n        \r\n        ++counterProposals;\r\n        timeOfLastProposal = now;                \r\n                \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);        \r\n    }  \r\n    \r\n    \r\n    \r\n    /**\r\n     * objectProposal - object previously submitted proposal, \r\n     *                  the objection right is obtained by \r\n     *                  purchasing prefered tokens on time of \r\n     *                  the hackathon.\r\n     * \r\n     *  @param id bytes32 : the id of the proposla to redeem\r\n     */\r\n     function objectProposal(bytes32 id){\r\n         \r\n        Proposal memory proposal = proposals[id];\r\n         \r\n        // check proposal exist \r\n        if (proposals[id].id == 0) throw;\r\n\r\n        // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n         \r\n        // ensure objection time\r\n        if (now >= proposals[id].votindEndTS) throw;\r\n         \r\n        // ensure not voted  \r\n        if (proposals[id].voted[msg.sender]) throw;\r\n         \r\n         // submit votes\r\n         uint votes = votingRights[msg.sender];\r\n         proposals[id].votesObjecting += votes;\r\n         \r\n         // mark voted \r\n         proposals[id].voted[msg.sender] = true; \r\n         \r\n         uint idx = getIndexByProposalId(id);\r\n         listProposals[idx] = proposals[id];   \r\n\r\n         ObjectedVote(id, msg.sender, votes);         \r\n     }\r\n     \r\n     \r\n     function getIndexByProposalId(bytes32 id) returns (uint result){\r\n         \r\n         for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }\r\n     }\r\n    \r\n    \r\n   \r\n    /**\r\n     * redeemProposalFunds - redeem funds requested by prior \r\n     *                       submitted proposal     \r\n     * \r\n     * @param id bytes32: the id of the proposal to redeem\r\n     */\r\n    function redeemProposalFunds(bytes32 id) onlyExecutive {\r\n\r\n        if (proposals[id].id == 0) throw;\r\n        if (proposals[id].submitter != msg.sender) throw;\r\n\r\n        // ensure objection time\r\n        if (now < proposals[id].votindEndTS) throw;\r\n                           \r\n    \r\n            // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n\r\n        // check votes objection => 55% of total votes\r\n        uint objectionThreshold = preferedQtySold / 100 * 55;\r\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\r\n    \r\n    \r\n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }\r\n        \r\n        // execute the proposal \r\n        proposals[id].redeemed = true; \r\n    }\r\n    \r\n    \r\n    /**\r\n     *  getAllTheFunds - to ensure there is no deadlock can \r\n     *                   can happen, and no case that voting \r\n     *                   structure will freeze the funds forever\r\n     *                   the startup will be able to get all the\r\n     *                   funds without a proposal required after\r\n     *                   6 months.\r\n     * \r\n     * \r\n     */             \r\n    function getAllTheFunds() onlyExecutive {\r\n        \r\n        // If there is a deadlock in voting participates\r\n        // the funds can be redeemed completelly in 6 months\r\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }  \r\n        \r\n        // all the Ether\r\n        bool success = msg.sender.send(this.balance);        \r\n        \r\n        // all the HKG\r\n        hackerGold.transfer(msg.sender, getHKGOwned());              \r\n    }\r\n    \r\n    \r\n    /**\r\n     * submitImpeachmentProposal - submit request to switch \r\n     *                             executive.\r\n     * \r\n     *  @param urlDetails  - details of the impeachment proposal \r\n     *  @param newExecutive - address of the new executive \r\n     * \r\n     */             \r\n     function submitImpeachmentProposal(string urlDetails, address newExecutive){\r\n         \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n         \r\n        // the submission of the first impeachment \r\n        // proposal is possible only after 3 months\r\n        // since the hackathon is over\r\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\r\n        \r\n                \r\n        // check there is 1 months over since last one\r\n        if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\r\n\r\n\r\n        // submit impeachment proposal\r\n        // add the votes of the submitter \r\n        // to the proposal right away\r\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n         \r\n        // rise event\r\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\r\n     }\r\n    \r\n    \r\n    /**\r\n     * supportImpeachment - vote for impeachment proposal \r\n     *                      that is currently in progress\r\n     *\r\n     */\r\n    function supportImpeachment(){\r\n\r\n        // ensure that support is for exist proposal \r\n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\r\n    \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n        \r\n        // check if not voted already \r\n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\r\n        \r\n        // check if not finished the 2 weeks of voting \r\n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\r\n                \r\n        // support the impeachment\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\r\n\r\n        // rise impeachment suppporting event\r\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\r\n        \r\n        // if the vote is over 70% execute the switch \r\n        uint percent = preferedQtySold / 100; \r\n        \r\n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }\r\n        \r\n    } \r\n    \r\n      \r\n    \r\n    // **************************** //\r\n    // *     Constant Getters     * //\r\n    // **************************** //\r\n    \r\n    function votingRightsOf(address _owner) constant returns (uint256 result) {\r\n        result = votingRights[_owner];\r\n    }\r\n    \r\n    function getPreferedQtySold() constant returns (uint result){\r\n        return preferedQtySold;\r\n    }\r\n    \r\n    function setVirtualExchange(address virtualExchangeAddr){\r\n        virtualExchangeAddress = virtualExchangeAddr;\r\n    }\r\n\r\n    function getHKGOwned() constant returns (uint result){\r\n        return hackerGold.balanceOf(this);\r\n    }\r\n    \r\n    function getEtherValue() constant returns (uint result){\r\n        return this.balance;\r\n    }\r\n    \r\n    function getExecutive() constant returns (address result){\r\n        return executive;\r\n    }\r\n    \r\n    function getHKGPrice() constant returns (uint result){\r\n        return hkgPrice;\r\n    }\r\n\r\n    function getEtherPrice() constant returns (uint result){\r\n        return etherPrice;\r\n    }\r\n    \r\n    function getDSTName() constant returns(string result){\r\n        return name;\r\n    }    \r\n    \r\n    function getDSTNameBytes() constant returns(bytes32 result){\r\n        return convert(name);\r\n    }    \r\n\r\n    function getDSTSymbol() constant returns(string result){\r\n        return symbol;\r\n    }    \r\n    \r\n    function getDSTSymbolBytes() constant returns(bytes32 result){\r\n        return convert(symbol);\r\n    }    \r\n\r\n    function getAddress() constant returns (address result) {\r\n        return this;\r\n    }\r\n    \r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n        \r\n    function getCollectedEther() constant returns (uint results) {        \r\n        return collectedEther;\r\n    }\r\n    \r\n    function getCounterProposals() constant returns (uint result){\r\n        return counterProposals;\r\n    }\r\n        \r\n    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\r\n        return listProposals[i].id;\r\n    }    \r\n\r\n    function getProposalObjectionByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].votesObjecting;\r\n    }\r\n\r\n    function getProposalValueByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].value;\r\n    }                  \r\n    \r\n    function getCurrentImpeachmentUrlDetails() constant returns (string result){\r\n        return lastImpeachmentProposal.urlDetails;\r\n    }\r\n    \r\n    \r\n    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\r\n        return lastImpeachmentProposal.votesSupporting;\r\n    }\r\n    \r\n    function convert(string key) returns (bytes32 ret) {\r\n            if (bytes(key).length > 32) {\r\n                throw;\r\n            }      \r\n\r\n            assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }    \r\n    \r\n    \r\n    \r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //    \r\n \r\n    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\r\n    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\r\n    \r\n    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\r\n    \r\n    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\r\n                                       \r\n    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \r\n    \r\n\r\n    // ****************** //\r\n    // *     Events     * //\r\n    // ****************** //        \r\n\r\n    \r\n    event PriceHKGChange(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply);\r\n    event BuyForHKGTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount);\r\n    event BuyForEtherTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount);\r\n\r\n    event DstTokensIssued(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit);\r\n    \r\n    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\r\n    \r\n    event EtherRedeemAccepted(address sender, uint value);\r\n    \r\n    event ObjectedVote(bytes32 id, address voter, uint votes);\r\n    \r\n    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\r\n    event ImpeachmentSupport(address supportter, uint votes);\r\n    \r\n    event ImpeachmentAccepted(address newExecutive);\r\n\r\n    event NewEtherPrice(uint newQtyForOneEther);\r\n    event DisableTokenIssuance();\r\n    \r\n    event BurnedAllRemainedTokens();\r\n    \r\n}\r\n\r\n\r\n \r\n\r\n/**\r\n *  VirtualExchange -  The exchange is a trading system used\r\n *                     on hack.ether.camp hackathon event to \r\n *                     support trading a DST tokens for HKG. \r\n *                    \r\n */\r\ncontract VirtualExchange{\r\n\r\n    address owner;  \r\n    EventInfo eventInfo;\r\n \r\n    mapping (bytes32 => address) dstListed;\r\n    \r\n    HackerGold hackerGold;\r\n    \r\n    function VirtualExchange(address hackerGoldAddr, address eventInfoAddr){\r\n    \r\n        owner = msg.sender;\r\n        hackerGold = HackerGold(hackerGoldAddr);\r\n        eventInfo  = EventInfo(eventInfoAddr);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * enlist - enlisting one decentralized startup team to \r\n     *          the hack event virtual exchange, making the \r\n     *          DST initated tokens available for acquisition.\r\n     * \r\n     *  @param dstAddress - address of the DSTContract \r\n     * \r\n     */ \r\n    function enlist(address dstAddress) onlyBeforeEnd {\r\n\r\n        DSTContract dstContract = DSTContract(dstAddress);\r\n\r\n        bytes32 symbolBytes = dstContract.getDSTSymbolBytes();\r\n\r\n        /* Don't enlist 2 with the same name */\r\n        if (isExistByBytes(symbolBytes)) throw;\r\n\r\n        // Only owner of the DST can deploy the DST \r\n        if (dstContract.getExecutive() != msg.sender) throw;\r\n\r\n        // All good enlist the company\r\n        dstListed[symbolBytes] = dstAddress;\r\n        \r\n        // Indicate to DST which Virtual Exchange is enlisted\r\n        dstContract.setVirtualExchange(address(this));\r\n        \r\n        // rise Enlisted event\r\n        Enlisted(dstAddress);\r\n    }\r\n    \r\n   \r\n\r\n    /**\r\n     *\r\n     * buy - on the hackathon timeframe that is the function \r\n     *       that will be the way to buy specific tokens for \r\n     *       startup.\r\n     * \r\n     * @param companyNameBytes - the company that is enlisted on the exchange \r\n     *                           and the tokens are available\r\n     * \r\n     * @param hkg - the ammount of hkg to spend for aquastion \r\n     *\r\n     */\r\n    function buy(bytes32 companyNameBytes, uint hkg) onlyBeforeEnd\r\n                                               returns (bool success) {\r\n\r\n    \r\n        // check DST exist \r\n        if (!isExistByBytes(companyNameBytes)) throw;\r\n\r\n        // validate availability  \r\n        DSTContract dstContract = DSTContract(dstListed[companyNameBytes]);\r\n        uint tokensQty = hkg * dstContract.getHKGPrice();\r\n\r\n        address veAddress = address(this);        \r\n        \r\n        // ensure that there is HKG balance\r\n        uint valueHKGOwned = hackerGold.balanceOf(msg.sender);        \r\n        if (valueHKGOwned < hkg) throw;        \r\n        \r\n        // ensure that there is HKG token allowed to be spend\r\n        uint valueAvailbeOnExchange = hackerGold.allowance(msg.sender, veAddress);\r\n        if (valueAvailbeOnExchange < hkg) throw;\r\n\r\n        // ensure there is DST tokens for sale\r\n        uint dstTokens = dstContract.allowance(dstContract, veAddress);\r\n        if (dstTokens < hkg * dstContract.getHKGPrice()) throw;    \r\n                        \r\n        // Transfer HKG to Virtual Exchange account  \r\n        hackerGold.transferFrom(msg.sender, veAddress, hkg);\r\n\r\n        // Transfer to dstCotract ownership\r\n        hackerGold.transfer(dstContract.getAddress(), hkg);         \r\n        \r\n        // Call DST to transfer tokens \r\n        dstContract.buyForHackerGold(hkg);            \r\n    }\r\n        \r\n\r\n    // **************************** //\r\n    // *     Constant Getters     * //\r\n    // **************************** //        \r\n    \r\n\r\n    function isExistByBytes(bytes32 companyNameBytes) constant returns (bool result) {\r\n            \r\n        if (dstListed[companyNameBytes] == 0x0) \r\n            return false;\r\n        else \r\n            return true;                  \r\n    }\r\n    \r\n    function getEventStart() constant eventInfoSet returns (uint result){\r\n        return eventInfo.getEventStart();\r\n    }\r\n\r\n    function getEventEnd() constant eventInfoSet returns (uint result){\r\n        return eventInfo.getEventEnd();\r\n    }\r\n    \r\n    function getNow() constant returns (uint result){\r\n        return now;\r\n    }\r\n    \r\n\r\n\r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //        \r\n    \r\n\r\n    modifier onlyOwner()    { if (msg.sender != owner)        throw; _; }\r\n    modifier eventInfoSet() { if (eventInfo  == address(0))   throw; _; }\r\n    \r\n    modifier onlyBeforeEnd() { if (now  >= eventInfo.getEventEnd()) throw; _; }\r\n    modifier onlyAfterEnd()  { if (now  <  eventInfo.getEventEnd()) throw; _; }\r\n    \r\n\r\n    // ****************** //\r\n    // *     Events     * //\r\n    // ****************** //        \r\n    \r\n    event Enlisted(address indexed dstContract);\r\n    \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"companyNameBytes\",\"type\":\"bytes32\"},{\"name\":\"hkg\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dstAddress\",\"type\":\"address\"}],\"name\":\"enlist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventStart\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventEnd\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"companyNameBytes\",\"type\":\"bytes32\"}],\"name\":\"isExistByBytes\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"hackerGoldAddr\",\"type\":\"address\"},{\"name\":\"eventInfoAddr\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dstContract\",\"type\":\"address\"}],\"name\":\"Enlisted\",\"type\":\"event\"}]","ContractName":"VirtualExchange","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b582baaf5e749d6aa98a22355a9d08b4c4d013c80000000000000000000000001c3c643f49be262c3040e917e7d2299b9bc081a1","Library":"","SwarmSource":""}]}