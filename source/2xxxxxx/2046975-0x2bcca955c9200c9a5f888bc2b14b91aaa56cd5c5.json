{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\nEtherandom v1.0 [API]\r\n\r\nCopyright (c) 2016, Etherandom [etherandom.com]\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n    * Neither the name of the <organization> nor the\r\n      names of its contributors may be used to endorse or promote products\r\n      derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL ETHERANDOM BE LIABLE FOR ANY\r\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \r\n\r\n*/\r\n\r\ncontract EtherandomI {\r\n  address public addr;\r\n  function seed() returns (bytes32 _id);\r\n  function seedWithGasLimit(uint _gasLimit) returns (bytes32 _id);\r\n  function exec(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality) returns (bytes32 _id);\r\n  function execWithGasLimit(bytes32 _serverSeedHash, bytes32 _clientSeed, uint _cardinality, uint _gasLimit) returns (bytes32 _id);\r\n  function getSeedCost(uint _gasLimit) constant returns (uint _cost);\r\n  function getExecCost(uint _gasLimit) constant returns (uint _cost);\r\n  function getMinimumGasLimit() constant returns (uint _minimumGasLimit);\r\n}\r\n\r\ncontract EtherandomProxyI {\r\n  function getContractAddress() constant returns (address _addr); \r\n  function getCallbackAddress() constant returns (address _addr); \r\n}\r\n\r\ncontract EtherandomizedI {\r\n  function onEtherandomSeed(bytes32 _id, bytes32 serverSeedHash);\r\n  function onEtherandomExec(bytes32 _id, bytes32 serverSeed, uint randomNumber);\r\n}\r\n\r\ncontract etherandomized {\r\n  EtherandomProxyI EAR;\r\n  EtherandomI etherandom;\r\n\r\n  modifier etherandomAPI {\r\n    address addr = EAR.getContractAddress();\r\n    if (addr == 0) {\r\n      etherandomSetNetwork();\r\n      addr = EAR.getContractAddress();\r\n    }\r\n    etherandom = EtherandomI(addr);\r\n    _\r\n  }\r\n\r\n  function etherandomSetNetwork() internal returns (bool) {\r\n    if (getCodeSize(0x5be0372559e0275c0c415ab48eb0e211bc2f52a8)>0){\r\n      EAR = EtherandomProxyI(0x5be0372559e0275c0c415ab48eb0e211bc2f52a8);\r\n      return true;\r\n    }\r\n    if (getCodeSize(0xf6d9979499491c1c0c9ef518860f4476c1cd551a)>0){\r\n      EAR = EtherandomProxyI(0xf6d9979499491c1c0c9ef518860f4476c1cd551a);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function getCodeSize(address _addr) constant internal returns (uint _size) {\r\n    assembly { _size := extcodesize(_addr) }\r\n  }\r\n\r\n  function etherandomSeed() etherandomAPI internal returns (bytes32 _id) {\r\n    uint cost = etherandom.getSeedCost(etherandom.getMinimumGasLimit());\r\n    return etherandom.seed.value(cost)();\r\n  }\r\n\r\n  function etherandomSeedWithGasLimit(uint gasLimit) etherandomAPI internal returns (bytes32 _id) {\r\n    uint cost = etherandom.getSeedCost(gasLimit);\r\n    return etherandom.seedWithGasLimit.value(cost)(gasLimit);\r\n  }\r\n\r\n  function etherandomExec(bytes32 serverSeedHash, bytes32 clientSeed, uint cardinality) etherandomAPI internal returns (bytes32 _id) {\r\n    uint cost = etherandom.getExecCost(etherandom.getMinimumGasLimit());\r\n    return etherandom.exec.value(cost)(serverSeedHash, clientSeed, cardinality);\r\n  }\r\n\r\n  function etherandomExecWithGasLimit(bytes32 serverSeedHash, bytes32 clientSeed, uint cardinality, uint gasLimit) etherandomAPI internal returns (bytes32 _id) {\r\n    uint cost = etherandom.getExecCost(gasLimit);\r\n    return etherandom.execWithGasLimit.value(cost)(serverSeedHash, clientSeed, cardinality, gasLimit);\r\n  }\r\n  \r\n  function etherandomCallbackAddress() internal returns (address _addr) {\r\n    return EAR.getCallbackAddress();\r\n  }\r\n\r\n  function etherandomVerify(bytes32 serverSeedHash, bytes32 serverSeed, bytes32 clientSeed, uint cardinality, uint randomNumber) internal returns (bool _verified) {\r\n    if (sha3(serverSeed) != serverSeedHash) return false;\r\n    uint num = addmod(uint(serverSeed), uint(clientSeed), cardinality);\r\n    return num == randomNumber;\r\n  }\r\n\r\n  function() {\r\n    throw;\r\n  }\r\n}\r\n\r\n\r\ncontract Dice is etherandomized {\r\n  struct Roll {\r\n    address bettor;\r\n    bytes32 clientSeed;\r\n  }\r\n\r\n  address owner;\r\n  uint pendingAmount;\r\n  mapping (bytes32 => Roll) pendingSeed;\r\n  mapping (bytes32 => Roll) pendingExec;\r\n  mapping (bytes32 => bytes32) serverSeedHashes;\r\n\r\n  function Dice() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function getAvailable() returns (uint _available) {\r\n    return this.balance - pendingAmount;\r\n  }\r\n\r\n  function roll() {\r\n    rollWithSeed(\"\");\r\n  }\r\n\r\n  function rollWithSeed(bytes32 clientSeed) {\r\n    if ( (msg.value != 1) || (getAvailable() < 2)) throw;\r\n    bytes32 _id = etherandomSeed();\r\n    pendingSeed[_id] = Roll({bettor: msg.sender, clientSeed: clientSeed});\r\n    pendingAmount = pendingAmount + 2;\r\n  }\r\n\r\n  function onEtherandomSeed(bytes32 _id, bytes32 serverSeedHash) {\r\n    if (msg.sender != etherandomCallbackAddress()) throw;\r\n    Roll roll = pendingSeed[_id];\r\n    bytes32 _execID = etherandomExec(serverSeedHash, roll.clientSeed, 100);\r\n    pendingExec[_execID] = roll;\r\n    serverSeedHashes[_execID] = serverSeedHash;\r\n    delete pendingSeed[_id];\r\n  }\r\n\r\n  function onEtherandomExec(bytes32 _id, bytes32 serverSeed, uint randomNumber) {\r\n    if (msg.sender != etherandomCallbackAddress()) throw;\r\n    Roll roll = pendingExec[_id];\r\n    bytes32 serverSeedHash = serverSeedHashes[_id];\r\n\r\n    pendingAmount = pendingAmount - 2;\r\n\r\n    if (etherandomVerify(serverSeedHash, serverSeed, roll.clientSeed, 100, randomNumber)) {\r\n      if (randomNumber < 50) roll.bettor.send(2);\r\n    } else {\r\n      roll.bettor.send(1);\r\n    }\r\n    \r\n    delete serverSeedHashes[_id];\r\n    delete pendingExec[_id];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"serverSeedHash\",\"type\":\"bytes32\"}],\"name\":\"onEtherandomSeed\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clientSeed\",\"type\":\"bytes32\"}],\"name\":\"rollWithSeed\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"roll\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"serverSeed\",\"type\":\"bytes32\"},{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"onEtherandomExec\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getAvailable\",\"outputs\":[{\"name\":\"_available\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"Dice","CompilerVersion":"v0.3.5-2016-08-08-c3ed550","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}