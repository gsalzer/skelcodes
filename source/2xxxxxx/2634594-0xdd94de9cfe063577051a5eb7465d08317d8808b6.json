{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n\r\nlibrary ECVerifyLib {\r\n    // From: https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    function ecrecovery(bytes32 hash, bytes sig) returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n          return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28]\r\n        //\r\n        // geth uses [0, 1] and some clients have followed. This might change, see:\r\n        //  https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27)\r\n          v += 27;\r\n\r\n        if (v != 27 && v != 28)\r\n            return (false, 0);\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function ecverify(bytes32 hash, bytes sig, address signer) returns (bool) {\r\n        bool ret;\r\n        address addr;\r\n        (ret, addr) = ecrecovery(hash, sig);\r\n        return ret == true && addr == signer;\r\n    }\r\n}\r\n\r\n\r\ncontract IndividualityTokenInterface {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Mint(address indexed _owner, bytes32 _tokenID);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /*\r\n     * Read storage functions\r\n     */\r\n\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    /*\r\n     *  Write storage functions\r\n     */\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transfer(address _to) public returns (bool success);\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to) public returns (bool success);\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function approve(address _spender) public returns (bool success);\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool);\r\n\r\n    /// @dev Returns the address of the owner of the given token id.\r\n    /// @param _tokenID Bytes32 id of token to lookup.\r\n    function ownerOf(bytes32 _tokenID) constant returns (address owner);\r\n\r\n    /// @dev Returns the token ID for the given address or 0x0 if they are not a token owner.\r\n    /// @param _owner Address of the owner to lookup.\r\n    function tokenId(address _owner) constant returns (bytes32 tokenID);\r\n}\r\n\r\n\r\ncontract IndividualityTokenRootInterface is IndividualityTokenInterface {\r\n    /// @dev Imports a token from the Devcon2Token contract.\r\n    function upgrade() public returns (bool success);\r\n\r\n    /// @dev Upgrades a token from the previous contract\r\n    /// @param _owner the address of the owner of the token on the original contract\r\n    /// @param _newOwner the address that should own the token on the new contract.\r\n    /// @param signature 65 byte signature of the tightly packed bytes (address(this) + _owner + _newOwner), signed by _owner\r\n    function proxyUpgrade(address _owner,\r\n                          address _newOwner,\r\n                          bytes signature) public returns (bool);\r\n\r\n    /// @dev Returns the number of tokens that have been upgraded.\r\n    function upgradeCount() constant returns (uint256 amount);\r\n\r\n    /// @dev Returns the number of tokens that have been upgraded.\r\n    /// @param _tokenID the id of the token to query\r\n    function isTokenUpgraded(bytes32 _tokenID) constant returns (bool isUpgraded);\r\n}\r\n\r\n\r\nlibrary TokenEventLib {\r\n    /*\r\n     * When underlying solidity issue is fixed this library will not be needed.\r\n     * https://github.com/ethereum/solidity/issues/1215\r\n     */\r\n    event Transfer(address indexed _from,\r\n                   address indexed _to,\r\n                   bytes32 indexed _tokenID);\r\n    event Approval(address indexed _owner,\r\n                   address indexed _spender,\r\n                   bytes32 indexed _tokenID);\r\n\r\n    function _Transfer(address _from, address _to, bytes32 _tokenID) public {\r\n        Transfer(_from, _to, _tokenID);\r\n    }\r\n\r\n    function _Approval(address _owner, address _spender, bytes32 _tokenID) public {\r\n        Approval(_owner, _spender, _tokenID);\r\n    }\r\n}\r\n\r\n\r\ncontract TokenInterface {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Mint(address indexed _to, bytes32 _id);\r\n    event Destroy(bytes32 _id);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event MinterAdded(address who);\r\n    event MinterRemoved(address who);\r\n\r\n    /*\r\n     *  Minting\r\n     */\r\n    /// @dev Mints a new token.\r\n    /// @param _to Address of token owner.\r\n    /// @param _identity String for owner identity.\r\n    function mint(address _to, string _identity) returns (bool success);\r\n\r\n    /// @dev Destroy a token\r\n    /// @param _id Bytes32 id of the token to destroy.\r\n    function destroy(bytes32 _id) returns (bool success);\r\n\r\n    /// @dev Add a new minter\r\n    /// @param who Address the address that can now mint tokens.\r\n    function addMinter(address who) returns (bool);\r\n\r\n    /// @dev Remove a minter\r\n    /// @param who Address the address that will no longer be a minter.\r\n    function removeMinter(address who) returns (bool);\r\n\r\n    /*\r\n     *  Read and write storage functions\r\n     */\r\n\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() returns (uint supply);\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transfer(address _to, bytes32 _value) returns (bool success);\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, bytes32 _value) returns (bool success);\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function approve(address _spender, bytes32 _value) returns (bool success);\r\n\r\n    /*\r\n     * Read storage functions\r\n     */\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool);\r\n\r\n    /// @dev Returns the identity of the given token id.\r\n    /// @param _id Bytes32 id of token to lookup.\r\n    function identityOf(bytes32 _id) constant returns (string identity);\r\n\r\n    /// @dev Returns the address of the owner of the given token id.\r\n    /// @param _id Bytes32 id of token to lookup.\r\n    function ownerOf(bytes32 _id) constant returns (address owner);\r\n}\r\n\r\n\r\ncontract IndividualityTokenRoot is IndividualityTokenRootInterface {\r\n    TokenInterface public devcon2Token;\r\n\r\n    function IndividualityTokenRoot(address _devcon2Token) {\r\n        devcon2Token = TokenInterface(_devcon2Token);\r\n    }\r\n\r\n    // owner => token\r\n    mapping (address => bytes32) ownerToToken;\r\n\r\n    // token => owner\r\n    mapping (bytes32 => address) tokenToOwner;\r\n\r\n    // owner => spender => token\r\n    mapping (address => mapping (address => bytes32)) approvals;\r\n\r\n    uint _upgradeCount;\r\n\r\n    /*\r\n     * Internal Helpers\r\n     */\r\n    function isEligibleForUpgrade(address _owner) internal returns (bool) {\r\n        if (ownerToToken[_owner] != 0x0) {\r\n            // already a token owner\r\n            return false;\r\n        } else if (!devcon2Token.isTokenOwner(_owner)) {\r\n            // not a token owner on the original devcon2Token contract.\r\n            return false;\r\n        } else if (isTokenUpgraded(bytes32(devcon2Token.balanceOf(_owner)))) {\r\n            // the token has already been upgraded.\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Any function modified with this will perform the `upgrade` call prior to\r\n     * execution which allows people to use this contract as-if they had\r\n     * already processed the upgrade.\r\n     */\r\n    modifier silentUpgrade {\r\n        if (isEligibleForUpgrade(msg.sender)) {\r\n            upgrade();\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() constant returns (uint256) {\r\n        return devcon2Token.totalSupply();\r\n    }\r\n\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        if (_owner == 0x0) {\r\n            return 0;\r\n        } else if (ownerToToken[_owner] == 0x0) {\r\n            // not a current token owner.  Check whether they are on the\r\n            // original contract.\r\n            if (devcon2Token.isTokenOwner(_owner)) {\r\n                // pull the tokenID\r\n                var tokenID = bytes32(devcon2Token.balanceOf(_owner));\r\n\r\n                if (tokenToOwner[tokenID] == 0x0) {\r\n                    // the token hasn't yet been upgraded so we can return 1.\r\n                    return 1;\r\n                }\r\n            }\r\n            return 0;\r\n        } else {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner,\r\n                       address _spender) constant returns (uint256 remaining) {\r\n        var approvedTokenID = approvals[_owner][_spender];\r\n\r\n        if (approvedTokenID == 0x0) {\r\n            return 0;\r\n        } else if (_owner == 0x0 || _spender == 0x0) {\r\n            return 0;\r\n        } else if (tokenToOwner[approvedTokenID] == _owner) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to,\r\n                      uint256 _value) public silentUpgrade returns (bool success) {\r\n        if (_value != 1) {\r\n            // 1 is the only value that makes any sense here.\r\n            return false;\r\n        } else if (_to == 0x0) {\r\n            // cannot transfer to the null address.\r\n            return false;\r\n        } else if (ownerToToken[msg.sender] == 0x0) {\r\n            // msg.sender is not a token owner\r\n            return false;\r\n        } else if (ownerToToken[_to] != 0x0) {\r\n            // cannot transfer to an address that already owns a token.\r\n            return false;\r\n        } else if (isEligibleForUpgrade(_to)) {\r\n            // cannot transfer to an account which is still holding their token\r\n            // in the old system.\r\n            return false;\r\n        }\r\n\r\n        // pull the token id.\r\n        var tokenID = ownerToToken[msg.sender];\r\n\r\n        // remove the token from the sender.\r\n        ownerToToken[msg.sender] = 0x0;\r\n\r\n        // assign the token to the new owner\r\n        ownerToToken[_to] = tokenID;\r\n        tokenToOwner[tokenID] = _to;\r\n\r\n        // log the transfer\r\n        Transfer(msg.sender, _to, 1);\r\n        TokenEventLib._Transfer(msg.sender, _to, tokenID);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    function transfer(address _to) public returns (bool success) {\r\n        return transfer(_to, 1);\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from,\r\n                          address _to,\r\n                          uint256 _value) public returns (bool success) {\r\n        if (_value != 1) {\r\n            // Cannot transfer anything other than 1 token.\r\n            return false;\r\n        } else if (_to == 0x0) {\r\n            // Cannot transfer to the null address\r\n            return false;\r\n        } else if (ownerToToken[_from] == 0x0) {\r\n            // Cannot transfer if _from is not a token owner\r\n            return false;\r\n        } else if (ownerToToken[_to] != 0x0) {\r\n            // Cannot transfer to an existing token owner\r\n            return false;\r\n        } else if (approvals[_from][msg.sender] != ownerToToken[_from]) {\r\n            // The approved token doesn't match the token being transferred.\r\n            return false;\r\n        } else if (isEligibleForUpgrade(_to)) {\r\n            // cannot transfer to an account which is still holding their token\r\n            // in the old system.\r\n            return false;\r\n        }\r\n\r\n        // pull the tokenID\r\n        var tokenID = ownerToToken[_from];\r\n\r\n        // null out the approval\r\n        approvals[_from][msg.sender] = 0x0;\r\n\r\n        // remove the token from the sender.\r\n        ownerToToken[_from] = 0x0;\r\n\r\n        // assign the token to the new owner\r\n        ownerToToken[_to] = tokenID;\r\n        tokenToOwner[tokenID] = _to;\r\n\r\n        // log the transfer\r\n        Transfer(_from, _to, 1);\r\n        TokenEventLib._Transfer(_from, _to, tokenID);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    function transferFrom(address _from, address _to) public returns (bool success) {\r\n        return transferFrom(_from, _to, 1);\r\n    }\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender,\r\n                     uint256 _value) public silentUpgrade returns (bool success) {\r\n        if (_value != 1) {\r\n            // cannot approve any value other than 1\r\n            return false;\r\n        } else if (_spender == 0x0) {\r\n            // cannot approve the null address as a spender.\r\n            return false;\r\n        } else if (ownerToToken[msg.sender] == 0x0) {\r\n            // cannot approve if not a token owner.\r\n            return false;\r\n        }\r\n\r\n        var tokenID = ownerToToken[msg.sender];\r\n        approvals[msg.sender][_spender] = tokenID;\r\n\r\n        Approval(msg.sender, _spender, 1);\r\n        TokenEventLib._Approval(msg.sender, _spender, tokenID);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    function approve(address _spender) public returns (bool success) {\r\n        return approve(_spender, 1);\r\n    }\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool) {\r\n        if (_owner == 0x0) {\r\n            return false;\r\n        } else if (ownerToToken[_owner] == 0x0) {\r\n            // Check if the owner has a token on the main devcon2Token contract.\r\n            if (devcon2Token.isTokenOwner(_owner)) {\r\n                // pull the token ID\r\n                var tokenID = bytes32(devcon2Token.balanceOf(_owner));\r\n\r\n                if (tokenToOwner[tokenID] == 0x0) {\r\n                    // They own an un-transfered token in the parent\r\n                    // devcon2Token contract.\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the address of the owner of the given token id.\r\n    /// @param _tokenID Bytes32 id of token to lookup.\r\n    function ownerOf(bytes32 _tokenID) constant returns (address owner) {\r\n        if (_tokenID == 0x0) {\r\n            return 0x0;\r\n        } else if (tokenToOwner[_tokenID] != 0x0) {\r\n            return tokenToOwner[_tokenID];\r\n        } else {\r\n            return devcon2Token.ownerOf(_tokenID);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the token ID for the given address or 0x0 if they are not a token owner.\r\n    /// @param _owner Address of the owner to lookup.\r\n    function tokenId(address _owner) constant returns (bytes32 tokenID) {\r\n        if (_owner == 0x0) {\r\n            return 0x0;\r\n        } else if (ownerToToken[_owner] != 0x0) {\r\n            return ownerToToken[_owner];\r\n        } else {\r\n            tokenID = bytes32(devcon2Token.balanceOf(_owner));\r\n            if (tokenToOwner[tokenID] == 0x0) {\r\n                // this token has not been transfered yet so return the proxied\r\n                // value.\r\n                return tokenID;\r\n            } else {\r\n                // The token has already been transferred so ignore the parent\r\n                // contract data.\r\n                return 0x0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Upgrades a token from the previous contract\r\n    function upgrade() public returns (bool success) {\r\n        if (!devcon2Token.isTokenOwner(msg.sender)) {\r\n            // not a token owner.\r\n            return false;\r\n        } else if (ownerToToken[msg.sender] != 0x0) {\r\n            // already owns a token\r\n            return false;\r\n        }\r\n        \r\n        // pull the token ID\r\n        var tokenID = bytes32(devcon2Token.balanceOf(msg.sender));\r\n\r\n        if (tokenID == 0x0) {\r\n            // (should not be possible but here as a sanity check)\r\n            // null token is invalid.\r\n            return false;\r\n        } else if (tokenToOwner[tokenID] != 0x0) {\r\n            // already upgraded.\r\n            return false;\r\n        } else if (devcon2Token.ownerOf(tokenID) != msg.sender) {\r\n            // (should not be possible but here as a sanity check)\r\n            // not the owner of the token.\r\n            return false;\r\n        }\r\n\r\n        // Assign the new ownership.\r\n        ownerToToken[msg.sender] = tokenID;\r\n        tokenToOwner[tokenID] = msg.sender;\r\n\r\n        // increment the number of tokens that have been upgraded.\r\n        _upgradeCount += 1;\r\n\r\n        // Log it\r\n        Mint(msg.sender, tokenID);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Upgrades a token from the previous contract\r\n    /// @param _owner the address of the owner of the token on the original contract\r\n    /// @param _newOwner the address that should own the token on the new contract.\r\n    /// @param signature 65 byte signature of the tightly packed bytes (address(this) + _owner + _newOwner), signed by _owner\r\n    function proxyUpgrade(address _owner,\r\n                          address _newOwner,\r\n                          bytes signature) public returns (bool) {\r\n        if (_owner == 0x0 || _newOwner == 0x0) {\r\n            // cannot work with null addresses.\r\n            return false;\r\n        } else if (!devcon2Token.isTokenOwner(_owner)) {\r\n            // not a token owner on the original devcon2Token contract.\r\n            return false;\r\n        }\r\n\r\n        bytes32 tokenID = bytes32(devcon2Token.balanceOf(_owner));\r\n\r\n        if (tokenID == 0x0) {\r\n            // (should not be possible since we already checked isTokenOwner\r\n            // but I like being explicit)\r\n            return false;\r\n        } else if (isTokenUpgraded(tokenID)) {\r\n            // the token has already been upgraded.\r\n            return false;\r\n        } else if (ownerToToken[_newOwner] != 0x0) {\r\n            // new owner already owns a token\r\n            return false;\r\n        } else if (_owner != _newOwner && isEligibleForUpgrade(_newOwner)) {\r\n            // cannot upgrade to account that is still has an upgradable token\r\n            // on the old system.\r\n            return false;\r\n        }\r\n\r\n        bytes32 signatureHash = sha3(address(this), _owner, _newOwner);\r\n\r\n        if (!ECVerifyLib.ecverify(signatureHash, signature, _owner)) {\r\n            return false;\r\n        }\r\n\r\n        // Assign the new token\r\n        tokenToOwner[tokenID] = _newOwner;\r\n        ownerToToken[_newOwner] = tokenID;\r\n\r\n        // increment the number of tokens that have been upgraded.\r\n        _upgradeCount += 1;\r\n\r\n        // Log it\r\n        Mint(_newOwner, tokenID);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns the number of tokens that have been upgraded.\r\n    function upgradeCount() constant returns (uint256 _amount) {\r\n        return _upgradeCount;\r\n    }\r\n\r\n    /// @dev Returns the number of tokens that have been upgraded.\r\n    /// @param _tokenID the id of the token to query\r\n    function isTokenUpgraded(bytes32 _tokenID) constant returns (bool isUpgraded) {\r\n        return (tokenToOwner[_tokenID] != 0x0);\r\n    }\r\n}\r\n\r\n\r\ncontract MainnetIndividualityTokenRoot is \r\n         IndividualityTokenRoot(0x0a43edfe106d295e7c1e591a4b04b5598af9474c) {\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenID\",\"type\":\"bytes32\"}],\"name\":\"isTokenUpgraded\",\"outputs\":[{\"name\":\"isUpgraded\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"proxyUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devcon2Token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokenId\",\"outputs\":[{\"name\":\"tokenID\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenID\",\"type\":\"bytes32\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeCount\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenID\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MainnetIndividualityTokenRoot","CompilerVersion":"v0.4.4+commit.4633f3de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}