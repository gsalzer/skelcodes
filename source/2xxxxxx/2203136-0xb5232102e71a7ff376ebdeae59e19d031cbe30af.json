{"status":"1","message":"OK","result":[{"SourceCode":"contract SellOrder {\r\n  /**************************\r\n          Constants\r\n  ***************************/\r\n\r\n  /**************************\r\n          Events\r\n  ***************************/\r\n\r\n  /**************************\r\n       Public variables\r\n  ***************************/\r\n\r\n  // Owner of the challenge with backdoor access.\r\n  // Remove for a real DAO contract:\r\n  address public challengeOwner;\r\n  address public owner; // DaoAccount that created the order\r\n  uint256 public tokens;\r\n  uint256 public price; // Wei per token\r\n\r\n  /**************************\r\n       Private variables\r\n  ***************************/\r\n\r\n\r\n  /**************************\r\n           Modifiers\r\n  ***************************/\r\n\r\n  modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n  modifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n  modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n  /**************************\r\n   Constructor and fallback\r\n  **************************/\r\n\r\n  function SellOrder (uint256 _tokens, uint256 _price, address _challengeOwner) noEther {\r\n    owner = msg.sender;\r\n\r\n    tokens = _tokens;\r\n    price = _price;\r\n\r\n    // Remove for a real DAO contract:\r\n    challengeOwner = _challengeOwner;\r\n  }\r\n\r\n  function () {\r\n    throw;\r\n  }\r\n\r\n  /**************************\r\n       Private functions\r\n  ***************************/\r\n\r\n  /**************************\r\n       Public functions\r\n  ***************************/\r\n\r\n  function cancel () noEther onlyOwner {\r\n    suicide(owner);\r\n  }\r\n\r\n  function execute () {\r\n    // ... transfer tokens to buyer\r\n\r\n    // Send ether to seller:\r\n    // suicide(owner);\r\n  }\r\n\r\n  // The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n  function terminate() noEther onlyChallengeOwner {\r\n    suicide(challengeOwner);\r\n  }\r\n}\r\n\r\ncontract AbstractDaoChallenge {\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);\r\n\tfunction tokenPrice() returns (uint256);\r\n}\r\n\r\ncontract DaoAccount\r\n{\r\n\t/**************************\r\n\t\t\t    Constants\r\n\t***************************/\r\n\r\n\t/**************************\r\n\t\t\t\t\tEvents\r\n\t***************************/\r\n\r\n\t// No events\r\n\r\n\t/**************************\r\n\t     Public variables\r\n\t***************************/\r\n\r\n\taddress public daoChallenge; // the DaoChallenge this account belongs to\r\n\r\n\t// Owner of the challenge with backdoor access.\r\n  // Remove for a real DAO contract:\r\n  address public challengeOwner;\r\n\r\n\t/**************************\r\n\t     Private variables\r\n\t***************************/\r\n\r\n\tuint256 tokenBalance; // number of tokens in this account\r\n  address owner;        // owner of the tokens\r\n\r\n\t/**************************\r\n\t\t\t     Modifiers\r\n\t***************************/\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\tmodifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t/**************************\r\n\t Constructor and fallback\r\n\t**************************/\r\n\r\n  function DaoAccount (address _owner, address _challengeOwner) noEther {\r\n    owner = _owner;\r\n    daoChallenge = msg.sender;\r\n\t\ttokenBalance = 0;\r\n\r\n    // Remove for a real DAO contract:\r\n    challengeOwner = _challengeOwner;\r\n\t}\r\n\r\n\tfunction () {\r\n\t\tthrow;\r\n\t}\r\n\r\n\t/**************************\r\n\t     Private functions\r\n\t***************************/\r\n\r\n\t/**************************\r\n\t\t\t Public functions\r\n\t***************************/\r\n\r\n\tfunction getOwnerAddress() constant returns (address ownerAddress) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction getTokenBalance() constant returns (uint256 tokens) {\r\n\t\treturn tokenBalance;\r\n\t}\r\n\r\n\tfunction buyTokens() onlyDaoChallenge returns (uint256 tokens) {\r\n\t\tuint256 amount = msg.value;\r\n\t\tuint256 tokenPrice = AbstractDaoChallenge(daoChallenge).tokenPrice();\r\n\r\n\t\t// No free tokens:\r\n\t\tif (amount == 0) throw;\r\n\r\n\t\t// No fractional tokens:\r\n\t\tif (amount % tokenPrice != 0) throw;\r\n\r\n\t\ttokens = amount / tokenPrice;\r\n\r\n\t\ttokenBalance += tokens;\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction transfer(uint256 tokens, DaoAccount recipient) noEther onlyDaoChallenge {\r\n\t\tif (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n\t\tif (tokenBalance - tokens > tokenBalance) throw; // Overflow\r\n\t\ttokenBalance -= tokens;\r\n\t\trecipient.receiveTokens(tokens);\r\n\t}\r\n\r\n\tfunction receiveTokens(uint256 tokens) {\r\n\t\t// Check that the sender is a DaoAccount and belongs to our DaoChallenge\r\n\t\tDaoAccount sender = DaoAccount(msg.sender);\r\n\t\tif (!AbstractDaoChallenge(daoChallenge).isMember(sender, sender.getOwnerAddress())) throw;\r\n\r\n\t\tif (tokens > sender.getTokenBalance()) throw;\r\n\r\n\t\t// Protect against overflow:\r\n\t\tif (tokenBalance + tokens < tokenBalance) throw;\r\n\r\n\t\ttokenBalance += tokens;\r\n\t}\r\n\r\n  function placeSellOrder(uint256 tokens, uint256 price) noEther onlyDaoChallenge returns (SellOrder) {\r\n    if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n    if (tokenBalance - tokens > tokenBalance) throw; // Overflow\r\n    tokenBalance -= tokens;\r\n\r\n    SellOrder order = new SellOrder(tokens, price, challengeOwner);\r\n    return order;\r\n  }\r\n\r\n  function cancelSellOrder(SellOrder order) noEther onlyDaoChallenge {\r\n    uint256 tokens = order.tokens();\r\n    tokenBalance += tokens;\r\n    order.cancel();\r\n  }\r\n\r\n\t// The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}\r\n\r\ncontract DaoChallenge\r\n{\r\n\t/**************************\r\n\t\t\t\t\tConstants\r\n\t***************************/\r\n\r\n\r\n\t/**************************\r\n\t\t\t\t\tEvents\r\n\t***************************/\r\n\r\n\tevent notifyTerminate(uint256 finalBalance);\r\n\tevent notifyTokenIssued(uint256 n, uint256 price, uint deadline);\r\n\r\n\tevent notifyNewAccount(address owner, address account);\r\n\tevent notifyBuyToken(address owner, uint256 tokens, uint256 price);\r\n\tevent notifyTransfer(address owner, address recipient, uint256 tokens);\r\n  event notifyPlaceSellOrder(uint256 tokens, uint256 price);\r\n  event notifyCancelSellOrder();\r\n\r\n\t/**************************\r\n\t     Public variables\r\n\t***************************/\r\n\r\n\t// For the current token issue:\r\n\tuint public tokenIssueDeadline = now;\r\n\tuint256 public tokensIssued = 0;\r\n\tuint256 public tokensToIssue = 0;\r\n\tuint256 public tokenPrice = 1000000000000000; // 1 finney\r\n\r\n\tmapping (address => DaoAccount) public daoAccounts;\r\n  mapping (address => SellOrder) public sellOrders;\r\n\r\n  // Owner of the challenge; a real DAO doesn't an owner.\r\n  address public challengeOwner;\r\n\r\n\t/**************************\r\n\t\t\t Private variables\r\n\t***************************/\r\n\r\n\t/**************************\r\n\t\t\t\t\t Modifiers\r\n\t***************************/\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t/**************************\r\n\t Constructor and fallback\r\n\t**************************/\r\n\r\n\tfunction DaoChallenge () {\r\n\t\tchallengeOwner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\r\n\t}\r\n\r\n\tfunction () noEther {\r\n\t}\r\n\r\n\t/**************************\r\n\t     Private functions\r\n\t***************************/\r\n\r\n\tfunction accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\r\n\t\tDaoAccount account = daoAccounts[accountOwner];\r\n\r\n\t\tif(account == DaoAccount(0x00) && createNew) {\r\n\t\t\taccount = new DaoAccount(accountOwner, challengeOwner);\r\n\t\t\tdaoAccounts[accountOwner] = account;\r\n\t\t\tnotifyNewAccount(accountOwner, address(account));\r\n\t\t}\r\n\r\n\t\treturn account;\r\n\t}\r\n\r\n\t/**************************\r\n\t     Public functions\r\n\t***************************/\r\n\r\n\tfunction createAccount () {\r\n\t\taccountFor(msg.sender, true);\r\n\t}\r\n\r\n\t// Check if a given account belongs to this DaoChallenge.\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool) {\r\n\t\tif (account == DaoAccount(0x00)) return false;\r\n\t\tif (allegedOwnerAddress == 0x00) return false;\r\n\t\tif (daoAccounts[allegedOwnerAddress] == DaoAccount(0x00)) return false;\r\n\t\t// allegedOwnerAddress is passed in for performance reasons, but not trusted\r\n\t\tif (daoAccounts[allegedOwnerAddress] != account) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getTokenBalance () constant noEther returns (uint256 tokens) {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) return 0;\r\n\t\treturn account.getTokenBalance();\r\n\t}\r\n\r\n\t// n: max number of tokens to be issued\r\n\t// price: in wei, e.g. 1 finney = 0.001 eth = 1000000000000000 wei\r\n\t// deadline: unix timestamp in seconds\r\n\tfunction issueTokens (uint256 n, uint256 price, uint deadline) noEther onlyChallengeOwner {\r\n\t\t// Only allow one issuing at a time:\r\n\t\tif (now < tokenIssueDeadline) throw;\r\n\r\n\t\t// Deadline can't be in the past:\r\n\t\tif (deadline < now) throw;\r\n\r\n\t\t// Issue at least 1 token\r\n\t\tif (n == 0) throw;\r\n\r\n\t\ttokenPrice = price;\r\n\t\ttokenIssueDeadline = deadline;\r\n\t\ttokensToIssue = n;\r\n\t\ttokensIssued = 0;\r\n\r\n\t\tnotifyTokenIssued(n, price, deadline);\r\n\t}\r\n\r\n\tfunction buyTokens () returns (uint256 tokens) {\r\n\t\ttokens = msg.value / tokenPrice;\r\n\r\n\t\tif (now > tokenIssueDeadline) throw;\r\n\t\tif (tokensIssued >= tokensToIssue) throw;\r\n\r\n\t\t// This hopefully prevents issuing too many tokens\r\n\t\t// if there's a race condition:\r\n\t\ttokensIssued += tokens;\r\n\t\tif (tokensIssued > tokensToIssue) throw;\r\n\r\n\t  DaoAccount account = accountFor(msg.sender, true);\r\n\t\tif (account.buyTokens.value(msg.value)() != tokens) throw;\r\n\r\n\t\tnotifyBuyToken(msg.sender, tokens, msg.value);\r\n\t\treturn tokens;\r\n \t}\r\n\r\n\tfunction transfer(uint256 tokens, address recipient) noEther {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) throw;\r\n\r\n\t\tDaoAccount recipientAcc = accountFor(recipient, false);\r\n\t\tif (recipientAcc == DaoAccount(0x00)) throw;\r\n\r\n\t\taccount.transfer(tokens, recipientAcc);\r\n\t\tnotifyTransfer(msg.sender, recipient, tokens);\r\n\t}\r\n\r\n  function placeSellOrder(uint256 tokens, uint256 price) noEther returns (SellOrder) {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) throw;\r\n\r\n    SellOrder order = account.placeSellOrder(tokens, price);\r\n\r\n    sellOrders[address(order)] = order;\r\n\r\n    notifyPlaceSellOrder(tokens, price);\r\n    return order;\r\n  }\r\n\r\n  function cancelSellOrder(address addr) noEther {\r\n    DaoAccount account = accountFor(msg.sender, false);\r\n    if (account == DaoAccount(0x00)) throw;\r\n\r\n    SellOrder order = sellOrders[addr];\r\n    if (order == SellOrder(0x00)) throw;\r\n\r\n    if (order.owner() != address(account)) throw;\r\n\r\n    sellOrders[addr] = SellOrder(0x00);\r\n\r\n    account.cancelSellOrder(order);\r\n\r\n    notifyCancelSellOrder();\r\n  }\r\n\r\n\t// The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tnotifyTerminate(this.balance);\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenIssueDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"allegedOwnerAddress\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"cancelSellOrder\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"placeSellOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"daoAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensToIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"finalBalance\",\"type\":\"uint256\"}],\"name\":\"notifyTerminate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"notifyTokenIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"notifyNewAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"notifyBuyToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"notifyTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"notifyPlaceSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"notifyCancelSellOrder\",\"type\":\"event\"}]","ContractName":"DaoChallenge","CompilerVersion":"v0.3.5-2016-07-01-48238c9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}