{"status":"1","message":"OK","result":[{"SourceCode":"contract Etherization {\r\n    \r\n    // 1 eth starting price\r\n    uint public START_PRICE = 1000000000000000000;\r\n    // 0.8 eth city build price\r\n    uint public CITY_PRICE = 800000000000000000;\r\n    // 0.5 eth building build price\r\n    uint public BUILDING_PRICE = 500000000000000000;\r\n    // 0.2 eth unit build price\r\n    uint public UNIT_PRICE = 200000000000000000;\r\n    // 0.02 eth unit maintenance price\r\n    uint public MAINT_PRICE = 20000000000000000;\r\n    // 0.1 eth min withdraw amount to prevent spam\r\n    uint public MIN_WTH = 100000000000000000;\r\n    \r\n    // minimum time to wait between moves in seconds\r\n    uint public WAIT_TIME = 14400;\r\n    uint MAP_ROWS = 34;\r\n    uint MAP_COLS = 34;\r\n    \r\n    \r\n    struct City {\r\n        uint owner;\r\n        string name;\r\n        // 0 - quarry, 1 - farm, 2 - woodworks, 3 - metalworks, 4 -stables\r\n        bool[5] buildings;\r\n        // 1 - pikemen, 2 - swordsmen, 3 - horsemen\r\n        uint[10] units; //maximum num of units per city 10\r\n        uint[2] rowcol;\r\n        int previousID;\r\n        int nextID;\r\n    }\r\n    \r\n    struct Player {\r\n        // Player address\r\n        address etherAddress;\r\n        // Their name\r\n        string name;\r\n        // Their treasury balance\r\n        uint treasury;\r\n        // Their capitol\r\n        uint capitol;\r\n        // Number of cities the player has under control\r\n        uint numCities;\r\n        uint numUnits;\r\n        // When was their last move (based on block.timestamp)\r\n        uint lastTimestamp;\r\n    }\r\n    \r\n    Player player;\r\n    Player[] public players;\r\n    uint public numPlayers = 0;\r\n    \r\n    mapping(address => uint) playerIDs;\r\n    mapping(uint => uint) public playerMsgs;\r\n    \r\n    City city;\r\n    City[] public cities;\r\n    uint public numCities = 0;\r\n    \r\n    uint[] public quarryCities;\r\n    uint[] public farmCities;\r\n    uint[] public woodworksCities;\r\n    uint[] public metalworksCities;\r\n    uint[] public stablesCities;\r\n    \r\n    uint[34][34] public map;\r\n\r\n    address wizardAddress;\r\n    \r\n    address utilsAddress;\r\n    address utilsAddress2;\r\n    \r\n    // Sum of all players' balances\r\n    uint public totalBalances = 0;\r\n\r\n    // Used to ensure only the owner can do some things.\r\n    modifier onlywizard { if (msg.sender == wizardAddress) _ }\r\n    \r\n    // Used to ensure only the utils contract can do some things.\r\n    modifier onlyutils { if (msg.sender == utilsAddress || msg.sender == utilsAddress2) _ }\r\n\r\n\r\n\r\n    // Sets up defaults.\r\n    function Etherization() {\r\n        wizardAddress = msg.sender;\r\n    }\r\n\r\n    function start(string playerName, string cityName, uint row, uint col, uint rowref, uint colref) {\r\n        \r\n        \r\n        // If they paid too little, reject and refund their money.\r\n        if (msg.value < START_PRICE) {\r\n            //msg.sender.send(msg.value);\r\n            //playerMsgs[msg.sender] = \"Not enough ether sent to found a city and start playing. Sending back any eth sent...\";\r\n            return;\r\n        }\r\n        // If the player already exists\r\n        if (playerIDs[msg.sender] > 0) {\r\n            //msg.sender.send(msg.value);\r\n            //playerMsgs[msg.sender] =  \"You already founded an etherization. Lookup your player ID by calling getMyPlayerID(). Sending back any eth sent...\";\r\n            return;\r\n        }\r\n        \r\n        player.etherAddress = msg.sender;\r\n        player.name = playerName;\r\n        player.treasury = msg.value;\r\n        totalBalances += msg.value;\r\n        player.capitol = numCities;\r\n        player.numCities = 1;\r\n        player.numUnits = 1;\r\n\r\n        players.push(player);\r\n        \r\n        city.owner = numPlayers;\r\n        city.name = cityName;\r\n        // the first city in the game has a quarry and a farm by default\r\n        if(numCities <= 0) {\r\n            city.buildings[0] = true;\r\n            quarryCities.push(0);\r\n            city.buildings[1] = true;\r\n            farmCities.push(0);\r\n            city.rowcol[0] = 10;\r\n            city.rowcol[1] = 10;\r\n            map[10][10] = numPlayers+1;\r\n        } else {\r\n            city.buildings[0] = false;\r\n            city.buildings[1] = false;\r\n            if(row>33 || col>33 || rowref>33 || colref>33 || int(row)-int(rowref) > int(1) || int(row)-int(rowref) < int(-1) || int(col)-int(colref) > int(1) || int(col)-int(colref) < int(-1) || map[row][col]>0 || map[rowref][colref]<=0) {\r\n                throw;\r\n            }\r\n            city.rowcol[0] = row;\r\n            city.rowcol[1] = col;\r\n            map[row][col] = numPlayers+1;\r\n            \r\n            players[numPlayers].treasury -= START_PRICE;\r\n            // distribute build funds to production type building owners\r\n            uint productionCut;\r\n            uint i;\r\n            productionCut = START_PRICE / quarryCities.length;\r\n            for(i=0; i < quarryCities.length; i++) {\r\n                players[cities[quarryCities[i]].owner].treasury += productionCut;\r\n            }\r\n        }\r\n        city.units[0] = 1;  //pikemen guards a city by default\r\n        city.previousID = -1;\r\n        city.nextID = -1;\r\n        \r\n        cities.push(city);\r\n        \r\n        playerIDs[msg.sender] = numPlayers+1; //to distinguish it from the default 0\r\n        numPlayers++;\r\n        numCities++;\r\n        \r\n        playerMsgs[playerIDs[msg.sender]-1] = 1 + row*100 + col*10000;\r\n        players[numPlayers-1].lastTimestamp = now;\r\n    }\r\n    \r\n    function deposit() {\r\n        players[playerIDs[msg.sender]-1].treasury += msg.value;\r\n        totalBalances += msg.value;\r\n    }\r\n    \r\n    function withdraw(uint amount) {\r\n        if(int(playerIDs[msg.sender])-1 < 0) {\r\n            throw;\r\n        }\r\n        uint playerID = playerIDs[msg.sender]-1;\r\n        if(timePassed(playerID) < WAIT_TIME) {\r\n            playerMsgs[playerIDs[msg.sender]-1] = 2;\r\n            return;        \r\n        }\r\n        if(amount < players[playerID].treasury && amount > MIN_WTH) {\r\n            players[playerID].treasury -= amount;\r\n            totalBalances -= amount;\r\n            players[playerID].etherAddress.send((amount*99)/100); //keep 1% as commission\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    function getMyPlayerID() constant returns (int ID) {\r\n        return int(playerIDs[msg.sender])-1;\r\n    }\r\n    \r\n    function getMyMsg() constant returns (uint s) {\r\n        return playerMsgs[playerIDs[msg.sender]-1];\r\n    }\r\n    \r\n    function getCity(uint cityID) constant returns (uint owner, string cityName, bool[5] buildings, uint[10] units, uint[2] rowcol, int previousID, int nextID) {\r\n        return (cities[cityID].owner, cities[cityID].name, cities[cityID].buildings, cities[cityID].units, cities[cityID].rowcol, cities[cityID].previousID, cities[cityID].nextID);\r\n    }\r\n    \r\n    \r\n    function timePassed(uint playerID) constant returns (uint tp) {\r\n        return (now - players[playerID].lastTimestamp);\r\n    }\r\n\r\n\r\n    // Used only by the wizard to check his commission.\r\n    function getCommission() onlywizard constant returns (uint com) {\r\n        return this.balance-totalBalances;\r\n    }\r\n\r\n    // Used only by the wizard to collect his commission.\r\n    function sweepCommission(uint amount) onlywizard {\r\n        if(amount < this.balance-totalBalances) {\r\n            wizardAddress.send(amount);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    function setUtils(address a) onlywizard {\r\n        utilsAddress = a;\r\n    }\r\n    \r\n    function setUtils2(address a) onlywizard {\r\n        utilsAddress2 = a;\r\n    }\r\n    \r\n    function getPlayerID(address sender) onlyutils constant returns (uint playerID) {\r\n        if(int(playerIDs[sender])-1 < 0) {\r\n            throw;\r\n        }\r\n        return playerIDs[sender]-1;\r\n    }\r\n    \r\n    function getWwLength() constant returns (uint length) {\r\n        return woodworksCities.length;\r\n    }\r\n    \r\n    function getMwLength() constant returns (uint length) {\r\n        return metalworksCities.length;\r\n    }\r\n    \r\n    function getStLength() constant returns (uint length) {\r\n        return stablesCities.length;\r\n    }\r\n    \r\n    function getFmLength() constant returns (uint length) {\r\n        return farmCities.length;\r\n    }\r\n    \r\n    function getQrLength() constant returns (uint length) {\r\n        return quarryCities.length;\r\n    }\r\n    \r\n    \r\n    function setMsg(address sender, uint s) onlyutils {\r\n        playerMsgs[playerIDs[sender]-1] = s;\r\n    }\r\n    \r\n    function setNumCities(uint nc) onlyutils {\r\n        numCities = nc;\r\n    }\r\n    \r\n    function setUnit(uint cityID, uint i, uint unitType) onlyutils {\r\n        cities[cityID].units[i] = unitType;\r\n    }\r\n    \r\n    function setOwner(uint cityID, uint owner) onlyutils {\r\n        cities[cityID].owner = owner;\r\n    }\r\n    \r\n    function setName(uint cityID, string name) onlyutils {\r\n        cities[cityID].name = name;\r\n    }\r\n    \r\n    function setPreviousID(uint cityID, int previousID) onlyutils {\r\n        cities[cityID].previousID = previousID;\r\n    }\r\n    \r\n    function setNextID(uint cityID, int nextID) onlyutils {\r\n        cities[cityID].nextID = nextID;\r\n    }\r\n    \r\n    function setRowcol(uint cityID, uint[2] rowcol) onlyutils {\r\n        cities[cityID].rowcol = rowcol;\r\n    }\r\n    \r\n    function setMap(uint row, uint col, uint ind) onlyutils {\r\n        map[row][col] = ind;\r\n    }\r\n    \r\n    function setCapitol(uint playerID, uint capitol) onlyutils {\r\n        players[playerID].capitol = capitol;\r\n    }\r\n\r\n    function setNumUnits(uint playerID, uint numUnits) onlyutils {\r\n        players[playerID].numUnits = numUnits;\r\n    }\r\n    \r\n    function setNumCities(uint playerID, uint numCities) onlyutils {\r\n        players[playerID].numCities = numCities;\r\n    }\r\n    \r\n    function setTreasury(uint playerID, uint treasury) onlyutils {\r\n        players[playerID].treasury = treasury;\r\n    }\r\n    \r\n    function setLastTimestamp(uint playerID, uint timestamp) onlyutils {\r\n        players[playerID].lastTimestamp = timestamp;\r\n    }\r\n    \r\n    function setBuilding(uint cityID, uint buildingType) onlyutils {\r\n        cities[cityID].buildings[buildingType] = true;\r\n        if(buildingType == 0) {\r\n            quarryCities.push(cityID);\r\n        } else if(buildingType == 1) {\r\n            farmCities.push(cityID);\r\n        } else if(buildingType == 2) {\r\n            woodworksCities.push(cityID);\r\n        } else if(buildingType == 3) {\r\n            metalworksCities.push(cityID);\r\n        } else if(buildingType == 4) {\r\n            stablesCities.push(cityID);\r\n        }\r\n    }\r\n    \r\n    function pushCity() onlyutils {\r\n        city.buildings[0] = false;\r\n        city.buildings[1] = false;\r\n        cities.push(city);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract EtherizationUtils2 {\r\n    \r\n    uint playerID;\r\n    uint ownerS;\r\n    uint ownerT;\r\n    uint numUnitsS;\r\n    uint numCitiesS;\r\n    uint treasuryS;\r\n    uint numUnitsT;\r\n    uint numCitiesT;\r\n    uint treasuryT;\r\n    uint j;\r\n    uint bestType;\r\n    uint bestTypeInd;\r\n    uint ran;\r\n    bool win;\r\n    bool cityCaptured = false;\r\n    \r\n    Etherization public e;\r\n    \r\n    address wizardAddress;\r\n    \r\n    // Used to ensure only the owner can do some things.\r\n    modifier onlywizard { if (msg.sender == wizardAddress) _ }\r\n    \r\n    \r\n    function EtherizationUtils2() {\r\n        wizardAddress = msg.sender;\r\n    }\r\n    \r\n    function sete(address a) onlywizard {\r\n        e = Etherization(a);\r\n    }\r\n    \r\n    function attack(uint source, uint target, uint[] unitIndxs) {\r\n        uint[2] memory sRowcol;\r\n        uint[2] memory tRowcol;\r\n        uint[10] memory unitsS;\r\n        uint[10] memory unitsT;\r\n        \r\n        playerID = e.getPlayerID(msg.sender);\r\n        \r\n        if(e.timePassed(playerID) < e.WAIT_TIME()) {\r\n            e.setMsg(msg.sender, 2);\r\n            return;        \r\n        }\r\n        \r\n        (ownerS,,,unitsS,sRowcol,,) = e.getCity(source);\r\n        (ownerT,,,unitsT,tRowcol,,) = e.getCity(target);\r\n        (,,treasuryS,,numCitiesS,numUnitsS,) = e.players(ownerS);\r\n        (,,treasuryT,,numCitiesT,numUnitsT,) = e.players(ownerT);\r\n        if(playerID != ownerS || playerID == ownerT || int(sRowcol[0])-int(tRowcol[0]) > int(1) || int(sRowcol[0])-int(tRowcol[0]) < int(-1) || int(sRowcol[1])-int(tRowcol[1]) > int(1) || int(sRowcol[1])-int(tRowcol[1]) < int(-1)) {\r\n            e.setMsg(msg.sender, 17);\r\n            return;\r\n        }\r\n\r\n        cityCaptured = false;\r\n        for(uint i=0; i<unitIndxs.length; i++) {\r\n            bestType = 0;\r\n            win = false;\r\n            ran = uint32(block.blockhash(block.number-1-i))/42949673; //random number between 0 and 100 (divide by MAX_UINT32/100)\r\n            // if attacked by pikemen - try to find swordsmen or next best unit\r\n            if(unitsS[unitIndxs[i]]==1) {\r\n                bestType = 0;\r\n                bestTypeInd = 0;\r\n                for(j=0; j<unitsT.length; j++) {\r\n                    if(unitsT[j] == 1 && bestType!=2) {\r\n                        bestType = 1;\r\n                        bestTypeInd = j;\r\n                    } else if(unitsT[j] == 2) {\r\n                        bestType = 2;\r\n                        bestTypeInd = j;\r\n                        break;\r\n                    } else if(unitsT[j] == 3 && bestType!=2 && bestType!=1) {\r\n                        bestType = 3;\r\n                        bestTypeInd = j;\r\n                    }\r\n                }\r\n                if(bestType==1) {\r\n                    if(ran > 50) {\r\n                        win = true;\r\n                    }\r\n                } else if(bestType==2) {\r\n                    if(ran > 75) {\r\n                        win = true;\r\n                    }\r\n                } else if(bestType==3) {\r\n                    if(ran > 25) {\r\n                        win = true;\r\n                    }\r\n                } else {\r\n                    cityCaptured = true;\r\n                    break;\r\n                }\r\n            }\r\n            // if attacked by swordsmen - try to find horsemen or next best unit\r\n            else if(unitsS[unitIndxs[i]]==2) {\r\n                bestType = 0;\r\n                bestTypeInd = 0;\r\n                for(j=0; j<unitsT.length; j++) {\r\n                    if(unitsT[j] == 2 && bestType!=3) {\r\n                        bestType = 2;\r\n                        bestTypeInd = j;\r\n                    } else if(unitsT[j] == 3) {\r\n                        bestType = 3;\r\n                        bestTypeInd = j;\r\n                        break;\r\n                    } else if(unitsT[j] == 1 && bestType!=3 && bestType!=2) {\r\n                        bestType = 1;\r\n                        bestTypeInd = j;\r\n                    }\r\n                }\r\n                if(bestType==1) {\r\n                    if(ran > 25) {\r\n                        win = true;\r\n                    }\r\n                } else if(bestType==2) {\r\n                    if(ran > 50) {\r\n                        win = true;\r\n                    }\r\n                } else if(bestType==3) {\r\n                    if(ran > 75) {\r\n                        win = true;\r\n                    }\r\n                } else {\r\n                    cityCaptured = true;\r\n                    break;\r\n                }\r\n            }\r\n            // if attacked by horsemen - try to find pikemen or next best unit\r\n            else if(unitsS[unitIndxs[i]]==3) {\r\n                bestType = 0;\r\n                bestTypeInd = 0;\r\n                for(j=0; j<unitsT.length; j++) {\r\n                    if(unitsT[j] == 3 && bestType!=1) {\r\n                        bestType = 3;\r\n                        bestTypeInd = j;\r\n                    } else if(unitsT[j] == 1) {\r\n                        bestType = 1;\r\n                        bestTypeInd = j;\r\n                        break;\r\n                    } else if(unitsT[j] == 2 && bestType!=1 && bestType!=3) {\r\n                        bestType = 2;\r\n                        bestTypeInd = j;\r\n                    }\r\n                }\r\n                if(bestType==1) {\r\n                    if(ran > 75) {\r\n                        win = true;\r\n                    }\r\n                } else if(bestType==2) {\r\n                    if(ran > 25) {\r\n                        win = true;\r\n                    }\r\n                } else if(bestType==3) {\r\n                    if(ran > 50) {\r\n                        win = true;\r\n                    }\r\n                } else {\r\n                    cityCaptured = true;\r\n                    break;\r\n                }\r\n            }\r\n            // if attacked by no-unit do nothing\r\n            else {\r\n                continue;\r\n            }\r\n            \r\n            if(cityCaptured) {\r\n                break;\r\n            }\r\n            if(win) {\r\n                unitsT[bestTypeInd] = 0; //kill defending unit\r\n                e.setUnit(target, bestTypeInd, 0); //kill defending unit\r\n                numUnitsT--;\r\n                e.setNumUnits(ownerT, numUnitsT);\r\n            } else {\r\n                unitsS[unitIndxs[i]] = 0; //kill attacking unit\r\n                e.setUnit(source, unitIndxs[i], 0); //kill attacking unit\r\n                numUnitsS--;\r\n                e.setNumUnits(playerID, numUnitsS);\r\n            }\r\n        }\r\n        \r\n        if(cityCaptured) {\r\n            //march into the city\r\n            j = 0;\r\n            for(; i < unitIndxs.length; i++) {\r\n                e.setUnit(target, j, unitsS[unitIndxs[i]]);\r\n                e.setUnit(source, unitIndxs[i], 0);\r\n                j++;\r\n            }\r\n            \r\n            //plunder treasury fraction\r\n            uint treasuryFraction = treasuryT/numCitiesT;\r\n            e.setNumCities(ownerT, numCitiesT-1);\r\n            e.setTreasury(ownerT, treasuryT-treasuryFraction);\r\n            e.setTreasury(playerID, treasuryS+treasuryFraction);\r\n            e.setNumCities(playerID, numCitiesS+1);\r\n            \r\n            int previousID;\r\n            int nextID;\r\n            uint capitol;\r\n            //remove the link to the city in losing player's city chai\r\n            (,,,,,,previousID,nextID) = e.getCity(target);\r\n            if(previousID >= 0) {\r\n                e.setNextID(uint(previousID), nextID);\r\n                (,,,capitol,,,) = e.players(ownerT);\r\n                if(capitol == target) {\r\n                    e.setCapitol(capitol, uint(previousID));\r\n                }\r\n            }\r\n            if(nextID >= 0) {\r\n                e.setPreviousID(uint(nextID), previousID);\r\n                if(capitol == target) {\r\n                    e.setCapitol(capitol, uint(nextID));\r\n                }\r\n            }\r\n            \r\n            e.setOwner(target, ownerS);\r\n            e.setMap(tRowcol[0], tRowcol[1], ownerS+1);\r\n            \r\n            (,,,,,,previousID,nextID) = e.getCity(source);\r\n            //add the city to winning player's city chain\r\n            e.setPreviousID(target, int(source));\r\n            e.setNextID(target, nextID);\r\n            if(nextID >= 0) {\r\n                e.setPreviousID(uint(nextID), int(target));\r\n            }\r\n            e.setNextID(source, int(target));\r\n            \r\n            e.setMsg(msg.sender, 18 + tRowcol[0]*100 + tRowcol[1]*10000);\r\n        } else {\r\n            e.setMsg(msg.sender, 19 + tRowcol[0]*100 + tRowcol[1]*10000);\r\n        }\r\n        e.setLastTimestamp(playerID, now);\r\n    }\r\n    \r\n    function buildCity(string cityName, uint[2] rowcol, uint[2] rowcolref) {\r\n        playerID = e.getPlayerID(msg.sender);\r\n        \r\n        if(e.timePassed(playerID) < e.WAIT_TIME()) {\r\n            e.setMsg(msg.sender, 2);\r\n            return;        \r\n        }\r\n        \r\n        uint treasury;\r\n        uint numCities;\r\n        uint numUnits;\r\n        uint capitol;\r\n        (,,treasury,capitol,numCities,numUnits,) = e.players(playerID);\r\n        if(treasury < e.CITY_PRICE()) {\r\n            e.setMsg(msg.sender, 6);\r\n            return;\r\n        }\r\n\r\n        e.setTreasury(playerID, treasury-e.CITY_PRICE());\r\n        \r\n        if(rowcol[0]>33 || rowcol[1]>33 || rowcolref[0]>33 || rowcolref[1]>33 || int(rowcol[0])-int(rowcolref[0]) > int(1) || int(rowcol[0])-int(rowcolref[0]) < int(-1) || int(rowcol[1])-int(rowcolref[1]) > int(1) || int(rowcol[1])-int(rowcolref[1]) < int(-1) || e.map(rowcol[0],rowcol[1])>0 || e.map(rowcolref[0],rowcolref[1])<=0) {\r\n            throw;\r\n        }\r\n\r\n        // distribute build funds to production type building owners\r\n        uint productionCut;\r\n        uint owner;\r\n        int i;\r\n        productionCut = e.CITY_PRICE() / e.getQrLength();\r\n        for(i=0; uint(i) < e.getQrLength(); i++) {\r\n            (owner,) = e.cities(e.quarryCities(uint(i)));\r\n            (,,treasury,,,,) = e.players(owner);\r\n            e.setTreasury(owner, treasury+productionCut);\r\n        }\r\n        \r\n        e.setNumCities(playerID, numCities+1);\r\n        e.setNumUnits(playerID, numUnits+1);\r\n\r\n        e.pushCity();\r\n        e.setOwner(e.numCities(), playerID);\r\n        e.setName(e.numCities(), cityName);\r\n        e.setUnit(e.numCities(), 0, 1);   //pikemen guards a city by default\r\n        \r\n        e.setRowcol(e.numCities(), rowcol);\r\n        e.setMap(rowcol[0], rowcol[1], playerID+1);\r\n        \r\n        // if player has no cities currently\r\n        if(numCities<1) {\r\n            e.setCapitol(playerID, e.numCities());\r\n            e.setPreviousID(e.numCities(), -1);\r\n        } else {\r\n            int nextID;\r\n            i = int(capitol);\r\n            (,nextID) = e.getCity(uint(i));\r\n            for(; nextID >= 0 ;) {\r\n                i = nextID;\r\n                (,nextID) = e.getCity(uint(i));\r\n            }\r\n            e.setNextID(uint(i), int(e.numCities()));\r\n            e.setPreviousID(e.numCities(), i);\r\n        }\r\n        e.setNextID(e.numCities(), -1);\r\n\r\n        e.setNumCities(e.numCities()+1);\r\n        \r\n        e.setMsg(msg.sender, 20 + rowcol[0]*100 + rowcol[1]*10000);\r\n        e.setLastTimestamp(playerID, now);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"sete\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"uint256\"},{\"name\":\"target\",\"type\":\"uint256\"},{\"name\":\"unitIndxs\",\"type\":\"uint256[]\"}],\"name\":\"attack\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cityName\",\"type\":\"string\"},{\"name\":\"rowcol\",\"type\":\"uint256[2]\"},{\"name\":\"rowcolref\",\"type\":\"uint256[2]\"}],\"name\":\"buildCity\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"e\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"EtherizationUtils2","CompilerVersion":"v0.3.5-nightly.2016.8.8+commit.c3ed550","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}