{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n/**\r\n * Author: Nick Johnson <arachnid at notdot.net>\r\n * \r\n * WARNING: This contract is new and thus-far only lightly tested. I'm fairly\r\n * confident it operates as described, but you may want to assure yourself of\r\n * its correctness - or wait for others to do so for you - before you trust your\r\n * ether to it. No guarantees, express or implied, are provided - use at your\r\n * own risk.\r\n * \r\n * @dev Ether vault contract. Stores ether with a 'time lock' on withdrawals,\r\n *      giving a user the chance to reclaim funds if an account is compromised.\r\n *      A recovery address has the ability to immediately destroy the wallet and\r\n *      send its funds to a new contract (such as a new vault, if the wallet)\r\n *      associated with this one is compromised or lost). A cold wallet or\r\n *      secure brain wallet should typically be used for this purpose.\r\n * \r\n * Setup:\r\n *   To set up a vault, first create a cold wallet or secure brain wallet to use\r\n *   as a recovery key, and get its address. Then, deploy this vault contract\r\n *   with the address of the recovery key, and a time delay (in seconds) to\r\n *   impose on withdrawals.\r\n * \r\n * Deposits:\r\n *   Simply deposit funds into this contract by sending them to them. This\r\n *   contract only uses the minimum gas stipend, so it's safe to use with\r\n *   sites that \"don't support smart contracts\".\r\n * \r\n * Withdrawals:\r\n *   Call unvault() with the amount you wish to withdraw (in wei - one ether is\r\n *   1e18 wei). After the time delay you specified when you created the wallet,\r\n *   you can call withdraw() to receive the funds.\r\n * \r\n * Vacations:\r\n *   If you anticipate not having access to the recovery key for some period,\r\n *   you can call `lock()` with a period (in seconds) that the funds should be\r\n *   unavailable for; this will prohibit any withdrawals completing during that\r\n *   period. If a withdrawal is outstanding, it will be postponed until the\r\n *   end of this period, too.\r\n * \r\n * Recovery:\r\n *   If your hotwallet is every compromised, or you detect an unauthorized\r\n *   `Unvault()` event, use your recovery key to call the `recover()` function\r\n *   with the address you want funds sent to. The funds will be immediately\r\n *   sent to this address (with no delay) and the contract will self destruct.\r\n * \r\n *   For safety, you may wish to prepare a new vault (with a new recovery key)\r\n *   and send your funds directly to that.\r\n */\r\ncontract Vault {\r\n    /**\r\n     * @dev Owner of the vault.\r\n     */\r\n    address public owner;\r\n    \r\n    /**\r\n     * @dev Recovery address for this vault.\r\n     */\r\n    address public recovery;\r\n\r\n    /**\r\n     * @dev Minimum interval between making an unvault call and allowing a\r\n     *      withdrawal.\r\n     */\r\n    uint public withdrawDelay;\r\n\r\n    /**\r\n     * @dev Earliest time at which a withdrawal can be made.\r\n     *      Valid iff withdrawAmount > 0.\r\n     */\r\n    uint public withdrawTime;\r\n    \r\n    /**\r\n     * @dev Amount requested to be withdrawn.\r\n     */\r\n    uint public withdrawAmount;\r\n\r\n    \r\n    modifier only_owner() {\r\n        if(msg.sender != owner) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier only_recovery() {\r\n        if(msg.sender != recovery) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdrawal request made\r\n     */\r\n    event Unvault(uint amount, uint when);\r\n    \r\n    /**\r\n     * @dev Recovery key used to send all funds to `address`.\r\n     */\r\n    event Recover(address target, uint value);\r\n    \r\n    /**\r\n     * @dev Funds deposited.\r\n     */\r\n    event Deposit(address from, uint value);\r\n    \r\n    /**\r\n     * @dev Funds withdrawn.\r\n     */\r\n    event Withdraw(address to, uint value);\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _recovery The address of the recovery account.\r\n     * @param _withdrawDelay The time (in seconds) between an unvault request\r\n     *        and the earliest time a withdrawal can be made.\r\n     */\r\n    function Vault(address _recovery, uint _withdrawDelay) {\r\n        owner = msg.sender;\r\n        recovery = _recovery;\r\n        withdrawDelay = _withdrawDelay;\r\n    }\r\n    \r\n    function max(uint a, uint b) internal returns (uint) {\r\n        if(a > b)\r\n            return a;\r\n        return b;\r\n    }\r\n    \r\n    /**\r\n     * @dev Request withdrawal of funds from the vault. Starts a timer for when\r\n     *      funds can be withdrawn. Increases to the amount will reset the\r\n     *      timer, but decreases can be made without changing it.\r\n     * @param amount The amount requested for withdrawal.\r\n     */\r\n    function unvault(uint amount) only_owner {\r\n        if(amount > this.balance)\r\n            throw;\r\n            \r\n        // Update the withdraw time if we're withdrawing more than previously.\r\n        if(amount > withdrawAmount)\r\n            withdrawTime = max(withdrawTime, block.timestamp + withdrawDelay);\r\n        \r\n        withdrawAmount = amount;\r\n        Unvault(amount, withdrawTime);\r\n    }\r\n    \r\n    /**\r\n     * @dev Withdraw funds. Valid only after `unvault` has been called and the\r\n     *      required interval has elapsed.\r\n     */\r\n    function withdraw() only_owner {\r\n        if(block.timestamp < withdrawTime || withdrawAmount == 0)\r\n            throw;\r\n        \r\n        uint amount = withdrawAmount;\r\n        withdrawAmount = 0;\r\n\r\n        if(!owner.send(amount))\r\n            throw;\r\n\r\n        Withdraw(owner, amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Use the recovery address to send all funds to the nominated address\r\n     *      and self-destruct this vault.\r\n     * @param target The target address to send funds to.\r\n     */\r\n    function recover(address target) only_recovery {\r\n        Recover(target, this.balance);\r\n        selfdestruct(target);\r\n    }\r\n    \r\n    /**\r\n     * @dev Permits locking funds for longer than the default duration; useful\r\n     *      if you will not have access to your recovery key for a while.\r\n     */\r\n    function lock(uint duration) only_owner {\r\n        withdrawTime = max(withdrawTime, block.timestamp + duration);\r\n    }\r\n    \r\n    function() payable {\r\n        if(msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"withdrawDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unvault\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recovery\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_recovery\",\"type\":\"address\"},{\"name\":\"_withdrawDelay\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"Unvault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Recover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"Vault","CompilerVersion":"v0.4.2-nightly.2016.9.15+commit.6a80511","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a99aed422e58076c37b68e9c99427f0e000000000000000000000000000000000000000000000000000000000000000000093a80","Library":"","SwarmSource":""}]}