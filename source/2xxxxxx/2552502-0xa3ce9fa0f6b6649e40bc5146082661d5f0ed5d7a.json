{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n/**\r\n * @title Contract for object that have an owner\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev Store owner on creation\r\n     */\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    /**\r\n     * @dev Delegate contract to another person\r\n     * @param _owner is another person address\r\n     */\r\n    function delegate(address _owner) onlyOwner\r\n    { owner = _owner; }\r\n\r\n    /**\r\n     * @dev Owner check modifier\r\n     */\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\n}\r\n/**\r\n * @title Contract for objects that can be morder\r\n */\r\ncontract Mortal is Owned {\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can kill me\r\n     */\r\n    function kill() onlyOwner\r\n    { suicide(owner); }\r\n}\r\n/**\r\n * @title Token contract represents any asset in digital economy\r\n */\r\ncontract Token is Mortal {\r\n    event Transfer(address indexed _from,  address indexed _to,      uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /* Short description of token */\r\n    string public name;\r\n    string public symbol;\r\n\r\n    /* Total count of tokens exist */\r\n    uint public totalSupply;\r\n\r\n    /* Fixed point position */\r\n    uint8 public decimals;\r\n    \r\n    /* Token approvement system */\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n \r\n    /**\r\n     * @return available balance of `sender` account (self balance)\r\n     */\r\n    function getBalance() constant returns (uint)\r\n    { return balanceOf[msg.sender]; }\r\n \r\n    /**\r\n     * @dev This method returns non zero result when sender is approved by\r\n     *      argument address and target address have non zero self balance\r\n     * @param _address target address \r\n     * @return available for `sender` balance of given address\r\n     */\r\n    function getBalance(address _address) constant returns (uint) {\r\n        return allowance[_address][msg.sender]\r\n             > balanceOf[_address] ? balanceOf[_address]\r\n                                   : allowance[_address][msg.sender];\r\n    }\r\n \r\n    /* Token constructor */\r\n    function Token(string _name, string _symbol, uint8 _decimals, uint _count) {\r\n        name     = _name;\r\n        symbol   = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply           = _count;\r\n        balanceOf[msg.sender] = _count;\r\n    }\r\n \r\n    /**\r\n     * @dev Transfer self tokens to given address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice `_value` tokens will be sended to `_to`\r\n     * @return `true` when transfer done\r\n     */\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        if (balanceOf[msg.sender] >= _value) {\r\n            balanceOf[msg.sender] -= _value;\r\n            balanceOf[_to]        += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer with approvement mechainsm\r\n     * @param _from source address, `_value` tokens shold be approved for `sender`\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send \r\n     * @notice from `_from` will be sended `_value` tokens to `_to`\r\n     * @return `true` when transfer is done\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        var avail = allowance[_from][msg.sender]\r\n                  > balanceOf[_from] ? balanceOf[_from]\r\n                                     : allowance[_from][msg.sender];\r\n        if (avail >= _value) {\r\n            allowance[_from][msg.sender] -= _value;\r\n            balanceOf[_from] -= _value;\r\n            balanceOf[_to]   += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Give to target address ability for self token manipulation without sending\r\n     * @param _address target address\r\n     * @param _value amount of token values for approving\r\n     */\r\n    function approve(address _address, uint _value) {\r\n        allowance[msg.sender][_address] += _value;\r\n        Approval(msg.sender, _address, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Reset count of tokens approved for given address\r\n     * @param _address target address\r\n     */\r\n    function unapprove(address _address)\r\n    { allowance[msg.sender][_address] = 0; }\r\n}\r\n/**\r\n * @title Ethereum crypto currency extention for Token contract\r\n */\r\ncontract TokenEther is Token {\r\n    function TokenEther(string _name, string _symbol)\r\n             Token(_name, _symbol, 18, 0)\r\n    {}\r\n\r\n    /**\r\n     * @dev This is the way to withdraw money from token\r\n     * @param _value how many tokens withdraw from balance\r\n     */\r\n    function withdraw(uint _value) {\r\n        if (balanceOf[msg.sender] >= _value) {\r\n            balanceOf[msg.sender] -= _value;\r\n            totalSupply           -= _value;\r\n            if(!msg.sender.send(_value)) throw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is the way to refill your token balance by ethers\r\n     */\r\n    function refill() payable returns (bool) {\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev This method is called when money sended to contract address,\r\n     *      a synonym for refill()\r\n     */\r\n    function () payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n    }\r\n    \r\n    /**\r\n     * @dev By security issues token that holds ethers can not be killed\r\n     */\r\n    function kill() onlyOwner { throw; }\r\n}\r\n\r\n\r\n//sol Registrar\r\n// Simple global registrar.\r\n// @authors:\r\n//   Gav Wood <g@ethdev.com>\r\n\r\ncontract Registrar {\r\n\tevent Changed(string indexed name);\r\n\r\n\tfunction owner(string _name) constant returns (address o_owner);\r\n\tfunction addr(string _name) constant returns (address o_address);\r\n\tfunction subRegistrar(string _name) constant returns (address o_subRegistrar);\r\n\tfunction content(string _name) constant returns (bytes32 o_content);\r\n}\r\n\r\n//sol OwnedRegistrar\r\n// Global registrar with single authoritative owner.\r\n// @authors:\r\n//   Gav Wood <g@ethdev.com>\r\n\r\ncontract AiraRegistrarService is Registrar, Mortal {\r\n\tstruct Record {\r\n\t\taddress addr;\r\n\t\taddress subRegistrar;\r\n\t\tbytes32 content;\r\n\t}\r\n\t\r\n    function owner(string _name) constant returns (address o_owner)\r\n    { return 0; }\r\n\r\n\tfunction disown(string _name) onlyOwner {\r\n\t\tdelete m_toRecord[_name];\r\n\t\tChanged(_name);\r\n\t}\r\n\r\n\tfunction setAddr(string _name, address _a) onlyOwner {\r\n\t\tm_toRecord[_name].addr = _a;\r\n\t\tChanged(_name);\r\n\t}\r\n\tfunction setSubRegistrar(string _name, address _registrar) onlyOwner {\r\n\t\tm_toRecord[_name].subRegistrar = _registrar;\r\n\t\tChanged(_name);\r\n\t}\r\n\tfunction setContent(string _name, bytes32 _content) onlyOwner {\r\n\t\tm_toRecord[_name].content = _content;\r\n\t\tChanged(_name);\r\n\t}\r\n\tfunction record(string _name) constant returns (address o_addr, address o_subRegistrar, bytes32 o_content) {\r\n\t\to_addr = m_toRecord[_name].addr;\r\n\t\to_subRegistrar = m_toRecord[_name].subRegistrar;\r\n\t\to_content = m_toRecord[_name].content;\r\n\t}\r\n\tfunction addr(string _name) constant returns (address) { return m_toRecord[_name].addr; }\r\n\tfunction subRegistrar(string _name) constant returns (address) { return m_toRecord[_name].subRegistrar; }\r\n\tfunction content(string _name) constant returns (bytes32) { return m_toRecord[_name].content; }\r\n\r\n\tmapping (string => Record) m_toRecord;\r\n}\r\n\r\ncontract AiraEtherFunds is TokenEther {\r\n    function AiraEtherFunds(address _bot_reg, string _name, string _symbol)\r\n            TokenEther(_name, _symbol) {\r\n        reg = AiraRegistrarService(_bot_reg);\r\n    }\r\n\r\n    /**\r\n     * @dev Event spawned when activation request received\r\n     */\r\n    event ActivationRequest(address indexed sender, bytes32 indexed code);\r\n\r\n    // Balance limit\r\n    uint public limit;\r\n    \r\n    function setLimit(uint _limit) onlyOwner\r\n    { limit = _limit; }\r\n\r\n    // Account activation fee\r\n    uint public fee;\r\n    \r\n    function setFee(uint _fee) onlyOwner\r\n    { fee = _fee; }\r\n\r\n    /**\r\n     * @dev Refill balance and activate it by code\r\n     * @param _code is activation code\r\n     */\r\n    function activate(string _code) payable {\r\n        var value = msg.value;\r\n \r\n        // Get a fee\r\n        if (fee > 0) {\r\n            if (value < fee) throw;\r\n            balanceOf[owner] += fee;\r\n            value            -= fee;\r\n        }\r\n\r\n        // Refund over limit\r\n        if (limit > 0 && value > limit) {\r\n            var refund = value - limit;\r\n            if (!msg.sender.send(refund)) throw;\r\n            value = limit;\r\n        }\r\n\r\n        // Refill account balance\r\n        balanceOf[msg.sender] += value;\r\n        totalSupply           += value;\r\n\r\n        // Activation event\r\n        ActivationRequest(msg.sender, stringToBytes32(_code));\r\n    }\r\n\r\n    /**\r\n     * @dev String to bytes32 conversion helper\r\n     */\r\n    function stringToBytes32(string memory source) constant returns (bytes32 result)\r\n    { assembly { result := mload(add(source, 32)) } }\r\n\r\n    /**\r\n     * @dev This is the way to refill your token balance by ethers\r\n     */\r\n    function refill() payable returns (bool) {\r\n        // Throw when over limit\r\n        if (balanceOf[msg.sender] + msg.value > limit) throw;\r\n\r\n        // Refill\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev This is the way to refill token balance by ethers\r\n     * @param _dest is destination address\r\n     */\r\n    function refill(address _dest) payable returns (bool) {\r\n        // Throw when over limit\r\n        if (balanceOf[_dest] + msg.value > limit) throw;\r\n\r\n        // Refill\r\n        balanceOf[_dest] += msg.value;\r\n        totalSupply      += msg.value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev This method is called when money sended to contract address,\r\n     *      a synonym for refill()\r\n     */\r\n    function () payable {\r\n        // Throw when over limit\r\n        if (balanceOf[msg.sender] + msg.value > limit) throw;\r\n\r\n        // Refill\r\n        balanceOf[msg.sender] += msg.value;\r\n        totalSupply           += msg.value;\r\n    }\r\n\r\n    /**\r\n     * @dev Outgoing transfer (send) with allowance\r\n     * @param _from source address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send \r\n     */\r\n    function sendFrom(address _from, address _to, uint _value) {\r\n        var avail = allowance[_from][msg.sender]\r\n                  > balanceOf[_from] ? balanceOf[_from]\r\n                                     : allowance[_from][msg.sender];\r\n        if (avail >= _value) {\r\n            allowance[_from][msg.sender] -= _value;\r\n            balanceOf[_from]             -= _value;\r\n            totalSupply                  -= _value;\r\n            if (!_to.send(_value)) throw;\r\n        }\r\n    }\r\n\r\n    AiraRegistrarService public reg;\r\n    modifier onlySecure { if (msg.sender != reg.addr(\"AiraSecure\")) throw; _; }\r\n\r\n    /**\r\n     * @dev Increase approved token values for AiraEthBot\r\n     * @param _client is a client address\r\n     * @param _value is amount of tokens\r\n     */\r\n    function secureApprove(address _client, uint _value) onlySecure {\r\n        var ethBot = reg.addr(\"AiraEth\");\r\n        if (ethBot != 0)\r\n            allowance[_client][ethBot] += _value;\r\n    }\r\n\r\n    /**\r\n     * @dev Close allowance for AiraEthBot\r\n     */\r\n    function secureUnapprove(address _client) onlySecure {\r\n        var ethBot = reg.addr(\"AiraEth\");\r\n        if (ethBot != 0)\r\n            allowance[_client][ethBot] = 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"secureApprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refill\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sendFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reg\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"}],\"name\":\"refill\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"secureUnapprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"unapprove\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bot_reg\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"ActivationRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"AiraEtherFunds","CompilerVersion":"v0.4.3+commit.2353da71","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d9f66e1e1dc316728d63c027e2597a33de4fe19b000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000e41697261457468657246756e647300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034554480000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":""}]}