{"status":"1","message":"OK","result":[{"SourceCode":"contract ThisExternalAssembly {\r\n    uint public numcalls;\r\n    uint public numcallsinternal;\r\n    uint public numfails;\r\n    uint public numsuccesses;\r\n    \r\n    address owner;\r\n\r\n    event logCall(uint indexed _numcalls, uint indexed _numcallsinternal);\r\n    \r\n    modifier onlyOwner { if (msg.sender != owner) throw; _ }\r\n    modifier onlyThis { if (msg.sender != address(this)) throw; _ }\r\n\r\n    // constructor\r\n    function ThisExternalAssembly() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function failSend() external onlyThis returns (bool) {\r\n        // storage change + nested external call\r\n        numcallsinternal++;\r\n        owner.send(42);\r\n\r\n        // placeholder for state checks\r\n        if (true) throw;\r\n\r\n        // never happens in this case\r\n        return true;\r\n    }\r\n    \r\n    function doCall(uint _gas) onlyOwner {\r\n        numcalls++;\r\n\r\n        address addr = address(this);\r\n        bytes4 sig = bytes4(sha3(\"failSend()\"));\r\n\r\n        bool ret;\r\n\r\n        // work around `solc` safeguards for throws in external calls\r\n        // https://ethereum.stackexchange.com/questions/6354/\r\n        assembly {\r\n            let x := mload(0x40) // read \"empty memory\" pointer\r\n            mstore(x,sig)\r\n\r\n            ret := call(\r\n                _gas, // gas amount\r\n                addr, // recipient account\r\n                0,    // value (no need to pass)\r\n                x,    // input start location\r\n                0x4,  // input size - just the sig\r\n                x,    // output start location\r\n                0x1)  // output size (bool - 1 byte)\r\n\r\n            //ret := mload(x) // no return value ever written :/\r\n            mstore(0x40,add(x,0x4)) // just in case, roll the tape\r\n        }\r\n\r\n        if (ret) { numsuccesses++; }\r\n        else { numfails++; }\r\n\r\n        // mostly helps with function identification if disassembled\r\n        logCall(numcalls, numcallsinternal);\r\n    }\r\n\r\n    // will clean-up :)\r\n    function selfDestruct() onlyOwner { selfdestruct(owner); }\r\n    \r\n    function() { throw; }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"numsuccesses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numfails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numcalls\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numcallsinternal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"failSend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"doCall\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_numcalls\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_numcallsinternal\",\"type\":\"uint256\"}],\"name\":\"logCall\",\"type\":\"event\"}]","ContractName":"ThisExternalAssembly","CompilerVersion":"v0.3.5-2016-08-07-f7af7de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}