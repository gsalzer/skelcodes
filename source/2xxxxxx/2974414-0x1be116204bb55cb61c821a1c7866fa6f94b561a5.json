{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 DFINITY Stiftung \r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n/**\r\n * title:  The DFINITY Stiftung donation contract (FDC).\r\n * author: Timo Hanke \r\n *\r\n * This contract \r\n *  - accepts on-chain donations for the foundation in ether \r\n *  - tracks on-chain and off-chain donations made to the foundation\r\n *  - assigns unrestricted tokens to addresses provided by donors\r\n *  - assigns restricted tokens to DFINITY Stiftung and early contributors \r\n *\r\n * On-chain donations are received in ether are converted to Swiss francs (CHF).\r\n * Off-chain donations are received and recorded directly in Swiss francs.\r\n * Tokens are assigned at a rate of 10 tokens per CHF. \r\n *\r\n * There are two types of tokens initially. Unrestricted tokens are assigned to\r\n * donors and restricted tokens are assigned to DFINITY Stiftung and early \r\n * contributors. Restricted tokens are converted to unrestricted tokens in the \r\n * finalization phase, after which only unrestricted tokens exist.\r\n *\r\n * After the finalization phase, tokens assigned to DFINITY Stiftung and early \r\n * contributors will make up a pre-defined share of all tokens. This is achieved\r\n * through burning excess restricted tokens before their restriction is removed.\r\n */\r\n\r\npragma solidity ^0.4.6;\r\n\r\n// import \"TokenTracker.sol\";\r\n\r\n/**\r\n * title:  A contract that tracks numbers of tokens assigned to addresses. \r\n * author: Timo Hanke \r\n *\r\n * Optionally, assignments can be chosen to be of \"restricted type\". \r\n * Being \"restricted\" means that the token assignment may later be partially\r\n * reverted (or the tokens \"burned\") by the contract. \r\n *\r\n * After all token assignments are completed the contract\r\n *   - burns some restricted tokens\r\n *   - releases the restriction on the remaining tokens\r\n * The percentage of tokens that burned out of each assignment of restricted\r\n * tokens is calculated to achieve the following condition:\r\n *   - the remaining formerly restricted tokens combined have a pre-configured\r\n *     share (percentage) among all remaining tokens.\r\n *\r\n * Once the conversion process has started the contract enters a state in which\r\n * no more assignments can be made.\r\n */\r\n\r\ncontract TokenTracker {\r\n  // Share of formerly restricted tokens among all tokens in percent \r\n  uint public restrictedShare; \r\n\r\n  // Mapping from address to number of tokens assigned to the address\r\n  mapping(address => uint) public tokens;\r\n\r\n  // Mapping from address to number of tokens assigned to the address that\r\n  // underly a restriction\r\n  mapping(address => uint) public restrictions;\r\n  \r\n  // Total number of (un)restricted tokens currently in existence\r\n  uint public totalRestrictedTokens; \r\n  uint public totalUnrestrictedTokens; \r\n  \r\n  // Total number of individual assignment calls have been for (un)restricted\r\n  // tokens\r\n  uint public totalRestrictedAssignments; \r\n  uint public totalUnrestrictedAssignments; \r\n\r\n  // State flag. Assignments can only be made if false. \r\n  // Starting the conversion (burn) process irreversibly sets this to true. \r\n  bool public assignmentsClosed = false;\r\n  \r\n  // The multiplier (defined by nominator and denominator) that defines the\r\n  // fraction of all restricted tokens to be burned. \r\n  // This is computed after assignments have ended and before the conversion\r\n  // process starts.\r\n  uint public burnMultDen;\r\n  uint public burnMultNom;\r\n\r\n  function TokenTracker(uint _restrictedShare) {\r\n    // Throw if restricted share >= 100\r\n    if (_restrictedShare >= 100) { throw; }\r\n    \r\n    restrictedShare = _restrictedShare;\r\n  }\r\n  \r\n  /** \r\n   * PUBLIC functions\r\n   *\r\n   *  - isUnrestricted (getter)\r\n   *  - multFracCeiling (library function)\r\n   *  - isRegistered(addr) (getter)\r\n   */\r\n  \r\n  /**\r\n   * Return true iff the assignments are closed and there are no restricted\r\n   * tokens left \r\n   */\r\n  function isUnrestricted() constant returns (bool) {\r\n    return (assignmentsClosed && totalRestrictedTokens == 0);\r\n  }\r\n\r\n  /**\r\n   * Return the ceiling of (x*a)/b\r\n   *\r\n   * Edge cases:\r\n   *   a = 0: return 0\r\n   *   b = 0, a != 0: error (solidity throws on division by 0)\r\n   */\r\n  function multFracCeiling(uint x, uint a, uint b) returns (uint) {\r\n    // Catch the case a = 0\r\n    if (a == 0) { return 0; }\r\n    \r\n    // Rounding up is the same as adding 1-epsilon and rounding down.\r\n    // 1-epsilon is modeled as (b-1)/b below.\r\n    return (x * a + (b - 1)) / b; \r\n  }\r\n    \r\n  /**\r\n   * Return true iff the address has tokens assigned (resp. restricted tokens)\r\n   */\r\n  function isRegistered(address addr, bool restricted) constant returns (bool) {\r\n    if (restricted) {\r\n      return (restrictions[addr] > 0);\r\n    } else {\r\n      return (tokens[addr] > 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * INTERNAL functions\r\n   *\r\n   *  - assign\r\n   *  - closeAssignments \r\n   *  - unrestrict \r\n   */\r\n   \r\n  /**\r\n   * Assign (un)restricted tokens to given address\r\n   */\r\n  function assign(address addr, uint tokenAmount, bool restricted) internal {\r\n    // Throw if assignments have been closed\r\n    if (assignmentsClosed) { throw; }\r\n\r\n    // Assign tokens\r\n    tokens[addr] += tokenAmount;\r\n\r\n    // Record restrictions and update total counters\r\n    if (restricted) {\r\n      totalRestrictedTokens += tokenAmount;\r\n      totalRestrictedAssignments += 1;\r\n      restrictions[addr] += tokenAmount;\r\n    } else {\r\n      totalUnrestrictedTokens += tokenAmount;\r\n      totalUnrestrictedAssignments += 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close future assignments.\r\n   *\r\n   * This is irreversible and closes all future assignments.\r\n   * The function can only be called once.\r\n   *\r\n   * A call triggers the calculation of what fraction of restricted tokens\r\n   * should be burned by subsequent calls to the unrestrict() function.\r\n   * The result of this calculation is a multiplication factor whose nominator\r\n   * and denominator are stored in the contract variables burnMultNom,\r\n   * burnMultDen.\r\n   */\r\n  function closeAssignmentsIfOpen() internal {\r\n    // Return if assignments are not open\r\n    if (assignmentsClosed) { return; } \r\n    \r\n    // Set the state to \"closed\"\r\n    assignmentsClosed = true;\r\n\r\n    /*\r\n     *  Calculate the total number of tokens that should remain after\r\n     *  conversion.  This is based on the total number of unrestricted tokens\r\n     *  assigned so far and the pre-configured share that the remaining\r\n     *  formerly restricted tokens should have.\r\n     */\r\n    uint totalTokensTarget = (totalUnrestrictedTokens * 100) / \r\n      (100 - restrictedShare);\r\n    \r\n    // The total number of tokens in existence now.\r\n    uint totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens;\r\n      \r\n    /*\r\n     * The total number of tokens that need to be burned to bring the existing\r\n     * number down to the target number. If the existing number is lower than\r\n     * the target then we won't burn anything.\r\n     */\r\n    uint totalBurn = 0; \r\n    if (totalTokensExisting > totalTokensTarget) {\r\n      totalBurn = totalTokensExisting - totalTokensTarget; \r\n    }\r\n\r\n    // The fraction of restricted tokens to be burned (by nominator and\r\n    // denominator).\r\n    burnMultNom = totalBurn;\r\n    burnMultDen = totalRestrictedTokens;\r\n    \r\n    /*\r\n     * For verifying the correctness of the above calculation it may help to\r\n     * note the following.\r\n     * Given 0 <= restrictedShare < 100, we have:\r\n     *  - totalTokensTarget >= totalUnrestrictedTokens\r\n     *  - totalTokensExisting <= totalRestrictedTokens + totalTokensTarget\r\n     *  - totalBurn <= totalRestrictedTokens\r\n     *  - burnMultNom <= burnMultDen\r\n     * Also note that burnMultDen = 0 means totalRestrictedTokens = 0, in which\r\n     * burnMultNom = 0 as well.\r\n     */\r\n  }\r\n\r\n  /**\r\n   * Unrestrict (convert) all restricted tokens assigned to the given address\r\n   *\r\n   * This function can only be called after assignments have been closed via\r\n   * closeAssignments().\r\n   * The return value is the number of restricted tokens that were burned in\r\n   * the conversion.\r\n   */\r\n  function unrestrict(address addr) internal returns (uint) {\r\n    // Throw is assignments are not yet closed\r\n    if (!assignmentsClosed) { throw; }\r\n\r\n    // The balance of restricted tokens for the given address \r\n    uint restrictionsForAddr = restrictions[addr];\r\n    \r\n    // Throw if there are none\r\n    if (restrictionsForAddr == 0) { throw; }\r\n\r\n    // Apply the burn multiplier to the balance of restricted tokens\r\n    // The result is the ceiling of the value: \r\n    // (restrictionForAddr * burnMultNom) / burnMultDen\r\n    uint burn = multFracCeiling(restrictionsForAddr, burnMultNom, burnMultDen);\r\n\r\n    // Remove the tokens to be burned from the address's balance\r\n    tokens[addr] -= burn;\r\n    \r\n    // Delete record of restrictions \r\n    delete restrictions[addr];\r\n    \r\n    // Update the counters for total (un)restricted tokens\r\n    totalRestrictedTokens   -= restrictionsForAddr;\r\n    totalUnrestrictedTokens += restrictionsForAddr - burn;\r\n      \r\n    return burn;\r\n  }\r\n}\r\n\r\n// import \"Phased.sol\";\r\n\r\n/*\r\n * title: Contract that advances through multiple configurable phases over time\r\n * author: Timo Hanke \r\n * \r\n * Phases are defined by their transition times. The moment one phase ends the\r\n * next one starts. Each time belongs to exactly one phase.\r\n *\r\n * The contract allows a limited set of changes to be applied to the phase\r\n * transitions while the contract is active.  As a matter of principle, changes\r\n * are prohibited from effecting the past. They may only ever affect future\r\n * phase transitions.\r\n *\r\n * The permitted changes are:\r\n *   - add a new phase after the last one\r\n *   - end the current phase right now and transition to the next phase\r\n *     immediately \r\n *   - delay the start of a future phase (thereby pushing out all subsequent\r\n *     phases by an equal amount of time)\r\n *   - define a maximum delay for a specified phase \r\n */\r\n \r\n\r\ncontract Phased {\r\n  /**\r\n   * Array of transition times defining the phases\r\n   *   \r\n   * phaseEndTime[i] is the time when phase i has just ended.\r\n   * Phase i is defined as the following time interval: \r\n   *   [ phaseEndTime[i-1], * phaseEndTime[i] )\r\n   */\r\n  uint[] public phaseEndTime;\r\n\r\n  /**\r\n   * Number of phase transitions N = phaseEndTime.length \r\n   *\r\n   * There are N+1 phases, numbered 0,..,N.\r\n   * The first phase has no start and the last phase has no end.\r\n   */\r\n  uint public N; \r\n\r\n  /**\r\n   *  Maximum delay for phase transitions\r\n   *\r\n   *  maxDelay[i] is the maximum amount of time by which the transition\r\n   *  phaseEndTime[i] can be delayed.\r\n  */\r\n  mapping(uint => uint) public maxDelay; \r\n\r\n  /*\r\n   * The contract has no constructor.\r\n   * The contract initialized itself with no phase transitions (N = 0) and one\r\n   * phase (N+1=1).\r\n   *\r\n   * There are two PUBLIC functions (getters):\r\n   *  - getPhaseAtTime\r\n   *  - isPhase\r\n   *  - getPhaseStartTime\r\n   *\r\n   * Note that both functions are guaranteed to return the same value when\r\n   * called twice with the same argument (but at different times).\r\n   */\r\n\r\n  /**\r\n   * Return the number of the phase to which the given time belongs.\r\n   *\r\n   * Return value i means phaseEndTime[i-1] <= time < phaseEndTime[i].\r\n   * The given time must not be in the future (because future phase numbers may\r\n   * still be subject to change).\r\n   */\r\n  function getPhaseAtTime(uint time) constant returns (uint n) {\r\n    // Throw if time is in the future\r\n    if (time > now) { throw; }\r\n    \r\n    // Loop until we have found the \"active\" phase\r\n    while (n < N && phaseEndTime[n] <= time) {\r\n      n++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return true if the given time belongs to the given phase.\r\n   *\r\n   * Returns the logical equivalent of the expression \r\n   *   (phaseEndTime[i-1] <= time < phaseEndTime[i]).\r\n   *\r\n   * The given time must not be in the future (because future phase numbers may\r\n   * still be subject to change).\r\n   */\r\n  function isPhase(uint time, uint n) constant returns (bool) {\r\n    // Throw if time is in the future\r\n    if (time > now) { throw; }\r\n    \r\n    // Throw if index is out-of-range\r\n    if (n >= N) { throw; }\r\n    \r\n    // Condition 1\r\n    if (n > 0 && phaseEndTime[n-1] > time) { return false; } \r\n    \r\n    // Condition 2\r\n    if (n < N && time >= phaseEndTime[n]) { return false; } \r\n   \r\n    return true; \r\n  }\r\n  \r\n  /**\r\n   * Return the start time of the given phase.\r\n   *\r\n   * This function is provided for convenience.\r\n   * The given phase number must not be 0, as the first phase has no start time.\r\n   * If calling for a future phase number the caller must be aware that future\r\n   * phase times can be subject to change.\r\n   */\r\n  function getPhaseStartTime(uint n) constant returns (uint) {\r\n    // Throw if phase is the first phase\r\n    if (n == 0) { throw; }\r\n   \r\n    return phaseEndTime[n-1];\r\n  }\r\n    \r\n  /*\r\n   *  There are 4 INTERNAL functions:\r\n   *    1. addPhase\r\n   *    2. setMaxDelay\r\n   *    3. delayPhaseEndBy\r\n   *    4. endCurrentPhaseIn\r\n   *\r\n   *  This contract does not implement access control to these function, so\r\n   *  they are made internal.\r\n   */\r\n   \r\n  /**\r\n   * 1. Add a phase after the last phase.\r\n   *\r\n   * The argument is the new endTime of the phase currently known as the last\r\n   * phase, or, in other words the start time of the newly introduced phase.  \r\n   * All calls to addPhase() MUST be with strictly increasing time arguments.\r\n   * It is not allowed to add a phase transition that lies in the past relative\r\n   * to the current block time.\r\n   */\r\n  function addPhase(uint time) internal {\r\n    // Throw if new transition time is not strictly increasing\r\n    if (N > 0 && time <= phaseEndTime[N-1]) { throw; } \r\n\r\n    // Throw if new transition time is not in the future\r\n    if (time <= now) { throw; }\r\n   \r\n    // Append new transition time to array \r\n    phaseEndTime.push(time);\r\n    N++;\r\n  }\r\n  \r\n  /**\r\n   * 2. Define a limit on the amount of time by which the given transition (i)\r\n   *    can be delayed.\r\n   *\r\n   * By default, transitions can not be delayed (limit = 0).\r\n   */\r\n  function setMaxDelay(uint i, uint timeDelta) internal {\r\n    // Throw if index is out-of-range\r\n    if (i >= N) { throw; }\r\n\r\n    maxDelay[i] = timeDelta;\r\n  }\r\n\r\n  /**\r\n   * 3. Delay the end of the given phase (n) by the given time delta. \r\n   *\r\n   * The given phase must not have ended.\r\n   *\r\n   * This function can be called multiple times for the same phase. \r\n   * The defined maximum delay will be enforced across multiple calls.\r\n   */\r\n  function delayPhaseEndBy(uint n, uint timeDelta) internal {\r\n    // Throw if index is out of range\r\n    if (n >= N) { throw; }\r\n\r\n    // Throw if phase has already ended\r\n    if (now >= phaseEndTime[n]) { throw; }\r\n\r\n    // Throw if the requested delay is higher than the defined maximum for the\r\n    // transition\r\n    if (timeDelta > maxDelay[n]) { throw; }\r\n\r\n    // Subtract from the current max delay, so maxDelay is honored across\r\n    // multiple calls\r\n    maxDelay[n] -= timeDelta;\r\n\r\n    // Push out all subsequent transitions by the same amount\r\n    for (uint i = n; i < N; i++) {\r\n      phaseEndTime[i] += timeDelta;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 4. End the current phase early.\r\n   *\r\n   * The current phase must not be the last phase, as the last phase has no end.\r\n   * The current phase will end at time now plus the given time delta.\r\n   *\r\n   * The minimal allowed time delta is 1. This is avoid a race condition for \r\n   * other transactions that are processed in the same block. \r\n   * Setting phaseEndTime[n] to now would push all later transactions from the \r\n   * same block into the next phase.\r\n   * If the specified timeDelta is 0 the function gracefully bumps it up to 1.\r\n   */\r\n  function endCurrentPhaseIn(uint timeDelta) internal {\r\n    // Get the current phase number\r\n    uint n = getPhaseAtTime(now);\r\n\r\n    // Throw if we are in the last phase\r\n    if (n >= N) { throw; }\r\n   \r\n    // Set timeDelta to the minimal allowed value\r\n    if (timeDelta == 0) { \r\n      timeDelta = 1; \r\n    }\r\n    \r\n    // The new phase end should be earlier than the currently defined phase\r\n    // end, otherwise we don't change it.\r\n    if (now + timeDelta < phaseEndTime[n]) { \r\n      phaseEndTime[n] = now + timeDelta;\r\n    }\r\n  }\r\n}\r\n\r\n// import \"StepFunction.sol\";\r\n\r\n/*\r\n * title:  A configurable step function \r\n * author: Timo Hanke \r\n *\r\n * The contract implements a step function going down from an initialValue to 0\r\n * in a number of steps (nSteps).\r\n * The steps are distributed equally over a given time (phaseLength).\r\n * Having n steps means that the time phaseLength is divided into n+1\r\n * sub-intervalls of equal length during each of which the function value is\r\n * constant. \r\n */\r\n\r\ncontract StepFunction {\r\n  uint public phaseLength;\r\n  uint public nSteps;\r\n  uint public step;\r\n\r\n  function StepFunction(uint _phaseLength, uint _initialValue, uint _nSteps) {\r\n    // Throw if phaseLength does not leave enough room for number of steps\r\n    if (_nSteps > _phaseLength) { throw; } \r\n  \r\n    // The reduction in value per step \r\n    step = _initialValue / _nSteps;\r\n    \r\n    // Throw if _initialValue was not divisible by _nSteps\r\n    if ( step * _nSteps != _initialValue) { throw; } \r\n\r\n    phaseLength = _phaseLength;\r\n    nSteps = _nSteps; \r\n  }\r\n \r\n  /*\r\n   * Note the following edge cases.\r\n   *   initialValue = 0: is valid and will create the constant zero function\r\n   *   nSteps = 0: is valid and will create the constant zero function (only 1\r\n   *   sub-interval)\r\n   *   phaseLength < nSteps: is valid, but unlikely to be intended (so the\r\n   *   constructor throws)\r\n   */\r\n  \r\n  /**\r\n   * Evaluate the step function at a given time  \r\n   *\r\n   * elapsedTime MUST be in the intervall [0,phaseLength)\r\n   * The return value is between initialValue and 0, never negative.\r\n   */\r\n  function getStepFunction(uint elapsedTime) constant returns (uint) {\r\n    // Throw is elapsedTime is out-of-range\r\n    if (elapsedTime >= phaseLength) { throw; }\r\n    \r\n    // The function value will bel calculated from the end value backwards.\r\n    // Hence we need the time left, which will lie in the intervall\r\n    // [0,phaseLength)\r\n    uint timeLeft  = phaseLength - elapsedTime - 1; \r\n\r\n    // Calculate the number of steps away from reaching end value\r\n    // When verifying the forumla below it may help to note:\r\n    //   at elapsedTime = 0 stepsLeft evaluates to nSteps,\r\n    //   at elapsedTime = -1 stepsLeft would evaluate to nSteps + 1.\r\n    uint stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength; \r\n\r\n    // Apply the step function\r\n    return stepsLeft * step;\r\n  }\r\n}\r\n\r\n// import \"Targets.sol\";\r\n\r\n/*\r\n * title: Contract implementing counters with configurable targets\r\n * author: Timo Hanke \r\n *\r\n * There is an arbitrary number of counters. Each counter is identified by its\r\n * counter id, a uint. Counters can never decrease.\r\n * \r\n * The contract has no constructor. The target values are set and re-set via\r\n * setTarget().\r\n */\r\n\r\ncontract Targets {\r\n\r\n  // Mapping from counter id to counter value \r\n  mapping(uint => uint) public counter;\r\n  \r\n  // Mapping from counter id to target value \r\n  mapping(uint => uint) public target;\r\n\r\n  // A public getter that returns whether the target was reached\r\n  function targetReached(uint id) constant returns (bool) {\r\n    return (counter[id] >= target[id]);\r\n  }\r\n  \r\n  /*\r\n   * Modifying counter or target are internal functions.\r\n   */\r\n  \r\n  // (Re-)set the target\r\n  function setTarget(uint id, uint _target) internal {\r\n    target[id] = _target;\r\n  }\r\n \r\n  // Add to the counter \r\n  // The function returns whether this current addition makes the counter reach\r\n  // or cross its target value \r\n  function addTowardsTarget(uint id, uint amount) \r\n    internal \r\n    returns (bool firstReached) \r\n  {\r\n    firstReached = (counter[id] < target[id]) && \r\n                   (counter[id] + amount >= target[id]);\r\n    counter[id] += amount;\r\n  }\r\n}\r\n\r\n// import \"Parameters.sol\";\r\n\r\n/**\r\n * title:  Configuration parameters for the FDC\r\n * author: Timo Hanke \r\n */\r\n\r\ncontract Parameters {\r\n\r\n  /*\r\n   * Time Constants\r\n   *\r\n   * Phases are, in this order: \r\n   *  earlyContribution (defined by end time)\r\n   *  pause\r\n   *  donation round0 (defined by start and end time)\r\n   *  pause\r\n   *  donation round1 (defined by start and end time)\r\n   *  pause\r\n   *  finalization (defined by start time, ends manually)\r\n   *  done\r\n   */\r\n\r\n  // The start of round 0 is set to 2017-01-17 19:00 of timezone Europe/Zurich\r\n  uint public constant round0StartTime      = 1484676000; \r\n  \r\n  // The start of round 1 is set to 2017-05-17 19:00 of timezone Europe/Zurich\r\n  // TZ=\"Europe/Zurich\" date -d \"2017-05-17 19:00\" \"+%s\"\r\n  uint public constant round1StartTime      = 1495040400; \r\n  \r\n  // Transition times that are defined by duration\r\n  uint public constant round0EndTime        = round0StartTime + 6 weeks;\r\n  uint public constant round1EndTime        = round1StartTime + 6 weeks;\r\n  uint public constant finalizeStartTime    = round1EndTime   + 1 weeks;\r\n  \r\n  // The finalization phase has a dummy end time because it is ended manually\r\n  uint public constant finalizeEndTime      = finalizeStartTime + 1000 years;\r\n  \r\n  // The maximum time by which donation round 1 can be delayed from the start \r\n  // time defined above\r\n  uint public constant maxRoundDelay     = 270 days;\r\n\r\n  // The time for which donation rounds remain open after they reach their \r\n  // respective targets   \r\n  uint public constant gracePeriodAfterRound0Target  = 1 days;\r\n  uint public constant gracePeriodAfterRound1Target  = 0 days;\r\n\r\n  /*\r\n   * Token issuance\r\n   * \r\n   * The following configuration parameters completely govern all aspects of the \r\n   * token issuance.\r\n   */\r\n  \r\n  // Tokens assigned for the equivalent of 1 CHF in donations\r\n  uint public constant tokensPerCHF = 10; \r\n  \r\n  // Minimal donation amount for a single on-chain donation\r\n  uint public constant minDonation = 1 ether; \r\n \r\n  // Bonus in percent added to donations throughout donation round 0 \r\n  uint public constant round0Bonus = 200; \r\n  \r\n  // Bonus in percent added to donations at beginning of donation round 1  \r\n  uint public constant round1InitialBonus = 25;\r\n  \r\n  // Number of down-steps for the bonus during donation round 1\r\n  uint public constant round1BonusSteps = 5;\r\n \r\n  // The CHF targets for each of the donation rounds, measured in cents of CHF \r\n  uint public constant millionInCents = 10**6 * 100;\r\n  uint public constant round0Target = 1 * millionInCents; \r\n  uint public constant round1Target = 20 * millionInCents;\r\n\r\n  // Share of tokens eventually assigned to DFINITY Stiftung and early \r\n  // contributors in % of all tokens eventually in existence\r\n  uint public constant earlyContribShare = 22; \r\n}\r\n\r\n// FDC.sol\r\n\r\ncontract FDC is TokenTracker, Phased, StepFunction, Targets, Parameters {\r\n  // An identifying string, set by the constructor\r\n  string public name;\r\n  \r\n  /*\r\n   * Phases\r\n   *\r\n   * The FDC over its lifetime runs through a number of phases. These phases are\r\n   * tracked by the base contract Phased.\r\n   *\r\n   * The FDC maps the chronologically defined phase numbers to semantically \r\n   * defined states.\r\n   */\r\n\r\n  // The FDC states\r\n  enum state {\r\n    pause,         // Pause without any activity \r\n    earlyContrib,  // Registration of DFINITY Stiftung/early contributions\r\n    round0,        // Donation round 0  \r\n    round1,        // Donation round 1 \r\n    offChainReg,   // Grace period for registration of off-chain donations\r\n    finalization,  // Adjustment of DFINITY Stiftung/early contribution tokens\r\n                   // down to their share\r\n    done           // Read-only phase\r\n  }\r\n\r\n  // Mapping from phase number (from the base contract Phased) to FDC state \r\n  mapping(uint => state) stateOfPhase;\r\n\r\n  /*\r\n   * Tokens\r\n   *\r\n   * The FDC uses base contract TokenTracker to:\r\n   *  - track token assignments for \r\n   *      - donors (unrestricted tokens)\r\n   *      - DFINITY Stiftung/early contributors (restricted tokens)\r\n   *  - convert DFINITY Stiftung/early contributor tokens down to their share\r\n   *\r\n   * The FDC uses the base contract Targets to:\r\n   *  - track the targets measured in CHF for each donation round\r\n   *\r\n   * The FDC itself:\r\n   *  - tracks the memos of off-chain donations (and prevents duplicates)\r\n   *  - tracks donor and early contributor addresses in two lists\r\n   */\r\n   \r\n  // Mapping to store memos that have been used \r\n  mapping(bytes32 => bool) memoUsed;\r\n\r\n  // List of registered addresses (each address will appear in one)\r\n  address[] public donorList;  \r\n  address[] public earlyContribList;  \r\n  \r\n  /*\r\n   * Exchange rate and ether handling\r\n   *\r\n   * The FDC keeps track of:\r\n   *  - the exchange rate between ether and Swiss francs\r\n   *  - the total and per address ether donations\r\n   */\r\n   \r\n  // Exchange rate between ether and Swiss francs\r\n  uint public weiPerCHF;       \r\n  \r\n  // Total number of Wei donated on-chain so far \r\n  uint public totalWeiDonated; \r\n  \r\n  // Mapping from address to total number of Wei donated for the address\r\n  mapping(address => uint) public weiDonated; \r\n\r\n  /*\r\n   * Access control \r\n   * \r\n   * The following three addresses have access to restricted functions of the \r\n   * FDC and to the donated funds.\r\n   */\r\n   \r\n  // Wallet address to which on-chain donations are being forwarded\r\n  address public foundationWallet; \r\n  \r\n  // Address that is allowed to register DFINITY Stiftung/early contributions\r\n  // and off-chain donations and to delay donation round 1\r\n  address public registrarAuth; \r\n  \r\n  // Address that is allowed to update the exchange rate\r\n  address public exchangeRateAuth; \r\n\r\n  // Address that is allowed to update the other authenticated addresses\r\n  address public masterAuth; \r\n\r\n  /*\r\n   * Global variables\r\n   */\r\n \r\n  // The phase numbers of the donation phases (set by the constructor, \r\n  // thereafter constant)\r\n  uint phaseOfRound0;\r\n  uint phaseOfRound1;\r\n  \r\n  /*\r\n   * Events\r\n   *\r\n   *  - DonationReceipt:     logs an on-chain or off-chain donation\r\n   *  - EarlyContribReceipt: logs the registration of early contribution \r\n   *  - BurnReceipt:         logs the burning of token during finalization\r\n   */\r\n  event DonationReceipt (address indexed addr,          // DFN address of donor\r\n                         string indexed currency,       // donation currency\r\n                         uint indexed bonusMultiplierApplied, // depends stage\r\n                         uint timestamp,                // time occurred\r\n                         uint tokenAmount,              // DFN to b recommended\r\n                         bytes32 memo);                 // unique note e.g TxID\r\n  event EarlyContribReceipt (address indexed addr,      // DFN address of donor \r\n                             uint tokenAmount,          // *restricted* tokens\r\n                             bytes32 memo);             // arbitrary note\r\n  event BurnReceipt (address indexed addr,              // DFN address adjusted\r\n                     uint tokenAmountBurned);           // DFN deleted by adj.\r\n\r\n  /**\r\n   * Constructor\r\n   *\r\n   * The constructor defines \r\n   *  - the privileged addresses for access control\r\n   *  - the phases in base contract Phased\r\n   *  - the mapping between phase numbers and states\r\n   *  - the targets in base contract Targets \r\n   *  - the share for early contributors in base contract TokenTracker\r\n   *  - the step function for the bonus calculation in donation round 1 \r\n   *\r\n   * All configuration parameters are taken from base contract Parameters.\r\n   */\r\n  function FDC(address _masterAuth, string _name)\r\n    TokenTracker(earlyContribShare)\r\n    StepFunction(round1EndTime-round1StartTime, round1InitialBonus, \r\n                 round1BonusSteps) \r\n  {\r\n    /*\r\n     * Set identifying string\r\n     */\r\n    name = _name;\r\n\r\n    /*\r\n     * Set privileged addresses for access control\r\n     */\r\n    foundationWallet  = _masterAuth;\r\n    masterAuth     = _masterAuth;\r\n    exchangeRateAuth  = _masterAuth;\r\n    registrarAuth  = _masterAuth;\r\n\r\n    /*\r\n     * Initialize base contract Phased\r\n     * \r\n     *           |------------------------- Phase number (0-7)\r\n     *           |    |-------------------- State name\r\n     *           |    |               |---- Transition number (0-6)\r\n     *           V    V               V\r\n     */\r\n    stateOfPhase[0] = state.earlyContrib; \r\n    addPhase(round0StartTime);     // 0\r\n    stateOfPhase[1] = state.round0;\r\n    addPhase(round0EndTime);       // 1 \r\n    stateOfPhase[2] = state.offChainReg;\r\n    addPhase(round1StartTime);     // 2\r\n    stateOfPhase[3] = state.round1;\r\n    addPhase(round1EndTime);       // 3 \r\n    stateOfPhase[4] = state.offChainReg;\r\n    addPhase(finalizeStartTime);   // 4 \r\n    stateOfPhase[5] = state.finalization;\r\n    addPhase(finalizeEndTime);     // 5 \r\n    stateOfPhase[6] = state.done;\r\n\r\n    // Let the other functions know what phase numbers the donation rounds were\r\n    // assigned to\r\n    phaseOfRound0 = 1;\r\n    phaseOfRound1 = 3;\r\n    \r\n    // Maximum delay for start of donation rounds \r\n    setMaxDelay(phaseOfRound0 - 1, maxRoundDelay);\r\n    setMaxDelay(phaseOfRound1 - 1, maxRoundDelay);\r\n\r\n    /*\r\n     * Initialize base contract Targets\r\n     */\r\n    setTarget(phaseOfRound0, round0Target);\r\n    setTarget(phaseOfRound1, round1Target);\r\n  }\r\n  \r\n  /*\r\n   * PUBLIC functions\r\n   * \r\n   * Un-authenticated:\r\n   *  - getState\r\n   *  - getMultiplierAtTime\r\n   *  - donateAsWithChecksum\r\n   *  - finalize\r\n   *  - empty\r\n   *  - getStatus\r\n   *\r\n   * Authenticated:\r\n   *  - registerEarlyContrib\r\n   *  - registerOffChainDonation\r\n   *  - setExchangeRate\r\n   *  - delayRound1\r\n   *  - setFoundationWallet\r\n   *  - setRegistrarAuth\r\n   *  - setExchangeRateAuth\r\n   *  - setAdminAuth\r\n   */\r\n\r\n  /**\r\n   * Get current state at the current block time \r\n   */\r\n  function getState() constant returns (state) {\r\n    return stateOfPhase[getPhaseAtTime(now)];\r\n  }\r\n  \r\n  /**\r\n   * Return the bonus multiplier at a given time\r\n   *\r\n   * The given time must  \r\n   *  - lie in one of the donation rounds, \r\n   *  - not lie in the future.\r\n   * Otherwise there is no valid multiplier.\r\n   */\r\n  function getMultiplierAtTime(uint time) constant returns (uint) {\r\n    // Get phase number (will throw if time lies in the future)\r\n    uint n = getPhaseAtTime(time);\r\n\r\n    // If time lies in donation round 0 we return the constant multiplier \r\n    if (stateOfPhase[n] == state.round0) {\r\n      return 100 + round0Bonus;\r\n    }\r\n\r\n    // If time lies in donation round 1 we return the step function\r\n    if (stateOfPhase[n] == state.round1) {\r\n      return 100 + getStepFunction(time - getPhaseStartTime(n));\r\n    }\r\n\r\n    // Throw outside of donation rounds\r\n    throw;\r\n  }\r\n\r\n  /**\r\n   * Send donation in the name a the given address with checksum\r\n   *\r\n   * The second argument is a checksum which must equal the first 4 bytes of the\r\n   * SHA-256 digest of the byte representation of the address.\r\n   */\r\n  function donateAsWithChecksum(address addr, bytes4 checksum) \r\n    payable \r\n    returns (bool) \r\n  {\r\n    // Calculate SHA-256 digest of the address \r\n    bytes32 hash = sha256(addr);\r\n    \r\n    // Throw is the checksum does not match the first 4 bytes\r\n    if (bytes4(hash) != checksum) { throw ; }\r\n\r\n    // Call un-checksummed donate function \r\n    return donateAs(addr);\r\n  }\r\n\r\n  /**\r\n   * Finalize the balance for the given address\r\n   *\r\n   * This function triggers the conversion (and burn) of the restricted tokens\r\n   * that are assigned to the given address.\r\n   *\r\n   * This function is only available during the finalization phase. It manages\r\n   * the calls to closeAssignments() and unrestrict() of TokenTracker.\r\n   */\r\n  function finalize(address addr) {\r\n    // Throw if we are not in the finalization phase \r\n    if (getState() != state.finalization) { throw; }\r\n\r\n    // Close down further assignments in TokenTracker\r\n    closeAssignmentsIfOpen(); \r\n\r\n    // Burn tokens\r\n    uint tokensBurned = unrestrict(addr); \r\n    \r\n    // Issue burn receipt\r\n    BurnReceipt(addr, tokensBurned);\r\n\r\n    // If no restricted tokens left\r\n    if (isUnrestricted()) { \r\n      // then end the finalization phase immediately\r\n      endCurrentPhaseIn(0); \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send any remaining balance to the foundation wallet\r\n   */\r\n  function empty() returns (bool) {\r\n    return foundationWallet.call.value(this.balance)();\r\n  }\r\n\r\n  /**\r\n   * Get status information from the FDC\r\n   *\r\n   * This function returns a mix of\r\n   *  - global status of the FDC\r\n   *  - global status of the FDC specific for one of the two donation rounds\r\n   *  - status related to a specific token address (DFINITY address)\r\n   *  - status (balance) of an external Ethereum account \r\n   *\r\n   * Arguments are:\r\n   *  - donationRound: donation round to query (0 or 1)\r\n   *  - dfnAddr: token address to query\r\n   *  - fwdAddr: external Ethereum address to query\r\n   */\r\n  function getStatus(uint donationRound, address dfnAddr, address fwdAddr)\r\n    public constant\r\n    returns (\r\n      state currentState,     // current state (an enum)\r\n      uint fxRate,            // exchange rate of CHF -> ETH (Wei/CHF)\r\n      uint currentMultiplier, // current bonus multiplier (0 if invalid)\r\n      uint donationCount,     // total individual donations made (a count)\r\n      uint totalTokenAmount,  // total DFN planned allocated to donors\r\n      uint startTime,         // expected start time of specified donation round\r\n      uint endTime,           // expected end time of specified donation round\r\n      bool isTargetReached,   // whether round target has been reached\r\n      uint chfCentsDonated,   // total value donated in specified round as CHF\r\n      uint tokenAmount,       // total DFN planned allocted to donor (user)\r\n      uint fwdBalance,        // total ETH (in Wei) waiting in fowarding address\r\n      uint donated)           // total ETH (in Wei) donated by DFN address \r\n  {\r\n    // The global status\r\n    currentState = getState();\r\n    if (currentState == state.round0 || currentState == state.round1) {\r\n      currentMultiplier = getMultiplierAtTime(now);\r\n    } \r\n    fxRate = weiPerCHF;\r\n    donationCount = totalUnrestrictedAssignments;\r\n    totalTokenAmount = totalUnrestrictedTokens;\r\n   \r\n    // The round specific status\r\n    if (donationRound == 0) {\r\n      startTime = getPhaseStartTime(phaseOfRound0);\r\n      endTime = getPhaseStartTime(phaseOfRound0 + 1);\r\n      isTargetReached = targetReached(phaseOfRound0);\r\n      chfCentsDonated = counter[phaseOfRound0];\r\n    } else {\r\n      startTime = getPhaseStartTime(phaseOfRound1);\r\n      endTime = getPhaseStartTime(phaseOfRound1 + 1);\r\n      isTargetReached = targetReached(phaseOfRound1);\r\n      chfCentsDonated = counter[phaseOfRound1];\r\n    }\r\n    \r\n    // The status specific to the DFN address\r\n    tokenAmount = tokens[dfnAddr];\r\n    donated = weiDonated[dfnAddr];\r\n    \r\n    // The status specific to the Ethereum address\r\n    fwdBalance = fwdAddr.balance;\r\n  }\r\n  \r\n  /**\r\n   * Set the exchange rate between ether and Swiss francs in Wei per CHF\r\n   *\r\n   * Must be called from exchangeRateAuth.\r\n   */\r\n  function setWeiPerCHF(uint weis) {\r\n    // Require permission\r\n    if (msg.sender != exchangeRateAuth) { throw; }\r\n\r\n    // Set the global state variable for exchange rate \r\n    weiPerCHF = weis;\r\n  }\r\n\r\n  /**\r\n   * Register early contribution in the name of the given address\r\n   *\r\n   * Must be called from registrarAuth.\r\n   *\r\n   * Arguments are:\r\n   *  - addr: address to the tokens are assigned\r\n   *  - tokenAmount: number of restricted tokens to assign\r\n   *  - memo: optional dynamic bytes of data to appear in the receipt\r\n   */\r\n  function registerEarlyContrib(address addr, uint tokenAmount, bytes32 memo) {\r\n    // Require permission\r\n    if (msg.sender != registrarAuth) { throw; }\r\n\r\n    // Reject registrations outside the early contribution phase\r\n    if (getState() != state.earlyContrib) { throw; }\r\n\r\n    // Add address to list if new\r\n    if (!isRegistered(addr, true)) {\r\n      earlyContribList.push(addr);\r\n    }\r\n    \r\n    // Assign restricted tokens in TokenTracker\r\n    assign(addr, tokenAmount, true);\r\n    \r\n    // Issue early contribution receipt\r\n    EarlyContribReceipt(addr, tokenAmount, memo);\r\n  }\r\n\r\n  /**\r\n   * Register off-chain donation in the name of the given address\r\n   *\r\n   * Must be called from registrarAuth.\r\n   *\r\n   * Arguments are:\r\n   *  - addr: address to the tokens are assigned\r\n   *  - timestamp: time when the donation came in (determines round and bonus)\r\n   *  - chfCents: value of the donation in cents of Swiss francs\r\n   *  - currency: the original currency of the donation (three letter string)\r\n   *  - memo: optional bytes of data to appear in the receipt\r\n   *\r\n   * The timestamp must not be in the future. This is because the timestamp \r\n   * defines the donation round and the multiplier and future phase times are\r\n   * still subject to change.\r\n   *\r\n   * If called during a donation round then the timestamp must lie in the same \r\n   * phase and if called during the extended period for off-chain donations then\r\n   * the timestamp must lie in the immediately preceding donation round. \r\n   */\r\n  function registerOffChainDonation(address addr, uint timestamp, uint chfCents, \r\n                                    string currency, bytes32 memo)\r\n  {\r\n    // Require permission\r\n    if (msg.sender != registrarAuth) { throw; }\r\n\r\n    // The current phase number and state corresponding state\r\n    uint currentPhase = getPhaseAtTime(now);\r\n    state currentState = stateOfPhase[currentPhase];\r\n    \r\n    // Reject registrations outside the two donation rounds (incl. their\r\n    // extended registration periods for off-chain donations)\r\n    if (currentState != state.round0 && currentState != state.round1 &&\r\n        currentState != state.offChainReg) {\r\n      throw;\r\n    }\r\n   \r\n    // Throw if timestamp is in the future\r\n    if (timestamp > now) { throw; }\r\n   \r\n    // Phase number and corresponding state of the timestamp  \r\n    uint timestampPhase = getPhaseAtTime(timestamp);\r\n    state timestampState = stateOfPhase[timestampPhase];\r\n   \r\n    // Throw if called during a donation round and the timestamp does not match\r\n    // that phase.\r\n    if ((currentState == state.round0 || currentState == state.round1) &&\r\n        (timestampState != currentState)) { \r\n      throw;\r\n    }\r\n    \r\n    // Throw if called during the extended period for off-chain donations and\r\n    // the timestamp does not lie in the immediately preceding donation phase.\r\n    if (currentState == state.offChainReg && timestampPhase != currentPhase-1) {\r\n      throw;\r\n    }\r\n\r\n    // Throw if the memo is duplicated\r\n    if (memoUsed[memo]) {\r\n      throw;\r\n    }\r\n\r\n    // Set the memo item to true\r\n    memoUsed[memo] = true;\r\n\r\n    // Do the book-keeping\r\n    bookDonation(addr, timestamp, chfCents, currency, memo);\r\n  }\r\n\r\n  /**\r\n   * Delay a donation round\r\n   *\r\n   * Must be called from the address registrarAuth.\r\n   *\r\n   * This function delays the start of donation round 1 by the given time delta\r\n   * unless the time delta is bigger than the configured maximum delay.\r\n   */\r\n  function delayDonPhase(uint donPhase, uint timedelta) {\r\n    // Require permission\r\n    if (msg.sender != registrarAuth) { throw; }\r\n\r\n    // Pass the call on to base contract Phased\r\n    // Delaying the start of a donation round is the same as delaying the end \r\n    // of the preceding phase\r\n    if (donPhase == 0) {\r\n      delayPhaseEndBy(phaseOfRound0 - 1, timedelta);\r\n    } else if (donPhase == 1) {\r\n      delayPhaseEndBy(phaseOfRound1 - 1, timedelta);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the forwarding address for donated ether\r\n   * \r\n   * Must be called from the address masterAuth before donation round 0 starts.\r\n   */\r\n  function setFoundationWallet(address newAddr) {\r\n    // Require permission\r\n    if (msg.sender != masterAuth) { throw; }\r\n    \r\n    // Require phase before round 0\r\n    if (getPhaseAtTime(now) >= phaseOfRound0) { throw; }\r\n \r\n    foundationWallet = newAddr;\r\n  }\r\n\r\n  /**\r\n   * Set new authenticated address for setting exchange rate\r\n   * \r\n   * Must be called from the address masterAuth.\r\n   */\r\n  function setExchangeRateAuth(address newAuth) {\r\n    // Require permission\r\n    if (msg.sender != masterAuth) { throw; }\r\n \r\n    exchangeRateAuth = newAuth;\r\n  }\r\n\r\n  /**\r\n   * Set new authenticated address for registrations\r\n   * \r\n   * Must be called from the address masterAuth.\r\n   */\r\n  function setRegistrarAuth(address newAuth) {\r\n    // Require permission\r\n    if (msg.sender != masterAuth) { throw; }\r\n \r\n    registrarAuth = newAuth;\r\n  }\r\n\r\n  /**\r\n   * Set new authenticated address for admin\r\n   * \r\n   * Must be called from the address masterAuth.\r\n   */\r\n  function setMasterAuth(address newAuth) {\r\n    // Require permission\r\n    if (msg.sender != masterAuth) { throw; }\r\n \r\n    masterAuth = newAuth;\r\n  }\r\n\r\n  /*\r\n   * PRIVATE functions\r\n   *\r\n   *  - donateAs\r\n   *  - bookDonation\r\n   */\r\n  \r\n  /**\r\n   * Process on-chain donation in the name of the given address \r\n   *\r\n   * This function is private because it shall only be called through its \r\n   * wrapper donateAsWithChecksum.\r\n   */\r\n  function donateAs(address addr) private returns (bool) {\r\n    // The current state\r\n    state st = getState();\r\n    \r\n    // Throw if current state is not a donation round\r\n    if (st != state.round0 && st != state.round1) { throw; }\r\n\r\n    // Throw if donation amount is below minimum\r\n    if (msg.value < minDonation) { throw; }\r\n\r\n    // Throw if the exchange rate is not yet defined\r\n    if (weiPerCHF == 0) { throw; } \r\n\r\n    // Update counters for ether donations\r\n    totalWeiDonated += msg.value;\r\n    weiDonated[addr] += msg.value;\r\n\r\n    // Convert ether to Swiss francs\r\n    uint chfCents = (msg.value * 100) / weiPerCHF;\r\n    \r\n    // Do the book-keeping\r\n    bookDonation(addr, now, chfCents, \"ETH\", \"\");\r\n\r\n    // Forward balance to the foundation wallet\r\n    return foundationWallet.call.value(this.balance)();\r\n  }\r\n\r\n  /**\r\n   * Put an accepted donation in the books.\r\n   *\r\n   * This function\r\n   *  - cannot throw as all checks have been done before, \r\n   *  - is agnostic to the source of the donation (on-chain or off-chain)\r\n   *  - is agnostic to the currency \r\n   *    (the currency argument is simply passed through to the DonationReceipt)\r\n   *\r\n   */\r\n  function bookDonation(address addr, uint timestamp, uint chfCents, \r\n                        string currency, bytes32 memo) private\r\n  {\r\n    // The current phase\r\n    uint phase = getPhaseAtTime(timestamp);\r\n    \r\n    // Add amount to the counter of the current phase\r\n    bool targetReached = addTowardsTarget(phase, chfCents);\r\n    \r\n    // If the target was crossed then start the grace period\r\n    if (targetReached && phase == getPhaseAtTime(now)) {\r\n      if (phase == phaseOfRound0) {\r\n        endCurrentPhaseIn(gracePeriodAfterRound0Target);\r\n      } else if (phase == phaseOfRound1) {\r\n        endCurrentPhaseIn(gracePeriodAfterRound1Target);\r\n      }\r\n    }\r\n\r\n    // Bonus multiplier that was valid at the given time \r\n    uint bonusMultiplier = getMultiplierAtTime(timestamp);\r\n    \r\n    // Apply bonus to amount in Swiss francs\r\n    chfCents = (chfCents * bonusMultiplier) / 100;\r\n\r\n    // Convert Swiss francs to amount of tokens\r\n    uint tokenAmount = (chfCents * tokensPerCHF) / 100;\r\n\r\n    // Add address to list if new\r\n    if (!isRegistered(addr, false)) {\r\n      donorList.push(addr);\r\n    }\r\n    \r\n    // Assign unrestricted tokens in TokenTracker\r\n    assign(addr,tokenAmount,false);\r\n\r\n    // Issue donation receipt\r\n    DonationReceipt(addr, currency, bonusMultiplier, timestamp, tokenAmount, \r\n                    memo);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"setFoundationWallet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUnrestrictedAssignments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round0StartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round0Target\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDonation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiDonated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multFracCeiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRestrictedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1BonusSteps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAuth\",\"type\":\"address\"}],\"name\":\"setExchangeRateAuth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1StartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1EndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRoundDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getPhaseStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getMultiplierAtTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"targetReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assignmentsClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donorList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phaseLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"chfCents\",\"type\":\"uint256\"},{\"name\":\"currency\",\"type\":\"string\"},{\"name\":\"memo\",\"type\":\"bytes32\"}],\"name\":\"registerOffChainDonation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gracePeriodAfterRound1Target\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRestrictedAssignments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnMultNom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gracePeriodAfterRound0Target\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"donationRound\",\"type\":\"uint256\"},{\"name\":\"dfnAddr\",\"type\":\"address\"},{\"name\":\"fwdAddr\",\"type\":\"address\"}],\"name\":\"getStatus\",\"outputs\":[{\"name\":\"currentState\",\"type\":\"uint8\"},{\"name\":\"fxRate\",\"type\":\"uint256\"},{\"name\":\"currentMultiplier\",\"type\":\"uint256\"},{\"name\":\"donationCount\",\"type\":\"uint256\"},{\"name\":\"totalTokenAmount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"isTargetReached\",\"type\":\"bool\"},{\"name\":\"chfCentsDonated\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"fwdBalance\",\"type\":\"uint256\"},{\"name\":\"donated\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnMultDen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"donPhase\",\"type\":\"uint256\"},{\"name\":\"timedelta\",\"type\":\"uint256\"}],\"name\":\"delayDonPhase\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1Target\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"earlyContribList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round0EndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isUnrestricted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"restrictions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyContribShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAuth\",\"type\":\"address\"}],\"name\":\"setRegistrarAuth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUnrestrictedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiPerCHF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"elapsedTime\",\"type\":\"uint256\"}],\"name\":\"getStepFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateAuth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterAuth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"isPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrarAuth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictedShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerCHF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1InitialBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weis\",\"type\":\"uint256\"}],\"name\":\"setWeiPerCHF\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"N\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"checksum\",\"type\":\"bytes4\"}],\"name\":\"donateAsWithChecksum\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"restricted\",\"type\":\"bool\"}],\"name\":\"isRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAuth\",\"type\":\"address\"}],\"name\":\"setMasterAuth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"step\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getPhaseAtTime\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round0Bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"empty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nSteps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"memo\",\"type\":\"bytes32\"}],\"name\":\"registerEarlyContrib\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiDonated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"millionInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_masterAuth\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"currency\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"bonusMultiplierApplied\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"memo\",\"type\":\"bytes32\"}],\"name\":\"DonationReceipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"memo\",\"type\":\"bytes32\"}],\"name\":\"EarlyContribReceipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmountBurned\",\"type\":\"uint256\"}],\"name\":\"BurnReceipt\",\"type\":\"event\"}]","ContractName":"FDC","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b2cb826c945d8df01802b5cf3c4105685d4933a0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000145354494654554e47204466696e69747920464443000000000000000000000000","Library":"","SwarmSource":""}]}