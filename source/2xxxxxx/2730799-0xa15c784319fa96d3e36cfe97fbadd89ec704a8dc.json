{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nfile:   Base.sol\r\nver:    0.2.1\r\nupdated:18-Nov-2016\r\nauthor: Darryl Morris (o0ragman0o)\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nAn basic contract furnishing inheriting contracts with ownership, reentry\r\nprotection and safe sending functions.\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n<http://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity ^0.4.0;\r\n\r\ncontract Base\r\n{\r\n/* Constants */\r\n\r\n    string constant VERSION = \"Base 0.1.1 \\n\";\r\n\r\n/* State Variables */\r\n\r\n    bool mutex;\r\n    address public owner;\r\n\r\n/* Events */\r\n\r\n    event Log(string message);\r\n    event ChangedOwner(address indexed oldOwner, address indexed newOwner);\r\n\r\n/* Modifiers */\r\n\r\n    // To throw call not made by owner\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    // This modifier can be used on functions with external calls to\r\n    // prevent reentry attacks.\r\n    // Constraints:\r\n    //   Protected functions must have only one point of exit.\r\n    //   Protected functions cannot use the `return` keyword\r\n    //   Protected functions return values must be through return parameters.\r\n    modifier preventReentry() {\r\n        if (mutex) throw;\r\n        else mutex = true;\r\n        _;\r\n        delete mutex;\r\n        return;\r\n    }\r\n\r\n    // This modifier can be applied to pulic access state mutation functions\r\n    // to protect against reentry if a `mutextProtect` function is already\r\n    // on the call stack.\r\n    modifier noReentry() {\r\n        if (mutex) throw;\r\n        _;\r\n    }\r\n\r\n    // Same as noReentry() but intended to be overloaded\r\n    modifier canEnter() {\r\n        if (mutex) throw;\r\n        _;\r\n    }\r\n    \r\n/* Functions */\r\n\r\n    function Base() { owner = msg.sender; }\r\n\r\n    function version() public constant returns (string) {\r\n        return VERSION;\r\n    }\r\n\r\n    function contractBalance() public constant returns(uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    // Change the owner of a contract\r\n    function changeOwner(address _newOwner)\r\n        public onlyOwner returns (bool)\r\n    {\r\n        owner = _newOwner;\r\n        ChangedOwner(msg.sender, owner);\r\n        return true;\r\n    }\r\n    \r\n    function safeSend(address _recipient, uint _ether)\r\n        internal\r\n        preventReentry()\r\n        returns (bool success_)\r\n    {\r\n        if(!_recipient.call.value(_ether)()) throw;\r\n        success_ = true;\r\n    }\r\n}\r\n\r\n/* End of Base */\r\n\r\n/*\r\nfile:   Math.sol\r\nver:    0.2.0\r\nupdated:18-Nov-2016\r\nauthor: Darryl Morris\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nAn inheritable contract containing math functions and comparitors.\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n<http://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity ^0.4.0;\r\n\r\ncontract Math\r\n{\r\n\r\n/* Constants */\r\n\r\n    string constant VERSION = \"Math 0.0.1 \\n\";\r\n    uint constant NULL = 0;\r\n    bool constant LT = false;\r\n    bool constant GT = true;\r\n    // No type bool <-> int type converstion in solidity :~(\r\n    uint constant iTRUE = 1;\r\n    uint constant iFALSE = 0;\r\n    uint constant iPOS = 1;\r\n    uint constant iZERO = 0;\r\n    uint constant iNEG = uint(-1);\r\n\r\n\r\n/* Modifiers */\r\n\r\n/* Functions */\r\n    function version() public constant returns (string)\r\n    {\r\n        return VERSION;\r\n    }\r\n\r\n    function assert(bool assertion) internal constant\r\n    {\r\n      if (!assertion) throw;\r\n    }\r\n    \r\n    // @dev Parametric comparitor for > or <\r\n    // !_sym returns a < b\r\n    // _sym  returns a > b\r\n    function cmp (uint a, uint b, bool _sym) internal constant returns (bool)\r\n    {\r\n        return (a!=b) && ((a < b) != _sym);\r\n    }\r\n\r\n    /// @dev Parametric comparitor for >= or <=\r\n    /// !_sym returns a <= b\r\n    /// _sym  returns a >= b\r\n    function cmpEq (uint a, uint b, bool _sym) internal constant returns (bool)\r\n    {\r\n        return (a==b) || ((a < b) != _sym);\r\n    }\r\n    \r\n    /// Trichotomous comparitor\r\n    /// a < b returns -1\r\n    /// a == b returns 0\r\n    /// a > b returns 1\r\n/*    function triCmp(uint a, uint b) internal constant returns (bool)\r\n    {\r\n        uint c = a - b;\r\n        return c & c & (0 - 1);\r\n    }\r\n    \r\n    function nSign(uint a) internal returns (uint)\r\n    {\r\n        return a & 2^255;\r\n    }\r\n    \r\n    function neg(uint a) internal returns (uint) {\r\n        return 0 - a;\r\n    }\r\n*/    \r\n    function safeMul(uint a, uint b) internal constant returns (uint)\r\n    {\r\n      uint c = a * b;\r\n      assert(a == 0 || c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal constant returns (uint)\r\n    {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal constant returns (uint)\r\n    {\r\n      uint c = a + b;\r\n      assert(c>=a && c>=b);\r\n      return c;\r\n    }\r\n}\r\n\r\n/* End of Math */\r\n\r\n\r\n/*\r\nfile:   ERC20.sol\r\nver:    0.2.3\r\nupdated:18-Nov-2016\r\nauthor: Darryl Morris\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nAn ERC20 compliant token.\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n<http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n//pragma solidity ^0.4.0;\r\n\r\n//import \"Math.sol\";\r\n//import \"Base.sol\";\r\n\r\n// ERC20 Standard Token Interface with safe maths and reentry protection\r\ncontract ERC20Interface\r\n{\r\n/* Structs */\r\n\r\n/* Constants */\r\n    string constant VERSION = \"ERC20 0.2.3-o0ragman0o\\nMath 0.0.1\\nBase 0.1.1\\n\";\r\n\r\n/* State Valiables */\r\n    uint public totalSupply;\r\n    uint8 public decimalPlaces;\r\n    string public name;\r\n    string public symbol;\r\n    \r\n    // Token ownership mapping\r\n    // mapping (address => uint) public balanceOf;\r\n    mapping (address => uint) balance;\r\n    \r\n    // Transfer allowances mapping\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n/* Events */\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value);\r\n\r\n/* Modifiers */\r\n\r\n/* Function Abstracts */\r\n\r\n    /* State variable Accessor Functions (for reference - leave commented) */\r\n\r\n    // Returns the allowable transfer of tokens by a proxy\r\n    // function allowance (address tokenHolders, address proxy, uint allowance) public constant returns (uint);\r\n\r\n    // Get the total token supply\r\n    // function totalSupply() public constant returns (uint);\r\n\r\n    // Returns token symbol\r\n    // function symbol() public constant returns(string);\r\n\r\n    // Returns token symbol\r\n    // function name() public constant returns(string);\r\n\r\n    // Returns decimal places designated for unit of token.\r\n    // function decimalPlaces() public returns(uint);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    // function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the\r\n    // _value amount.\r\n    // function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract ERC20Token is Base, Math, ERC20Interface\r\n{\r\n\r\n/* Events */\r\n\r\n/* Structs */\r\n\r\n/* Constants */\r\n\r\n/* State Valiables */\r\n\r\n/* Modifiers */\r\n\r\n    modifier isAvailable(uint _amount) {\r\n        if (_amount > balance[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isAllowed(address _from, uint _amount) {\r\n        if (_amount > allowance[_from][msg.sender] ||\r\n           _amount > balance[_from]) throw;\r\n        _;        \r\n    }\r\n\r\n/* Funtions Public */\r\n\r\n    function ERC20Token(\r\n        uint _supply,\r\n        uint8 _decimalPlaces,\r\n        string _symbol,\r\n        string _name)\r\n    {\r\n        totalSupply = _supply;\r\n        decimalPlaces = _decimalPlaces;\r\n        symbol = _symbol;\r\n        name = _name;\r\n        balance[msg.sender] = totalSupply;\r\n    }\r\n    \r\n    function version() public constant returns(string) {\r\n        return VERSION;\r\n    }\r\n    \r\n    function balanceOf(address _addr)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return balance[_addr];\r\n    }\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        canEnter\r\n        isAvailable(_value)\r\n        returns (bool)\r\n    {\r\n        balance[msg.sender] = safeSub(balance[msg.sender], _value);\r\n        balance[_to] = safeAdd(balance[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        external\r\n        canEnter\r\n        isAllowed(_from, _value)\r\n        returns (bool)\r\n    {\r\n        balance[_from] = safeSub(balance[_from], _value);\r\n        balance[_to] = safeAdd(balance[_to], _value);\r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the\r\n    // _value amount. If this function is called again it overwrites the current\r\n    // allowance with _value.\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        canEnter\r\n        returns (bool success)\r\n    {\r\n        if (balance[msg.sender] == 0) throw;\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/* End of ERC20 */\r\n\r\n\r\n/*\r\nfile:   LibCLL.sol\r\nver:    0.3.1\r\nupdated:21-Sep-2016\r\nauthor: Darryl Morris\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nA Solidity library for implementing a data indexing regime using\r\na circular linked list.\r\n\r\nThis library provisions lookup, navigation and key/index storage\r\nfunctionality which can be used in conjunction with an array or mapping.\r\n\r\nNOTICE: This library uses internal functions only and so cannot be compiled\r\nand deployed independently from its calling contract.\r\n\r\nThis library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n<http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n//pragma solidity ^0.4.0;\r\n\r\n// LibCLL using `uint` keys\r\nlibrary LibCLLu {\r\n\r\n    string constant VERSION = \"LibCLLu 0.3.1\";\r\n    uint constant NULL = 0;\r\n    uint constant HEAD = NULL;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n    \r\n    struct CLL{\r\n        mapping (uint => mapping (bool => uint)) cll;\r\n    }\r\n\r\n    // n: node id  d: direction  r: return node id\r\n\r\n    function version() internal constant returns (string) {\r\n        return VERSION;\r\n    }\r\n\r\n    // Return existential state of a list.\r\n    function exists(CLL storage self)\r\n        internal\r\n        constant returns (bool)\r\n    {\r\n        if (self.cll[HEAD][PREV] != HEAD || self.cll[HEAD][NEXT] != HEAD)\r\n            return true;\r\n    }\r\n    \r\n    // Returns the number of elements in the list\r\n    function sizeOf(CLL storage self) internal constant returns (uint r) {\r\n        uint i = step(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            i = step(self, i, NEXT);\r\n            r++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Returns the links of a node as and array\r\n    function getNode(CLL storage self, uint n)\r\n        internal  constant returns (uint[2])\r\n    {\r\n        return [self.cll[n][PREV], self.cll[n][NEXT]];\r\n    }\r\n\r\n    // Returns the link of a node `n` in direction `d`.\r\n    function step(CLL storage self, uint n, bool d)\r\n        internal  constant returns (uint)\r\n    {\r\n        return self.cll[n][d];\r\n    }\r\n\r\n    // Can be used before `insert` to build an ordered list\r\n    // `a` an existing node to search from, e.g. HEAD.\r\n    // `b` value to seek\r\n    // `r` first node beyond `b` in direction `d`\r\n    function seek(CLL storage self, uint a, uint b, bool d)\r\n        internal  constant returns (uint r)\r\n    {\r\n        r = step(self, a, d);\r\n        while  ((b!=r) && ((b < r) != d)) r = self.cll[r][d];\r\n        return;\r\n    }\r\n\r\n    // Creates a bidirectional link between two nodes on direction `d`\r\n    function stitch(CLL storage self, uint a, uint b, bool d) internal  {\r\n        self.cll[b][!d] = a;\r\n        self.cll[a][d] = b;\r\n    }\r\n\r\n    // Insert node `b` beside and existing node `a` in direction `d`.\r\n    function insert (CLL storage self, uint a, uint b, bool d) internal  {\r\n        uint c = self.cll[a][d];\r\n        stitch (self, a, b, d);\r\n        stitch (self, b, c, d);\r\n    }\r\n    \r\n    function remove(CLL storage self, uint n) internal returns (uint) {\r\n        if (n == NULL) return;\r\n        stitch(self, self.cll[n][PREV], self.cll[n][NEXT], NEXT);\r\n        delete self.cll[n][PREV];\r\n        delete self.cll[n][NEXT];\r\n        return n;\r\n    }\r\n\r\n    function push(CLL storage self, uint n, bool d) internal  {\r\n        insert(self, HEAD, n, d);\r\n    }\r\n    \r\n    function pop(CLL storage self, bool d) internal returns (uint) {\r\n        return remove(self, step(self, HEAD, d));\r\n    }\r\n}\r\n\r\n// LibCLL using `int` keys\r\nlibrary LibCLLi {\r\n\r\n    string constant VERSION = \"LibCLLi 0.3.1\";\r\n    int constant NULL = 0;\r\n    int constant HEAD = NULL;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n    \r\n    struct CLL{\r\n        mapping (int => mapping (bool => int)) cll;\r\n    }\r\n\r\n    // n: node id  d: direction  r: return node id\r\n\r\n    function version() internal constant returns (string) {\r\n        return VERSION;\r\n    }\r\n\r\n    // Return existential state of a node. n == HEAD returns list existence.\r\n    function exists(CLL storage self, int n) internal constant returns (bool) {\r\n        if (self.cll[HEAD][PREV] != HEAD || self.cll[HEAD][NEXT] != HEAD)\r\n            return true;\r\n    }\r\n    // Returns the number of elements in the list\r\n    function sizeOf(CLL storage self) internal constant returns (uint r) {\r\n        int i = step(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            i = step(self, i, NEXT);\r\n            r++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Returns the links of a node as and array\r\n    function getNode(CLL storage self, int n)\r\n        internal  constant returns (int[2])\r\n    {\r\n        return [self.cll[n][PREV], self.cll[n][NEXT]];\r\n    }\r\n\r\n    // Returns the link of a node `n` in direction `d`.\r\n    function step(CLL storage self, int n, bool d)\r\n        internal  constant returns (int)\r\n    {\r\n        return self.cll[n][d];\r\n    }\r\n\r\n    // Can be used before `insert` to build an ordered list\r\n    // `a` an existing node to search from, e.g. HEAD.\r\n    // `b` value to seek\r\n    // `r` first node beyond `b` in direction `d`\r\n    function seek(CLL storage self, int a, int b, bool d)\r\n        internal  constant returns (int r)\r\n    {\r\n        r = step(self, a, d);\r\n        while  ((b!=r) && ((b < r) != d)) r = self.cll[r][d];\r\n        return;\r\n    }\r\n\r\n    // Creates a bidirectional link between two nodes on direction `d`\r\n    function stitch(CLL storage self, int a, int b, bool d) internal  {\r\n        self.cll[b][!d] = a;\r\n        self.cll[a][d] = b;\r\n    }\r\n\r\n    // Insert node `b` beside existing node `a` in direction `d`.\r\n    function insert (CLL storage self, int a, int b, bool d) internal  {\r\n        int c = self.cll[a][d];\r\n        stitch (self, a, b, d);\r\n        stitch (self, b, c, d);\r\n    }\r\n    \r\n    function remove(CLL storage self, int n) internal returns (int) {\r\n        if (n == NULL) return;\r\n        stitch(self, self.cll[n][PREV], self.cll[n][NEXT], NEXT);\r\n        delete self.cll[n][PREV];\r\n        delete self.cll[n][NEXT];\r\n        return n;\r\n    }\r\n\r\n    function push(CLL storage self, int n, bool d) internal  {\r\n        insert(self, HEAD, n, d);\r\n    }\r\n    \r\n    function pop(CLL storage self, bool d) internal returns (int) {\r\n        return remove(self, step(self, HEAD, d));\r\n    }\r\n}\r\n\r\n\r\n/* End of LibCLLi */\r\n\r\n/*\r\nfile:   ITT.sol\r\nver:    0.3.6\r\nupdated:18-Nov-2016\r\nauthor: Darryl Morris (o0ragman0o)\r\nemail:  o0ragman0o AT gmail.com\r\n\r\nAn ERC20 compliant token with currency\r\nexchange functionality here called an 'Intrinsically Tradable\r\nToken' (ITT).\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n<http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n//pragma solidity ^0.4.0;\r\n\r\n//import \"Base.sol\";\r\n//import \"Math.sol\";\r\n//import \"ERC20.sol\";\r\n//import \"LibCLL.sol\";\r\n\r\ncontract ITTInterface\r\n{\r\n\r\n    using LibCLLu for LibCLLu.CLL;\r\n\r\n/* Constants */\r\n\r\n    string constant VERSION = \"ITT 0.3.6\\nERC20 0.2.3-o0ragman0o\\nMath 0.0.1\\nBase 0.1.1\\n\";\r\n    uint constant HEAD = 0;\r\n    uint constant MINNUM = uint(1);\r\n    // use only 128 bits of uint to prevent mul overflows.\r\n    uint constant MAXNUM = 2**128;\r\n    uint constant MINPRICE = uint(1);\r\n    uint constant NEG = uint(-1); //2**256 - 1\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n    bool constant BID = false;\r\n    bool constant ASK = true;\r\n\r\n    // minimum gas required to prevent out of gas on 'take' loop\r\n    uint constant MINGAS = 100000;\r\n\r\n    // For staging and commiting trade details.  This saves unneccessary state\r\n    // change gas usage during multi order takes but does increase logic\r\n    // complexity when encountering 'trade with self' orders\r\n    struct TradeMessage {\r\n        bool make;\r\n        bool side;\r\n        uint price;\r\n        uint tradeAmount;\r\n        uint balance;\r\n        uint etherBalance;\r\n    }\r\n\r\n/* State Valiables */\r\n\r\n    // To allow for trade halting by owner.\r\n    bool public trading;\r\n\r\n    // Mapping for ether ownership of accumulated deposits, sales and refunds.\r\n    mapping (address => uint) etherBalance;\r\n\r\n    // Orders are stored in circular linked list FIFO's which are mappings with\r\n    // price as key and value as trader address.  A trader can have only one\r\n    // order open at each price. Reordering at that price will cancel the first\r\n    // order and push the new one onto the back of the queue.\r\n    mapping (uint => LibCLLu.CLL) orderFIFOs;\r\n    \r\n    // Order amounts are stored in a seperate lookup. The keys of this mapping\r\n    // are `sha3` hashes of the price and trader address.\r\n    // This mapping prevents more than one order at a particular price.\r\n    mapping (bytes32 => uint) amounts;\r\n\r\n    // The pricebook is a linked list holding keys to lookup the price FIFO's\r\n    LibCLLu.CLL priceBook = orderFIFOs[0];\r\n\r\n\r\n/* Events */\r\n\r\n    // Triggered on a make sell order\r\n    event Ask (uint indexed price, uint amount, address indexed trader);\r\n\r\n    // Triggered on a make buy order\r\n    event Bid (uint indexed price, uint amount, address indexed trader);\r\n\r\n    // Triggered on a filled order\r\n    event Sale (uint indexed price, uint amount, address indexed buyer, address indexed seller);\r\n\r\n    // Triggered when trading is started or halted\r\n    event Trading(bool trading);\r\n\r\n/* Functions Public constant */\r\n\r\n    /// @notice Returns best bid or ask price. \r\n    function spread(bool _side) public constant returns(uint);\r\n    \r\n    /// @notice Returns the order amount for trader `_trader` at '_price'\r\n    /// @param _trader Address of trader\r\n    /// @param _price Price of order\r\n    function getAmount(uint _price, address _trader) \r\n        public constant returns(uint);\r\n\r\n    /// @notice Returns the collective order volume at a `_price`.\r\n    /// @param _price FIFO for price.\r\n    function getPriceVolume(uint _price) public constant returns (uint);\r\n\r\n    /// @notice Returns an array of all prices and their volumes.\r\n    /// @dev [even] indecies are the price. [odd] are the volume. [0] is the\r\n    /// index of the spread.\r\n    function getBook() public constant returns (uint[]);\r\n\r\n/* Functions Public non-constant*/\r\n\r\n    /// @notice Will buy `_amount` tokens at or below `_price` each.\r\n    /// @param _bidPrice Highest price to bid.\r\n    /// @param _amount The requested amount of tokens to buy.\r\n    /// @param _make Value of true will make order if not filled.\r\n    function buy (uint _bidPrice, uint _amount, bool _make)\r\n        payable returns (bool);\r\n\r\n    /// @notice Will sell `_amount` tokens at or above `_price` each.\r\n    /// @param _askPrice Lowest price to ask.\r\n    /// @param _amount The requested amount of tokens to buy.\r\n    /// @param _make A value of true will make an order if not market filled.\r\n    function sell (uint _askPrice, uint _amount, bool _make)\r\n        external returns (bool);\r\n\r\n    /// @notice Will withdraw `_ether` to your account.\r\n    /// @param _ether The amount to withdraw\r\n    function withdraw(uint _ether)\r\n        external returns (bool success_);\r\n\r\n    /// @notice Cancel order at `_price`\r\n    /// @param _price The price at which the order was placed.\r\n    function cancel(uint _price) \r\n        external returns (bool);\r\n\r\n    /// @notice Will set trading state to `_trading`\r\n    /// @param _trading State to set trading to.\r\n    function setTrading(bool _trading) \r\n        external returns (bool);\r\n}\r\n\r\n\r\n/* Intrinsically Tradable Token code */ \r\n\r\ncontract ITT is ERC20Token, ITTInterface\r\n{\r\n\r\n/* Structs */\r\n\r\n/* Modifiers */\r\n\r\n    /// @dev Passes if token is currently trading\r\n    modifier isTrading() {\r\n        if (!trading) throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Validate buy parameters\r\n    modifier isValidBuy(uint _bidPrice, uint _amount) {\r\n        if ((etherBalance[msg.sender] + msg.value) < (_amount * _bidPrice) ||\r\n            _amount == 0 || _amount > totalSupply ||\r\n            _bidPrice <= MINPRICE || _bidPrice >= MAXNUM) throw; // has insufficient ether.\r\n        _;\r\n    }\r\n\r\n    /// @dev Validates sell parameters. Price must be larger than 1.\r\n    modifier isValidSell(uint _askPrice, uint _amount) {\r\n        if (_amount > balance[msg.sender] || _amount == 0 ||\r\n            _askPrice < MINPRICE || _askPrice > MAXNUM) throw;\r\n        _;\r\n    }\r\n    \r\n    /// @dev Validates ether balance\r\n    modifier hasEther(address _member, uint _ether) {\r\n        if (etherBalance[_member] < _ether) throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Validates token balance\r\n    modifier hasBalance(address _member, uint _amount) {\r\n        if (balance[_member] < _amount) throw;\r\n        _;\r\n    }\r\n\r\n/* Functions */\r\n\r\n    function ITT(\r\n        uint _totalSupply,\r\n        uint8 _decimalPlaces,\r\n        string _symbol,\r\n        string _name\r\n        )\r\n            ERC20Token(\r\n                _totalSupply,\r\n                _decimalPlaces,\r\n                _symbol,\r\n                _name\r\n                )\r\n    {\r\n        // setup pricebook and maximum spread.\r\n        priceBook.cll[HEAD][PREV] = MINPRICE;\r\n        priceBook.cll[MINPRICE][PREV] = MAXNUM;\r\n        priceBook.cll[HEAD][NEXT] = MAXNUM;\r\n        priceBook.cll[MAXNUM][NEXT] = MINPRICE;\r\n        trading = true;\r\n        balance[owner] = totalSupply;\r\n    }\r\n\r\n/* Functions Getters */\r\n\r\n    function version() public constant returns(string) {\r\n        return VERSION;\r\n    }\r\n\r\n    function etherBalanceOf(address _addr) public constant returns (uint) {\r\n        return etherBalance[_addr];\r\n    }\r\n\r\n    function spread(bool _side) public constant returns(uint) {\r\n        return priceBook.step(HEAD, _side);\r\n    }\r\n\r\n    function getAmount(uint _price, address _trader) \r\n        public constant returns(uint) {\r\n        return amounts[sha3(_price, _trader)];\r\n    }\r\n\r\n    function sizeOf(uint l) constant returns (uint s) {\r\n        if(l == 0) return priceBook.sizeOf();\r\n        return orderFIFOs[l].sizeOf();\r\n    }\r\n    \r\n    function getPriceVolume(uint _price) public constant returns (uint v_)\r\n    {\r\n        uint n = orderFIFOs[_price].step(HEAD,NEXT);\r\n        while (n != HEAD) { \r\n            v_ += amounts[sha3(_price, address(n))];\r\n            n = orderFIFOs[_price].step(n, NEXT);\r\n        }\r\n        return;\r\n    }\r\n\r\n    function getBook() public constant returns (uint[])\r\n    {\r\n        uint i; \r\n        uint p = priceBook.step(MINNUM, NEXT);\r\n        uint[] memory volumes = new uint[](priceBook.sizeOf() * 2 - 2);\r\n        while (p < MAXNUM) {\r\n            volumes[i++] = p;\r\n            volumes[i++] = getPriceVolume(p);\r\n            p = priceBook.step(p, NEXT);\r\n        }\r\n        return volumes; \r\n    }\r\n    \r\n    function numOrdersOf(address _addr) public constant returns (uint)\r\n    {\r\n        uint c;\r\n        uint p = MINNUM;\r\n        while (p < MAXNUM) {\r\n            if (amounts[sha3(p, _addr)] > 0) c++;\r\n            p = priceBook.step(p, NEXT);\r\n        }\r\n        return c;\r\n    }\r\n    \r\n    function getOpenOrdersOf(address _addr) public constant returns (uint[])\r\n    {\r\n        uint i;\r\n        uint c;\r\n        uint p = MINNUM;\r\n        uint[] memory open = new uint[](numOrdersOf(_addr)*2);\r\n        p = MINNUM;\r\n        while (p < MAXNUM) {\r\n            if (amounts[sha3(p, _addr)] > 0) {\r\n                open[i++] = p;\r\n                open[i++] = amounts[sha3(p, _addr)];\r\n            }\r\n            p = priceBook.step(p, NEXT);\r\n        }\r\n        return open;\r\n    }\r\n\r\n    function getNode(uint _list, uint _node) public constant returns(uint[2])\r\n    {\r\n        return [orderFIFOs[_list].cll[_node][PREV], \r\n            orderFIFOs[_list].cll[_node][NEXT]];\r\n    }\r\n    \r\n/* Functions Public */\r\n\r\n// Here non-constant public functions act as a security layer. They are re-entry\r\n// protected so cannot call each other. For this reason, they\r\n// are being used for parameter and enterance validation, while internal\r\n// functions manage the logic. This also allows for deriving contracts to\r\n// overload the public function with customised validations and not have to\r\n// worry about rewritting the logic.\r\n\r\n    function buy (uint _bidPrice, uint _amount, bool _make)\r\n        payable\r\n        canEnter\r\n        isTrading\r\n        isValidBuy(_bidPrice, _amount)\r\n        returns (bool)\r\n    {\r\n        trade(_bidPrice, _amount, BID, _make);\r\n        return true;\r\n    }\r\n\r\n    function sell (uint _askPrice, uint _amount, bool _make)\r\n        external\r\n        canEnter\r\n        isTrading\r\n        isValidSell(_askPrice, _amount)\r\n        returns (bool)\r\n    {\r\n        trade(_askPrice, _amount, ASK, _make);\r\n        return true;\r\n    }\r\n\r\n    function withdraw(uint _ether)\r\n        external\r\n        canEnter\r\n        hasEther(msg.sender, _ether)\r\n        returns (bool success_)\r\n    {\r\n        etherBalance[msg.sender] -= _ether;\r\n        safeSend(msg.sender, _ether);\r\n        success_ = true;\r\n    }\r\n\r\n    function cancel(uint _price)\r\n        external\r\n        canEnter\r\n        returns (bool)\r\n    {\r\n        TradeMessage memory tmsg;\r\n        tmsg.price = _price;\r\n        tmsg.balance = balance[msg.sender];\r\n        tmsg.etherBalance = etherBalance[msg.sender];\r\n        cancelIntl(tmsg);\r\n        balance[msg.sender] = tmsg.balance;\r\n        etherBalance[msg.sender] = tmsg.etherBalance;\r\n        return true;\r\n    }\r\n    \r\n    function setTrading(bool _trading)\r\n        external\r\n        onlyOwner\r\n        canEnter\r\n        returns (bool)\r\n    {\r\n        trading = _trading;\r\n        Trading(true);\r\n        return true;\r\n    }\r\n\r\n/* Functions Internal */\r\n\r\n// Internal functions handle this contract's logic.\r\n\r\n    function trade (uint _price, uint _amount, bool _side, bool _make) internal {\r\n        TradeMessage memory tmsg;\r\n        tmsg.price = _price;\r\n        tmsg.tradeAmount = _amount;\r\n        tmsg.side = _side;\r\n        tmsg.make = _make;\r\n        \r\n        // Cache state balances to memory and commit to storage only once after trade.\r\n        tmsg.balance  = balance[msg.sender];\r\n        tmsg.etherBalance = etherBalance[msg.sender] + msg.value;\r\n\r\n        take(tmsg);\r\n        make(tmsg);\r\n        \r\n        balance[msg.sender] = tmsg.balance;\r\n        etherBalance[msg.sender] = tmsg.etherBalance;\r\n    }\r\n    \r\n    function take (TradeMessage tmsg)\r\n        internal\r\n    {\r\n        address maker;\r\n        bytes32 orderHash;\r\n        uint takeAmount;\r\n        uint takeEther;\r\n        // use of signed math on unsigned ints is intentional\r\n        uint sign = tmsg.side ? uint(1) : uint(-1);\r\n        uint bestPrice = spread(!tmsg.side);\r\n\r\n        // Loop with available gas to take orders\r\n        while (\r\n            tmsg.tradeAmount > 0 &&\r\n            cmpEq(tmsg.price, bestPrice, !tmsg.side) && \r\n            msg.gas > MINGAS\r\n        )\r\n        {\r\n            maker = address(orderFIFOs[bestPrice].step(HEAD, NEXT));\r\n            orderHash = sha3(bestPrice, maker);\r\n            if (tmsg.tradeAmount < amounts[orderHash]) {\r\n                // Prepare to take partial order\r\n                amounts[orderHash] = safeSub(amounts[orderHash], tmsg.tradeAmount);\r\n                takeAmount = tmsg.tradeAmount;\r\n                tmsg.tradeAmount = 0;\r\n            } else {\r\n                // Prepare to take full order\r\n                takeAmount = amounts[orderHash];\r\n                tmsg.tradeAmount = safeSub(tmsg.tradeAmount, takeAmount);\r\n                closeOrder(bestPrice, maker);\r\n            }\r\n            takeEther = safeMul(bestPrice, takeAmount);\r\n            // signed multiply on uints is intentional and so safeMaths will \r\n            // break here. Valid range for exit balances are 0..2**128 \r\n            tmsg.etherBalance += takeEther * sign;\r\n            tmsg.balance -= takeAmount * sign;\r\n            if (tmsg.side) {\r\n                // Sell to bidder\r\n                if (msg.sender == maker) {\r\n                    // bidder is self\r\n                    tmsg.balance += takeAmount;\r\n                } else {\r\n                    balance[maker] += takeAmount;\r\n                }\r\n            } else {\r\n                // Buy from asker;\r\n                if (msg.sender == maker) {\r\n                    // asker is self\r\n                    tmsg.etherBalance += takeEther;\r\n                } else {                \r\n                    etherBalance[maker] += takeEther;\r\n                }\r\n            }\r\n            // prep for next order\r\n            bestPrice = spread(!tmsg.side);\r\n            Sale (bestPrice, takeAmount, msg.sender, maker);\r\n        }\r\n    }\r\n\r\n    function make(TradeMessage tmsg)\r\n        internal\r\n    {\r\n        bytes32 orderHash;\r\n        if (tmsg.tradeAmount == 0 || !tmsg.make || msg.gas < MINGAS) return;\r\n        orderHash = sha3(tmsg.price, msg.sender);\r\n        if (amounts[orderHash] != 0) {\r\n            // Cancel any pre-existing owned order at this price\r\n            cancelIntl(tmsg);\r\n        }\r\n        if (!orderFIFOs[tmsg.price].exists()) {\r\n            // Register price in pricebook\r\n            priceBook.insert(\r\n                priceBook.seek(HEAD, tmsg.price, tmsg.side),\r\n                tmsg.price, !tmsg.side);\r\n        }\r\n\r\n        amounts[orderHash] = tmsg.tradeAmount;\r\n        orderFIFOs[tmsg.price].push(uint(msg.sender), PREV); \r\n\r\n        if (tmsg.side) {\r\n            tmsg.balance -= tmsg.tradeAmount;\r\n            Ask (tmsg.price, tmsg.tradeAmount, msg.sender);\r\n        } else {\r\n            tmsg.etherBalance -= tmsg.tradeAmount * tmsg.price;\r\n            Bid (tmsg.price, tmsg.tradeAmount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function cancelIntl(TradeMessage tmsg) internal {\r\n        uint amount = amounts[sha3(tmsg.price, msg.sender)];\r\n        if (amount == 0) return;\r\n        if (tmsg.price > spread(BID)) tmsg.balance += amount; // was ask\r\n        else tmsg.etherBalance += tmsg.price * amount; // was bid\r\n        closeOrder(tmsg.price, msg.sender);\r\n    }\r\n\r\n    function closeOrder(uint _price, address _trader) internal {\r\n        orderFIFOs[_price].remove(uint(_trader));\r\n        if (!orderFIFOs[_price].exists())  {\r\n            priceBook.remove(_price);\r\n        }\r\n        delete amounts[sha3(_price, _trader)];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"etherBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ether\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBook\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"getAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getOpenOrdersOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"numOrdersOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_askPrice\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_make\",\"type\":\"bool\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_side\",\"type\":\"bool\"}],\"name\":\"spread\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trading\",\"type\":\"bool\"}],\"name\":\"setTrading\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"getPriceVolume\",\"outputs\":[{\"name\":\"v_\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidPrice\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_make\",\"type\":\"bool\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"l\",\"type\":\"uint256\"}],\"name\":\"sizeOf\",\"outputs\":[{\"name\":\"s\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimalPlaces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_list\",\"type\":\"uint256\"},{\"name\":\"_node\",\"type\":\"uint256\"}],\"name\":\"getNode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trading\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_decimalPlaces\",\"type\":\"uint8\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"}],\"name\":\"Ask\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"Sale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trading\",\"type\":\"bool\"}],\"name\":\"Trading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangedOwner\",\"type\":\"event\"}]","ContractName":"ITT","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000005495454646c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000254954542044656d6f20302e332e36202d204c69766520436861696e2028736f6c20332e362900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000005495454646c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000254954542044656d6f20302e332e36202d204c69766520436861696e2028736f6c20332e3629000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":""}]}