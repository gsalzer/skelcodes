{"status":"1","message":"OK","result":[{"SourceCode":"contract owned {\r\n    address public owner;\r\n    \r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function setOwner(address _new) onlyOwner {\r\n        owner = _new;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n    }\r\n}\r\n\r\ncontract TheGrid is owned {\r\n\t// The number of the game\r\n\tuint public gameId = 1;\r\n\t// The size of the grid. It will start at 3 and increase\r\n    uint public size = 4;\r\n\tuint public nextsize = 5;\r\n\t// Number of empty spots. Reaching 0 will create next game\r\n    uint public empty = 16;\r\n    \r\n\t// The micro of the owners benefit, i.e. it will gain\r\n\t// money / 1000000 * benefitMicros.\r\n    uint public benefitMicros = 24900;\r\n\t// The current price for one spot of the grid\r\n    uint public price = 100 finney;\r\n\t// The price to start with for one spot\r\n\tuint public startPrice = 100 finney;\r\n\t// Micros of the price increase after buy, i.e after each buy\r\n\t// the price will be old / 1000000 * priceIncrease\r\n\tuint public priceIncrease = 15000;\r\n\t// The win for this game\r\n    uint public win;\r\n    \r\n\t// A mapping of the pending payouts\r\n\tmapping(address => uint) public pendingPayouts;\r\n\tuint public totalPayouts;\r\n\t// A mapping of the points gained in this game\r\n    mapping(address => uint) public balanceOf;\r\n    uint public totalSupply;\r\n    \r\n\t// State of the grid. Positions are encoded as _x*size+_y.\r\n    address[] public theGrid;\r\n\t// A list of all players, needed for payouts.\r\n    address[] public players;\r\n\t// The last player who played. Not allowed to play next turn too.\r\n\taddress public lastPlayer;\r\n\t\r\n\t// The timeout interval\r\n\tuint public timeout = 6 hours;\r\n\t// Timestamp of the timeout if no one plays before\r\n\tuint public timeoutAt;\r\n    \r\n\t// Will be triggered on the end of each game\r\n\tevent GameEnded(uint indexed gameId, uint win, uint totalPoints);\r\n\t// Will be triggered on each start of a game\r\n\tevent GameStart(uint indexed gameId, uint size);\r\n\t// Will be triggered on each bought position\r\n\tevent PositionBought(uint indexed gameId, uint indexed moveNo,\r\n\t\t\t\t\t\t uint where, address who, uint pointsGained, \r\n\t\t\t\t\t\t uint etherPaid);\r\n\t// Will be triggered on each timeout!\r\n\tevent Timeout(uint indexed gameId, uint indexed moveNo);\r\n\t// Will be triggered on each payout withdraw\r\n\tevent Collect(address indexed who, uint value);\r\n\t\r\n    function TheGrid() {\r\n\t\t// Setting the length of theGrid and timeout\r\n        theGrid.length = empty;        \r\n\t\ttimeoutAt = now + timeout;\r\n\t\tGameStart(gameId, size);\r\n    }\r\n\t\r\n\t// The direction count counts the positions hold by this player in ONE\r\n\t// direction, i.e. to determine a line length you have to call it twice\r\n\t// (one time for north direction, one time for south by example)\r\n\tfunction directionCount(int _x, int _y, int _dx, int _dy)\r\n\t\t\tinternal returns (uint) {\r\n\t\tvar found = uint(0);\r\n\t\tvar s = int(size);\r\n\t\t_x += _dx;\r\n\t\t_y += _dy;\r\n\t\t// While still on the grid...\r\n\t\twhile (_x < s && _y < s && _x >= 0 && _y >= 0) {\r\n\t\t\t// If it is the sender, gain point, else break\r\n\t\t\tif (theGrid[getIndex(uint(_x), uint(_y))] == msg.sender) {\r\n\t\t\t\tfound ++;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// Go to next position\r\n\t\t\t_x += _dx;\r\n\t\t\t_y += _dy;\r\n\t\t}\r\n\t\treturn found;\r\n\t}\r\n    \r\n    /// Buy the spot at _x, _y if it is available and gain points for every\r\n    /// connected spot of your color sharing lines with this spot.\r\n    function buy(uint _x, uint _y) {\r\n\t\t// Has to be an available position (getIndex will throw off-grid)\r\n        if (theGrid[getIndex(_x, _y)] != 0) throw;\r\n\t\t// No one is allowed to play two token right after each other\r\n\t\tif (msg.sender == lastPlayer) throw;\r\n\t\t// If there is a timeout, divide the price by two and let the\r\n\t\t// next game start at 3 again.\r\n\t\tif (now > timeoutAt) {\r\n\t\t\tprice = price / 2;\r\n\t\t\t// 1 finney is the lowest acceptable price. It makes sure the\r\n\t\t\t// calculation of a players share never becomes 0.\r\n\t\t\tif (price < 1 finney) price = 1 finney;\r\n\t\t\tnextsize = 3;\r\n\t\t\tTimeout(gameId, size*size - empty + 1);\r\n\t\t}\r\n\t\t// If more than the price per position is sended, add it to the\r\n\t\t// payouts so it can be withdrawn later\r\n\t\tif (msg.value < price) {\r\n\t\t\tthrow;\r\n\t\t} else {\r\n\t\t\t// The owner of the contract gets a little benefit\r\n\t\t\t// The sender gets back the overhead\r\n\t\t\tvar benefit = price / 1000000 * benefitMicros;\r\n\t\t\tif (pendingPayouts[owner] + benefit < pendingPayouts[owner]) throw;\r\n\t\t\tpendingPayouts[owner] += benefit;\r\n\t\t\tif (pendingPayouts[msg.sender] + msg.value - price < pendingPayouts[msg.sender]) throw;\r\n\t\t\tpendingPayouts[msg.sender] += msg.value - price;\r\n\t\t\tif (totalPayouts + msg.value - price + benefit < totalPayouts) throw;\r\n\t\t\ttotalPayouts += msg.value - price + benefit;\r\n\t\t\t// Add the price to the win\r\n\t\t\tif (win + price - benefit < win) throw;\r\n\t\t\twin += price - benefit;\r\n\t\t}\r\n\r\n        // Set the position to this address\r\n        empty --;\r\n        theGrid[getIndex(_x, _y)] = msg.sender;\r\n        \r\n        // Add player on first time and give him his one joining point\r\n        var found = uint(0);\r\n\t\tif (balanceOf[msg.sender] == 0) {\r\n            players.push(msg.sender);\r\n\t\t\tfound = 1;\r\n        }\r\n        \r\n        // Discover linear connected spots and give the buyer the square\r\n\t\t// of the lines lengths as points. See the rules.\r\n\t\t\r\n\t\tvar x = int(_x);\r\n\t\tvar y = int(_y);\r\n\t\t\r\n\t\t// East to west\r\n\t\tvar a = 1 + directionCount(x, y, 1, 0) + directionCount(x, y, -1, 0);\r\n\t\tif (a >= 3) {\r\n\t\t\tfound += a * a;\r\n\t\t}\r\n\t\t\r\n\t\t// North east to south west\r\n\t\ta = 1 + directionCount(x, y, 1, 1) + directionCount(x, y, -1, -1);\r\n\t\tif (a >= 3) {\r\n\t\t\tfound += a * a;\r\n\t\t}\r\n\t\t\r\n\t\t// North to south\r\n\t\ta = 1 + directionCount(x, y, 0, 1) + directionCount(x, y, 0, -1);\r\n\t\tif (a >= 3) {\r\n\t\t\tfound += a * a;\r\n\t\t}\r\n\t\t\r\n\t\t// North west to south east\r\n\t\ta = 1 + directionCount(x, y, 1, -1) + directionCount(x, y, -1, 1);\r\n\t\tif (a >= 3) {\r\n\t\t\tfound += a * a;\r\n\t\t}\r\n        \r\n        // Add points\r\n\t\tif (balanceOf[msg.sender] + found < balanceOf[msg.sender]) throw;\r\n        balanceOf[msg.sender] += found;\r\n\t\tif (totalSupply + found < totalSupply) throw;\r\n        totalSupply += found;\r\n\t\t\r\n\t\t// Trigger event before the price increases!\r\n\t\tPositionBought(gameId, size*size-empty, getIndex(_x, _y), msg.sender, found, price);\r\n\t\t\r\n\t\t// Increase the price per position by the price Increase\r\n\t\tprice = price / 1000000 * (1000000 + priceIncrease);\r\n\t\t\r\n\t\t// Set new timeout and last player played\r\n\t\ttimeoutAt = now + timeout;\r\n\t\tlastPlayer = msg.sender;\r\n\t\t\r\n\t\t// If this was the last empty position, initiate next game\r\n        if (empty == 0) nextRound();\r\n    }\r\n\t\r\n\t/// Collect your pending payouts using this method\r\n\tfunction collect() {\r\n\t\tvar balance = pendingPayouts[msg.sender];\r\n\t\tpendingPayouts[msg.sender] = 0;\r\n\t\ttotalPayouts -= balance;\r\n\t\tif (!msg.sender.send(balance)) throw;\r\n\t\tCollect(msg.sender, balance);\r\n\t}\r\n    \r\n\t// Returns the in array index of one position and throws on\r\n\t// off-grid position\r\n    function getIndex(uint _x, uint _y) internal returns (uint) {\r\n        if (_x >= size) throw;\r\n        if (_y >= size) throw;\r\n\t\treturn _x * size + _y;\r\n    }\r\n    \r\n\t// Will initiate the next game by clearing most of the data\r\n\t// and calculating the payouts.\r\n    function nextRound() internal {\r\n        GameEnded(gameId, win, totalSupply);\r\n\t\t// Calculate share per point\r\n\t\tif (totalPayouts + win < totalPayouts) throw;\r\n\t\ttotalPayouts += win;\r\n\t\t// If the totalSupply is 0, no one played, so no one can gain a share\r\n\t\t// The maximum total Supply is lower than 1.1e9, so the share can't\r\n\t\t// become 0 because of a too high totalSupply, as a finney is still\r\n\t\t// bigger.\r\n\t\tvar share = totalSupply == 0 ? 0 : win / totalSupply;\r\n        // Send balances to the payouts\r\n\t\t// If the win was not dividable by the number of points, it is kept\r\n\t\t// for the next game. Most properly only some wei.\r\n        for (var i = 0; i < players.length; i++) {\r\n\t\t\tvar amount = share * balanceOf[players[i]];\r\n\t\t\ttotalSupply -= balanceOf[players[i]];\r\n\t\t\tbalanceOf[players[i]] = 0;\r\n\t\t\tif (pendingPayouts[players[i]] + amount < pendingPayouts[players[i]]) throw;\r\n            pendingPayouts[players[i]] += amount;\r\n\t\t\twin -= amount;\r\n        }\r\n\t\t\r\n        \r\n        // Delete positions and player\r\n        delete theGrid;\r\n        delete players;\r\n\t\tlastPlayer = 0x0;\r\n\t\t// The next game will be a bit bigger, but limit it to 64.\r\n        size = nextsize;\r\n\t\tif (nextsize < 64) nextsize ++;\r\n\t\tgameId ++;\r\n\t\t// Calculate empty spots\r\n        empty = size * size;\r\n\t\ttheGrid.length = empty;\r\n\t\t// Reset the price\r\n\t\tprice = startPrice;\r\n\t\t\r\n\t\tGameStart(gameId, size);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"timeoutAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextsize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"win\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingPayouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"theGrid\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"benefitMicros\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"},{\"name\":\"_y\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"empty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceIncrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"win\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"name\":\"GameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"GameStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"moveNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"where\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pointsGained\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherPaid\",\"type\":\"uint256\"}],\"name\":\"PositionBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"moveNo\",\"type\":\"uint256\"}],\"name\":\"Timeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Collect\",\"type\":\"event\"}]","ContractName":"TheGrid","CompilerVersion":"v0.3.5-2016-08-03-3b21d98","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}