{"status":"1","message":"OK","result":[{"SourceCode":"contract Mapoc {\r\n    address _owner;\r\n    address _filiate;\r\n\r\n    mapping (string => uint) private mapExecs;\r\n    Execution[] private executions;\r\n    event Executed(string Hash);\r\n    event Validated(string Hash);\r\n    \r\n    struct Execution {\r\n        uint dateCreated;\r\n        string hash;\r\n        bool validated;\r\n        uint dateValidated;\r\n    }\r\n    \r\n    \r\n    /* CONSTRUCTOR */\r\n    function Mapoc(/*address filiate*/) {\r\n        _owner = msg.sender;\r\n        _filiate = msg.sender;\r\n    }\r\n    \r\n    function kill() ownerAllowed() {\r\n        suicide(_owner);\r\n    }\r\n    \r\n    /* MAPPING */\r\n    function map(string hash) internal returns(uint) {\r\n        uint ret = mapExecs[hash];\r\n        if(ret >= executions.length || !strEqual(executions[ret].hash, hash)) throw;\r\n        return ret;\r\n    }\r\n    \r\n    /* MODIFIERS */\r\n    modifier bothAllowed() {\r\n        if(msg.sender != _owner && msg.sender != _filiate) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier ownerAllowed() {\r\n        if(msg.sender != _owner) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier filiateAllowed() {\r\n        if(msg.sender != _filiate) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier notYetExist(string hash) {\r\n        uint num = mapExecs[hash];\r\n        if(num < executions.length && strEqual(executions[num].hash, hash)) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier notYetValidated(string hash) {\r\n        Execution e = executions[map(hash)];\r\n        if(e.validated) throw;\r\n        _;\r\n    }\r\n    \r\n    modifier orderExist(string hash) {\r\n        Execution e = executions[map(hash)];\r\n        if(!strEqual(e.hash, hash)) throw;\r\n        _;\r\n    }\r\n    \r\n    /* FONCTIONS */\r\n    function AddExec(string Hash) public ownerAllowed() notYetExist(Hash) {\r\n        uint num = executions.length++;\r\n        mapExecs[Hash] = num;\r\n        Execution e = executions[num];\r\n        e.dateCreated = now;\r\n        e.hash = Hash;\r\n        Executed(Hash);\r\n    }\r\n    \r\n    function ValidateExec(string Hash) public filiateAllowed() notYetValidated(Hash) {\r\n        Execution e = executions[map(Hash)];\r\n        e.validated = true;\r\n        e.dateValidated = now;\r\n        Validated(Hash);\r\n    }\r\n    \r\n    function CheckExecution(string Hash) public bothAllowed() constant returns(bool IsExist, uint DateCreated, bool Validated, uint DateValidated){\r\n        uint ret = mapExecs[Hash];\r\n        if(ret >= executions.length || !strEqual(executions[ret].hash, Hash)) return (false, 0, false, 0);\r\n        Execution e = executions[ret];\r\n        return (true, e.dateCreated, e.validated, e.dateValidated);\r\n    }\r\n    \r\n    function IsValidated(string Hash) public bothAllowed() constant returns(bool) {\r\n        Execution e = executions[map(Hash)];\r\n        return e.validated;\r\n    }\r\n    \r\n    function LastExecuted() public bothAllowed() constant returns(string Hash, uint DateCreated) {\r\n        DateCreated = 0;\r\n        if(executions.length > 0) {\r\n            if(!executions[0].validated) {\r\n                Hash = executions[0].hash;\r\n                DateCreated = executions[0].dateCreated;\r\n            }\r\n            for(uint i = executions.length - 1; i > 0; i--) {\r\n                if(!executions[i].validated && executions[i].dateCreated > DateCreated) {\r\n                    Hash = executions[i].hash;\r\n                    DateCreated = executions[i].dateCreated;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return (Hash, DateCreated);\r\n    }\r\n    \r\n    function LastValidated() public bothAllowed() constant returns(string Hash, uint DateValidated) {\r\n        DateValidated = 0;\r\n        for(uint i = 0; i < executions.length; i++) {\r\n            if(executions[i].validated && executions[i].dateValidated > DateValidated) {\r\n                Hash = executions[i].hash;\r\n                DateValidated = executions[i].dateValidated;\r\n            }\r\n        }\r\n        return (Hash, DateValidated);\r\n    }\r\n    \r\n    function CountExecs() public bothAllowed() constant returns(uint Total, uint NotVal) {\r\n        uint nbNotVal = 0;\r\n        for(uint i = 0; i < executions.length; i++) {\r\n            if(!executions[i].validated) nbNotVal++;\r\n        }\r\n        return (executions.length, nbNotVal);\r\n    }\r\n    \r\n    function NotValSince(uint timestampFrom) public bothAllowed() constant returns(uint Count, string First, uint DateFirst, string Last, uint DateLast) {\r\n        Count = 0;\r\n        DateFirst = now;\r\n        DateLast = 0;\r\n        for(uint i = 0; i < executions.length; i++) {\r\n            if(!executions[i].validated && executions[i].dateCreated >= timestampFrom) {\r\n                Count++;\r\n                if(executions[i].dateCreated < DateFirst) {\r\n                    First = executions[i].hash;\r\n                    DateFirst = executions[i].dateCreated;\r\n                }\r\n                else if(executions[i].dateCreated > DateLast) {\r\n                    Last = executions[i].hash;\r\n                    DateLast = executions[i].dateCreated;\r\n                }\r\n            }\r\n        }\r\n        return (Count, First, DateFirst, Last, DateLast);\r\n    }\r\n    \r\n    function ListNotValSince(uint timestampFrom) public bothAllowed() constant returns(uint Count, string List, uint OldestTime) {\r\n        Count = 0;\r\n        List = \"\\n\";\r\n        OldestTime = now;\r\n        for(uint i = 0; i < executions.length; i++) {\r\n            if(!executions[i].validated && executions[i].dateCreated >= timestampFrom) {\r\n                Count++;\r\n                List = strConcat(List, executions[i].hash, \" ;\\n\");\r\n                if(executions[i].dateCreated < OldestTime)\r\n                    OldestTime = executions[i].dateCreated;\r\n            }\r\n        }\r\n        return (Count, List, OldestTime);\r\n    }\r\n    \r\n    function ListAllSince(uint timestampFrom) public bothAllowed() constant returns(uint Count, string List) {\r\n        List = \"\\n\";\r\n        for(uint i = 0; i < executions.length; i++) {\r\n            string memory val;\r\n            if(executions[i].validated)\r\n                val = \"confirmed\\n\";\r\n            else\r\n                val = \"published\\n\";\r\n                \r\n            List = strConcat(List, executions[i].hash, \" : \", val);\r\n        }\r\n        return (executions.length, List);\r\n    }\r\n    \r\n    /* UTILS */\r\n    function strEqual(string _a, string _b) internal returns(bool) {\r\n\t\tbytes memory a = bytes(_a);\r\n\t\tbytes memory b = bytes(_b);\r\n\t\tif (a.length != b.length)\r\n\t\t\treturn false;\r\n\r\n\t\tfor (uint i = 0; i < a.length; i ++)\r\n\t\t\tif (a[i] != b[i])\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction strConcat(string _a, string _b, string _c, string _d, string _e) internal returns(string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns(string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c) internal returns(string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n    \r\n    function strConcat(string _a, string _b) internal returns(string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"ValidateExec\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestampFrom\",\"type\":\"uint256\"}],\"name\":\"ListNotValSince\",\"outputs\":[{\"name\":\"Count\",\"type\":\"uint256\"},{\"name\":\"List\",\"type\":\"string\"},{\"name\":\"OldestTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestampFrom\",\"type\":\"uint256\"}],\"name\":\"NotValSince\",\"outputs\":[{\"name\":\"Count\",\"type\":\"uint256\"},{\"name\":\"First\",\"type\":\"string\"},{\"name\":\"DateFirst\",\"type\":\"uint256\"},{\"name\":\"Last\",\"type\":\"string\"},{\"name\":\"DateLast\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"CheckExecution\",\"outputs\":[{\"name\":\"IsExist\",\"type\":\"bool\"},{\"name\":\"DateCreated\",\"type\":\"uint256\"},{\"name\":\"Validated\",\"type\":\"bool\"},{\"name\":\"DateValidated\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"IsValidated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"AddExec\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestampFrom\",\"type\":\"uint256\"}],\"name\":\"ListAllSince\",\"outputs\":[{\"name\":\"Count\",\"type\":\"uint256\"},{\"name\":\"List\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LastValidated\",\"outputs\":[{\"name\":\"Hash\",\"type\":\"string\"},{\"name\":\"DateValidated\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CountExecs\",\"outputs\":[{\"name\":\"Total\",\"type\":\"uint256\"},{\"name\":\"NotVal\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LastExecuted\",\"outputs\":[{\"name\":\"Hash\",\"type\":\"string\"},{\"name\":\"DateCreated\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Hash\",\"type\":\"string\"}],\"name\":\"Validated\",\"type\":\"event\"}]","ContractName":"Mapoc","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":""}]}