{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function owner() external view returns (address);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IMasterChef {\r\n    function BONUS_MULTIPLIER() external view returns (uint256);\r\n    function bonusEndBlock() external view returns (uint256);\r\n    function devaddr() external view returns (address);\r\n    function migrator() external view returns (address);\r\n    function owner() external view returns (address);\r\n    function startBlock() external view returns (uint256);\r\n    function sushi() external view returns (address);\r\n    function sushiPerBlock() external view returns (uint256);\r\n    function totalAllocPoint() external view returns (uint256);\r\n    function poolLength() external view returns (uint256);\r\n\r\n    function poolInfo(uint256 nr)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\r\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\r\n}\r\n\r\ninterface IPair is IERC20 {\r\n    function token0() external view returns (IERC20);\r\n    function token1() external view returns (IERC20);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112,\r\n            uint112,\r\n            uint32\r\n        );\r\n}\r\n\r\ninterface IFactory {\r\n    function allPairsLength() external view returns (uint256);\r\n    function allPairs(uint256 i) external view returns (IPair);\r\n    function getPair(IERC20 token0, IERC20 token1) external view returns (IPair);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n}\r\n\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public immutable owner;\r\n\r\n    constructor() internal {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\nlibrary BoringERC20 {\r\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length >= 64) {\r\n            return abi.decode(data, (string));\r\n        } else if (data.length == 32) {\r\n            uint8 i = 0;\r\n            while(i < 32 && data[i] != 0) {\r\n                i++;\r\n            }\r\n            bytes memory bytesArray = new bytes(i);\r\n            for (i = 0; i < 32 && data[i] != 0; i++) {\r\n                bytesArray[i] = data[i];\r\n            }\r\n            return string(bytesArray);\r\n        } else {\r\n            return \"???\";\r\n        }\r\n    } \r\n    \r\n    function symbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    function name(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    function decimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n}\r\n\r\nlibrary BoringPair {\r\n    function factory(IPair pair) internal view returns (IFactory) {\r\n        (bool success, bytes memory data) = address(pair).staticcall(abi.encodeWithSelector(0xc45a0155));\r\n        return success && data.length == 32 ? abi.decode(data, (IFactory)) : IFactory(0);\r\n    }\r\n}\r\n\r\ninterface IStrategy {\r\n    function skim(uint256 amount) external;\r\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\r\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\r\n    function exit(uint256 balance) external returns (int256 amountAdded);\r\n}\r\n\r\ninterface IBentoBox {\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\r\n    event LogRegisterProtocol(address indexed protocol);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\r\n    event LogStrategyDivest(address indexed token, uint256 amount);\r\n    event LogStrategyInvest(address indexed token, uint256 amount);\r\n    event LogStrategyLoss(address indexed token, uint256 amount);\r\n    event LogStrategyProfit(address indexed token, uint256 amount);\r\n    event LogStrategyQueued(address indexed token, address indexed strategy);\r\n    event LogStrategySet(address indexed token, address indexed strategy);\r\n    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\r\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\r\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\r\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    function balanceOf(IERC20, address) external view returns (uint256);\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\r\n    function claimOwnership() external;\r\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable;\r\n    function deposit(IERC20 token_, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);\r\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\r\n    function masterContractApproved(address, address) external view returns (bool);\r\n    function masterContractOf(address) external view returns (address);\r\n    function nonces(address) external view returns (uint256);\r\n    function owner() external view returns (address);\r\n    function pendingOwner() external view returns (address);\r\n    function pendingStrategy(IERC20) external view returns (IStrategy);\r\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function registerProtocol() external;\r\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\r\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\r\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\r\n    function strategy(IERC20) external view returns (IStrategy);\r\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\r\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\r\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\r\n    function totals(IERC20) external view returns (uint128 elastic, uint128 base);\r\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\r\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\r\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\r\n    function whitelistMasterContract(address masterContract, bool approved) external;\r\n    function whitelistedMasterContracts(address) external view returns (bool);\r\n    function withdraw(IERC20 token_, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\ncontract BoringHelper is Ownable {\r\n    IERC20 public WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IFactory public sushiFactory; // IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\r\n    IFactory public uniV2Factory; // IFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    IBentoBox public bentoBox; // 0xB5891167796722331b7ea7824F036b3Bdcb4531C\r\n\r\n    constructor(\r\n        IERC20 WETH_,\r\n        IFactory sushiFactory_,\r\n        IFactory uniV2Factory_,\r\n        IBentoBox bentoBox_\r\n    ) public {\r\n        WETH = WETH_;\r\n        sushiFactory = sushiFactory_;\r\n        uniV2Factory = uniV2Factory_;\r\n        bentoBox = bentoBox_;\r\n    }\r\n\r\n    function getETHRate(IERC20 token) public view returns (uint256) {\r\n        if (token == WETH) {\r\n            return 1e18;\r\n        }\r\n        IPair pairUniV2 = IPair(uniV2Factory.getPair(token, WETH));\r\n        IPair pairSushi = IPair(sushiFactory.getPair(token, WETH));\r\n        if (address(pairUniV2) == address(0) && address(pairSushi) == address(0)) {\r\n            return 0;\r\n        }\r\n\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        IERC20 token0;\r\n        if (address(pairUniV2) != address(0)) {\r\n            (uint112 reserve0UniV2, uint112 reserve1UniV2, ) = pairUniV2.getReserves();\r\n            reserve0 += reserve0UniV2;\r\n            reserve1 += reserve1UniV2;\r\n            token0 = pairUniV2.token0();\r\n        }\r\n\r\n        if (address(pairSushi) != address(0)) {\r\n            (uint112 reserve0Sushi, uint112 reserve1Sushi, ) = pairSushi.getReserves();\r\n            reserve0 += reserve0Sushi;\r\n            reserve1 += reserve1Sushi;\r\n            if (token0 == IERC20(0)) {\r\n                token0 = pairSushi.token0();\r\n            }\r\n        }\r\n\r\n        if (token0 == WETH) {\r\n            return uint256(reserve1) * 1e18 / reserve0;\r\n        } else {\r\n            return uint256(reserve0) * 1e18 / reserve1;\r\n        }\r\n    }\r\n\r\n    struct BalanceFull {\r\n        IERC20 token;\r\n        uint256 balance;\r\n        uint256 bentoBalance;\r\n        uint256 bentoAllowance;\r\n        uint128 bentoAmount;\r\n        uint128 bentoShare;\r\n        uint256 rate;\r\n    }\r\n\r\n    function getBalances(address who, IERC20[] calldata addresses) public view returns (BalanceFull[] memory) {\r\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\r\n\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            IERC20 token = addresses[i];\r\n            balances[i].token = token;\r\n            balances[i].balance = token.balanceOf(who);\r\n            balances[i].bentoAllowance = token.allowance(who, address(bentoBox));\r\n            balances[i].bentoBalance = bentoBox.balanceOf(token, who);\r\n            if (balances[i].bentoBalance != 0) {\r\n                (balances[i].bentoAmount, balances[i].bentoShare) = bentoBox.totals(token);\r\n            }\r\n            balances[i].rate = getETHRate(token);\r\n        }\r\n\r\n        return balances;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"WETH_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"sushiFactory_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"uniV2Factory_\",\"type\":\"address\"},{\"internalType\":\"contract IBentoBox\",\"name\":\"bentoBox_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bentoBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bentoAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"bentoAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"bentoShare\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelper.BalanceFull[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiFactory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BoringHelper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000b5891167796722331b7ea7824f036b3bdcb4531c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://15324e05f35e78a12735a8e0136394ae53dce44d611bffbb0b6894b6e79d05a2"}]}