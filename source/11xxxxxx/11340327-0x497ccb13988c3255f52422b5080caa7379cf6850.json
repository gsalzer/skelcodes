{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/test_contracts/AllUsedERC20Methods.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\n\\ncontract AllUsedERC20Methods {\\n    function name() public pure returns (string memory) {\\n        return 'AllUsedERC20Methods';\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return 'ALLERC20';\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public pure returns (uint256) {\\n        return 10**9;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test_contracts/AllUsedERC721Methods.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\n\\ncontract AllUsedERC721Methods {\\n    function name() public pure returns (string memory) {\\n        return 'AllUsedERC721Methods';\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return 'ALLERC721';\\n    }\\n\\n    function totalSupply() public pure returns (uint256) {\\n        return 10**9;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        external\\n        pure\\n        returns (bool)\\n    {\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test_contracts/IncompleteERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\n\\ncontract IncompleteERC20 {\\n    function symbol() public pure returns (string memory) {\\n        return 'INCERC20';\\n    }\\n\\n    function totalSupply() public pure returns (uint256) {\\n        return 10**9;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test_contracts/IncompleteERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\n\\ncontract IncompleteERC721 {\\n    function name() public pure returns (string memory) {\\n        return 'IncompleteERC721';\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        external\\n        pure\\n        returns (bool)\\n    {\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test_contracts/OtherERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\n\\ncontract OtherERC165 {\\n    function supportsInterface(bytes4 interfaceID)\\n        external\\n        pure\\n        returns (bool)\\n    {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test_contracts/UniToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\n\\ncontract UniToken {\\n    address public token0;\\n    address public token1;\\n\\n    constructor(address _token0, address _token1) {\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n\\n    function symbol() public pure returns (string memory) {\\n        return \\\"UNI-V2\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenLoader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n// target contract interface - selection of used ERC20 and ERC721 methods\\nabstract contract Target {\\n    function name() public virtual view returns (string memory);\\n\\n    function symbol() public virtual view returns (string memory);\\n\\n    function decimals() public virtual view returns (uint8);\\n\\n    function totalSupply() public virtual view returns (uint256);\\n\\n    // Method from ERC165 interface used to check whether the contract is ERC721\\n    function supportsInterface(bytes4 interfaceID)\\n        external\\n        virtual\\n        view\\n        returns (bool);\\n}\\n\\ncontract TokenLoader {\\n    struct TokenInfo {\\n        address addr; // address of the token contract\\n        bool definitelyIsERC721; // can be resolved only when the token implements ERC165\\n        string name; // mandatory in ERC20, voluntary in ERC721 (ERC721Metadata interface)\\n        string symbol; // mandatory in ERC20, voluntary in ERC721 (ERC721Metadata interface)\\n        uint8 decimals; // mandatory in ERC20\\n        uint256 totalSupply; // mandatory in ERC20, voluntary in ERC721 (ERC721Enumerable interface)\\n    }\\n\\n    function loadTokens(address[] calldata tokens)\\n        external\\n        view\\n        returns (TokenInfo[] memory tokenInfo)\\n    {\\n        tokenInfo = new TokenInfo[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            if (!isContract(tokens[i])) {\\n                continue;\\n            }\\n            Target target = Target(tokens[i]);\\n\\n            tokenInfo[i].addr = tokens[i];\\n\\n            tokenInfo[i].definitelyIsERC721 = definitelyIsERC721(target);\\n\\n            (bool success, bytes memory returnData) = address(target)\\n                .staticcall(abi.encodeWithSelector(target.name.selector));\\n            if (success) {\\n                tokenInfo[i].name = abi.decode(returnData, (string));\\n            } else {\\n                tokenInfo[i].name = '';\\n            }\\n\\n            (success, returnData) = address(target).staticcall(\\n                abi.encodeWithSelector(target.symbol.selector)\\n            );\\n            if (success) {\\n                tokenInfo[i].symbol = abi.decode(returnData, (string));\\n            } else {\\n                tokenInfo[i].symbol = '';\\n            }\\n\\n            (success, returnData) = address(target).staticcall(\\n                abi.encodeWithSelector(target.decimals.selector)\\n            );\\n            if (success) {\\n                tokenInfo[i].decimals = abi.decode(returnData, (uint8));\\n            } else {\\n                tokenInfo[i].decimals = 0;\\n            }\\n\\n            (success, returnData) = address(target).staticcall(\\n                abi.encodeWithSelector(target.totalSupply.selector)\\n            );\\n            if (success) {\\n                tokenInfo[i].totalSupply = abi.decode(returnData, (uint256));\\n            } else {\\n                tokenInfo[i].totalSupply = 0;\\n            }\\n        }\\n\\n        return tokenInfo;\\n    }\\n\\n    function isContract(address _addr) private view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    function definitelyIsERC721(Target target) private view returns (bool) {\\n        // 0x80ac58cd - ERC721 ID\\n        (bool success, bytes memory returnData) = address(target).staticcall(\\n            abi.encodeWithSelector(\\n                target.supportsInterface.selector,\\n                0x80ac58cd\\n            )\\n        );\\n        return success && abi.decode(returnData, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniTokenLoader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\n\\npragma solidity ^0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract UniTarget {\\n    function symbol() public virtual view returns (string memory);\\n\\n    function token0() public virtual view returns (address);\\n\\n    function token1() public virtual view returns (address);\\n}\\n\\n// target contract interface - selection of used ERC20\\nabstract contract Target {\\n    function name() public virtual view returns (string memory);\\n\\n    function symbol() public virtual view returns (string memory);\\n\\n    function decimals() public virtual view returns (uint8);\\n\\n    function totalSupply() public virtual view returns (uint256);\\n}\\n\\ncontract UniTokenLoader {\\n\\n    struct TokenInfo {\\n        address addr;\\n        string name;\\n        string symbol;\\n        uint8 decimals;\\n        uint256 totalSupply;\\n    }\\n\\n    function loadTokens(address[] calldata tokens) external view returns (TokenInfo[] memory tokenInfo) {\\n        tokenInfo = new TokenInfo[](2 * tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            UniTarget uniToken = UniTarget(tokens[i]);\\n            (bool success, bytes memory returnData) = tokens[i].staticcall(abi.encodeWithSelector(uniToken.symbol.selector));\\n\\n            // keccak256(bytes(\\\"UNI-V2\\\")) = 0x0c49a525f6758cfb27d0ada1467d2a2e99733995423d47ae30ae4ba2ba563255\\n            if (success && returnData.length != 0 && keccak256(abi.decode(returnData, (bytes))) == 0x0c49a525f6758cfb27d0ada1467d2a2e99733995423d47ae30ae4ba2ba563255) {\\n                address token0Address = uniToken.token0();\\n                address token1Address = uniToken.token1();\\n                Target token0 = Target(token0Address);\\n                Target token1 = Target(token1Address);\\n\\n                tokenInfo[2 * i] = TokenInfo(token0Address, token0.name(), token0.symbol(), token0.decimals(), token0.totalSupply());\\n                tokenInfo[2 * i + 1] = TokenInfo(token1Address, token1.name(), token1.symbol(), token1.decimals(), token1.totalSupply());\\n            }\\n        }\\n\\n        return tokenInfo;\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"loadTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"definitelyIsERC721\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenLoader.TokenInfo[]\",\"name\":\"tokenInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenLoader","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}