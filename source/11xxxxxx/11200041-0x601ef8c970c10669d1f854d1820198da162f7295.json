{"status":"1","message":"OK","result":[{"SourceCode":"/**************************************************************************\r\n *            ____        _                              \r\n *           / ___|      | |     __ _  _   _   ___  _ __ \r\n *          | |    _____ | |    / _` || | | | / _ \\| '__|\r\n *          | |___|_____|| |___| (_| || |_| ||  __/| |   \r\n *           \\____|      |_____|\\__,_| \\__, | \\___||_|   \r\n *                                     |___/             \r\n * \r\n **************************************************************************\r\n *\r\n *  The MIT License (MIT)\r\n * SPDX-License-Identifier: MIT\r\n *\r\n * Copyright (c) 2016-2020 Cyril Lapinte\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n **************************************************************************\r\n *\r\n * Flatten Contract: TokenCore\r\n *\r\n * Git Commit:\r\n * https://github.com/c-layer/contracts/commit/9993912325afde36151b04d0247ac9ea9ffa2a93\r\n *\r\n **************************************************************************/\r\n\r\n\r\n// File: @c-layer/common/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IAccessDefinitions.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IAccessDefinitions\r\n * @dev IAccessDefinitions\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\ncontract IAccessDefinitions {\r\n\r\n  // Hardcoded role granting all - non sysop - privileges\r\n  bytes32 internal constant ALL_PRIVILEGES = bytes32(\"AllPrivileges\");\r\n  address internal constant ALL_PROXIES = address(0x416c6C50726F78696573); // \"AllProxies\"\r\n\r\n  // Roles\r\n  bytes32 internal constant FACTORY_CORE_ROLE = bytes32(\"FactoryCoreRole\");\r\n  bytes32 internal constant FACTORY_PROXY_ROLE = bytes32(\"FactoryProxyRole\");\r\n\r\n  // Sys Privileges\r\n  bytes4 internal constant DEFINE_ROLE_PRIV =\r\n    bytes4(keccak256(\"defineRole(bytes32,bytes4[])\"));\r\n  bytes4 internal constant ASSIGN_OPERATORS_PRIV =\r\n    bytes4(keccak256(\"assignOperators(bytes32,address[])\"));\r\n  bytes4 internal constant REVOKE_OPERATORS_PRIV =\r\n    bytes4(keccak256(\"revokeOperators(address[])\"));\r\n  bytes4 internal constant ASSIGN_PROXY_OPERATORS_PRIV =\r\n    bytes4(keccak256(\"assignProxyOperators(address,bytes32,address[])\"));\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IOperableStorage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title IOperableStorage\r\n * @dev The Operable storage\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\nabstract contract IOperableStorage is IAccessDefinitions {\r\n  function proxyDelegateId(address _proxy) virtual public view returns (uint256);\r\n  function delegate(uint256 _delegateId) virtual public view returns (address);\r\n\r\n  function coreRole(address _address) virtual public view returns (bytes32);\r\n  function proxyRole(address _proxy, address _address) virtual public view returns (bytes32);\r\n  function rolePrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\r\n  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\r\n  function hasCorePrivilege(address _address, bytes4 _privilege) virtual public view returns (bool);\r\n  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) virtual public view returns (bool);\r\n\r\n  event RoleDefined(bytes32 role);\r\n  event OperatorAssigned(bytes32 role, address operator);\r\n  event ProxyOperatorAssigned(address proxy, bytes32 role, address operator);\r\n  event OperatorRevoked(address operator);\r\n  event ProxyOperatorRevoked(address proxy, address operator);\r\n\r\n  event ProxyDefined(address proxy, uint256 delegateId);\r\n  event ProxyMigrated(address proxy, address newCore);\r\n  event ProxyRemoved(address proxy);\r\n}\r\n\r\n// File: @c-layer/common/contracts/operable/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * @dev functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n *\r\n * Error messages\r\n *   OW01: Message sender is not the owner\r\n *   OW02: New owner must be valid\r\n*/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"OW01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0), \"OW02\");\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/Storage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Storage\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n **/\r\ncontract Storage {\r\n  mapping(address => uint256) internal proxyDelegateIds;\r\n  mapping(uint256 => address) internal delegates;\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/OperableStorage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OperableStorage\r\n * @dev The Operable contract enable the restrictions of operations to a set of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\ncontract OperableStorage is IOperableStorage, Ownable, Storage {\r\n\r\n  struct RoleData {\r\n    mapping(bytes4 => bool) privileges;\r\n  }\r\n\r\n  struct OperatorData {\r\n    bytes32 coreRole;\r\n    mapping(address => bytes32) proxyRoles;\r\n  }\r\n\r\n  // Mapping address => role\r\n  // Mapping role => bytes4 => bool\r\n  mapping (address => OperatorData) internal operators;\r\n  mapping (bytes32 => RoleData) internal roles;\r\n\r\n  /**\r\n   * @dev proxyDelegateId\r\n   */\r\n  function proxyDelegateId(address _proxy) override public view returns (uint256) {\r\n    return proxyDelegateIds[_proxy];\r\n  }\r\n\r\n  /**\r\n   * @dev delegate\r\n   */\r\n  function delegate(uint256 _delegateId) override public view returns (address) {\r\n    return delegates[_delegateId];\r\n  }\r\n\r\n  /**\r\n   * @dev core role\r\n   * @param _address operator address\r\n   */\r\n  function coreRole(address _address) override public view returns (bytes32) {\r\n    return operators[_address].coreRole;\r\n  }\r\n\r\n  /**\r\n   * @dev proxy role\r\n   * @param _address operator address\r\n   */\r\n  function proxyRole(address _proxy, address _address)\r\n    override public view returns (bytes32)\r\n  {\r\n    return operators[_address].proxyRoles[_proxy];\r\n  }\r\n\r\n  /**\r\n   * @dev has role privilege\r\n   * @dev low level access to role privilege\r\n   * @dev ignores ALL_PRIVILEGES role\r\n   */\r\n  function rolePrivilege(bytes32 _role, bytes4 _privilege)\r\n    override public view returns (bool)\r\n  {\r\n    return roles[_role].privileges[_privilege];\r\n  }\r\n\r\n  /**\r\n   * @dev roleHasPrivilege\r\n   */\r\n  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) override public view returns (bool) {\r\n    return (_role == ALL_PRIVILEGES) || roles[_role].privileges[_privilege];\r\n  }\r\n\r\n  /**\r\n   * @dev hasCorePrivilege\r\n   * @param _address operator address\r\n   */\r\n  function hasCorePrivilege(address _address, bytes4 _privilege) override public view returns (bool) {\r\n    bytes32 role = operators[_address].coreRole;\r\n    return (role == ALL_PRIVILEGES) || roles[role].privileges[_privilege];\r\n  }\r\n\r\n  /**\r\n   * @dev hasProxyPrivilege\r\n   * @dev the default proxy role can be set with proxy address(0)\r\n   * @param _address operator address\r\n   */\r\n  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) override public view returns (bool) {\r\n    OperatorData storage data = operators[_address];\r\n    bytes32 role = (data.proxyRoles[_proxy] != bytes32(0)) ?\r\n      data.proxyRoles[_proxy] : data.proxyRoles[ALL_PROXIES];\r\n    return (role == ALL_PRIVILEGES) || roles[role].privileges[_privilege];\r\n  }\r\n}\r\n\r\n// File: contracts/interface/IRule.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IRule\r\n * @dev IRule interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n **/\r\ninterface IRule {\r\n  function isAddressValid(address _address) external view returns (bool);\r\n  function isTransferValid(address _from, address _to, uint256 _amount)\r\n    external view returns (bool);\r\n}\r\n\r\n// File: @c-layer/oracle/contracts/interface/IUserRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IUserRegistry\r\n * @dev IUserRegistry interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n **/\r\nabstract contract IUserRegistry {\r\n\r\n  enum KeyCode {\r\n    KYC_LIMIT_KEY,\r\n    RECEPTION_LIMIT_KEY,\r\n    EMISSION_LIMIT_KEY\r\n  }\r\n\r\n  event UserRegistered(uint256 indexed userId, address address_, uint256 validUntilTime);\r\n  event AddressAttached(uint256 indexed userId, address address_);\r\n  event AddressDetached(uint256 indexed userId, address address_);\r\n  event UserSuspended(uint256 indexed userId);\r\n  event UserRestored(uint256 indexed userId);\r\n  event UserValidity(uint256 indexed userId, uint256 validUntilTime);\r\n  event UserExtendedKey(uint256 indexed userId, uint256 key, uint256 value);\r\n  event UserExtendedKeys(uint256 indexed userId, uint256[] values);\r\n  event ExtendedKeysDefinition(uint256[] keys);\r\n\r\n  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\r\n    virtual external returns (bool);\r\n  function registerManyUsersFullExternal(\r\n    address[] calldata _addresses,\r\n    uint256 _validUntilTime,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n  function attachManyAddressesExternal(uint256[] calldata _userIds, address[] calldata _addresses)\r\n    virtual external returns (bool);\r\n  function detachManyAddressesExternal(address[] calldata _addresses)\r\n    virtual external returns (bool);\r\n  function suspendManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\r\n  function restoreManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\r\n  function updateManyUsersExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended) virtual external returns (bool);\r\n  function updateManyUsersExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _key, uint256 _value) virtual external returns (bool);\r\n  function updateManyUsersAllExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n  function updateManyUsersFullExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n\r\n  function name() virtual public view returns (string memory);\r\n  function currency() virtual public view returns (bytes32);\r\n\r\n  function userCount() virtual public view returns (uint256);\r\n  function userId(address _address) virtual public view returns (uint256);\r\n  function validUserId(address _address) virtual public view returns (uint256);\r\n  function validUser(address _address, uint256[] memory _keys)\r\n    virtual public view returns (uint256, uint256[] memory);\r\n  function validity(uint256 _userId) virtual public view returns (uint256, bool);\r\n\r\n  function extendedKeys() virtual public view returns (uint256[] memory);\r\n  function extended(uint256 _userId, uint256 _key)\r\n    virtual public view returns (uint256);\r\n  function manyExtended(uint256 _userId, uint256[] memory _key)\r\n    virtual public view returns (uint256[] memory);\r\n\r\n  function isAddressValid(address _address) virtual public view returns (bool);\r\n  function isValid(uint256 _userId) virtual public view returns (bool);\r\n\r\n  function defineExtendedKeys(uint256[] memory _extendedKeys) virtual public returns (bool);\r\n\r\n  function registerUser(address _address, uint256 _validUntilTime)\r\n    virtual public returns (bool);\r\n  function registerUserFull(\r\n    address _address,\r\n    uint256 _validUntilTime,\r\n    uint256[] memory _values) virtual public returns (bool);\r\n\r\n  function attachAddress(uint256 _userId, address _address) virtual public returns (bool);\r\n  function detachAddress(address _address) virtual public returns (bool);\r\n  function detachSelf() virtual public returns (bool);\r\n  function detachSelfAddress(address _address) virtual public returns (bool);\r\n  function suspendUser(uint256 _userId) virtual public returns (bool);\r\n  function restoreUser(uint256 _userId) virtual public returns (bool);\r\n  function updateUser(uint256 _userId, uint256 _validUntilTime, bool _suspended)\r\n    virtual public returns (bool);\r\n  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\r\n    virtual public returns (bool);\r\n  function updateUserAllExtended(uint256 _userId, uint256[] memory _values)\r\n    virtual public returns (bool);\r\n  function updateUserFull(\r\n    uint256 _userId,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] memory _values) virtual public returns (bool);\r\n}\r\n\r\n// File: @c-layer/oracle/contracts/interface/IRatesProvider.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IRatesProvider\r\n * @dev IRatesProvider interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract IRatesProvider {\r\n\r\n  function defineRatesExternal(uint256[] calldata _rates) virtual external returns (bool);\r\n\r\n  function name() virtual public view returns (string memory);\r\n\r\n  function rate(bytes32 _currency) virtual public view returns (uint256);\r\n\r\n  function currencies() virtual public view\r\n    returns (bytes32[] memory, uint256[] memory, uint256);\r\n  function rates() virtual public view returns (uint256, uint256[] memory);\r\n\r\n  function convert(uint256 _amount, bytes32 _fromCurrency, bytes32 _toCurrency)\r\n    virtual public view returns (uint256);\r\n\r\n  function defineCurrencies(\r\n    bytes32[] memory _currencies,\r\n    uint256[] memory _decimals,\r\n    uint256 _rateOffset) virtual public returns (bool);\r\n  function defineRates(uint256[] memory _rates) virtual public returns (bool);\r\n\r\n  event RateOffset(uint256 rateOffset);\r\n  event Currencies(bytes32[] currencies, uint256[] decimals);\r\n  event Rate(bytes32 indexed currency, uint256 rate);\r\n}\r\n\r\n// File: contracts/interface/ITokenStorage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ITokenStorage\r\n * @dev Token storage interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract ITokenStorage {\r\n  enum TransferCode {\r\n    UNKNOWN,\r\n    OK,\r\n    INVALID_SENDER,\r\n    NO_RECIPIENT,\r\n    INSUFFICIENT_TOKENS,\r\n    LOCKED,\r\n    FROZEN,\r\n    RULE,\r\n    INVALID_RATE,\r\n    NON_REGISTRED_SENDER,\r\n    NON_REGISTRED_RECEIVER,\r\n    LIMITED_EMISSION,\r\n    LIMITED_RECEPTION\r\n  }\r\n\r\n  enum Scope {\r\n    DEFAULT\r\n  }\r\n\r\n  enum AuditStorageMode {\r\n    ADDRESS,\r\n    USER_ID,\r\n    SHARED\r\n  }\r\n\r\n  enum AuditTriggerMode {\r\n    UNDEFINED,\r\n    NONE,\r\n    SENDER_ONLY,\r\n    RECEIVER_ONLY,\r\n    BOTH\r\n  }\r\n\r\n  address internal constant ANY_ADDRESSES = address(0x416e79416464726573736573); // \"AnyAddresses\"\r\n\r\n  event OracleDefined(\r\n    IUserRegistry userRegistry,\r\n    IRatesProvider ratesProvider,\r\n    address currency);\r\n  event TokenDelegateDefined(uint256 indexed delegateId, address delegate, uint256[] configurations);\r\n  event TokenDelegateRemoved(uint256 indexed delegateId);\r\n  event AuditConfigurationDefined(\r\n    uint256 indexed configurationId,\r\n    uint256 scopeId,\r\n    AuditTriggerMode mode,\r\n    uint256[] senderKeys,\r\n    uint256[] receiverKeys,\r\n    IRatesProvider ratesProvider,\r\n    address currency);\r\n  event AuditTriggersDefined(\r\n    uint256 indexed configurationId,\r\n    address[] senders,\r\n    address[] receivers,\r\n    AuditTriggerMode[] modes);\r\n  event AuditsRemoved(address scope, uint256 scopeId);\r\n  event SelfManaged(address indexed holder, bool active);\r\n\r\n  event Minted(address indexed token, uint256 amount);\r\n  event MintFinished(address indexed token);\r\n  event Burned(address indexed token, uint256 amount);\r\n  event RulesDefined(address indexed token, IRule[] rules);\r\n  event LockDefined(\r\n    address indexed lock,\r\n    address sender,\r\n    address receiver,\r\n    uint256 startAt,\r\n    uint256 endAt\r\n  );\r\n  event Seize(address indexed token, address account, uint256 amount);\r\n  event Freeze(address address_, uint256 until);\r\n  event ClaimDefined(\r\n    address indexed token,\r\n    address indexed claim,\r\n    uint256 claimAt);\r\n  event TokenLocksDefined(\r\n    address indexed token,\r\n    address[] locks);\r\n  event TokenDefined(\r\n    address indexed token,\r\n    string name,\r\n    string symbol,\r\n    uint256 decimals);\r\n  event LogTransferData(\r\n    address token, address caller, address sender, address receiver,\r\n    uint256 senderId, uint256[] senderKeys, bool senderFetched,\r\n    uint256 receiverId, uint256[] receiverKeys, bool receiverFetched,\r\n    uint256 value, uint256 convertedValue);\r\n  event LogTransferAuditData(\r\n    uint256 auditConfigurationId, uint256 scopeId,\r\n    address currency, IRatesProvider ratesProvider,\r\n    bool senderAuditRequired, bool receiverAuditRequired);\r\n  event LogAuditData(\r\n    uint64 createdAt, uint64 lastTransactionAt,\r\n    uint256 cumulatedEmission, uint256 cumulatedReception\r\n  );\r\n}\r\n\r\n// File: contracts/TokenStorage.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Token storage\r\n * @dev Token storage\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\ncontract TokenStorage is ITokenStorage, OperableStorage {\r\n  using SafeMath for uint256;\r\n\r\n  struct LockData {\r\n    uint64 startAt;\r\n    uint64 endAt;\r\n  }\r\n\r\n  struct TokenData {\r\n    string name;\r\n    string symbol;\r\n    uint256 decimals;\r\n\r\n    uint256 totalSupply;\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowances;\r\n\r\n    bool mintingFinished;\r\n\r\n    uint256 allTimeMinted;\r\n    uint256 allTimeBurned;\r\n    uint256 allTimeSeized;\r\n\r\n    mapping (address => uint256) frozenUntils;\r\n    address[] locks;\r\n    IRule[] rules;\r\n  }\r\n\r\n  struct AuditData {\r\n    uint64 createdAt;\r\n    uint64 lastTransactionAt;\r\n    uint256 cumulatedEmission;\r\n    uint256 cumulatedReception;\r\n  }\r\n\r\n  struct AuditStorage {\r\n    address currency;\r\n\r\n    AuditData sharedData;\r\n    mapping(uint256 => AuditData) userData;\r\n    mapping(address => AuditData) addressData;\r\n  }\r\n\r\n  struct AuditConfiguration {\r\n    uint256 scopeId;\r\n\r\n    uint256[] senderKeys;\r\n    uint256[] receiverKeys;\r\n    IRatesProvider ratesProvider;\r\n\r\n    mapping (address => mapping(address => AuditTriggerMode)) triggers;\r\n  }\r\n\r\n  // AuditConfigurationId => AuditConfiguration\r\n  mapping (uint256 => AuditConfiguration) internal auditConfigurations;\r\n  // DelegateId => AuditConfigurationId[]\r\n  mapping (uint256 => uint256[]) internal delegatesConfigurations_;\r\n  mapping (address => TokenData) internal tokens;\r\n\r\n  // Scope x ScopeId => AuditStorage\r\n  mapping (address => mapping (uint256 => AuditStorage)) internal audits;\r\n\r\n  // Prevents operator to act on behalf\r\n  mapping (address => bool) internal selfManaged;\r\n\r\n  // Proxy x Sender x Receiver x LockData\r\n  mapping (address => mapping (address => mapping(address => LockData))) internal locks;\r\n\r\n  IUserRegistry internal userRegistry_;\r\n  IRatesProvider internal ratesProvider_;\r\n  address internal currency_;\r\n  string internal name_;\r\n\r\n  /**\r\n   * @dev currentTime()\r\n   */\r\n  function currentTime() internal view returns (uint64) {\r\n    // solhint-disable-next-line not-rely-on-time\r\n    return uint64(now);\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IProxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title IProxy\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n **/\r\ninterface IProxy {\r\n\r\n  function core() external view returns (address);\r\n\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/Proxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Proxy\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   PR01: Only accessible by core\r\n *   PR02: Core request should be successful\r\n **/\r\ncontract Proxy is IProxy {\r\n\r\n  address public override core;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than a core\r\n   */\r\n  modifier onlyCore {\r\n    require(core == msg.sender, \"PR01\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _core) public {\r\n    core = _core;\r\n  }\r\n\r\n  /**\r\n   * @dev update the core\r\n   */\r\n  function updateCore(address _core)\r\n    public onlyCore returns (bool)\r\n  {\r\n    core = _core;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev enforce static immutability (view)\r\n   * @dev in order to read core value through internal core delegateCall\r\n   */\r\n  function staticCallUint256() internal view returns (uint256 value) {\r\n    (bool status, bytes memory result) = core.staticcall(msg.data);\r\n    require(status, string(result));\r\n    value = abi.decode(result, (uint256));\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IOperableCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title IOperableCore\r\n * @dev The Operable contract enable the restrictions of operations to a set of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\nabstract contract IOperableCore is IOperableStorage {\r\n  function defineRole(bytes32 _role, bytes4[] memory _privileges) virtual public returns (bool);\r\n  function assignOperators(bytes32 _role, address[] memory _operators) virtual public returns (bool);\r\n  function assignProxyOperators(\r\n    address _proxy, bytes32 _role, address[] memory _operators) virtual public returns (bool);\r\n  function revokeOperators(address[] memory _operators) virtual public returns (bool);\r\n  function revokeProxyOperators(address _proxy, address[] memory _operators) virtual public returns (bool);\r\n\r\n  function defineProxy(address _proxy, uint256 _delegateId) virtual public returns (bool);\r\n  function migrateProxy(address _proxy, address _newCore) virtual public returns (bool);\r\n  function removeProxy(address _proxy) virtual public returns (bool);\r\n}\r\n\r\n// File: @c-layer/common/contracts/call/DelegateCall.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title DelegateCall\r\n * @dev Calls delegates for non view functions only\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error Messages:\r\n **/\r\nlibrary DelegateCall {\r\n\r\n  function _delegateCall(address _delegate) internal virtual returns (bool status)\r\n  {\r\n    bytes memory result;\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (status, result) = _delegate.delegatecall(msg.data);\r\n    require(status, string(result));\r\n  }\r\n\r\n  function _delegateCallBool(address _delegate) internal returns (bool status)\r\n  {\r\n    return abi.decode(_delegateCallBytes(_delegate), (bool));\r\n  }\r\n\r\n  function _delegateCallUint256(address _delegate) internal returns (uint256)\r\n  {\r\n    return abi.decode(_delegateCallBytes(_delegate), (uint256));\r\n  }\r\n\r\n  function _delegateCallBytes(address _delegate)\r\n    internal returns (bytes memory result)\r\n  {\r\n    bool status;\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (status, result) = _delegate.delegatecall(msg.data);\r\n    require(status, string(result));\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/Core.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Core\r\n * @dev Solidity version 0.5.x prevents to mark as view\r\n * @dev functions using delegate call.\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   CO01: Only Proxy may access the function\r\n *   CO02: Address 0 is an invalid delegate address\r\n *   CO03: Delegatecall should be successful\r\n *   CO04: DelegateId must be greater than 0\r\n *   CO05: Proxy must exist\r\n *   CO06: Proxy must be already defined\r\n *   CO07: Proxy update must be successful\r\n **/\r\ncontract Core is Storage {\r\n  using DelegateCall for address;\r\n\r\n  modifier onlyProxy {\r\n    require(delegates[proxyDelegateIds[msg.sender]] != address(0), \"CO01\");\r\n    _;\r\n  }\r\n\r\n  function validProxyDelegate(address _proxy) internal view returns (address delegate) {\r\n    uint256 delegateId = proxyDelegateIds[_proxy];\r\n    delegate = delegates[delegateId];\r\n    require(delegate != address(0), \"CO02\");\r\n  }\r\n\r\n  function delegateCall(address _proxy) internal returns (bool status)\r\n  {\r\n    return validProxyDelegate(_proxy)._delegateCall();\r\n  }\r\n\r\n  function delegateCallBool(address _proxy)\r\n    internal returns (bool)\r\n  {\r\n    return validProxyDelegate(_proxy)._delegateCallBool();\r\n  }\r\n\r\n  function delegateCallUint256(address _proxy)\r\n    internal returns (uint256)\r\n  {\r\n    return validProxyDelegate(_proxy)._delegateCallUint256();\r\n  }\r\n\r\n  function delegateCallBytes(address _proxy)\r\n    internal returns (bytes memory result)\r\n  {\r\n    return validProxyDelegate(_proxy)._delegateCallBytes();\r\n  }\r\n\r\n  function defineDelegateInternal(uint256 _delegateId, address _delegate) internal returns (bool) {\r\n    require(_delegateId != 0, \"CO04\");\r\n    delegates[_delegateId] = _delegate;\r\n    return true;\r\n  }\r\n\r\n  function defineProxyInternal(address _proxy, uint256 _delegateId)\r\n    virtual internal returns (bool)\r\n  {\r\n    require(delegates[_delegateId] != address(0), \"CO02\");\r\n    require(_proxy != address(0), \"CO05\");\r\n\r\n    proxyDelegateIds[_proxy] = _delegateId;\r\n    return true;\r\n  }\r\n\r\n  function migrateProxyInternal(address _proxy, address _newCore)\r\n    internal returns (bool)\r\n  {\r\n    require(proxyDelegateIds[_proxy] != 0, \"CO06\");\r\n    require(Proxy(_proxy).updateCore(_newCore), \"CO07\");\r\n    return true;\r\n  }\r\n\r\n  function removeProxyInternal(address _proxy)\r\n    internal virtual returns (bool)\r\n  {\r\n    require(proxyDelegateIds[_proxy] != 0, \"CO06\");\r\n    delete proxyDelegateIds[_proxy];\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/OperableCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OperableCore\r\n * @dev The Operable contract enable the restrictions of operations to a set of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   OC01: Sender is not a system operator\r\n *   OC02: Sender is not a core operator\r\n *   OC03: Sender is not a proxy operator\r\n *   OC04: Role must not be null\r\n *   OC05: AllPrivileges is a reserved role\r\n *   OC06: AllProxies is not a valid proxy address\r\n *   OC07: Proxy must be valid\r\n *   OC08: Operator has no role\r\n */\r\ncontract OperableCore is IOperableCore, Core, OperableStorage {\r\n\r\n  constructor(address[] memory _sysOperators) public {\r\n    assignOperators(ALL_PRIVILEGES, _sysOperators);\r\n    assignProxyOperators(ALL_PROXIES, ALL_PRIVILEGES, _sysOperators);\r\n  }\r\n\r\n  /**\r\n   * @dev onlySysOp modifier\r\n   * @dev for safety reason, core owner\r\n   * @dev can always define roles and assign or revoke operatos\r\n   */\r\n  modifier onlySysOp() {\r\n    require(msg.sender == owner || hasCorePrivilege(msg.sender, msg.sig), \"OC01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev onlyCoreOp modifier\r\n   */\r\n  modifier onlyCoreOp() {\r\n    require(hasCorePrivilege(msg.sender, msg.sig), \"OC02\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev onlyProxyOp modifier\r\n   */\r\n  modifier onlyProxyOp(address _proxy) {\r\n    require(hasProxyPrivilege(msg.sender, _proxy, msg.sig), \"OC03\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev defineRoles\r\n   * @param _role operator role\r\n   * @param _privileges as 4 bytes of the method\r\n   */\r\n  function defineRole(bytes32 _role, bytes4[] memory _privileges)\r\n    override public onlySysOp returns (bool)\r\n  {\r\n    require(_role != bytes32(0), \"OC04\");\r\n    require(_role != ALL_PRIVILEGES, \"OC05\");\r\n\r\n    delete roles[_role];\r\n    for (uint256 i=0; i < _privileges.length; i++) {\r\n      roles[_role].privileges[_privileges[i]] = true;\r\n    }\r\n    emit RoleDefined(_role);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev assignOperators\r\n   * @param _role operator role. May be a role not defined yet.\r\n   * @param _operators addresses\r\n   */\r\n  function assignOperators(bytes32 _role, address[] memory _operators)\r\n    override public onlySysOp returns (bool)\r\n  {\r\n    require(_role != bytes32(0), \"OC04\");\r\n\r\n    for (uint256 i=0; i < _operators.length; i++) {\r\n      operators[_operators[i]].coreRole = _role;\r\n      emit OperatorAssigned(_role, _operators[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev assignProxyOperators\r\n   * @param _role operator role. May be a role not defined yet.\r\n   * @param _operators addresses\r\n   */\r\n  function assignProxyOperators(\r\n    address _proxy, bytes32 _role, address[] memory _operators)\r\n    override public onlySysOp returns (bool)\r\n  {\r\n    require(_proxy == ALL_PROXIES ||\r\n      delegates[proxyDelegateIds[_proxy]] != address(0), \"OC07\");\r\n    require(_role != bytes32(0), \"OC04\");\r\n\r\n    for (uint256 i=0; i < _operators.length; i++) {\r\n      operators[_operators[i]].proxyRoles[_proxy] = _role;\r\n      emit ProxyOperatorAssigned(_proxy, _role, _operators[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev revokeOperator\r\n   * @param _operators addresses\r\n   */\r\n  function revokeOperators(address[] memory _operators)\r\n    override public onlySysOp returns (bool)\r\n  {\r\n    for (uint256 i=0; i < _operators.length; i++) {\r\n      OperatorData storage operator = operators[_operators[i]];\r\n      require(operator.coreRole != bytes32(0), \"OC08\");\r\n      operator.coreRole = bytes32(0);\r\n\r\n      emit OperatorRevoked(_operators[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev revokeProxyOperator\r\n   * @param _operators addresses\r\n   */\r\n  function revokeProxyOperators(address _proxy, address[] memory _operators)\r\n    override public onlySysOp returns (bool)\r\n  {\r\n    for (uint256 i=0; i < _operators.length; i++) {\r\n      OperatorData storage operator = operators[_operators[i]];\r\n      require(operator.proxyRoles[_proxy] != bytes32(0), \"OC08\");\r\n      operator.proxyRoles[_proxy] = bytes32(0);\r\n\r\n      emit ProxyOperatorRevoked(_proxy, _operators[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function defineProxy(address _proxy, uint256 _delegateId)\r\n    override public onlyCoreOp returns (bool)\r\n  {\r\n    require(_proxy != ALL_PROXIES, \"OC06\");\r\n    defineProxyInternal(_proxy, _delegateId);\r\n    emit ProxyDefined(_proxy, _delegateId);\r\n    return true;\r\n  }\r\n\r\n  function migrateProxy(address _proxy, address _newCore)\r\n    override public onlyCoreOp returns (bool)\r\n  {\r\n    migrateProxyInternal(_proxy, _newCore);\r\n    emit ProxyMigrated(_proxy, _newCore);\r\n    return true;\r\n  }\r\n\r\n  function removeProxy(address _proxy)\r\n    override public onlyCoreOp returns (bool)\r\n  {\r\n    removeProxyInternal(_proxy);\r\n    emit ProxyRemoved(_proxy);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/core/OperableProxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OperableProxy\r\n * @dev The OperableAs contract enable the restrictions of operations to a set of operators\r\n * @dev It relies on another Operable contract and reuse the same list of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * OP01: Message sender must be authorized\r\n */\r\ncontract OperableProxy is Proxy {\r\n\r\n  // solhint-disable-next-line no-empty-blocks\r\n  constructor(address _core) public Proxy(_core) { }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the operator\r\n   */\r\n  modifier onlyOperator {\r\n    require(OperableCore(core).hasProxyPrivilege(\r\n      msg.sender, address(this), msg.sig), \"OP01\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/interface/IERC20.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n *\r\n */\r\ninterface IERC20 {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint256);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    external view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function increaseApproval(address _spender, uint256 _addedValue)\r\n    external returns (bool);\r\n\r\n  function decreaseApproval(address _spender, uint256 _subtractedValue)\r\n    external returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ITokenProxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IToken proxy\r\n * @dev Token proxy interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\nabstract contract ITokenProxy is IERC20, Proxy {\r\n\r\n  function canTransfer(address, address, uint256)\r\n    virtual public view returns (uint256);\r\n\r\n  function emitTransfer(address _from, address _to, uint256 _value)\r\n    virtual public returns (bool);\r\n\r\n  function emitApproval(address _owner, address _spender, uint256 _value)\r\n    virtual public returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ITokenCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ITokenCore\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n **/\r\nabstract contract ITokenCore is ITokenStorage, IOperableCore {\r\n\r\n  function name() virtual public view returns (string memory);\r\n  function oracle() virtual public view returns (\r\n    IUserRegistry userRegistry,\r\n    IRatesProvider ratesProvider,\r\n    address currency);\r\n\r\n  function auditConfiguration(uint256 _configurationId)\r\n    virtual public view returns (\r\n      uint256 scopeId,\r\n      AuditTriggerMode _mode,\r\n      uint256[] memory senderKeys,\r\n      uint256[] memory receiverKeys,\r\n      IRatesProvider ratesProvider,\r\n      address currency);\r\n  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\r\n    virtual public view returns (AuditTriggerMode);\r\n  function delegatesConfigurations(uint256 _delegateId)\r\n    virtual public view returns (uint256[] memory);\r\n\r\n  function auditCurrency(\r\n    address _scope,\r\n    uint256 _scopeId\r\n  ) virtual external view returns (address currency);\r\n  function audit(\r\n    address _scope,\r\n    uint256 _scopeId,\r\n    AuditStorageMode _storageMode,\r\n    bytes32 _storageId) virtual external view returns (\r\n    uint64 createdAt,\r\n    uint64 lastTransactionAt,\r\n    uint256 cumulatedEmission,\r\n    uint256 cumulatedReception);\r\n\r\n  /**************  ERC20  **************/\r\n  function tokenName() virtual external view returns (string memory);\r\n  function tokenSymbol() virtual external view returns (string memory);\r\n\r\n  function decimals() virtual external returns (uint256);\r\n  function totalSupply() virtual external returns (uint256);\r\n  function balanceOf(address) virtual external returns (uint256);\r\n  function allowance(address, address) virtual external returns (uint256);\r\n  function transfer(address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function transferFrom(address, address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function approve(address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function increaseApproval(address, address, uint256)\r\n    virtual external returns (bool status);\r\n  function decreaseApproval(address, address, uint256)\r\n    virtual external returns (bool status);\r\n\r\n  /***********  TOKEN DATA   ***********/\r\n  function token(address _token) virtual external view returns (\r\n    bool mintingFinished,\r\n    uint256 allTimeMinted,\r\n    uint256 allTimeBurned,\r\n    uint256 allTimeSeized,\r\n    address[] memory locks,\r\n    uint256 freezedUntil,\r\n    IRule[] memory);\r\n  function lock(address _lock, address _sender, address _receiver) virtual external view returns (\r\n    uint64 startAt, uint64 endAt);\r\n  function canTransfer(address, address, uint256)\r\n    virtual external returns (uint256);\r\n\r\n  /***********  TOKEN ADMIN  ***********/\r\n  function mint(address, address[] calldata, uint256[] calldata)\r\n    virtual external returns (bool);\r\n  function finishMinting(address)\r\n    virtual external returns (bool);\r\n  function burn(address, uint256)\r\n    virtual external returns (bool);\r\n  function seize(address _token, address, uint256)\r\n    virtual external returns (bool);\r\n  function defineLock(address, address, address, uint64, uint64)\r\n    virtual external returns (bool);\r\n  function defineTokenLocks(address _token, address[] memory locks)\r\n    virtual external returns (bool);\r\n  function freezeManyAddresses(\r\n    address _token,\r\n    address[] calldata _addresses,\r\n    uint256 _until) virtual external returns (bool);\r\n  function defineRules(address, IRule[] calldata) virtual external returns (bool);\r\n\r\n  /************  CORE ADMIN  ************/\r\n  function defineToken(\r\n    address _token,\r\n    uint256 _delegateId,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint256 _decimals) virtual external returns (bool);\r\n\r\n  function defineOracle(\r\n    IUserRegistry _userRegistry,\r\n    IRatesProvider _ratesProvider,\r\n    address _currency) virtual external returns (bool);\r\n  function defineTokenDelegate(\r\n    uint256 _delegateId,\r\n    address _delegate,\r\n    uint256[] calldata _configurations) virtual external returns (bool);\r\n  function defineAuditConfiguration(\r\n    uint256 _configurationId,\r\n    uint256 _scopeId,\r\n    AuditTriggerMode _mode,\r\n    uint256[] calldata _senderKeys,\r\n    uint256[] calldata _receiverKeys,\r\n    IRatesProvider _ratesProvider,\r\n    address _currency) virtual external returns (bool);\r\n  function removeAudits(address _scope, uint256 _scopeId)\r\n    virtual external returns (bool);\r\n  function defineAuditTriggers(\r\n    uint256 _configurationId,\r\n    address[] calldata _senders,\r\n    address[] calldata _receivers,\r\n    AuditTriggerMode[] calldata _modes) virtual external returns (bool);\r\n\r\n  function isSelfManaged(address _owner)\r\n    virtual external view returns (bool);\r\n  function manageSelf(bool _active)\r\n    virtual external returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ITokenDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Token Delegate Interface\r\n * @dev Token Delegate Interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\nabstract contract ITokenDelegate is ITokenStorage {\r\n\r\n  function decimals() virtual public view returns (uint256);\r\n  function totalSupply() virtual public view returns (uint256);\r\n  function balanceOf(address _owner) virtual public view returns (uint256);\r\n  function allowance(address _owner, address _spender)\r\n    virtual public view returns (uint256);\r\n  function transfer(address _sender, address _receiver, uint256 _value)\r\n    virtual public returns (bool);\r\n  function transferFrom(\r\n    address _caller, address _sender, address _receiver, uint256 _value)\r\n    virtual public returns (bool);\r\n  function canTransfer(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _value) virtual public view returns (TransferCode);\r\n  function approve(address _sender, address _spender, uint256 _value)\r\n    virtual public returns (bool);\r\n  function increaseApproval(address _sender, address _spender, uint _addedValue)\r\n    virtual public returns (bool);\r\n  function decreaseApproval(address _sender, address _spender, uint _subtractedValue)\r\n    virtual public returns (bool);\r\n  function checkConfigurations(uint256[] memory _auditConfigurationIds)\r\n    virtual public returns (bool);\r\n}\r\n\r\n// File: contracts/TokenCore.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenCore\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n *   TC01: Token cannot be equivalent to AllProxies\r\n *   TC02: Currency stored values must remain consistent\r\n *   TC03: Delegate has invalid audit configurations values\r\n *   TC04: Mismatched between the configuration and the audit storage currency\r\n *   TC05: The audit triggers definition requires the same number of addresses and values\r\n **/\r\ncontract TokenCore is ITokenCore, OperableCore, TokenStorage {\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor(string memory _name, address[] memory _sysOperators)\r\n    public OperableCore(_sysOperators)\r\n  {\r\n    name_ = _name;\r\n  }\r\n\r\n  function name() override public view returns (string memory) {\r\n    return name_;\r\n  }\r\n\r\n  function oracle() override public view returns (\r\n    IUserRegistry userRegistry,\r\n    IRatesProvider ratesProvider,\r\n    address currency)\r\n  {\r\n    return (userRegistry_, ratesProvider_, currency_);\r\n  }\r\n\r\n  function auditConfiguration(uint256 _configurationId)\r\n    override public view returns (\r\n      uint256 scopeId,\r\n      AuditTriggerMode mode,\r\n      uint256[] memory senderKeys,\r\n      uint256[] memory receiverKeys,\r\n      IRatesProvider ratesProvider,\r\n      address currency)\r\n  {\r\n    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\r\n    return (\r\n      auditConfiguration_.scopeId,\r\n      auditConfiguration_.triggers[ANY_ADDRESSES][ANY_ADDRESSES],\r\n      auditConfiguration_.senderKeys,\r\n      auditConfiguration_.receiverKeys,\r\n      auditConfiguration_.ratesProvider,\r\n      audits[address(this)][auditConfiguration_.scopeId].currency\r\n    );\r\n  }\r\n\r\n  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\r\n    override public view returns (AuditTriggerMode)\r\n  {\r\n    return auditConfigurations[_configurationId].triggers[_sender][_receiver];\r\n  }\r\n\r\n  function delegatesConfigurations(uint256 _delegateId)\r\n    override public view returns (uint256[] memory)\r\n  {\r\n    return delegatesConfigurations_[_delegateId];\r\n  }\r\n\r\n  function auditCurrency(\r\n    address _scope,\r\n    uint256 _scopeId\r\n  ) override external view returns (address currency) {\r\n    return audits[_scope][_scopeId].currency;\r\n  }\r\n\r\n  function audit(\r\n    address _scope,\r\n    uint256 _scopeId,\r\n    AuditStorageMode _storageMode,\r\n    bytes32 _storageId) override external view returns (\r\n    uint64 createdAt,\r\n    uint64 lastTransactionAt,\r\n    uint256 cumulatedEmission,\r\n    uint256 cumulatedReception)\r\n  {\r\n    AuditData memory auditData;\r\n    if (_storageMode == AuditStorageMode.SHARED) {\r\n      auditData = audits[_scope][_scopeId].sharedData;\r\n    }\r\n    if (_storageMode == AuditStorageMode.ADDRESS) {\r\n      auditData = audits[_scope][_scopeId].addressData[address(bytes20(_storageId))];\r\n    }\r\n    if (_storageMode == AuditStorageMode.USER_ID) {\r\n      auditData = audits[_scope][_scopeId].userData[uint256(_storageId)];\r\n    }\r\n\r\n    createdAt = auditData.createdAt;\r\n    lastTransactionAt = auditData.lastTransactionAt;\r\n    cumulatedEmission = auditData.cumulatedEmission;\r\n    cumulatedReception = auditData.cumulatedReception;\r\n  }\r\n\r\n  /**************  ERC20  **************/\r\n  function tokenName() override external view returns (string memory) {\r\n    return tokens[msg.sender].name;\r\n  }\r\n\r\n  function tokenSymbol() override external view returns (string memory) {\r\n    return tokens[msg.sender].symbol;\r\n  }\r\n\r\n  function decimals() override external onlyProxy returns (uint256) {\r\n    return delegateCallUint256(msg.sender);\r\n  }\r\n\r\n  function totalSupply() override external onlyProxy returns (uint256) {\r\n    return delegateCallUint256(msg.sender);\r\n  }\r\n\r\n  function balanceOf(address) external onlyProxy override returns (uint256) {\r\n    return delegateCallUint256(msg.sender);\r\n  }\r\n\r\n  function allowance(address, address)\r\n    override external onlyProxy returns (uint256)\r\n  {\r\n    return delegateCallUint256(msg.sender);\r\n  }\r\n\r\n  function transfer(address, address, uint256)\r\n    override external onlyProxy returns (bool status)\r\n  {\r\n    return delegateCall(msg.sender);\r\n  }\r\n\r\n  function transferFrom(address, address, address, uint256)\r\n    override external onlyProxy returns (bool status)\r\n  {\r\n    return delegateCall(msg.sender);\r\n  }\r\n\r\n  function approve(address, address, uint256)\r\n    override external onlyProxy returns (bool status)\r\n  {\r\n    return delegateCall(msg.sender);\r\n  }\r\n\r\n  function increaseApproval(address, address, uint256)\r\n    override external onlyProxy returns (bool status)\r\n  {\r\n    return delegateCall(msg.sender);\r\n  }\r\n\r\n  function decreaseApproval(address, address, uint256)\r\n    override external onlyProxy returns (bool status)\r\n  {\r\n    return delegateCall(msg.sender);\r\n  }\r\n\r\n  /***********  TOKEN DATA   ***********/\r\n  function token(address _token) override external view returns (\r\n    bool mintingFinished,\r\n    uint256 allTimeMinted,\r\n    uint256 allTimeBurned,\r\n    uint256 allTimeSeized,\r\n    address[] memory locks,\r\n    uint256 frozenUntil,\r\n    IRule[] memory rules) {\r\n    TokenData storage tokenData = tokens[_token];\r\n\r\n    mintingFinished = tokenData.mintingFinished;\r\n    allTimeMinted = tokenData.allTimeMinted;\r\n    allTimeBurned = tokenData.allTimeBurned;\r\n    allTimeSeized = tokenData.allTimeSeized;\r\n    locks = tokenData.locks;\r\n    frozenUntil = tokenData.frozenUntils[_token];\r\n    rules = tokenData.rules;\r\n  }\r\n\r\n  function lock(address _lock, address _sender, address _receiver) override external view returns (\r\n    uint64 startAt, uint64 endAt)\r\n  {\r\n    LockData storage lockData_ = locks[_lock][_sender][_receiver];\r\n    return (lockData_.startAt, lockData_.endAt);\r\n  }\r\n\r\n  function canTransfer(address, address, uint256)\r\n    override external onlyProxy returns (uint256)\r\n  {\r\n    return delegateCallUint256(msg.sender);\r\n  }\r\n\r\n  /***********  TOKEN ADMIN  ***********/\r\n  function mint(address _token, address[] calldata, uint256[] calldata)\r\n    override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  function finishMinting(address _token)\r\n    override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  function burn(address _token, uint256)\r\n    override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  function seize(address _token, address, uint256)\r\n    override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  function freezeManyAddresses(\r\n    address _token,\r\n    address[] calldata,\r\n    uint256) override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  function defineLock(address _lock, address, address, uint64, uint64)\r\n    override external onlyProxyOp(_lock) returns (bool)\r\n  {\r\n    return delegateCall(_lock);\r\n  }\r\n\r\n  function defineTokenLocks(address _token, address[] calldata)\r\n    override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  function defineRules(address _token, IRule[] calldata)\r\n    override external onlyProxyOp(_token) returns (bool)\r\n  {\r\n    return delegateCall(_token);\r\n  }\r\n\r\n  /************  CORE ADMIN  ************/\r\n  function removeProxyInternal(address _token)\r\n    internal override returns (bool)\r\n  {\r\n    super.removeProxyInternal(_token);\r\n    delete tokens[_token];\r\n    return true;\r\n  }\r\n\r\n  function defineToken(\r\n    address _token,\r\n    uint256 _delegateId,\r\n    string calldata _name,\r\n    string calldata _symbol,\r\n    uint256 _decimals)\r\n    override external onlyCoreOp returns (bool)\r\n  {\r\n    require(_token != ALL_PROXIES, \"TC01\");\r\n    defineProxy(_token, _delegateId);\r\n    TokenData storage tokenData = tokens[_token];\r\n    tokenData.name = _name;\r\n    tokenData.symbol = _symbol;\r\n    tokenData.decimals = _decimals;\r\n\r\n    emit TokenDefined(_token, _name, _symbol, _decimals);\r\n    return true;\r\n  }\r\n\r\n  function defineOracle(\r\n    IUserRegistry _userRegistry,\r\n    IRatesProvider _ratesProvider,\r\n    address _currency)\r\n    override external onlyCoreOp returns (bool)\r\n  {\r\n    userRegistry_ = _userRegistry;\r\n    ratesProvider_ = _ratesProvider;\r\n    currency_ = _currency;\r\n\r\n    emit OracleDefined(userRegistry_, _ratesProvider, _currency);\r\n    return true;\r\n  }\r\n\r\n  function defineTokenDelegate(\r\n    uint256 _delegateId,\r\n    address _delegate,\r\n    uint256[] calldata _auditConfigurations) override external onlyCoreOp returns (bool)\r\n  {\r\n    require(_delegate == address(0) ||\r\n      ITokenDelegate(_delegate).checkConfigurations(_auditConfigurations), \"TC03\");\r\n\r\n    defineDelegateInternal(_delegateId, _delegate);\r\n    if(_delegate != address(0)) {\r\n      delegatesConfigurations_[_delegateId] = _auditConfigurations;\r\n      emit TokenDelegateDefined(_delegateId, _delegate, _auditConfigurations);\r\n    } else {\r\n      delete delegatesConfigurations_[_delegateId];\r\n      emit TokenDelegateRemoved(_delegateId);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function defineAuditConfiguration(\r\n    uint256 _configurationId,\r\n    uint256 _scopeId,\r\n    AuditTriggerMode _mode,\r\n    uint256[] calldata _senderKeys,\r\n    uint256[] calldata _receiverKeys,\r\n    IRatesProvider _ratesProvider,\r\n    address _currency) override external onlyCoreOp returns (bool)\r\n  {\r\n    // Mark permanently the core audit storage with the currency to be used with\r\n    AuditStorage storage auditStorage = audits[address(this)][_scopeId];\r\n    if(auditStorage.currency == address(0)) {\r\n      auditStorage.currency = _currency;\r\n    } else {\r\n      require(auditStorage.currency == _currency, \"TC04\");\r\n    }\r\n\r\n    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\r\n    auditConfiguration_.scopeId = _scopeId;\r\n    auditConfiguration_.senderKeys = _senderKeys;\r\n    auditConfiguration_.receiverKeys = _receiverKeys;\r\n    auditConfiguration_.ratesProvider = _ratesProvider;\r\n    auditConfiguration_.triggers[ANY_ADDRESSES][ANY_ADDRESSES] = _mode;\r\n\r\n    emit AuditConfigurationDefined(\r\n      _configurationId,\r\n      _scopeId,\r\n      _mode,\r\n      _senderKeys,\r\n      _receiverKeys,\r\n      _ratesProvider,\r\n      _currency);\r\n    return true;\r\n  }\r\n\r\n  function removeAudits(address _scope, uint256 _scopeId)\r\n    override external onlyCoreOp returns (bool)\r\n  {\r\n    delete audits[_scope][_scopeId];\r\n    emit AuditsRemoved(_scope, _scopeId);\r\n    return true;\r\n  }\r\n\r\n  function defineAuditTriggers(\r\n    uint256 _configurationId,\r\n    address[] calldata _senders,\r\n    address[] calldata _receivers,\r\n    AuditTriggerMode[] calldata _modes) override external onlyCoreOp returns (bool)\r\n  {\r\n    require(_senders.length == _receivers.length && _senders.length == _modes.length, \"TC05\");\r\n\r\n    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\r\n    for(uint256 i=0; i < _senders.length; i++) {\r\n      auditConfiguration_.triggers[_senders[i]][_receivers[i]] = _modes[i];\r\n    }\r\n\r\n    emit AuditTriggersDefined(_configurationId, _senders, _receivers, _modes);\r\n    return true;\r\n  }\r\n\r\n  function isSelfManaged(address _owner)\r\n    override external view returns (bool)\r\n  {\r\n    return selfManaged[_owner];\r\n  }\r\n\r\n  function manageSelf(bool _active)\r\n    override external returns (bool)\r\n  {\r\n    selfManaged[msg.sender] = _active;\r\n    emit SelfManaged(msg.sender, _active);\r\n  }\r\n}\r\n\r\n// File: contracts/TokenProxy.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Token proxy\r\n * @dev Token proxy default implementation\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\ncontract TokenProxy is ITokenProxy, OperableProxy {\r\n\r\n  // solhint-disable-next-line no-empty-blocks\r\n  constructor(address _core) public OperableProxy(_core) { }\r\n\r\n  function name() override public view returns (string memory) {\r\n    return TokenCore(core).tokenName();\r\n  }\r\n\r\n  function symbol() override public view returns (string memory) {\r\n    return TokenCore(core).tokenSymbol();\r\n  }\r\n\r\n  function decimals() override public view returns (uint256) {\r\n    return staticCallUint256();\r\n  }\r\n\r\n  function totalSupply() override public view returns (uint256) {\r\n    return staticCallUint256();\r\n  }\r\n\r\n  function balanceOf(address) override public view returns (uint256) {\r\n    return staticCallUint256();\r\n  }\r\n\r\n  function allowance(address, address)\r\n    override public view returns (uint256)\r\n  {\r\n    return staticCallUint256();\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) override public returns (bool status)\r\n  {\r\n    return TokenCore(core).transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    override public returns (bool status)\r\n  {\r\n    return TokenCore(core).transferFrom(msg.sender, _from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    override public returns (bool status)\r\n  {\r\n    return TokenCore(core).approve(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint256 _addedValue)\r\n    override public returns (bool status)\r\n  {\r\n    return TokenCore(core).increaseApproval(msg.sender, _spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint256 _subtractedValue)\r\n    override public returns (bool status)\r\n  {\r\n    return TokenCore(core).decreaseApproval(msg.sender, _spender, _subtractedValue);\r\n  }\r\n\r\n  function canTransfer(address, address, uint256)\r\n    override public view returns (uint256)\r\n  {\r\n    return staticCallUint256();\r\n  }\r\n\r\n  function emitTransfer(address _from, address _to, uint256 _value)\r\n    override public onlyCore returns (bool)\r\n  {\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function emitApproval(address _owner, address _spender, uint256 _value)\r\n    override public onlyCore returns (bool)\r\n  {\r\n    emit Approval(_owner, _spender, _value);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/MintableDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title MintableDelegate\r\n * @dev MintableDelegate contract\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * MT01: Transfer events must be generated\r\n * MT02: Token is already minted\r\n * MT03: Parameters must be same length\r\n */\r\nabstract contract MintableDelegate is TokenStorage {\r\n\r\n  modifier canMint(address _token) {\r\n    require(!tokens[_token].mintingFinished, \"MT02\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to burn tokens\r\n   * @param _amount The amount of tokens to burn.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function burn(address _token, uint256 _amount)\r\n    public returns (bool)\r\n  {\r\n    TokenData storage token = tokens[_token];\r\n    token.totalSupply = token.totalSupply.sub(_amount);\r\n    token.balances[msg.sender] = token.balances[msg.sender].sub(_amount);\r\n    token.allTimeBurned = token.allTimeBurned.add(_amount);\r\n\r\n    require(\r\n      TokenProxy(_token).emitTransfer(msg.sender, address(0), _amount),\r\n      \"MT01\");\r\n    emit Burned(_token, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint all tokens at once\r\n   * @param _recipients The addresses that will receive the minted tokens.\r\n   * @param _amounts The amounts of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _token, address[] memory _recipients, uint256[] memory _amounts)\r\n    public canMint(_token) returns (bool)\r\n  {\r\n    require(_recipients.length == _amounts.length, \"MT03\");\r\n\r\n    bool result = true;\r\n    for (uint256 i=0; i < _recipients.length; i++) {\r\n      result = result && mintInternal(_token, _recipients[i], _amounts[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting(address _token)\r\n    public canMint(_token) returns (bool)\r\n  {\r\n    tokens[_token].mintingFinished = true;\r\n    emit MintFinished(_token);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens internal\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mintInternal(address _token, address _to, uint256 _amount)\r\n    virtual internal canMint(_token) returns (bool)\r\n  {\r\n    TokenData storage token = tokens[_token];\r\n    token.totalSupply = token.totalSupply.add(_amount);\r\n    token.balances[_to] = token.balances[_to].add(_amount);\r\n    token.allTimeMinted = token.allTimeMinted.add(_amount);\r\n\r\n    require(\r\n      TokenProxy(_token).emitTransfer(address(0), _to, _amount),\r\n      \"MT01\");\r\n    emit Minted(_token, _amount);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/STransferData.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title STransferData\r\n * @dev STransferData structure\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n**/\r\n\r\nstruct STransferData {\r\n  address token;\r\n  address caller;\r\n  address sender;\r\n  address receiver;\r\n\r\n  uint256 senderId;\r\n  uint256[] senderKeys;\r\n  bool senderFetched;\r\n\r\n  uint256 receiverId;\r\n  uint256[] receiverKeys;\r\n  bool receiverFetched;\r\n\r\n  uint256 value;\r\n  uint256 convertedValue;\r\n}\r\n\r\n// File: contracts/delegate/BaseTokenDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Base Token Delegate\r\n * @dev Base Token Delegate\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * TD01: Recipient must not be null or be a reserved address\r\n * TD02: Not enougth tokens\r\n * TD03: Transfer event must be generated\r\n * TD04: Allowance limit reached\r\n */\r\ncontract BaseTokenDelegate is ITokenDelegate, TokenStorage {\r\n\r\n  function decimals() virtual override public view returns (uint256) {\r\n    return tokens[msg.sender].decimals;\r\n  }\r\n\r\n  function totalSupply() virtual override public view returns (uint256) {\r\n    return tokens[msg.sender].totalSupply;\r\n  }\r\n\r\n  function balanceOf(address _owner) virtual override public view returns (uint256) {\r\n    return tokens[msg.sender].balances[_owner];\r\n  }\r\n\r\n  function allowance(address _owner, address _spender)\r\n    virtual override public view returns (uint256)\r\n  {\r\n    return tokens[msg.sender].allowances[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transfer function\r\n   */\r\n  function transfer(address _sender, address _receiver, uint256 _value)\r\n    virtual override public returns (bool)\r\n  {\r\n    return transferInternal(\r\n      transferData(msg.sender, address(0), _sender, _receiver, _value));\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden transferFrom function\r\n   */\r\n  function transferFrom(\r\n    address _caller, address _sender, address _receiver, uint256 _value)\r\n    virtual override public returns (bool)\r\n  {\r\n    return transferInternal(\r\n      transferData(msg.sender, _caller, _sender, _receiver, _value));\r\n  }\r\n\r\n  /**\r\n   * @dev can transfer\r\n   */\r\n  function canTransfer(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _value) virtual override public view returns (TransferCode)\r\n  {\r\n    return canTransferInternal(\r\n      transferData(msg.sender, address(0), _sender, _receiver, _value));\r\n  }\r\n\r\n  /**\r\n   * @dev approve\r\n   */\r\n  function approve(address _sender, address _spender, uint256 _value)\r\n    virtual override public returns (bool)\r\n  {\r\n    TokenData storage token = tokens[msg.sender];\r\n    token.allowances[_sender][_spender] = _value;\r\n    require(\r\n      TokenProxy(msg.sender).emitApproval(_sender, _spender, _value),\r\n      \"TD03\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev increase approval\r\n   */\r\n  function increaseApproval(address _sender, address _spender, uint _addedValue)\r\n    virtual override public returns (bool)\r\n  {\r\n    TokenData storage token = tokens[msg.sender];\r\n    token.allowances[_sender][_spender] = (\r\n      token.allowances[_sender][_spender].add(_addedValue));\r\n    require(\r\n      TokenProxy(msg.sender).emitApproval(_sender, _spender, token.allowances[_sender][_spender]),\r\n      \"TD03\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev decrease approval\r\n   */\r\n  function decreaseApproval(address _sender, address _spender, uint _subtractedValue)\r\n    virtual override public returns (bool)\r\n  {\r\n    TokenData storage token = tokens[msg.sender];\r\n    uint oldValue = token.allowances[_sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      token.allowances[_sender][_spender] = 0;\r\n    } else {\r\n      token.allowances[_sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    require(\r\n      TokenProxy(msg.sender).emitApproval(_sender, _spender, token.allowances[_sender][_spender]),\r\n      \"TD03\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev check configuration\r\n   **/\r\n  function checkConfigurations(uint256[] memory) virtual override public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev transfer\r\n   */\r\n  function transferInternal(STransferData memory _transferData)\r\n    virtual internal returns (bool)\r\n  {\r\n    TokenData storage token = tokens[_transferData.token];\r\n    address caller = _transferData.caller;\r\n    address sender = _transferData.sender;\r\n    address receiver = _transferData.receiver;\r\n    uint256 value = _transferData.value;\r\n\r\n    require(receiver != address(0) || receiver != ANY_ADDRESSES, \"TD01\");\r\n    require(value <= token.balances[sender], \"TD02\");\r\n\r\n    if (caller != address(0)\r\n      && (selfManaged[sender]\r\n        || !hasProxyPrivilege(caller, _transferData.token, msg.sig)))\r\n    {\r\n      require(value <= token.allowances[sender][caller], \"TD04\");\r\n      token.allowances[sender][caller] = token.allowances[sender][caller].sub(value);\r\n    }\r\n\r\n    token.balances[sender] = token.balances[sender].sub(value);\r\n    token.balances[receiver] = token.balances[receiver].add(value);\r\n    require(\r\n      TokenProxy(msg.sender).emitTransfer(sender, receiver, value),\r\n      \"TD03\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev can transfer\r\n   */\r\n  function canTransferInternal(STransferData memory _transferData)\r\n    virtual internal view returns (TransferCode)\r\n  {\r\n    TokenData storage token = tokens[_transferData.token];\r\n    address sender = _transferData.sender;\r\n    address receiver = _transferData.receiver;\r\n    uint256 value = _transferData.value;\r\n\r\n    if (sender == address(0)) {\r\n      return TransferCode.INVALID_SENDER;\r\n    }\r\n\r\n    if (receiver == address(0)) {\r\n      return TransferCode.NO_RECIPIENT;\r\n    }\r\n\r\n    if (value > token.balances[sender]) {\r\n      return TransferCode.INSUFFICIENT_TOKENS;\r\n    }\r\n\r\n    return TransferCode.OK;\r\n  }\r\n\r\n  /**\r\n   * @dev transferData\r\n   */\r\n  function transferData(\r\n    address _token, address _caller,\r\n    address _sender, address _receiver, uint256 _value)\r\n    internal pure returns (STransferData memory)\r\n  {\r\n    uint256[] memory emptyArray = new uint256[](1);\r\n    return STransferData(\r\n        _token,\r\n        _caller,\r\n        _sender,\r\n        _receiver,\r\n        0,\r\n        emptyArray,\r\n        false,\r\n        0,\r\n        emptyArray,\r\n        false,\r\n        _value,\r\n        0\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/RuleEngineDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title RuleEngineDelegate\r\n * @dev RuleEngineDelegate contract\r\n * TokenRuleEngine is a token that will apply\r\n * rules restricting transferability\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n **/\r\nabstract contract RuleEngineDelegate is TokenStorage {\r\n\r\n  /**\r\n   * @dev Define rules to the token\r\n   */\r\n  function defineRules(address _token, IRule[] memory _rules)\r\n    public returns (bool)\r\n  {\r\n    tokens[_token].rules = _rules;\r\n    emit RulesDefined(_token, _rules);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the rules are valid\r\n   */\r\n  function areTransferRulesValid(STransferData memory _transferData)\r\n    internal view returns (bool)\r\n  {\r\n    IRule[] memory rules_ = tokens[_transferData.token].rules;\r\n    for (uint256 i = 0; i < rules_.length; i++) {\r\n      if (!rules_[i].isTransferValid(_transferData.sender, _transferData.receiver, _transferData.value)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/MintableTokenDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Token Delegate\r\n * @dev Token Delegate\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n */\r\ncontract MintableTokenDelegate is RuleEngineDelegate, MintableDelegate, BaseTokenDelegate {\r\n}\r\n\r\n// File: contracts/delegate/SeizableDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SeizableDelegate\r\n * @dev Token which allows owner to seize accounts\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * ST01: Transfer events must be generated\r\n * ST02: Operator cannot seize itself\r\n*/\r\nabstract contract SeizableDelegate is TokenStorage {\r\n\r\n  /**\r\n   * @dev called by the owner to seize value from the account\r\n   */\r\n  function seize(\r\n    address _token,\r\n    address _account,\r\n    uint256 _amount) public returns (bool)\r\n  {\r\n    require(_account != msg.sender, \"ST02\");\r\n    TokenData storage token = tokens[_token];\r\n\r\n    token.balances[_account] = token.balances[_account].sub(_amount);\r\n    token.balances[msg.sender] = token.balances[msg.sender].add(_amount);\r\n    token.allTimeSeized = token.allTimeSeized.add(_amount);\r\n\r\n    require(\r\n      TokenProxy(_token).emitTransfer(_account, msg.sender, _amount),\r\n      \"ST01\");\r\n    emit Seize(_token, _account, _amount);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/FreezableDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FreezableDelegate\r\n * @dev FreezableDelegate contract\r\n * This rule allow a legal authority to enforce a freeze of assets.\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * FTD01: The address is frozen\r\n */\r\nabstract contract FreezableDelegate is TokenStorage {\r\n\r\n  /**\r\n   * @dev allow owner to freeze several addresses\r\n   * @param _until allows to auto unlock if the frozen time is known initially.\r\n   * otherwise infinity can be used\r\n   */\r\n  function freezeManyAddresses(\r\n    address _token,\r\n    address[] memory _addresses,\r\n    uint256 _until) public returns (bool)\r\n  {\r\n    mapping(address => uint256) storage frozenUntils = tokens[_token].frozenUntils;\r\n    for (uint256 i = 0; i < _addresses.length; i++) {\r\n      frozenUntils[_addresses[i]] = _until;\r\n      emit Freeze(_addresses[i], _until);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev isFrozen\r\n   */\r\n  function isFrozen(STransferData memory _transferData) internal view returns (bool) {\r\n    mapping(address => uint256) storage frozenUntils = tokens[_transferData.token].frozenUntils;\r\n    // solhint-disable-next-line not-rely-on-time\r\n    uint256 currentTime = now;\r\n    return currentTime < frozenUntils[_transferData.caller]\r\n      || currentTime < frozenUntils[_transferData.sender]\r\n      || currentTime < frozenUntils[_transferData.receiver];\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/LockableDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title LockableDelegate\r\n * @dev LockableDelegate contract\r\n * This rule allows to lock assets for a period of time\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * LD01: locks must be valid proxies\r\n * LD02: startAt must be before or equal to endAt\r\n */\r\nabstract contract LockableDelegate is TokenStorage {\r\n\r\n  /**\r\n   * @dev define token lock\r\n   */\r\n  function defineTokenLocks(address _token, address[] memory _locks) public returns (bool)\r\n  {\r\n    for(uint256 i=0; i < _locks.length; i++) {\r\n      require(delegates[proxyDelegateIds[_locks[i]]] != address(0), \"LD01\");\r\n    }\r\n\r\n    tokens[_token].locks = _locks;\r\n    emit TokenLocksDefined(_token, _locks);\r\n  }\r\n\r\n  /**\r\n   * @dev define lock\r\n   */\r\n  function defineLock(\r\n    address _lock,\r\n    address _sender,\r\n    address _receiver,\r\n    uint64 _startAt,\r\n    uint64 _endAt) public returns (bool)\r\n  {\r\n    require(_startAt <= _endAt, \"LD02\");\r\n    locks[_lock][_sender][_receiver] = LockData(_startAt, _endAt);\r\n    emit LockDefined(_lock, _sender, _receiver, _startAt, _endAt);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev isLocked\r\n   */\r\n  function isLocked(STransferData memory _transferData)\r\n    internal view returns (bool isLocked_)\r\n  {\r\n    address[] storage lockAddresses = tokens[_transferData.token].locks;\r\n\r\n    // solhint-disable-next-line not-rely-on-time\r\n    uint256 currentTime = now;\r\n\r\n    for (uint256 i=0; i < lockAddresses.length && !isLocked_; i++) {\r\n      address lockAddress = lockAddresses[i];\r\n      LockData storage lockData = locks[lockAddress][_transferData.sender][_transferData.receiver];\r\n\r\n      if (lockData.endAt < currentTime) {\r\n        LockData storage senderLockData = locks[lockAddress][_transferData.sender][ANY_ADDRESSES];\r\n        LockData storage receiverLockData = locks[lockAddress][ANY_ADDRESSES][_transferData.receiver];\r\n\r\n        if (senderLockData.endAt >= currentTime && receiverLockData.endAt >= currentTime) {\r\n          isLocked_ =\r\n            (currentTime < senderLockData.endAt && currentTime >= senderLockData.startAt) ||\r\n            (currentTime < receiverLockData.endAt && currentTime >= receiverLockData.startAt);\r\n          continue;\r\n        }\r\n\r\n        lockData = senderLockData;\r\n        if (lockData.endAt < currentTime) {\r\n          lockData = receiverLockData;\r\n        }\r\n      }\r\n\r\n      if (lockData.endAt < currentTime) {\r\n        lockData = locks[lockAddress][ANY_ADDRESSES][ANY_ADDRESSES];\r\n      }\r\n\r\n      isLocked_ =\r\n        (currentTime < lockData.endAt && currentTime >= lockData.startAt);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/STransferAuditData.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title STransferAuditData\r\n * @dev SAuditData structure\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n**/\r\n\r\nstruct STransferAuditData {\r\n  uint256 auditConfigurationId;\r\n  uint256 scopeId;\r\n  address currency;\r\n  IRatesProvider ratesProvider;\r\n\r\n  bool senderAuditRequired;\r\n  bool receiverAuditRequired;\r\n}\r\n\r\n// File: contracts/delegate/OracleEnrichedDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OracleEnrichedDelegate\r\n * @dev OracleEnrichedDelegate contract\r\n * @dev Enriched the transfer with oracle's informations\r\n * @dev needed for the delegate processing\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n */\r\ncontract OracleEnrichedDelegate is TokenStorage {\r\n\r\n  uint256 internal constant SENDER_LIMIT_ID = 0;\r\n  uint256 internal constant RECEIVER_LIMIT_ID = 0;\r\n\r\n  /**\r\n   * @dev fetchSenderUserId\r\n   */\r\n  function fetchSenderUserId(STransferData memory _transferData) internal view\r\n  {\r\n    if (!_transferData.senderFetched) {\r\n      _transferData.senderId = userRegistry_.validUserId(_transferData.sender);\r\n      _transferData.senderFetched = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev fetchSenderUser\r\n   */\r\n  function fetchSenderUser(STransferData memory _transferData,\r\n     STransferAuditData memory _transferAuditData) internal view\r\n  {\r\n    if (!_transferData.senderFetched) {\r\n      (_transferData.senderId, _transferData.senderKeys) =\r\n        userRegistry_.validUser(_transferData.sender,\r\n        auditConfigurations[_transferAuditData.auditConfigurationId].senderKeys);\r\n      _transferData.senderFetched = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev fetchReceiverUserId\r\n   */\r\n  function fetchReceiverUserId(STransferData memory _transferData) internal view\r\n  {\r\n    if (!_transferData.receiverFetched) {\r\n      _transferData.receiverId = userRegistry_.validUserId(_transferData.receiver);\r\n      _transferData.receiverFetched = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev fetchReceiverUser\r\n   */\r\n  function fetchReceiverUser(STransferData memory _transferData,\r\n    STransferAuditData memory _transferAuditData) internal view\r\n  {\r\n    if (!_transferData.receiverFetched) {\r\n      (_transferData.receiverId, _transferData.receiverKeys) =\r\n        userRegistry_.validUser(_transferData.receiver,\r\n        auditConfigurations[_transferAuditData.auditConfigurationId].receiverKeys);\r\n      _transferData.receiverFetched = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev fetchConvertedValue\r\n   * @dev warning: a converted value of 0 should be considered invalid\r\n   * @dev it is left to the code calling this function to handle this case\r\n   */\r\n  function fetchConvertedValue(STransferData memory _transferData,\r\n    STransferAuditData memory _transferAuditData) internal view\r\n  {\r\n    if (_transferData.convertedValue == 0 && _transferData.value != 0) {\r\n      address currencyFrom = _transferData.token;\r\n      _transferData.convertedValue = (\r\n         _transferAuditData.currency != address(0) && currencyFrom != _transferAuditData.currency\r\n      ) ? _transferAuditData.ratesProvider.convert(_transferData.value,\r\n            bytes32(bytes20(currencyFrom)), bytes32(bytes20(_transferAuditData.currency))\r\n          ) : _transferData.value;\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/AuditableDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title AuditableDelegate\r\n * @dev Auditable delegate contract\r\n * Auditable provides transaction data which can be used\r\n * in other smart contracts\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * AT01: Configuration and User Registry must have the same currency\r\n **/\r\ncontract AuditableDelegate is OracleEnrichedDelegate {\r\n\r\n  uint256 internal constant AUDIT_CONFIGURATION_LIMITABLE_TRANSFERABILITY = 0;\r\n\r\n  /**\r\n   * @dev prepareAuditInternal\r\n   */\r\n  function prepareAuditInternal(STransferData memory _transferData)\r\n    internal view returns (STransferAuditData memory)\r\n  {\r\n    uint256 configurationId = delegatesConfigurations_[proxyDelegateIds[_transferData.token]\r\n      ][AUDIT_CONFIGURATION_LIMITABLE_TRANSFERABILITY];\r\n    AuditConfiguration storage configuration = auditConfigurations[configurationId];\r\n\r\n    AuditTriggerMode mode = configuration.triggers[_transferData.sender][_transferData.receiver];\r\n    if (mode == AuditTriggerMode.UNDEFINED) {\r\n      mode = configuration.triggers[_transferData.sender][ANY_ADDRESSES];\r\n    }\r\n    if (mode == AuditTriggerMode.UNDEFINED) {\r\n      mode = configuration.triggers[ANY_ADDRESSES][_transferData.receiver];\r\n    }\r\n    if (mode == AuditTriggerMode.UNDEFINED) {\r\n      mode = configuration.triggers[ANY_ADDRESSES][ANY_ADDRESSES];\r\n    }\r\n\r\n    return STransferAuditData(\r\n      configurationId,\r\n      configuration.scopeId,\r\n      audits[address(this)][configuration.scopeId].currency,\r\n      configuration.ratesProvider,\r\n      (mode == AuditTriggerMode.BOTH || mode == AuditTriggerMode.SENDER_ONLY),\r\n      (mode == AuditTriggerMode.BOTH || mode == AuditTriggerMode.RECEIVER_ONLY)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Update audit data\r\n   */\r\n  function updateAllAuditsInternal(STransferData memory _transferData,\r\n    STransferAuditData memory _transferAuditData) internal returns (bool)\r\n  {\r\n    uint64 transactionAt = currentTime();\r\n    audits[_transferData.token][uint256(Scope.DEFAULT)\r\n      ].addressData[_transferData.sender].lastTransactionAt = transactionAt;\r\n    audits[_transferData.token][uint256(Scope.DEFAULT)\r\n      ].addressData[_transferData.sender].lastTransactionAt = transactionAt;\r\n\r\n    if (_transferAuditData.senderAuditRequired || _transferAuditData.receiverAuditRequired) {\r\n      fetchConvertedValue(_transferData, _transferAuditData);\r\n\r\n      if (_transferAuditData.senderAuditRequired) {\r\n        fetchSenderUser(_transferData, _transferAuditData);\r\n        if (_transferData.senderId != 0) {\r\n          AuditData storage senderAudit =\r\n            audits[address(this)][_transferAuditData.scopeId].userData[_transferData.senderId];\r\n          if (senderAudit.createdAt == 0) {\r\n            senderAudit.createdAt = transactionAt;\r\n          }\r\n\r\n          senderAudit.cumulatedEmission =\r\n            senderAudit.cumulatedEmission.add(_transferData.convertedValue);\r\n        }\r\n      }\r\n\r\n      if (_transferAuditData.receiverAuditRequired) {\r\n        fetchReceiverUser(_transferData, _transferAuditData);\r\n        if (_transferData.receiverId != 0) {\r\n          AuditData storage receiverAudit =\r\n            audits[address(this)][_transferAuditData.scopeId].userData[_transferData.receiverId];\r\n          if (receiverAudit.createdAt == 0) {\r\n            receiverAudit.createdAt = transactionAt;\r\n          }\r\n          receiverAudit.cumulatedReception =\r\n            receiverAudit.cumulatedReception.add(_transferData.convertedValue);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/KYCOnlyTransferabilityDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title KYCOnlyTransferabilityDelegate\r\n * @dev KYCOnlyTransferabilityDelegate contract\r\n * This rule allow a legal authority to limite the transferability.\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * LR01: The transfer constraints must remain valid\r\n*/\r\ncontract KYCOnlyTransferabilityDelegate is AuditableDelegate {\r\n\r\n  /**\r\n   * @dev hasTransferValidUsers\r\n   */\r\n  function hasTransferValidUsers(STransferData memory _transferData,\r\n    STransferAuditData memory _transferAuditData) internal view returns (TransferCode code)\r\n  {\r\n    if (_transferAuditData.senderAuditRequired) {\r\n      fetchSenderUserId(_transferData);\r\n      if (_transferData.senderId == 0) {\r\n        return TransferCode.NON_REGISTRED_SENDER;\r\n      }\r\n    }\r\n\r\n    if (_transferAuditData.receiverAuditRequired) {\r\n      fetchReceiverUserId(_transferData);\r\n      if (_transferData.receiverId == 0) {\r\n        return TransferCode.NON_REGISTRED_RECEIVER;\r\n      }\r\n    }\r\n    return TransferCode.OK;\r\n  }\r\n}\r\n\r\n// File: contracts/delegate/KYCOnlyTokenDelegate.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title KYCOnly Token Delegate\r\n * @dev KYCOnly Token Delegate\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messagesa\r\n * KOT01: The token must not be locked\r\n * KOT02: The addresses must not be frozen\r\n * KOT03: The transfer rules must be valid\r\n * KOT04: The sender or receiver are not valid\r\n */\r\ncontract KYCOnlyTokenDelegate is\r\n  KYCOnlyTransferabilityDelegate,\r\n  RuleEngineDelegate,\r\n  SeizableDelegate,\r\n  FreezableDelegate,\r\n  LockableDelegate,\r\n  MintableTokenDelegate\r\n{\r\n\r\n  uint256 internal constant AUDIT_CONFIG_REQUIREMENTS = 1; // 1- Transfer Limits\r\n\r\n  /**\r\n   * @dev check config requirements\r\n   **/\r\n  function checkConfigurations(uint256[] memory _auditConfigurationIds)\r\n    override public returns (bool)\r\n  {\r\n    return (_auditConfigurationIds.length >= AUDIT_CONFIG_REQUIREMENTS);\r\n  }\r\n\r\n /**\r\n   * @dev transfer\r\n   */\r\n  function transferInternal(STransferData memory _transferData)\r\n    override internal returns (bool)\r\n  {\r\n    require(!isLocked(_transferData), \"KOT01\");\r\n    require(!isFrozen(_transferData), \"KOT02\");\r\n    require(areTransferRulesValid(_transferData), \"KOT03\");\r\n\r\n    STransferAuditData memory _transferAuditData =\r\n      prepareAuditInternal(_transferData);\r\n    require(hasTransferValidUsers(_transferData, _transferAuditData) == TransferCode.OK, \"KOT04\");\r\n\r\n    return super.transferInternal(_transferData);\r\n  }\r\n\r\n  /**\r\n   * @dev can transfer\r\n   */\r\n  function canTransferInternal(STransferData memory _transferData)\r\n    override internal view returns (TransferCode code)\r\n  {\r\n    if (isLocked(_transferData)) {\r\n      return TransferCode.LOCKED;\r\n    }\r\n    if (isFrozen(_transferData)) {\r\n      return TransferCode.FROZEN;\r\n    }\r\n    if (!areTransferRulesValid(_transferData)) {\r\n      return TransferCode.RULE;\r\n    }\r\n\r\n    STransferAuditData memory _transferAuditData =\r\n      prepareAuditInternal(_transferData);\r\n    code = hasTransferValidUsers(_transferData, _transferAuditData);\r\n\r\n    return (code == TransferCode.OK) ?\r\n      super.canTransferInternal(_transferData) : code;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"configurationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scopeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum ITokenStorage.AuditTriggerMode\",\"name\":\"mode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"senderKeys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"receiverKeys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"contract IRatesProvider\",\"name\":\"ratesProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"AuditConfigurationDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"configurationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"enum ITokenStorage.AuditTriggerMode[]\",\"name\":\"modes\",\"type\":\"uint8[]\"}],\"name\":\"AuditTriggersDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"scope\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scopeId\",\"type\":\"uint256\"}],\"name\":\"AuditsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claim\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAt\",\"type\":\"uint256\"}],\"name\":\"ClaimDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"until\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lock\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endAt\",\"type\":\"uint256\"}],\"name\":\"LockDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"createdAt\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lastTransactionAt\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulatedEmission\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulatedReception\",\"type\":\"uint256\"}],\"name\":\"LogAuditData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auditConfigurationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scopeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRatesProvider\",\"name\":\"ratesProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"senderAuditRequired\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"receiverAuditRequired\",\"type\":\"bool\"}],\"name\":\"LogTransferAuditData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"senderKeys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"senderFetched\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiverId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"receiverKeys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"receiverFetched\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"convertedValue\",\"type\":\"uint256\"}],\"name\":\"LogTransferData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IUserRegistry\",\"name\":\"userRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRatesProvider\",\"name\":\"ratesProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"OracleDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegateId\",\"type\":\"uint256\"}],\"name\":\"ProxyDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCore\",\"type\":\"address\"}],\"name\":\"ProxyMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ProxyOperatorAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ProxyOperatorRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"RoleDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRule[]\",\"name\":\"rules\",\"type\":\"address[]\"}],\"name\":\"RulesDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Seize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"SelfManaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"TokenDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"delegateId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"configurations\",\"type\":\"uint256[]\"}],\"name\":\"TokenDelegateDefined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"delegateId\",\"type\":\"uint256\"}],\"name\":\"TokenDelegateRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"locks\",\"type\":\"address[]\"}],\"name\":\"TokenLocksDefined\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"canTransfer\",\"outputs\":[{\"internalType\":\"enum ITokenStorage.TransferCode\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_auditConfigurationIds\",\"type\":\"uint256[]\"}],\"name\":\"checkConfigurations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"coreRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_startAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_endAt\",\"type\":\"uint64\"}],\"name\":\"defineLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IRule[]\",\"name\":\"_rules\",\"type\":\"address[]\"}],\"name\":\"defineRules\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_locks\",\"type\":\"address[]\"}],\"name\":\"defineTokenLocks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delegateId\",\"type\":\"uint256\"}],\"name\":\"delegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"finishMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_until\",\"type\":\"uint256\"}],\"name\":\"freezeManyAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_privilege\",\"type\":\"bytes4\"}],\"name\":\"hasCorePrivilege\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_privilege\",\"type\":\"bytes4\"}],\"name\":\"hasProxyPrivilege\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"proxyDelegateId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"proxyRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_role\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"_privilege\",\"type\":\"bytes4\"}],\"name\":\"roleHasPrivilege\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_role\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"_privilege\",\"type\":\"bytes4\"}],\"name\":\"rolePrivilege\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KYCOnlyTokenDelegate","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a667c53643c2a6ba42901bf274488cdc9a83fbd75dd1fefdb78fb8f6ff615388"}]}