{"status":"1","message":"OK","result":[{"SourceCode":"// File: browser/SafeERC20.sol\r\n\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must equal true).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n\r\n        require(address(token).isContract());\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success);\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            require(abi.decode(returndata, (bool)));\r\n        }\r\n    }\r\n}\r\n\r\n// File: browser/Address.sol\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: browser/SafeMath.sol\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: browser/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: browser/TokenVesting.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting {\r\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\r\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\r\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\r\n    // cliff period of a year and a duration of four years, are safe to use.\r\n    // solhint-disable not-rely-on-time\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event TokensReleased(uint256 mTokensAmount, uint256 sTokensAmount);\r\n\r\n    // beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\r\n    uint256 private _cliff;\r\n    uint256 private _start;\r\n    uint256 private _duration;\r\n\r\n    address public mainToken;\r\n    \r\n    address public secondaryToken;\r\n    \r\n    uint256 public multiplier;\r\n    \r\n    address public factory;\r\n    \r\n    uint256 public totalVestingAmount;\r\n    \r\n    mapping (address => uint256) private _released;\r\n    \r\n    \r\n    constructor (address beneficiary, uint256 amount, uint256 start, uint256 cliffDuration, uint256 duration, address _mainToken, address _secondaryToken, uint256 _multipier) public {\r\n        require(beneficiary != address(0));\r\n        require(cliffDuration <= duration);\r\n        require(duration > 0);\r\n        require(start.add(duration) > block.timestamp);\r\n\r\n        _beneficiary = beneficiary;\r\n        _duration = duration;\r\n        _cliff = start.add(cliffDuration);\r\n        _start = start;\r\n        mainToken = _mainToken;\r\n        secondaryToken = _secondaryToken;\r\n        multiplier = _multipier;\r\n        factory = msg.sender;\r\n        totalVestingAmount = amount;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the cliff time of the token vesting.\r\n     */\r\n    function cliff() public view returns (uint256) {\r\n        return _cliff;\r\n    }\r\n\r\n    /**\r\n     * @return the start time of the token vesting.\r\n     */\r\n    function start() public view returns (uint256) {\r\n        return _start;\r\n    }\r\n\r\n    /**\r\n     * @return the duration of the token vesting.\r\n     */\r\n    function duration() public view returns (uint256) {\r\n        return _duration;\r\n    }\r\n    \r\n    /**\r\n     * @return the amount of the token released.\r\n     */\r\n    function available() public view returns (uint256) {\r\n        return totalVestingAmount.sub(_released[mainToken]);\r\n    }\r\n    \r\n    /**\r\n     * @return the amount of the token released.\r\n     */\r\n    function released(address token) public view returns (uint256) {\r\n        return (_released[token]);\r\n    }\r\n    \r\n    /**\r\n     * @return the amount of secondary tokens that has been accrued but hasn't been released yet.\r\n     */\r\n    function _accruedAmount() public view returns (uint256) {\r\n        return _releasableAmount().mul(multiplier).div(10000);\r\n    }\r\n  \r\n \r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary.\r\n     */\r\n    function release() public {\r\n        uint256 unreleased = _releasableAmount();\r\n        \r\n\r\n        require(unreleased > 0);\r\n        \r\n        uint256 sTokensToRelease = unreleased.mul(multiplier).div(10000);\r\n\r\n        _released[mainToken] = _released[mainToken].add(unreleased);\r\n        _released[secondaryToken] = _released[secondaryToken].add(sTokensToRelease);\r\n\r\n\r\n        IERC20(mainToken).safeTransfer(_beneficiary, unreleased);\r\n        IERC20(secondaryToken).safeTransferFrom(factory, _beneficiary, sTokensToRelease);\r\n\r\n        emit TokensReleased(unreleased, sTokensToRelease);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     */\r\n    function _releasableAmount() private view returns (uint256) {\r\n        return _vestedAmount().sub(_released[mainToken]);\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     */\r\n    function _vestedAmount() private view returns (uint256) {\r\n       \r\n\r\n        if (block.timestamp < _cliff) {\r\n            return 0;\r\n        } else if (block.timestamp >= _start.add(_duration)) {\r\n            return totalVestingAmount;\r\n        } else {\r\n            return totalVestingAmount.mul(block.timestamp.sub(_start)).div(_duration);\r\n        }\r\n    }\r\n}\r\n// File: browser/VestingFactory.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract VestingFactory {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    uint256 public cliffTime;\r\n    \r\n    uint256 public duration;\r\n    \r\n    uint256 public multipier;\r\n    \r\n    address public mainToken;\r\n    \r\n    address public secondaryToken;\r\n    \r\n    \r\n    uint256 public maxVesting;\r\n    \r\n    uint256 public currentVestedAmount;\r\n    \r\n    mapping(address => address[]) public userVsVesting;\r\n    \r\n    event Vested(address indexed user, address indexed vestingContract);\r\n    \r\n    constructor(\r\n        uint256 _cliffTime,\r\n        uint256 _duration,\r\n        uint256 _multipier,\r\n        address _mainToken,\r\n        address _secondaryToken,\r\n        uint256 _maxVesting\r\n    )\r\n        public\r\n    {\r\n        cliffTime = _cliffTime;\r\n        duration = _duration;\r\n        multipier = _multipier;\r\n        mainToken = _mainToken;\r\n        secondaryToken = _secondaryToken;\r\n        maxVesting = _maxVesting;\r\n    }\r\n    \r\n    function vest(uint256 amount) external {\r\n        \r\n        require(currentVestedAmount.add(amount) <= maxVesting, \"Breaching max vesting limit\");\r\n        currentVestedAmount = currentVestedAmount.add(amount);\r\n        uint256 cliff = 0;\r\n        \r\n        if (cliffTime > block.timestamp) {\r\n            cliff = cliffTime.sub(block.timestamp);\r\n        }\r\n        \r\n        \r\n        TokenVesting vesting = new TokenVesting(\r\n            msg.sender,\r\n            amount,\r\n            block.timestamp,\r\n            cliff,\r\n            duration,\r\n            mainToken,\r\n            secondaryToken,\r\n            multipier\r\n        );\r\n        \r\n        userVsVesting[msg.sender].push(address(vesting));\r\n        IERC20(mainToken).safeTransferFrom(msg.sender, address(vesting), amount);\r\n        IERC20(secondaryToken).safeApprove(address(vesting), amount.mul(multipier).div(10000));\r\n        \r\n        emit Vested(msg.sender, address(vesting));\r\n        \r\n    }\r\n    \r\n    function userContracts(address user) public view returns(address[] memory){\r\n        return userVsVesting[user];\r\n    }\r\n    \r\n    function accruedAmount(address user) public view returns(uint256){\r\n        uint256 amount = 0;\r\n        for(uint i=0; i<userVsVesting[user].length;i++){\r\n           amount = amount.add(TokenVesting(userVsVesting[user][i])._accruedAmount()); \r\n        }\r\n        return amount;\r\n    }\r\n    \r\n    function mainTokenBalance(address user) public view returns(uint256){\r\n        uint256 amount = 0;\r\n        for(uint i=0; i<userVsVesting[user].length;i++){\r\n           amount = amount.add(TokenVesting(userVsVesting[user][i]).available()); \r\n        }\r\n        return amount;\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cliffTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multipier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mainToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_secondaryToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxVesting\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingContract\",\"type\":\"address\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"accruedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cliffTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentVestedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"mainTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multipier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondaryToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userVsVesting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VestingFactory","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005ffecba80000000000000000000000000000000000000000000000000000000000001c200000000000000000000000000000000000000000000000000000000000002710000000000000000000000000913d8adf7ce6986a8cbfee5a54725d9eea4f0729000000000000000000000000346e2c8925d3bdc406181340eb7485d6460557440000000000000000000000000000000000000000000000008ac7230489e80000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ea6ceacbb0fcae24a7cced0a171d95976c998e3dad3259b314091755a4914259"}]}