{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2020-11-13\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n/**\r\n * Rekeep3r.network \r\n * A standard implementation of kp3rv1 protocol\r\n * Mint function capped both for normal mint and for addKPRCredit\r\n * Original functionality still in place\r\n */\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"add: +\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"sub: -\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"mul: *\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"div: /\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b) internal pure returns (uint) {\r\n        return mod(a, b, \"mod: %\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IReKeep3rV1 {\r\n    function addVotes(address voter, uint amount) external;\r\n    function removeVotes(address voter, uint amount) external;\r\n    function addKPRCredit(address job, uint amount) external;\r\n    function approveLiquidity(address liquidity) external;\r\n    function revokeLiquidity(address liquidity) external;\r\n    function addJob(address job) external;\r\n    function removeJob(address job) external;\r\n    function setKeep3rHelper(address _kprh) external;\r\n    function setGovernance(address _governance) external;\r\n    function acceptGovernance() external;\r\n    function dispute(address keeper) external;\r\n    function slash(address bonded, address keeper, uint amount) external;\r\n    function revoke(address keeper) external;\r\n    function resolve(address keeper) external;\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ncontract ProxyReKeep3r {\r\n    using SafeMath for uint;\r\n    /// @notice The name of this contract\r\n    string public constant name = \"ProxyReKeep3r\";\r\n\r\n    // max cap for owner\r\n    uint256 constant maxCap = 100000000000000000000000;\r\n\r\n    /// @notice The address of the governance token\r\n    IReKeep3rV1 immutable public REKP3R;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n        \r\n    bytes32 public immutable DOMAINSEPARATOR;\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n\r\n    address public guardian;\r\n    address public pendingGuardian;\r\n    \r\n    function setGuardian(address _guardian) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::setGuardian: !guardian\");\r\n        pendingGuardian = _guardian;\r\n    }\r\n    \r\n    function acceptGuardianship() external {\r\n        require(msg.sender == pendingGuardian, \"ProxyReKeep3r::setGuardian: !pendingGuardian\");\r\n        guardian = pendingGuardian;\r\n    }\r\n    \r\n    function addVotes(address voter, uint amount) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::addVotes: !guardian\");\r\n        REKP3R.addVotes(voter, amount);\r\n    }\r\n\r\n    function removeVotes(address voter, uint amount) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::removeVotes: !guardian\");\r\n        REKP3R.removeVotes(voter, amount);\r\n    }\r\n\r\n    function addKPRCredit(address job, uint amount) external {\r\n        require(msg.sender == guardian && REKP3R.totalSupply().add(amount) <= maxCap, \"ProxyReKeep3r::addKPRCredit: !guardian or mint maxCap limit\");\r\n        REKP3R.addKPRCredit(job, amount);\r\n    }\r\n\r\n    function approveLiquidity(address liquidity) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::approveLiquidity: !guardian\");\r\n        REKP3R.approveLiquidity(liquidity);\r\n    }\r\n\r\n    function revokeLiquidity(address liquidity) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::revokeLiquidity: !guardian\");\r\n        REKP3R.revokeLiquidity(liquidity);\r\n    }\r\n\r\n    function addJob(address job) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::addJob: !guardian\");\r\n        REKP3R.addJob(job);\r\n    }\r\n\r\n    function removeJob(address job) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::removeJob: !guardian\");\r\n        REKP3R.removeJob(job);\r\n    }\r\n\r\n    function setKeep3rHelper(address kprh) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::setKeep3rHelper: !guardian\");\r\n        REKP3R.setKeep3rHelper(kprh);\r\n    }\r\n\r\n    function setGovernance(address _governance) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::setGovernance: !guardian\");\r\n        REKP3R.setGovernance(_governance);\r\n    }\r\n\r\n    function acceptGovernance() external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::acceptGovernance: !guardian\");\r\n        REKP3R.acceptGovernance();\r\n    }\r\n\r\n    function dispute(address keeper) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::dispute: !guardian\");\r\n        REKP3R.dispute(keeper);\r\n    }\r\n\r\n    function slash(address bonded, address keeper, uint amount) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::slash: !guardian\");\r\n        REKP3R.slash(bonded, keeper, amount);\r\n    }\r\n\r\n    function revoke(address keeper) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::revoke: !guardian\");\r\n        REKP3R.revoke(keeper);\r\n    }\r\n\r\n    function resolve(address keeper) external {\r\n        require(msg.sender == guardian, \"ProxyReKeep3r::resolve: !guardian\");\r\n        REKP3R.resolve(keeper);\r\n    }\r\n\r\n    constructor(address token_) public {\r\n        guardian = msg.sender;\r\n        REKP3R = IReKeep3rV1(token_);\r\n        DOMAINSEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DOMAINSEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REKP3R\",\"outputs\":[{\"internalType\":\"contract IReKeep3rV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGuardianship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"job\",\"type\":\"address\"}],\"name\":\"addJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"job\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addKPRCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"}],\"name\":\"approveLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"job\",\"type\":\"address\"}],\"name\":\"removeJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"resolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity\",\"type\":\"address\"}],\"name\":\"revokeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"kprh\",\"type\":\"address\"}],\"name\":\"setKeep3rHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bonded\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ProxyReKeep3r","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000affdff710ff020f26c36c5117df549739296926b","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a5a704580718399898b74f64c8c0598b7f665ca0e19c14c359f4b13a34bd2abd"}]}