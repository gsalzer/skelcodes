{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/libraries/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/Math.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IHiposwapV1Callee.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IHiposwapV1Callee {\r\n    function hiposwapV1Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/interfaces/IHiposwapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IHiposwapV2Pair {\r\n    \r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint reserve0, uint reserve1);\r\n    event _Maker(address indexed sender, address token, uint amount, uint time);\r\n\r\n    \r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function currentPoolId0() external view returns (uint);\r\n    function currentPoolId1() external view returns (uint);\r\n    function getMakerPool0(uint poolId) external view returns (uint _balance, uint _swapOut, uint _swapIn);\r\n    function getMakerPool1(uint poolId) external view returns (uint _balance, uint _swapOut, uint _swapIn);\r\n    function getReserves() external view returns (uint reserve0, uint reserve1);\r\n    function getBalance() external view returns (uint _balance0, uint _balance1);\r\n    function getMaker(address mkAddress) external view returns (uint,address,uint,uint);\r\n    function getFees() external view returns (uint _fee0, uint _fee1);\r\n    function getFeeAdmins() external view returns (uint _feeAdmin0, uint _feeAdmin1);\r\n    function getAvgTimes() external view returns (uint _avgTime0, uint _avgTime1);\r\n    function transferFeeAdmin(address to) external;\r\n    function getFeePercents() external view returns (uint _feeAdminPercent, uint _feePercent, uint _totalPercent);\r\n    function setFeePercents(uint _feeAdminPercent, uint _feePercent, uint _totalPercent) external;\r\n    function getRemainPercent() external view returns (uint);\r\n    function getTotalPercent() external view returns (uint);\r\n    \r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function order(address to) external returns (address token, uint amount);\r\n    function retrieve(uint amount0, uint amount1, address sender, address to) external returns (uint, uint);\r\n    function getAmountA(address to, uint amountB) external view returns(uint amountA, uint _amountB, uint rewardsB, uint remainA);\r\n    function getAmountB(address to, uint amountA) external view returns(uint _amountA, uint amountB, uint rewardsB, uint remainA);\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/GSN/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Ownable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/HiposwapV2Pair.sol\r\n\r\npragma solidity =0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract HiposwapV2Pair is IHiposwapV2Pair, Ownable {\r\n    using SafeMath  for uint;\r\n    \r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    \r\n    address public override factory;\r\n    address public override token0;\r\n    address public override token1;\r\n    \r\n    uint private fee0;\r\n    uint private fee1;\r\n    \r\n    uint private feeAdmin0;\r\n    uint private feeAdmin1;\r\n    \r\n    uint public totalWeightTime0;\r\n    uint public totalWeightTime1;\r\n    \r\n    uint public totalTokens0;\r\n    uint public totalTokens1;\r\n    \r\n    uint private avgTime0;\r\n    uint private avgTime1;\r\n    \r\n    uint private reserve0;\r\n    uint private reserve1;\r\n    \r\n    uint private feeAdminPercent = 5;\r\n    uint private feePercent = 10;\r\n    uint private totalPercent = 10000;\r\n    \r\n    struct MakerPool {\r\n        uint balance; // remain tokenA\r\n        uint swapOut; // swapped tokenA\r\n        uint swapIn; // received tokenB\r\n        uint createTime;\r\n    }\r\n    \r\n    MakerPool[] public makerPools0;\r\n    MakerPool[] public makerPools1;\r\n    \r\n    uint public override currentPoolId0;\r\n    uint public override currentPoolId1;\r\n    \r\n    struct Maker {\r\n        uint poolId;\r\n        address token;\r\n        uint amount;\r\n        uint time;\r\n    }\r\n    mapping(address => Maker) private makers;\r\n    \r\n    uint public constant MINIMUM_SWITCH_POOL_TIME = 30 minutes;\r\n    \r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'HiposwapV2Pair: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    function getReserves() public override view returns (uint _reserve0, uint _reserve1) {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n    }\r\n    \r\n    function getFees() public override view returns (uint _fee0, uint _fee1) {\r\n        _fee0 = fee0;\r\n        _fee1 = fee1;\r\n    }\r\n    \r\n    function getFeeAdmins() public override view returns (uint _feeAdmin0, uint _feeAdmin1) {\r\n        _feeAdmin0 = feeAdmin0;\r\n        _feeAdmin1 = feeAdmin1;\r\n    }\r\n    \r\n    function getAvgTimes() public override view returns (uint _avgTime0, uint _avgTime1) {\r\n        _avgTime0 = avgTime0;\r\n        _avgTime1 = avgTime1;\r\n    }\r\n    \r\n    function getFeePercents() public override view returns (uint _feeAdminPercent, uint _feePercent, uint _totalPercent) {\r\n        _feeAdminPercent = feeAdminPercent;\r\n        _feePercent = feePercent;\r\n        _totalPercent = totalPercent;\r\n    }\r\n    \r\n    function getRemainPercent() public override view returns (uint) {\r\n        return totalPercent.sub(feeAdminPercent).sub(feePercent);\r\n    }\r\n    \r\n    function getTotalPercent() external override view returns (uint) {\r\n        return totalPercent;\r\n    }\r\n    \r\n    function setFeePercents(uint _feeAdminPercent, uint _feePercent, uint _totalPercent) public override onlyOwner {\r\n        require(_feeAdminPercent.add(_feePercent) < _totalPercent, \"HiposwapV2Pair: INVALID_PARAM\");\r\n        feeAdminPercent = _feeAdminPercent;\r\n        feePercent = _feePercent;\r\n        totalPercent = _totalPercent;\r\n    }\r\n    \r\n    function getBalance() public override view returns (uint _balance0, uint _balance1) {\r\n        _balance0 = IERC20(token0).balanceOf(address(this));\r\n        _balance1 = IERC20(token1).balanceOf(address(this));\r\n    }\r\n    \r\n    function getMaker(address mkAddress) public override view returns (uint,address,uint,uint) {\r\n        Maker memory m = makers[mkAddress];\r\n        return (m.poolId, m.token, m.amount, m.time);\r\n    }\r\n    \r\n    function getMakerPool0(uint poolId) public override view returns (uint _balance, uint _swapOut, uint _swapIn) {\r\n        return _getMakerPool(true, poolId);\r\n    }\r\n    \r\n    function getMakerPool1(uint poolId) public override view returns (uint _balance, uint _swapOut, uint _swapIn) {\r\n        return _getMakerPool(false, poolId);\r\n    }\r\n    \r\n    function _getMakerPool(bool left, uint poolId) private view returns (uint _balance, uint _swapOut, uint _swapIn) {\r\n        MakerPool[] memory mps = left ? makerPools0 : makerPools1;\r\n        if (mps.length > poolId) {\r\n            MakerPool memory mp = mps[poolId];\r\n            return (mp.balance, mp.swapOut, mp.swapIn);\r\n        }\r\n    }\r\n    \r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'HiposwapV2Pair: TRANSFER_FAILED');\r\n    }\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint reserve0, uint reserve1);\r\n    event _Maker(address indexed sender, address token, uint amount, uint time);\r\n    \r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) external override {\r\n        require(msg.sender == factory, 'HiposwapV2Pair: FORBIDDEN'); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n    \r\n    function checkMakerPool(bool left) private {\r\n        MakerPool[] storage mps = left ? makerPools0 : makerPools1;\r\n        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\r\n        if (mps.length > 0) {\r\n            MakerPool storage mp = mps[currentPoolId];\r\n            if (mp.swapOut > mp.balance.mul(9) && now > mp.createTime.add(MINIMUM_SWITCH_POOL_TIME)) {\r\n                mps.push(MakerPool(0, 0, 0, now));\r\n                if (left) {\r\n                    currentPoolId0 = currentPoolId0.add(1);\r\n                    mp.swapIn = mp.swapIn.add(fee1);\r\n                    fee1 = 0;\r\n                    totalWeightTime0 = 0;\r\n                    totalTokens0 = 0;\r\n                    avgTime0 = 0;\r\n                } else {\r\n                    currentPoolId1 = currentPoolId1.add(1);\r\n                    mp.swapIn = mp.swapIn.add(fee0);\r\n                    fee0 = 0;\r\n                    totalWeightTime1 = 0;\r\n                    totalTokens1 = 0;\r\n                    avgTime1 = 0;\r\n                }\r\n            }\r\n        } else {\r\n            mps.push(MakerPool(0, 0, 0, now));\r\n        }\r\n    }\r\n    \r\n    function addFee(bool left, uint fee, uint feeAdmin) private {\r\n        if (left) {\r\n            fee1 = fee1.add(fee);\r\n            feeAdmin1 = feeAdmin1.add(feeAdmin);\r\n        } else {\r\n            fee0 = fee0.add(fee);\r\n            feeAdmin0 = feeAdmin0.add(feeAdmin);\r\n        }\r\n    }\r\n    \r\n    \r\n    function checkAvgTime(bool left, uint time) private view returns (bool isChargeFee) {\r\n        if (left) {\r\n            if(avgTime0 > 0){\r\n                isChargeFee = now < time.add(avgTime0);\r\n            }\r\n        } else {\r\n            if(avgTime1 > 0){\r\n                isChargeFee = now < time.add(avgTime1);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function updateAvgTime(bool left, uint time, uint amount) private {\r\n        if(amount > 0 && now > time) {\r\n            uint weight = (now - time).mul(amount);\r\n            if (left) {\r\n                uint _totalWeightTime0 = totalWeightTime0 + weight;\r\n                if (_totalWeightTime0 >= totalWeightTime0) {\r\n                    totalWeightTime0 = _totalWeightTime0;\r\n                    totalTokens0 = totalTokens0.add(amount);\r\n                    avgTime0 = totalWeightTime0 / totalTokens0;\r\n                } else { // reset if overflow\r\n                    totalWeightTime0 = 0;\r\n                    totalTokens0 = 0;\r\n                }\r\n            } else {\r\n                uint _totalWeightTime1 = totalWeightTime1 + weight;\r\n                if (_totalWeightTime1 >= totalWeightTime1) {\r\n                    totalWeightTime1 = _totalWeightTime1;\r\n                    totalTokens1 = totalTokens1.add(amount);\r\n                    avgTime1 = totalWeightTime1 / totalTokens1;\r\n                } else { // reset if overflow\r\n                    totalWeightTime1 = 0;\r\n                    totalTokens1 = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function transferFeeAdmin(address to) external override onlyOwner{\r\n        require(feeAdmin0 > 0 || feeAdmin1 > 0, \"HiposwapV2Pair: EMPTY_ADMIN_FEES\");\r\n        if (feeAdmin0 > 0) {\r\n            _safeTransfer(token0, to, feeAdmin0);\r\n            feeAdmin0 = 0;\r\n        }\r\n        if (feeAdmin1 > 0) {\r\n            _safeTransfer(token1, to, feeAdmin1);\r\n            feeAdmin1 = 0;\r\n        }\r\n    }\r\n    \r\n    function order(address to) external override lock returns (address token, uint amount){\r\n        uint amount0 = IERC20(token0).balanceOf(address(this)).sub(reserve0);\r\n        uint amount1 = IERC20(token1).balanceOf(address(this)).sub(reserve1);\r\n        require((amount0 > 0 && amount1 == 0) || (amount0 == 0 && amount1 > 0), \"HiposwapV2Pair: INVALID_AMOUNT\");\r\n        bool left = amount0 > 0;\r\n        checkMakerPool(left);\r\n        Maker memory mk = makers[to];\r\n        if(mk.amount > 0) {\r\n            require(mk.token == token0 || mk.token == token1, \"HiposwapV2Pair: INVALID_TOKEN\");\r\n            bool _left = mk.token == token0;\r\n            uint _currentPoolId = _left ? currentPoolId0 : currentPoolId1;\r\n            require(_currentPoolId >= mk.poolId, \"HiposwapV2Pair: INVALID_POOL_ID\");\r\n            if(_currentPoolId > mk.poolId){\r\n                deal(to);\r\n                mk.amount = 0;\r\n            }else{\r\n                require(left == _left, \"HiposwapV2Pair: ONLY_ONE_MAKER_ALLOWED\");\r\n            }\r\n        }\r\n        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\r\n        amount = left ? amount0 : amount1;\r\n        token = left ? token0 : token1;\r\n        makers[to] = Maker(currentPoolId, token, mk.amount.add(amount), now);\r\n        emit _Maker(to, token, amount, now);\r\n        MakerPool storage mp = left ? makerPools0[currentPoolId] : makerPools1[currentPoolId];\r\n        mp.balance = mp.balance.add(amount);\r\n        (reserve0, reserve1) = getBalance();\r\n    }\r\n    \r\n    function deal(address to) public {\r\n        Maker storage mk = makers[to];\r\n        require(mk.token == token0 || mk.token == token1, \"HiposwapV2Pair: INVALID_TOKEN\");\r\n        bool left = mk.token == token0;\r\n        MakerPool storage mp = left ? makerPools0[mk.poolId] : makerPools1[mk.poolId];\r\n        (uint amountA, uint amountB) = (mk.amount, 0);\r\n        if(mp.swapIn > 0 && mp.swapOut > 0){\r\n            amountB = Math.min(mk.amount.mul(mp.swapIn) / mp.swapOut, mp.swapIn);\r\n            uint swapOut = amountB.mul(mp.swapOut) / mp.swapIn;\r\n            amountA = amountA.sub(swapOut);\r\n            mp.swapIn = mp.swapIn.sub(amountB);\r\n            mp.swapOut = mp.swapOut.sub(swapOut);\r\n        }\r\n        if (amountA > mp.balance) {\r\n            // if swapOut, swapIn, balance = 3, 2, 0; mk.amount = 1; then amountB = 0, amountA = 1;\r\n            uint dust = amountA.sub(mp.balance);\r\n            addFee(!left, dust, 0);\r\n            mp.swapOut = mp.swapOut.sub(dust);\r\n            amountA = mp.balance;\r\n        }\r\n        mp.balance = mp.balance.sub(amountA);\r\n        (uint amount0, uint amount1) = left ? (amountA, amountB) : (amountB, amountA);\r\n        if(amount0 > 0){\r\n            _safeTransfer(token0, to, amount0);\r\n            reserve0 = IERC20(token0).balanceOf(address(this));\r\n        }\r\n        if(amount1 > 0){\r\n            _safeTransfer(token1, to, amount1);\r\n            reserve1 = IERC20(token1).balanceOf(address(this));\r\n        }\r\n        delete makers[to];\r\n    }\r\n    \r\n    function retrieve(uint amount0, uint amount1, address sender, address to) external override lock onlyOwner returns (uint, uint){\r\n        require(amount0 > 0 || amount1 > 0, \"HiposwapV2Pair: INVALID_AMOUNT\");\r\n        Maker storage mk = makers[sender];\r\n        require(mk.token == token0 || mk.token == token1, \"HiposwapV2Pair: INVALID_TOKEN\");\r\n        bool left = mk.token == token0;\r\n        \r\n        MakerPool storage mp = left ? makerPools0[mk.poolId] : makerPools1[mk.poolId];\r\n        (uint amountA, uint amountB) = left ? (amount0, amount1) : (amount1, amount0);\r\n        \r\n        bool isChargeFee = mk.poolId == (left ? currentPoolId0 : currentPoolId1) && checkAvgTime(left, mk.time);\r\n        uint amountOrigin = mk.amount;\r\n        if (amountA > 0) {\r\n            uint amountAMax = Math.min(mk.amount, mp.balance);\r\n            uint remain = getRemainPercent();\r\n            amountAMax = isChargeFee ? amountAMax.mul(remain) / totalPercent : amountAMax; // 9985/10000\r\n            require(amountA <= amountAMax, \"HiposwapV2Pair: INSUFFICIENT_AMOUNT\");\r\n            if(isChargeFee){\r\n                uint fee = amountA.mul(feePercent) / remain; // 10/9985\r\n                uint feeAdmin = amountA.mul(feeAdminPercent) / remain; // = 5/9985\r\n                amountA = amountA.add(fee).add(feeAdmin);\r\n                addFee(!left, fee, feeAdmin);\r\n            }\r\n            mk.amount = mk.amount.sub(amountA);\r\n            mp.balance = mp.balance.sub(amountA);\r\n        }\r\n        \r\n        if (amountB > 0) {\r\n            require(mp.swapIn > 0 && mp.swapOut > 0, \"HiposwapV2Pair: INSUFFICIENT_SWAP_BALANCE\");\r\n            \r\n            uint amountBMax = Math.min(mp.swapIn, mk.amount.mul(mp.swapIn) / mp.swapOut);\r\n            amountBMax = isChargeFee ? amountBMax.mul(getRemainPercent()) / totalPercent : amountBMax; // 9985/10000\r\n            require(amountB <= amountBMax, \"HiposwapV2Pair: INSUFFICIENT_SWAP_AMOUNT\");\r\n            \r\n            if(isChargeFee){\r\n                uint fee = amountB.mul(feePercent) / getRemainPercent(); // 10/9985\r\n                uint feeAdmin = amountB.mul(feeAdminPercent) / getRemainPercent(); // = 5/9985\r\n                amountB = amountB.add(fee).add(feeAdmin);\r\n                addFee(left, fee, feeAdmin);\r\n            }else if (mk.poolId == (left ? currentPoolId0 : currentPoolId1)) {\r\n                uint rewards = amountB.mul(feePercent) / totalPercent; // 10/10000\r\n                if(left){\r\n                    if (rewards > fee1) {\r\n                        rewards = fee1;\r\n                    }\r\n                    {\r\n                    uint _amount1 = amount1;\r\n                    amount1 = _amount1.add(rewards);\r\n                    fee1 = fee1.sub(rewards);\r\n                    }\r\n                }else{\r\n                    if (rewards > fee0) {\r\n                        rewards = fee0;\r\n                    }\r\n                    {// avoid stack too deep\r\n                    uint _amount0 = amount0;\r\n                    amount0 = _amount0.add(rewards);\r\n                    fee0 = fee0.sub(rewards);\r\n                    }\r\n                }\r\n            }\r\n            uint _amountA = amountB.mul(mp.swapOut) / mp.swapIn;\r\n            mp.swapIn = mp.swapIn.sub(amountB);\r\n            mk.amount = mk.amount.sub(_amountA);\r\n            mp.swapOut = mp.swapOut.sub(_amountA);\r\n        }\r\n        \r\n        updateAvgTime(left, mk.time, amountOrigin.sub(mk.amount));\r\n        \r\n        if (mk.amount == 0) {\r\n            delete makers[sender];\r\n        }\r\n        if(amount0 > 0){\r\n            _safeTransfer(token0, to, amount0);\r\n            reserve0 = IERC20(token0).balanceOf(address(this));\r\n        }\r\n        if(amount1 > 0){\r\n            _safeTransfer(token1, to, amount1);\r\n            reserve1 = IERC20(token1).balanceOf(address(this));\r\n        }\r\n        return (amount0, amount1);\r\n    }\r\n    \r\n    function getMakerAndPool(address to) private view returns (Maker memory mk, MakerPool memory mp){\r\n        mk = makers[to];\r\n        require(mk.token == token0 || mk.token == token1, \"HiposwapV2Pair: INVALID_TOKEN\");\r\n        bool left = mk.token == token0;\r\n        uint poolId = mk.poolId;\r\n        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\r\n        require(poolId >= 0 && poolId <= currentPoolId, \"HiposwapV2Pair: INVALID_POOL_ID\");\r\n        mp = left ? makerPools0[poolId] : makerPools1[poolId];\r\n    }\r\n    // amountB is exact\r\n    function getAmountA(address to, uint amountB) external override view returns(uint amountA, uint _amountB, uint rewardsB, uint remainA){\r\n        (Maker memory mk, MakerPool memory mp) = getMakerAndPool(to);\r\n        bool left = mk.token == token0;\r\n        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\r\n        bool isChargeFee = mk.poolId == currentPoolId && checkAvgTime(left, mk.time);\r\n        uint remain = getRemainPercent();\r\n        if(amountB > 0){\r\n            if(mp.swapIn > 0 && mp.swapOut > 0){\r\n                uint mkAmount = isChargeFee ? mk.amount.mul(remain) / totalPercent : mk.amount; // 9985/10000\r\n                uint swapIn = isChargeFee ? mp.swapIn.mul(remain) / totalPercent : mp.swapIn;\r\n                uint amountBMax = Math.min(amountB, Math.min(swapIn, mkAmount.mul(mp.swapIn) / mp.swapOut));\r\n                uint amountAMax = amountBMax.mul(mp.swapOut) / mp.swapIn;\r\n                amountAMax = isChargeFee ? amountAMax.mul(totalPercent) / remain : amountAMax;\r\n                mk.amount = mk.amount.sub(amountAMax);\r\n                _amountB = amountBMax;\r\n                if (!isChargeFee && mk.poolId == currentPoolId) {\r\n                    uint tmp = _amountB; // avoid stack too deep\r\n                    uint rewards = tmp.mul(feePercent) / totalPercent;\r\n                    if(left){\r\n                        if (rewards > fee1) {\r\n                            rewards = fee1;\r\n                        }\r\n                    }else{\r\n                        if (rewards > fee0) {\r\n                            rewards = fee0;\r\n                        }\r\n                    }\r\n                    rewardsB = rewards;\r\n                }\r\n            }\r\n        }\r\n        \r\n        amountA = Math.min(mk.amount, mp.balance);\r\n        remainA = mk.amount.sub(amountA);\r\n        amountA = isChargeFee ? amountA.mul(remain) / totalPercent : amountA;\r\n    }\r\n    // amountA is exact\r\n    function getAmountB(address to, uint amountA) external override view returns(uint _amountA, uint amountB, uint rewardsB, uint remainA){\r\n        (Maker memory mk, MakerPool memory mp) = getMakerAndPool(to);\r\n        bool left = mk.token == token0;\r\n        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\r\n        bool isChargeFee = mk.poolId == currentPoolId && checkAvgTime(left, mk.time);\r\n        uint remain = getRemainPercent();\r\n        if(amountA > 0){\r\n            uint mkAmount = isChargeFee ? mk.amount.mul(remain) / totalPercent : mk.amount;\r\n            uint mpBalance = isChargeFee ? mp.balance.mul(remain) / totalPercent : mp.balance;\r\n            _amountA = Math.min(Math.min(amountA, mkAmount), mpBalance);\r\n            if (_amountA == mkAmount) {\r\n                mk.amount = 0;\r\n            } else {\r\n                mk.amount = mk.amount.sub(isChargeFee ? _amountA.mul(totalPercent) / remain : _amountA);\r\n            }\r\n        }\r\n        if(mp.swapIn > 0 && mp.swapOut > 0){\r\n            amountB = Math.min(mp.swapIn, mk.amount.mul(mp.swapIn) / mp.swapOut);\r\n            mk.amount = mk.amount.sub(amountB.mul(mp.swapOut) / mp.swapIn);\r\n            if (isChargeFee) {\r\n                amountB = amountB.mul(remain) / totalPercent;\r\n            } else if (mk.poolId == currentPoolId) {\r\n                uint rewards = amountB.mul(feePercent) / totalPercent;\r\n                if(left){\r\n                    if (rewards > fee1) {\r\n                        rewards = fee1;\r\n                    }\r\n                }else{\r\n                    if (rewards > fee0) {\r\n                        rewards = fee0;\r\n                    }\r\n                }\r\n                rewardsB = rewards;\r\n            }\r\n        }\r\n        remainA = mk.amount;\r\n    }\r\n    \r\n    function _update(uint balance0, uint balance1) private {\r\n        require(balance0 <= uint(-1) && balance1 <= uint(-1), 'HiposwapV2Pair: OVERFLOW');\r\n        reserve0 = balance0;\r\n        reserve1 = balance1;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n    \r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\r\n        require(amount0Out > 0 || amount1Out > 0, 'HiposwapV2Pair: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        (uint _reserve0, uint _reserve1) = getReserves(); // gas savings\r\n        require(amount0Out <= _reserve0 && amount1Out <= _reserve1, 'HiposwapV2Pair: INSUFFICIENT_LIQUIDITY');\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        { // scope for _token{0,1}, avoids stack too deep errors\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        require(to != _token0 && to != _token1, 'HiposwapV2Pair: INVALID_TO');\r\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n        if (data.length > 0) IHiposwapV1Callee(to).hiposwapV1Call(msg.sender, amount0Out, amount1Out, data);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, 'HiposwapV2Pair: INSUFFICIENT_INPUT_AMOUNT');\r\n        \r\n        if (amount0In > 0) {\r\n            uint fee = amount0In.mul(feePercent) / totalPercent; //  = 10/10000\r\n            uint feeAdmin = amount0In.mul(feeAdminPercent) / totalPercent; // = 5/10000\r\n            uint swapIn = amount0In.sub(fee).sub(feeAdmin);\r\n            MakerPool storage mp = makerPools1[currentPoolId1];\r\n            mp.swapIn = mp.swapIn.add(swapIn);\r\n            mp.swapOut = mp.swapOut.add(amount1Out);\r\n            mp.balance = mp.balance.sub(amount1Out);\r\n            addFee(false, fee, feeAdmin);\r\n        }\r\n        if (amount1In >0) {\r\n            uint fee = amount1In.mul(feePercent) / totalPercent; //  = 10/10000\r\n            uint feeAdmin = amount1In.mul(feeAdminPercent) / totalPercent; // = 5/10000\r\n            uint swapIn = amount1In.sub(fee).sub(feeAdmin);\r\n            MakerPool storage mp = makerPools0[currentPoolId0];\r\n            mp.swapIn = mp.swapIn.add(swapIn);\r\n            mp.swapOut = mp.swapOut.add(amount0Out);\r\n            mp.balance = mp.balance.sub(amount0Out);\r\n            addFee(true, fee, feeAdmin);\r\n        }\r\n\r\n        _update(balance0, balance1);\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n    \r\n}\r\n\r\n// File: contracts/interfaces/IHiposwapV2Util.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\ninterface IHiposwapV2Util {\r\n    function pairCreationCode() external returns (bytes memory bytecode);\r\n}\r\n\r\n// File: contracts/HiposwapV2Util.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.6;\r\n\r\n\r\n\r\ncontract HiposwapV2Util is IHiposwapV2Util {\r\n    function pairCreationCode() external override returns (bytes memory bytecode){\r\n        bytecode = type(HiposwapV2Pair).creationCode;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"pairCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HiposwapV2Util","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c7e9be50bb4ffc531b9a4180cc4d54d28a30c5789decd285ef2522f4c1a73b21"}]}