{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n    // *\r\n    function mul(uint256 a,uint256 b) internal pure returns (uint256 c) {\r\n        if(a == 0){\r\n            return 0;\r\n        }\r\n        \r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    // /\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c){\r\n        assert(b > 0);\r\n        c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n    \r\n    // -\r\n    function sub(uint256 a,uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    // +\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c){\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract CommonConstants {\r\n    bytes4 constant internal ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\r\n    bytes4 constant internal ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\r\n}\r\n\r\n\r\n// ERC-165 identifier interface is 0x4e2312e0\r\ninterface ERC1155TokenReceiver{\r\n    function onERC1155Received(address _operator,address _from,uint256 _id,uint256 _value,bytes calldata _data) external returns(bytes4);\r\n    function onERC1155BatchReceived(address _operator,address _from,uint256[] calldata _ids,uint256[] calldata _values,bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC165 {\r\n    //Returns true if this contract implements the interface define by 'interfaceId'\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n//ERC-1155 Multi Token Standard\r\ncontract IERC1155 is IERC165 {\r\n    //Either 'TransferSingle' or 'TransferBatch' MUST emit when tokens are transferred,including zero value transfers as well as minting of buring\r\n    event TransferSingle(address indexed _operator,address indexed _from,address indexed _to,uint256 _id,uint256 _value);\r\n    \r\n    event TransferBatch(address indexed _operator,address indexed _from,address indexed _to,uint256[] _ids, uint256[] _values);\r\n    \r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    \r\n    // MUST emit when the URI is updated for a token ID\r\n    // URIs are defined in RFC 3986\r\n    // The URI MUST point a JSON file that conforms to the 'ERC-1155 Metadata URI JSON Schema'.\r\n    event URI(string _value,uint256 indexed _id);\r\n    \r\n    // Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n    function safeTransferFrom(address _from,address _to,uint256 _id,uint256 _value,bytes calldata _data) external;\r\n    \r\n    // Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n    function safeBatchTransferFrom(address _from,address _to,uint256[] calldata _ids,uint256[] calldata _values,bytes calldata _data) external;\r\n    \r\n    // Get the balance of an account's Tokens\r\n    function balanceOf(address _owner,uint256 _id) external view returns (uint256);\r\n    \r\n    // Get the balance of multiple account/token pairs\r\n    function balanceOfBatch(address[] calldata _owner,uint256[] calldata _ids) external view returns (uint256[] memory);\r\n    \r\n    // Enable or disable approval for a third party (\"operator\") to manager all of the caller's tokens\r\n    function setApprovalForAll(address _operator,bool _approved) external;\r\n    \r\n    //Queries the approval status of an operator for a given owner\r\n    function isApprovedForAll(address _owner,address _operator) external view returns (bool);    \r\n}\r\n\r\n// Implementation of the {IERC165} interface\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    \r\n    mapping(bytes4=>bool) private _supportedInterfaces;\r\n    \r\n    constructor() internal {\r\n        // Derived contract need only register support for their own interface\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n    \r\n    // Registers the contract as an implementer of the interface defined by 'interfaceId'\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff,\"ERC165:invalid interface id\");\r\n        _supportedInterfaces[interfaceId] == true;\r\n    }\r\n}\r\n\r\n// Collection of function related to the address type\r\nlibrary Address{\r\n    // Returns true if 'account' is a contract\r\n    function isContract(address account) internal view returns (bool) {\r\n         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    \r\n    //Converts an 'address' info 'address payable'\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    \r\n    //Replacement for Solidity's 'transfer':sends 'amount' wei to 'recipient',forwarding all available gas and reverting on erros;\r\n    function sendValue(address payable recipient,uint256 amount) internal {\r\n        require(address(this).balance >= amount,\"Address: insufficient balance\");\r\n        \r\n        (bool success,) = recipient.call.value(amount)(\"\");\r\n        require(success,\"Address: unable to send value,recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// A sample implementation of core ERC1155 function\r\ncontract ERC1155 is IERC1155,ERC165, CommonConstants{\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    // id=>(owner => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal balances;\r\n    \r\n    // owner => (operator => approved)\r\n    mapping (address => mapping(address => bool)) internal operatorApproval;\r\n    \r\n/////////////////////////////////////////// ERC165 //////////////////////////////////////////////\r\n     /*\r\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^\r\n        bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^\r\n        bytes4(keccak256(\"balanceOf(address,uint256)\")) ^\r\n        bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^\r\n        bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\r\n        bytes4(keccak256(\"isApprovedForAll(address,address)\"));\r\n    */\r\n    bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\r\n    \r\n/////////////////////////////////////////// CONSTRUCTOR //////////////////////////////////////////\r\n    constructor() public {\r\n        _registerInterface(INTERFACE_SIGNATURE_ERC1155);\r\n    }\r\n    \r\n/////////////////////////////////////////// ERC1155 //////////////////////////////////////////////\r\n\r\n    // Transfers '_value' amount of an '_id' from the '_from' address to the '_to' address specified\r\n    function safeTransferFrom(address _from, address _to,uint256 _id,uint256 _value,bytes calldata _data) external {\r\n        require(_to != address(0x0),\"Address: _to must be non-zero\");\r\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true,\"Approval: need operator approval for 3rd party transfers\");\r\n        \r\n        // SafeMath will throw with insuficient funds _from or if _id is not valid(balance will be zero)\r\n        balances[_id][_from] = balances[_id][_from].sub(_value);\r\n        balances[_id][_to] = _value.add(balances[_id][_to]);\r\n        \r\n        // MUST emit event\r\n        emit TransferSingle(msg.sender,_from,_to,_id,_value);\r\n        \r\n        if(_to.isContract()){\r\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\r\n        }\r\n    }\r\n    \r\n    // Transfers '_values' amount(s) of '_ids' from the '_from' address to the '_to' address specified\r\n    function safeBatchTransferFrom(address _from,address _to,uint256[] calldata _ids,uint256[] calldata _values,bytes calldata _data) external {\r\n        //MUST throw on error\r\n        require(_to != address(0x0),\"Address: _to must be non-zero\");\r\n        require(_ids.length == _values.length,\"_ids and _values array length must match\");\r\n        require(_from == msg.sender || operatorApproval[_from][msg.sender] == true,\"Approval: need operator approval for 3rd party transfers\");\r\n        \r\n        for (uint256 i = 0; i < _ids.length; ++ i){\r\n            uint256 id = _ids[i];\r\n            uint256 value = _values[i];\r\n            \r\n            //SafeMath will throw with insuficient funds _from or if _id is not valid(valance will be zero)\r\n            balances[id][_from] = balances[id][_from].sub(value);\r\n            balances[id][_to] = value.add(balances[id][_to]);\r\n        }\r\n        \r\n        \r\n        emit TransferBatch(msg.sender,_from,_to,_ids,_values);\r\n        \r\n        if(_to.isContract()){\r\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\r\n        }\r\n    }\r\n    \r\n    // Get the balance of an account's tokens\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\r\n        return balances[_id][_owner];\r\n    }\r\n\r\n    // Get the balance of multiple account/token pairs\r\n    function balanceOfBatch(address[] calldata _owners,uint256[] calldata _ids) external view returns (uint256[] memory) {\r\n        require(_owners.length == _ids.length,\"_owners and _ids array length must match\");\r\n        \r\n        uint256[] memory balances_ = new uint256[](_owners.length);\r\n        \r\n        for (uint256 i = 0; i < _owners.length; ++ i){\r\n            balances_[i] = balances[_ids[i]][_owners[i]];\r\n        }\r\n        return balances_;\r\n    }\r\n\r\n    // Enable or disable approval for a third party(\"operator\") to manage all of the caller's token\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        operatorApproval[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender,_operator,_approved);\r\n    }\r\n    \r\n    // Queries the approval status of an operator for a given owner\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return operatorApproval[_owner][_operator];\r\n    }\r\n    \r\n/////////////////////////////////////////// Internal //////////////////////////////////////////////\r\n    function _doSafeTransferAcceptanceCheck(address _operator,address _from,address _to,uint256 _id,uint256 _value,bytes memory _data) internal {\r\n        require(ERC1155TokenReceiver(_to).onERC1155Received(_operator,_from,_id,_value,_data) == ERC1155_ACCEPTED,\"contract returned an unknown value from onERC1155Received\");\r\n    }\r\n    \r\n    function _doSafeBatchTransferAcceptanceCheck(address _operator,address _from,address _to, uint256[] memory _ids,uint256[] memory _values,bytes memory _data) internal {\r\n        require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator,_from,_ids,_values,_data) == ERC1155_BATCH_ACCEPTED,\"contract returned an unknown value from onERC1155BatchReceived\");\r\n    }\r\n    \r\n}\r\n\r\n\r\nlibrary UintLibrary {\r\n    function toString(uint256 _i) internal pure returns (string memory) {\r\n        if(_i == 0){\r\n            return \"0\";\r\n        }\r\n        \r\n        uint j = _i;\r\n        uint len;\r\n        while(j != 0) {\r\n            len ++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len -1;\r\n        \r\n        while(_i != 0){\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        \r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n\r\nlibrary StringLibrary {\r\n    using UintLibrary for uint256;\r\n    \r\n    function append(string memory _a,string memory _b) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory bab = new bytes(_ba.length + _bb.length);\r\n        \r\n        uint k = 0;\r\n        for(uint i = 0;i < _ba.length; i ++)bab[k++] = _ba[i];\r\n        for(uint i = 0;i < _bb.length; i ++)bab[k++] = _bb[i];\r\n        return string(bab);\r\n    }\r\n    \r\n    function append(string memory _a,string memory _b,string memory _c) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory babc = new bytes(_ba.length + _bb.length + _bc.length);\r\n        \r\n        uint k = 0;\r\n        for(uint i = 0; i < _ba.length; i ++) babc[k ++] = _ba[i];\r\n        for(uint i = 0; i < _bb.length; i ++) babc[k ++] = _bb[i];\r\n        for(uint i = 0; i < _bc.length; i ++) babc[k ++] = _bc[i];\r\n        \r\n        return string(babc);\r\n    }\r\n    \r\n    function recover(string memory message, uint8 v, bytes32 r,bytes32 s) internal pure returns (address) {\r\n        bytes memory msgBytes = bytes(message);\r\n        bytes memory fullMessage = concat(\r\n            bytes(\"\\x19Ethereum Signed Message:\\n\"),\r\n            bytes(msgBytes.length.toString()),\r\n            msgBytes,\r\n            new bytes(0), new bytes(0), new bytes(0),new bytes(0)\r\n        );\r\n        \r\n        return ecrecover(keccak256(fullMessage),v,r,s);\r\n    }\r\n    \r\n    // Merging multiple strings\r\n    function concat(bytes memory _ba,bytes memory _bb,bytes memory _bc,bytes memory _bd,bytes memory _be, bytes memory _bf,bytes memory _bg) internal pure returns(bytes memory) {\r\n        bytes memory resultBytes = new bytes(_ba.length + _bb.length + _bc.length + _bd.length + _be.length + _bf.length + _bg.length);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i ++) resultBytes[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i ++) resultBytes[k++] = _bb[i];\r\n        for (uint i = 0; i < _bc.length; i ++) resultBytes[k++] = _bc[i];\r\n        for (uint i = 0; i < _bd.length; i ++) resultBytes[k++] = _bd[i];\r\n        for (uint i = 0; i < _be.length; i ++) resultBytes[k++] = _be[i];\r\n        for (uint i = 0; i < _bf.length; i ++) resultBytes[k++] = _bf[i];\r\n        for (uint i = 0; i < _bg.length; i ++) resultBytes[k++] = _bg[i];\r\n\r\n        return resultBytes;   \r\n    }\r\n}\r\n\r\ncontract HasContractURI is ERC165 {\r\n    string public contractURI;\r\n    \r\n     /*\r\n     * bytes4(keccak256('contractURI()')) == 0xe8a3d485\r\n     */\r\n    bytes4 private constant _INTERFACT_ID_CONTRACT_URI = 0xe8a3d485;\r\n    \r\n    constructor(string memory _contractURI) public {\r\n        contractURI = _contractURI;\r\n        _registerInterface(_INTERFACT_ID_CONTRACT_URI);\r\n    }\r\n    \r\n    // Internal function to set the contract URI\r\n    function _setContractURI(string memory _contractURI) internal {\r\n        contractURI = _contractURI;\r\n    }\r\n}\r\n\r\ncontract HasTokenURI {\r\n    using StringLibrary for string;\r\n    \r\n    // Token URI prefix \r\n    string public tokenURIPrefix;\r\n    \r\n    // Optional mapping for token URIs;\r\n    mapping(uint256 => string) private _tokenURIs;\r\n    \r\n    constructor(string memory _tokenURIPrefix) public {\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n    }\r\n    \r\n    // Returns an URI for a given token ID\r\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\r\n        return tokenURIPrefix.append(_tokenURIs[tokenId]);\r\n    }\r\n    \r\n    // Internal function to set the token URI for a given token.Reverts if the token ID does not exist.\r\n    function _setTokenURI(uint256 tokenId,string memory uri) internal {\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n    \r\n    // Internal function to set the token URI prefix\r\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n    }\r\n    \r\n    function _clearTokenURI(uint256 tokenId) internal {\r\n        if(bytes(_tokenURIs[tokenId]).length != 0){\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n// Provider information about the current execution context, including the sender of the transaction and its data.\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying an instance of this contract,which \r\n    // should be used via inheritance.\r\n    constructor() internal {}\r\n    \r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    \r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// Contract module which providers a basic access control mechanism, where there is an account (an owner) that\r\n// can be granted exclusive access to specific functions.\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    // Initializes the contract setting the deployer as the initial owner;\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    \r\n    // Returns the address of the current owner\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    // Throws if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(isOwner(),\"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    // Returns true is the caller is the current owner.\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n    \r\n    // Leaves the contract without owner.\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner,address(0));\r\n        _owner = address(0);\r\n    }\r\n    \r\n    // Transfers ownership of the contract to a new account\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    \r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0x0),\"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner,newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// The ERC-165 identifier for this interface is 0x0e89341c\r\ninterface IERC1155Metadata_URI {\r\n    // a distinct uniform resource identifier (URI) for a given token.\r\n    // the URI may point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n    function uri(uint256 _id) external view returns (string memory);\r\n}\r\n\r\n// The ERC-165 identifier for this interface is 0x0e89341c.\r\ncontract ERC1155Metadata_URI is IERC1155Metadata_URI, HasTokenURI {\r\n    constructor(string memory _tokenURIPrefix) HasTokenURI(_tokenURIPrefix) public { }\r\n    \r\n    function uri(uint256 _id) external view returns (string memory) {\r\n        return _tokenURI(_id);\r\n    }\r\n}\r\n\r\ncontract HasSecondarySaleFees is ERC165 {\r\n    event SecondarySaleFees(uint256 tokenId,address[] recipient,uint[] bps);\r\n    \r\n    /*\r\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\r\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\r\n     *\r\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\r\n    \r\n    constructor() public {\r\n        _registerInterface(_INTERFACE_ID_FEES);\r\n    }\r\n    \r\n    function getFeeRecipients(uint256 id) public view returns (address payable[] memory);\r\n    function getFeeBps(uint256 id) public view returns (uint[] memory);\r\n}\r\n\r\ncontract ERC1155Base is HasSecondarySaleFees,Ownable,ERC1155Metadata_URI,HasContractURI,ERC1155{\r\n    struct Fee {\r\n        address payable recipient;\r\n        uint256 value;\r\n    }\r\n    \r\n    // id => creator\r\n    mapping(uint256 => address) public creators;\r\n    // id => fees\r\n    mapping(uint256 => Fee[]) public fees;\r\n    \r\n    constructor(string memory contractURI, string memory tokenURIPrefix) HasContractURI(contractURI) ERC1155Metadata_URI(tokenURIPrefix) public {\r\n        \r\n    }\r\n    \r\n    function getFeeRecipients(uint256 id) public view returns (address payable[] memory) {\r\n        Fee[] memory _fees = fees[id];\r\n        address payable[] memory result = new address payable[](_fees.length);\r\n        for(uint i = 0; i < _fees.length; i ++){\r\n            result[i] = _fees[i].recipient;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function getFeeBps(uint256 id) public view returns (uint[] memory) {\r\n        Fee[] memory _fees = fees[id];\r\n        uint[] memory result = new uint[](_fees.length);\r\n        for(uint i = 0;i < _fees.length; i ++){\r\n            result[i] = _fees[i].value;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    function _mint(uint256 _id,Fee[] memory _fees,uint256 _supply,string memory _uri) internal {\r\n        require(creators[_id] == address(0x0),\"Token is already minted\");\r\n        require(_supply != 0,\"Supply should be positive\");\r\n        require(bytes(_uri).length > 0,\"uri should be set\");\r\n        \r\n        creators[_id] = msg.sender;\r\n        address[] memory recipients = new address[](_fees.length);\r\n        uint[] memory bps = new uint[](_fees.length);\r\n        for (uint i = 0;i < _fees.length; i ++){\r\n            require(_fees[i].recipient != address(0x0),\"Recipient should be present\");\r\n            require(_fees[i].value != 0,\"Fee value should be positive\");\r\n            fees[_id].push(_fees[i]);\r\n            recipients[i] = _fees[i].recipient;\r\n            bps[i] = _fees[i].value;\r\n        }\r\n        \r\n        if (_fees.length > 0){\r\n            emit SecondarySaleFees(_id,recipients,bps);\r\n        }\r\n        \r\n        balances[_id][msg.sender] = _supply;\r\n        _setTokenURI(_id,_uri);\r\n        \r\n        emit TransferSingle(msg.sender,address(0x0),msg.sender,_id,_supply);\r\n        emit URI(_uri,_id);\r\n    }\r\n    \r\n    function burn(address _owner, uint256 _id,uint256 _value) external {\r\n        require(_owner == msg.sender || operatorApproval[_owner][msg.sender] == true,\"Need operator approva for 3rd party burns\");\r\n        \r\n        balances[_id][_owner] = balances[_id][_owner].sub(_value);\r\n        \r\n        emit TransferSingle(msg.sender,_owner,address(0x0),_id,_value);\r\n    }\r\n    \r\n    // Internal function to set the token URI for a given token \r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(creators[tokenId] != address(0x0),\"setTokenURI:Token should exist\");\r\n        super._setTokenURI(tokenId,uri);\r\n    }\r\n    \r\n    function setTokenURIPrefix(string memory tokenURIPrefix) public onlyOwner {\r\n        super._setTokenURIPrefix(tokenURIPrefix);\r\n    }\r\n    \r\n    function setContractURI(string memory contractURI) public onlyOwner {\r\n        super._setContractURI(contractURI);\r\n    }\r\n}\r\n\r\n\r\n// library for managing addresses assigned to a Role\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address=>bool) bearer;\r\n    }\r\n    \r\n    // Give an account access to this Role\r\n    function add(Role storage role,address account) internal {\r\n        require(!has(role,account),\"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n    \r\n    // Remove an account's access to this role\r\n    function remove(Role storage role,address account) internal {\r\n        require(has(role,account),\"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n    \r\n    \r\n    // Check if an account has this role\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0x0),\"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\ncontract SignerRole is Context {\r\n    using Roles for Roles.Role;\r\n    \r\n    event SignerAdded(address indexed account);\r\n    event SignerRemoved(address indexed account);\r\n    \r\n    Roles.Role private _signers;\r\n    \r\n    constructor() internal {\r\n        _addSigner(_msgSender());\r\n    }\r\n    \r\n    modifier onlySigner(){\r\n        require(isSigner(_msgSender()),\"SignerRole: caller does not have the Signer role\");\r\n        _;\r\n    }\r\n    \r\n    function isSigner(address account) public view returns (bool) {\r\n        return _signers.has(account);\r\n    }\r\n    \r\n    function addSigner(address account) public onlySigner {\r\n        _addSigner(account);\r\n    }\r\n    \r\n    function renounceSigner() public {\r\n        _removeSigner(_msgSender());\r\n    }\r\n    \r\n    function _addSigner(address account) internal {\r\n        _signers.add(account);\r\n    }\r\n    \r\n    function _removeSigner(address account) internal {\r\n        _signers.remove(account);\r\n        emit SignerRemoved(account);\r\n    }\r\n}\r\n\r\ncontract AntasyToken is Ownable,SignerRole, ERC1155Base {\r\n    string public name;\r\n    string public symbol;\r\n    \r\n    constructor(string memory _name,string memory _symbol,address signer, string memory contractURI,string memory tokenURIPrefix) ERC1155Base(contractURI,tokenURIPrefix) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        \r\n        _addSigner(signer);\r\n        _registerInterface(bytes4(keccak256('MINT_WITH_ADDRESS')));\r\n    }\r\n    \r\n    function addSigner(address account) public onlyOwner {\r\n        _addSigner(account);\r\n    }\r\n    \r\n    function removeSigner(address account) public onlyOwner{\r\n        _removeSigner(account);\r\n    }\r\n    \r\n    function mint(uint256 id, Fee[] memory fee,uint256 supply,string memory uri) public {\r\n    //require(isSigner(ecrecover(keccak256(abi.encode(this,id)),v,r,s)),\"signer should sign tokenId\");\r\n        _mint(id,fee,supply,uri);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenURIPrefix\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipient\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"bps\",\"type\":\"uint256[]\"}],\"name\":\"SecondarySaleFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"creators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getFeeBps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getFeeRecipients\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC1155Base.Fee[]\",\"name\":\"fee\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenURIPrefix\",\"type\":\"string\"}],\"name\":\"setTokenURIPrefix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenURIPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AntasyToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000583c9404923b02c65f74c2c1ece8735475a9ffb9000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000006416e7461737900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006416e746173790000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002868747470733a2f2f7777772e616e746173792e636f6d2f636f6c6c656374696f6e2f64657461696c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007697066733a2f2f00000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a5db46d6b853522c54614a823eff9fcaa3f6f56908142fdf6d93dddfaa656ac6"}]}