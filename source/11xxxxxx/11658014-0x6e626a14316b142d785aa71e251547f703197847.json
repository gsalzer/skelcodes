{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\GFarmTokenInterface.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.5;\r\n\r\ninterface GFarmTokenInterface{\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function burn(address from, uint256 amount) external;\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n\r\n// File: contracts\\GFarmNFTInterface.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ninterface GFarmNFTInterface{\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function leverageID(uint8 _leverage) external pure returns(uint8);\r\n    function idToLeverage(uint id) external view returns(uint8);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @uniswap\\v2-core\\contracts\\interfaces\\IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts\\GFarmTrading.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n\r\ncontract GFarmTrading{\r\n\r\n    using SafeMath for uint;\r\n\r\n    // VARIABLES & CONSTANTS\r\n\r\n    // 1. Tokens\r\n    GFarmTokenInterface public token;\r\n    IUniswapV2Pair public lp;\r\n    GFarmNFTInterface public nft;\r\n\r\n    // 2. Trading\r\n    uint constant PRECISION = 1e5;\r\n    bool public TRADING_PAUSED;\r\n    uint constant MAX_GAIN_P = 400; // 400% = 5x\r\n    uint constant STOP_LOSS_P = 90; // -90%\r\n    uint public MIN_POSITION_SIZE_ETH = 0; // 1e18\r\n    uint public MAX_POS_GFARM_LP_P = 200000; // (2%) PRECISION\r\n    uint public MAX_ACTIVITY_PER_BLOCK = 10;\r\n    uint constant MAX_GFARM_POS_MUL = 2; // 2x\r\n    uint public TOTAL_GFARM_BURNED;\r\n    uint public TOTAL_GFARM_MINTED;\r\n\r\n    // 3. Important uniswap addresses / pairs\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IUniswapV2Pair constant ethPairDAI = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11);\r\n    IUniswapV2Pair constant ethPairUSDT = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\r\n    IUniswapV2Pair constant ethPairUSDC = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\r\n\r\n    // 4. Governance & dev fund\r\n    address public GOVERNANCE;\r\n    address public immutable DEV_FUND;\r\n    uint constant GOVERNANCE_P = 50000; // PRECISION\r\n    uint constant DEV_FUND_P = 50000; // PRECISION\r\n\r\n    // 6. Info on each trade\r\n    struct Trade{\r\n        uint openBlock;\r\n        address initiator;\r\n        bool buy;\r\n        uint openPrice; // PRECISION\r\n        uint initialPositionSizeGFARM; // 1e18\r\n        uint positionSizeETH; // 1e18\r\n        uint16 leverage;\r\n    }\r\n\r\n    // 7. Info on each user's gains\r\n    struct Gains{\r\n        uint valueGFARM; // 1e18\r\n        uint lastTradeClosed; // block\r\n    }\r\n\r\n    // 8. Mappings: each user\r\n    mapping(address => Trade) public trades;\r\n    mapping(address => Gains) public gains;\r\n    mapping(address => uint) private addressTradeOpenID;\r\n\r\n    // 9. General\r\n    mapping(uint => uint) private tradesPerBlock;\r\n    address[] public addressesTradeOpen;\r\n\r\n    // 10. Events\r\n    event TradeOpened(\r\n        address indexed a,\r\n        uint price,\r\n        bool buy,\r\n        uint positionSizeETH,\r\n        uint positionSizeGFARM,\r\n        uint leverage\r\n    );\r\n    event TradeClosed(\r\n        address indexed a,\r\n        uint price,\r\n        bool buy,\r\n        uint positionSizeETH,\r\n        uint positionSizeGFARM,\r\n        uint leverage,\r\n        int pnlGFARM,\r\n        int pnlETH\r\n    );\r\n    event TradeLiquidated(\r\n        address indexed liquidator,\r\n        address indexed trader,\r\n        uint price,\r\n        bool buy,\r\n        uint positionSizeETH,\r\n        uint positionSizeGFARM,\r\n        uint leverage,\r\n        uint rewardGFARM,\r\n        uint rewardETH\r\n    );\r\n    event GainsClaimed(\r\n        address indexed a,\r\n        uint amountGFARM,\r\n        uint amountETH\r\n    );\r\n\r\n    constructor(address _GOV, address _DEV){\r\n        GOVERNANCE = _GOV;\r\n        DEV_FUND = _DEV;\r\n    }\r\n\r\n    // GOVERNANCE\r\n\r\n    // 0. Modifier\r\n    modifier onlyGov(){\r\n        require(msg.sender == GOVERNANCE, \"Can only be called by governance.\");\r\n        _;\r\n    }\r\n\r\n    // 1. Update governance address\r\n    function set_GOVERNANCE(address _gov) external onlyGov{\r\n        require(msg.sender == GOVERNANCE);\r\n        GOVERNANCE = _gov;\r\n    }\r\n\r\n    // 2. Set token address\r\n    function set_TOKEN(address _token) external onlyGov{\r\n        require(token == GFarmTokenInterface(0), \"Token address already set\");\r\n        token = GFarmTokenInterface(_token);\r\n    }\r\n\r\n    // 3. Set lp address\r\n    function set_LP(address _lp) external onlyGov{\r\n        require(lp == IUniswapV2Pair(0), \"LP address already set\");\r\n        lp = IUniswapV2Pair(_lp);\r\n    }\r\n\r\n    // 4. Set token address\r\n    function set_NFT(address _nft) external onlyGov{\r\n        require(nft == GFarmNFTInterface(0), \"NFT address already set\");\r\n        nft = GFarmNFTInterface(_nft);\r\n    }\r\n\r\n    // 5. Update max trading activity per blockx\r\n    function set_MAX_ACTIVITY_PER_BLOCK(uint _maxTrades) external onlyGov{\r\n        require(_maxTrades < 15);\r\n        MAX_ACTIVITY_PER_BLOCK = _maxTrades;\r\n    }\r\n\r\n    // 6. Update min position size in ETH to open a trade\r\n    function set_MIN_POSITION_SIZE_ETH(uint _minPos) external onlyGov{\r\n        MIN_POSITION_SIZE_ETH = _minPos;\r\n    }\r\n\r\n    // 7. Update max GFARM position size based on GFARM liquidity\r\n    function set_MAX_POS_GFARM_LP_P(uint _maxPosLp) external onlyGov{\r\n        MAX_POS_GFARM_LP_P = _maxPosLp;\r\n    }\r\n\r\n    // 8. Prevent the opening of new trades & gain claims\r\n    function pause() external onlyGov{\r\n        TRADING_PAUSED = true;\r\n    } \r\n\r\n    // 9. Resume the opening of new trades & gain claims\r\n    function restart() external onlyGov{\r\n        TRADING_PAUSED = false;\r\n    }\r\n\r\n    // PRICING\r\n\r\n    // 1. ETH price from ETH/DAI pool and ETH reserve (PRECISION, 1e18)\r\n    function pairInfoDAI() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ethPairDAI.getReserves();\r\n        uint reserveDAI;\r\n        uint reserveETH;\r\n        if(WETH == ethPairDAI.token0()){\r\n            reserveETH = reserves0;\r\n            reserveDAI = reserves1;\r\n        }else{\r\n            reserveDAI = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // DAI: 18 decimals\r\n        return (reserveDAI.mul(PRECISION).div(reserveETH), reserveETH);\r\n    }\r\n    // 2. ETH price from ETH/USDT pool and ETH reserve (PRECISION, 1e18)\r\n    function pairInfoUSDT() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ethPairUSDT.getReserves();\r\n        uint reserveUSDT;\r\n        uint reserveETH;\r\n        if(WETH == ethPairUSDT.token0()){\r\n            reserveETH = reserves0;\r\n            reserveUSDT = reserves1;\r\n        }else{\r\n            reserveUSDT = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // USDT: 6 decimals\r\n        return (reserveUSDT.mul(1e12).mul(PRECISION).div(reserveETH), reserveETH);\r\n    }\r\n    // 3. ETH price from ETH/USDC pool and ETH reserve (PRECISION, 1e18)\r\n    function pairInfoUSDC() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = ethPairUSDC.getReserves();\r\n        uint reserveUSDC;\r\n        uint reserveETH;\r\n        if(WETH == ethPairUSDC.token0()){\r\n            reserveETH = reserves0;\r\n            reserveUSDC = reserves1;\r\n        }else{\r\n            reserveUSDC = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n        // USDC: 6 decimals\r\n        return (reserveUSDC.mul(1e12).mul(PRECISION).div(reserveETH), reserveETH);\r\n    }\r\n    // 4. ETH price: weighted average based on liquidity (PRECISION)\r\n    function getEthPrice() public view returns(uint){\r\n        (uint priceEthDAI, uint reserveEthDAI) = pairInfoDAI();\r\n        (uint priceEthUSDT, uint reserveEthUSDT) = pairInfoUSDT();\r\n        (uint priceEthUSDC, uint reserveEthUSDC) = pairInfoUSDC();\r\n\r\n        uint reserveEth = reserveEthDAI.add(reserveEthUSDT).add(reserveEthUSDC);\r\n\r\n        return (\r\n                priceEthDAI.mul(reserveEthDAI).add(\r\n                    priceEthUSDT.mul(reserveEthUSDT)\r\n                ).add(\r\n                    priceEthUSDC.mul(reserveEthUSDC)\r\n                )\r\n            ).div(reserveEth);\r\n    }\r\n    // 5. GFARM and ETH reserves on Uniswap (1e18, 1e18)\r\n    function getReservesLP() private view returns(uint, uint){\r\n        (uint112 reserves0, uint112 reserves1, ) = lp.getReserves();\r\n\r\n        uint reserveETH;\r\n        uint reserveGFARM;\r\n\r\n        if(WETH == lp.token0()){\r\n            reserveETH = reserves0;\r\n            reserveGFARM = reserves1;\r\n        }else{\r\n            reserveGFARM = reserves0;\r\n            reserveETH = reserves1;\r\n        }\r\n\r\n        return (reserveGFARM, reserveETH);\r\n    }\r\n    // 6. GFARM price in ETH (PRECISION)\r\n    function getGFarmPriceEth() private view returns(uint){\r\n        (uint reserveGFARM, uint reserveETH) = getReservesLP();\r\n        return reserveETH.mul(PRECISION).div(reserveGFARM);\r\n    }\r\n\r\n    // MAX & MIN POSITION SIZE\r\n\r\n    // Min position size in GFARM (1e18)\r\n    function getMinPosGFARM() public view returns(uint){\r\n        return MIN_POSITION_SIZE_ETH.mul(PRECISION).div(getGFarmPriceEth());\r\n    }\r\n\r\n    // Max position size in GFARM (1e18)\r\n    // Lowest between: MAX_POS_GFARM_LP_P % of GFARM liquidity OR\r\n    //                 value based on ETH liquidity & trade leverage\r\n    function getMaxPosGFARM(uint _leverage) public view returns(uint){\r\n        (, uint reserveEthDAI) = pairInfoDAI();\r\n        (, uint reserveEthUSDT) = pairInfoUSDT();\r\n        (, uint reserveEthUSDC) = pairInfoUSDC();\r\n\r\n        uint totalReserveETH = reserveEthDAI.add(reserveEthUSDT).add(reserveEthUSDC);\r\n        uint sqrt10 = 3162277660168379331; // 1e18 precision\r\n\r\n        uint maxPosGFARM = (sqrt10.mul(totalReserveETH).sub(totalReserveETH.mul(1e18)))\r\n                        .div(_leverage.mul(3000))\r\n                        .div(1e18/PRECISION).div(getGFarmPriceEth());\r\n\r\n        (uint reserveGFARM, ) = getReservesLP();\r\n        uint maxPosGFARM_lpBased = reserveGFARM.mul(MAX_POS_GFARM_LP_P).div(100*PRECISION);\r\n\r\n        if(maxPosGFARM > maxPosGFARM_lpBased){\r\n            return maxPosGFARM_lpBased; \r\n        }\r\n        \r\n        return maxPosGFARM;\r\n    }\r\n\r\n    // PRIVATE FUNCTIONS (called internally only)\r\n    \r\n    // 1. Percent difference between 2 prices of ETH (PRECISION)\r\n    function percentDiff(uint a, uint b) private pure returns(int){\r\n        return (int(b) - int(a))*100*int(PRECISION)/int(a);\r\n    }\r\n    // 2. Trades % PnL based on price movement (PRECISION)\r\n    function currentPercentProfit(\r\n        uint _openPrice,\r\n        uint _currentPrice,\r\n        bool _buy,\r\n        uint16 _leverage) private pure returns(int p){\r\n        if(_buy){\r\n            p = percentDiff(_openPrice, _currentPrice)*int(_leverage);\r\n        }else{\r\n            p = percentDiff(_openPrice, _currentPrice)*(-1)*int(_leverage);\r\n        }\r\n        int maxLossPercentage = -100 * int(PRECISION);\r\n        int maxGainPercentage = int(MAX_GAIN_P * PRECISION);\r\n        if(p < maxLossPercentage){\r\n            p = maxLossPercentage;\r\n        }else if(p > maxGainPercentage){\r\n            p = maxGainPercentage;\r\n        }\r\n    }\r\n    // 3. Has the trade reached the SL\r\n    function canLiquidatePure(\r\n        uint _openPrice,\r\n        uint _currentPrice,\r\n        bool _buy,\r\n        uint16 _leverage) private pure returns(bool){\r\n        if(_buy){\r\n            return currentPercentProfit(_openPrice, _currentPrice, _buy, _leverage) \r\n                    <= (-1)*int(STOP_LOSS_P*PRECISION);\r\n        }else{\r\n            return currentPercentProfit(_openPrice, _currentPrice, _buy, _leverage)\r\n                    <= (-1)*int(STOP_LOSS_P*PRECISION);\r\n        }\r\n    }\r\n    // 4. Remove trade from list of open trades\r\n    function unregisterOpenTrade(address a) private{\r\n        delete trades[a];\r\n        if(addressesTradeOpen.length > 1){\r\n            addressesTradeOpen[addressTradeOpenID[a]] = \r\n                addressesTradeOpen[addressesTradeOpen.length - 1];\r\n            addressTradeOpenID[\r\n                addressesTradeOpen[addressesTradeOpen.length - 1]\r\n            ] = addressTradeOpenID[a];\r\n        }\r\n        addressesTradeOpen.pop();\r\n        delete addressTradeOpenID[a];\r\n    }\r\n\r\n    // PUBLIC FUNCTIONS (called internally and externally)\r\n\r\n    // 1. Does an address have an open trade\r\n    function hasOpenTrade(address a) public view returns(bool){\r\n        return trades[a].openBlock != 0;\r\n    }\r\n    // 2. Does an address have an open trade that can be liquidated\r\n    function canLiquidate(address a) public view returns(bool){\r\n        require(hasOpenTrade(a), \"This address has no open trade.\");\r\n        Trade memory t = trades[a];\r\n        return canLiquidatePure(t.openPrice, getEthPrice(), t.buy, t.leverage);\r\n    }\r\n    // 3. GFARM position size based on ETH position size & GFARM/ETH price (1e18)\r\n    function positionSizeGFARM(address a) public view returns(uint posGFARM){\r\n        Trade memory t = trades[a];\r\n\r\n        posGFARM = t.positionSizeETH.mul(PRECISION).div(getGFarmPriceEth());\r\n\r\n        // Max 2x initial position size if GFARM/ETH goes down\r\n        uint doubleInitialPos = t.initialPositionSizeGFARM.mul(2);\r\n        if(posGFARM > doubleInitialPos){\r\n            posGFARM = doubleInitialPos;\r\n        }\r\n    }\r\n    // 4. PnL of msg.sender if has an open trade (1e18)\r\n    function myTokenPNL() public view returns(int){\r\n        if(!hasOpenTrade(msg.sender)){ return 0; }\r\n        Trade memory t = trades[msg.sender];\r\n        return int(positionSizeGFARM(msg.sender)) \r\n                * currentPercentProfit(t.openPrice, getEthPrice(), t.buy, t.leverage)\r\n                / int(100*PRECISION);\r\n    }\r\n    // 5. Amount you get by liquidating the trade opened by an address (1e18)\r\n    function liquidateAmountGFARM(address a) public view returns(uint){\r\n        return positionSizeGFARM(a).mul((100 - STOP_LOSS_P)).div(100);\r\n    }\r\n    // 6. NFTs count in msg.sender's wallet\r\n    function myNftsCount() public view returns(uint){\r\n        return nft.balanceOf(msg.sender);\r\n    }\r\n\r\n    // EXTERNAL TRADING FUNCTIONS\r\n    \r\n    // 1. Open a new trade at current ETH price\r\n    function openTrade(bool _buy, uint _positionSizeGFARM, uint16 _leverage) external{\r\n        require(tradesPerBlock[block.number] < MAX_ACTIVITY_PER_BLOCK,\r\n            \"Max trading activity per block reached.\");\r\n\r\n        require(TRADING_PAUSED == false,\r\n            \"Trading is paused, cannot open any new trade.\");\r\n\r\n        require(tx.origin == msg.sender,\r\n            \"Contracts not allowed.\");\r\n\r\n        require(!hasOpenTrade(msg.sender),\r\n            \"You can only have 1 trade open at a time.\");\r\n\r\n        require(_positionSizeGFARM > 0,\r\n            \"Opening a trade with 0 tokens.\");\r\n\r\n        uint maxPosGFARM = getMaxPosGFARM(_leverage);\r\n\r\n        require(_positionSizeGFARM <= maxPosGFARM,\r\n            \"Your position size exceeds the max authorized position size.\");\r\n\r\n        require(_positionSizeGFARM >= getMinPosGFARM(),\r\n            \"Your position size must be bigger than the minimum position size.\");\r\n\r\n        uint ethPrice = getEthPrice();\r\n\r\n        if(_leverage != 10){\r\n            uint nftCount = myNftsCount();\r\n            require(nftCount > 0, \"You don't own any GFarm NFT.\");\r\n\r\n            bool hasCorrespondingNFT = false;\r\n\r\n            for(uint i = 0; i < nftCount; i++){\r\n                uint nftID = nft.tokenOfOwnerByIndex(msg.sender, i);\r\n                uint correspondingLeverage = nft.idToLeverage(nftID);\r\n                if(correspondingLeverage == _leverage){\r\n                    hasCorrespondingNFT = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            require(hasCorrespondingNFT,\r\n                \"You don't own the corresponding NFT for this leverage.\");            \r\n        }\r\n        \r\n        token.transferFrom(msg.sender, address(this), _positionSizeGFARM);\r\n        token.burn(address(this), _positionSizeGFARM);\r\n        TOTAL_GFARM_BURNED = TOTAL_GFARM_BURNED.add(_positionSizeGFARM);\r\n\r\n        uint GOV_fee = _positionSizeGFARM.mul(GOVERNANCE_P).div(100*PRECISION);\r\n        uint DEV_fee = _positionSizeGFARM.mul(DEV_FUND_P).div(100*PRECISION);\r\n\r\n        uint positionSizeGFARM_minusFees = _positionSizeGFARM.sub(GOV_fee).sub(DEV_fee);\r\n        uint positionSizeETH_minusFees = positionSizeGFARM_minusFees.mul(getGFarmPriceEth())\r\n                                        .div(PRECISION);\r\n\r\n        token.mint(GOVERNANCE, GOV_fee);\r\n        token.mint(DEV_FUND, DEV_fee);\r\n\r\n        trades[msg.sender] = Trade(\r\n            block.number,\r\n            msg.sender,\r\n            _buy,\r\n            ethPrice,\r\n            positionSizeGFARM_minusFees,\r\n            positionSizeETH_minusFees,\r\n            _leverage\r\n        );\r\n\r\n        addressesTradeOpen.push(msg.sender);\r\n        addressTradeOpenID[msg.sender] = addressesTradeOpen.length.sub(1);\r\n    \r\n        tradesPerBlock[block.number] = tradesPerBlock[block.number].add(1);\r\n\r\n        emit TradeOpened(\r\n            msg.sender,\r\n            ethPrice,\r\n            _buy,\r\n            positionSizeETH_minusFees,\r\n            positionSizeGFARM_minusFees,\r\n            _leverage\r\n        );\r\n    }\r\n\r\n    // 2. Close open trade at current ETH price\r\n    function closeTrade() external{\r\n        require(tradesPerBlock[block.number] < MAX_ACTIVITY_PER_BLOCK,\r\n            \"Max trading activity per block reached.\");\r\n\r\n        require(tx.origin == msg.sender,\r\n            \"Contracts not allowed.\");\r\n\r\n        require(hasOpenTrade(msg.sender), \r\n            \"You have no open trade.\");\r\n\r\n        Trade memory t = trades[msg.sender];\r\n\r\n        require(block.number >= t.openBlock.add(3),\r\n            \"Trade must be open for at least 3 blocks.\");\r\n\r\n        uint posGFARM = positionSizeGFARM(msg.sender);\r\n        int pnlGFARM;\r\n        int pnlETH;\r\n\r\n        if(!canLiquidate(msg.sender)){\r\n            pnlGFARM = myTokenPNL();\r\n            uint tokensBack = posGFARM;\r\n\r\n            // Gain\r\n            if(pnlGFARM > 0){ \r\n                Gains storage userGains = gains[msg.sender];\r\n                userGains.valueGFARM = userGains.valueGFARM\r\n                                        .add(uint(pnlGFARM));\r\n                userGains.lastTradeClosed = block.number;\r\n            // Loss\r\n            }else if(pnlGFARM < 0){\r\n                tokensBack = tokensBack.sub(uint(pnlGFARM*(-1)));\r\n            }\r\n\r\n            token.mint(msg.sender, tokensBack);\r\n            TOTAL_GFARM_MINTED = TOTAL_GFARM_MINTED.add(tokensBack);\r\n        }else{\r\n            pnlGFARM = int(posGFARM) * (-1);\r\n        }\r\n\r\n        pnlETH = pnlGFARM * int(getGFarmPriceEth()) / int(PRECISION);\r\n\r\n        emit TradeClosed(\r\n            msg.sender,\r\n            getEthPrice(),\r\n            t.buy,\r\n            t.positionSizeETH,\r\n            posGFARM,\r\n            t.leverage,\r\n            pnlGFARM,\r\n            pnlETH\r\n        );\r\n\r\n        unregisterOpenTrade(msg.sender);\r\n        tradesPerBlock[block.number] = tradesPerBlock[block.number].add(1);\r\n    }\r\n\r\n    // 3. Liquidate trade opened by an address\r\n    function liquidate(address a) external{\r\n        require(tx.origin == msg.sender,\r\n            \"Contracts not allowed.\");\r\n\r\n        require(tradesPerBlock[block.number] < MAX_ACTIVITY_PER_BLOCK,\r\n            \"Max trading activity per block reached.\");\r\n\r\n        require(canLiquidate(a),\r\n            \"No trade to liquidate for this address.\");\r\n\r\n        require(myNftsCount() > 0 || msg.sender == GOVERNANCE,\r\n            \"You don't own any GFarm NFT.\");\r\n\r\n        Trade memory t = trades[a];\r\n\r\n        uint amountGFARM = liquidateAmountGFARM(a);\r\n        uint amountETH = amountGFARM.mul(getGFarmPriceEth()).div(PRECISION);\r\n        uint posGFARM = positionSizeGFARM(a);\r\n\r\n        token.mint(msg.sender, amountGFARM);\r\n        TOTAL_GFARM_MINTED = TOTAL_GFARM_MINTED.add(amountGFARM);\r\n\r\n        unregisterOpenTrade(a);\r\n        tradesPerBlock[block.number] = tradesPerBlock[block.number].add(1);\r\n\r\n        emit TradeLiquidated(\r\n            msg.sender,\r\n            a,\r\n            getEthPrice(),\r\n            t.buy,\r\n            t.positionSizeETH,\r\n            posGFARM,\r\n            t.leverage,\r\n            amountGFARM,\r\n            amountETH\r\n        );\r\n    }\r\n\r\n    // 4. Claim gains made with all trades\r\n    function claimGains() external{\r\n        require(tx.origin == msg.sender,\r\n            \"Contracts not allowed.\");\r\n\r\n        require(TRADING_PAUSED == false,\r\n            \"Trading is paused, cannot open any new trade.\");\r\n\r\n        Gains storage userGains = gains[msg.sender];\r\n        require(block.number.sub(userGains.lastTradeClosed) >= 3,\r\n            \"You must wait 3 block after you close a trade.\");\r\n\r\n        uint gainsGFARM = userGains.valueGFARM;\r\n        uint gainsETH = gainsGFARM.mul(getGFarmPriceEth()).div(PRECISION);\r\n\r\n        token.mint(msg.sender, gainsGFARM);\r\n        TOTAL_GFARM_MINTED = TOTAL_GFARM_MINTED.add(gainsGFARM);\r\n\r\n        emit GainsClaimed(\r\n            msg.sender,\r\n            gainsGFARM,\r\n            gainsETH\r\n        );\r\n\r\n        userGains.valueGFARM = 0;\r\n    }\r\n\r\n    // UI VIEW FUNCTIONS (READ-ONLY)\r\n\r\n    function myGains() external view returns(uint){\r\n        return gains[msg.sender].valueGFARM;\r\n    }\r\n    \r\n    function canClaimGains() external view returns(bool){\r\n        return block.number.sub(gains[msg.sender].lastTradeClosed) \r\n                >= 3 && gains[msg.sender].valueGFARM > 0;\r\n    }\r\n    \r\n    function myPercentPNL() external view returns(int){\r\n        if(!hasOpenTrade(msg.sender)){ return 0; }\r\n\r\n        Trade memory t = trades[msg.sender];\r\n        return currentPercentProfit(t.openPrice, getEthPrice(), t.buy, t.leverage);\r\n    }\r\n    \r\n    function myOpenPrice() external view returns(uint){\r\n        return trades[msg.sender].openPrice;\r\n    }\r\n    \r\n    function myPositionSizeETH() external view returns(uint){\r\n        return trades[msg.sender].positionSizeETH;\r\n    }\r\n    \r\n    function myPositionSizeGFARM() external view returns(uint){\r\n        return positionSizeGFARM(msg.sender);\r\n    }\r\n    \r\n    function myDirection() external view returns(string memory){\r\n        if(trades[msg.sender].buy){ return 'Buy'; }\r\n        return 'Sell';\r\n    }\r\n    \r\n    function myLeverage() external view returns(uint){\r\n        return trades[msg.sender].leverage;\r\n    }\r\n    \r\n    function tradeOpenSinceThreeBlocks() external view returns(bool){\r\n        Trade memory t = trades[msg.sender];\r\n        if(!hasOpenTrade(msg.sender) || block.number < t.openBlock){ \r\n            return false; \r\n        }\r\n        return block.number.sub(t.openBlock) >= 3;\r\n    }\r\n    \r\n    function getAddressesTradeOpen() external view returns(address[] memory){\r\n        return addressesTradeOpen;\r\n    }\r\n    \r\n    function unlockedLeverages() external view returns(uint8[5] memory leverages){\r\n        for(uint i = 0; i < myNftsCount(); i++){\r\n            uint8 leverage = nft.idToLeverage(\r\n                                nft.tokenOfOwnerByIndex(msg.sender, i)\r\n                            );\r\n            uint8 id = nft.leverageID(leverage);\r\n            leverages[id] = leverage;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_GOV\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DEV\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountGFARM\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"GainsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionSizeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionSizeGFARM\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"pnlGFARM\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"pnlETH\",\"type\":\"int256\"}],\"name\":\"TradeClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionSizeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionSizeGFARM\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardGFARM\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardETH\",\"type\":\"uint256\"}],\"name\":\"TradeLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionSizeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionSizeGFARM\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"}],\"name\":\"TradeOpened\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEV_FUND\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ACTIVITY_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_POS_GFARM_LP_P\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_POSITION_SIZE_ETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_GFARM_BURNED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_GFARM_MINTED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRADING_PAUSED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressesTradeOpen\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canClaimGains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"canLiquidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimGains\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"valueGFARM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTradeClosed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesTradeOpen\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"getMaxPosGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinPosGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"hasOpenTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"liquidateAmountGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lp\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myDirection\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myNftsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myOpenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPercentPNL\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPositionSizeETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myPositionSizeGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokenPNL\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract GFarmNFTInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_positionSizeGFARM\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_leverage\",\"type\":\"uint16\"}],\"name\":\"openTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"positionSizeGFARM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"posGFARM\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"set_GOVERNANCE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"set_LP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTrades\",\"type\":\"uint256\"}],\"name\":\"set_MAX_ACTIVITY_PER_BLOCK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPosLp\",\"type\":\"uint256\"}],\"name\":\"set_MAX_POS_GFARM_LP_P\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPos\",\"type\":\"uint256\"}],\"name\":\"set_MIN_POSITION_SIZE_ETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"name\":\"set_NFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"set_TOKEN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract GFarmTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeOpenSinceThreeBlocks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"openBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPositionSizeGFARM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionSizeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"leverage\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockedLeverages\",\"outputs\":[{\"internalType\":\"uint8[5]\",\"name\":\"leverages\",\"type\":\"uint8[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GFarmTrading","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000c66fbe50dd33c9aadd65707f7088d597c86fe00f000000000000000000000000d39a38bd2d2d552f3908ff698a5530aa397fb92d","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c730ec07cf0eed42bd30c3889832919ea5b598cb5eef6f3d71188bab41af9376"}]}