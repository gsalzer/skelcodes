{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\nlibrary SafeMathLib {\r\n  function times(uint a, uint b) public pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) public pure returns (uint) {\r\n    require(b <= a, 'Underflow detected');\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) public pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ninterface IUniswapRouter {\r\n\r\n    event LiquidityAdded(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Auction\r\n */\r\n\r\ncontract Auction {\r\n    using SafeMathLib for uint;\r\n\r\n    struct Tranche {\r\n        uint blockIssued;\r\n        uint weiPerToken;\r\n        uint totalTokens;\r\n        uint currentTokens;\r\n    }\r\n\r\n    uint256 public poolBalance;\r\n    address public management;\r\n    uint256 public decayPerBlock;\r\n    uint256 public lastTokensPerWei;\r\n    uint256 public priceFloor;\r\n    uint256 public trancheNumber = 1;\r\n    uint256 public totalTokensOffered;\r\n    uint256 public totalTokensSold = 0;\r\n\r\n    uint256 public initialPrice = 0;\r\n    uint256 public initialTrancheSize = 0;\r\n    uint256 public minimumPrice = 0;\r\n    uint256 public startBlock = 0;\r\n\r\n    bytes32 public siteHash;\r\n\r\n    address payable public safeAddress;\r\n    IERC20 public token;\r\n    IUniswapRouter public uniswap;\r\n    Tranche public currentTranche;\r\n\r\n    event PurchaseOccurred(address purchaser, uint weiSpent, uint tokensAcquired, uint tokensLeftInTranche, uint weiReturned, uint trancheNumber, uint timestamp);\r\n    event LiquidityPushed(uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'Auction: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    constructor(address mgmt,\r\n                address tokenAddr,\r\n                address uniswapRouter,\r\n                uint auctionStartBlock,\r\n                uint tokensForSale,\r\n                uint firstTranchePricePerToken,\r\n                uint firstTrancheSize,\r\n                uint initialDecay,\r\n                uint minPrice,\r\n                address payable safeAddr) {\r\n        management = mgmt;\r\n        token = IERC20(tokenAddr);\r\n        uniswap = IUniswapRouter(uniswapRouter);\r\n        startBlock = auctionStartBlock > 0 ? auctionStartBlock : block.number;\r\n        totalTokensOffered = tokensForSale;\r\n        initialPrice = firstTranchePricePerToken;\r\n        initialTrancheSize = firstTrancheSize;\r\n        currentTranche = Tranche(startBlock, firstTranchePricePerToken, firstTrancheSize, firstTrancheSize);\r\n        decayPerBlock = initialDecay;\r\n        safeAddress = safeAddr;\r\n        minimumPrice = minPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev default function\r\n     * gas ~\r\n     */\r\n    receive() external payable {\r\n        buy(currentTranche.weiPerToken);\r\n    }\r\n\r\n    function withdrawTokens() public managementOnly {\r\n        uint balance = token.balanceOf(address(this));\r\n        token.transfer(management, balance);\r\n    }\r\n\r\n    function setSiteHash(bytes32 newHash) public managementOnly {\r\n        siteHash = newHash;\r\n    }\r\n\r\n    function pushLiquidity() public managementOnly {\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        uint minToken = tokenBalance / 2;\r\n        uint ethBalance = address(this).balance;\r\n        uint deadline = block.timestamp + 1 hours;\r\n        token.approve(address(uniswap), tokenBalance);\r\n        // this will take all the eth and refund excess tokens\r\n        (uint amountToken, uint amountETH, uint liquidity) = uniswap.addLiquidityETH{value: ethBalance}(address(token), tokenBalance, minToken, ethBalance, safeAddress, deadline);\r\n        emit LiquidityPushed(amountToken, amountETH, liquidity);\r\n    }\r\n\r\n    function getBuyPrice() public view returns (uint) {\r\n        if (block.number < currentTranche.blockIssued) {\r\n            return 0;\r\n        }\r\n        // linear time decay\r\n        uint distanceBlocks = block.number.minus(currentTranche.blockIssued);\r\n        uint decay = decayPerBlock.times(distanceBlocks);\r\n        uint proposedPrice;\r\n        if (currentTranche.weiPerToken < decay.plus(minimumPrice)) {\r\n            proposedPrice = minimumPrice;\r\n        } else {\r\n            proposedPrice = currentTranche.weiPerToken.minus(decay);\r\n        }\r\n        return proposedPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Buy tokens\r\n     * gas ~\r\n     */\r\n    function buy(uint maxPrice) public payable lock {\r\n        require(msg.value > 0, 'Auction: must send ether to buy');\r\n        require(block.number >= startBlock, 'Auction: not started yet');\r\n        // buyPrice = wei / 1e18 tokens\r\n        uint weiPerToken = getBuyPrice();\r\n\r\n        require(weiPerToken <= maxPrice, 'Auction: price too high');\r\n        // buyAmount = wei * tokens / wei = tokens\r\n        uint buyAmountTokens = (msg.value * 1 ether) / weiPerToken;\r\n        uint leftOverTokens = 0;\r\n        uint weiReturned = 0;\r\n        uint trancheNumReported = trancheNumber;\r\n\r\n        // if they bought more than the tranche has...\r\n        if (buyAmountTokens >= currentTranche.currentTokens) {\r\n            // compute the excess amount of tokens\r\n            uint excessTokens = buyAmountTokens - currentTranche.currentTokens;\r\n            // weiReturned / msg.value = excessTokens / buyAmountTokens\r\n            weiReturned = msg.value.times(excessTokens) / buyAmountTokens;\r\n            // send the excess ether back\r\n            // re-entrance blocked by the lock modifier\r\n            msg.sender.transfer(weiReturned);\r\n            // now they are only buying the remaining\r\n            buyAmountTokens = currentTranche.currentTokens;\r\n\r\n            // double the tokens offered\r\n            uint nextTrancheTokens = currentTranche.totalTokens.times(2);\r\n            uint tokensLeftInOffering = totalTokensOffered.minus(totalTokensSold).minus(buyAmountTokens);\r\n\r\n            // if we are not offering enough tokens to cover the next tranche doubling, this is the last tranche\r\n            if (nextTrancheTokens > tokensLeftInOffering) {\r\n                nextTrancheTokens = tokensLeftInOffering;\r\n            }\r\n\r\n            // double the price per token\r\n            currentTranche.weiPerToken = weiPerToken.times(2);\r\n\r\n            // set the new tranche token amounts\r\n            currentTranche.totalTokens = nextTrancheTokens;\r\n            currentTranche.currentTokens = currentTranche.totalTokens;\r\n\r\n            // double the decay per block and reset the block issued\r\n            currentTranche.blockIssued = block.number;\r\n            decayPerBlock = decayPerBlock.times(2);\r\n\r\n            // increment tranche index\r\n            trancheNumber = trancheNumber.plus(1);\r\n\r\n        } else {\r\n            currentTranche.currentTokens = currentTranche.currentTokens.minus(buyAmountTokens);\r\n            leftOverTokens = currentTranche.currentTokens;\r\n        }\r\n\r\n        // send the tokens! re-entrance not possible here because of Token design, but will be possible with ERC-777\r\n        token.transfer(msg.sender, buyAmountTokens);\r\n\r\n        // bookkeeping: count the tokens sold\r\n        totalTokensSold = totalTokensSold.plus(buyAmountTokens);\r\n        emit PurchaseOccurred(msg.sender, msg.value.minus(weiReturned), buyAmountTokens, leftOverTokens, weiReturned, trancheNumReported, block.timestamp);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstTranchePricePerToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstTrancheSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialDecay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"safeAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAcquired\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensLeftInTranche\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiReturned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trancheNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PurchaseOccurred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTranche\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIssued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weiPerToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decayPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialTrancheSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTokensPerWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFloor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pushLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newHash\",\"type\":\"bytes32\"}],\"name\":\"setSiteHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"siteHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensOffered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trancheNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Auction","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b00000000000000000000000045080a6531d671ddff20db42f93792a489685e320000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000000000000000000000000000000000000000ac0c33000000000000000000000000000000000000000000108b2a2c280290940000000000000000000000000000000000000000000000000000000000143603a5ff800000000000000000000000000000000000000000000069e10de76676d080000000000000000000000000000000000000000000000000000000000002540be400000000000000000000000000000000000000000000000000000000e8d4a51000000000000000000000000000c7900783578e026645a6fcfdb7aa26adb63160e2","EVMVersion":"Default","Library":"SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dc4500e3adf9436e52141f7c020662926232c95e1c74847318833cafdf45e694"}]}