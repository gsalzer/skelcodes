{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function owner() external view returns (address);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISushiSwapPoolNames {\n    function logos(uint256) external view returns(string memory);\n    function names(uint256) external view returns(string memory);\n    function setPoolInfo(uint256 pid, string memory logo, string memory name) external;\n}\n\ninterface ISushiToken is IERC20{\n    function delegates(address who) external view returns(address);\n    function getCurrentVotes(address who) external view returns(uint256);\n    function nonces(address who) external view returns(uint256);\n}\n\ninterface IMasterChef {\n    function BONUS_MULTIPLIER() external view returns (uint256);\n    function bonusEndBlock() external view returns (uint256);\n    function devaddr() external view returns (address);\n    function migrator() external view returns (address);\n    function owner() external view returns (address);\n    function startBlock() external view returns (uint256);\n    function sushi() external view returns (address);\n    function sushiPerBlock() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function poolInfo(uint256 nr) external view returns (address, uint256, uint256, uint256);\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface IFactory {\n    function allPairsLength() external view returns (uint256);\n    function allPairs(uint256 i) external view returns (address);\n    function getPair(address token0, address token1) external view returns (address);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n}\n\ninterface IPair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112, uint112, uint32);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); uint256 c = a - b; return c; }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; }\n}\n\ncontract Ownable {\n    address public owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = msg.sender;\n        owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n\ncontract BoringCryptoTokenScanner\n{\n    using SafeMath for uint256;\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n    \n    struct BalanceFull {\n        address token;\n        uint256 balance;\n        uint256 rate;\n    }\n    \n    struct TokenInfo {\n        address token;\n        uint256 decimals;\n        string name;\n        string symbol;\n    }\n\n    function getTokenInfo(address[] calldata addresses) public view returns(TokenInfo[] memory) {\n        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            infos[i].token = address(token);\n            \n            infos[i].name = token.name();\n            infos[i].symbol = token.symbol();\n            infos[i].decimals = token.decimals();\n        }\n\n        return infos;\n    }\n\n    function findBalances(address who, address[] calldata addresses) public view returns(Balance[] memory) {\n        uint256 balanceCount;\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (IERC20(addresses[i]).balanceOf(who) > 0) {\n                balanceCount++;\n            }\n        }\n\n        Balance[] memory balances = new Balance[](balanceCount);\n\n        balanceCount = 0;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            uint256 balance = token.balanceOf(who);\n            if (balance > 0) {\n                balances[balanceCount].token = address(token);\n                balances[balanceCount].balance = token.balanceOf(who);\n                balanceCount++;\n            }\n        }\n\n        return balances;\n    }\n    \n    function getBalances(address who, address[] calldata addresses, IFactory factory, address currency) public view returns(BalanceFull[] memory) {\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            balances[i].token = address(token);\n            balances[i].balance = token.balanceOf(who);\n\n            IPair pair = IPair(factory.getPair(addresses[i], currency));\n            if(address(pair) != address(0))\n            {\n                uint256 reserveCurrency;\n                uint256 reserveToken;\n                if (pair.token0() == currency) {\n                    (reserveCurrency, reserveToken,) = pair.getReserves();\n                }\n                else\n                {\n                    (reserveToken, reserveCurrency,) = pair.getReserves();\n                }\n                balances[i].rate = reserveToken * 1e18 / reserveCurrency;\n            }\n        }\n\n        return balances;\n    }\n\n    struct Factory {\n        IFactory factory;\n        uint256 allPairsLength;\n        address feeTo;\n        address feeToSetter;\n    }\n    \n    function getFactoryInfo(IFactory[] calldata addresses) public view returns(Factory[] memory) {\n        Factory[] memory factories = new Factory[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IFactory factory = addresses[i];\n            factories[i].factory = factory;\n            \n            factories[i].allPairsLength = factory.allPairsLength();\n            factories[i].feeTo = factory.feeTo();\n            factories[i].feeToSetter = factory.feeToSetter();\n        }\n\n        return factories;\n    }\n\n    struct Pair {\n        address token;\n        address token0;\n        address token1;\n    }\n    \n    function getPairs(IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\n        if (toID == 0){\n            toID = factory.allPairsLength();\n        }\n        \n        Pair[] memory pairs = new Pair[](toID - fromID);\n\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            uint256 i = id - fromID;\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n        }\n        return pairs;\n    }\n\n    function findPairs(address who, IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\n        if (toID == 0){\n            toID = factory.allPairsLength();\n        }\n        \n        uint256 pairCount;\n\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            if (IERC20(token).balanceOf(who) > 0) {\n                pairCount++;\n            }\n        }\n\n        Pair[] memory pairs = new Pair[](pairCount);\n\n        pairCount = 0;\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            uint256 balance = IERC20(token).balanceOf(who);\n            if (balance > 0) {\n                pairs[pairCount].token = token;\n                pairs[pairCount].token0 = IPair(token).token0();\n                pairs[pairCount].token1 = IPair(token).token1();\n                pairCount++;\n            }\n        }\n\n        return pairs;\n    }\n\n    struct PairFull {\n        address token;\n        address token0;\n        address token1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n        uint256 balance;\n    }\n\n    function getPairsFull(address who, address[] calldata addresses) public view returns(PairFull[] memory) {\n        PairFull[] memory pairs = new PairFull[](addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            address token = addresses[i];\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n            (uint256 reserve0, uint256 reserve1,) = IPair(token).getReserves();\n            pairs[i].reserve0 = reserve0;\n            pairs[i].reserve1 = reserve1;\n            pairs[i].balance = IERC20(token).balanceOf(who);\n            pairs[i].totalSupply = IERC20(token).totalSupply();\n        }\n        return pairs;\n    }\n}\n\ncontract BoringCryptoDashboardV2\n{\n    using SafeMath for uint256;\n\n    struct PairFull {\n        address token;\n        address token0;\n        address token1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n        uint256 balance;\n    }\n\n    function getPairsFull(address who, address[] calldata addresses) public view returns(PairFull[] memory) {\n        PairFull[] memory pairs = new PairFull[](addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            address token = addresses[i];\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n            (uint256 reserve0, uint256 reserve1,) = IPair(token).getReserves();\n            pairs[i].reserve0 = reserve0;\n            pairs[i].reserve1 = reserve1;\n            pairs[i].balance = IERC20(token).balanceOf(who);\n            pairs[i].totalSupply = IERC20(token).totalSupply();\n        }\n        return pairs;\n    }\n    \n    struct PoolsInfo {\n        uint256 totalAllocPoint;\n        uint256 poolLength;\n    }\n\n    struct PoolInfo {\n        uint256 pid;\n        IPair lpToken;           // Address of LP token contract.\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\n        address token0;\n        address token1;\n    }\n    \n    IMasterChef chef = IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n    \n    function getPools(uint256[] calldata pids) public view returns(PoolsInfo memory, PoolInfo[] memory) {\n        PoolsInfo memory info;\n        info.totalAllocPoint = chef.totalAllocPoint();\n        uint256 poolLength = chef.poolLength();\n        info.poolLength = poolLength;\n        \n        PoolInfo[] memory pools = new PoolInfo[](pids.length);\n\n        for (uint256 i = 0; i < pids.length; i++) {\n            (address lpToken, uint256 allocPoint,,) = chef.poolInfo(pids[i]);\n            IPair uniV2 = IPair(lpToken);\n            pools[i].lpToken = uniV2;\n            pools[i].allocPoint = allocPoint;\n\n            pools[i].token0 = uniV2.token0();\n            pools[i].token1 = uniV2.token1();\n        }\n        return (info, pools);\n    }\n    \n    function findPools(address who, uint256[] calldata pids) public view returns(PoolInfo[] memory) {\n        uint256 count;\n\n        for (uint256 i = 0; i < pids.length; i++) {\n            (uint256 balance,) = chef.userInfo(pids[i], who);\n            if (balance > 0) {\n                count++;\n            }\n        }\n\n        PoolInfo[] memory pools = new PoolInfo[](count);\n\n        count = 0;\n        for (uint256 i = 0; i < pids.length; i++) {\n            (uint256 balance,) = chef.userInfo(pids[i], who);\n            if (balance > 0) {\n                (address lpToken, uint256 allocPoint,,) = chef.poolInfo(pids[i]);\n                IPair uniV2 = IPair(lpToken);\n                pools[count].lpToken = uniV2;\n                pools[count].allocPoint = allocPoint;\n    \n                pools[count].token0 = uniV2.token0();\n                pools[count].token1 = uniV2.token1();\n                count++;\n            }\n        }\n\n        return pools;\n    }\n    \n    function getETHRate(address token) public view returns(uint256) {\n        uint256 eth_rate = 1e18;\n        if (token != 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\n        {\n            IPair pairUniV2;\n            IPair pairSushi;\n            pairUniV2 = IPair(IFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f).getPair(token, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n            pairSushi = IPair(IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac).getPair(token, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n            if (address(pairUniV2) == address(0) && address(pairSushi) == address(0)) {\n                return 0;\n            }\n            \n            uint112 reserve0UniV2; uint112 reserve1UniV2;\n            uint112 reserve0Sushi; uint112 reserve1Sushi;\n            \n            if (address(pairUniV2) != address(0)) {\n                (reserve0UniV2, reserve1UniV2,) = pairUniV2.getReserves();\n            }\n            if (address(pairSushi) != address(0)) {\n                (reserve0Sushi, reserve1Sushi,) = pairSushi.getReserves();\n            }\n            \n            if (address(pairSushi) == address(0) || reserve0UniV2 > reserve0Sushi || reserve1UniV2 > reserve1Sushi) {\n                if (pairUniV2.token0() == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) { eth_rate = uint256(reserve1UniV2).mul(1e18).div(reserve0UniV2); } else { eth_rate = uint256(reserve0UniV2).mul(1e18).div(reserve1UniV2); }\n            } else {\n                if (pairSushi.token0() == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) { eth_rate = uint256(reserve1Sushi).mul(1e18).div(reserve0Sushi); } else { eth_rate = uint256(reserve0Sushi).mul(1e18).div(reserve1Sushi); }\n            }\n        }\n        return eth_rate;\n    }    \n    \n    struct UserPoolInfo {\n        uint256 balance; // Balance of pool tokens\n        uint256 totalSupply; // Token staked lp tokens\n        uint256 lpBalance; // Balance of lp tokens not staked\n        uint256 lpTotalSupply; // TotalSupply of lp tokens\n        uint256 lpAllowance; // LP tokens approved for masterchef\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 token0rate;\n        uint256 token1rate;\n        uint256 rewardDebt;\n        uint256 pending; // Pending SUSHI\n    }    \n    \n    function pollPools(address who, uint256[] calldata pids) public view returns(UserPoolInfo[] memory) {\n        UserPoolInfo[] memory pools = new UserPoolInfo[](pids.length);\n\n        for (uint256 i = 0; i < pids.length; i++) {\n            (uint256 amount,) = chef.userInfo(pids[i], who);\n            pools[i].balance = amount;\n            pools[i].pending = chef.pendingSushi(pids[i], who);\n\n            (address lpToken,,,) = chef.poolInfo(pids[i]);\n            IPair uniV2 = IPair(lpToken);\n            pools[i].totalSupply = uniV2.balanceOf(address(chef));\n            pools[i].lpAllowance = uniV2.allowance(who, address(chef));\n            pools[i].lpBalance = uniV2.balanceOf(who);\n            pools[i].lpTotalSupply = uniV2.totalSupply();\n            pools[i].token0rate = getETHRate(uniV2.token0());\n            pools[i].token1rate = getETHRate(uniV2.token1());\n            \n            (uint112 reserve0, uint112 reserve1,) = uniV2.getReserves();\n            pools[i].reserve0 = reserve0;\n            pools[i].reserve1 = reserve1;\n        }\n        return pools;\n    }    \n}\n\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"findPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getPairsFull\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PairFull[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"getPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalAllocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolLength\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PoolsInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"internalType\":\"struct BoringCryptoDashboardV2.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"pollPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringCryptoDashboardV2.UserPoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BoringCryptoDashboardV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}