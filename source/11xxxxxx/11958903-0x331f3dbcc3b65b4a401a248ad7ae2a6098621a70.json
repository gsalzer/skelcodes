{"status":"1","message":"OK","result":[{"SourceCode":"{\"IBaseTokenData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\ninterface IBaseTokenData {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n}\"},\"IDoubleProxy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity =0.8.0;\\n\\ninterface IDoubleProxy {\\n    function init(address[] calldata proxyList, address currentProxy) external;\\n\\n    function proxy() external view returns (address);\\n\\n    function setProxy() external;\\n\\n    function isProxy(address) external view returns (bool);\\n\\n    function proxiesLength() external view returns (uint256);\\n\\n    function proxies(uint256 start, uint256 offset) external view returns (address[] memory);\\n\\n    function proxies() external view returns (address[] memory);\\n}\\n\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\\u0027s tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``\\u0027s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\\u0027s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n//import \\\"./IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver {//is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\"},\"IERC1155Views.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n/**\\n * @title IERC1155Views - An optional utility interface to improve the ERC-1155 Standard.\\n * @dev This interface introduces some additional capabilities for ERC-1155 Tokens.\\n */\\ninterface IERC1155Views {\\n\\n    /**\\n     * @dev Returns the total supply of the given token id\\n     * @param objectId the id of the token whose availability you want to know \\n     */\\n    function totalSupply(uint256 objectId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the name of the given token id\\n     * @param objectId the id of the token whose name you want to know \\n     */\\n    function name(uint256 objectId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the given token id\\n     * @param objectId the id of the token whose symbol you want to know \\n     */\\n    function symbol(uint256 objectId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals of the given token id\\n     * @param objectId the id of the token whose decimals you want to know \\n     */\\n    function decimals(uint256 objectId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the uri of the given token id\\n     * @param objectId the id of the token whose uri you want to know \\n     */\\n    function uri(uint256 objectId) external view returns (string memory);\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IERC20Data.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IBaseTokenData.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Data is IBaseTokenData, IERC20 {\\n    function decimals() external view returns (uint256);\\n}\"},\"IERC20WrapperV1.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./IEthItemModelBase.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20-Based EthItem, version 1.\\r\\n * @dev All the wrapped ERC20 Tokens will be created following this Model.\\r\\n * The minting operation can be done by calling the appropriate method given in this interface.\\r\\n * The burning operation will send back the original wrapped ERC20 amount.\\r\\n * To initalize it, the original \\u0027init(address,string,string)\\u0027\\r\\n * function of the EthItem Token Standard will be used, but the first address parameter will be the original ERC20 Source Contract to Wrap, and NOT the ERC20Model, which is always taken by the Contract who creates the Wrapper.\\r\\n */\\r\\ninterface IERC20WrapperV1 is IEthItemModelBase {\\r\\n\\r\\n    /**\\r\\n     * @param objectId the Object Id you want to know info about\\r\\n     * @return erc20TokenAddress the wrapped ERC20 Token address corresponding to the given objectId\\r\\n     */\\r\\n    function source(uint256 objectId) external view returns (address erc20TokenAddress);\\r\\n\\r\\n     /**\\r\\n     * @param erc20TokenAddress the wrapped ERC20 Token address you want to know info about\\r\\n     * @return objectId the id in the collection which correspondes to the given erc20TokenAddress\\r\\n     */\\r\\n    function object(address erc20TokenAddress) external view returns (uint256 objectId);\\r\\n\\r\\n    /**\\r\\n     * @dev Mint operation.\\r\\n     * It inhibits and bypasses the original EthItem Token Standard \\u0027mint(uint256,string)\\u0027.\\r\\n     * The logic will execute a transferFrom call to the given erc20TokenAddress to transfer the chosed amount of tokens\\r\\n     * @param erc20TokenAddress The token address to wrap.\\r\\n     * @param amount The token amount to wrap\\r\\n     *\\r\\n     * @return objectId the id given by this collection to the given erc20TokenAddress. It can be brand new if it is the first time this collection is created. Otherwhise, the firstly-created objectId value will be used.\\r\\n     * @return wrapperAddress The address ethItemERC20Wrapper generated after the creation of the returned objectId\\r\\n     */\\r\\n    function mint(address erc20TokenAddress, uint256 amount) external returns (uint256 objectId, address wrapperAddress);\\r\\n\\r\\n    function mintETH() external payable returns (uint256 objectId, address wrapperAddress);\\r\\n}\"},\"IEthItemInteroperableInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC20Data.sol\\\";\\n\\ninterface IEthItemInteroperableInterface is IERC20, IERC20Data {\\n\\n    function init(uint256 id, string calldata name, string calldata symbol, uint256 decimals) external;\\n\\n    function mainInterface() external view returns (address);\\n\\n    function objectId() external view returns (uint256);\\n\\n    function mint(address owner, uint256 amount) external;\\n\\n    function burn(address owner, uint256 amount) external;\\n\\n    function permitNonce(address sender) external view returns(uint256);\\n\\n    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\\n}\"},\"IEthItemMainInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./IERC1155Views.sol\\\";\\nimport \\\"./IEthItemInteroperableInterface.sol\\\";\\nimport \\\"./IBaseTokenData.sol\\\";\\n\\ninterface IEthItemMainInterface is IERC1155, IERC1155Views, IBaseTokenData {\\n\\n    function init(\\n        address interfaceModel,\\n        string calldata name,\\n        string calldata symbol\\n    ) external;\\n\\n    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\\n\\n    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\\n\\n    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\\n\\n    function interoperableInterfaceModel() external view returns (address, uint256);\\n\\n    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\\n\\n    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\\n\\n    function mint(uint256 amount, string calldata partialUri)\\n        external\\n        returns (uint256, address);\\n\\n    function burn(\\n        uint256 objectId,\\n        uint256 amount\\n    ) external;\\n\\n    function burnBatch(\\n        uint256[] calldata objectIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    event NewItem(uint256 indexed objectId, address indexed tokenAddress);\\n    event Mint(uint256 objectId, address tokenAddress, uint256 amount);\\n}\\n\"},\"IEthItemModelBase.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./IEthItemMainInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This interface contains the commonn data provided by all the EthItem models\\r\\n */\\r\\ninterface IEthItemModelBase is IEthItemMainInterface {\\r\\n\\r\\n    /**\\r\\n     * @dev Contract Initialization, the caller of this method should be a Contract containing the logic to provide the EthItemERC20WrapperModel to be used to create ERC20-based objectIds\\r\\n     * @param name the chosen name for this NFT\\r\\n     * @param symbol the chosen symbol (Ticker) for this NFT\\r\\n     */\\r\\n    function init(string calldata name, string calldata symbol) external;\\r\\n\\r\\n    /**\\r\\n     * @return modelVersionNumber The version number of the Model, it should be progressive\\r\\n     */\\r\\n    function modelVersion() external pure returns(uint256 modelVersionNumber);\\r\\n\\r\\n    /**\\r\\n     * @return factoryAddress the address of the Contract which initialized this EthItem\\r\\n     */\\r\\n    function factory() external view returns(address factoryAddress);\\r\\n}\"},\"IMateriaFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\ninterface IMateriaFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setDefaultMateriaFee(uint256) external;\\n\\n    function setDefaultSwapFee(uint256) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function setFees(\\n        address,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function owner() external view returns (address);\\n}\\n\"},\"IMateriaOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity 0.8.0;\\n\\nimport \\u0027./IERC1155Receiver.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\nimport \\u0027./IDoubleProxy.sol\\u0027;\\n\\ninterface IMateriaOrchestrator is IERC1155Receiver {\\n    function setDoubleProxy(address newDoubleProxy) external;\\n\\n    function setBridgeToken(address newBridgeToken) external;\\n\\n    function setErc20Wrapper(address newErc20Wrapper) external;\\n\\n    function setFactory(address newFactory) external;\\n\\n    function setEthereumObjectId(uint256 newEthereumObjectId) external;\\n\\n    function setSwapper(address _swapper) external;\\n\\n    function setLiquidityAdder(address _adder) external;\\n\\n    function setLiquidityRemover(address _remover) external;\\n\\n    function retire(address newOrchestrator) external;\\n\\n    function setFees(\\n        address token,\\n        uint256 materiaFee,\\n        uint256 swapFee\\n    ) external;\\n\\n    function setDefaultFees(uint256 materiaFee, uint256 swapFee) external;\\n\\n    function setFeeTo(address feeTo) external;\\n\\n    function getCrumbs(\\n        address token,\\n        uint256 amount,\\n        address receiver\\n    ) external;\\n\\n    function factory() external view returns (IMateriaFactory);\\n\\n    function bridgeToken() external view returns (IERC20);\\n\\n    function erc20Wrapper() external view returns (IERC20WrapperV1);\\n\\n    function ETHEREUM_OBJECT_ID() external view returns (uint256);\\n\\n    function swapper() external view returns (address);\\n\\n    function liquidityAdder() external view returns (address);\\n\\n    function liquidityRemover() external view returns (address);\\n\\n    function doubleProxy() external view returns (IDoubleProxy);\\n\\n    //Liquidity adding\\n\\n    function addLiquidity(\\n        address token,\\n        uint256 tokenAmountDesired,\\n        uint256 bridgeAmountDesired,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        uint256 bridgeAmountDesired,\\n        uint256 EthAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    //Liquidity removing\\n\\n    function removeLiquidity(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function removeLiquidityETH(\\n        uint256 liquidity,\\n        uint256 bridgeAmountMin,\\n        uint256 EthAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function removeLiquidityWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function removeLiquidityETHWithPermit(\\n        uint256 liquidity,\\n        uint256 ethAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    //Swapping\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    //Materia utilities\\n\\n    function isEthItem(address token)\\n        external\\n        view\\n        returns (\\n            address collection,\\n            bool ethItem,\\n            uint256 itemId\\n        );\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory amounts);\\n}\\n\"},\"IMateriaPair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\ninterface IMateriaPair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address,\\n        address,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function setMateriaFee(uint256 _materiaFee) external;\\n\\n    function setSwapFee(uint256 _swapFee) external;\\n\\n    function materiaFee() external view returns (uint256);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"},\"MateriaLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\n\\npragma solidity \\u003e=0.5.0;\\n\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IMateriaFactory.sol\\u0027;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\nlibrary MateriaLibrary {\\n    using SafeMath for uint256;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\u0027MateriaLibrary: IDENTICAL_ADDRESSES\\u0027);\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\u0027MateriaLibrary: ZERO_ADDRESS\\u0027);\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\u0027ff\\u0027,\\n                            factory,\\n                            keccak256(abi.encodePacked(token0, token1)),\\n                            hex\\u00271974917c1e01e6369c1b45f631eae6a71d24cb5108c460cc7f0b1c608b3a7c94\\u0027 // init code hash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IMateriaPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_AMOUNT\\u0027);\\n        require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027MateriaLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027MateriaLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i \\u003c path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027MateriaLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i \\u003e 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"},\"MateriaLiquidityRemover.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\npragma solidity 0.8.0;\\n\\nimport \\u0027./MateriaOperator.sol\\u0027;\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./IMateriaPair.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\n\\nimport \\u0027./MateriaLibrary.sol\\u0027;\\n\\ncontract MateriaLiquidityRemover is MateriaOperator {\\n    function removeLiquidity(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public ensure(deadline) returns (uint256 amountBridge, uint256 amountToken) {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address pair;\\n\\n        {\\n            (bool ethItem, uint256 itemId) = _isEthItem(token, erc20Wrapper);\\n            token = ethItem ? token : address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\\n            pair = MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), token, bridgeToken);\\n        }\\n\\n        IMateriaPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IMateriaPair(pair).burn(to);\\n        (address token0, ) = MateriaLibrary.sortTokens(token, bridgeToken);\\n        (amountBridge, amountToken) = token0 == address(bridgeToken) ? (amount0, amount1) : (amount1, amount0);\\n        require(amountBridge \\u003e= bridgeAmountMin, \\u0027INSUFFICIENT_BRIDGE_AMOUNT\\u0027);\\n        require(amountToken \\u003e= tokenAmountMin, \\u0027INSUFFICIENT_TOKEN_AMOUNT\\u0027);\\n    }\\n\\n    function removeLiquidityETH(\\n        uint256 liquidity,\\n        uint256 bridgeAmountMin,\\n        uint256 ethAmountMin,\\n        address to,\\n        uint256 deadline\\n    ) public ensure(deadline) returns (uint256 amountBridge, uint256 amountEth) {\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address ieth = _tokenToInteroperable(address(0), erc20Wrapper);\\n\\n        address pair =\\n            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), ieth, bridgeToken);\\n\\n        IMateriaPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint256 amount0, uint256 amount1) = IMateriaPair(pair).burn(address(this));\\n        (address token0, ) = MateriaLibrary.sortTokens(ieth, address(bridgeToken));\\n        (amountBridge, amountEth) = token0 == address(bridgeToken) ? (amount0, amount1) : (amount1, amount0);\\n        require(amountBridge \\u003e= bridgeAmountMin, \\u0027INSUFFICIENT_BRIDGE_AMOUNT\\u0027);\\n        require(amountEth \\u003e= ethAmountMin, \\u0027INSUFFICIENT_TOKEN_AMOUNT\\u0027);\\n        TransferHelper.safeTransfer(bridgeToken, to, amountBridge);\\n        _unwrapEth(uint256(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID()), amountEth, erc20Wrapper, to);\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n\\n        address pair = MateriaLibrary.pairFor(factory, bridgeToken, token);\\n        uint256 value = approveMax ? type(uint256).max : liquidity;\\n        IMateriaPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        removeLiquidity(token, liquidity, tokenAmountMin, bridgeAmountMin, to, deadline);\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        uint256 liquidity,\\n        uint256 tokenAmountMin,\\n        uint256 bridgeAmountMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        address factory = address(IMateriaOrchestrator(address(this)).factory());\\n        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\\n        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\\n\\n        address pair = MateriaLibrary.pairFor(factory, bridgeToken, _tokenToInteroperable(address(0), erc20Wrapper));\\n        uint256 value = approveMax ? type(uint256).max : liquidity;\\n        IMateriaPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        removeLiquidityETH(liquidity, bridgeAmountMin, tokenAmountMin, to, deadline);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) public pure override returns (bytes4) {\\n        revert();\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) public pure override returns (bytes4) {\\n        revert();\\n    }\\n\\n    function supportsInterface(bytes4) public pure override returns (bool) {\\n        return false;\\n    }\\n}\\n\"},\"MateriaOperator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL3\\npragma solidity ^0.8.0;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IMateriaOrchestrator.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\nimport \\u0027./IEthItemInteroperableInterface.sol\\u0027;\\nimport \\u0027./IERC20WrapperV1.sol\\u0027;\\n\\nabstract contract MateriaOperator is IERC1155Receiver, IERC165 {\\n    modifier ensure(uint256 deadline) {\\n        require(deadline \\u003e= block.timestamp, \\u0027Materia: Expired\\u0027);\\n        _;\\n    }\\n\\n    function _ensure(uint256 deadline) internal ensure(deadline) {}\\n\\n    function _isEthItem(address token, address wrapper) internal view returns (bool ethItem, uint256 id) {\\n        try IEthItemInteroperableInterface(token).mainInterface() {\\n            ethItem = true;\\n        } catch {\\n            ethItem = false;\\n            id = IERC20WrapperV1(wrapper).object(token);\\n        }\\n    }\\n\\n    function _wrapErc20(\\n        address token,\\n        uint256 amount,\\n        address wrapper\\n    ) internal returns (address interoperable, uint256 newAmount) {\\n        if (IERC20(token).allowance(address(this), wrapper) \\u003c amount) {\\n            IERC20(token).approve(wrapper, type(uint256).max);\\n        }\\n\\n        (uint256 id, ) = IERC20WrapperV1(wrapper).mint(token, amount);\\n\\n        newAmount = IERC20(interoperable = address(IERC20WrapperV1(wrapper).asInteroperable(id))).balanceOf(\\n            address(this)\\n        );\\n    }\\n\\n    function _unwrapErc20(\\n        uint256 id,\\n        address tokenOut,\\n        uint256 amount,\\n        address wrapper,\\n        address to\\n    ) internal {\\n        IERC20WrapperV1(wrapper).burn(id, amount);\\n        TransferHelper.safeTransfer(tokenOut, to, IERC20(tokenOut).balanceOf(address(this)));\\n    }\\n\\n    function _unwrapEth(\\n        uint256 id,\\n        uint256 amount,\\n        address wrapper,\\n        address to\\n    ) internal {\\n        IERC20WrapperV1(wrapper).burn(id, amount);\\n        TransferHelper.safeTransferETH(to, amount);\\n    }\\n\\n    function _wrapEth(uint256 amount, address wrapper) public payable returns (address interoperable) {\\n        (, interoperable) = IERC20WrapperV1(wrapper).mintETH{value: amount}();\\n    }\\n\\n    function _adjustAmount(address token, uint256 amount) internal view returns (uint256 newAmount) {\\n        newAmount = amount * (10**(18 - IERC20Data(token).decimals()));\\n    }\\n\\n    function _tokenToInteroperable(address token, address wrapper) internal view returns (address interoperable) {\\n        if (token == address(0))\\n            interoperable = address(\\n                IERC20WrapperV1(wrapper).asInteroperable(\\n                    uint256(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID())\\n                )\\n            );\\n        else {\\n            (, uint256 itemId) = _isEthItem(token, wrapper);\\n            interoperable = address(IERC20WrapperV1(wrapper).asInteroperable(itemId));\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.0;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) \\u003e= x, \\u0027ds-math-add-overflow\\u0027);\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) \\u003c= x, \\u0027ds-math-sub-underflow\\u0027);\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\u0027ds-math-mul-overflow\\u0027);\\n    }\\n}\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"}],\"name\":\"_wrapEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"interoperable\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBridge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBridge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MateriaLiquidityRemover","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://497d5ca4146cc8e3704b234a0bb1dbf9e09262f25e9f065d11d3aa492e118166"}]}