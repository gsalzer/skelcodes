{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with buidler v1.4.3 https://buidler.dev\r\n\r\n// File @openzeppelin/contracts/GSN/Context.sol@v3.1.0\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.1.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v3.1.0\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Pausable.sol@v3.1.0\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core_library/contracts/access/WhitelistedOperators.sol@v3.1.1\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\ncontract WhitelistedOperators is Ownable {\r\n\r\n    mapping(address => bool) internal _whitelistedOperators;\r\n\r\n    event WhitelistedOperator(address operator, bool enabled);\r\n\r\n    /// @notice Enable or disable address operator access\r\n    /// @param operator address that will be given/removed operator right.\r\n    /// @param enabled set whether the operator is enabled or disabled.\r\n    function whitelistOperator(address operator, bool enabled) external onlyOwner {\r\n        _whitelistedOperators[operator] = enabled;\r\n        emit WhitelistedOperator(operator, enabled);\r\n    }\r\n\r\n    /// @notice check whether address `who` is given operator rights.\r\n    /// @param who The address to query.\r\n    /// @return whether the address is whitelisted operator\r\n    function isOperator(address who) public view returns (bool) {\r\n        return _whitelistedOperators[who];\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/introspection/IERC165.sol@v3.1.0\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/introspection/ERC165.sol@v3.1.0\r\n\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v3.1.0\r\n\r\n\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-erc20_base/contracts/token/ERC20/IERC20.sol@v3.0.0\r\n\r\n/*\r\nhttps://github.com/OpenZeppelin/openzeppelin-contracts\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016-2019 zOS Global Limited\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-erc20_base/contracts/token/ERC20/IERC20Detailed.sol@v3.0.0\r\n\r\n/*\r\nhttps://github.com/OpenZeppelin/openzeppelin-contracts\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016-2019 zOS Global Limited\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n/**\r\n * @dev Interface for commonly used additional ERC20 interfaces\r\n */\r\ninterface IERC20Detailed {\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-erc20_base/contracts/token/ERC20/IERC20Allowance.sol@v3.0.0\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n/**\r\n * @dev Interface for additional ERC20 allowance features\r\n */\r\ninterface IERC20Allowance {\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-erc20_base/contracts/token/ERC20/ERC20.sol@v3.0.0\r\n\r\n/*\r\nhttps://github.com/OpenZeppelin/openzeppelin-contracts\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016-2019 zOS Global Limited\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20MinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\nabstract contract ERC20 is ERC165, Context, IERC20, IERC20Detailed, IERC20Allowance {\r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) internal _balances;\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n    uint256 internal _totalSupply;\r\n\r\n    constructor() internal {\r\n        _registerInterface(type(IERC20).interfaceId);\r\n        _registerInterface(type(IERC20Detailed).interfaceId);\r\n        _registerInterface(type(IERC20Allowance).interfaceId);\r\n\r\n        // ERC20Name interfaceId: bytes4(keccak256(\"name()\"))\r\n        _registerInterface(0x06fdde03);\r\n        // ERC20Symbol interfaceId: bytes4(keccak256(\"symbol()\"))\r\n        _registerInterface(0x95d89b41);\r\n        // ERC20Decimals interfaceId: bytes4(keccak256(\"decimals()\"))\r\n        _registerInterface(0x313ce567);\r\n    }\r\n\r\n/////////////////////////////////////////// ERC20 ///////////////////////////////////////\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n/////////////////////////////////////////// ERC20Allowance ///////////////////////////////////////\r\n\r\n    /**\r\n     * @dev See {IERC20Allowance-increaseAllowance}.\r\n     */\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) public virtual override returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Allowance-decreaseAllowance}.\r\n     */\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) public virtual override returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n/////////////////////////////////////////// Internal Functions ///////////////////////////////////////\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n/////////////////////////////////////////// Hooks ///////////////////////////////////////\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-erc20_base/contracts/token/ERC20/ERC20WithOperators.sol@v3.0.0\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\n\r\nabstract contract ERC20WithOperators is ERC20, WhitelistedOperators {\r\n\r\n    /**\r\n     * NOTICE\r\n     * This override will allow *any* whitelisted operator to be able to\r\n     * transfer unresitricted amounts of ERC20WithOperators-based tokens from 'sender'\r\n     * to 'recipient'. Care must be taken to ensure to integrity of the\r\n     * whitelisted operator list.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        address msgSender = _msgSender();\r\n\r\n        // bypass the internal allowance manipulation and checks for the\r\n        // whitelisted operator (i.e. _msgSender()). as a side-effect, the\r\n        // 'Approval' event will not be emitted since the allowance was not\r\n        // updated.\r\n        if (!isOperator(msgSender)) {\r\n            _approve(sender, msgSender, allowance(sender, msgSender).sub(amount));\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n        if (isOperator(spender)) {\r\n            // allow the front-end to determine whether or not an approval is\r\n            // necessary, given that the whitelisted operator status of the\r\n            // spender is unknown. A call to WhitelistedOperators::isOperator()\r\n            // is more direct, but we want to expose a mechanism by which to\r\n            // check through the ERC20 interface.\r\n            return type(uint256).max;\r\n        } else {\r\n            return super.allowance(owner, spender);\r\n        }\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public override returns (bool) {\r\n        if (isOperator(spender)) {\r\n            // bypass the internal allowance manipulation and checks for the\r\n            // whitelisted operator (i.e. spender). as a side-effect, the\r\n            // 'Approval' event will not be emitted since the allowance was not\r\n            // updated.\r\n            return true;\r\n        } else {\r\n            return super.increaseAllowance(spender, addedValue);\r\n        }\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override returns (bool) {\r\n        if (isOperator(spender)) {\r\n            // bypass the internal allowance manipulation and checks for the\r\n            // whitelisted operator (i.e. spender). as a side-effect, the\r\n            // 'Approval' event will not be emitted since the allowance was not\r\n            // updated.\r\n            return true;\r\n        } else {\r\n            return super.decreaseAllowance(spender, subtractedValue);\r\n        }\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal override {\r\n        if (isOperator(spender)) {\r\n            // bypass the internal allowance manipulation and checks for the\r\n            // whitelisted operator (i.e. spender). as a side-effect, the\r\n            // 'Approval' event will not be emitted since the allowance was not\r\n            // updated.\r\n            return;\r\n        } else {\r\n            super._approve(owner, spender, value);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/f1dt-ethereum-contracts/contracts/token/ERC20/REVV.sol@v1.0.0\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\n/**\r\n * @title REVV\r\n */\r\ncontract REVV is ERC20WithOperators {\r\n\r\n    string public override constant name = \"REVV\";\r\n    string public override constant symbol = \"REVV\";\r\n    uint8 public override constant decimals = 18;\r\n\r\n    constructor (\r\n        address[] memory holders,\r\n        uint256[] memory amounts\r\n    ) public ERC20WithOperators()\r\n    {\r\n        require(holders.length == amounts.length, \"REVV: wrong arguments\");\r\n        for (uint256 i = 0; i < holders.length; ++i) {\r\n            _mint(holders[i], amounts[i]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/f1dt-ethereum-contracts/contracts/game/PrePaid.sol@v1.0.0\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PrePaid contract.\r\n * Contract which manages the deposits made by wallets for pre-sale. Participants are\r\n * allowed to make deposits before the sale starts, and withdrawals after the sale ends.\r\n */\r\ncontract PrePaid is Context, Pausable, WhitelistedOperators {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Event emitted when the user deposits into their escrow balance.\r\n     * @param wallet The wallet address of the user.\r\n     * @param amount The amount added to the user's escrow balance.\r\n     */\r\n    event Deposited(\r\n        address wallet,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * Event emitted when the user withdraws from their escrow balance.\r\n     * @param wallet The wallet address of the user.\r\n     * @param amount The amount deducted from user's escrow balance.\r\n     */\r\n    event Withdrawn(\r\n        address wallet,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * Event emitted when the sale state is changed.\r\n     * @param state The sale that was set\r\n     */\r\n    event StateChanged(\r\n        uint8 state\r\n    );\r\n\r\n    uint8 public constant BEFORE_SALE_STATE = 1;\r\n    uint8 public constant SALE_START_STATE = 2;\r\n    uint8 public constant SALE_END_STATE = 3;\r\n\r\n    uint8 public state = BEFORE_SALE_STATE;\r\n    REVV public immutable revv;\r\n    uint256 public globalDeposit = 0;\r\n    uint256 public globalEarnings = 0;\r\n    mapping(address => uint256) public balanceOf; // wallet => escrowed amount\r\n\r\n    /**\r\n     * Modifier to make a function callable only when the contract is in a specific state\r\n     */\r\n    modifier whenInState(uint8 state_) {\r\n        require(state == state_, \"PrePaid: state locked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Modifier to make a function callable only by a whitelisted operator.\r\n     */\r\n    modifier onlyWhitelistedOperator() {\r\n        require(isOperator(_msgSender()), \"PrePaid: invalid operator\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if `revv_` is the zero address.\r\n     * @param revv_ The REVV token contract address.\r\n     */\r\n    constructor(\r\n        REVV revv_\r\n    ) public {\r\n        require(revv_ != REVV(0), \"PrePaid: zero address\");\r\n        revv = revv_;\r\n        _pause(); // pause on start\r\n    }\r\n\r\n    /**\r\n     * Deposits `amount` into the sender's escrow balance and updates the global deposit\r\n     * balance.\r\n     * @dev Sender should ensure that this contract has a transfer allowance of\r\n     *  at least `amount` of REVV from their account before calling this function.\r\n     * @dev Reverts if the contract is paused.\r\n     * @dev Reverts if the sale has started.\r\n     * @dev Reverts if the sale has ended.\r\n     * @dev Reverts if the deposit amount is zero.\r\n     * @dev Reverts if the updated global deposit balance overflows.\r\n     * @dev Reverts if the deposit transfer from the sender fails.\r\n     * @dev Emits the Deposited event.\r\n     * @dev An amount of REVV is transferred from the sender to this contract.\r\n     * @param amount The amount to deposit.\r\n     */\r\n    function deposit(\r\n        uint256 amount\r\n    ) external whenNotPaused whenInState(BEFORE_SALE_STATE) {\r\n        require(amount != 0, \"PrePaid: zero deposit\");\r\n        globalDeposit = globalDeposit.add(amount);\r\n        address sender = _msgSender();\r\n        uint256 newBalance = balanceOf[sender] + amount;\r\n        balanceOf[sender] = newBalance;\r\n        require(\r\n            revv.transferFrom(sender, address(this), amount),\r\n            \"PrePaid: transfer in failed\"\r\n        );\r\n        emit Deposited(sender, amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraws the remainder of the sender's escrow balance to their wallet.\r\n     * @dev Reverts if the sale has not ended.\r\n     * @dev Reverts if the sender has no balance to withdraw from.\r\n     * @dev Reverts if the transfer to the sender fails.\r\n     * @dev Emits the Withdrawn event.\r\n     * @dev An amount of REVV is transferred from the contract to sender.\r\n     */\r\n    function withdraw() external whenInState(SALE_END_STATE) {\r\n        address sender = _msgSender();\r\n        uint256 balance = balanceOf[sender];\r\n        require(balance != 0, \"PrePaid: no balance\");\r\n        require(\r\n            revv.transfer(sender, balance),\r\n            \"PrePaid: transfer out failed\"\r\n        );\r\n        balanceOf[sender] = 0;\r\n        emit Withdrawn(sender, balance);\r\n    }\r\n\r\n     /**\r\n     * Consumes a pre-paid `amount` from the specified wallet's escrow balance and\r\n     * updates the global earnings balance.\r\n     * @dev Reverts if the contract is paused.\r\n     * @dev Reverts if sale has not started.\r\n     * @dev Reverts if the sale has ended.\r\n     * @dev Reverts if called by any other than a whitelisted operator.\r\n     * @dev Reverts if the consumption amount is zero.\r\n     * @dev Reverts if the given wallet has an insufficient balance to deduct the\r\n     *  specified `amount` from.\r\n     * @dev Reverts if the updated global earnings balance overflows.\r\n     * @dev An amount of REVV is transferred from the contract to the sender.\r\n     * @param wallet The wallet from which to consume `amount` from its escrow balance.\r\n     * @param amount The amount to consume.\r\n     */\r\n    function consume(\r\n        address wallet,\r\n        uint256 amount\r\n    ) external whenNotPaused whenInState(SALE_START_STATE) onlyWhitelistedOperator {\r\n        require(amount != 0, \"PrePaid: zero amount\");\r\n        uint256 balance = balanceOf[wallet];\r\n        require(balance >= amount, \"PrePaid: insufficient funds\");\r\n        balanceOf[wallet] = balance - amount;\r\n        globalEarnings = globalEarnings.add(amount);\r\n    }\r\n\r\n    /**\r\n     * Deducts revv escrowed by wallet and deposits to operator\r\n     * @dev Reverts if the sale has not ended.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if the global earnings balance is zero.\r\n     * @dev Reverts if the transfer to the sender fails.\r\n     * @dev An amount of REVV is transferred from this contract to the sender.\r\n     */\r\n    function collectRevenue() external whenInState(SALE_END_STATE) onlyOwner {\r\n        require(globalEarnings != 0, \"PrePaid: no earnings\");\r\n        require(\r\n            revv.transfer(_msgSender(), globalEarnings),\r\n            \"PrePaid: transfer out failed\"\r\n        );\r\n        globalEarnings = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the discount percentage based on the global deposit balance.\r\n     * @return The discount percentage.\r\n     */\r\n    function getDiscount() external view returns (\r\n        uint256\r\n    ) {\r\n        uint256 value = globalDeposit;\r\n\r\n        if (value < 2e25) {\r\n            return 0;\r\n        } else if (value < 3e25) {\r\n            return 10;\r\n        } else if (value < 4e25) {\r\n            return 25;\r\n        } else {\r\n            return 50;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * Sets the sale state.\r\n    * @dev Reverts if `_state` is not one of BEFORE_SALE_STATE, SALE_START_STATE or\r\n    *   SALE_END_STATE.\r\n    * @dev Reverts if the current state is already set to `state_`.\r\n    * @param state_ The state to set. Should be one of BEFORE_SALE_STATE,\r\n    *   SALE_START_STATE or SALE_END_STATE.\r\n    * @dev Emits the StateChanged event.\r\n    */\r\n    function _setSaleState(uint8 state_) internal {\r\n        require(state_ & 0x3 != 0, \"PrePaid: invalid state\");\r\n        require(state_ != state, \"PrePaid: state already set\");\r\n        state = state_;\r\n        emit StateChanged(state_);\r\n    }\r\n\r\n    /**\r\n     * Sets the sale state.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if `_state` is not one of BEFORE_SALE_STATE, SALE_START_STATE or \r\n     *  SALE_END_STATE.\r\n     * @dev Reverts if the current state is already set to `state_`.\r\n     * @param state_ The state to set. Should be one of BEFORE_SALE_STATE,\r\n     *  SALE_START_STATE or SALE_END_STATE.\r\n     */\r\n    function setSaleState(uint8 state_) external onlyOwner {\r\n        _setSaleState(state_);\r\n    }\r\n\r\n     /**\r\n     * Sets the sale start state.\r\n     * @dev Reverts if called by any other than a whitelisted operator.\r\n     * @dev Reverts if the current state is already set to SALE_START_STATE.\r\n     */\r\n    function setSaleStart() external onlyWhitelistedOperator {\r\n        _setSaleState(SALE_START_STATE);\r\n    }\r\n\r\n     /**\r\n     * Sets the sale end state.\r\n     * @dev Reverts if called by any other than a whitelisted operator.\r\n     * @dev Reverts if the current state is already set to SALE_END_STATE.\r\n     */\r\n    function setSaleEnd() external onlyWhitelistedOperator {\r\n        _setSaleState(SALE_END_STATE);\r\n    }\r\n\r\n     /**\r\n     * Pauses the contract.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if the contract is paused.\r\n     * @dev Emits the Paused event.\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * Unpauses the contract.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if the contract is not paused.\r\n     * @dev Emits the Unpaused event.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Contracts.sol\r\n\r\n\r\n\r\npragma solidity 0.6.8;\r\n\r\n// import \"@animoca/ethereum-contracts-erc20_base/contracts/mocks/token/ERC20/ERC20Mock.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/token/ERC20/REVV.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/metadata/DeltaTimeCoreMetadata.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/token/ERC1155721/NFTRepairCentre.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/staking/DeltaTimeStakingBeta.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/sale/REVVSale.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/game/TimeTrialEliteLeague.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/sale/QualifyingGameSale.sol\";\r\n// import \"@animoca/f1dt-ethereum-contracts/contracts/token/ERC721/TrackTickets.sol\";","ABI":"[{\"inputs\":[{\"internalType\":\"contract REVV\",\"name\":\"revv_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"WhitelistedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BEFORE_SALE_STATE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_END_STATE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_START_STATE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"consume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revv\",\"outputs\":[{\"internalType\":\"contract REVV\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSaleEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSaleStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"state_\",\"type\":\"uint8\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"whitelistOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PrePaid","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000557b933a7c2c45672b610f8954a3deb39a51a8ca","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://76837e53ae3de2f335dc63db9411b9cee342d7b69eed8996a4928ce505ae018d"}]}