{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/mwilliams/Library/Mobile Documents/com~apple~CloudDocs/Projects/Qubicles/Technology/Hurricane/testing/contracts/lib/FeeHelpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary FeeHelpers {\\n    using SafeMath for uint256;\\n    \\n    function getClaimBurnFee(uint256 lastStakedTimestamp, uint256 claimBurnFee) public view returns (uint256) {\\n        uint256 base = 1;\\n\\n        if (block.timestamp < lastStakedTimestamp + 1 days) {\\n            return base.mul(100).div(25);\\n        } else if (block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(20);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days) {\\n            return base.mul(100).div(10);\\n        } else if (block.timestamp < lastStakedTimestamp + 4 days) {\\n            return base.mul(100).div(5);\\n        } else {\\n            return base.mul(100).div(claimBurnFee);\\n        }\\n    }\\n\\n    function getClaimTreasuryFee(uint256 lastStakedTimestamp, uint256 claimTreasuryFeePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n\\n        if (block.timestamp < lastStakedTimestamp + 1 days) {\\n            return base.mul(100).div(9);\\n        } else if (block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(8);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days || block.timestamp < lastStakedTimestamp + 4 days) {\\n            return base.mul(100).div(5);\\n        } else if (block.timestamp > lastStakedTimestamp + 4 days && block.timestamp < lastStakedTimestamp + 29 days) {\\n            return base.mul(100).div(4);\\n        } else {\\n            return base.mul(100).div(claimTreasuryFeePercent);\\n        }\\n    }\\n\\n    function getClaimLPFee(uint256 lastStakedTimestamp, uint256 claimLPFeePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n\\n        if (block.timestamp < lastStakedTimestamp + 1 days) {\\n            return base.mul(100).div(15);\\n        } else if (block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(12);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days || block.timestamp < lastStakedTimestamp + 4 days) {\\n            return base.mul(100).div(10);\\n        } else if (block.timestamp > lastStakedTimestamp + 4 days && block.timestamp < lastStakedTimestamp + 29 days) {\\n            return base.mul(100).div(5);\\n        } else {\\n            return base.mul(100).div(claimLPFeePercent);\\n        }\\n    }\\n    \\n    function getClaimLiquidBalancePcnt(uint256 lastStakedTimestamp, uint256 claimLiquidBalancePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n\\n        if (block.timestamp < lastStakedTimestamp + 1 days) {\\n            return base.mul(100).div(1);\\n        } else if (block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(10);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days) {\\n            return base.mul(100).div(15);\\n        } else if (block.timestamp > lastStakedTimestamp + 3 days && block.timestamp < lastStakedTimestamp + 29 days) {\\n            return base.mul(100).div(20);\\n        } else {\\n            return base.mul(100).div(claimLiquidBalancePercent);\\n        }\\n    }\\n\\n    function getUnstakeBurnFee(uint256 lastStakedTimestamp, uint256 unstakeBurnFeePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n\\n        if (block.timestamp < lastStakedTimestamp + 1 days || block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(25);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days) {\\n            return base.mul(100).div(20);\\n        } else if (block.timestamp < lastStakedTimestamp + 4 days) {\\n            return base.mul(100).div(15);\\n        } else if (block.timestamp > lastStakedTimestamp + 4 days && block.timestamp < lastStakedTimestamp + 29 days) {\\n            return base.mul(100).div(5);\\n        } else {\\n            return base.mul(100).div(unstakeBurnFeePercent);\\n        }\\n    }\\n\\n    function getUnstakeTreasuryFee(uint256 lastStakedTimestamp, uint256 unstakeTreasuryFeePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n\\n        if (block.timestamp < lastStakedTimestamp + 1 days || block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(25);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days) {\\n            return base.mul(100).div(20);\\n        } else if (block.timestamp < lastStakedTimestamp + 4 days) {\\n            return base.mul(100).div(15);\\n        } else if (block.timestamp > lastStakedTimestamp + 4 days && block.timestamp < lastStakedTimestamp + 29 days) {\\n            return base.mul(100).div(5);\\n        } else {\\n            return base.mul(100).div(unstakeTreasuryFeePercent);\\n        }\\n    }\\n    \\n    function getUnstakeLPFee(uint256 lastStakedTimestamp, uint256 unstakeLPFeePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n        if (block.timestamp < lastStakedTimestamp + 1 days || block.timestamp < lastStakedTimestamp + 2 days) {\\n            return base.mul(100).div(25);\\n        } else if (block.timestamp < lastStakedTimestamp + 3 days) {\\n            return base.mul(100).div(20);\\n        } else if (block.timestamp < lastStakedTimestamp + 4 days) {\\n            return base.mul(100).div(15);\\n        } else if (block.timestamp > lastStakedTimestamp + 4 days && block.timestamp < lastStakedTimestamp + 29 days) {\\n            return base.mul(100).div(10);\\n        } else {\\n            return base.mul(100).div(unstakeLPFeePercent);\\n        }\\n    }\\n\\n    function getKatrinaExitFee(uint256 farmingStartTimestamp, uint256 katrinaExitFeePercent) public view returns (uint256) {\\n        uint256 base = 1;\\n        if (block.timestamp < farmingStartTimestamp + 29 days) {\\n            return 25;\\n        } else {\\n            return base.mul(100).div(katrinaExitFeePercent);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/mwilliams/Library/Mobile Documents/com~apple~CloudDocs/Projects/Qubicles/Technology/Hurricane/testing/contracts/lib/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n\\n// File: @openzeppelin/contracts/math/Math.sol\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/mwilliams/Library/Mobile Documents/com~apple~CloudDocs/Projects/Qubicles/Technology/Hurricane/testing/contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n\\n// File: @openzeppelin/contracts/math/SafeMath.sol\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimBurnFee\",\"type\":\"uint256\"}],\"name\":\"getClaimBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimLPFeePercent\",\"type\":\"uint256\"}],\"name\":\"getClaimLPFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimLiquidBalancePercent\",\"type\":\"uint256\"}],\"name\":\"getClaimLiquidBalancePcnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTreasuryFeePercent\",\"type\":\"uint256\"}],\"name\":\"getClaimTreasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"farmingStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"katrinaExitFeePercent\",\"type\":\"uint256\"}],\"name\":\"getKatrinaExitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeBurnFeePercent\",\"type\":\"uint256\"}],\"name\":\"getUnstakeBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeLPFeePercent\",\"type\":\"uint256\"}],\"name\":\"getUnstakeLPFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTreasuryFeePercent\",\"type\":\"uint256\"}],\"name\":\"getUnstakeTreasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FeeHelpers","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}