{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PauserRole\r\n * @dev Pausers are responsible for pausing/unpausing transfers.\r\n */\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed token, address indexed account);\r\n    event PauserRemoved(address indexed token, address indexed account);\r\n\r\n    // Mapping from token to token pausers.\r\n    mapping(address => Roles.Role) private _pausers;\r\n\r\n    constructor () internal {}\r\n\r\n    modifier onlyPauser(address token) {\r\n        require(isPauser(token, msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address token, address account) public view returns (bool) {\r\n        return _pausers[token].has(account);\r\n    }\r\n\r\n    function addPauser(address token, address account) public onlyPauser(token) {\r\n        _addPauser(token, account);\r\n    }\r\n\r\n    function renouncePauser(address token) public {\r\n        _removePauser(token, msg.sender);\r\n    }\r\n\r\n    function _addPauser(address token, address account) internal {\r\n        _pausers[token].add(account);\r\n        emit PauserAdded(token, account);\r\n    }\r\n\r\n    function _removePauser(address token, address account) internal {\r\n        _pausers[token].remove(account);\r\n        emit PauserRemoved(token, account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address indexed token, address account);\r\n    event Unpaused(address indexed token, address account);\r\n\r\n    // Mapping from token to token paused status.\r\n    mapping(address => bool) private _paused;\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused(address token) public view returns (bool) {\r\n        return _paused[token];\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused(address token) {\r\n        require(!_paused[token]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused(address token) {\r\n        require(_paused[token]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause(address token) public onlyPauser(token) whenNotPaused(token) {\r\n        _paused[token] = true;\r\n        emit Paused(token, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause(address token) public onlyPauser(token) whenPaused(token) {\r\n        _paused[token] = false;\r\n        emit Unpaused(token, msg.sender);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AllowlistAdminRole\r\n * @dev AllowlistAdmins are responsible for assigning and removing Allowlisted accounts.\r\n */\r\ncontract AllowlistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event AllowlistAdminAdded(address indexed token, address indexed account);\r\n    event AllowlistAdminRemoved(address indexed token, address indexed account);\r\n\r\n    // Mapping from token to token allowlist admins.\r\n    mapping(address => Roles.Role) private _allowlistAdmins;\r\n\r\n    constructor () internal {}\r\n\r\n    modifier onlyAllowlistAdmin(address token) {\r\n        require(isAllowlistAdmin(token, msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isAllowlistAdmin(address token, address account) public view returns (bool) {\r\n        return _allowlistAdmins[token].has(account);\r\n    }\r\n\r\n    function addAllowlistAdmin(address token, address account) public onlyAllowlistAdmin(token) {\r\n        _addAllowlistAdmin(token, account);\r\n    }\r\n\r\n    function renounceAllowlistAdmin(address token) public {\r\n        _removeAllowlistAdmin(token, msg.sender);\r\n    }\r\n\r\n    function _addAllowlistAdmin(address token, address account) internal {\r\n        _allowlistAdmins[token].add(account);\r\n        emit AllowlistAdminAdded(token, account);\r\n    }\r\n\r\n    function _removeAllowlistAdmin(address token, address account) internal {\r\n        _allowlistAdmins[token].remove(account);\r\n        emit AllowlistAdminRemoved(token, account);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AllowlistedRole\r\n * @dev Allowlisted accounts have been forbidden by a AllowlistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are AllowlistAdmins (who can also remove\r\n * it), and not Allowlisteds themselves.\r\n */\r\ncontract AllowlistedRole is AllowlistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event AllowlistedAdded(address indexed token, address indexed account);\r\n    event AllowlistedRemoved(address indexed token, address indexed account);\r\n\r\n    // Mapping from token to token allowlisteds.\r\n    mapping(address => Roles.Role) private _allowlisteds;\r\n\r\n    modifier onlyNotAllowlisted(address token) {\r\n        require(!isAllowlisted(token, msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isAllowlisted(address token, address account) public view returns (bool) {\r\n        return _allowlisteds[token].has(account);\r\n    }\r\n\r\n    function addAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\r\n        _addAllowlisted(token, account);\r\n    }\r\n\r\n    function removeAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\r\n        _removeAllowlisted(token, account);\r\n    }\r\n\r\n    function _addAllowlisted(address token, address account) internal {\r\n        _allowlisteds[token].add(account);\r\n        emit AllowlistedAdded(token, account);\r\n    }\r\n\r\n    function _removeAllowlisted(address token, address account) internal {\r\n        _allowlisteds[token].remove(account);\r\n        emit AllowlistedRemoved(token, account);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BlocklistAdminRole\r\n * @dev BlocklistAdmins are responsible for assigning and removing Blocklisted accounts.\r\n */\r\ncontract BlocklistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event BlocklistAdminAdded(address indexed token, address indexed account);\r\n    event BlocklistAdminRemoved(address indexed token, address indexed account);\r\n\r\n    // Mapping from token to token blocklist admins.\r\n    mapping(address => Roles.Role) private _blocklistAdmins;\r\n\r\n    constructor () internal {}\r\n\r\n    modifier onlyBlocklistAdmin(address token) {\r\n        require(isBlocklistAdmin(token, msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isBlocklistAdmin(address token, address account) public view returns (bool) {\r\n        return _blocklistAdmins[token].has(account);\r\n    }\r\n\r\n    function addBlocklistAdmin(address token, address account) public onlyBlocklistAdmin(token) {\r\n        _addBlocklistAdmin(token, account);\r\n    }\r\n\r\n    function renounceBlocklistAdmin(address token) public {\r\n        _removeBlocklistAdmin(token, msg.sender);\r\n    }\r\n\r\n    function _addBlocklistAdmin(address token, address account) internal {\r\n        _blocklistAdmins[token].add(account);\r\n        emit BlocklistAdminAdded(token, account);\r\n    }\r\n\r\n    function _removeBlocklistAdmin(address token, address account) internal {\r\n        _blocklistAdmins[token].remove(account);\r\n        emit BlocklistAdminRemoved(token, account);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BlocklistedRole\r\n * @dev Blocklisted accounts have been forbidden by a BlocklistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are BlocklistAdmins (who can also remove\r\n * it), and not Blocklisteds themselves.\r\n */\r\ncontract BlocklistedRole is BlocklistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event BlocklistedAdded(address indexed token, address indexed account);\r\n    event BlocklistedRemoved(address indexed token, address indexed account);\r\n\r\n    // Mapping from token to token blocklisteds.\r\n    mapping(address => Roles.Role) private _blocklisteds;\r\n\r\n    modifier onlyNotBlocklisted(address token) {\r\n        require(!isBlocklisted(token, msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isBlocklisted(address token, address account) public view returns (bool) {\r\n        return _blocklisteds[token].has(account);\r\n    }\r\n\r\n    function addBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\r\n        _addBlocklisted(token, account);\r\n    }\r\n\r\n    function removeBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\r\n        _removeBlocklisted(token, account);\r\n    }\r\n\r\n    function _addBlocklisted(address token, address account) internal {\r\n        _blocklisteds[token].add(account);\r\n        emit BlocklistedAdded(token, account);\r\n    }\r\n\r\n    function _removeBlocklisted(address token, address account) internal {\r\n        _blocklisteds[token].remove(account);\r\n        emit BlocklistedRemoved(token, account);\r\n    }\r\n}\r\n\r\ncontract ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns (address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\ncontract ERC1820Implementer {\r\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n  mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    if(_interfaceHashes[interfaceHash]) {\r\n      return ERC1820_ACCEPT_MAGIC;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  function _setInterface(string memory interfaceLabel) internal {\r\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400 security token standard\r\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\r\n */\r\ninterface IERC1400 /*is IERC20*/ { // Interfaces can currently not inherit interfaces, but IERC1400 shall include IERC20\r\n\r\n  // ****************** Document Management *******************\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32);\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\r\n\r\n  // ******************* Token Information ********************\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\r\n\r\n  // *********************** Transfers ************************\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\r\n\r\n  // *************** Partition Token Transfers ****************\r\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\r\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\r\n\r\n  // ****************** Controller Operation ******************\r\n  function isControllable() external view returns (bool);\r\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\r\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\r\n\r\n  // ****************** Operator Management *******************\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\r\n\r\n  // ****************** Operator Information ******************\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\r\n\r\n  // ********************* Token Issuance *********************\r\n  function isIssuable() external view returns (bool);\r\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\r\n\r\n  // ******************** Token Redemption ********************\r\n  function redeem(uint256 value, bytes calldata data) external;\r\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\r\n\r\n  // ******************* Transfer Validity ********************\r\n  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\r\n  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\r\n  //\r\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \r\n\r\n  // ******************* Controller Events ********************\r\n  // We don't use this event as we don't use \"controllerTransfer\"\r\n  //   event ControllerTransfer(\r\n  //       address controller,\r\n  //       address indexed from,\r\n  //       address indexed to,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n  //\r\n  // We don't use this event as we don't use \"controllerRedeem\"\r\n  //   event ControllerRedemption(\r\n  //       address controller,\r\n  //       address indexed tokenHolder,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n\r\n  // ******************** Document Events *********************\r\n  event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n  // ******************** Transfer Events *********************\r\n  event TransferByPartition(\r\n      bytes32 indexed fromPartition,\r\n      address operator,\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 value,\r\n      bytes data,\r\n      bytes operatorData\r\n  );\r\n\r\n  event ChangedPartition(\r\n      bytes32 indexed fromPartition,\r\n      bytes32 indexed toPartition,\r\n      uint256 value\r\n  );\r\n\r\n  // ******************** Operator Events *********************\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n  // ************** Issuance / Redemption Events **************\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\r\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC-1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n * \r\n * Code\tReason\r\n * 0x50\ttransfer failure\r\n * 0x51\ttransfer success\r\n * 0x52\tinsufficient balance\r\n * 0x53\tinsufficient allowance\r\n * 0x54\ttransfers halted (contract paused)\r\n * 0x55\tfunds locked (lockup period)\r\n * 0x56\tinvalid sender\r\n * 0x57\tinvalid receiver\r\n * 0x58\tinvalid operator (transfer agent)\r\n * 0x59\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5c\t\r\n * 0x5d\t\r\n * 0x5e\t\r\n * 0x5f\ttoken meta or info\r\n *\r\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\r\n */\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensValidator\r\n * @dev ERC1400TokensValidator interface\r\n */\r\ninterface IERC1400TokensValidator {\r\n\r\n  function canValidate(\r\n    address token,\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToValidate(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Interface to the Minterrole contract\r\n */\r\ninterface IMinterRole {\r\n  function isMinter(address account) external view returns (bool);\r\n}\r\n\r\n\r\ncontract ERC1400TokensValidator is IERC1400TokensValidator, Pausable, AllowlistedRole, BlocklistedRole, ERC1820Client, ERC1820Implementer {\r\n  using SafeMath for uint256;\r\n\r\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\r\n\r\n  bytes4 constant internal ERC20_TRANSFER_FUNCTION_ID = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n  bytes4 constant internal ERC20_TRANSFERFROM_FUNCTION_ID = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n  // Mapping from token to allowlist activation status.\r\n  mapping(address => bool) internal _allowlistActivated;\r\n\r\n  // Mapping from token to blocklist activation status.\r\n  mapping(address => bool) internal _blocklistActivated;\r\n\r\n  // Mapping from token to partition granularity activation status.\r\n  mapping(address => bool) internal _granularityByPartitionActivated;\r\n\r\n  // Mapping from token to holds activation status.\r\n  mapping(address => bool) internal _holdsActivated;\r\n\r\n  // Mapping from token to self-holds activation status.\r\n  mapping(address => bool) internal _selfHoldsActivated;\r\n\r\n  // Mapping from token to token controllers.\r\n  mapping(address => address[]) internal _tokenControllers;\r\n\r\n  // Mapping from (token, operator) to token controller status.\r\n  mapping(address => mapping(address => bool)) internal _isTokenController;\r\n\r\n  enum HoldStatusCode {\r\n    Nonexistent,\r\n    Ordered,\r\n    Executed,\r\n    ExecutedAndKeptOpen,\r\n    ReleasedByNotary,\r\n    ReleasedByPayee,\r\n    ReleasedOnExpiration\r\n  }\r\n\r\n  struct Hold {\r\n    bytes32 partition;\r\n    address sender;\r\n    address recipient;\r\n    address notary;\r\n    uint256 value;\r\n    uint256 expiration;\r\n    bytes32 secretHash;\r\n    bytes32 secret;\r\n    HoldStatusCode status;\r\n  }\r\n\r\n  // Mapping from (token, partition) to partition granularity.\r\n  mapping(address => mapping(bytes32 => uint256)) internal _granularityByPartition;\r\n  \r\n  // Mapping from (token, holdId) to hold.\r\n  mapping(address => mapping(bytes32 => Hold)) internal _holds;\r\n\r\n  // Mapping from (token, tokenHolder) to balance on hold.\r\n  mapping(address => mapping(address => uint256)) internal _heldBalance;\r\n\r\n  // Mapping from (token, tokenHolder, partition) to balance on hold of corresponding partition.\r\n  mapping(address => mapping(address => mapping(bytes32 => uint256))) internal _heldBalanceByPartition;\r\n\r\n  // Mapping from (token, partition) to global balance on hold of corresponding partition.\r\n  mapping(address => mapping(bytes32 => uint256)) internal _totalHeldBalanceByPartition;\r\n\r\n  // Total balance on hold.\r\n  mapping(address => uint256) internal _totalHeldBalance;\r\n\r\n  // Mapping from hold parameter's hash to hold's nonce.\r\n  mapping(bytes32 => uint256) internal _hashNonce;\r\n\r\n  // Mapping from (hash, nonce) to hold ID.\r\n  mapping(bytes32 => mapping(uint256 => bytes32)) internal _holdIds;\r\n\r\n  event HoldCreated(\r\n    address indexed token,\r\n    bytes32 indexed holdId,\r\n    bytes32 partition,\r\n    address sender,\r\n    address recipient,\r\n    address indexed notary,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 secretHash\r\n  );\r\n  event HoldReleased(address indexed token, bytes32 holdId, address indexed notary, HoldStatusCode status);\r\n  event HoldRenewed(address indexed token, bytes32 holdId, address indexed notary, uint256 oldExpiration, uint256 newExpiration);\r\n  event HoldExecuted(address indexed token, bytes32 holdId, address indexed notary, uint256 heldValue, uint256 transferredValue, bytes32 secret);\r\n  event HoldExecutedAndKeptOpen(address indexed token, bytes32 holdId, address indexed notary, uint256 heldValue, uint256 transferredValue, bytes32 secret);\r\n  \r\n  /**\r\n   * @dev Modifier to verify if sender is a token controller.\r\n   */\r\n  modifier onlyTokenController(address token) {\r\n    require(\r\n      msg.sender == token ||\r\n      msg.sender == Ownable(token).owner() ||\r\n      _isTokenController[token][msg.sender],\r\n      \"Sender is not a token controller.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to verify if sender is a pauser.\r\n   */\r\n  modifier onlyPauser(address token) {\r\n    require(\r\n      msg.sender == Ownable(token).owner() ||\r\n      _isTokenController[token][msg.sender] ||\r\n      isPauser(token, msg.sender),\r\n      \"Sender is not a pauser\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to verify if sender is an allowlist admin.\r\n   */\r\n  modifier onlyAllowlistAdmin(address token) {\r\n    require(\r\n      msg.sender == Ownable(token).owner() ||\r\n      _isTokenController[token][msg.sender] ||\r\n      isAllowlistAdmin(token, msg.sender),\r\n      \"Sender is not an allowlist admin\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to verify if sender is a blocklist admin.\r\n   */\r\n  modifier onlyBlocklistAdmin(address token) {\r\n    require(\r\n      msg.sender == Ownable(token).owner() ||\r\n      _isTokenController[token][msg.sender] ||\r\n      isBlocklistAdmin(token, msg.sender),\r\n      \"Sender is not a blocklist admin\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    ERC1820Implementer._setInterface(ERC1400_TOKENS_VALIDATOR);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the list of token controllers for a given token.\r\n   * @return Setup of a given token.\r\n   */\r\n  function retrieveTokenSetup(address token) external view returns (bool, bool, bool, bool, bool, address[] memory) {\r\n    return (\r\n      _allowlistActivated[token],\r\n      _blocklistActivated[token],\r\n      _granularityByPartitionActivated[token],\r\n      _holdsActivated[token],\r\n      _selfHoldsActivated[token],\r\n      _tokenControllers[token]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Register token setup.\r\n   */\r\n  function registerTokenSetup(\r\n    address token,\r\n    bool allowlistActivated,\r\n    bool blocklistActivated,\r\n    bool granularityByPartitionActivated,\r\n    bool holdsActivated,\r\n    bool selfHoldsActivated,\r\n    address[] calldata operators\r\n  ) external onlyTokenController(token) {\r\n    _allowlistActivated[token] = allowlistActivated;\r\n    _blocklistActivated[token] = blocklistActivated;\r\n    _granularityByPartitionActivated[token] = granularityByPartitionActivated;\r\n    _holdsActivated[token] = holdsActivated;\r\n    _selfHoldsActivated[token] = selfHoldsActivated;\r\n    _setTokenControllers(token, operators);\r\n  }\r\n\r\n  /**\r\n   * @dev Set list of token controllers for a given token.\r\n   * @param token Token address.\r\n   * @param operators Operators addresses.\r\n   */\r\n  function _setTokenControllers(address token, address[] memory operators) internal {\r\n    for (uint i = 0; i<_tokenControllers[token].length; i++){\r\n      _isTokenController[token][_tokenControllers[token][i]] = false;\r\n    }\r\n    for (uint j = 0; j<operators.length; j++){\r\n      _isTokenController[token][operators[j]] = true;\r\n    }\r\n    _tokenControllers[token] = operators;\r\n  }\r\n\r\n  /**\r\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\r\n   * @param token Address of the token.\r\n   * @param functionSig ID of the function that is called.\r\n   * @param partition Name of the partition (left empty for ERC20 transfer).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   * @return 'true' if the token transfer can be validated, 'false' if not.\r\n   */\r\n  function canValidate(\r\n    address token,\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view \r\n    returns(bool)\r\n  {\r\n    (bool canValidateToken,) = _canValidate(token, functionSig, partition, operator, from, to, value, data, operatorData);\r\n    return canValidateToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Function called by the token contract before executing a transfer.\r\n   * @param functionSig ID of the function that is called.\r\n   * @param partition Name of the partition (left empty for ERC20 transfer).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   * @return 'true' if the token transfer can be validated, 'false' if not.\r\n   */\r\n  function tokensToValidate(\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n  {\r\n    (bool canValidateToken, bytes32 holdId) = _canValidate(msg.sender, functionSig, partition, operator, from, to, value, data, operatorData);\r\n    require(canValidateToken, \"55\"); // 0x55\tfunds locked (lockup period)\r\n\r\n    if (_holdsActivated[msg.sender] && holdId != \"\") {\r\n      Hold storage executableHold = _holds[msg.sender][holdId];\r\n      _setHoldToExecuted(\r\n        msg.sender,\r\n        executableHold,\r\n        holdId,\r\n        value,\r\n        executableHold.value,\r\n        \"\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\r\n   * @return 'true' if the token transfer can be validated, 'false' if not.\r\n   * @return hold ID in case a hold can be executed for the given parameters.\r\n   */\r\n  function _canValidate(\r\n    address token,\r\n    bytes4 functionSig,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes memory /*data*/,\r\n    bytes memory /*operatorData*/\r\n  ) // Comments to avoid compilation warnings for unused variables.\r\n    internal\r\n    view\r\n    whenNotPaused(token)\r\n    returns(bool, bytes32)\r\n  {\r\n    if(_functionRequiresValidation(functionSig)) {\r\n      if(_allowlistActivated[token]) {\r\n        if(!isAllowlisted(token, from) || !isAllowlisted(token, to)) {\r\n          return (false, \"\");\r\n        }\r\n      }\r\n      if(_blocklistActivated[token]) {\r\n        if(isBlocklisted(token, from) || isBlocklisted(token, to)) {\r\n          return (false, \"\");\r\n        }\r\n      }\r\n    }\r\n\r\n    if(_granularityByPartitionActivated[token]) {\r\n      if(\r\n        _granularityByPartition[token][partition] > 0 &&\r\n        !_isMultiple(_granularityByPartition[token][partition], value)\r\n      ) {\r\n        return (false, \"\");\r\n      } \r\n    }\r\n\r\n    if (_holdsActivated[token]) {\r\n      if(functionSig == ERC20_TRANSFERFROM_FUNCTION_ID) {\r\n        (,, bytes32 holdId) = _retrieveHoldHashNonceId(token, partition, operator, from, to, value);\r\n        Hold storage hold = _holds[token][holdId];\r\n        \r\n        if (_holdCanBeExecutedAsNotary(hold, operator, value) && value <= IERC1400(token).balanceOfByPartition(partition, from)) {\r\n          return (true, holdId);\r\n        }\r\n      }\r\n      \r\n      if(value > _spendableBalanceOfByPartition(token, partition, from)) {\r\n        return (false, \"\");\r\n      }\r\n    }\r\n    \r\n    return (true, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Get granularity for a given partition.\r\n   * @param token Address of the token.\r\n   * @param partition Name of the partition.\r\n   * @return Granularity of the partition.\r\n   */\r\n  function granularityByPartition(address token, bytes32 partition) external view returns (uint256) {\r\n    return _granularityByPartition[token][partition];\r\n  }\r\n  \r\n  /**\r\n   * @dev Set partition granularity\r\n   */\r\n  function setGranularityByPartition(\r\n    address token,\r\n    bytes32 partition,\r\n    uint256 granularity\r\n  )\r\n    external\r\n    onlyTokenController(token)\r\n  {\r\n    _granularityByPartition[token][partition] = granularity;\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token pre-hold.\r\n   */\r\n  function preHoldFor(\r\n    address token,\r\n    bytes32 holdId,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 timeToExpiration,\r\n    bytes32 secretHash\r\n  )\r\n    external\r\n    returns (bool)\r\n  {\r\n    return _createHold(\r\n      token,\r\n      holdId,\r\n      address(0),\r\n      recipient,\r\n      notary,\r\n      partition,\r\n      value,\r\n      _computeExpiration(timeToExpiration),\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token pre-hold with expiration date.\r\n   */\r\n  function preHoldForWithExpirationDate(\r\n    address token,\r\n    bytes32 holdId,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 secretHash\r\n  )\r\n    external\r\n    returns (bool)\r\n  {\r\n    _checkExpiration(expiration);\r\n\r\n    return _createHold(\r\n      token,\r\n      holdId,\r\n      address(0),\r\n      recipient,\r\n      notary,\r\n      partition,\r\n      value,\r\n      expiration,\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token hold.\r\n   */\r\n  function hold(\r\n    address token,\r\n    bytes32 holdId,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 timeToExpiration,\r\n    bytes32 secretHash\r\n  ) \r\n    external\r\n    returns (bool)\r\n  {\r\n    return _createHold(\r\n      token,\r\n      holdId,\r\n      msg.sender,\r\n      recipient,\r\n      notary,\r\n      partition,\r\n      value,\r\n      _computeExpiration(timeToExpiration),\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token hold on behalf of the token holder.\r\n   */\r\n  function holdFrom(\r\n    address token,\r\n    bytes32 holdId,\r\n    address sender,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 timeToExpiration,\r\n    bytes32 secretHash\r\n  )\r\n    external\r\n    returns (bool)\r\n  {\r\n    require(sender != address(0), \"Payer address must not be zero address\");\r\n    return _createHold(\r\n      token,\r\n      holdId,\r\n      sender,\r\n      recipient,\r\n      notary,\r\n      partition,\r\n      value,\r\n      _computeExpiration(timeToExpiration),\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token hold with expiration date.\r\n   */\r\n  function holdWithExpirationDate(\r\n    address token,\r\n    bytes32 holdId,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 secretHash\r\n  )\r\n    external\r\n    returns (bool)\r\n  {\r\n    _checkExpiration(expiration);\r\n\r\n    return _createHold(\r\n      token,\r\n      holdId,\r\n      msg.sender,\r\n      recipient,\r\n      notary,\r\n      partition,\r\n      value,\r\n      expiration,\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token hold with expiration date on behalf of the token holder.\r\n   */\r\n  function holdFromWithExpirationDate(\r\n    address token,\r\n    bytes32 holdId,\r\n    address sender,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 secretHash\r\n  )\r\n    external\r\n    returns (bool)\r\n  {\r\n    _checkExpiration(expiration);\r\n    require(sender != address(0), \"Payer address must not be zero address\");\r\n\r\n    return _createHold(\r\n      token,\r\n      holdId,\r\n      sender,\r\n      recipient,\r\n      notary,\r\n      partition,\r\n      value,\r\n      expiration,\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new token hold.\r\n   */\r\n  function _createHold(\r\n    address token,\r\n    bytes32 holdId,\r\n    address sender,\r\n    address recipient,\r\n    address notary,\r\n    bytes32 partition,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 secretHash\r\n  ) internal returns (bool)\r\n  {\r\n    Hold storage newHold = _holds[token][holdId];\r\n\r\n    require(recipient != address(0), \"Payee address must not be zero address\");\r\n    require(value != 0, \"Value must be greater than zero\");\r\n    require(newHold.value == 0, \"This holdId already exists\");\r\n    require(notary != address(0), \"Notary address must not be zero address\");\r\n    \r\n    if (sender == address(0)) { // pre-hold (tokens do not already exist)\r\n      require(\r\n        _canPreHold(token, msg.sender),\r\n        \"The pre-hold can only be created by the minter\"\r\n      );\r\n    } else { // post-hold (tokens already exist)\r\n      require(value <= _spendableBalanceOfByPartition(token, partition, sender), \"Amount of the hold can't be greater than the spendable balance of the sender\");\r\n      require(\r\n        _canPostHold(token, partition, msg.sender, sender),\r\n        \"The hold can only be renewed by the issuer or the payer\"\r\n      );\r\n    }\r\n    \r\n    newHold.partition = partition;\r\n    newHold.sender = sender;\r\n    newHold.recipient = recipient;\r\n    newHold.notary = notary;\r\n    newHold.value = value;\r\n    newHold.expiration = expiration;\r\n    newHold.secretHash = secretHash;\r\n    newHold.status = HoldStatusCode.Ordered;\r\n\r\n    if(sender != address(0)) {\r\n      // In case tokens already exist, increase held balance\r\n      _increaseHeldBalance(token, newHold, holdId);\r\n    }\r\n\r\n    emit HoldCreated(\r\n      token,\r\n      holdId,\r\n      partition,\r\n      sender,\r\n      recipient,\r\n      notary,\r\n      value,\r\n      expiration,\r\n      secretHash\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Release token hold.\r\n   */\r\n  function releaseHold(address token, bytes32 holdId) external returns (bool) {\r\n    return _releaseHold(token, holdId);\r\n  }\r\n\r\n  /**\r\n   * @dev Release token hold.\r\n   */\r\n  function _releaseHold(address token, bytes32 holdId) internal returns (bool) {\r\n    Hold storage releasableHold = _holds[token][holdId];\r\n\r\n    require(\r\n        releasableHold.status == HoldStatusCode.Ordered || releasableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\r\n        \"A hold can only be released in status Ordered or ExecutedAndKeptOpen\"\r\n    );\r\n    require(\r\n        _isExpired(releasableHold.expiration) ||\r\n        (msg.sender == releasableHold.notary) ||\r\n        (msg.sender == releasableHold.recipient),\r\n        \"A not expired hold can only be released by the notary or the payee\"\r\n    );\r\n\r\n    if (_isExpired(releasableHold.expiration)) {\r\n        releasableHold.status = HoldStatusCode.ReleasedOnExpiration;\r\n    } else {\r\n        if (releasableHold.notary == msg.sender) {\r\n            releasableHold.status = HoldStatusCode.ReleasedByNotary;\r\n        } else {\r\n            releasableHold.status = HoldStatusCode.ReleasedByPayee;\r\n        }\r\n    }\r\n\r\n    if(releasableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\r\n      _decreaseHeldBalance(token, releasableHold, releasableHold.value);\r\n    }\r\n\r\n    emit HoldReleased(token, holdId, releasableHold.notary, releasableHold.status);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Renew hold.\r\n   */\r\n  function renewHold(address token, bytes32 holdId, uint256 timeToExpiration) external returns (bool) {\r\n    return _renewHold(token, holdId, _computeExpiration(timeToExpiration));\r\n  }\r\n\r\n  /**\r\n   * @dev Renew hold with expiration time.\r\n   */\r\n  function renewHoldWithExpirationDate(address token, bytes32 holdId, uint256 expiration) external returns (bool) {\r\n    _checkExpiration(expiration);\r\n\r\n    return _renewHold(token, holdId, expiration);\r\n  }\r\n\r\n  /**\r\n   * @dev Renew hold.\r\n   */\r\n  function _renewHold(address token, bytes32 holdId, uint256 expiration) internal returns (bool) {\r\n    Hold storage renewableHold = _holds[token][holdId];\r\n\r\n    require(\r\n      renewableHold.status == HoldStatusCode.Ordered\r\n      || renewableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\r\n      \"A hold can only be renewed in status Ordered or ExecutedAndKeptOpen\"\r\n    );\r\n    require(!_isExpired(renewableHold.expiration), \"An expired hold can not be renewed\");\r\n\r\n    if (renewableHold.sender == address(0)) { // pre-hold (tokens do not already exist)\r\n      require(\r\n        _canPreHold(token, msg.sender),\r\n        \"The pre-hold can only be renewed by the minter\"\r\n      );\r\n    } else { // post-hold (tokens already exist)\r\n      require(\r\n        _canPostHold(token, renewableHold.partition, msg.sender, renewableHold.sender),\r\n        \"The hold can only be renewed by the issuer or the payer\"\r\n      );\r\n    }\r\n    \r\n    uint256 oldExpiration = renewableHold.expiration;\r\n    renewableHold.expiration = expiration;\r\n\r\n    emit HoldRenewed(\r\n      token,\r\n      holdId,\r\n      renewableHold.notary,\r\n      oldExpiration,\r\n      expiration\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Execute hold.\r\n   */\r\n  function executeHold(address token, bytes32 holdId, uint256 value, bytes32 secret) external returns (bool) {\r\n    return _executeHold(\r\n      token,\r\n      holdId,\r\n      msg.sender,\r\n      value,\r\n      secret,\r\n      false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Execute hold and keep open.\r\n   */\r\n  function executeHoldAndKeepOpen(address token, bytes32 holdId, uint256 value, bytes32 secret) external returns (bool) {\r\n    return _executeHold(\r\n      token,\r\n      holdId,\r\n      msg.sender,\r\n      value,\r\n      secret,\r\n      true\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * @dev Execute hold.\r\n   */\r\n  function _executeHold(\r\n    address token,\r\n    bytes32 holdId,\r\n    address operator,\r\n    uint256 value,\r\n    bytes32 secret,\r\n    bool keepOpenIfHoldHasBalance\r\n  ) internal returns (bool)\r\n  {\r\n    Hold storage executableHold = _holds[token][holdId];\r\n\r\n    bool canExecuteHold;\r\n    if(secret != \"\" && _holdCanBeExecutedAsSecretHolder(executableHold, value, secret)) {\r\n      executableHold.secret = secret;\r\n      canExecuteHold = true;\r\n    } else if(_holdCanBeExecutedAsNotary(executableHold, operator, value)) {\r\n      canExecuteHold = true;\r\n    }\r\n\r\n    if(canExecuteHold) {\r\n      if (keepOpenIfHoldHasBalance && ((executableHold.value - value) > 0)) {\r\n        _setHoldToExecutedAndKeptOpen(\r\n          token,\r\n          executableHold,\r\n          holdId,\r\n          value,\r\n          value,\r\n          secret\r\n        );\r\n      } else {\r\n        _setHoldToExecuted(\r\n          token,\r\n          executableHold,\r\n          holdId,\r\n          value,\r\n          executableHold.value,\r\n          secret\r\n        );\r\n      }\r\n\r\n      if (executableHold.sender == address(0)) { // pre-hold (tokens do not already exist)\r\n        IERC1400(token).issueByPartition(executableHold.partition, executableHold.recipient, value, \"\");\r\n      } else { // post-hold (tokens already exist)\r\n        IERC1400(token).operatorTransferByPartition(executableHold.partition, executableHold.sender, executableHold.recipient, value, \"\", \"\");\r\n      }\r\n      \r\n    } else {\r\n      revert(\"hold can not be executed\");\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Set hold to executed.\r\n   */\r\n  function _setHoldToExecuted(\r\n    address token,\r\n    Hold storage executableHold,\r\n    bytes32 holdId,\r\n    uint256 value,\r\n    uint256 heldBalanceDecrease,\r\n    bytes32 secret\r\n  ) internal\r\n  {\r\n    if(executableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\r\n      _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\r\n    }\r\n\r\n    executableHold.status = HoldStatusCode.Executed;\r\n\r\n    emit HoldExecuted(\r\n      token,\r\n      holdId,\r\n      executableHold.notary,\r\n      executableHold.value,\r\n      value,\r\n      secret\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Set hold to executed and kept open.\r\n   */\r\n  function _setHoldToExecutedAndKeptOpen(\r\n    address token,\r\n    Hold storage executableHold,\r\n    bytes32 holdId,\r\n    uint256 value,\r\n    uint256 heldBalanceDecrease,\r\n    bytes32 secret\r\n  ) internal\r\n  {\r\n    if(executableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\r\n      _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\r\n    } \r\n\r\n    executableHold.status = HoldStatusCode.ExecutedAndKeptOpen;\r\n    executableHold.value = executableHold.value.sub(value);\r\n\r\n    emit HoldExecutedAndKeptOpen(\r\n      token,\r\n      holdId,\r\n      executableHold.notary,\r\n      executableHold.value,\r\n      value,\r\n      secret\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Increase held balance.\r\n   */\r\n  function _increaseHeldBalance(address token, Hold storage executableHold, bytes32 holdId) private {\r\n    _heldBalance[token][executableHold.sender] = _heldBalance[token][executableHold.sender].add(executableHold.value);\r\n    _totalHeldBalance[token] = _totalHeldBalance[token].add(executableHold.value);\r\n\r\n    _heldBalanceByPartition[token][executableHold.sender][executableHold.partition] = _heldBalanceByPartition[token][executableHold.sender][executableHold.partition].add(executableHold.value);\r\n    _totalHeldBalanceByPartition[token][executableHold.partition] = _totalHeldBalanceByPartition[token][executableHold.partition].add(executableHold.value);\r\n\r\n    _increaseNonce(token, executableHold, holdId);\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease held balance.\r\n   */\r\n  function _decreaseHeldBalance(address token, Hold storage executableHold, uint256 value) private {\r\n    _heldBalance[token][executableHold.sender] = _heldBalance[token][executableHold.sender].sub(value);\r\n    _totalHeldBalance[token] = _totalHeldBalance[token].sub(value);\r\n\r\n    _heldBalanceByPartition[token][executableHold.sender][executableHold.partition] = _heldBalanceByPartition[token][executableHold.sender][executableHold.partition].sub(value);\r\n    _totalHeldBalanceByPartition[token][executableHold.partition] = _totalHeldBalanceByPartition[token][executableHold.partition].sub(value);\r\n\r\n    if(executableHold.status == HoldStatusCode.Ordered) {\r\n      _decreaseNonce(token, executableHold);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Increase nonce.\r\n   */\r\n  function _increaseNonce(address token, Hold storage executableHold, bytes32 holdId) private {\r\n    (bytes32 holdHash, uint256 nonce,) = _retrieveHoldHashNonceId(\r\n      token, executableHold.partition,\r\n      executableHold.notary,\r\n      executableHold.sender,\r\n      executableHold.recipient,\r\n      executableHold.value\r\n    );\r\n    _hashNonce[holdHash] = nonce.add(1);\r\n    _holdIds[holdHash][nonce.add(1)] = holdId;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease nonce.\r\n   */\r\n  function _decreaseNonce(address token, Hold storage executableHold) private {\r\n    (bytes32 holdHash, uint256 nonce,) = _retrieveHoldHashNonceId(\r\n      token,\r\n      executableHold.partition,\r\n      executableHold.notary,\r\n      executableHold.sender,\r\n      executableHold.recipient,\r\n      executableHold.value\r\n    );\r\n    _holdIds[holdHash][nonce] = \"\";\r\n    _hashNonce[holdHash] = _hashNonce[holdHash].sub(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Check secret.\r\n   */\r\n  function _checkSecret(Hold storage executableHold, bytes32 secret) internal view returns (bool) {\r\n    if(executableHold.secretHash == sha256(abi.encodePacked(secret))) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Compute expiration time.\r\n   */\r\n  function _computeExpiration(uint256 timeToExpiration) internal view returns (uint256) {\r\n    uint256 expiration = 0;\r\n\r\n    if (timeToExpiration != 0) {\r\n        expiration = now.add(timeToExpiration);\r\n    }\r\n\r\n    return expiration;\r\n  }\r\n\r\n  /**\r\n   * @dev Check expiration time.\r\n   */\r\n  function _checkExpiration(uint256 expiration) private view {\r\n    require(expiration > now || expiration == 0, \"Expiration date must be greater than block timestamp or zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Check is expiration date is past.\r\n   */\r\n  function _isExpired(uint256 expiration) internal view returns (bool) {\r\n    return expiration != 0 && (now >= expiration);\r\n  }\r\n\r\n  /**\r\n   * @dev Retrieve hold hash, nonce, and ID for given parameters\r\n   */\r\n  function _retrieveHoldHashNonceId(address token, bytes32 partition, address notary, address sender, address recipient, uint value) internal view returns (bytes32, uint256, bytes32) {\r\n    // Pack and hash hold parameters\r\n    bytes32 holdHash = keccak256(abi.encodePacked(\r\n      token,\r\n      partition,\r\n      sender,\r\n      recipient,\r\n      notary,\r\n      value\r\n    ));\r\n    uint256 nonce = _hashNonce[holdHash];\r\n    bytes32 holdId = _holdIds[holdHash][nonce];\r\n\r\n    return (holdHash, nonce, holdId);\r\n  }  \r\n\r\n  /**\r\n   * @dev Check if hold can be executed\r\n   */\r\n  function _holdCanBeExecuted(Hold storage executableHold, uint value) internal view returns (bool) {\r\n    if(!(executableHold.status == HoldStatusCode.Ordered || executableHold.status == HoldStatusCode.ExecutedAndKeptOpen)) {\r\n      return false; // A hold can only be executed in status Ordered or ExecutedAndKeptOpen\r\n    } else if(value == 0) {\r\n      return false; // Value must be greater than zero\r\n    } else if(_isExpired(executableHold.expiration)) {\r\n      return false; // The hold has already expired\r\n    } else if(value > executableHold.value) {\r\n      return false; // The value should be equal or less than the held amount\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check if hold can be executed as secret holder\r\n   */\r\n  function _holdCanBeExecutedAsSecretHolder(Hold storage executableHold, uint value, bytes32 secret) internal view returns (bool) {\r\n    if(\r\n      _checkSecret(executableHold, secret)\r\n      && _holdCanBeExecuted(executableHold, value)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check if hold can be executed as notary\r\n   */\r\n  function _holdCanBeExecutedAsNotary(Hold storage executableHold, address operator, uint value) internal view returns (bool) {\r\n    if(\r\n      executableHold.notary == operator\r\n      && _holdCanBeExecuted(executableHold, value)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }  \r\n\r\n  /**\r\n   * @dev Retrieve hold data.\r\n   */\r\n  function retrieveHoldData(address token, bytes32 holdId) external view returns (\r\n    bytes32 partition,\r\n    address sender,\r\n    address recipient,\r\n    address notary,\r\n    uint256 value,\r\n    uint256 expiration,\r\n    bytes32 secretHash,\r\n    bytes32 secret,\r\n    HoldStatusCode status)\r\n  {\r\n    Hold storage retrievedHold = _holds[token][holdId];\r\n    return (\r\n      retrievedHold.partition,\r\n      retrievedHold.sender,\r\n      retrievedHold.recipient,\r\n      retrievedHold.notary,\r\n      retrievedHold.value,\r\n      retrievedHold.expiration,\r\n      retrievedHold.secretHash,\r\n      retrievedHold.secret,\r\n      retrievedHold.status\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Total supply on hold.\r\n   */\r\n  function totalSupplyOnHold(address token) external view returns (uint256) {\r\n    return _totalHeldBalance[token];\r\n  }\r\n\r\n  /**\r\n   * @dev Total supply on hold for a specific partition.\r\n   */\r\n  function totalSupplyOnHoldByPartition(address token, bytes32 partition) external view returns (uint256) {\r\n    return _totalHeldBalanceByPartition[token][partition];\r\n  }\r\n\r\n  /**\r\n   * @dev Get balance on hold of a tokenholder.\r\n   */\r\n  function balanceOnHold(address token, address account) external view returns (uint256) {\r\n    return _heldBalance[token][account];\r\n  }\r\n\r\n  /**\r\n   * @dev Get balance on hold of a tokenholder for a specific partition.\r\n   */\r\n  function balanceOnHoldByPartition(address token, bytes32 partition, address account) external view returns (uint256) {\r\n    return _heldBalanceByPartition[token][account][partition];\r\n  }\r\n\r\n  /**\r\n   * @dev Get spendable balance of a tokenholder.\r\n   */\r\n  function spendableBalanceOf(address token, address account) external view returns (uint256) {\r\n    return _spendableBalanceOf(token, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Get spendable balance of a tokenholder for a specific partition.\r\n   */\r\n  function spendableBalanceOfByPartition(address token, bytes32 partition, address account) external view returns (uint256) {\r\n    return _spendableBalanceOfByPartition(token, partition, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Get spendable balance of a tokenholder.\r\n   */\r\n  function _spendableBalanceOf(address token, address account) internal view returns (uint256) {\r\n    return IERC20(token).balanceOf(account) - _heldBalance[token][account];\r\n  }\r\n\r\n  /**\r\n   * @dev Get spendable balance of a tokenholder for a specific partition.\r\n   */\r\n  function _spendableBalanceOfByPartition(address token, bytes32 partition, address account) internal view returns (uint256) {\r\n    return IERC1400(token).balanceOfByPartition(partition, account) - _heldBalanceByPartition[token][account][partition];\r\n  }\r\n\r\n  /************************** TOKEN CONTROLLERS *******************************/\r\n\r\n  /**\r\n   * @dev Check if operator can create pre-holds.\r\n   * @return 'true' if the operator can create pre-holds, 'false' if not.\r\n   */\r\n  function _canPreHold(address token, address operator) internal view returns(bool) { \r\n    return IMinterRole(token).isMinter(operator);\r\n  }\r\n\r\n  /**\r\n   * @dev Check if operator can create/update holds.\r\n   * @return 'true' if the operator can create/update holds, 'false' if not.\r\n   */\r\n  function _canPostHold(address token, bytes32 partition, address operator, address sender) internal view returns(bool) {    \r\n    if (_selfHoldsActivated[token]) {\r\n      return IERC1400(token).isOperatorForPartition(partition, operator, sender);\r\n    } else {\r\n      return _isTokenController[token][operator];\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Check if validator is activated for the function called in the smart contract.\r\n   * @param functionSig ID of the function that is called.\r\n   * @return 'true' if the function requires validation, 'false' if not.\r\n   */\r\n  function _functionRequiresValidation(bytes4 functionSig) internal pure returns(bool) {\r\n    if(_areEqual(functionSig, ERC20_TRANSFER_FUNCTION_ID) || _areEqual(functionSig, ERC20_TRANSFERFROM_FUNCTION_ID)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Check if 2 variables of type bytes4 are identical.\r\n   * @return 'true' if 2 variables are identical, 'false' if not.\r\n   */\r\n  function _areEqual(bytes4 a, bytes4 b) internal pure returns(bool) {\r\n    for (uint256 i = 0; i < a.length; i++) {\r\n      if(a[i] != b[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Check if 'value' is multiple of 'granularity'.\r\n   * @param granularity The granularity that want's to be checked.\r\n   * @param value The quantity that want's to be checked.\r\n   * @return 'true' if 'value' is a multiple of 'granularity'.\r\n   */\r\n  function _isMultiple(uint256 granularity, uint256 value) internal pure returns(bool) {\r\n    return(value.div(granularity).mul(granularity) == value);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"renounceAllowlistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"}],\"name\":\"retrieveHoldData\",\"outputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"name\":\"secret\",\"type\":\"bytes32\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"totalSupplyOnHold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOnHold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBlocklisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"timeToExpiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"hold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"holdWithExpirationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAllowlisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAllowlistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"totalSupplyOnHoldByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"executeHold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"spendableBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAllowlisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"granularity\",\"type\":\"uint256\"}],\"name\":\"setGranularityByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAllowlisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"timeToExpiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"holdFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"executeHoldAndKeepOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"spendableBalanceOfByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"functionSig\",\"type\":\"bytes4\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"tokensToValidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"timeToExpiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"preHoldFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeBlocklisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"renewHoldWithExpirationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlocklistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlocklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"granularityByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"functionSig\",\"type\":\"bytes4\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canValidate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"holdFromWithExpirationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"retrieveTokenSetup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"}],\"name\":\"releaseHold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBlocklistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"timeToExpiration\",\"type\":\"uint256\"}],\"name\":\"renewHold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"renounceBlocklistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOnHoldByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holdId\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"preHoldForWithExpirationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"allowlistActivated\",\"type\":\"bool\"},{\"name\":\"blocklistActivated\",\"type\":\"bool\"},{\"name\":\"granularityByPartitionActivated\",\"type\":\"bool\"},{\"name\":\"holdsActivated\",\"type\":\"bool\"},{\"name\":\"selfHoldsActivated\",\"type\":\"bool\"},{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"registerTokenSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAllowlistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holdId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expiration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"name\":\"HoldCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"holdId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"HoldReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"holdId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newExpiration\",\"type\":\"uint256\"}],\"name\":\"HoldRenewed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"holdId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"heldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transferredValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"HoldExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"holdId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"heldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transferredValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"HoldExecutedAndKeptOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlocklistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlocklistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlocklistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlocklistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AllowlistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AllowlistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AllowlistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AllowlistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"}]","ContractName":"ERC1400TokensValidator","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://cb5be0d516dea0d904044040988374f1ebe4fb307c6b6694d2792b06870f1d62"}]}