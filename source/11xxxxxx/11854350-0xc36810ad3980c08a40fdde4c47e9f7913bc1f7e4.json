{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlackList.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BlackList is Ownable{\\n\\n    mapping (address =\\u003e bool) internal isBlackListed;\\n    \\n    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\\n\\n    event AddedBlackList(address _user);\\n\\n    event RemovedBlackList(address _user);\\n    \\n    function getBlackListStatus(address addr) public view returns (bool) {\\n        return isBlackListed[addr];\\n    }\\n    \\n    function addBlackList (address _evilUser) public  onlyAccessorBlackFunds(msg.sender) {\\n        isBlackListed[_evilUser] = true;\\n        emit AddedBlackList(_evilUser);\\n    }\\n    \\n    function removeBlackList (address _clearedUser) public onlyAccessorBlackFunds(msg.sender){\\n        isBlackListed[_clearedUser] = false;\\n        emit RemovedBlackList(_clearedUser);\\n    }\\n    \\n    modifier onlyAccessorBlackFunds(address addr){\\n        require(addr == blackListAccessorAddress, \\\"You are not allowed!\\\");\\n        _;\\n    }\\n\\n}\\n\"},\"Erc20Token.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport \\\"./BlackList.sol\\\";\\nimport \\\"./Erc20TokenInterface.sol\\\";\\nimport \\\"./MathLibrary.sol\\\";\\n\\ncontract Erc20Token is Erc20TokenInterface, BlackList {\\n    using MathLibrary for uint256;\\n    \\n    constructor() internal {\\n        balances[mintAddress] = 1500000000;\\n        totalSupply_ = 1500000000;\\n        emit Transfer(address(0), mintAddress, 1500000000);\\n        name = \\\"IR Digital Token\\\";\\n        symbol = \\\"IRDT\\\";\\n        decimals = 4;\\n    }\\n\\n    /**\\n     * Transfer token from sender(caller) to \\u0027_to\\u0027 account\\n     *\\n     * Requirements:\\n     *\\n     * - `_to` cannot be the zero address.\\n     * - the sender(caller) must have a balance of at least `_value`.\\n     */\\n    function transfer(address _to, uint256 _value) validAddress(_to, \\\"_to address is not valid\\\") smallerOrLessThan(_value, balances[msg.sender], \\\"transfer value should be smaller than your balance\\\") public returns (bool) {\\n        require(!isBlackListed[msg.sender], \\\"from address is blacklisted\\\");\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n\\n    /**\\n     * sender(caller) transfer \\u0027_value\\u0027 token to \\u0027_to\\u0027 address from \\u0027_from\\u0027 address\\n     *\\n     * Requirements:\\n     *\\n     * - `_to` and `_from` cannot be the zero address.\\n     * - `_from` must have a balance of at least `_value` .\\n     * - the sender(caller) must have allowance for `_from`\\u0027s tokens of at least `_value`.\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) validAddress(_from, \\\"_from address is not valid\\\") validAddress(_to, \\\"_to address is not valid\\\") public returns (bool) {\\n        require(_value\\u003c=allowances[_from][msg.sender], \\\"_value should be smaller than your allowance\\\");\\n        require(_value\\u003c=balances[_from],\\\"_value should be smaller than _from\\u0027s balance\\\");\\n        require(!isBlackListed[_from], \\\"from address is blacklisted\\\");\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * change allowance of `_spender` to `_value` by sender(caller)\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address _spender, uint256 _value) validAddress(_spender, \\\"_spender is not valid address\\\") public returns (bool) {\\n        allowances[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n    * Atomically increases the allowance granted to `spender` by the sender(caller).\\n    * Emits an {Approval} event indicating the updated allowance.\\n    *\\n    * Requirements:\\n    *\\n    * - `spender` cannot be the zero address.\\n    */\\n    function increaseApproval(address _spender, uint _addedValue) validAddress(_spender, \\\"_spender is not valid address\\\") public returns (bool) {\\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add(_addedValue);\\n        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * Atomically decreases the allowance granted to `spender` by the sender(caller).\\n    * Emits an {Approval} event indicating the updated allowance.\\n    *\\n    * Requirements:\\n    *\\n    * - `_spender` cannot be the zero address.\\n    * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\\n    */\\n    function decreaseApproval(address _spender, uint _subtractedValue) validAddress(_spender, \\\"_spender is not valid address\\\") public returns (bool) {\\n        uint oldValue = allowances[msg.sender][_spender];\\n        allowances[msg.sender][_spender] = _subtractedValue \\u003e oldValue ? 0 : oldValue.sub(_subtractedValue);\\n        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n\\n    /**\\n    * Destroys `amount` tokens from `account`, reducing the\\n    * total supply.\\n    * Emits a {Transfer} event with `to` set to the zero address.\\n    *\\n    * Requirements:\\n    * - `amount` cannot be less than zero.\\n    * - `amount` cannot be more than sender(caller)\\u0027s balance.\\n    */\\n    function burn(uint256 amount) public {\\n        require(amount \\u003e 0, \\\"amount cannot be less than zero\\\");\\n        require(amount \\u003c= balances[msg.sender], \\\"amount to burn is more than the caller\\u0027s balance\\\");\\n        balances[msg.sender] = balances[msg.sender].sub(amount);\\n        totalSupply_ = totalSupply_.sub(amount);\\n        emit Transfer(msg.sender, address(0), amount);\\n    }\\n    \\n    /**\\n    * sender(caller) create a \\u0027value\\u0027 token mint request.\\n    *\\n    * Requirement:\\n    * - sender(Caller) should be mintAccessorAddress\\n    */\\n    function mint(uint256 value) public {\\n        require(msg.sender == mintAccessorAddress,\\\"you are not permitted to create mint request\\\");\\n        totalSupply_ = totalSupply_.add(value);\\n        balances[mintAddress] = balances[mintAddress].add(value);\\n        emit Transfer(address(0), mintAddress, value);\\n    }\\n    \\n    /**\\n    * Destroys tokens from `blackUser`, if that account is blacklisted.\\n    * Emits a {DestroyedBlackFunds} event.\\n    * Requirements:\\n    * - `blackUser` should already be isBlackListed.\\n    */\\n    function destroyBlackFunds (address blackUser) public onlyAccessor(msg.sender) {\\n        require(isBlackListed[blackUser]);\\n        uint256 dirtyFunds = balances[blackUser];\\n        balances[blackUser] = 0;\\n        totalSupply_ = totalSupply_.sub(dirtyFunds);\\n        emit Transfer(blackUser, address(0), dirtyFunds);\\n        emit DestroyedBlackFunds(blackUser, dirtyFunds);\\n    }\\n\\n    \\n    modifier onlyAccessor(address addr){\\n        require(addr == blackFundDestroyerAccessorAddress, \\\"You are not allowed!\\\");\\n        _;\\n    }\\n    \\n}\\n\\n\"},\"Erc20TokenInterface.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\n\\ncontract Erc20TokenInterface {\\n    mapping(address =\\u003e uint256) internal balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal allowances;\\n    uint256 internal totalSupply_;\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    modifier smallerOrLessThan(uint256 _value1, uint256 _value2, string errorMessage) {\\n        require(_value1 \\u003c= _value2, errorMessage);\\n        _;\\n    }\\n\\n    modifier validAddress(address _address, string errorMessage) {\\n        require(_address != address(0), errorMessage);\\n        _;\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    function balanceOf(address _owner) public view returns (uint256) {\\n        return balances[_owner];\\n    }\\n\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\n        return allowances[_owner][_spender];\\n    }\\n\\n    function transfer(address to, uint256 value) public returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\\n\\n    function approve(address spender, uint256 value) public returns (bool);\\n\\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool);\\n\\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n}\\n\"},\"IRDT.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport \\\"./Erc20Token.sol\\\";\\nimport \\\"./TokenContractWithTokenFee.sol\\\";\\n\\n/**\\n * Website: IRDT.io\\n **/\\ncontract IRDT is TokenContractWithTokenFee {\\n    constructor (address[] BoDAddress, address[] accessors) public {\\n        BoDAddresses = BoDAddress;\\n        mintAccessorAddress = accessors[0];\\n        mintDestChangerAddress = accessors[1];\\n        blackListAccessorAddress = accessors[2];\\n        blackFundDestroyerAccessorAddress = accessors[3];\\n        mintAddress = accessors[4];\\n    }\\n}\\n\"},\"MathLibrary.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nlibrary MathLibrary {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport \\\"./MathLibrary.sol\\\";\\nimport \\\"./Erc20TokenInterface.sol\\\";\\ncontract Ownable {\\n    using MathLibrary for uint256;\\n    address public owner;\\n    address[] public BoDAddresses;\\n    \\n    address public mintAddress;\\n    \\n    address public mintDestChangerAddress;\\n    address public mintAccessorAddress;\\n    address public blackListAccessorAddress;\\n    address public blackFundDestroyerAccessorAddress;\\n    struct TransferObject {\\n        uint256 transferCounter;\\n        uint256 from;\\n        address to;\\n        mapping(address =\\u003e bool) voted;\\n    }\\n\\n    TransferObject transferObject;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event AuthorityTransfer(address indexed from, address indexed to);\\n\\n    constructor() public payable {\\n        owner = msg.sender;\\n        \\n    }\\n\\n     /**\\n    * change owner of contract\\n    */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n    \\n     /**\\n    * change destination of mint address\\n    */\\n    function changeMintAddress(address addr) public{\\n        require(msg.sender == mintDestChangerAddress);\\n        mintAddress = addr;\\n    }\\n    \\n     /**\\n    * change accessor of mint destination changer\\n    */\\n    function changeMintDestChangerAddress(address addr) public{\\n        require(msg.sender == BoDAddresses[1]);\\n        mintDestChangerAddress = addr;\\n    }\\n    \\n     /**\\n    * change accessor of mint function\\n    */\\n    function changeMintAccessorAddress(address addr) public{\\n        require(msg.sender == BoDAddresses[0]);\\n        mintAccessorAddress = addr;\\n    }\\n    \\n     /**\\n    * change accessor of blackList\\n    */\\n    function changeBlackListAccessorAddress(address addr) public{\\n        require(msg.sender == BoDAddresses[2]);\\n        blackListAccessorAddress = addr;\\n    }\\n    \\n     /**\\n    * change accessor of blackList destroy fund\\n    */\\n    function changeBlackFundAccessorAddress(address addr) public{\\n        require(msg.sender == BoDAddresses[3]);\\n        blackFundDestroyerAccessorAddress = addr;\\n    }\\n    \\n     /**\\n    * sender(caller) vote for transfer `_from\\u0027 address to \\u0027_to\\u0027 address in board of directors\\n    *\\n    * Requirement:\\n    * - sender(Caller) and _from` should be in the board of directors.\\n    * - `_to` shouldn\\u0027t be in the board of directors\\n    */\\n    function transferAuthority(uint256 from, address to) notInBoD(to, \\\"_to address is already in board of directors\\\") isAuthority(msg.sender, \\\"you are not permitted to vote for transfer\\\") public {\\n        require(from \\u003c BoDAddresses.length);\\n        if (BoDAddresses[from] == msg.sender) {\\n            transferAuth(from, to);\\n            return;\\n        }\\n        require(!transferObject.voted[msg.sender]);\\n\\n        if (transferObject.from != from || transferObject.to != to) {\\n            transferObject.transferCounter = 0;\\n            for (uint j = 0; j \\u003c BoDAddresses.length; j++) {\\n                transferObject.voted[BoDAddresses[j]] = false;\\n            }\\n        }\\n        if (transferObject.transferCounter == 0) {\\n            transferObject.from = from;\\n            transferObject.to = to;\\n            \\n        }\\n        transferObject.transferCounter++;\\n        transferObject.voted[msg.sender] = true;\\n        if (transferObject.transferCounter == BoDAddresses.length - 1) {\\n            transferAuth(from, to);\\n        }\\n    }\\n\\n     /**\\n    * this function is called if all of board of directors vote for the transfer `_from`-\\u003e`_to\\u0027.\\n    */\\n    function transferAuth(uint256 from, address to) private {\\n        for (uint j = 0; j \\u003c BoDAddresses.length; j++) {\\n            transferObject.voted[BoDAddresses[j]] = false;\\n        }\\n        emit AuthorityTransfer(BoDAddresses[from], to);\\n        BoDAddresses[from] = to;\\n        transferObject.transferCounter = 0;\\n        \\n    }\\n\\n     /**\\n    * This function is used by board of directors to remove other tokens in contract\\n    */\\n    function removeErc20TokensFromContract(address _token, address to) public isAuthority(msg.sender, \\\"you are not permitted\\\"){\\n        Erc20TokenInterface erc20Token = Erc20TokenInterface(_token);\\n        uint256 value = erc20Token.balanceOf(address(this));\\n        erc20Token.transfer(to,value);\\n    }\\n    \\n    \\n    modifier isAuthority(address authority, string errorMessage) {\\n        bool isBoD = false;\\n        for (uint i = 0; i \\u003c BoDAddresses.length; i++) {\\n            if (authority == BoDAddresses[i]) {\\n                isBoD = true;\\n                break;\\n            }\\n        }\\n        require(isBoD, errorMessage);\\n        _;\\n    }\\n\\n    modifier notInBoD(address addr, string errorMessage){\\n        bool flag = true;\\n        for (uint i = 0; i \\u003c BoDAddresses.length; i++) {\\n            if (addr == BoDAddresses[i]) {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        require(flag, errorMessage);\\n        _;\\n    }\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n    \\n}\\n\"},\"SignatureRecover.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\ncontract SignatureRecover {\\n    uint256 constant chainId = 1;\\n\\n    struct Unit {\\n        address to;\\n        uint256 value;\\n        uint256 fee;\\n        uint256 nonce;\\n    }\\n\\n    string private constant EIP712_DOMAIN = \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\";\\n    string private constant UNIT_TYPE = \\\"Unit(address to,uint256 value,uint256 fee,uint256 nonce)\\\";\\n\\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(EIP712_DOMAIN));\\n    bytes32 private constant UNIT_TYPEHASH = keccak256(abi.encodePacked(UNIT_TYPE));\\n\\n    bytes32 private DOMAIN_SEPARATOR = keccak256(abi.encode(\\n            EIP712_DOMAIN_TYPEHASH,\\n            keccak256(\\\"IRDT\\\"),\\n            keccak256(\\\"1\\\"),\\n            chainId,\\n            this\\n        ));\\n\\n    function hashUnit(Unit memory unitobj) private view returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(\\n                    UNIT_TYPEHASH,\\n                    unitobj.to,\\n                    unitobj.value,\\n                    unitobj.fee,\\n                    unitobj.nonce\\n                ))\\n            ));\\n    }\\n\\n\\n    /**\\n    * recover \\u0027_from\\u0027 address by signature\\n    */\\n    function testVerify(bytes32 s, bytes32 r, uint8 v, address _to, uint256 _value, uint256 _fee, uint256 _nonce) internal view returns (address) {\\n        Unit memory _msgobj = Unit({\\n        to : _to,\\n        value : _value,\\n        fee : _fee,\\n        nonce : _nonce\\n        });\\n        return ecrecover(hashUnit(_msgobj), v, r, s);\\n    }\\n}\\n\"},\"TokenContractWithTokenFee.sol\":{\"content\":\"pragma solidity ^0.4.0;\\n\\nimport \\\"./Erc20Token.sol\\\";\\nimport \\\"./SignatureRecover.sol\\\";\\n\\ncontract TokenContractWithTokenFee is Erc20Token, SignatureRecover {\\n\\n    mapping(bytes32 =\\u003e bool) public signatures;\\n\\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\\n\\n    modifier smallerOrLessThan(uint256 _value1, uint256 _value2, string errorMessage) {\\n        require(_value1 \\u003c= _value2, errorMessage);\\n        _;\\n    }\\n\\n    modifier validAddress(address _address, string errorMessage) {\\n        require(_address != address(0), errorMessage);\\n        _;\\n    }\\n\\n    /**\\n    * burn the specific signature from the signatures\\n    *\\n    * Requirement:\\n    * - sender(Caller) should be signer of that specific signature\\n    */\\n    function burnTransaction(bytes32 s, bytes32 r, uint8 v, address _to, uint256 _value, uint256 _fee, uint256 _nonce) validAddress(_to, \\\"_to address is not valid\\\") public {\\n        require(!signatures[s], \\\"this signature is burned or done before\\\");\\n        address from = testVerify(s, r, v, _to, _value, _fee, _nonce);\\n        require(from == msg.sender, \\\"you\\u0027re not permitted to burn this signature\\\");\\n        signatures[s] = true;\\n    }\\n\\n    /**\\n    * check if the transferPreSigned is valid or not!?\\n    *\\n    * Requirement:\\n    * - \\u0027_to\\u0027 can not be zero address.\\n    */\\n    function validTransaction(bytes32 s, bytes32 r, uint8 v, address _to, uint256 _value, uint256 _fee, uint256 _nonce) validAddress(_to, \\\"_to address is not valid\\\") view public returns (bool, address) {\\n        address from = testVerify(s, r, v, _to, _value, _fee, _nonce);\\n        require(!isBlackListed[from], \\\"from address is blacklisted\\\");\\n        return (from != address(0) \\u0026\\u0026 !signatures[s] \\u0026\\u0026 balances[from] \\u003e= _value.add(_fee), from);\\n    }\\n\\n\\n    /**\\n    * submit the transferPreSigned\\n    *\\n    * Requirement:\\n    * - \\u0027_to\\u0027 can not be zero address.\\n    * signature must be unused\\n    */\\n    function transferPreSigned(bytes32 s, bytes32 r, uint8 v, address _to, uint256 _value, uint256 _fee, uint256 _nonce) validAddress(_to, \\\"_to address is not valid\\\") public returns (bool){\\n        require(signatures[s] == false, \\\"signature has been used\\\");\\n        address from = testVerify(s, r, v, _to, _value, _fee, _nonce);\\n        require(from != address(0), \\\"signature is wrong\\\");\\n        require(!isBlackListed[from], \\\"from address is blacklisted\\\");\\n        balances[from] = balances[from].sub(_value.add(_fee));\\n        balances[_to] = balances[_to].add(_value);\\n        balances[msg.sender] = balances[msg.sender].add(_fee);\\n        signatures[s] = true;\\n        emit Transfer(from, _to, _value);\\n        emit Transfer(from, msg.sender, _fee);\\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\\n        return true;\\n    }\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_evilUser\",\"type\":\"address\"}],\"name\":\"addBlackList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"validTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeBlackFundAccessorAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeMintAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"signatures\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BoDAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blackListAccessorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBlackListStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"removeErc20TokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"transferPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"burnTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blackFundDestroyerAccessorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeMintAccessorAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintAccessorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clearedUser\",\"type\":\"address\"}],\"name\":\"removeBlackList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeBlackListAccessorAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blackUser\",\"type\":\"address\"}],\"name\":\"destroyBlackFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintDestChangerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeMintDestChangerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"BoDAddress\",\"type\":\"address[]\"},{\"name\":\"accessors\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TransferPreSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blackListedUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"DestroyedBlackFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AddedBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"RemovedBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"AuthorityTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"IRDT","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000004000000000000000000000000541ae5959e16bd037633e931a1fe7e06e7ec61a90000000000000000000000009a33fe9f4da5a9925b69a050e77dceb9885b7b20000000000000000000000000ef2cd59db270d53f17c0591b0da2d9bb0980e7b4000000000000000000000000c6221d58dd05592b543b9bc531364dab5782570d00000000000000000000000000000000000000000000000000000000000000050000000000000000000000009cd50c13b61be2dab899be22b0de7c3e2e2254c200000000000000000000000010dab2ec740ae0b3ca22ea0a7fbdd1e447665c6b000000000000000000000000e939c2afeebdfe85ce10990bf5a9e3d5ab235bc1000000000000000000000000a479492a7ee37aed31116b9dddc445aea29e94460000000000000000000000009e83cc0d903a5b33d9caf66eea314064cdaf2289","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c738d0940882793fa66884f442238273dfaf2475f691bea0c7c911db804b970b"}]}