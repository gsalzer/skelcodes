{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.0.7 https://hardhat.org\r\n\r\n// File contracts/utils/Ownable.sol\r\n\r\n// SPDX-License-Identifier: None\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n * @author crypto-pumpkin@github\r\n *\r\n * By initialization, the owner account will be the one that called initializeOwner. This\r\n * can later be changed with {transferOwnership}.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev COVER: Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/utils/Address.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/utils/SafeERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBonusRewards.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Cover Protocol Bonus Token Rewards Interface\r\n * @author crypto-pumpkin\r\n */\r\ninterface IBonusRewards {\r\n  event Deposit(address indexed user, address indexed lpToken, uint256 amount);\r\n  event Withdraw(address indexed user, address indexed lpToken, uint256 amount);\r\n\r\n  struct Bonus {\r\n    address bonusTokenAddr; // the external bonus token, like CRV\r\n    uint48 startTime;\r\n    uint48 endTime;\r\n    uint256 weeklyRewards; // total amount to be distributed from start to end\r\n    uint256 accRewardsPerToken; // accumulated bonus to the lastUpdated Time\r\n    uint256 remBonus; // remaining bonus in contract\r\n  }\r\n\r\n  struct Pool {\r\n    Bonus[] bonuses;\r\n    uint256 lastUpdatedAt; // last accumulated bonus update timestamp\r\n  }\r\n\r\n  struct User {\r\n    uint256 amount;\r\n    uint256[] rewardsWriteoffs; // the amount of bonus tokens to write off when calculate rewards from last update\r\n  }\r\n\r\n  function getPoolList() external view returns (address[] memory);\r\n  function getResponders() external view returns (address[] memory);\r\n  function getPool(address _lpToken) external view returns (Pool memory);\r\n  function getUser(address _lpToken, address _account) external view returns (User memory _user, uint256[] memory _rewards);\r\n  function getAuthorizers(address _lpToken, address _bonusTokenAddr) external view returns (address[] memory);\r\n  function viewRewards(address _lpToken, address _user) external view  returns (uint256[] memory);\r\n\r\n  function claimRewardsForPools(address[] calldata _lpTokens) external;\r\n  function deposit(address _lpToken, uint256 _amount) external;\r\n  function withdraw(address _lpToken, uint256 _amount) external;\r\n  function emergencyWithdraw(address[] calldata _lpTokens) external;\r\n  function addBonus(\r\n    address _lpToken,\r\n    address _bonusTokenAddr,\r\n    uint48 _startTime,\r\n    uint256 _weeklyRewards,\r\n    uint256 _transferAmount\r\n  ) external;\r\n  function extendBonus(\r\n    address _lpToken,\r\n    uint256 _poolBonusId,\r\n    address _bonusTokenAddr,\r\n    uint256 _transferAmount\r\n  ) external;\r\n  function updateBonus(\r\n    address _lpToken,\r\n    address _bonusTokenAddr,\r\n    uint256 _weeklyRewards,\r\n    uint48 _startTime\r\n  ) external;\r\n\r\n  // only owner\r\n  function setResponders(address[] calldata _responders) external;\r\n  function setPaused(bool _paused) external;\r\n  function collectDust(address _token, address _lpToken, uint256 _poolBonusId) external;\r\n  function addPoolsAndAllowBonus(\r\n    address[] calldata _lpTokens,\r\n    address[] calldata _bonusTokenAddrs,\r\n    address[] calldata _authorizers\r\n  ) external;\r\n}\r\n\r\n\r\n// File contracts/BonusRewards.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Cover Protocol Bonus Token Rewards contract\r\n * @author crypto-pumpkin\r\n * @notice ETH is not allowed to be an bonus token, use wETH instead\r\n * @notice We support multiple bonus tokens for each pool. However, each pool will have 1 bonus token normally, may have 2 in rare cases\r\n */\r\ncontract BonusRewards is IBonusRewards, Ownable, ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n\r\n  bool public paused;\r\n  uint256 private constant WEEK = 7 days;\r\n  // help calculate rewards/bonus PerToken only. 1e12 will allow meaningful $1 deposit in a $1bn pool  \r\n  uint256 private constant CAL_MULTIPLIER = 1e30;\r\n  // use array to allow convinient replacement. Size of responders should be very small to 0 till a reputible responder multi-sig within DeFi or Yearn ecosystem is established\r\n  address[] private responders;\r\n  address[] private poolList;\r\n  // lpToken => Pool\r\n  mapping(address => Pool) private pools;\r\n  // lpToken => User address => User data\r\n  mapping(address => mapping(address => User)) private users;\r\n  // use array to allow convinient replacement. Size of Authorizers should be very small (one or two partner addresses for the pool and bonus)\r\n  // lpToken => bonus token => [] allowed authorizers to add bonus tokens\r\n  mapping(address => mapping(address => address[])) private allowedTokenAuthorizers;\r\n  // bonusTokenAddr => 1, used to avoid collecting bonus token when not ready\r\n  mapping(address => uint8) private bonusTokenAddrMap;\r\n\r\n  modifier notPaused() {\r\n    require(!paused, \"BonusRewards: paused\");\r\n    _;\r\n  }\r\n\r\n  function claimRewardsForPools(address[] calldata _lpTokens) external override nonReentrant notPaused {\r\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\r\n      address lpToken = _lpTokens[i];\r\n      User memory user = users[lpToken][msg.sender];\r\n      if (user.amount == 0) continue;\r\n      _updatePool(lpToken);\r\n      _claimRewards(lpToken, user);\r\n      _updateUserWriteoffs(lpToken);\r\n    }\r\n  }\r\n\r\n  function deposit(address _lpToken, uint256 _amount) external override nonReentrant notPaused {\r\n    require(pools[_lpToken].lastUpdatedAt > 0, \"Blacksmith: pool does not exists\");\r\n    require(IERC20(_lpToken).balanceOf(msg.sender) >= _amount, \"Blacksmith: insufficient balance\");\r\n\r\n    _updatePool(_lpToken);\r\n    User storage user = users[_lpToken][msg.sender];\r\n    _claimRewards(_lpToken, user);\r\n\r\n    IERC20 token = IERC20(_lpToken);\r\n    uint256 balanceBefore = token.balanceOf(address(this));\r\n    token.safeTransferFrom(msg.sender, address(this), _amount);\r\n    uint256 received = token.balanceOf(address(this)) - balanceBefore;\r\n\r\n    user.amount = user.amount + received;\r\n    _updateUserWriteoffs(_lpToken);\r\n    emit Deposit(msg.sender, _lpToken, received);\r\n  }\r\n\r\n  /// @notice withdraw up to all user deposited\r\n  function withdraw(address _lpToken, uint256 _amount) external override nonReentrant notPaused {\r\n    require(pools[_lpToken].lastUpdatedAt > 0, \"Blacksmith: pool does not exists\");\r\n    _updatePool(_lpToken);\r\n\r\n    User storage user = users[_lpToken][msg.sender];\r\n    _claimRewards(_lpToken, user);\r\n    uint256 amount = user.amount > _amount ? _amount : user.amount;\r\n    user.amount = user.amount - amount;\r\n    _updateUserWriteoffs(_lpToken);\r\n\r\n    _safeTransfer(_lpToken, amount);\r\n    emit Withdraw(msg.sender, _lpToken, amount);\r\n  }\r\n\r\n  /// @notice withdraw all without rewards\r\n  function emergencyWithdraw(address[] calldata _lpTokens) external override nonReentrant {\r\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\r\n      User storage user = users[_lpTokens[i]][msg.sender];\r\n      uint256 amount = user.amount;\r\n      user.amount = 0;\r\n      _safeTransfer(_lpTokens[i], amount);\r\n      emit Withdraw(msg.sender, _lpTokens[i], amount);\r\n    }\r\n  }\r\n\r\n  /// @notice called by authorizers only\r\n  function addBonus(\r\n    address _lpToken,\r\n    address _bonusTokenAddr,\r\n    uint48 _startTime,\r\n    uint256 _weeklyRewards,\r\n    uint256 _transferAmount\r\n  ) external override nonReentrant notPaused {\r\n    require(_isAuthorized(allowedTokenAuthorizers[_lpToken][_bonusTokenAddr]), \"BonusRewards: not authorized caller\");\r\n    require(_startTime >= block.timestamp, \"BonusRewards: startTime in the past\");\r\n\r\n    // make sure the pool is in the right state (exist with no active bonus at the moment) to add new bonus tokens\r\n    Pool memory pool = pools[_lpToken];\r\n    require(pool.lastUpdatedAt > 0, \"BonusRewards: pool does not exist\");\r\n    Bonus[] memory bonuses = pool.bonuses;\r\n    for (uint256 i = 0; i < bonuses.length; i++) {\r\n      if (bonuses[i].bonusTokenAddr == _bonusTokenAddr) {\r\n        // when there is alreay a bonus program with the same bonus token, make sure the program has ended properly\r\n        require(bonuses[i].endTime + WEEK < block.timestamp, \"BonusRewards: last bonus period hasn't ended\");\r\n        require(bonuses[i].remBonus == 0, \"BonusRewards: last bonus not all claimed\");\r\n      }\r\n    }\r\n\r\n    IERC20 bonusTokenAddr = IERC20(_bonusTokenAddr);\r\n    uint256 balanceBefore = bonusTokenAddr.balanceOf(address(this));\r\n    bonusTokenAddr.safeTransferFrom(msg.sender, address(this), _transferAmount);\r\n    uint256 received = bonusTokenAddr.balanceOf(address(this)) - balanceBefore;\r\n    // endTime is based on how much tokens transfered v.s. planned weekly rewards\r\n    uint48 endTime = uint48(received * WEEK / _weeklyRewards + _startTime);\r\n\r\n    pools[_lpToken].bonuses.push(Bonus({\r\n      bonusTokenAddr: _bonusTokenAddr,\r\n      startTime: _startTime,\r\n      endTime: endTime,\r\n      weeklyRewards: _weeklyRewards,\r\n      accRewardsPerToken: 0,\r\n      remBonus: received\r\n    }));\r\n  }\r\n\r\n  /// @notice called by authorizers only, update weeklyRewards (if not ended), or update startTime (only if rewards not started, 0 is ignored)\r\n  function updateBonus(\r\n    address _lpToken,\r\n    address _bonusTokenAddr,\r\n    uint256 _weeklyRewards,\r\n    uint48 _startTime\r\n  ) external override nonReentrant notPaused {\r\n    require(_isAuthorized(allowedTokenAuthorizers[_lpToken][_bonusTokenAddr]), \"BonusRewards: not authorized caller\");\r\n    require(_startTime == 0 || _startTime > block.timestamp, \"BonusRewards: startTime in the past\");\r\n\r\n    // make sure the pool is in the right state (exist with no active bonus at the moment) to add new bonus tokens\r\n    Pool memory pool = pools[_lpToken];\r\n    require(pool.lastUpdatedAt > 0, \"BonusRewards: pool does not exist\");\r\n    Bonus[] memory bonuses = pool.bonuses;\r\n    for (uint256 i = 0; i < bonuses.length; i++) {\r\n      if (bonuses[i].bonusTokenAddr == _bonusTokenAddr && bonuses[i].endTime > block.timestamp) {\r\n        Bonus storage bonus = pools[_lpToken].bonuses[i];\r\n        _updatePool(_lpToken); // update pool with old weeklyReward to this block\r\n        if (bonus.startTime >= block.timestamp) {\r\n          // only honor new start time, if program has not started\r\n          if (_startTime >= block.timestamp) {\r\n            bonus.startTime = _startTime;\r\n          }\r\n          bonus.endTime = uint48(bonus.remBonus * WEEK / _weeklyRewards + bonus.startTime);\r\n        } else {\r\n          uint256 remBonusToDistribute = (bonus.endTime - block.timestamp) * bonus.weeklyRewards / WEEK;\r\n          bonus.endTime = uint48(remBonusToDistribute * WEEK / _weeklyRewards + block.timestamp);\r\n        }\r\n        bonus.weeklyRewards = _weeklyRewards;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice extend the current bonus program, the program has to be active (endTime is in the future)\r\n  function extendBonus(\r\n    address _lpToken,\r\n    uint256 _poolBonusId,\r\n    address _bonusTokenAddr,\r\n    uint256 _transferAmount\r\n  ) external override nonReentrant notPaused {\r\n    require(_isAuthorized(allowedTokenAuthorizers[_lpToken][_bonusTokenAddr]), \"BonusRewards: not authorized caller\");\r\n\r\n    Bonus memory bonus = pools[_lpToken].bonuses[_poolBonusId];\r\n    require(bonus.bonusTokenAddr == _bonusTokenAddr, \"BonusRewards: bonus and id dont match\");\r\n    require(bonus.endTime > block.timestamp, \"BonusRewards: bonus program ended, please start a new one\");\r\n\r\n    IERC20 bonusTokenAddr = IERC20(_bonusTokenAddr);\r\n    uint256 balanceBefore = bonusTokenAddr.balanceOf(address(this));\r\n    bonusTokenAddr.safeTransferFrom(msg.sender, address(this), _transferAmount);\r\n    uint256 received = bonusTokenAddr.balanceOf(address(this)) - balanceBefore;\r\n    // endTime is based on how much tokens transfered v.s. planned weekly rewards\r\n    uint48 endTime = uint48(received * WEEK / bonus.weeklyRewards + bonus.endTime);\r\n\r\n    pools[_lpToken].bonuses[_poolBonusId].endTime = endTime;\r\n    pools[_lpToken].bonuses[_poolBonusId].remBonus = bonus.remBonus + received;\r\n  }\r\n\r\n  /// @notice add pools and authorizers to add bonus tokens for pools, combine two calls into one. Only reason we add pools is when bonus tokens will be added\r\n  function addPoolsAndAllowBonus(\r\n    address[] calldata _lpTokens,\r\n    address[] calldata _bonusTokenAddrs,\r\n    address[] calldata _authorizers\r\n  ) external override onlyOwner notPaused {\r\n    // add pools\r\n    uint256 currentTime = block.timestamp;\r\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\r\n      address _lpToken = _lpTokens[i];\r\n      require(IERC20(_lpToken).decimals() <= 18, \"BonusRewards: lptoken decimals > 18\");\r\n      if (pools[_lpToken].lastUpdatedAt == 0) {\r\n        pools[_lpToken].lastUpdatedAt = currentTime;\r\n        poolList.push(_lpToken);\r\n      }\r\n\r\n      // add bonus tokens and their authorizers (who are allowed to add the token to pool)\r\n      for (uint256 j = 0; j < _bonusTokenAddrs.length; j++) {\r\n        address _bonusTokenAddr = _bonusTokenAddrs[j];\r\n        require(pools[_bonusTokenAddr].lastUpdatedAt == 0, \"BonusRewards: lpToken, not allowed\");\r\n        allowedTokenAuthorizers[_lpToken][_bonusTokenAddr] = _authorizers;\r\n        bonusTokenAddrMap[_bonusTokenAddr] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice collect bonus token dust to treasury\r\n  function collectDust(address _token, address _lpToken, uint256 _poolBonusId) external override onlyOwner {\r\n    require(pools[_token].lastUpdatedAt == 0, \"BonusRewards: lpToken, not allowed\");\r\n\r\n    if (_token == address(0)) { // token address(0) = ETH\r\n      payable(owner()).transfer(address(this).balance);\r\n    } else {\r\n      uint256 balance = IERC20(_token).balanceOf(address(this));\r\n      if (bonusTokenAddrMap[_token] == 1) {\r\n        // bonus token\r\n        Bonus memory bonus = pools[_lpToken].bonuses[_poolBonusId];\r\n        require(bonus.bonusTokenAddr == _token, \"BonusRewards: wrong pool\");\r\n        require(bonus.endTime + WEEK < block.timestamp, \"BonusRewards: not ready\");\r\n        balance = bonus.remBonus;\r\n        pools[_lpToken].bonuses[_poolBonusId].remBonus = 0;\r\n      }\r\n\r\n      IERC20(_token).transfer(owner(), balance);\r\n    }\r\n  }\r\n\r\n  function setResponders(address[] calldata _responders) external override onlyOwner {\r\n    responders = _responders;\r\n  }\r\n\r\n  function setPaused(bool _paused) external override {\r\n    require(_isAuthorized(responders), \"BonusRewards: caller not responder\");\r\n    paused = _paused;\r\n  }\r\n\r\n  function getPool(address _lpToken) external view override returns (Pool memory) {\r\n    return pools[_lpToken];\r\n  }\r\n\r\n  function getUser(address _lpToken, address _account) external view override returns (User memory, uint256[] memory) {\r\n    return (users[_lpToken][_account], viewRewards(_lpToken, _account));\r\n  }\r\n\r\n  function getAuthorizers(address _lpToken, address _bonusTokenAddr) external view override returns (address[] memory) {\r\n    return allowedTokenAuthorizers[_lpToken][_bonusTokenAddr];\r\n  }\r\n\r\n  function getResponders() external view override returns (address[] memory) {\r\n    return responders;\r\n  }\r\n\r\n  function viewRewards(address _lpToken, address _user) public view override returns (uint256[] memory) {\r\n    Pool memory pool = pools[_lpToken];\r\n    User memory user = users[_lpToken][_user];\r\n    uint256[] memory rewards = new uint256[](pool.bonuses.length);\r\n    if (user.amount <= 0) return rewards;\r\n\r\n    uint256 rewardsWriteoffsLen = user.rewardsWriteoffs.length;\r\n    for (uint256 i = 0; i < rewards.length; i ++) {\r\n      Bonus memory bonus = pool.bonuses[i];\r\n      if (bonus.startTime < block.timestamp && bonus.remBonus > 0) {\r\n        uint256 lpTotal = IERC20(_lpToken).balanceOf(address(this));\r\n        uint256 bonusForTime = _calRewardsForTime(bonus, pool.lastUpdatedAt);\r\n        uint256 bonusPerToken = bonus.accRewardsPerToken + bonusForTime / lpTotal;\r\n        uint256 rewardsWriteoff = rewardsWriteoffsLen <= i ? 0 : user.rewardsWriteoffs[i];\r\n        uint256 reward = user.amount * bonusPerToken / CAL_MULTIPLIER - rewardsWriteoff;\r\n        rewards[i] = reward < bonus.remBonus ? reward : bonus.remBonus;\r\n      }\r\n    }\r\n    return rewards;\r\n  }\r\n\r\n\r\n  function getPoolList() external view override returns (address[] memory) {\r\n    return poolList;\r\n  }\r\n\r\n  /// @notice update pool's bonus per staked token till current block timestamp, do nothing if pool does not exist\r\n  function _updatePool(address _lpToken) private {\r\n    Pool storage pool = pools[_lpToken];\r\n    uint256 poolLastUpdatedAt = pool.lastUpdatedAt;\r\n    if (poolLastUpdatedAt == 0 || block.timestamp <= poolLastUpdatedAt) return;\r\n    pool.lastUpdatedAt = block.timestamp;\r\n    uint256 lpTotal = IERC20(_lpToken).balanceOf(address(this));\r\n    if (lpTotal == 0) return;\r\n\r\n    for (uint256 i = 0; i < pool.bonuses.length; i ++) {\r\n      Bonus storage bonus = pool.bonuses[i];\r\n      if (poolLastUpdatedAt < bonus.endTime && bonus.startTime < block.timestamp) {\r\n        uint256 bonusForTime = _calRewardsForTime(bonus, poolLastUpdatedAt);\r\n        bonus.accRewardsPerToken = bonus.accRewardsPerToken + bonusForTime / lpTotal;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _updateUserWriteoffs(address _lpToken) private {\r\n    Bonus[] memory bonuses = pools[_lpToken].bonuses;\r\n    User storage user = users[_lpToken][msg.sender];\r\n    for (uint256 i = 0; i < bonuses.length; i++) {\r\n      // update writeoff to match current acc rewards per token\r\n      if (user.rewardsWriteoffs.length == i) {\r\n        user.rewardsWriteoffs.push(user.amount * bonuses[i].accRewardsPerToken / CAL_MULTIPLIER);\r\n      } else {\r\n        user.rewardsWriteoffs[i] = user.amount * bonuses[i].accRewardsPerToken / CAL_MULTIPLIER;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice tranfer upto what the contract has\r\n  function _safeTransfer(address _token, uint256 _amount) private returns (uint256 _transferred) {\r\n    IERC20 token = IERC20(_token);\r\n    uint256 balance = token.balanceOf(address(this));\r\n    if (balance > _amount) {\r\n      token.safeTransfer(msg.sender, _amount);\r\n      _transferred = _amount;\r\n    } else if (balance > 0) {\r\n      token.safeTransfer(msg.sender, balance);\r\n      _transferred = balance;\r\n    }\r\n  }\r\n\r\n  function _calRewardsForTime(Bonus memory _bonus, uint256 _lastUpdatedAt) internal view returns (uint256) {\r\n    if (_bonus.endTime <= _lastUpdatedAt) return 0;\r\n\r\n    uint256 calEndTime = block.timestamp > _bonus.endTime ? _bonus.endTime : block.timestamp;\r\n    uint256 calStartTime = _lastUpdatedAt > _bonus.startTime ? _lastUpdatedAt : _bonus.startTime;\r\n    uint256 timePassed = calEndTime - calStartTime;\r\n    return _bonus.weeklyRewards * CAL_MULTIPLIER * timePassed / WEEK;\r\n  }\r\n\r\n  function _claimRewards(address _lpToken, User memory _user) private {\r\n    // only claim if user has deposited before\r\n    if (_user.amount == 0) return;\r\n    uint256 rewardsWriteoffsLen = _user.rewardsWriteoffs.length;\r\n    Bonus[] memory bonuses = pools[_lpToken].bonuses;\r\n    for (uint256 i = 0; i < bonuses.length; i++) {\r\n      uint256 rewardsWriteoff = rewardsWriteoffsLen <= i ? 0 : _user.rewardsWriteoffs[i];\r\n      uint256 bonusSinceLastUpdate = _user.amount * bonuses[i].accRewardsPerToken / CAL_MULTIPLIER - rewardsWriteoff;\r\n      uint256 toTransfer = bonuses[i].remBonus < bonusSinceLastUpdate ? bonuses[i].remBonus : bonusSinceLastUpdate;\r\n      if (toTransfer == 0) continue;\r\n      uint256 transferred = _safeTransfer(bonuses[i].bonusTokenAddr, toTransfer);\r\n      pools[_lpToken].bonuses[i].remBonus = bonuses[i].remBonus - transferred;\r\n    }\r\n  }\r\n\r\n  // only owner or authorized users from list\r\n  function _isAuthorized(address[] memory checkList) private view returns (bool) {\r\n    if (msg.sender == owner()) return true;\r\n\r\n    for (uint256 i = 0; i < checkList.length; i++) {\r\n      if (msg.sender == checkList[i]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"_startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"_weeklyRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferAmount\",\"type\":\"uint256\"}],\"name\":\"addBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_lpTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_bonusTokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_authorizers\",\"type\":\"address[]\"}],\"name\":\"addPoolsAndAllowBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_lpTokens\",\"type\":\"address[]\"}],\"name\":\"claimRewardsForPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolBonusId\",\"type\":\"uint256\"}],\"name\":\"collectDust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_lpTokens\",\"type\":\"address[]\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolBonusId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bonusTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_transferAmount\",\"type\":\"uint256\"}],\"name\":\"extendBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusTokenAddr\",\"type\":\"address\"}],\"name\":\"getAuthorizers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bonusTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"endTime\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"weeklyRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardsPerToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remBonus\",\"type\":\"uint256\"}],\"internalType\":\"struct IBonusRewards.Bonus[]\",\"name\":\"bonuses\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct IBonusRewards.Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getResponders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardsWriteoffs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IBonusRewards.User\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_responders\",\"type\":\"address[]\"}],\"name\":\"setResponders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_weeklyRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"_startTime\",\"type\":\"uint48\"}],\"name\":\"updateBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BonusRewards","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d0a22542c34abc2f3422f5a3b9b9552342772b1c6669d52607c8083eaefe9881"}]}