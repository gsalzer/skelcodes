{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RollupProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd.\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {Pausable} from '@openzeppelin/contracts/utils/Pausable.sol';\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport {IVerifier} from './interfaces/IVerifier.sol';\\nimport {IRollupProcessor} from './interfaces/IRollupProcessor.sol';\\nimport {IFeeDistributor} from './interfaces/IFeeDistributor.sol';\\nimport {IERC20Permit} from './interfaces/IERC20Permit.sol';\\nimport {Decoder} from './Decoder.sol';\\nimport './libraries/RollupProcessorLibrary.sol';\\n\\n/**\\n * @title Rollup Processor\\n * @dev Smart contract responsible for processing Aztec zkRollups, including relaying them to a verifier\\n * contract for validation and performing all relevant ERC20 token transfers\\n */\\ncontract RollupProcessor is IRollupProcessor, Decoder, Ownable, Pausable {\\n    using SafeMath for uint256;\\n\\n    bytes32 public dataRoot = 0x2708a627d38d74d478f645ec3b4e91afa325331acf1acebe9077891146b75e39;\\n    bytes32 public nullRoot = 0x2694dbe3c71a25d92213422d392479e7b8ef437add81e1e17244462e6edca9b1;\\n    bytes32 public rootRoot = 0x2d264e93dc455751a721aead9dba9ee2a9fef5460921aeede73f63f6210e6851;\\n\\n    uint256 public dataSize;\\n    uint256 public nextRollupId;\\n\\n    IVerifier public verifier;\\n\\n    uint256 public constant numberOfAssets = 4;\\n    uint256 public constant txNumPubInputs = 12;\\n    uint256 public constant rollupNumPubInputs = 10 + numberOfAssets;\\n    uint256 public constant txPubInputLength = txNumPubInputs * 32; // public inputs length for of each inner proof tx\\n    uint256 public constant rollupPubInputLength = rollupNumPubInputs * 32;\\n    uint256 public constant ethAssetId = 0;\\n    uint256 public immutable escapeBlockLowerBound;\\n    uint256 public immutable escapeBlockUpperBound;\\n\\n    event RollupProcessed(\\n        uint256 indexed rollupId,\\n        bytes32 dataRoot,\\n        bytes32 nullRoot,\\n        bytes32 rootRoot,\\n        uint256 dataSize\\n    );\\n    event Deposit(uint256 assetId, address depositorAddress, uint256 depositValue);\\n    event Withdraw(uint256 assetId, address withdrawAddress, uint256 withdrawValue);\\n    event WithdrawError(bytes errorReason);\\n    event AssetAdded(uint256 indexed assetId, address indexed assetAddress);\\n    event RollupProviderUpdated(address indexed providerAddress, bool valid);\\n    event VerifierUpdated(address indexed verifierAddress);\\n\\n    // Array of supported ERC20 token address.\\n    address[] public supportedAssets;\\n\\n    // Mapping which maps an asset address to a bool, determining whether it supports\\n    // permit as according to ERC-2612\\n    mapping(address => bool) assetPermitSupport;\\n\\n    // Mapping from assetId to mapping of userAddress to public userBalance stored on this contract\\n    mapping(uint256 => mapping(address => uint256)) public userPendingDeposits;\\n\\n    mapping(address => mapping(bytes32 => bool)) public depositProofApprovals;\\n\\n    mapping(address => bool) public rollupProviders;\\n\\n    address public override feeDistributor;\\n\\n    // Metrics\\n    uint256[] public totalPendingDeposit;\\n    uint256[] public totalDeposited;\\n    uint256[] public totalWithdrawn;\\n    uint256[] public totalFees;\\n\\n    constructor(\\n        address _verifierAddress,\\n        uint256 _escapeBlockLowerBound,\\n        uint256 _escapeBlockUpperBound,\\n        address _contractOwner\\n    ) public {\\n        verifier = IVerifier(_verifierAddress);\\n        escapeBlockLowerBound = _escapeBlockLowerBound;\\n        escapeBlockUpperBound = _escapeBlockUpperBound;\\n        rollupProviders[msg.sender] = true;\\n        totalPendingDeposit.push(0);\\n        totalDeposited.push(0);\\n        totalWithdrawn.push(0);\\n        totalFees.push(0);\\n        transferOwnership(_contractOwner);\\n    }\\n\\n    function setRollupProvider(address providerAddress, bool valid) public override onlyOwner {\\n        rollupProviders[providerAddress] = valid;\\n        emit RollupProviderUpdated(providerAddress, valid);\\n    }\\n\\n    function setVerifier(address _verifierAddress) public override onlyOwner {\\n        verifier = IVerifier(_verifierAddress);\\n        emit VerifierUpdated(_verifierAddress);\\n    }\\n\\n    function setFeeDistributor(address feeDistributorAddress) public override onlyOwner {\\n        feeDistributor = feeDistributorAddress;\\n    }\\n\\n    /**\\n     * @dev Approve a proofHash for spending a users deposited funds, this is one way and must be called by the owner of the funds\\n     * @param _proofHash - keccack256 hash of the inner proof public inputs\\n     */\\n\\n    function approveProof(bytes32 _proofHash) public override whenNotPaused {\\n        depositProofApprovals[msg.sender][_proofHash] = true;\\n    }\\n\\n    /**\\n     * @dev Get the ERC20 token address of a supported asset, for a given assetId\\n     * @param assetId - identifier used to denote a particular asset\\n     */\\n    function getSupportedAsset(uint256 assetId) public view override returns (address) {\\n        if (assetId == ethAssetId) {\\n            return address(0x0);\\n        }\\n\\n        return supportedAssets[assetId - 1];\\n    }\\n\\n    /**\\n     * @dev Get the addresses of all supported ERC20 tokens\\n     */\\n    function getSupportedAssets() external view override returns (address[] memory) {\\n        return supportedAssets;\\n    }\\n\\n    function getTotalDeposited() external view override returns (uint256[] memory) {\\n        return totalDeposited;\\n    }\\n\\n    function getTotalWithdrawn() external view override returns (uint256[] memory) {\\n        return totalWithdrawn;\\n    }\\n\\n    function getTotalPendingDeposit() external view override returns (uint256[] memory) {\\n        return totalPendingDeposit;\\n    }\\n\\n    function getTotalFees() external view override returns (uint256[] memory) {\\n        return totalFees;\\n    }\\n\\n    /**\\n     * @dev Get the status of whether an asset supports the permit ERC-2612 approval flow\\n     * @param assetId - unique identifier of the supported asset\\n     */\\n    function getAssetPermitSupport(uint256 assetId) external view override returns (bool) {\\n        address assetAddress = getSupportedAsset(assetId);\\n        return assetPermitSupport[assetAddress];\\n    }\\n\\n    /**\\n     * @dev Get the status of the escape hatch, specifically retrieve whether the\\n     * hatch is open and also the number of blocks until the hatch will switch from\\n     * open to closed or vice versa\\n     */\\n    function getEscapeHatchStatus() public view override returns (bool, uint256) {\\n        uint256 blockNum = block.number;\\n\\n        bool isOpen = blockNum % escapeBlockUpperBound >= escapeBlockLowerBound;\\n        uint256 blocksRemaining = 0;\\n        if (isOpen) {\\n            // num blocks escape hatch will remain open for\\n            blocksRemaining = escapeBlockUpperBound - (blockNum % escapeBlockUpperBound);\\n        } else {\\n            // num blocks until escape hatch will be opened\\n            blocksRemaining = escapeBlockLowerBound - (blockNum % escapeBlockUpperBound);\\n        }\\n        return (isOpen, blocksRemaining);\\n    }\\n\\n    /**\\n     * @dev Get the balance of a user, for a particular asset, held on the user's behalf\\n     * by this contract\\n     * @param assetId - unique identifier of the asset\\n     * @param userAddress - Ethereum address of the user who's balance is being queried\\n     */\\n    function getUserPendingDeposit(uint256 assetId, address userAddress) external view override returns (uint256) {\\n        return userPendingDeposits[assetId][userAddress];\\n    }\\n\\n    /**\\n     * @dev Increase the userPendingDeposits mapping\\n     */\\n    function increasePendingDepositBalance(\\n        uint256 assetId,\\n        address depositorAddress,\\n        uint256 amount\\n    ) internal {\\n        userPendingDeposits[assetId][depositorAddress] = userPendingDeposits[assetId][depositorAddress].add(amount);\\n        totalPendingDeposit[assetId] = totalPendingDeposit[assetId].add(amount);\\n    }\\n\\n    /**\\n     * @dev Decrease the userPendingDeposits mapping\\n     */\\n    function decreasePendingDepositBalance(\\n        uint256 assetId,\\n        address transferFromAddress,\\n        uint256 amount\\n    ) internal {\\n        uint256 userBalance = userPendingDeposits[assetId][transferFromAddress];\\n        require(userBalance >= amount, 'Rollup Processor: INSUFFICIENT_DEPOSIT');\\n\\n        userPendingDeposits[assetId][transferFromAddress] = userBalance.sub(amount);\\n        totalPendingDeposit[assetId] = totalPendingDeposit[assetId].sub(amount);\\n        totalDeposited[assetId] = totalDeposited[assetId].add(amount);\\n    }\\n\\n    /**\\n     * @dev Set the mapping between an assetId and the address of the linked asset.\\n     * Protected by onlyOwner\\n     * @param linkedToken - address of the asset\\n     * @param supportsPermit - bool determining whether this supports permit\\n     */\\n    function setSupportedAsset(address linkedToken, bool supportsPermit) external override onlyOwner {\\n        require(linkedToken != address(0x0), 'Rollup Processor: ZERO_ADDRESS');\\n\\n        supportedAssets.push(linkedToken);\\n        assetPermitSupport[linkedToken] = supportsPermit;\\n\\n        uint256 assetId = supportedAssets.length;\\n        require(assetId < numberOfAssets, 'Rollup Processor: MAX_ASSET_REACHED');\\n\\n        totalPendingDeposit.push(0);\\n        totalDeposited.push(0);\\n        totalWithdrawn.push(0);\\n        totalFees.push(0);\\n\\n        emit AssetAdded(assetId, linkedToken);\\n    }\\n\\n    /**\\n     * @dev Update the value indicating whether a linked asset supports permit.\\n     * Protected by onlyOwner\\n     * @param assetId - unique ID of the asset\\n     * @param supportsPermit - bool determining whether this supports permit\\n     */\\n    function setAssetPermitSupport(uint256 assetId, bool supportsPermit) external override onlyOwner {\\n        address assetAddress = getSupportedAsset(assetId);\\n        require(assetAddress != address(0x0), 'Rollup Processor: TOKEN_ASSET_NOT_LINKED');\\n\\n        assetPermitSupport[assetAddress] = supportsPermit;\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Non-permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param amount - number of tokens being deposited\\n     * @param depositorAddress - address from which funds are being transferred to the contract\\n     */\\n    function depositPendingFunds(\\n        uint256 assetId,\\n        uint256 amount,\\n        address depositorAddress\\n    ) external payable override whenNotPaused {\\n        if (assetId == ethAssetId) {\\n            require(msg.value == amount, 'Rollup Processor: WRONG_AMOUNT');\\n\\n            increasePendingDepositBalance(assetId, depositorAddress, amount);\\n        } else {\\n            require(msg.value == 0, 'Rollup Processor: WRONG_PAYMENT_TYPE');\\n\\n            address assetAddress = getSupportedAsset(assetId);\\n            internalDeposit(assetId, assetAddress, depositorAddress, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param amount - number of tokens being deposited\\n     * @param depositorAddress - address from which funds are being transferred to the contract\\n     * @param spender - address being granted approval to spend the funds\\n     * @param permitApprovalAmount - amount permit signature is approving\\n     * @param deadline - when the permit signature expires\\n     * @param v - ECDSA sig param\\n     * @param r - ECDSA sig param\\n     * @param s - ECDSA sig param\\n     */\\n    function depositPendingFundsPermit(\\n        uint256 assetId,\\n        uint256 amount,\\n        address depositorAddress,\\n        address spender,\\n        uint256 permitApprovalAmount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override whenNotPaused {\\n        address assetAddress = getSupportedAsset(assetId);\\n        IERC20Permit(assetAddress).permit(depositorAddress, spender, permitApprovalAmount, deadline, v, r, s);\\n        internalDeposit(assetId, assetAddress, depositorAddress, amount);\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Non-permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param assetAddress - address of the ERC20 asset\\n     * @param depositorAddress - address from which funds are being transferred to the contract\\n     * @param amount - amount being deposited\\n     */\\n    function internalDeposit(\\n        uint256 assetId,\\n        address assetAddress,\\n        address depositorAddress,\\n        uint256 amount\\n    ) internal {\\n        // check user approved contract to transfer funds, so can throw helpful error to user\\n        uint256 rollupAllowance = IERC20(assetAddress).allowance(depositorAddress, address(this));\\n        require(rollupAllowance >= amount, 'Rollup Processor: INSUFFICIENT_TOKEN_APPROVAL');\\n\\n        IERC20(assetAddress).transferFrom(depositorAddress, address(this), amount);\\n        increasePendingDepositBalance(assetId, depositorAddress, amount);\\n\\n        emit Deposit(assetId, depositorAddress, amount);\\n    }\\n\\n    /**\\n     * @dev Process a rollup - decode the rollup, update relevant state variables and\\n     * verify the proof\\n     * @param proofData - cryptographic proof data associated with a rollup\\n     * @param signatures - bytes array of secp256k1 ECDSA signatures, authorising a transfer of tokens\\n     * from the publicOwner for the particular inner proof in question. There is a signature for each\\n     * inner proof.\\n     *\\n     * Structure of each signature in the bytes array is:\\n     * 0x00 - 0x20 : r\\n     * 0x20 - 0x40 : s\\n     * 0x40 - 0x60 : v (in form: 0x0000....0001b for example)\\n     *\\n     * @param viewingKeys - viewingKeys for the notes submitted in the rollup. Note: not used in the logic\\n     * of the rollupProcessor contract, but called here as a convenient to place data on chain\\n     */\\n    function escapeHatch(\\n        bytes calldata proofData,\\n        bytes calldata signatures,\\n        bytes calldata viewingKeys\\n    ) external override whenNotPaused {\\n        (bool isOpen, ) = getEscapeHatchStatus();\\n        require(isOpen, 'Rollup Processor: ESCAPE_BLOCK_RANGE_INCORRECT');\\n\\n        processRollupProof(proofData, signatures, viewingKeys);\\n    }\\n\\n    function processRollup(\\n        bytes calldata proofData,\\n        bytes calldata signatures,\\n        bytes calldata viewingKeys,\\n        bytes calldata providerSignature,\\n        address provider,\\n        address payable feeReceiver,\\n        uint256 feeLimit\\n    ) external override whenNotPaused {\\n        uint256 initialGas = gasleft();\\n\\n        require(rollupProviders[provider], 'Rollup Processor: UNKNOWN_PROVIDER');\\n        bytes memory sigData =\\n            abi.encodePacked(proofData[0:rollupPubInputLength], feeReceiver, feeLimit, feeDistributor);\\n        RollupProcessorLibrary.validateSignature(keccak256(sigData), providerSignature, provider);\\n\\n        processRollupProof(proofData, signatures, viewingKeys);\\n\\n        transferFee(proofData);\\n\\n        (bool success, ) =\\n            feeDistributor.call(\\n                abi.encodeWithSignature(\\n                    'reimburseGas(uint256,uint256,address)',\\n                    initialGas - gasleft(),\\n                    feeLimit,\\n                    feeReceiver\\n                )\\n            );\\n        require(success, 'Rollup Processor: REIMBURSE_GAS_FAILED');\\n    }\\n\\n    function processRollupProof(\\n        bytes memory proofData,\\n        bytes memory signatures,\\n        bytes calldata /*viewingKeys*/\\n    ) internal {\\n        uint256 numTxs = verifyProofAndUpdateState(proofData);\\n        processDepositsAndWithdrawals(proofData, numTxs, signatures);\\n    }\\n\\n    /**\\n     * @dev Verify the zk proof and update the contract state variables with those provided by the rollup.\\n     * @param proofData - cryptographic zk proof data. Passed to the verifier for verification.\\n     */\\n    function verifyProofAndUpdateState(bytes memory proofData) internal returns (uint256) {\\n        (\\n            bytes32 newDataRoot,\\n            bytes32 newNullRoot,\\n            uint256 rollupId,\\n            uint256 rollupSize,\\n            bytes32 newRootRoot,\\n            uint256 numTxs,\\n            uint256 newDataSize\\n        ) = validateMerkleRoots(proofData);\\n\\n        // Verify the rollup proof.\\n        //\\n        // We manually call the verifier contract via assembly. This is to prevent a\\n        // redundant copy of `proofData` into memory, which costs between 100,000 to 1,000,000 gas\\n        // depending on the rollup size!\\n        bool proof_verified = false;\\n        address verifierAddress;\\n        uint256 temp1;\\n        uint256 temp2;\\n        uint256 temp3;\\n        assembly {\\n            // Step 1: we need to insert 68 bytes of verifier 'calldata' just prior to proofData\\n            // Start by defining the start of our 'calldata'. Also grab the verifier contract address from storage\\n            let inputPtr := sub(proofData, 0x44)\\n            verifierAddress := sload(verifier_slot)\\n\\n            // Step 2: we need to overwrite the memory between `inputPtr` and `inputPtr + 68`\\n            // we load the existing 68 bytes of memory into stack variables temp1, temp2, temp3\\n            // Once we have called the verifier contract, we will write this data back into memory\\n            temp1 := mload(inputPtr)\\n            temp2 := mload(add(inputPtr, 0x20))\\n            temp3 := mload(add(inputPtr, 0x40))\\n\\n            // Step 3: insert our calldata into memory\\n            // We call the function `verify(bytes,uint256)`\\n            // The function signature is 0xac318c5d\\n            // Calldata map is:\\n            // 0x00 - 0x04 : 0xac318c5d\\n            // 0x04 - 0x24 : 0x40 (number of bytes between 0x04 and the start of the `proofData` array at 0x44)\\n            // 0x24 - 0x44 : rollupSize\\n            // 0x44 - .... : proofData (already present in memory)\\n            mstore8(inputPtr, 0xac)\\n            mstore8(add(inputPtr, 0x01), 0x31)\\n            mstore8(add(inputPtr, 0x02), 0x8c)\\n            mstore8(add(inputPtr, 0x03), 0x5d)\\n            mstore(add(inputPtr, 0x04), 0x40)\\n            mstore(add(inputPtr, 0x24), rollupSize)\\n\\n            // Total calldata size is proofData.length + 96 bytes (the 66 bytes we just wrote, plus the 32 byte 'length' field of proofData)\\n            let callSize := add(mload(proofData), 0x64)\\n\\n            // Step 4: Call our verifier contract. If does not return any values, but will throw an error if the proof is not valid\\n            // i.e. verified == false if proof is not valid\\n            proof_verified := staticcall(gas(), verifierAddress, inputPtr, callSize, 0x00, 0x00)\\n\\n            // Step 5: Restore the memory we overwrote with our 'calldata'\\n            mstore(inputPtr, temp1)\\n            mstore(add(inputPtr, 0x20), temp2)\\n            mstore(add(inputPtr, 0x40), temp3)\\n        }\\n\\n        // Check the proof is valid!\\n        require(proof_verified, 'proof verification failed');\\n\\n        // Update state variables.\\n        dataRoot = newDataRoot;\\n        nullRoot = newNullRoot;\\n        nextRollupId = rollupId.add(1);\\n        rootRoot = newRootRoot;\\n        dataSize = newDataSize;\\n\\n        emit RollupProcessed(rollupId, dataRoot, nullRoot, rootRoot, dataSize);\\n        return numTxs;\\n    }\\n\\n    /**\\n     * @dev Extract public inputs and validate they are inline with current contract state.\\n     * @param proofData - Rollup proof data.\\n     */\\n    function validateMerkleRoots(bytes memory proofData)\\n        internal\\n        view\\n        returns (\\n            bytes32,\\n            bytes32,\\n            uint256,\\n            uint256,\\n            bytes32,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        (\\n            // Stack to deep workaround:\\n            // 0: rollupId\\n            // 1: rollupSize\\n            // 2: dataStartIndex\\n            // 3: numTxs\\n            uint256[4] memory nums,\\n            bytes32 oldDataRoot,\\n            bytes32 newDataRoot,\\n            bytes32 oldNullRoot,\\n            bytes32 newNullRoot,\\n            bytes32 oldRootRoot,\\n            bytes32 newRootRoot\\n        ) = decodeProof(proofData, numberOfAssets);\\n\\n        // Escape hatch denominated by a rollup size of 0, which means inserting 2 new entries.\\n        nums[3] = nums[1] == 0 ? 1 : nums[1];\\n\\n        // Ensure we are inserting at the next subtree boundary.\\n        uint256 toInsert = nums[3].mul(2);\\n        if (dataSize % toInsert == 0) {\\n            require(nums[2] == dataSize, 'Rollup Processor: INCORRECT_DATA_START_INDEX');\\n        } else {\\n            uint256 expected = dataSize + toInsert - (dataSize % toInsert);\\n            require(nums[2] == expected, 'Rollup Processor: INCORRECT_DATA_START_INDEX');\\n        }\\n\\n        // Data validation checks.\\n        require(oldDataRoot == dataRoot, 'Rollup Processor: INCORRECT_DATA_ROOT');\\n        require(oldNullRoot == nullRoot, 'Rollup Processor: INCORRECT_NULL_ROOT');\\n        require(oldRootRoot == rootRoot, 'Rollup Processor: INCORRECT_ROOT_ROOT');\\n        require(nums[0] == nextRollupId, 'Rollup Processor: ID_NOT_SEQUENTIAL');\\n\\n        return (newDataRoot, newNullRoot, nums[0], nums[1], newRootRoot, nums[3], nums[2] + toInsert);\\n    }\\n\\n    /**\\n     * @dev Process deposits and withdrawls.\\n     * @param proofData - the proof data\\n     * @param numTxs - number of transactions rolled up in the proof\\n     * @param signatures - bytes array of secp256k1 ECDSA signatures, authorising a transfer of tokens\\n     */\\n    function processDepositsAndWithdrawals(\\n        bytes memory proofData,\\n        uint256 numTxs,\\n        bytes memory signatures\\n    ) internal {\\n        uint256 sigIndex = 0x00;\\n        uint256 proofDataPtr;\\n        assembly {\\n            proofDataPtr := add(proofData, 0x20) // add 0x20 to skip over 1st field in bytes array (the length field)\\n        }\\n        proofDataPtr += rollupPubInputLength; // update pointer to skip over rollup public inputs and point to inner tx public inputs\\n        uint256 end = proofDataPtr + (numTxs * txPubInputLength);\\n        uint256 stepSize = txPubInputLength;\\n\\n        // This is a bit of a hot loop, we iterate over every tx to determine whether to process deposits or withdrawals.\\n        while (proofDataPtr < end) {\\n            // extract the minimum information we need to determine whether to skip this iteration\\n            uint256 proofId;\\n            uint256 publicInput;\\n            uint256 publicOutput;\\n            bool txNeedsProcessing;\\n            assembly {\\n                proofId := mload(proofDataPtr)\\n                publicInput := mload(add(proofDataPtr, 0x20))\\n                publicOutput := mload(add(proofDataPtr, 0x40))\\n                // only process deposits and withdrawals iff\\n                // the proofId == 0 (not an account proof) and publicInput > 0 OR publicOutput > 0\\n                txNeedsProcessing := and(iszero(proofId), or(not(iszero(publicInput)), not(iszero(publicOutput))))\\n            }\\n\\n            if (txNeedsProcessing) {\\n                // extract asset Id\\n                uint256 assetId;\\n                assembly {\\n                    assetId := mload(add(proofDataPtr, 0x60))\\n                }\\n\\n                if (publicInput > 0) {\\n                    // validate user has approved deposit\\n                    address inputOwner;\\n                    bytes32 digest;\\n                    assembly {\\n                        inputOwner := mload(add(proofDataPtr, 0x140))\\n\\n                        // compute the message digest to check if user has approved tx\\n                        digest := keccak256(proofDataPtr, stepSize)\\n                    }\\n                    if (!depositProofApprovals[inputOwner][digest]) {\\n                        // extract and validate signature\\n                        // we can create a bytes memory container for the signature without allocating new memory,\\n                        // by overwriting the previous 32 bytes in the `signatures` array with the 'length' of our synthetic byte array (92)\\n                        // we store the memory we overwrite in `temp`, so that we can restore it\\n                        bytes memory signature;\\n                        uint256 temp;\\n                        assembly {\\n                            // set `signature` to point to 32 bytes less than the desired `r, s, v` values in `signatures`\\n                            signature := add(signatures, sigIndex)\\n                            // cache the memory we're about to overwrite\\n                            temp := mload(signature)\\n                            // write in a 92-byte 'length' parameter into the `signature` bytes array\\n                            mstore(signature, 0x60)\\n                        }\\n                        // validate the signature\\n                        RollupProcessorLibrary.validateUnpackedSignature(digest, signature, inputOwner);\\n                        // restore the memory we overwrote\\n                        assembly {\\n                            mstore(signature, temp)\\n                            sigIndex := add(sigIndex, 0x60)\\n                        }\\n                    }\\n                    decreasePendingDepositBalance(assetId, inputOwner, publicInput);\\n                }\\n\\n                if (publicOutput > 0) {\\n                    address outputOwner;\\n                    assembly {\\n                        outputOwner := mload(add(proofDataPtr, 0x160))\\n                    }\\n                    withdraw(publicOutput, outputOwner, assetId);\\n                }\\n            }\\n            proofDataPtr += txPubInputLength;\\n        }\\n    }\\n\\n    function transferFee(bytes memory proofData) internal {\\n        for (uint256 i = 0; i < numberOfAssets; ++i) {\\n            uint256 txFee = extractTotalTxFee(proofData, i);\\n            if (txFee > 0) {\\n                bool success;\\n                if (i == ethAssetId) {\\n                    (success, ) = payable(feeDistributor).call{value: txFee}('');\\n                } else {\\n                    address assetAddress = getSupportedAsset(i);\\n                    IERC20(assetAddress).approve(feeDistributor, txFee);\\n                    (success, ) = feeDistributor.call(abi.encodeWithSignature('deposit(uint256,uint256)', i, txFee));\\n                }\\n                require(success, 'Rollup Processor: DEPOSIT_TX_FEE_FAILED');\\n                totalFees[i] = totalFees[i].add(txFee);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal utility function to withdraw funds from the contract to a receiver address\\n     * @param withdrawValue - value being withdrawn from the contract\\n     * @param receiverAddress - address receiving public ERC20 tokens\\n     * @param assetId - ID of the asset for which a withdrawl is being performed\\n     */\\n    function withdraw(\\n        uint256 withdrawValue,\\n        address receiverAddress,\\n        uint256 assetId\\n    ) internal {\\n        require(receiverAddress != address(0), 'Rollup Processor: ZERO_ADDRESS');\\n        if (assetId == 0) {\\n            // We explicitly do not throw if this call fails, as this opens up the possiblity of\\n            // griefing attacks, as engineering a failed withdrawal will invalidate an entire rollup block\\n            payable(receiverAddress).call{gas: 30000, value: withdrawValue}('');\\n        } else {\\n            address assetAddress = getSupportedAsset(assetId);\\n            IERC20(assetAddress).transfer(receiverAddress, withdrawValue);\\n        }\\n        totalWithdrawn[assetId] = totalWithdrawn[assetId].add(withdrawValue);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IVerifier {\\n    function verify(bytes memory serialized_proof, uint256 _keyId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRollupProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IRollupProcessor {\\n    function feeDistributor() external view returns (address);\\n\\n    function escapeHatch(\\n        bytes calldata proofData,\\n        bytes calldata signatures,\\n        bytes calldata viewingKeys\\n    ) external;\\n\\n    function processRollup(\\n        bytes calldata proofData,\\n        bytes calldata signatures,\\n        bytes calldata viewingKeys,\\n        bytes calldata providerSignature,\\n        address provider,\\n        address payable feeReceiver,\\n        uint256 feeLimit\\n    ) external;\\n\\n    function depositPendingFunds(\\n        uint256 assetId,\\n        uint256 amount,\\n        address owner\\n    ) external payable;\\n\\n    function depositPendingFundsPermit(\\n        uint256 assetId,\\n        uint256 amount,\\n        address owner,\\n        address spender,\\n        uint256 permitApprovalAmount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function setRollupProvider(address provderAddress, bool valid) external;\\n\\n    function approveProof(bytes32 _proofHash) external;\\n\\n    function setFeeDistributor(address feeDistributorAddress) external;\\n\\n    function setVerifier(address verifierAddress) external;\\n\\n    function setSupportedAsset(address linkedToken, bool supportsPermit) external;\\n\\n    function setAssetPermitSupport(uint256 assetId, bool supportsPermit) external;\\n\\n    function getSupportedAsset(uint256 assetId) external view returns (address);\\n\\n    function getSupportedAssets() external view returns (address[] memory);\\n\\n    function getTotalDeposited() external view returns (uint256[] memory);\\n\\n    function getTotalWithdrawn() external view returns (uint256[] memory);\\n\\n    function getTotalPendingDeposit() external view returns (uint256[] memory);\\n\\n    function getTotalFees() external view returns (uint256[] memory);\\n\\n    function getAssetPermitSupport(uint256 assetId) external view returns (bool);\\n\\n    function getEscapeHatchStatus() external view returns (bool, uint256);\\n\\n    function getUserPendingDeposit(uint256 assetId, address userAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IFeeDistributor {\\n    event FeeReimbursed(address receiver, uint256 amount);\\n\\n    function txFeeBalance(uint256 assetId) external view returns (uint256);\\n\\n    function deposit(uint256 assetId, uint256 amount) external payable returns (uint256 depositedAmount);\\n\\n    function reimburseGas(\\n        uint256 gasUsed,\\n        uint256 feeLimit,\\n        address payable feeReceiver\\n    ) external returns (uint256 reimbursement);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IERC20Permit is IERC20 {\\n    function nonces(address user) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Decoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\nimport {Types} from './verifier/cryptography/Types.sol';\\nimport {Bn254Crypto} from './verifier/cryptography/Bn254Crypto.sol';\\n\\ncontract Decoder {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Decode the public inputs component of proofData. Required to update state variables\\n     * @param proofData - cryptographic proofData associated with a rollup\\n     */\\n    function decodeProof(bytes memory proofData, uint256 numberOfAssets)\\n        internal\\n        pure\\n        returns (\\n            uint256[4] memory nums,\\n            bytes32 oldDataRoot,\\n            bytes32 newDataRoot,\\n            bytes32 oldNullRoot,\\n            bytes32 newNullRoot,\\n            bytes32 oldRootRoot,\\n            bytes32 newRootRoot\\n        )\\n    {\\n        uint256 rollupId;\\n        uint256 rollupSize;\\n        uint256 dataStartIndex;\\n        uint256 numTxs;\\n        assembly {\\n            let dataStart := add(proofData, 0x20) // jump over first word, it's length of data\\n            rollupId := mload(dataStart)\\n            rollupSize := mload(add(dataStart, 0x20))\\n            dataStartIndex := mload(add(dataStart, 0x40))\\n            oldDataRoot := mload(add(dataStart, 0x60))\\n            newDataRoot := mload(add(dataStart, 0x80))\\n            oldNullRoot := mload(add(dataStart, 0xa0))\\n            newNullRoot := mload(add(dataStart, 0xc0))\\n            oldRootRoot := mload(add(dataStart, 0xe0))\\n            newRootRoot := mload(add(dataStart, 0x100))\\n            numTxs := mload(add(add(dataStart, 0x120), mul(0x20, numberOfAssets)))\\n        }\\n        return (\\n            [rollupId, rollupSize, dataStartIndex, numTxs],\\n            oldDataRoot,\\n            newDataRoot,\\n            oldNullRoot,\\n            newNullRoot,\\n            oldRootRoot,\\n            newRootRoot\\n        );\\n    }\\n\\n    function extractTotalTxFee(bytes memory proofData, uint256 assetId) internal pure returns (uint256) {\\n        uint256 totalTxFee;\\n        assembly {\\n            totalTxFee := mload(add(add(proofData, 0x140), mul(0x20, assetId)))\\n        }\\n        return totalTxFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RollupProcessorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\nlibrary RollupProcessorLibrary {\\n\\n    /**\\n    * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n    * to prevent signature malleability based attacks\\n    * @param digest - Hashed data being signed over.\\n    * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n    * @param signer - Address that signs the signature.\\n    */\\n    function validateSignature(\\n        bytes32 digest,\\n        bytes memory signature,\\n        address signer\\n    ) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        require(signer != address(0x0), 'validateSignature: ZERO_ADDRESS');\\n\\n\\n        // prepend \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" to the digest to create the signed message\\n        bytes32 message;\\n        assembly {\\n            mstore(0, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(add(0, 28), digest)\\n            message := keccak256(0, 60)\\n        }\\n        assembly {\\n            let mPtr := mload(0x40)\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(mPtr, message)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := shr(248, mload(add(signature, 0x60))) // bitshifting, to resemble padLeft\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n            * Original memory map for input to precompile\\n            *\\n            * signature : signature + 0x20            message\\n            * signature + 0x20 : signature + 0x40     r\\n            * signature + 0x40 : signature + 0x60     s\\n            * signature + 0x60 : signature + 0x80     v\\n            * Desired memory map for input to precompile\\n            *\\n            * signature : signature + 0x20            message\\n            * signature + 0x20 : signature + 0x40     v\\n            * signature + 0x40 : signature + 0x60     r\\n            * signature + 0x60 : signature + 0x80     s\\n            */\\n\\n            // store s\\n            mstore(add(mPtr, 0x60), s)\\n            // store r\\n            mstore(add(mPtr, 0x40), mload(add(signature, 0x20)))\\n            // store v\\n            mstore(add(mPtr, 0x20), v)\\n            result := and(\\n                and(\\n                    // validate s is in lower half order\\n                    lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                    and(\\n                        // validate signature length == 0x41\\n                        eq(byteLength, 0x41),\\n                        // validate v == 27 or v == 28\\n                        or(eq(v, 27), eq(v, 28))\\n                    )\\n                ),\\n                // validate call to ecrecover precompile succeeds\\n                staticcall(gas(), 0x01, mPtr, 0x80, mPtr, 0x20)\\n            )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(message, mload(mPtr))\\n            case 0 {\\n                recoveredSigner := mload(mPtr)\\n            }\\n            mstore(mPtr, byteLength) // and put the byte length back where it belongs\\n        \\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n\\n        require(result, 'validateSignature: signature recovery failed');\\n        require(recoveredSigner == signer, 'validateSignature: INVALID_SIGNATURE');\\n    }\\n\\n    /**\\n    * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n    * to prevent signature malleability based attacks\\n    * This 'Unpacked' version expects 'signature' to be a 92-byte array.\\n    * i.e. the `v` parameter occupies a full 32 bytes of memory, not 1 byte \\n    * @param digest - Hashed data being signed over.\\n    * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n    * @param signer - Address that signs the signature.\\n    */\\n    function validateUnpackedSignature(\\n        bytes32 digest,\\n        bytes memory signature,\\n        address signer\\n    ) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        require(signer != address(0x0), 'validateSignature: ZERO_ADDRESS');\\n\\n\\n        // prepend \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" to the digest to create the signed message\\n        bytes32 message;\\n        assembly {\\n            mstore(0, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(28, digest)\\n            message := keccak256(0, 60)\\n        }\\n        assembly {\\n            // There's a little trick we can pull. We expect `signature` to be a byte array, of length 0x60, with\\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `signature`.\\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\\n            // load length as a temporary variable\\n            // N.B. we mutate the signature by re-ordering r, s, and v!\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(signature, message)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := mload(add(signature, 0x60))\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n            * Original memory map for input to precompile\\n            *\\n            * signature : signature + 0x20            message\\n            * signature + 0x20 : signature + 0x40     r\\n            * signature + 0x40 : signature + 0x60     s\\n            * signature + 0x60 : signature + 0x80     v\\n            * Desired memory map for input to precompile\\n            *\\n            * signature : signature + 0x20            message\\n            * signature + 0x20 : signature + 0x40     v\\n            * signature + 0x40 : signature + 0x60     r\\n            * signature + 0x60 : signature + 0x80     s\\n            */\\n\\n            // move s to v position\\n            mstore(add(signature, 0x60), s)\\n            // move r to s position\\n            mstore(add(signature, 0x40), mload(add(signature, 0x20)))\\n            // move v to r position\\n            mstore(add(signature, 0x20), v)\\n            result := and(\\n                and(\\n                    // validate s is in lower half order\\n                    lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                    and(\\n                        // validate signature length == 0x60 (unpacked)\\n                        eq(byteLength, 0x60),\\n                        // validate v == 27 or v == 28\\n                        or(eq(v, 27), eq(v, 28))\\n                    )\\n                ),\\n                // validate call to ecrecover precompile succeeds\\n                staticcall(gas(), 0x01, signature, 0x80, signature, 0x20)\\n            )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(message, mload(signature))\\n            case 0 {\\n                recoveredSigner := mload(signature)\\n            }\\n            mstore(signature, byteLength) // and put the byte length back where it belongs\\n        \\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n\\n        require(result, 'validateSignature: signature recovery failed');\\n        require(recoveredSigner == signer, 'validateSignature: INVALID_SIGNATURE');\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary Types {\\n    uint256 constant PROGRAM_WIDTH = 4;\\n    uint256 constant NUM_NU_CHALLENGES = 11;\\n\\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct Proof {\\n        G1Point W1;\\n        G1Point W2;\\n        G1Point W3;\\n        G1Point W4;\\n        G1Point Z;\\n        G1Point T1;\\n        G1Point T2;\\n        G1Point T3;\\n        G1Point T4;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 w4;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        uint256 sigma3;\\n        uint256 q_arith;\\n        uint256 q_ecc;\\n        uint256 q_c;\\n        uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        uint256 w1_omega;\\n        uint256 w2_omega;\\n        uint256 w3_omega;\\n        uint256 w4_omega;\\n        G1Point PI_Z;\\n        G1Point PI_Z_OMEGA;\\n        G1Point recursive_P1;\\n        G1Point recursive_P2;\\n        uint256 quotient_polynomial_eval;\\n    }\\n\\n    struct ChallengeTranscript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        uint256 v7;\\n        uint256 v8;\\n        uint256 v9;\\n        uint256 v10;\\n    }\\n\\n    struct VerificationKey {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        G1Point Q1;\\n        G1Point Q2;\\n        G1Point Q3;\\n        G1Point Q4;\\n        G1Point Q5;\\n        G1Point QM;\\n        G1Point QC;\\n        G1Point QARITH;\\n        G1Point QECC;\\n        G1Point QRANGE;\\n        G1Point QLOGIC;\\n        G1Point SIGMA1;\\n        G1Point SIGMA2;\\n        G1Point SIGMA3;\\n        G1Point SIGMA4;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        G2Point g2_x;\\n\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Bn254Crypto.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from \\\"./Types.sol\\\";\\n\\n/**\\n * @title Bn254 elliptic curve crypto\\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\\n */\\nlibrary Bn254Crypto {\\n    uint256 constant p_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\\n    // it is cheaper than using the pow precompile\\n    function pow_small(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal pure returns (uint256) {\\n        uint256 result = 1;\\n        uint256 input = base;\\n        uint256 count = 1;\\n\\n        assembly {\\n            let endpoint := add(exponent, 0x01)\\n            for {} lt(count, endpoint) { count := add(count, count) }\\n            {\\n                if and(exponent, count) {\\n                    result := mulmod(result, input, modulus)\\n                }\\n                input := mulmod(input, input, modulus)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function invert(uint256 fr) internal view returns (uint256)\\n    {\\n        uint256 output;\\n        bool success;\\n        uint256 p = r_mod;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), fr)\\n            mstore(add(mPtr, 0x80), sub(p, 2))\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            output := mload(0x00)\\n        }\\n        require(success, \\\"pow precompile call failed!\\\");\\n        return output;\\n    }\\n\\n    function new_g1(uint256 x, uint256 y)\\n        internal\\n        pure\\n        returns (Types.G1Point memory)\\n    {\\n        uint256 xValue;\\n        uint256 yValue;\\n        assembly {\\n            xValue := mod(x, r_mod)\\n            yValue := mod(y, r_mod)\\n        }\\n        return Types.G1Point(xValue, yValue);\\n    }\\n\\n    function new_g2(uint256 x0, uint256 x1, uint256 y0, uint256 y1)\\n        internal\\n        pure\\n        returns (Types.G2Point memory)\\n    {\\n        return Types.G2Point(x0, x1, y0, y1);\\n    }\\n\\n    function P1() internal pure returns (Types.G1Point memory) {\\n        return Types.G1Point(1, 2);\\n    }\\n\\n    function P2() internal pure returns (Types.G2Point memory) {\\n        return Types.G2Point({\\n            x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n            x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\\n            y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n            y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n        });\\n    }\\n\\n\\n    /// Evaluate the following pairing product:\\n    /// e(a1, a2).e(-b1, b2) == 1\\n    function pairingProd2(\\n        Types.G1Point memory a1,\\n        Types.G2Point memory a2,\\n        Types.G1Point memory b1,\\n        Types.G2Point memory b2\\n    ) internal view returns (bool) {\\n        validateG1Point(a1);\\n        validateG1Point(b1);\\n        bool success;\\n        uint256 out;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(a1))\\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\\n            mstore(add(mPtr, 0x40), mload(a2))\\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\\n\\n            mstore(add(mPtr, 0xc0), mload(b1))\\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\\n            mstore(add(mPtr, 0x100), mload(b2))\\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\\n            success := staticcall(\\n                gas(),\\n                8,\\n                mPtr,\\n                0x180,\\n                0x00,\\n                0x20\\n            )\\n            out := mload(0x00)\\n        }\\n        require(success, \\\"Pairing check failed!\\\");\\n        return (out != 0);\\n    }\\n\\n    /**\\n    * validate the following:\\n    *   x != 0\\n    *   y != 0\\n    *   x < p\\n    *   y < p\\n    *   y^2 = x^3 + 3 mod p\\n    */\\n    function validateG1Point(Types.G1Point memory point) internal pure {\\n        bool is_well_formed;\\n        uint256 p = p_mod;\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n\\n            is_well_formed := and(\\n                and(\\n                    and(lt(x, p), lt(y, p)),\\n                    not(or(iszero(x), iszero(y)))\\n                ),\\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\\n            )\\n        }\\n        require(is_well_formed, \\\"Bn254: G1 point not on curve, or is malformed\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_escapeBlockLowerBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_escapeBlockUpperBound\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"AssetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rollupId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nullRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rootRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dataSize\",\"type\":\"uint256\"}],\"name\":\"RollupProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"providerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"RollupProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifierAddress\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawValue\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"errorReason\",\"type\":\"bytes\"}],\"name\":\"WithdrawError\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofHash\",\"type\":\"bytes32\"}],\"name\":\"approveProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"}],\"name\":\"depositPendingFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"permitApprovalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositPendingFundsPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"depositProofApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escapeBlockLowerBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escapeBlockUpperBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"viewingKeys\",\"type\":\"bytes\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethAssetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetPermitSupport\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEscapeHatchStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getSupportedAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDeposited\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalFees\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPendingDeposit\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserPendingDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextRollupId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nullRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"viewingKeys\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"providerSignature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeLimit\",\"type\":\"uint256\"}],\"name\":\"processRollup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupNumPubInputs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rollupProviders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupPubInputLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"supportsPermit\",\"type\":\"bool\"}],\"name\":\"setAssetPermitSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeDistributorAddress\",\"type\":\"address\"}],\"name\":\"setFeeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"providerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"setRollupProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkedToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"supportsPermit\",\"type\":\"bool\"}],\"name\":\"setSupportedAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportedAssets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPendingDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txNumPubInputs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txPubInputLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPendingDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RollupProcessor","CompilerVersion":"v0.6.10+commit.00c0fcaf","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dcc80db987bf63f01b7bafced6230de5002ef87400000000000000000000000000000000000000000000000000000000000011d000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000fcf75295f242c4e87203abb5d7c9bbeda90a8895","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}