{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\nimport \\\"./IContractRegistry.sol\\\";\\nimport \\\"./ILockable.sol\\\";\\nimport \\\"./IContractRegistryListener.sol\\\";\\nimport \\\"./WithClaimableRegistryManagement.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\ncontract ContractRegistry is IContractRegistry, Initializable, WithClaimableRegistryManagement {\\n\\n\\taddress previousContractRegistry;\\n\\tmapping(string =\\u003e address) contracts;\\n\\taddress[] managedContractAddresses;\\n\\tmapping(string =\\u003e address) managers;\\n\\n\\tconstructor(address _previousContractRegistry, address registryAdmin) public {\\n\\t\\tpreviousContractRegistry = _previousContractRegistry;\\n\\t\\t_transferRegistryManagement(registryAdmin);\\n\\t}\\n\\n\\tmodifier onlyAdmin {\\n\\t\\trequire(msg.sender == registryAdmin() || msg.sender == initializationAdmin(), \\\"sender is not an admin (registryAdmin or initializationAdmin when initialization in progress)\\\");\\n\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyAdminOrMigrationManager {\\n\\t\\trequire(msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == managers[\\\"migrationManager\\\"], \\\"sender is not an admin (registryAdmin or initializationAdmin when initialization in progress) and not the migration manager\\\");\\n\\n\\t\\t_;\\n\\t}\\n\\n\\t/*\\n\\t* External functions\\n\\t*/\\n\\n\\tfunction setContract(string calldata contractName, address addr, bool managedContract) external override onlyAdminOrMigrationManager {\\n\\t\\trequire(!managedContract || addr != address(0), \\\"managed contract may not have address(0)\\\");\\n\\t\\tremoveManagedContract(contracts[contractName]);\\n\\t\\tcontracts[contractName] = addr;\\n\\t\\tif (managedContract) {\\n\\t\\t\\taddManagedContract(addr);\\n\\t\\t}\\n\\t\\temit ContractAddressUpdated(contractName, addr, managedContract);\\n\\t\\tnotifyOnContractsChange();\\n\\t}\\n\\n\\tfunction getContract(string calldata contractName) external override view returns (address) {\\n\\t\\treturn contracts[contractName];\\n\\t}\\n\\n\\tfunction lockContracts() external override onlyAdminOrMigrationManager {\\n\\t\\tfor (uint i = 0; i \\u003c managedContractAddresses.length; i++) {\\n\\t\\t\\tILockable(managedContractAddresses[i]).lock();\\n\\t\\t}\\n\\t}\\n\\n\\tfunction unlockContracts() external override onlyAdminOrMigrationManager {\\n\\t\\tfor (uint i = 0; i \\u003c managedContractAddresses.length; i++) {\\n\\t\\t\\tILockable(managedContractAddresses[i]).unlock();\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getManagedContracts() external override view returns (address[] memory) {\\n\\t\\treturn managedContractAddresses;\\n\\t}\\n\\n\\tfunction setManager(string calldata role, address manager) external override onlyAdmin {\\n\\t\\tmanagers[role] = manager;\\n\\t\\temit ManagerChanged(role, manager);\\n\\t}\\n\\n\\tfunction getManager(string calldata role) external override view returns (address) {\\n\\t\\treturn managers[role];\\n\\t}\\n\\n\\tfunction setNewContractRegistry(IContractRegistry newRegistry) external override onlyAdmin {\\n\\t\\tfor (uint i = 0; i \\u003c managedContractAddresses.length; i++) {\\n\\t\\t\\tIContractRegistryListener(managedContractAddresses[i]).setContractRegistry(newRegistry);\\n\\t\\t\\tIContractRegistryListener(managedContractAddresses[i]).refreshContracts();\\n\\t\\t}\\n\\t\\temit ContractRegistryUpdated(address(newRegistry));\\n\\t}\\n\\n\\tfunction getPreviousContractRegistry() external override view returns (address) {\\n\\t\\treturn previousContractRegistry;\\n\\t}\\n\\n\\t/*\\n\\t* Private methods\\n\\t*/\\n\\n\\tfunction notifyOnContractsChange() private {\\n\\t\\tfor (uint i = 0; i \\u003c managedContractAddresses.length; i++) {\\n\\t\\t\\tIContractRegistryListener(managedContractAddresses[i]).refreshContracts();\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addManagedContract(address addr) private {\\n\\t\\tmanagedContractAddresses.push(addr);\\n\\t}\\n\\n\\tfunction removeManagedContract(address addr) private {\\n\\t\\tuint length = managedContractAddresses.length;\\n\\t\\tfor (uint i = 0; i \\u003c length; i++) {\\n\\t\\t\\tif (managedContractAddresses[i] == addr) {\\n\\t\\t\\t\\tif (i != length - 1) {\\n\\t\\t\\t\\t\\tmanagedContractAddresses[i] = managedContractAddresses[length-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmanagedContractAddresses.pop();\\n\\t\\t\\t\\tlength--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}\\n\"},\"ContractRegistryAccessor.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IContractRegistry.sol\\\";\\nimport \\\"./WithClaimableRegistryManagement.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\\n\\n    IContractRegistry private contractRegistry;\\n\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\\n        require(address(_contractRegistry) != address(0), \\\"_contractRegistry cannot be 0\\\");\\n        setContractRegistry(_contractRegistry);\\n        _transferRegistryManagement(_registryAdmin);\\n    }\\n\\n    modifier onlyAdmin {\\n        require(isAdmin(), \\\"sender is not an admin (registryManger or initializationAdmin)\\\");\\n\\n        _;\\n    }\\n\\n    function isManager(string memory role) internal view returns (bool) {\\n        IContractRegistry _contractRegistry = contractRegistry;\\n        return isAdmin() || _contractRegistry != IContractRegistry(0) \\u0026\\u0026 contractRegistry.getManager(role) == msg.sender;\\n    }\\n\\n    function isAdmin() internal view returns (bool) {\\n        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);\\n    }\\n\\n    function getProtocolContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"protocol\\\");\\n    }\\n\\n    function getStakingRewardsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"stakingRewards\\\");\\n    }\\n\\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"feesAndBootstrapRewards\\\");\\n    }\\n\\n    function getCommitteeContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"committee\\\");\\n    }\\n\\n    function getElectionsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"elections\\\");\\n    }\\n\\n    function getDelegationsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"delegations\\\");\\n    }\\n\\n    function getGuardiansRegistrationContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"guardiansRegistration\\\");\\n    }\\n\\n    function getCertificationContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"certification\\\");\\n    }\\n\\n    function getStakingContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"staking\\\");\\n    }\\n\\n    function getSubscriptionsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"subscriptions\\\");\\n    }\\n\\n    function getStakingRewardsWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"stakingRewardsWallet\\\");\\n    }\\n\\n    function getBootstrapRewardsWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"bootstrapRewardsWallet\\\");\\n    }\\n\\n    function getGeneralFeesWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"generalFeesWallet\\\");\\n    }\\n\\n    function getCertifiedFeesWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"certifiedFeesWallet\\\");\\n    }\\n\\n    function getStakingContractHandler() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"stakingContractHandler\\\");\\n    }\\n\\n    /*\\n    * Governance functions\\n    */\\n\\n    event ContractRegistryAddressUpdated(address addr);\\n\\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \\\"new contract registry must provide the previous contract registry\\\");\\n        contractRegistry = newContractRegistry;\\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\\n    }\\n\\n    function getContractRegistry() public view returns (IContractRegistry) {\\n        return contractRegistry;\\n    }\\n\\n}\\n\"},\"IContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IContractRegistry {\\n\\n\\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\\n\\tevent ManagerChanged(string role, address newManager);\\n\\tevent ContractRegistryUpdated(address newContractRegistry);\\n\\n\\t/*\\n\\t* External functions\\n\\t*/\\n\\n\\t/// @dev updates the contracts address and emits a corresponding event\\n\\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\\n\\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\\n\\n\\t/// @dev returns the current address of the given contracts\\n\\tfunction getContract(string calldata contractName) external view returns (address);\\n\\n\\t/// @dev returns the list of contract addresses managed by the registry\\n\\tfunction getManagedContracts() external view returns (address[] memory);\\n\\n\\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\\n\\n\\tfunction getManager(string calldata role) external view returns (address);\\n\\n\\tfunction lockContracts() external /* onlyAdmin */;\\n\\n\\tfunction unlockContracts() external /* onlyAdmin */;\\n\\n\\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\\n\\n\\tfunction getPreviousContractRegistry() external view returns (address);\\n\\n}\\n\"},\"IContractRegistryListener.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IContractRegistry.sol\\\";\\n\\ninterface IContractRegistryListener {\\n\\n    function refreshContracts() external;\\n\\n    function setContractRegistry(IContractRegistry newRegistry) external;\\n\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IFeesWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IMigratableFeesWallet.sol\\\";\\n\\n/// @title Fees Wallet contract interface, manages the fee buckets\\ninterface IFeesWallet {\\n\\n    event FeesWithdrawnFromBucket(uint256 bucketId, uint256 withdrawn, uint256 total);\\n    event FeesAddedToBucket(uint256 bucketId, uint256 added, uint256 total);\\n\\n    /*\\n     *   External methods\\n     */\\n\\n    /// @dev Called by: subscriptions contract.\\n    /// Top-ups the fee pool with the given amount at the given rate (typically called by the subscriptions contract).\\n    function fillFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external;\\n\\n    /// @dev collect fees from the buckets since the last call and transfers the amount back.\\n    /// Called by: only Rewards contract.\\n    function collectFees() external returns (uint256 collectedFees) /* onlyRewardsContract */;\\n\\n    /// @dev Returns the amount of fees that are currently available for withdrawal\\n    function getOutstandingFees() external view returns (uint256 outstandingFees);\\n\\n    /*\\n     * General governance\\n     */\\n\\n    event EmergencyWithdrawal(address addr);\\n\\n    /// @dev migrates the fees of bucket starting at startTimestamp.\\n    /// bucketStartTime must be a bucket\\u0027s start time.\\n    /// Calls acceptBucketMigration in the destination contract.\\n    function migrateBucket(IMigratableFeesWallet destination, uint256 bucketStartTime) external /* onlyMigrationManager */;\\n\\n    /// @dev Called by the old FeesWallet contract.\\n    /// Part of the IMigratableFeesWallet interface.\\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\\n\\n    /// @dev an emergency withdrawal enables withdrawal of all funds to an escrow account. To be use in emergencies only.\\n    function emergencyWithdraw() external /* onlyMigrationManager */;\\n\\n}\\n\"},\"ILockable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface ILockable {\\n\\n    event Locked();\\n    event Unlocked();\\n\\n    function lock() external /* onlyLockOwner */;\\n    function unlock() external /* onlyLockOwner */;\\n    function isLocked() view external returns (bool);\\n\\n}\\n\"},\"IMigratableFeesWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\n/// @title An interface for Fee wallets that support bucket migration.\\ninterface IMigratableFeesWallet {\\n    /// @dev receives a bucket start time and an amount\\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\\n}\\n\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ncontract Initializable {\\n\\n    address private _initializationAdmin;\\n\\n    event InitializationComplete();\\n\\n    constructor() public{\\n        _initializationAdmin = msg.sender;\\n    }\\n\\n    modifier onlyInitializationAdmin() {\\n        require(msg.sender == initializationAdmin(), \\\"sender is not the initialization admin\\\");\\n\\n        _;\\n    }\\n\\n    /*\\n    * External functions\\n    */\\n\\n    function initializationAdmin() public view returns (address) {\\n        return _initializationAdmin;\\n    }\\n\\n    function initializationComplete() external onlyInitializationAdmin {\\n        _initializationAdmin = address(0);\\n        emit InitializationComplete();\\n    }\\n\\n    function isInitializationComplete() public view returns (bool) {\\n        return _initializationAdmin == address(0);\\n    }\\n\\n}\"},\"IProtocol.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IProtocol {\\n    event ProtocolVersionChanged(string deploymentSubset, uint256 currentVersion, uint256 nextVersion, uint256 fromTimestamp);\\n\\n    /*\\n     *   External functions\\n     */\\n\\n    /// @dev returns true if the given deployment subset exists (i.e - is registered with a protocol version)\\n    function deploymentSubsetExists(string calldata deploymentSubset) external view returns (bool);\\n\\n    /// @dev returns the current protocol version for the given deployment subset.\\n    function getProtocolVersion(string calldata deploymentSubset) external view returns (uint256);\\n\\n    /*\\n     *   Governance functions\\n     */\\n\\n    /// @dev create a new deployment subset.\\n    function createDeploymentSubset(string calldata deploymentSubset, uint256 initialProtocolVersion) external /* onlyFunctionalManager */;\\n\\n    /// @dev schedules a protocol version upgrade for the given deployment subset.\\n    function setProtocolVersion(string calldata deploymentSubset, uint256 nextVersion, uint256 fromTimestamp) external /* onlyFunctionalManager */;\\n}\\n\"},\"ISubscriptions.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\n/// @title Subscriptions contract interface\\ninterface ISubscriptions {\\n    event SubscriptionChanged(uint256 indexed vcId, address owner, string name, uint256 genRefTime, string tier, uint256 rate, uint256 expiresAt, bool isCertified, string deploymentSubset);\\n    event Payment(uint256 indexed vcId, address by, uint256 amount, string tier, uint256 rate);\\n    event VcConfigRecordChanged(uint256 indexed vcId, string key, string value);\\n    event VcCreated(uint256 indexed vcId);\\n    event VcOwnerChanged(uint256 indexed vcId, address previousOwner, address newOwner);\\n\\n    /*\\n     *   External functions\\n     */\\n\\n    /// @dev Called by: authorized subscriber (plan) contracts\\n    /// Creates a new VC\\n    function createVC(string calldata name, string calldata tier, uint256 rate, uint256 amount, address owner, bool isCertified, string calldata deploymentSubset) external returns (uint, uint);\\n\\n    /// @dev Called by: authorized subscriber (plan) contracts\\n    /// Extends the subscription of an existing VC.\\n    function extendSubscription(uint256 vcId, uint256 amount, string calldata tier, uint256 rate, address payer) external;\\n\\n    /// @dev called by VC owner to set a VC config record. Emits a VcConfigRecordChanged event.\\n    function setVcConfigRecord(uint256 vcId, string calldata key, string calldata value) external /* onlyVcOwner */;\\n\\n    /// @dev returns the value of a VC config record\\n    function getVcConfigRecord(uint256 vcId, string calldata key) external view returns (string memory);\\n\\n    /// @dev Transfers VC ownership to a new owner (can only be called by the current owner)\\n    function setVcOwner(uint256 vcId, address owner) external /* onlyVcOwner */;\\n\\n    /// @dev Returns the data of a VC (not including config records)\\n    function getVcData(uint256 vcId) external view returns (\\n        string memory name,\\n        string memory tier,\\n        uint256 rate,\\n        uint expiresAt,\\n        uint256 genRefTime,\\n        address owner,\\n        string memory deploymentSubset,\\n        bool isCertified\\n    );\\n\\n    /*\\n     *   Governance functions\\n     */\\n\\n    event SubscriberAdded(address subscriber);\\n    event SubscriberRemoved(address subscriber);\\n    event GenesisRefTimeDelayChanged(uint256 newGenesisRefTimeDelay);\\n    event MinimumInitialVcPaymentChanged(uint256 newMinimumInitialVcPayment);\\n\\n    /// @dev Called by the owner to authorize a subscriber (plan)\\n    function addSubscriber(address addr) external /* onlyFunctionalManager */;\\n\\n    /// @dev Called by the owner to unauthorize a subscriber (plan)\\n    function removeSubscriber(address addr) external /* onlyFunctionalManager */;\\n\\n    /// @dev Called by the owner to set the genesis ref time delay\\n    function setGenesisRefTimeDelay(uint256 newGenesisRefTimeDelay) external /* onlyFunctionalManager */;\\n\\n    /// @dev Returns the genesis ref time delay\\n    function getGenesisRefTimeDelay() external view returns (uint256);\\n\\n    /// @dev Called by the owner to set the minimum initial vc payment\\n    function setMinimumInitialVcPayment(uint256 minimumInitialVcPayment) external /* onlyFunctionalManager */;\\n\\n    /// @dev Returns the minimum initial vc payment\\n    function getMinimumInitialVcPayment() external view returns (uint256);\\n\\n    /// @dev Returns the settings of this contract\\n    function getSettings() external view returns(\\n        uint genesisRefTimeDelay,\\n        uint256 minimumInitialVcPayment\\n    );\\n\\n}\\n\"},\"Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./ContractRegistryAccessor.sol\\\";\\nimport \\\"./ILockable.sol\\\";\\n\\ncontract Lockable is ILockable, ContractRegistryAccessor {\\n\\n    bool public locked;\\n\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\\n\\n    modifier onlyLockOwner() {\\n        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), \\\"caller is not a lock owner\\\");\\n\\n        _;\\n    }\\n\\n    function lock() external override onlyLockOwner {\\n        locked = true;\\n        emit Locked();\\n    }\\n\\n    function unlock() external override onlyLockOwner {\\n        locked = false;\\n        emit Unlocked();\\n    }\\n\\n    function isLocked() external override view returns (bool) {\\n        return locked;\\n    }\\n\\n    modifier onlyWhenActive() {\\n        require(!locked, \\\"contract is locked for this operation\\\");\\n\\n        _;\\n    }\\n}\\n\"},\"ManagedContract.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Lockable.sol\\\";\\n\\ncontract ManagedContract is Lockable {\\n\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\\n\\n    modifier onlyMigrationManager {\\n        require(isManager(\\\"migrationManager\\\"), \\\"sender is not the migration manager\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyFunctionalManager {\\n        require(isManager(\\\"functionalManager\\\"), \\\"sender is not the functional manager\\\");\\n\\n        _;\\n    }\\n\\n    function refreshContracts() virtual external {}\\n\\n}\"},\"MonthlySubscriptionPlan.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./Subscriptions.sol\\\";\\nimport \\\"./ContractRegistry.sol\\\";\\n\\ncontract MonthlySubscriptionPlan is ContractRegistryAccessor {\\n\\n    string public tier;\\n    uint256 public monthlyRate;\\n\\n    IERC20 public erc20;\\n\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin, IERC20 _erc20, string memory _tier, uint256 _monthlyRate) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {\\n        require(bytes(_tier).length \\u003e 0, \\\"must specify a valid tier label\\\");\\n\\n        tier = _tier;\\n        erc20 = _erc20;\\n        monthlyRate = _monthlyRate;\\n    }\\n\\n    /*\\n     *   External functions\\n     */\\n\\n    /// @dev Creates a new VC (msg.sender is the VC owner)\\n    function createVC(string calldata name, uint256 amount, bool isCertified, string calldata deploymentSubset) external {\\n        require(amount \\u003e 0, \\\"must include funds\\\");\\n\\n        ISubscriptions subs = ISubscriptions(getSubscriptionsContract());\\n        require(erc20.transferFrom(msg.sender, address(this), amount), \\\"failed to transfer subscription fees\\\");\\n        require(erc20.approve(address(subs), amount), \\\"failed to transfer subscription fees\\\");\\n        subs.createVC(name, tier, monthlyRate, amount, msg.sender, isCertified, deploymentSubset);\\n    }\\n\\n    /// @dev Extends the subscription of an existing VC\\n    function extendSubscription(uint256 vcId, uint256 amount) external {\\n        require(amount \\u003e 0, \\\"must include funds\\\");\\n\\n        ISubscriptions subs = ISubscriptions(getSubscriptionsContract());\\n        require(erc20.transferFrom(msg.sender, address(this), amount), \\\"failed to transfer subscription fees from vc payer to subscriber\\\");\\n        require(erc20.approve(address(subs), amount), \\\"failed to approve subscription fees to subscriptions by subscriber\\\");\\n        subs.extendSubscription(vcId, amount, tier, monthlyRate, msg.sender);\\n    }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"Subscriptions.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISubscriptions.sol\\\";\\nimport \\\"./IProtocol.sol\\\";\\nimport \\\"./IFeesWallet.sol\\\";\\nimport \\\"./ManagedContract.sol\\\";\\n\\ncontract Subscriptions is ISubscriptions, ManagedContract {\\n    using SafeMath for uint256;\\n\\n    enum CommitteeType {\\n        General,\\n        Certification\\n    }\\n\\n    struct VirtualChain {\\n        string name;\\n        string tier;\\n        uint256 rate; // TODO get rate from subscriber when extending, don\\u0027t keep in state\\n        uint expiresAt;\\n        uint256 genRefTime;\\n        address owner;\\n        string deploymentSubset;\\n        bool isCertified;\\n    }\\n\\n    mapping(uint =\\u003e mapping(string =\\u003e string)) configRecords;\\n    mapping(address =\\u003e bool) public authorizedSubscribers;\\n    mapping(uint =\\u003e VirtualChain) virtualChains;\\n\\n    uint public nextVcId;\\n\\n    struct Settings {\\n        uint genesisRefTimeDelay;\\n        uint256 minimumInitialVcPayment;\\n    }\\n    Settings settings;\\n\\n    IERC20 public erc20;\\n\\n    constructor (IContractRegistry _contractRegistry, address _registryAdmin, IERC20 _erc20, uint256 _genesisRefTimeDelay, uint256 _minimumInitialVcPayment, uint[] memory vcIds, uint256 initialNextVcId, ISubscriptions previousSubscriptionsContract) ManagedContract(_contractRegistry, _registryAdmin) public {\\n        require(address(_erc20) != address(0), \\\"erc20 must not be 0\\\");\\n\\n        erc20 = _erc20;\\n        nextVcId = initialNextVcId;\\n\\n        setGenesisRefTimeDelay(_genesisRefTimeDelay);\\n        setMinimumInitialVcPayment(_minimumInitialVcPayment);\\n\\n        for (uint i = 0; i \\u003c vcIds.length; i++) {\\n            importSubscription(vcIds[i], previousSubscriptionsContract);\\n        }\\n    }\\n\\n    modifier onlySubscriber {\\n        require(authorizedSubscribers[msg.sender], \\\"sender must be an authorized subscriber\\\");\\n\\n        _;\\n    }\\n\\n    /*\\n     *   External functions\\n     */\\n\\n    function importSubscription(uint vcId, ISubscriptions previousSubscriptionsContract) public onlyInitializationAdmin {\\n        require(virtualChains[vcId].owner == address(0), \\\"the vcId already exists\\\");\\n\\n        (string memory name,\\n        string memory tier,\\n        uint256 rate,\\n        uint expiresAt,\\n        uint256 genRefTime,\\n        address owner,\\n        string memory deploymentSubset,\\n        bool isCertified) = previousSubscriptionsContract.getVcData(vcId);\\n\\n        virtualChains[vcId] = VirtualChain({\\n            name: name,\\n            tier: tier,\\n            rate: rate,\\n            expiresAt: expiresAt,\\n            genRefTime: genRefTime,\\n            owner: owner,\\n            deploymentSubset: deploymentSubset,\\n            isCertified: isCertified\\n        });\\n\\n        if (vcId \\u003e= nextVcId) {\\n            nextVcId = vcId + 1;\\n        }\\n\\n        emit SubscriptionChanged(vcId, owner, name, genRefTime, tier, rate, expiresAt, isCertified, deploymentSubset);\\n    }\\n\\n    function setVcConfigRecord(uint256 vcId, string calldata key, string calldata value) external override onlyWhenActive {\\n        require(msg.sender == virtualChains[vcId].owner, \\\"only vc owner can set a vc config record\\\");\\n        configRecords[vcId][key] = value;\\n        emit VcConfigRecordChanged(vcId, key, value);\\n    }\\n\\n    function getVcConfigRecord(uint256 vcId, string calldata key) external override view returns (string memory) {\\n        return configRecords[vcId][key];\\n    }\\n\\n    function addSubscriber(address addr) external override onlyFunctionalManager {\\n        authorizedSubscribers[addr] = true;\\n        emit SubscriberAdded(addr);\\n    }\\n\\n    function removeSubscriber(address addr) external override onlyFunctionalManager {\\n        require(authorizedSubscribers[addr], \\\"given add is not an authorized subscriber\\\");\\n\\n        authorizedSubscribers[addr] = false;\\n        emit SubscriberRemoved(addr);\\n    }\\n\\n    function createVC(string calldata name, string calldata tier, uint256 rate, uint256 amount, address owner, bool isCertified, string calldata deploymentSubset) external override onlySubscriber onlyWhenActive returns (uint, uint) {\\n        require(owner != address(0), \\\"vc owner cannot be the zero address\\\");\\n        require(protocolContract.deploymentSubsetExists(deploymentSubset) == true, \\\"No such deployment subset\\\");\\n        require(amount \\u003e= settings.minimumInitialVcPayment, \\\"initial VC payment must be at least minimumInitialVcPayment\\\");\\n\\n        uint vcId = nextVcId++;\\n        VirtualChain memory vc = VirtualChain({\\n            name: name,\\n            expiresAt: block.timestamp,\\n            genRefTime: now + settings.genesisRefTimeDelay,\\n            owner: owner,\\n            tier: tier,\\n            rate: rate,\\n            deploymentSubset: deploymentSubset,\\n            isCertified: isCertified\\n        });\\n        virtualChains[vcId] = vc;\\n\\n        emit VcCreated(vcId);\\n\\n        _extendSubscription(vcId, amount, tier, rate, owner);\\n        return (vcId, vc.genRefTime);\\n    }\\n\\n    function extendSubscription(uint256 vcId, uint256 amount, string calldata tier, uint256 rate, address payer) external override onlySubscriber onlyWhenActive {\\n        _extendSubscription(vcId, amount, tier, rate, payer);\\n    }\\n\\n    function getVcData(uint256 vcId) external override view returns (\\n        string memory name,\\n        string memory tier,\\n        uint256 rate,\\n        uint expiresAt,\\n        uint256 genRefTime,\\n        address owner,\\n        string memory deploymentSubset,\\n        bool isCertified\\n    ) {\\n        VirtualChain memory vc = virtualChains[vcId];\\n        name = vc.name;\\n        tier = vc.tier;\\n        rate = vc.rate;\\n        expiresAt = vc.expiresAt;\\n        genRefTime = vc.genRefTime;\\n        owner = vc.owner;\\n        deploymentSubset = vc.deploymentSubset;\\n        isCertified = vc.isCertified;\\n    }\\n\\n    function setVcOwner(uint256 vcId, address owner) external override onlyWhenActive {\\n        require(msg.sender == virtualChains[vcId].owner, \\\"only the vc owner can transfer ownership\\\");\\n        require(owner != address(0), \\\"cannot transfer ownership to the zero address\\\");\\n\\n        virtualChains[vcId].owner = owner;\\n        emit VcOwnerChanged(vcId, msg.sender, owner);\\n    }\\n\\n    /*\\n     *   Governance functions\\n     */\\n\\n    function setGenesisRefTimeDelay(uint256 newGenesisRefTimeDelay) public override onlyFunctionalManager {\\n        settings.genesisRefTimeDelay = newGenesisRefTimeDelay;\\n        emit GenesisRefTimeDelayChanged(newGenesisRefTimeDelay);\\n    }\\n\\n    function setMinimumInitialVcPayment(uint256 newMinimumInitialVcPayment) public override onlyFunctionalManager {\\n        settings.minimumInitialVcPayment = newMinimumInitialVcPayment;\\n        emit MinimumInitialVcPaymentChanged(newMinimumInitialVcPayment);\\n    }\\n\\n    function getGenesisRefTimeDelay() external override view returns (uint) {\\n        return settings.genesisRefTimeDelay;\\n    }\\n\\n    function getMinimumInitialVcPayment() external override view returns (uint) {\\n        return settings.minimumInitialVcPayment;\\n    }\\n\\n    function getSettings() external override view returns(\\n        uint genesisRefTimeDelay,\\n        uint256 minimumInitialVcPayment\\n    ) {\\n        Settings memory _settings = settings;\\n        genesisRefTimeDelay = _settings.genesisRefTimeDelay;\\n        minimumInitialVcPayment = _settings.minimumInitialVcPayment;\\n    }\\n\\n    /*\\n    * Private functions\\n    */\\n\\n    function _extendSubscription(uint256 vcId, uint256 amount, string memory tier, uint256 rate, address payer) private {\\n        VirtualChain memory vc = virtualChains[vcId];\\n        require(vc.genRefTime != 0, \\\"vc does not exist\\\");\\n        require(keccak256(bytes(tier)) == keccak256(bytes(virtualChains[vcId].tier)), \\\"given tier must match the VC tier\\\");\\n\\n        IFeesWallet feesWallet = vc.isCertified ? certifiedFeesWallet : generalFeesWallet;\\n        require(erc20.transferFrom(msg.sender, address(this), amount), \\\"failed to transfer subscription fees from subscriber to subscriptions\\\");\\n        require(erc20.approve(address(feesWallet), amount), \\\"failed to approve rewards to acquire subscription fees\\\");\\n\\n        uint fromTimestamp = vc.expiresAt \\u003e now ? vc.expiresAt : now;\\n        feesWallet.fillFeeBuckets(amount, rate, fromTimestamp);\\n\\n        vc.expiresAt = fromTimestamp.add(amount.mul(30 days).div(rate));\\n        vc.rate = rate;\\n\\n        // commit new expiration timestamp to storage\\n        virtualChains[vcId].expiresAt = vc.expiresAt;\\n        virtualChains[vcId].rate = vc.rate;\\n\\n        emit SubscriptionChanged(vcId, vc.owner, vc.name, vc.genRefTime, vc.tier, vc.rate, vc.expiresAt, vc.isCertified, vc.deploymentSubset);\\n        emit Payment(vcId, payer, amount, vc.tier, vc.rate);\\n    }\\n\\n    /*\\n     * Contracts topology / registry interface\\n     */\\n\\n    IFeesWallet generalFeesWallet;\\n    IFeesWallet certifiedFeesWallet;\\n    IProtocol protocolContract;\\n    function refreshContracts() external override {\\n        generalFeesWallet = IFeesWallet(getGeneralFeesWallet());\\n        certifiedFeesWallet = IFeesWallet(getCertifiedFeesWallet());\\n        protocolContract = IProtocol(getProtocolContract());\\n    }\\n}\\n\"},\"WithClaimableRegistryManagement.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @title Claimable\\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\\n * This allows the new owner to accept the transfer.\\n */\\ncontract WithClaimableRegistryManagement is Context {\\n    address private _registryAdmin;\\n    address private _pendingRegistryAdmin;\\n\\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _registryAdmin = msgSender;\\n        emit RegistryManagementTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current registryAdmin.\\n     */\\n    function registryAdmin() public view returns (address) {\\n        return _registryAdmin;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the registryAdmin.\\n     */\\n    modifier onlyRegistryAdmin() {\\n        require(isRegistryAdmin(), \\\"WithClaimableRegistryManagement: caller is not the registryAdmin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current registryAdmin.\\n     */\\n    function isRegistryAdmin() public view returns (bool) {\\n        return _msgSender() == _registryAdmin;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\\n     *\\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\\n     * thereby removing any functionality that is only available to the registryAdmin.\\n     */\\n    function renounceRegistryManagement() public onlyRegistryAdmin {\\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\\n        _registryAdmin = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\\n     */\\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\\n        require(newRegistryAdmin != address(0), \\\"RegistryAdmin: new registryAdmin is the zero address\\\");\\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\\n        _registryAdmin = newRegistryAdmin;\\n    }\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingManager.\\n     */\\n    modifier onlyPendingRegistryAdmin() {\\n        require(msg.sender == _pendingRegistryAdmin, \\\"Caller is not the pending registryAdmin\\\");\\n        _;\\n    }\\n    /**\\n     * @dev Allows the current registryAdmin to set the pendingManager address.\\n     * @param newRegistryAdmin The address to transfer registryManagement to.\\n     */\\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\\n        _pendingRegistryAdmin = newRegistryAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\\n     */\\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\\n        _transferRegistryManagement(_pendingRegistryAdmin);\\n        _pendingRegistryAdmin = address(0);\\n    }\\n\\n    /**\\n     * @dev Returns the current pendingRegistryAdmin\\n    */\\n    function pendingRegistryAdmin() public view returns (address) {\\n       return _pendingRegistryAdmin;  \\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_erc20\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tier\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_monthlyRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitializationComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRegistryAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"RegistryManagementTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCertified\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"deploymentSubset\",\"type\":\"string\"}],\"name\":\"createVC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vcId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"extendSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractRegistry\",\"outputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitializationComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRegistryAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthlyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRegistryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"newContractRegistry\",\"type\":\"address\"}],\"name\":\"setContractRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tier\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"transferRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MonthlySubscriptionPlan","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000005454223e3078db87e55a15be541cc925f3702eb0000000000000000000000000628e8c4d1611ed5b748f59f5ce694809af2f91d4000000000000000000000000ff56cc6b1e6ded347aa0b7676c85ab0b3d08b0fa00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000056bc75e2d6310000000000000000000000000000000000000000000000000000000000000000000056265746131000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6cb5eb69f14faef6d254eba3a0d8bff45b3ad9a4a9162eb53e7f00b91a19299b"}]}