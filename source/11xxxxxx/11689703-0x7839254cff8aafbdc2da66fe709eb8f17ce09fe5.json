{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AMMQuoter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interface/IUniswapExchange.sol\\\";\\nimport \\\"./interface/IUniswapFactory.sol\\\";\\nimport \\\"./interface/IUniswapRouterV2.sol\\\";\\nimport \\\"./interface/ICurveFi.sol\\\";\\nimport \\\"./interface/IWeth.sol\\\";\\nimport \\\"./interface/IPermanentStorage.sol\\\";\\n\\ncontract AMMQuoter {\\n    using SafeMath for uint256;\\n    /* Constants */\\n    string public constant version = \\\"5.1.0\\\";\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    address public constant UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public constant SUSHISWAP_ROUTER_ADDRESS = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\\n    address public immutable weth;\\n    IPermanentStorage public immutable permStorage;\\n\\n    event CurveTokenAdded(\\n        address indexed makerAddress,\\n        address indexed assetAddress,\\n        int128 index\\n    );\\n\\n    constructor (IPermanentStorage _permStorage, address _weth) public {\\n        permStorage = _permStorage;\\n        weth = _weth;\\n    }\\n\\n    function isETH(address assetAddress) public pure returns (bool) {\\n        return (assetAddress == ZERO_ADDRESS || assetAddress == ETH_ADDRESS);\\n    }\\n\\n    function getMakerOutAmount(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 makerAssetAmount;\\n        if (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(_makerAddr);\\n            address[] memory path = new address[](2);\\n            if (isETH(_takerAssetAddr)) {\\n                path[0] = weth;\\n                path[1] = _makerAssetAddr;\\n            } else if (isETH(_makerAssetAddr)) {\\n                path[0] = _takerAssetAddr;\\n                path[1] = weth;\\n            } else {\\n                path[0] = _takerAssetAddr;\\n                path[1] = _makerAssetAddr;\\n            }\\n            uint256[] memory amounts = router.getAmountsOut(_takerAssetAmount, path);\\n            makerAssetAmount = amounts[1];\\n        } else {\\n            address curveTakerIntenalAsset = isETH(_takerAssetAddr) ? ETH_ADDRESS : _takerAssetAddr;\\n            address curveMakerIntenalAsset = isETH(_makerAssetAddr) ? ETH_ADDRESS : _makerAssetAddr;\\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod,) = permStorage.getCurvePoolInfo(_makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\\n                require(swapMethod != 0, \\\"AMMQuoter: swap method not registered\\\");\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\\n                toTokenCurveIndex = toTokenCurveIndex - 1;\\n                ICurveFi curve = ICurveFi(_makerAddr);\\n                if (swapMethod == 1) {\\n                    makerAssetAmount = curve.get_dy(fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount).sub(1);\\n                } else if (swapMethod == 2) {\\n                    makerAssetAmount = curve.get_dy_underlying(fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount).sub(1);\\n                }\\n            } else {\\n                revert(\\\"AMMQuoter: Unsupported makerAddr\\\");\\n            }\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function getBestOutAmount(\\n        address[] calldata _makerAddresses,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount\\n    )\\n        external\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 0;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 makerAssetAmount = getMakerOutAmount(makerAddress, _takerAssetAddr, _makerAssetAddr, _takerAssetAmount);\\n            if (makerAssetAmount > bestAmount) {\\n                bestAmount = makerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function getTakerInAmount(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 takerAssetAmount;\\n        if (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(_makerAddr);\\n            address[] memory path = new address[](2);\\n            if (isETH(_takerAssetAddr)) {\\n                path[0] = weth;\\n                path[1] = _makerAssetAddr;\\n            } else if (isETH(_makerAssetAddr)) {\\n                path[0] = _takerAssetAddr;\\n                path[1] = weth;\\n            } else {\\n                path[0] = _takerAssetAddr;\\n                path[1] = _makerAssetAddr;\\n            }\\n            uint256[] memory amounts = router.getAmountsIn(_makerAssetAmount, path);\\n            takerAssetAmount = amounts[0];\\n        } else {\\n            address curveTakerIntenalAsset = isETH(_takerAssetAddr) ? ETH_ADDRESS : _takerAssetAddr;\\n            address curveMakerIntenalAsset = isETH(_makerAssetAddr) ? ETH_ADDRESS : _makerAssetAddr;\\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod, bool supportGetDx) = permStorage.getCurvePoolInfo(_makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\\n                require(swapMethod != 0, \\\"AMMQuoter: swap method not registered\\\");\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\\n                toTokenCurveIndex = toTokenCurveIndex - 1;\\n                ICurveFi curve = ICurveFi(_makerAddr);\\n                if (supportGetDx) {\\n                    if (swapMethod == 1) {\\n                        takerAssetAmount = curve.get_dx(fromTokenCurveIndex, toTokenCurveIndex, _makerAssetAmount);\\n                    } else if (swapMethod == 2) {\\n                        takerAssetAmount = curve.get_dx_underlying(fromTokenCurveIndex, toTokenCurveIndex, _makerAssetAmount);\\n                    }\\n                } else {\\n                    if (swapMethod == 1) {\\n                        // does not support get_dx_underlying, try to get an estimated rate here\\n                        takerAssetAmount = curve.get_dy(toTokenCurveIndex, fromTokenCurveIndex, _makerAssetAmount);\\n                    } else if (swapMethod == 2) {\\n                        takerAssetAmount = curve.get_dy_underlying(toTokenCurveIndex, fromTokenCurveIndex, _makerAssetAmount);\\n                    }\\n                }\\n            } else {\\n                revert(\\\"AMMQuoter: Unsupported makerAddr\\\");\\n            }\\n        }\\n        return takerAssetAmount;\\n    }\\n\\n    function getBestInAmount(\\n        address[] calldata _makerAddresses,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount\\n    )\\n        external\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 2**256 - 1;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 takerAssetAmount = getTakerInAmount(makerAddress, _takerAssetAddr, _makerAssetAddr, _makerAssetAmount);\\n            if (takerAssetAmount < bestAmount) {\\n                bestAmount = takerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUniswapExchange.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapExchange {\\n    // Address of ERC20 token sold on this exchange\\n    function tokenAddress() external view returns (address token);\\n    // Address of Uniswap Factory\\n    function factoryAddress() external view returns (address factory);\\n    // Provide Liquidity\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\\n    // Get Prices\\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\\n    // Trade ETH to ERC20\\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256 tokens_bought);\\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\\n    // Trade ERC20 to ETH\\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\\n    // Trade ERC20 to ERC20\\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\\n    // Trade ERC20 to Custom Pool\\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\\n    // ERC20 comaptibility for liquidity tokens\\n    function name() external view returns (bytes32);\\n    function symbol() external view returns (bytes32);\\n    function decimals() external view returns (uint256);\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    // Never use\\n    function setup(address token_addr) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUniswapFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapFactory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n\\n    // Create Exchange\\n    function createExchange(address token) external returns (address exchange);\\n    // Get Exchange and Token Info\\n    function getExchange(address token) external view returns (address exchange);\\n    function getToken(address exchange) external view returns (address token);\\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\\n    // Never use\\n    function initializeFactory(address template) external;\\n}\\n\\n    \\n\\n    \"\r\n    },\r\n    \"contracts/interface/IUniswapRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapRouterV2 {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/interface/ICurveFi.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface ICurveFi {\\n    function get_virtual_price() external returns (uint256 out);\\n    function add_liquidity(\\n        uint256[2] calldata amounts,\\n        uint256 deadline\\n    ) external;\\n\\n    function add_liquidity(\\n        // sBTC pool\\n        uint256[3] calldata amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function add_liquidity(\\n        // bUSD pool\\n        uint256[4] calldata amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function get_dx(\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external view returns (uint256 out);\\n\\n    function get_dx_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external view returns (uint256 out);\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256 out);\\n\\n    function get_dy_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256 out);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external payable;\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external payable;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function remove_liquidity(\\n        uint256 _amount,\\n        uint256 deadline,\\n        uint256[2] calldata min_amounts\\n    ) external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[2] calldata amounts,\\n        uint256 deadline\\n    ) external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[3] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[4] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\\n        external;\\n\\n    function commit_new_parameters(\\n        int128 amplification,\\n        int128 new_fee,\\n        int128 new_admin_fee\\n    ) external;\\n\\n    function apply_new_parameters() external;\\n\\n    function revert_new_parameters() external;\\n\\n    function commit_transfer_ownership(address _owner) external;\\n\\n    function apply_transfer_ownership() external;\\n\\n    function revert_transfer_ownership() external;\\n\\n    function withdraw_admin_fees() external;\\n\\n    function coins(int128 arg0) external returns (address out);\\n\\n    function underlying_coins(int128 arg0) external returns (address out);\\n\\n    function balances(int128 arg0) external returns (uint256 out);\\n\\n    function A() external returns (int128 out);\\n\\n    function fee() external returns (int128 out);\\n\\n    function admin_fee() external returns (int128 out);\\n\\n    function owner() external returns (address out);\\n\\n    function admin_actions_deadline() external returns (uint256 out);\\n\\n    function transfer_ownership_deadline() external returns (uint256 out);\\n\\n    function future_A() external returns (int128 out);\\n\\n    function future_fee() external returns (int128 out);\\n\\n    function future_admin_fee() external returns (int128 out);\\n\\n    function future_owner() external returns (address out);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IWeth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interface/IPermanentStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IPermanentStorage {\\n    function wethAddr() external view returns (address);\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx);\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) external;\\n    function isTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRelayerValid(address _relayer) external view returns (bool);\\n    function setTransactionSeen(bytes32 _transactionHash) external;\\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IPermanentStorage\",\"name\":\"_permStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"index\",\"type\":\"int128\"}],\"name\":\"CurveTokenAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SUSHISWAP_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V2_ROUTER_02_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_makerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_makerAssetAmount\",\"type\":\"uint256\"}],\"name\":\"getBestInAmount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bestMaker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_makerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_takerAssetAmount\",\"type\":\"uint256\"}],\"name\":\"getBestOutAmount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bestMaker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bestAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_takerAssetAmount\",\"type\":\"uint256\"}],\"name\":\"getMakerOutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_makerAssetAmount\",\"type\":\"uint256\"}],\"name\":\"getTakerInAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"isETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permStorage\",\"outputs\":[{\"internalType\":\"contract IPermanentStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AMMQuoter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000006d9cc14a1d36e6ff13fc6efa9e9326fcd12e7903000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}