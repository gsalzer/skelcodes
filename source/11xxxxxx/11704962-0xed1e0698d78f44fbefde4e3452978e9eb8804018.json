{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.0.7 https://hardhat.org\r\n\r\n// File contracts/Container.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\ncontract Container {\r\n\r\n    struct Item{\r\n        uint256 itemType;\r\n        uint256 status;\r\n        address[] addresses;\r\n    }\r\n\r\n    uint256 MaxItemAdressNum = 255;\r\n    mapping (bytes32 => Item) private container;\r\n    // bool private _nativePaused = false;\r\n\r\n\r\n    function itemAddressExists(bytes32 _id, address _oneAddress) internal view returns(bool){\r\n        for(uint256 i = 0; i < container[_id].addresses.length; i++){\r\n            if(container[_id].addresses[i] == _oneAddress)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getItemAddresses(bytes32 _id) internal view returns(address[] memory){\r\n        return container[_id].addresses;\r\n    }\r\n\r\n    function getItemInfo(bytes32 _id) internal view returns(uint256, uint256, uint256){\r\n        return (container[_id].itemType, container[_id].status, container[_id].addresses.length);\r\n    }\r\n\r\n    function getItemAddressCount(bytes32 _id) internal view returns(uint256){\r\n        return container[_id].addresses.length;\r\n    }\r\n\r\n    function setItemInfo(bytes32 _id, uint256 _itemType, uint256 _status) internal{\r\n        container[_id].itemType = _itemType;\r\n        container[_id].status = _status;\r\n    }\r\n\r\n    function addItemAddress(bytes32 _id, address _oneAddress) internal{\r\n        require(!itemAddressExists(_id, _oneAddress), \"dup address added\");\r\n        require(container[_id].addresses.length < MaxItemAdressNum, \"too many addresses\");\r\n        container[_id].addresses.push(_oneAddress);\r\n    }\r\n    function removeItemAddresses(bytes32 _id) internal {\r\n        delete container[_id].addresses;\r\n    }\r\n\r\n    function removeOneItemAddress(bytes32 _id, address _oneAddress) internal {\r\n        for(uint256 i = 0; i < container[_id].addresses.length; i++){\r\n            if(container[_id].addresses[i] == _oneAddress){\r\n                container[_id].addresses[i] = container[_id].addresses[container[_id].addresses.length - 1];\r\n                container[_id].addresses.pop();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeItem(bytes32 _id) internal{\r\n        delete container[_id];\r\n    }\r\n\r\n    function replaceItemAddress(bytes32 _id, address _oneAddress, address _anotherAddress) internal {\r\n        for(uint256 i = 0; i < container[_id].addresses.length; i++){\r\n            if(container[_id].addresses[i] == _oneAddress){\r\n                container[_id].addresses[i] = _anotherAddress;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/BridgeStorage.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ncontract BridgeStorage is Container {\r\n    string public constant name = \"BridgeStorage\";\r\n\r\n    address private caller;\r\n\r\n    constructor(address aCaller) {\r\n        caller = aCaller;\r\n    }\r\n\r\n    modifier onlyCaller() {\r\n        require(msg.sender == caller, \"only use main contract to call\");\r\n        _;\r\n    }\r\n\r\n    function supporterExists(bytes32 taskHash, address user) public view returns(bool) {\r\n        return itemAddressExists(taskHash, user);\r\n    }\r\n\r\n    function setTaskInfo(bytes32 taskHash, uint256 taskType, uint256 status) external onlyCaller {\r\n        setItemInfo(taskHash, taskType, status);\r\n    }\r\n\r\n    function getTaskInfo(bytes32 taskHash) public view returns(uint256, uint256, uint256){\r\n        return getItemInfo(taskHash);\r\n    }\r\n\r\n    function addSupporter(bytes32 taskHash, address oneAddress) external onlyCaller{\r\n        addItemAddress(taskHash, oneAddress);\r\n    }\r\n\r\n    function removeAllSupporter(bytes32 taskHash) external onlyCaller {\r\n        removeItemAddresses(taskHash);\r\n    }\r\n    function removeTask(bytes32 taskHash)external onlyCaller{\r\n        removeItem(taskHash);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aCaller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"oneAddress\",\"type\":\"address\"}],\"name\":\"addSupporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"getTaskInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"removeAllSupporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"}],\"name\":\"removeTask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"taskType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setTaskInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"taskHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"supporterExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BridgeStorage","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008546871840b95739426839086d0a3b7e17252405","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ed245152f9740c784e3947371cc0ae23036b5344a0359521a1de79c0e86c3a47"}]}