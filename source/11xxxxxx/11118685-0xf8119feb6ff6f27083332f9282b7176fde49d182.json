{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interactiveAdapters/curve/CurveAssetInteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport { ERC20 } from \\\"../../shared/ERC20.sol\\\";\\nimport { SafeERC20 } from \\\"../../shared/SafeERC20.sol\\\";\\nimport { TokenAmount } from \\\"../../shared/Structs.sol\\\";\\nimport { ERC20ProtocolAdapter } from \\\"../../adapters/ERC20ProtocolAdapter.sol\\\";\\nimport { CurveRegistry, PoolInfo } from \\\"../../adapters/curve/CurveRegistry.sol\\\";\\nimport { InteractiveAdapter } from \\\"../InteractiveAdapter.sol\\\";\\nimport { Stableswap } from \\\"../../interfaces/Stableswap.sol\\\";\\n\\n/**\\n * @dev Deposit contract interface.\\n * Only the functions required for CurveAssetInteractiveAdapter contract are added.\\n * The Deposit contract is available here\\n * github.com/curvefi/curve-contract/blob/compounded/vyper/deposit.vy.\\n */\\n/* solhint-disable func-name-mixedcase */\\ninterface Deposit {\\n    function add_liquidity(uint256[2] calldata, uint256) external;\\n\\n    function add_liquidity(uint256[3] calldata, uint256) external;\\n\\n    function add_liquidity(uint256[4] calldata, uint256) external;\\n\\n    function remove_liquidity_one_coin(\\n        uint256,\\n        int128,\\n        uint256\\n    ) external;\\n}\\n\\n/* solhint-enable func-name-mixedcase */\\n\\n/**\\n * @title Interactive adapter for Curve protocol (liquidity).\\n * @dev Implementation of CurveInteractiveAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract CurveAssetInteractiveAdapter is InteractiveAdapter, ERC20ProtocolAdapter {\\n    using SafeERC20 for ERC20;\\n\\n    address internal constant REGISTRY = 0x3fb5Cd4b0603C3D5828D3b5658B10C9CB81aa922;\\n\\n    /**\\n     * @notice Deposits tokens to the Curve pool (pair).\\n     * @param tokenAmounts Array with one element - TokenAmount struct with\\n     * underlying token address, underlying token amount to be deposited, and amount type.\\n     * @param data ABI-encoded additional parameters:\\n     *     - crvToken - curve token address.\\n     * @return tokensToBeWithdrawn Array with tokens sent back.\\n     * @dev Implementation of InteractiveAdapter function.\\n     */\\n    function deposit(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        override\\n        returns (address[] memory tokensToBeWithdrawn)\\n    {\\n        require(tokenAmounts.length == 1, \\\"CLIA: should be 1 tokenAmount[1]\\\");\\n\\n        address token = tokenAmounts[0].token;\\n        uint256 amount = getAbsoluteAmountDeposit(tokenAmounts[0]);\\n\\n        (address crvToken, uint256 tokenIndex) = abi.decode(data, (address, uint256));\\n        tokensToBeWithdrawn = new address[](1);\\n        tokensToBeWithdrawn[0] = crvToken;\\n\\n        PoolInfo memory poolInfo = CurveRegistry(REGISTRY).getPoolInfo(crvToken);\\n        uint256 totalCoins = poolInfo.totalCoins;\\n        address callee = poolInfo.deposit;\\n\\n        uint256[] memory inputAmounts = new uint256[](totalCoins);\\n        for (uint256 i = 0; i < totalCoins; i++) {\\n            inputAmounts[i] = i == uint256(tokenIndex) ? amount : 0;\\n        }\\n\\n        uint256 allowance = ERC20(token).allowance(address(this), callee);\\n\\n        if (allowance < amount) {\\n            if (allowance > 0) {\\n                ERC20(token).safeApprove(callee, 0, \\\"CLIA[1]\\\");\\n            }\\n            ERC20(token).safeApprove(callee, type(uint256).max, \\\"CLIA[2]\\\");\\n        }\\n\\n        if (totalCoins == 2) {\\n            // solhint-disable-next-line no-empty-blocks\\n            try Deposit(callee).add_liquidity([inputAmounts[0], inputAmounts[1]], 0)  {} catch {\\n                revert(\\\"CLIA: deposit fail[1]\\\");\\n            }\\n        } else if (totalCoins == 3) {\\n            try\\n                Deposit(callee).add_liquidity(\\n                    [inputAmounts[0], inputAmounts[1], inputAmounts[2]],\\n                    0\\n                )\\n             // solhint-disable-next-line no-empty-blocks\\n            {\\n\\n            } catch {\\n                revert(\\\"CLIA: deposit fail[2]\\\");\\n            }\\n        } else if (totalCoins == 4) {\\n            try\\n                Deposit(callee).add_liquidity(\\n                    [inputAmounts[0], inputAmounts[1], inputAmounts[2], inputAmounts[3]],\\n                    0\\n                )\\n             // solhint-disable-next-line no-empty-blocks\\n            {\\n\\n            } catch {\\n                revert(\\\"CLIA: deposit fail[3]\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdraws tokens from the Curve pool.\\n     * @param tokenAmounts Array with one element - TokenAmount struct with\\n     * Curve token address, Curve token amount to be redeemed, and amount type.\\n     * @param data ABI-encoded additional parameters:\\n     *     - toToken - destination token address (one of those used in pool).\\n     * @return tokensToBeWithdrawn Array with one element - destination token address.\\n     * @dev Implementation of InteractiveAdapter function.\\n     */\\n    function withdraw(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        override\\n        returns (address[] memory tokensToBeWithdrawn)\\n    {\\n        require(tokenAmounts.length == 1, \\\"CLIA: should be 1 tokenAmount[2]\\\");\\n\\n        address token = tokenAmounts[0].token;\\n        uint256 amount = getAbsoluteAmountWithdraw(tokenAmounts[0]);\\n        (address toToken, int128 tokenIndex) = abi.decode(data, (address, int128));\\n\\n        tokensToBeWithdrawn = new address[](1);\\n        tokensToBeWithdrawn[0] = toToken;\\n\\n        PoolInfo memory poolInfo = CurveRegistry(REGISTRY).getPoolInfo(token);\\n        address callee = poolInfo.deposit;\\n\\n        uint256 allowance = ERC20(token).allowance(address(this), callee);\\n\\n        if (allowance < amount) {\\n            if (allowance > 0) {\\n                ERC20(token).safeApprove(callee, 0, \\\"CLIA[3]\\\");\\n            }\\n            ERC20(token).safeApprove(callee, type(uint256).max, \\\"CLIA[4]\\\");\\n        }\\n\\n        // solhint-disable-next-line no-empty-blocks\\n        try Deposit(callee).remove_liquidity_one_coin(amount, tokenIndex, 0)  {} catch {\\n            revert(\\\"CLIA: withdraw fail\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Stableswap.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\n\\n/**\\n * @dev Stableswap contract interface.\\n * The Stableswap contract is available here\\n * github.com/curvefi/curve-contract/blob/compounded/vyper/stableswap.vy.\\n */\\ninterface Stableswap {\\n    /* solhint-disable-next-line func-name-mixedcase */\\n    function exchange_underlying(\\n        int128,\\n        int128,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function exchange(\\n        int128,\\n        int128,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function coins(int128) external view returns (address);\\n\\n    function coins(uint256) external view returns (address);\\n\\n    function balances(int128) external view returns (uint256);\\n\\n    function balances(uint256) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Deposit.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\n\\n/**\\n * @dev Deposit contract interface.\\n * Only the functions required for CurveAssetInteractiveAdapter contract are added.\\n * The Deposit contract is available here\\n * github.com/curvefi/curve-contract/blob/compounded/vyper/deposit.vy.\\n */\\ninterface Deposit {\\n    /* solhint-disable func-name-mixedcase */\\n    function add_liquidity(uint256[2] calldata, uint256) external;\\n\\n    function add_liquidity(uint256[3] calldata, uint256) external;\\n\\n    function add_liquidity(uint256[4] calldata, uint256) external;\\n\\n    function remove_liquidity_one_coin(\\n        uint256,\\n        int128,\\n        uint256\\n    ) external;\\n    /* solhint-enable func-name-mixedcase */\\n}\\n\"\r\n    },\r\n    \"contracts/interactiveAdapters/InteractiveAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport { ProtocolAdapter } from \\\"../adapters/ProtocolAdapter.sol\\\";\\nimport { TokenAmount, AmountType } from \\\"../shared/Structs.sol\\\";\\nimport { ERC20 } from \\\"../shared/ERC20.sol\\\";\\n\\n/**\\n * @title Base contract for interactive protocol adapters.\\n * @dev deposit() and withdraw() functions MUST be implemented\\n * as well as all the functions from ProtocolAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract InteractiveAdapter is ProtocolAdapter {\\n    uint256 internal constant DELIMITER = 1e18;\\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /**\\n     * @dev The function must deposit assets to the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function deposit(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    /**\\n     * @dev The function must withdraw assets from the protocol.\\n     * @return MUST return assets to be sent back to the `msg.sender`.\\n     */\\n    function withdraw(TokenAmount[] calldata tokenAmounts, bytes calldata data)\\n        external\\n        payable\\n        virtual\\n        returns (address[] memory);\\n\\n    function getAbsoluteAmountDeposit(TokenAmount calldata tokenAmount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            uint256 balance;\\n            if (token == ETH) {\\n                balance = address(this).balance;\\n            } else {\\n                balance = ERC20(token).balanceOf(address(this));\\n            }\\n\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function getAbsoluteAmountWithdraw(TokenAmount calldata tokenAmount)\\n        internal\\n        virtual\\n        returns (uint256)\\n    {\\n        address token = tokenAmount.token;\\n        uint256 amount = tokenAmount.amount;\\n        AmountType amountType = tokenAmount.amountType;\\n\\n        require(\\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\\n            \\\"IA: bad amount type\\\"\\n        );\\n        if (amountType == AmountType.Relative) {\\n            require(amount <= DELIMITER, \\\"IA: bad amount\\\");\\n\\n            int256 balanceSigned = getBalance(token, address(this));\\n            uint256 balance = balanceSigned > 0 ? uint256(balanceSigned) : uint256(-balanceSigned);\\n            if (amount == DELIMITER) {\\n                return balance;\\n            } else {\\n                return mul(balance, amount) / DELIMITER;\\n            }\\n        } else {\\n            return amount;\\n        }\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"IA: mul overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/curve/CurveRegistry.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport { Ownable } from \\\"../../core/Ownable.sol\\\";\\n\\nstruct PoolInfo {\\n    address swap; // stableswap contract address.\\n    address deposit; // deposit contract address.\\n    uint256 totalCoins; // Number of coins used in stableswap contract.\\n    string name; // Pool name (\\\"... Pool\\\").\\n}\\n\\n/**\\n * @title Registry for Curve contracts.\\n * @dev Implements two getters - getSwapAndTotalCoins(address) and getName(address).\\n * @notice Call getSwapAndTotalCoins(token) and getName(address) function and get address,\\n * coins number, and name of stableswap contract for the given token address.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract CurveRegistry is Ownable {\\n    mapping(address => PoolInfo) internal poolInfo_;\\n\\n    function setPoolsInfo(address[] memory tokens, PoolInfo[] memory poolsInfo)\\n        external\\n        onlyOwner\\n    {\\n        uint256 length = tokens.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            setPoolInfo(tokens[i], poolsInfo[i]);\\n        }\\n    }\\n\\n    function getPoolInfo(address token) external view returns (PoolInfo memory) {\\n        return poolInfo_[token];\\n    }\\n\\n    function setPoolInfo(address token, PoolInfo memory poolInfo) internal {\\n        poolInfo_[token] = poolInfo;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/ERC20ProtocolAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport { ERC20 } from \\\"../shared/ERC20.sol\\\";\\nimport { ProtocolAdapter } from \\\"./ProtocolAdapter.sol\\\";\\n\\n/**\\n * @title Adapter for any protocol with ERC20 interface.\\n * @dev Implementation of ProtocolAdapter abstract contract.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\ncontract ERC20ProtocolAdapter is ProtocolAdapter {\\n    /**\\n     * @return Amount of tokens held by the given account.\\n     * @dev Implementation of ProtocolAdapter abstract contract function.\\n     */\\n    function getBalance(address token, address account) public view override returns (int256) {\\n        return int256(ERC20(token).balanceOf(account));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/Structs.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\n// The struct consists of TokenBalanceMeta structs for\\n// (base) token and its underlying tokens (if any).\\nstruct FullTokenBalance {\\n    TokenBalanceMeta base;\\n    TokenBalanceMeta[] underlying;\\n}\\n\\n// The struct consists of TokenBalance struct\\n// with token address and absolute amount\\n// and ERC20Metadata struct with ERC20-style metadata.\\n// NOTE: 0xEeee...EEeE address is used for ETH.\\nstruct TokenBalanceMeta {\\n    TokenBalance tokenBalance;\\n    ERC20Metadata erc20metadata;\\n}\\n\\n// The struct consists of ERC20-style token metadata.\\nstruct ERC20Metadata {\\n    string name;\\n    string symbol;\\n    uint8 decimals;\\n}\\n\\n// The struct consists of protocol adapter's name\\n// and array of TokenBalance structs\\n// with token addresses and absolute amounts.\\nstruct AdapterBalance {\\n    bytes32 protocolAdapterName;\\n    TokenBalance[] tokenBalances;\\n}\\n\\n// The struct consists of token address\\n// and its absolute amount (may be negative).\\nstruct TokenBalance {\\n    address token;\\n    int256 amount;\\n}\\n\\n// The struct consists of token address,\\n// and price per full share (1e18).\\nstruct Component {\\n    address token;\\n    int256 rate;\\n}\\n\\n//=============================== Interactive Adapters Structs ====================================\\n\\n// The struct consists of array of actions,\\n// array of inputs, fee, required outputs,\\n// and salt parameter used to protect users from double spends.\\nstruct TransactionData {\\n    Action[] actions;\\n    TokenAmount[] inputs;\\n    Fee fee;\\n    AbsoluteTokenAmount[] requiredOutputs;\\n    uint256 salt;\\n}\\n\\n// The struct consists of name of the protocol adapter,\\n// action type, array of token amounts,\\n// and some additional data (depends on the protocol).\\nstruct Action {\\n    bytes32 protocolAdapterName;\\n    ActionType actionType;\\n    TokenAmount[] tokenAmounts;\\n    bytes data;\\n}\\n\\n// The struct consists of token address\\n// its amount and amount type.\\nstruct TokenAmount {\\n    address token;\\n    uint256 amount;\\n    AmountType amountType;\\n}\\n\\n// The struct consists of fee share\\n// and beneficiary address.\\nstruct Fee {\\n    uint256 share;\\n    address beneficiary;\\n}\\n\\n// The struct consists of token address\\n// and its absolute amount.\\nstruct AbsoluteTokenAmount {\\n    address token;\\n    uint256 amount;\\n}\\n\\nenum ActionType { None, Deposit, Withdraw }\\n\\nenum AmountType { None, Relative, Absolute }\\n\"\r\n    },\r\n    \"contracts/shared/ERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address, address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/shared/SafeERC20.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\\n * returns false). Tokens that return no value (and instead revert or throw on failure)\\n * are also supported, non-reverting calls are assumed to be successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value),\\n            \\\"transfer\\\",\\n            location\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value),\\n            \\\"transferFrom\\\",\\n            location\\n        );\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address spender,\\n        uint256 value,\\n        string memory location\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            string(abi.encodePacked(\\\"SafeERC20: bad approve call from \\\", location))\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value),\\n            \\\"approve\\\",\\n            location\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\\n     * relaxing the requirement on the return value: the return value is optional\\n     * (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     * @param location Location of the call (for debug).\\n     */\\n    function callOptionalReturn(\\n        ERC20 token,\\n        bytes memory data,\\n        string memory functionName,\\n        string memory location\\n    ) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\\n        // mechanism, since we're implementing it ourselves.\\n\\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\\n        //  1. The call itself is made, and success asserted\\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(\\n            success,\\n            string(abi.encodePacked(\\\"SafeERC20: \\\", functionName, \\\" failed in \\\", location))\\n        );\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(\\n                abi.decode(returndata, (bool)),\\n                string(\\n                    abi.encodePacked(\\\"SafeERC20: \\\", functionName, \\\" returned false in \\\", location)\\n                )\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/ProtocolAdapter.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Protocol adapter abstract contract.\\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\\n * @author Igor Sobolev <sobolev@zerion.io>\\n */\\nabstract contract ProtocolAdapter {\\n    /**\\n     * @dev MUST return amount and type of the given token\\n     * locked on the protocol by the given account.\\n     */\\n    function getBalance(address token, address account) public virtual returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/core/Ownable.sol\": {\r\n      \"content\": \"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License\\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\\n//\\n// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract Ownable {\\n    modifier onlyOwner {\\n        require(msg.sender == owner_, \\\"O: only owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyPendingOwner {\\n        require(msg.sender == pendingOwner_, \\\"O: only pending owner\\\");\\n        _;\\n    }\\n\\n    address private owner_;\\n    address private pendingOwner_;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @notice Initializes owner variable with msg.sender address.\\n     */\\n    constructor() {\\n        owner_ = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @notice Sets pending owner to the desired address.\\n     * The function is callable only by the owner.\\n     */\\n    function proposeOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"O: empty newOwner\\\");\\n        require(newOwner != owner_, \\\"O: equal to owner_\\\");\\n        require(newOwner != pendingOwner_, \\\"O: equal to pendingOwner_\\\");\\n        pendingOwner_ = newOwner;\\n    }\\n\\n    /**\\n     * @notice Transfers ownership to the pending owner.\\n     * The function is callable only by the pending owner.\\n     */\\n    function acceptOwnership() external onlyPendingOwner {\\n        emit OwnershipTransferred(owner_, msg.sender);\\n        owner_ = msg.sender;\\n        delete pendingOwner_;\\n    }\\n\\n    /**\\n     * @return Owner of the contract.\\n     */\\n    function owner() external view returns (address) {\\n        return owner_;\\n    }\\n\\n    /**\\n     * @return Pending owner of the contract.\\n     */\\n    function pendingOwner() external view returns (address) {\\n        return pendingOwner_;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToBeWithdrawn\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum AmountType\",\"name\":\"amountType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenAmount[]\",\"name\":\"tokenAmounts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensToBeWithdrawn\",\"type\":\"address[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"CurveAssetInteractiveAdapter","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://411c282979abc12e031c7f338f39b64c0b309f4a2c0b60c7be5f2d4bfa2fa499"}]}