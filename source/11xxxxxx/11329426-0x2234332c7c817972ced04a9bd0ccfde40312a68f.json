{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/keso/projects/crypto/uptown-panda-token/contracts/UptownPandaFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/IUptownPandaFarm.sol\\\";\\n\\ncontract UptownPandaFarm is IUptownPandaFarm {\\n    event SupplySnapshotAdded(uint256 idx, uint256 intervalIdx, uint256 timestamp, uint256 totalAmount);\\n    event SupplySnapshotUpdated(uint256 idx, uint256 intervalIdx, uint256 timestamp, uint256 totalAmount);\\n    event HarvestChunkAdded(address indexed staker, uint256 idx, uint256 timestamp, uint256 amount);\\n    event RewardClaimed(address indexed staker, uint256 indexed harvestChunkIdx, uint256 timestamp, uint256 amount);\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    uint256 public constant REWARD_HALVING_INTERVAL = 10 days; // interval for halving the rewards in seconds\\n    uint256 public constant HARVEST_INTERVAL = 1 days; // how long does it take to increase % of allowed reward withdraw\\n    uint256 public constant HARVEST_STEP = 10; // how much percent you're allowed to withdraw (after 1 day 10%, after 2 days 20%,...)\\n    uint256 public immutable HARVEST_CHUNKS_COUNT = uint256(100).div(HARVEST_STEP); // how many parts harvest is split into\\n\\n    bool public hasFarmingStarted = false; // indicates if farming has begun\\n    uint256 public initialFarmUpSupply; // inidicates how many $UP tokens were minted for the farm\\n    address public upTokenAddress; // $UP token address\\n    address public farmTokenAddress; // address of token to farm with\\n\\n    IERC20 private upToken; // $UP IERC20 token\\n    IERC20 private farmToken; // farm IERC20 token\\n\\n    address private owner;\\n\\n    struct SupplySnapshot {\\n        uint256 intervalIdx;\\n        uint256 timestamp;\\n        uint256 amount;\\n    }\\n\\n    struct HarvestChunk {\\n        uint256 timestamp;\\n        uint256 totalAmount;\\n        uint256 claimedAmount;\\n    }\\n\\n    SupplySnapshot[] public supplySnapshots;\\n    mapping(address => uint256) public balances;\\n    mapping(address => HarvestChunk[]) public harvestChunks;\\n    mapping(address => uint256) public harvestSnapshotIdxs;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier originIsOwner() {\\n        require(owner == tx.origin, \\\"Tx origin is not the owner of the contract.\\\");\\n        _;\\n    }\\n\\n    modifier farmNotStarted() {\\n        require(!hasFarmingStarted, \\\"Farm has already been started.\\\");\\n        _;\\n    }\\n\\n    modifier farmStarted() {\\n        require(hasFarmingStarted, \\\"Farm has not been started yet.\\\");\\n        _;\\n    }\\n\\n    modifier farmUpSupplySetCorrectly(address _upToken, uint256 supplyToCheck) {\\n        require(\\n            IERC20(_upToken).balanceOf(address(this)) == supplyToCheck,\\n            \\\"Token supply for this farm is not set correctly!\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier stakeAddressIsValid() {\\n        require(!address(msg.sender).isContract(), \\\"Staking from contracts is not allowed.\\\");\\n        _;\\n    }\\n\\n    modifier stakeAmountIsValid(uint256 _amount) {\\n        require(_amount > 0, \\\"Staking amount must be bigger than 0.\\\");\\n        _;\\n    }\\n\\n    modifier withdrawAmountIsValid(uint256 _amount) {\\n        require(_amount > 0, \\\"Withdraw amount must be bigger than 0.\\\");\\n        require(balances[msg.sender] >= _amount, \\\"Requested amount is bigger than your balance.\\\");\\n        _;\\n    }\\n\\n    function startFarming(\\n        address _upToken,\\n        address _farmToken,\\n        uint256 _initialFarmUpSupply\\n    ) external override originIsOwner farmNotStarted farmUpSupplySetCorrectly(_upToken, _initialFarmUpSupply) {\\n        addSupplySnapshot(0, block.timestamp, 0);\\n        upTokenAddress = _upToken;\\n        farmTokenAddress = _farmToken;\\n        upToken = IERC20(_upToken);\\n        farmToken = IERC20(_farmToken);\\n        initialFarmUpSupply = _initialFarmUpSupply;\\n        hasFarmingStarted = true;\\n    }\\n\\n    function stake(uint256 _amount) external override farmStarted stakeAddressIsValid stakeAmountIsValid(_amount) {\\n        harvestReward(totalStakedSupply().add(_amount));\\n        farmToken.transferFrom(msg.sender, address(this), _amount);\\n        balances[msg.sender] = balances[msg.sender].add(_amount);\\n    }\\n\\n    function withdraw(uint256 _amount) external override farmStarted withdrawAmountIsValid(_amount) {\\n        harvestReward(totalStakedSupply().sub(_amount));\\n        farmToken.transfer(msg.sender, _amount);\\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\\n    }\\n\\n    function harvest() external override farmStarted {\\n        harvestReward(totalStakedSupply()); // since no funds are added(staking)/subtracted(withdrawing) we just pass in the current supply\\n    }\\n\\n    function claim() external override farmStarted {\\n        claimHarvestedReward();\\n    }\\n\\n\\n    function harvestableReward() external view override returns (uint256) {\\n        if (supplySnapshots.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 latestSupplySnapshotIdx = supplySnapshots.length.sub(1);\\n        uint256 total = 0;\\n        for (uint256 i = harvestSnapshotIdxs[msg.sender]; i < latestSupplySnapshotIdx; i++) {\\n            total = total.add(calculateChunkRewardFromSupplySnapshot(i));\\n        }\\n\\n        SupplySnapshot storage latestSupplySnapshot = supplySnapshots[latestSupplySnapshotIdx];\\n        uint256 currentIntervalIdx = latestSupplySnapshot.intervalIdx;\\n        uint256 currentTimestamp = latestSupplySnapshot.timestamp;\\n        while (true) {\\n            uint256 nextIntervalIdx = currentIntervalIdx.add(1);\\n            uint256 nextTimestamp = Math.min(block.timestamp, getIntervalTimestamp(nextIntervalIdx));\\n            uint256 intervalChunkLength = nextTimestamp.sub(currentTimestamp);\\n            total = total.add(\\n                calculateChunkReward(intervalChunkLength, currentIntervalIdx, latestSupplySnapshot.amount)\\n            );\\n            if (nextTimestamp == block.timestamp) {\\n                break;\\n            }\\n            currentIntervalIdx = nextIntervalIdx;\\n            currentTimestamp = nextTimestamp;\\n        }\\n\\n        return total;\\n    }\\n\\n    function claimableHarvestedReward() external view override returns (uint256) {\\n        HarvestChunk[] storage stakerHarvestChunks = harvestChunks[msg.sender];\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < stakerHarvestChunks.length; i++) {\\n            total = total.add(getHarvestChunkClaimableAmount(stakerHarvestChunks[i]));\\n        }\\n        return total;\\n    }\\n\\n    function totalHarvestedReward() external view override returns (uint256) {\\n        HarvestChunk[] storage stakerHarvestChunks = harvestChunks[msg.sender];\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < stakerHarvestChunks.length; i++) {\\n            total = total.add(stakerHarvestChunks[i].totalAmount.sub(stakerHarvestChunks[i].claimedAmount));\\n        }\\n        return total;\\n    }\\n\\n    function getHarvestChunkClaimableAmount(HarvestChunk storage _stakerHarvestChunk) private view returns (uint256) {\\n        uint256 claimPercent = getHarvestChunkClaimPercent(_stakerHarvestChunk.timestamp);\\n        uint256 claimAmount = _stakerHarvestChunk.totalAmount.mul(claimPercent).div(100);\\n        return _stakerHarvestChunk.claimedAmount > claimAmount ? 0 : claimAmount.sub(_stakerHarvestChunk.claimedAmount);\\n    }\\n\\n    function getHarvestChunkClaimPercent(uint256 _harvestTimestamp) private view returns (uint256) {\\n        if (_harvestTimestamp >= block.timestamp) {\\n            return 0;\\n        }\\n        uint256 currentChunk = block.timestamp.sub(_harvestTimestamp).div(HARVEST_INTERVAL);\\n        return currentChunk >= HARVEST_CHUNKS_COUNT ? 100 : currentChunk.mul(HARVEST_STEP);\\n    }\\n\\n    function claimHarvestedReward() private {\\n        HarvestChunk[] storage stakerHarvestChunks = harvestChunks[msg.sender];\\n        for (uint256 i = 0; i < stakerHarvestChunks.length; i++) {\\n            uint256 claimableAmount = getHarvestChunkClaimableAmount(stakerHarvestChunks[i]);\\n            if (claimableAmount == 0) {\\n                continue;\\n            }\\n            upToken.transfer(msg.sender, claimableAmount);\\n            stakerHarvestChunks[i].claimedAmount = stakerHarvestChunks[i].claimedAmount.add(claimableAmount);\\n            emit RewardClaimed(msg.sender, i, block.timestamp, claimableAmount);\\n        }\\n    }\\n\\n    function harvestReward(uint256 _newTotalSupply) private {\\n        updateSupplySnapshots(_newTotalSupply);\\n\\n        uint256 latestSupplySnapshotIdx = supplySnapshots.length.sub(1);\\n\\n        if (balances[msg.sender] == 0) {\\n            harvestSnapshotIdxs[msg.sender] = latestSupplySnapshotIdx;\\n            return;\\n        }\\n\\n        claimHarvestedReward();\\n\\n        uint256 rewardToHarvest = 0;\\n        for (uint256 i = harvestSnapshotIdxs[msg.sender]; i < latestSupplySnapshotIdx; i++) {\\n            rewardToHarvest = rewardToHarvest.add(calculateChunkRewardFromSupplySnapshot(i));\\n        }\\n        harvestSnapshotIdxs[msg.sender] = latestSupplySnapshotIdx;\\n        addHarvestChunk(rewardToHarvest);\\n    }\\n\\n    function addHarvestChunk(uint256 _rewardToHarvest) private {\\n        uint256 idx = harvestChunks[msg.sender].length;\\n        harvestChunks[msg.sender].push(HarvestChunk(block.timestamp, _rewardToHarvest, 0));\\n        emit HarvestChunkAdded(msg.sender, idx, block.timestamp, _rewardToHarvest);\\n    }\\n\\n    function updateSupplySnapshots(uint256 _newTotalSupply) private {\\n        uint256 latestSnapshotIdx = supplySnapshots.length.sub(1);\\n        SupplySnapshot storage latestSnapshot = supplySnapshots[latestSnapshotIdx];\\n        if (latestSnapshot.timestamp >= block.timestamp) {\\n            updateSupplySnapshot(latestSnapshotIdx, latestSnapshot, _newTotalSupply);\\n            return;\\n        }\\n\\n        uint256 currentIntervalIdx = latestSnapshot.intervalIdx;\\n        while (true) {\\n            uint256 nextIntervalIdx = currentIntervalIdx.add(1);\\n            uint256 nextIntervalTimestamp = getIntervalTimestamp(nextIntervalIdx);\\n            uint256 snapshotIntervalIdx = block.timestamp < nextIntervalTimestamp\\n                ? currentIntervalIdx\\n                : nextIntervalIdx;\\n            uint256 snapshotTimestamp = Math.min(block.timestamp, nextIntervalTimestamp);\\n            uint256 snapshotAmount = snapshotTimestamp == block.timestamp ? _newTotalSupply : latestSnapshot.amount;\\n            addSupplySnapshot(snapshotIntervalIdx, snapshotTimestamp, snapshotAmount);\\n            if (snapshotTimestamp == block.timestamp) {\\n                break;\\n            }\\n            currentIntervalIdx = nextIntervalIdx;\\n        }\\n    }\\n\\n    function updateSupplySnapshot(\\n        uint256 _supplySnapshotIdx,\\n        SupplySnapshot storage _supplySnapshot,\\n        uint256 _newTotalSupply\\n    ) private {\\n        _supplySnapshot.amount = _newTotalSupply;\\n        emit SupplySnapshotUpdated(\\n            _supplySnapshotIdx,\\n            _supplySnapshot.intervalIdx,\\n            _supplySnapshot.timestamp,\\n            _supplySnapshot.amount\\n        );\\n    }\\n\\n    function addSupplySnapshot(\\n        uint256 _intervalIdx,\\n        uint256 _timestamp,\\n        uint256 _amount\\n    ) private {\\n        uint256 supplySnapshotIdx = supplySnapshots.length;\\n        supplySnapshots.push(SupplySnapshot(_intervalIdx, _timestamp, _amount));\\n        emit SupplySnapshotAdded(supplySnapshotIdx, _intervalIdx, _timestamp, _amount);\\n    }\\n\\n    function totalStakedSupply() public view returns (uint256) {\\n        return supplySnapshots.length > 0 ? supplySnapshots[supplySnapshots.length.sub(1)].amount : 0; // latest entry is current total supply\\n    }\\n\\n    function calculateChunkRewardFromSupplySnapshot(uint256 supplySnapshotIdx) private view returns (uint256) {\\n        uint256 intervalChunkLength = supplySnapshots[supplySnapshotIdx.add(1)].timestamp.sub(\\n            supplySnapshots[supplySnapshotIdx].timestamp\\n        );\\n        return\\n            calculateChunkReward(\\n                intervalChunkLength,\\n                supplySnapshots[supplySnapshotIdx].intervalIdx,\\n                supplySnapshots[supplySnapshotIdx].amount\\n            );\\n    }\\n\\n    function calculateChunkReward(\\n        uint256 _intervalChunkLength,\\n        uint256 _intervalIdx,\\n        uint256 _supplyAmount\\n    ) private view returns (uint256) {\\n        if (_supplyAmount == 0) {\\n            return 0;\\n        }\\n        return\\n            getIntervalTotalReward(_intervalIdx)\\n                .mul(_intervalChunkLength)\\n                .div(REWARD_HALVING_INTERVAL)\\n                .mul(balances[msg.sender])\\n                .div(_supplyAmount);\\n    }\\n\\n    function nextIntervalTimestamp() external view returns (uint256) {\\n        if (supplySnapshots.length == 0) {\\n            return 0;\\n        }\\n        uint256 currentIntervalIdx = block.timestamp.sub(supplySnapshots[0].timestamp).div(REWARD_HALVING_INTERVAL);\\n        return getIntervalTimestamp(currentIntervalIdx.add(1));\\n    }\\n\\n    function currentIntervalTotalReward() external view returns (uint256) {\\n        uint256 currentIntervalIdx = supplySnapshots.length == 0\\n            ? 0\\n            : block.timestamp.sub(supplySnapshots[0].timestamp).div(REWARD_HALVING_INTERVAL);\\n        return getIntervalTotalReward(currentIntervalIdx);\\n    }\\n\\n    function getIntervalTotalReward(uint256 _intervalIdx) private view returns (uint256) {\\n        return initialFarmUpSupply.div(2**_intervalIdx.add(1));\\n    }\\n\\n    function getIntervalTimestamp(uint256 _intervalIdx) private view returns (uint256) {\\n        return\\n            supplySnapshots.length > 0\\n                ? supplySnapshots[0].timestamp.add(REWARD_HALVING_INTERVAL.mul(_intervalIdx))\\n                : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/keso/projects/crypto/uptown-panda-token/contracts/interfaces/IUptownPandaFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IUptownPandaFarm {\\n    function startFarming(\\n        address _upToken,\\n        address _farmToken,\\n        uint256 _initialFarmUpSupply\\n    ) external;\\n\\n    function stake(uint256 _amount) external;\\n\\n    function withdraw(uint256 _amount) external;\\n\\n    function harvest() external;\\n\\n    function claim() external;\\n\\n    function harvestableReward() external view returns (uint256);\\n\\n    function claimableHarvestedReward() external view returns (uint256);\\n\\n    function totalHarvestedReward() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"HarvestChunkAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"harvestChunkIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"SupplySnapshotAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"intervalIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"SupplySnapshotUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HARVEST_CHUNKS_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARVEST_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARVEST_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_HALVING_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableHarvestedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIntervalTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"harvestChunks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"harvestSnapshotIdxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestableReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasFarmingStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialFarmUpSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextIntervalTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_farmToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialFarmUpSupply\",\"type\":\"uint256\"}],\"name\":\"startFarming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supplySnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"intervalIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHarvestedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UptownPandaFarm","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}