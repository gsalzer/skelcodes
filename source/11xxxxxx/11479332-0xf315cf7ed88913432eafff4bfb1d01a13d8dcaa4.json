{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.6.6;\n\ninterface INewSageRouter {\n    function detoMintAmounts(\n        address from,\n        address leader\n    ) external payable;\n}\n\ncontract SmartMatrixNewsage {\n    INewSageRouter public NewSageRouter;\n    struct User {\n        bool isTeam;\n        uint256 teamId;\n        uint256 id;\n        address referrer;\n        uint256 partnersCount;\n        mapping(uint8 => bool) activeX3Levels;\n        mapping(uint8 => bool) activeX6Levels;\n        mapping(uint8 => X3) x3Matrix;\n        mapping(uint8 => X6) x6Matrix;\n    }\n\n    struct X3 {\n        address currentReferrer;\n        address[] referrals;\n        bool blocked;\n        uint256 reinvestCount;\n    }\n\n    struct X6 {\n        address currentReferrer;\n        address[] firstLevelReferrals;\n        address[] secondLevelReferrals;\n        bool blocked;\n        uint256 reinvestCount;\n        address closedPart;\n    }\n\n    uint256 public lastteamId = 1;\n    struct Team {\n       address leader;\n       uint256 totalAmount;\n       uint256 member;\n    }\n    mapping(uint256 => Team) public idToTeam;\n\n    uint8 public constant LAST_LEVEL = 12;\n\n    mapping(address => User) public users;\n    mapping(uint256 => address) public idToAddress;\n\n    uint256 public lastUserId = 2;\n    address public owner;\n\n    mapping(uint8 => uint256) public levelPrice;\n\n    event Registration(\n        address indexed user,\n        address indexed referrer,\n        uint256 indexed userId,\n        uint256 referrerId\n    );\n    event Reinvest(\n        address indexed user,\n        address indexed currentReferrer,\n        address indexed caller,\n        uint8 matrix,\n        uint8 level\n    );\n    event Upgrade(\n        address indexed user,\n        address indexed referrer,\n        uint8 matrix,\n        uint8 level\n    );\n    event NewUserPlace(\n        address indexed user,\n        address indexed referrer,\n        uint8 matrix,\n        uint8 level,\n        uint8 place\n    );\n    event MissedEthReceive(\n        address indexed receiver,\n        address indexed from,\n        uint8 matrix,\n        uint8 level\n    );\n    event SentExtraEthDividends(\n        address indexed from,\n        address indexed receiver,\n        uint8 matrix,\n        uint8 level\n    );\n\n    constructor(address ownerAddress, address routerAddress) public {\n        NewSageRouter = INewSageRouter(routerAddress);\n        levelPrice[1] = 0.0025 ether;\n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\n            levelPrice[i] = levelPrice[i - 1] * 2;\n        }\n\n        owner = ownerAddress;\n\n        Team memory team = Team({\n            leader:ownerAddress,\n            totalAmount: uint256(0),\n            member:uint256(1)\n        });\n        idToTeam[0]=team;\n\n        User memory user = User({\n            isTeam:true,\n            teamId:0,\n            id: 1,\n            referrer: address(0),\n            partnersCount: uint256(0)\n        });\n        users[ownerAddress] = user;\n        idToAddress[1] = ownerAddress;\n\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\n            users[ownerAddress].activeX3Levels[i] = true;\n            users[ownerAddress].activeX6Levels[i] = true;\n        }\n\n    }\n    \n    function findMaxTeam()public view returns (address) {\n        uint256 temp_i=0;\n        for(uint256 i=0;i<lastteamId;i++){\n            if(idToTeam[temp_i].totalAmount<idToTeam[i].totalAmount){\n                temp_i=i;\n            }\n        }\n        return idToTeam[temp_i].leader;\n    }\n\n    receive() external payable {\n       \n    }\n\n    function registrationExt(\n        bool isTeam,\n        address referrerAddress,\n        uint8[] calldata x3Levels,\n        uint8[] calldata x6Levels\n    ) external payable {\n        registration(isTeam,msg.sender, referrerAddress, x3Levels, x6Levels);\n    }\n\n    function requirePrice(uint8[] memory x3Levels, uint8[] memory x6Levels) private  {\n        require(x3Levels.length <= LAST_LEVEL, \"x3Levels.length <= LAST_LEVEL\");\n        require(x6Levels.length <= LAST_LEVEL, \"x6Levels.length <= LAST_LEVEL\");\n        uint256 allprice = 0;\n        for (uint8 i = 0; i < x3Levels.length; i++) {\n            uint8 level = x3Levels[i];\n            require(level >= 1 && level <= LAST_LEVEL, \"level >= 1 && level <= LAST_LEVEL\");\n            require(!users[msg.sender].activeX3Levels[level], \"level already activated\");\n            allprice = allprice + levelPrice[level];\n        }\n        for (uint8 i = 0; i < x6Levels.length; i++) {\n            uint8 level = x6Levels[i];\n            \n            require(level >= 1 && level <= LAST_LEVEL, \"level >= 1 && level <= LAST_LEVEL\");\n            require(!users[msg.sender].activeX6Levels[level],\"level already activated\");\n            allprice = allprice + levelPrice[level];\n        }\n        require(msg.value == allprice, \"invalid price\");\n    }\n    function buyLevels(uint8[] memory x3Levels, uint8[] memory x6Levels) private  {\n\n      for (uint8 i = 0; i < x3Levels.length; i++) {\n            uint8 level = x3Levels[i];\n            if (level!=1&&users[msg.sender].x3Matrix[level - 1].blocked) {\n              users[msg.sender].x3Matrix[level - 1].blocked = false;\n            }\n            users[msg.sender].activeX3Levels[level] = true;\n            address freeX3Referrer = findFreeX3Referrer(msg.sender, level);\n            users[msg.sender].x3Matrix[level].currentReferrer = freeX3Referrer;\n            updateX3Referrer(msg.sender, freeX3Referrer, level);\n            emit Upgrade(msg.sender, freeX3Referrer, 1, level);\n        }\n\n        for (uint8 i = 0; i < x6Levels.length; i++) {\n            uint8 level = x6Levels[i];\n            if (level!=1&&users[msg.sender].x6Matrix[level - 1].blocked) {\n              users[msg.sender].x6Matrix[level - 1].blocked = false;\n            }\n            users[msg.sender].activeX6Levels[level] = true;\n            address freeX6Referrer = findFreeX6Referrer(msg.sender, level);\n            updateX6Referrer(msg.sender, freeX6Referrer, level);\n            emit Upgrade(msg.sender, freeX6Referrer, 2, level);\n        }\n       address templeader = findMaxTeam();\n        NewSageRouter.detoMintAmounts{value: address(this).balance}(msg.sender,templeader);\n        \n    }\n\n    function buyNewLevel(uint8[] calldata x3Levels, uint8[] calldata x6Levels)\n        external\n        payable\n    {\n        require(\n            isUserExists(msg.sender),\n            \"user is not exists. Register first.\"\n        );\n        requirePrice(x3Levels,x6Levels);\n        buyLevels(x3Levels,x6Levels);\n\n        idToTeam[users[msg.sender].teamId].totalAmount=idToTeam[users[msg.sender].teamId].totalAmount+msg.value;\n        \n\n    }\n\n    function registration(\n        bool isTeam,\n        address userAddress,\n        address referrerAddress,\n        uint8[] memory x3Levels,\n        uint8[] memory x6Levels\n        \n    ) private {\n        requirePrice(x3Levels,x6Levels);\n        require(!isUserExists(userAddress), \"user exists\");\n        require(isUserExists(referrerAddress), \"referrer not exists\");\n\n        uint32 size;\n        assembly {\n            size := extcodesize(userAddress)\n        }\n        require(size == 0, \"cannot be a contract\");\n        \n        uint256 tempTeamId;\n        if(isTeam){\n            tempTeamId=lastteamId;\n            lastteamId++;\n            Team memory team = Team({\n                leader:userAddress,\n                totalAmount: msg.value,\n                member:uint256(1)\n            });\n            idToTeam[tempTeamId]=team;\n        }else{\n            tempTeamId=users[referrerAddress].teamId;\n            idToTeam[tempTeamId].totalAmount=idToTeam[tempTeamId].totalAmount+msg.value;\n            idToTeam[tempTeamId].member++;\n        }\n        User memory user = User({\n            isTeam:isTeam,\n            teamId:tempTeamId,\n            id: lastUserId,\n            referrer: referrerAddress,\n            partnersCount: 0\n            \n        });\n\n        users[userAddress] = user;\n        idToAddress[lastUserId] = userAddress;\n        users[userAddress].referrer = referrerAddress;\n        lastUserId++;\n        users[referrerAddress].partnersCount++;\n\n        buyLevels(x3Levels,x6Levels);\n\n        emit Registration(\n            userAddress,\n            referrerAddress,\n            users[userAddress].id,\n            users[referrerAddress].id\n        );\n    }\n\n    function updateX3Referrer(\n        address userAddress,\n        address referrerAddress,\n        uint8 level\n    ) private {\n        X3 storage x3Level = users[referrerAddress].x3Matrix[level];\n        x3Level.referrals.push(userAddress);\n\n        if (x3Level.referrals.length < 3) {\n            emit NewUserPlace(\n                userAddress,\n                referrerAddress,\n                1,\n                level,\n                uint8(x3Level.referrals.length)\n            );\n            return sendETHDividends(referrerAddress, userAddress, 1, level);\n        }\n\n        emit NewUserPlace(userAddress, referrerAddress, 1, level, 3);\n        //close matrix\n        x3Level.referrals = new address[](0);\n        if (\n            !users[referrerAddress].activeX3Levels[level + 1] &&\n            level != LAST_LEVEL\n        ) {\n            x3Level.blocked = true;\n        }\n\n        //create new one by recursion\n        if (referrerAddress != owner) {\n            //check referrer active level\n            address freeReferrerAddress = findFreeX3Referrer(\n                referrerAddress,\n                level\n            );\n            if (x3Level.currentReferrer != freeReferrerAddress) {\n                x3Level.currentReferrer = freeReferrerAddress;\n            }\n\n            x3Level.reinvestCount++;\n            emit Reinvest(\n                referrerAddress,\n                freeReferrerAddress,\n                userAddress,\n                1,\n                level\n            );\n            updateX3Referrer(referrerAddress, freeReferrerAddress, level);\n        } else {\n            sendETHDividends(owner, userAddress, 1, level);\n            users[owner].x3Matrix[level].reinvestCount++;\n            emit Reinvest(owner, address(0), userAddress, 1, level);\n        }\n    }\n\n    function updateX6Referrer(\n        address userAddress,\n        address referrerAddress,\n        uint8 level\n    ) private {\n        require(\n            users[referrerAddress].activeX6Levels[level],\n            \"500. Referrer level is inactive\"\n        );\n        X6 storage x6Level = users[referrerAddress].x6Matrix[level];\n        if (x6Level.firstLevelReferrals.length < 2) {\n            x6Level.firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(\n                userAddress,\n                referrerAddress,\n                2,\n                level,\n                uint8(x6Level.firstLevelReferrals.length)\n            );\n\n            //set current level\n            users[userAddress].x6Matrix[level]\n                .currentReferrer = referrerAddress;\n\n            if (referrerAddress == owner) {\n                return sendETHDividends(referrerAddress, userAddress, 2, level);\n            }\n\n            address ref = x6Level.currentReferrer;\n            users[ref].x6Matrix[level].secondLevelReferrals.push(userAddress);\n\n            uint256 len = users[ref].x6Matrix[level].firstLevelReferrals.length;\n\n            if (\n                (len == 2) &&\n                (users[ref].x6Matrix[level].firstLevelReferrals[0] ==\n                    referrerAddress) &&\n                (users[ref].x6Matrix[level].firstLevelReferrals[1] ==\n                    referrerAddress)\n            ) {\n                if (x6Level.firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\n                }\n            } else if (\n                (len == 1 || len == 2) &&\n                users[ref].x6Matrix[level].firstLevelReferrals[0] ==\n                referrerAddress\n            ) {\n                if (x6Level.firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 3);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 4);\n                }\n            } else if (\n                len == 2 &&\n                users[ref].x6Matrix[level].firstLevelReferrals[1] ==\n                referrerAddress\n            ) {\n                if (x6Level.firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\n                }\n            }\n\n            return updateX6ReferrerSecondLevel(userAddress, ref, level);\n        }\n\n        x6Level.secondLevelReferrals.push(userAddress);\n\n        if (x6Level.closedPart != address(0)) {\n            if (\n                (x6Level.firstLevelReferrals[0] ==\n                    x6Level.firstLevelReferrals[1]) &&\n                (x6Level.firstLevelReferrals[0] == x6Level.closedPart)\n            ) {\n                updateX6(userAddress, referrerAddress, level, true);\n                return\n                    updateX6ReferrerSecondLevel(\n                        userAddress,\n                        referrerAddress,\n                        level\n                    );\n            } else if (x6Level.firstLevelReferrals[0] == x6Level.closedPart) {\n                updateX6(userAddress, referrerAddress, level, true);\n                return\n                    updateX6ReferrerSecondLevel(\n                        userAddress,\n                        referrerAddress,\n                        level\n                    );\n            } else {\n                updateX6(userAddress, referrerAddress, level, false);\n                return\n                    updateX6ReferrerSecondLevel(\n                        userAddress,\n                        referrerAddress,\n                        level\n                    );\n            }\n        }\n\n        if (x6Level.firstLevelReferrals[1] == userAddress) {\n            updateX6(userAddress, referrerAddress, level, false);\n            return\n                updateX6ReferrerSecondLevel(\n                    userAddress,\n                    referrerAddress,\n                    level\n                );\n        } else if (x6Level.firstLevelReferrals[0] == userAddress) {\n            updateX6(userAddress, referrerAddress, level, true);\n            return\n                updateX6ReferrerSecondLevel(\n                    userAddress,\n                    referrerAddress,\n                    level\n                );\n        }\n\n        if (\n            users[x6Level.firstLevelReferrals[0]].x6Matrix[level]\n                .firstLevelReferrals\n                .length <=\n            users[x6Level.firstLevelReferrals[1]].x6Matrix[level]\n                .firstLevelReferrals\n                .length\n        ) {\n            updateX6(userAddress, referrerAddress, level, false);\n        } else {\n            updateX6(userAddress, referrerAddress, level, true);\n        }\n\n        updateX6ReferrerSecondLevel(userAddress, referrerAddress, level);\n    }\n\n    function updateX6(\n        address userAddress,\n        address referrerAddress,\n        uint8 level,\n        bool x2\n    ) private {\n        X6 storage x6Level = users[referrerAddress].x6Matrix[level];\n        if (!x2) {\n            users[x6Level.firstLevelReferrals[0]].x6Matrix[level]\n                .firstLevelReferrals\n                .push(userAddress);\n            emit NewUserPlace(\n                userAddress,\n                x6Level.firstLevelReferrals[0],\n                2,\n                level,\n                uint8(\n                    users[x6Level.firstLevelReferrals[0]].x6Matrix[level]\n                        .firstLevelReferrals\n                        .length\n                )\n            );\n            emit NewUserPlace(\n                userAddress,\n                referrerAddress,\n                2,\n                level,\n                2 +\n                    uint8(\n                        users[x6Level.firstLevelReferrals[0]].x6Matrix[level]\n                            .firstLevelReferrals\n                            .length\n                    )\n            );\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = x6Level\n                .firstLevelReferrals[0];\n        } else {\n            users[x6Level.firstLevelReferrals[1]].x6Matrix[level]\n                .firstLevelReferrals\n                .push(userAddress);\n            emit NewUserPlace(\n                userAddress,\n                x6Level.firstLevelReferrals[1],\n                2,\n                level,\n                uint8(\n                    users[x6Level.firstLevelReferrals[1]].x6Matrix[level]\n                        .firstLevelReferrals\n                        .length\n                )\n            );\n            emit NewUserPlace(\n                userAddress,\n                referrerAddress,\n                2,\n                level,\n                4 +\n                    uint8(\n                        users[x6Level.firstLevelReferrals[1]].x6Matrix[level]\n                            .firstLevelReferrals\n                            .length\n                    )\n            );\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = x6Level\n                .firstLevelReferrals[1];\n        }\n    }\n\n    function updateX6ReferrerSecondLevel(\n        address userAddress,\n        address referrerAddress,\n        uint8 level\n    ) private {\n        X6 storage x6Level = users[referrerAddress].x6Matrix[level];\n        if (x6Level.secondLevelReferrals.length < 4) {\n            return sendETHDividends(referrerAddress, userAddress, 2, level);\n        }\n\n        address[] memory x6 = users[x6Level.currentReferrer].x6Matrix[level]\n            .firstLevelReferrals;\n\n        if (x6.length == 2) {\n            if (x6[0] == referrerAddress || x6[1] == referrerAddress) {\n                users[x6Level.currentReferrer].x6Matrix[level]\n                    .closedPart = referrerAddress;\n            } else if (x6.length == 1) {\n                if (x6[0] == referrerAddress) {\n                    users[x6Level.currentReferrer].x6Matrix[level]\n                        .closedPart = referrerAddress;\n                }\n            }\n        }\n\n        x6Level.firstLevelReferrals = new address[](0);\n        x6Level.secondLevelReferrals = new address[](0);\n        x6Level.closedPart = address(0);\n\n        if (\n            !users[referrerAddress].activeX6Levels[level + 1] &&\n            level != LAST_LEVEL\n        ) {\n            x6Level.blocked = true;\n        }\n\n        x6Level.reinvestCount++;\n\n        if (referrerAddress != owner) {\n            address freeReferrerAddress = findFreeX6Referrer(\n                referrerAddress,\n                level\n            );\n\n            emit Reinvest(\n                referrerAddress,\n                freeReferrerAddress,\n                userAddress,\n                2,\n                level\n            );\n            updateX6Referrer(referrerAddress, freeReferrerAddress, level);\n        } else {\n            emit Reinvest(owner, address(0), userAddress, 2, level);\n            sendETHDividends(owner, userAddress, 2, level);\n        }\n    }\n\n    function findFreeX3Referrer(address userAddress, uint8 level)\n        public\n        view\n        returns (address)\n    {\n        while (true) {\n            if (users[users[userAddress].referrer].activeX3Levels[level]) {\n                return users[userAddress].referrer;\n            }\n\n            userAddress = users[userAddress].referrer;\n        }\n    }\n\n    function findFreeX6Referrer(address userAddress, uint8 level)\n        public\n        view\n        returns (address)\n    {\n        while (true) {\n            if (users[users[userAddress].referrer].activeX6Levels[level]) {\n                return users[userAddress].referrer;\n            }\n\n            userAddress = users[userAddress].referrer;\n        }\n    }\n\n    function usersActiveX3Levels(address userAddress, uint8 level)\n        public\n        view\n        returns (bool)\n    {\n        return users[userAddress].activeX3Levels[level];\n    }\n\n    function usersActiveX6Levels(address userAddress, uint8 level)\n        public\n        view\n        returns (bool)\n    {\n        return users[userAddress].activeX6Levels[level];\n    }\n\n    function usersX3Matrix(address userAddress, uint8 level)\n        public\n        view\n        returns (\n            address,\n            address[] memory,\n            bool,\n            uint\n        )\n    {\n        return (\n            users[userAddress].x3Matrix[level].currentReferrer,\n            users[userAddress].x3Matrix[level].referrals,\n            users[userAddress].x3Matrix[level].blocked,\n            users[userAddress].x3Matrix[level].reinvestCount\n        );\n    }\n\n    function usersX6Matrix(address userAddress, uint8 level)\n        public\n        view\n        returns (\n            address,\n            address[] memory,\n            address[] memory,\n            bool,\n            address,\n            uint\n        )\n    {\n        return (\n            users[userAddress].x6Matrix[level].currentReferrer,\n            users[userAddress].x6Matrix[level].firstLevelReferrals,\n            users[userAddress].x6Matrix[level].secondLevelReferrals,\n            users[userAddress].x6Matrix[level].blocked,\n            users[userAddress].x6Matrix[level].closedPart,\n            users[userAddress].x6Matrix[level].reinvestCount\n        );\n    }\n\n    function isUserExists(address user) public view returns (bool) {\n        return (users[user].id != 0);\n    }\n\n    function findEthReceiver(\n        address userAddress,\n        address _from,\n        uint8 matrix,\n        uint8 level\n    ) private returns (address, bool) {\n        address receiver = userAddress;\n        bool isExtraDividends;\n        if (matrix == 1) {\n            while (true) {\n                if (users[receiver].x3Matrix[level].blocked) {\n                    emit MissedEthReceive(receiver, _from, 1, level);\n                    isExtraDividends = true;\n                    receiver = users[receiver].x3Matrix[level].currentReferrer;\n                } else {\n                    return (receiver, isExtraDividends);\n                }\n            }\n        } else {\n            while (true) {\n                if (users[receiver].x6Matrix[level].blocked) {\n                    emit MissedEthReceive(receiver, _from, 2, level);\n                    isExtraDividends = true;\n                    receiver = users[receiver].x6Matrix[level].currentReferrer;\n                } else {\n                    return (receiver, isExtraDividends);\n                }\n            }\n        }\n    }\n\n    function sendETHDividends(\n        address userAddress,\n        address _from,\n        uint8 matrix,\n        uint8 level\n    ) private {\n        (address receiver, bool isExtraDividends) = findEthReceiver(\n            userAddress,\n            _from,\n            matrix,\n            level\n        );\n\n       address(uint160(receiver)).transfer((levelPrice[level] * 67) / 100);\n        if (isExtraDividends) {\n            emit SentExtraEthDividends(_from, receiver, matrix, level);\n        }\n    }\n\n    function bytesToAddress(bytes memory bys)\n        private\n        pure\n        returns (address addr)\n    {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n     \n}\n\ncontract SmartMatrixNewsageFactory {\n    function creatSmartMatrixNewsage(\n        address ownerAddress,\n        address routerAddress\n    ) public returns (address) {\n        SmartMatrixNewsage smartMatrixNewsage = new SmartMatrixNewsage(\n            ownerAddress,\n            routerAddress\n        );\n        return address(smartMatrixNewsage);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"name\":\"creatSmartMatrixNewsage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SmartMatrixNewsageFactory","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}