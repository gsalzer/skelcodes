{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n// File: contracts/validator/DataValidator.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract DataValidator {\r\n    function validateSinglePixelData(\r\n        uint256[] calldata pixelData\r\n    ) external virtual pure returns (uint256 numberOfPixels);\r\n    \r\n    function validatePixelGroupData(\r\n        uint256[] calldata pixelGroups,\r\n        uint256[] calldata pixelGroupIndexes\r\n    ) external virtual pure returns (uint256 numberOfPixels);\r\n    \r\n    function validateTransparentPixelGroupData(\r\n        uint256[] calldata transparentPixelGroups,\r\n        uint256[] calldata transparentPixelGroupIndexes,\r\n        uint256[2] calldata metadata\r\n    ) external virtual pure returns (uint256 numberOfPixels);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/validator/MurAllDataValidator.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract MurAllDataValidator is DataValidator {\r\n    using SafeMath for uint256;\r\n    uint256 constant MAX_PIXEL_RES = 2097152; // 2048 x 1024 pixels\r\n    uint256 constant NUMBER_PER_GROUP = 32;\r\n    uint256 constant MAX_NUM_OF_GROUPS = 65536; // 2097152 pixels / 32 pixels per group (max number in 2 bytes 0 - 65535)\r\n    uint256 constant TRANSPARENT_PIXELS_THRESHOLD = 24; // 32 - 8; if 8 pixels or less then should be an individual group\r\n    uint256 constant MAX_INDIVIDUAL_PIXEL_ARRAY_LENGTH = 262144; //Each slot in the data fits 8 px and 8 indexes (2097152 / 8)\r\n    uint256 constant NUMBER_PER_INDIVIDUAL_PIXEL_GROUP = 8; // 8 individual pixels per uint256\r\n    // 0x000000000000000000000000000000000000000000000000000000000000000F\r\n    uint256 constant METADATA_HAS_ALPHA_CHANNEL_BYTES_MASK = 15;\r\n\r\n    /** @dev Checks if all pixel group data is valid\r\n     * @param pixelGroups The pixel group data\r\n     * @param pixelGroupIndexes The pixel group index data\r\n     */\r\n    modifier onlyValidGroupData(uint256[] memory pixelGroups, uint256[] memory pixelGroupIndexes) {\r\n        (uint256 quotient, uint256 remainder) = getDivided(pixelGroups.length, 16);\r\n\r\n        if (remainder != 0) {\r\n            quotient += 1; // e.g. when groupLen = 16, groupLen/16 = 1, we expect a group index length of 1 as 16 positions fit in 1 uint256\r\n        }\r\n\r\n        require(pixelGroupIndexes.length == quotient, \"unexpected group index array length\"); //Each group slot fits 16 coords of each 32 px group\r\n        require(pixelGroups.length <= MAX_NUM_OF_GROUPS, \"pixel groups too large\");\r\n        _;\r\n    }\r\n\r\n    /** @dev Checks if all pixel group data is valid\r\n     * @param pixelData The pixel group data\r\n     \r\n     */\r\n    modifier onlyValidSinglePixelData(uint256[] memory pixelData) {\r\n        require(pixelData.length <= MAX_INDIVIDUAL_PIXEL_ARRAY_LENGTH, \"pixelData too large\");\r\n        _;\r\n    }\r\n\r\n    function validateSinglePixelData(uint256[] memory pixelData)\r\n        public\r\n        override\r\n        pure\r\n        onlyValidSinglePixelData(pixelData)\r\n        returns (uint256 numberOfPixels)\r\n    {\r\n        uint256 len = pixelData.length;\r\n\r\n        if (len > 0) {\r\n            //assuming all individual pixel groups except the last have all 8 pixels filled except the last group\r\n            numberOfPixels = NUMBER_PER_INDIVIDUAL_PIXEL_GROUP.mul(len).sub(\r\n                checkIndividualPixelGroupForZeroes(pixelData[len - 1])\r\n            );\r\n        }\r\n    }\r\n\r\n    function validatePixelGroupData(uint256[] memory pixelGroups, uint256[] memory pixelGroupIndexes)\r\n        public\r\n        override\r\n        pure\r\n        onlyValidGroupData(pixelGroups, pixelGroupIndexes)\r\n        returns (uint256 numberOfPixels)\r\n    {\r\n        if (pixelGroups.length > 0) {\r\n            numberOfPixels = NUMBER_PER_GROUP.mul(pixelGroups.length); // 32 pixels per group\r\n        }\r\n    }\r\n\r\n    function validateTransparentPixelGroupData(\r\n        uint256[] memory transparentPixelGroups,\r\n        uint256[] memory transparentPixelGroupIndexes,\r\n        uint256[2] memory metadata\r\n    )\r\n        public\r\n        override\r\n        pure\r\n        onlyValidGroupData(transparentPixelGroups, transparentPixelGroupIndexes)\r\n        returns (uint256 numberOfPixels)\r\n    {\r\n        uint256 len = transparentPixelGroups.length;\r\n        if (len > 0) {\r\n            numberOfPixels = len.mul(NUMBER_PER_GROUP); // 32 pixels per group\r\n\r\n            if (hasAlphaChannel(metadata[1])) {\r\n                numberOfPixels = len.mul(NUMBER_PER_GROUP); // 32 pixels per group\r\n                uint256 currentGroup;\r\n                uint256 previousNumberOfPixels;\r\n\r\n                // don't count transparent pixels in pixel count:\r\n                // loop over the pixel groups checking for transparent pixels and deduct from total pixels\r\n                for (uint256 i = 0; i < len; i++) {\r\n                    previousNumberOfPixels = numberOfPixels;\r\n                    assembly {\r\n                        // We know that we only access the array in bounds, so we can avoid the check.\r\n                        // 0x20 needs to be added to an array because the first slot contains the\r\n                        // array length.\r\n                        currentGroup := mload(add(add(transparentPixelGroups, 0x20), mul(i, 0x20)))\r\n\r\n                        // first is actually last 2 bytes in the byte array (uint256 converted to uint16)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(\r\n                                and(currentGroup, 0x00000000000000000000000000000000000000000000000000000000000000FF)\r\n                            )\r\n                        )\r\n                        // iszero returns 1 if the value is equal to zero, or 0 if the value is any other number, so we use that to subtract from pixel count\r\n                        mstore(0x1F, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x1E, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x1D, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x1C, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x1B, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x1A, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x19, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x18, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x17, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x16, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x15, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x14, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x13, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x12, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x11, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x10, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x0F, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x0E, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x0D, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x0C, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x0B, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x0A, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x09, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x08, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x07, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x06, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x05, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x04, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x03, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x02, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n\r\n                        mstore(0x01, currentGroup)\r\n                        numberOfPixels := sub(\r\n                            numberOfPixels,\r\n                            iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000000000FF))\r\n                        )\r\n                    }\r\n                    /**\r\n                     * To prevent misuse we check to see that the number of transparent pixels is below the threshold\r\n                     * If its above the threshold it means theres only 8 or less pixels in the group thus the user should have used\r\n                     * individual pixels instead of a group.\r\n                     */\r\n                    require(\r\n                        previousNumberOfPixels.sub(numberOfPixels) < TRANSPARENT_PIXELS_THRESHOLD,\r\n                        \"Misuse of transparency detected\"\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDivided(uint256 numerator, uint256 denominator)\r\n        internal\r\n        pure\r\n        returns (uint256 quotient, uint256 remainder)\r\n    {\r\n        quotient = numerator / denominator;\r\n        remainder = numerator - denominator * quotient;\r\n    }\r\n\r\n    function hasAlphaChannel(uint256 metadata) internal pure returns (bool) {\r\n        return (METADATA_HAS_ALPHA_CHANNEL_BYTES_MASK & metadata) != 0;\r\n    }\r\n\r\n    function checkIndividualPixelGroupForZeroes(uint256 toCheck) public pure returns (uint256 amountOfZeroes) {\r\n        assembly {\r\n            // first is actually last 2 bytes in the byte array (uint256 converted to uint16)\r\n            // iszero returns 1 if the value is equal to zero, or 0 if the value is any other number, so we use that to add to the count\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(toCheck, 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x1C, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x18, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x14, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x10, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x0C, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x08, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n\r\n            mstore(0x04, toCheck)\r\n            amountOfZeroes := add(\r\n                amountOfZeroes,\r\n                iszero(and(mload(0), 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF))\r\n            )\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toCheck\",\"type\":\"uint256\"}],\"name\":\"checkIndividualPixelGroupForZeroes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfZeroes\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pixelGroups\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"pixelGroupIndexes\",\"type\":\"uint256[]\"}],\"name\":\"validatePixelGroupData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfPixels\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pixelData\",\"type\":\"uint256[]\"}],\"name\":\"validateSinglePixelData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfPixels\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"transparentPixelGroups\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"transparentPixelGroupIndexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[2]\",\"name\":\"metadata\",\"type\":\"uint256[2]\"}],\"name\":\"validateTransparentPixelGroupData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfPixels\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MurAllDataValidator","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"21000","ConstructorArguments":"","EVMVersion":"constantinople","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://af258d35e8c9f3cb89a78099ef2af6ab52d45f7b04df030add2f2abf335f4999"}]}