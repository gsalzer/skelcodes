{"status":"1","message":"OK","result":[{"SourceCode":"# Created by interfinex.io\r\n# - The Greeks\r\n\r\n@internal\r\ndef safeTransferFrom(_token: address, _from: address, _to: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(_from, bytes32),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token transferFrom failed!\"\r\n\r\n    return True\r\n\r\n@internal\r\ndef safeApprove(_token: address, _spender: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"approve(address,uint256)\"),\r\n            convert(_spender, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token approval failed!\"\r\n\r\n    return True\r\n\r\n@internal\r\ndef safeTransfer(_token: address, _to: address, _value: uint256) -> bool:\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Token approval failed!\"\r\n\r\n    return True\r\n\r\ninterface MarginFactory:\r\n    def pair_to_margin_market(assetTokenContract: address, collateralTokenContract: address) -> address: nonpayable\r\n\r\n\r\ninterface MarginMarket:\r\n    def deposit(_amount: uint256) -> uint256: nonpayable\r\n    def liquidityToken() -> address: view\r\n    def withdraw(_liquidityTokenAmount: uint256) -> uint256: nonpayable\r\n    def increasePosition(\r\n        _totalMarginAmount: uint256, \r\n        _borrowAmount: uint256, \r\n        minCollateralAmount: uint256, \r\n        maxCollateralAmount: uint256, \r\n        deadline: uint256, \r\n        useIfex: bool,\r\n        account: address\r\n    ) -> uint256: nonpayable\r\n    def closePosition(\r\n        minAssetAmount: uint256, \r\n        maxAssetAmount: uint256, \r\n        deadline: uint256, \r\n        useIfex: bool, \r\n        account: address\r\n    ): nonpayable\r\n\r\ninterface ERC20:\r\n    def approve(_spender : address, _value : uint256) -> bool: nonpayable\r\n    def transferFrom(_from : address, _to : address, _value : uint256) -> bool: nonpayable    \r\n    def allowance(_owner: address, _spender: address) -> uint256: view\r\n    def balanceOf(_account: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256): nonpayable\r\n\r\ninterface WrappedEther:\r\n    def deposit(): payable\r\n    def withdraw(wad: uint256): nonpayable\r\n\r\nwrappedEtherContract: public(address)\r\nmarginFactoryContract: public(address)\r\n\r\nisInitialised: public(bool)\r\n\r\n@internal\r\ndef approveContract(tokenContract: address, exchangeContract: address):\r\n    assetAllowance: uint256 = ERC20(tokenContract).allowance(self, exchangeContract)\r\n    if assetAllowance < MAX_UINT256 / 2:\r\n        ERC20(tokenContract).approve(exchangeContract, MAX_UINT256)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    return\r\n\r\n@external\r\ndef initialize(_wrappedEtherContract: address, _marginFactoryContract: address, ):\r\n    assert self.isInitialised == False, \"Already initialised\"\r\n    self.isInitialised = True\r\n    self.wrappedEtherContract = _wrappedEtherContract\r\n    self.marginFactoryContract = _marginFactoryContract\r\n\r\n@external\r\n@payable\r\ndef deposit(assetTokenContract: address):\r\n    marginMarketContract: address = MarginFactory(self.marginFactoryContract).pair_to_margin_market(\r\n        self.wrappedEtherContract,\r\n        assetTokenContract\r\n    )\r\n    liquidityTokenContract: address = MarginMarket(marginMarketContract).liquidityToken()\r\n\r\n    self.approveContract(self.wrappedEtherContract, marginMarketContract)\r\n    WrappedEther(self.wrappedEtherContract).deposit(value=msg.value)\r\n    MarginMarket(marginMarketContract).deposit(msg.value)\r\n    ERC20(liquidityTokenContract).transfer(msg.sender, ERC20(liquidityTokenContract).balanceOf(self))\r\n\r\n@external\r\ndef withdraw(assetTokenContract: address, liquidityTokenAmount: uint256):\r\n    marginMarketContract: address = MarginFactory(self.marginFactoryContract).pair_to_margin_market(\r\n        self.wrappedEtherContract,\r\n        assetTokenContract\r\n    )\r\n    liquidityTokenContract: address = MarginMarket(marginMarketContract).liquidityToken()\r\n    ERC20(liquidityTokenContract).transferFrom(msg.sender, self, liquidityTokenAmount)\r\n\r\n    self.approveContract(liquidityTokenContract, marginMarketContract)\r\n    MarginMarket(marginMarketContract).withdraw(liquidityTokenAmount)\r\n\r\n    WrappedEther(self.wrappedEtherContract).withdraw(ERC20(self.wrappedEtherContract).balanceOf(self))\r\n    send(msg.sender, self.balance)\r\n\r\n@external\r\n@payable\r\ndef increasePosition(\r\n    assetTokenContract: address,\r\n    _borrowAmount: uint256, \r\n    minCollateralAmount: uint256, \r\n    maxCollateralAmount: uint256, \r\n    deadline: uint256, \r\n    useIfex: bool\r\n) -> uint256:\r\n    marginMarketContract: address = MarginFactory(self.marginFactoryContract).pair_to_margin_market(\r\n        self.wrappedEtherContract,\r\n        assetTokenContract\r\n    )\r\n\r\n    _totalMarginAmount: uint256 = msg.value\r\n    self.approveContract(self.wrappedEtherContract, marginMarketContract)\r\n    WrappedEther(self.wrappedEtherContract).deposit(value=msg.value)\r\n    \r\n    collateralAmount: uint256 = MarginMarket(marginMarketContract).increasePosition(\r\n        _totalMarginAmount, \r\n        _borrowAmount, \r\n        minCollateralAmount, \r\n        maxCollateralAmount, \r\n        deadline, \r\n        useIfex,\r\n        msg.sender\r\n    )\r\n\r\n    return collateralAmount\r\n\r\n@external\r\ndef closePosition(\r\n    assetTokenContract: address,\r\n    minAssetAmount: uint256, \r\n    maxAssetAmount: uint256, \r\n    deadline: uint256, \r\n    useIfex: bool\r\n): \r\n    marginMarketContract: address = MarginFactory(self.marginFactoryContract).pair_to_margin_market(\r\n        self.wrappedEtherContract,\r\n        assetTokenContract\r\n    )\r\n\r\n    MarginMarket(marginMarketContract).closePosition(\r\n        minAssetAmount,\r\n        maxAssetAmount,\r\n        deadline,\r\n        useIfex,\r\n        msg.sender\r\n    )\r\n\r\n    wethBalance: uint256 = ERC20(self.wrappedEtherContract).balanceOf(self)\r\n    if wethBalance > 0:\r\n        WrappedEther(self.wrappedEtherContract).withdraw(wethBalance)\r\n        send(msg.sender, self.balance)","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"initialize\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_wrappedEtherContract\"},{\"type\":\"address\",\"name\":\"_marginFactoryContract\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":106570},{\"name\":\"deposit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":46339},{\"name\":\"withdraw\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"uint256\",\"name\":\"liquidityTokenAmount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":46600},{\"name\":\"increasePosition\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"uint256\",\"name\":\"_borrowAmount\"},{\"type\":\"uint256\",\"name\":\"minCollateralAmount\"},{\"type\":\"uint256\",\"name\":\"maxCollateralAmount\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"bool\",\"name\":\"useIfex\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":44369},{\"name\":\"closePosition\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"assetTokenContract\"},{\"type\":\"uint256\",\"name\":\"minAssetAmount\"},{\"type\":\"uint256\",\"name\":\"maxAssetAmount\"},{\"type\":\"uint256\",\"name\":\"deadline\"},{\"type\":\"bool\",\"name\":\"useIfex\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":44313},{\"name\":\"wrappedEtherContract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421},{\"name\":\"marginFactoryContract\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451},{\"name\":\"isInitialised\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1481}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}