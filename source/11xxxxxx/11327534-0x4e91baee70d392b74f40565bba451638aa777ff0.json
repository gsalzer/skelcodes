{"status":"1","message":"OK","result":[{"SourceCode":"{\"ACOAssetHelper.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nlibrary ACOAssetHelper {\\r\\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to approve ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param spender Authorized address.\\r\\n     * @param amount Amount to authorize.\\r\\n     */\\r\\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callApproveERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOAssetHelper::_callTransferFromERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetSymbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetDecimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to the asset name.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset name.\\r\\n     */\\r\\n    function _getAssetName(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"Ethereum\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetName\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset balance of an account.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param account Address of the account.\\r\\n     * @return The account balance.\\r\\n     */\\r\\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return account.balance;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetBalanceOf\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset allowance between two addresses.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @return The owner allowance for the spender.\\r\\n     */\\r\\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\\r\\n        if (_isEther(asset)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\\r\\n            require(success, \\\"ACOAssetHelper::_getAssetAllowance\\\");\\r\\n            return abi.decode(returndata, (uint256));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer an asset. \\r\\n     * @param asset Address of the asset to be transferred.\\r\\n     * @param to Address of the destination.\\r\\n     * @param amount The amount to be transferred.\\r\\n     */\\r\\n    function _transferAsset(address asset, address to, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            (bool success,) = to.call{value:amount}(new bytes(0));\\r\\n            require(success, \\u0027ACOAssetHelper::_transferAsset\\u0027);\\r\\n        } else {\\r\\n            _callTransferERC20(asset, to, amount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\t/**\\r\\n     * @dev Internal function to receive an asset. \\r\\n     * @param asset Address of the asset to be received.\\r\\n     * @param amount The amount to be received.\\r\\n     */\\r\\n    function _receiveAsset(address asset, uint256 amount) internal {\\r\\n        if (_isEther(asset)) {\\r\\n            require(msg.value == amount, \\\"ACOAssetHelper:: Invalid ETH amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOAssetHelper:: Ether is not expected\\\");\\r\\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\\r\\n     * @param asset Address of the asset.\\r\\n     * @param owner Address of the owner of the tokens.\\r\\n     * @param spender Address of the spender authorized.\\r\\n     * @param amount Amount to check allowance.\\r\\n     */\\r\\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\\r\\n        if (_getAssetAllowance(asset, owner, spender) \\u003c amount) {\\r\\n            _callApproveERC20(asset, spender, MAX_UINT);\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOOTC.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./OTCTypes.sol\\\";\\r\\nimport \\\"./ACOAssetHelper.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IACOFactory.sol\\\";\\r\\nimport \\\"./IWETH.sol\\\";\\r\\nimport \\\"./IACOToken.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ACOOTC\\r\\n * @dev Contract to trade OTC on ACO tokens. \\r\\n * Inspired on Swap SC by AirSwap, under Apache License, Version 2.0\\r\\n * https://github.com/airswap/airswap-protocols/blob/master/source/swap/contracts/Swap.sol\\r\\n */\\r\\ncontract ACOOTC {\\r\\n\\tusing SafeMath for uint256;\\r\\n\\t\\r\\n\\tevent Swap(\\r\\n\\t\\tuint256 indexed nonce,\\r\\n\\t\\taddress indexed signer,\\r\\n\\t\\taddress indexed sender,\\r\\n\\t\\tbool isAskOrder,\\r\\n\\t\\tuint256 signerAmount,\\r\\n\\t\\taddress signerToken,\\r\\n\\t\\tuint256 senderAmount,\\r\\n\\t\\taddress senderToken,\\r\\n\\t\\taddress affiliate,\\r\\n\\t\\tuint256 affiliateAmount,\\r\\n\\t\\taddress affiliateToken\\r\\n\\t);\\r\\n\\tevent Cancel(uint256 indexed nonce, address indexed signer);\\r\\n\\tevent CancelUpTo(uint256 indexed nonce, address indexed signer);\\r\\n\\tevent AuthorizeSender(address indexed authorizerAddress, address indexed authorizedSender);\\r\\n\\tevent AuthorizeSigner(address indexed authorizerAddress, address indexed authorizedSigner);\\r\\n\\tevent RevokeSender(address indexed authorizerAddress, address indexed revokedSender);\\r\\n\\tevent RevokeSigner(address indexed authorizerAddress, address indexed revokedSigner);\\r\\n\\t\\r\\n\\t//Domain and version for use in signatures (EIP-712)\\r\\n\\tbytes internal constant DOMAIN_NAME = \\\"ACOOTC\\\";\\r\\n\\tbytes internal constant DOMAIN_VERSION = \\\"1\\\";\\r\\n\\r\\n\\t// Unique domain identifier for use in signatures (EIP-712)\\r\\n\\tbytes32 private immutable _domainSeparator;\\r\\n\\r\\n\\t// Possible nonce statuses\\r\\n\\tbytes1 internal constant AVAILABLE = 0x00;\\r\\n\\tbytes1 internal constant UNAVAILABLE = 0x01;\\r\\n\\r\\n\\t// Address of the ACO Factory contract\\r\\n\\tIACOFactory public immutable acoFactory;\\r\\n\\t// Address of the WETH contract\\r\\n\\tIWETH public immutable weth;\\r\\n\\r\\n\\t// Mapping of sender address to a delegated sender address and bool\\r\\n\\tmapping(address =\\u003e mapping(address =\\u003e bool)) public senderAuthorizations;\\r\\n\\r\\n\\t// Mapping of signer address to a delegated signer and bool\\r\\n\\tmapping(address =\\u003e mapping(address =\\u003e bool)) public signerAuthorizations;\\r\\n\\r\\n\\t// Mapping of signers to nonces with value AVAILABLE (0x00) or UNAVAILABLE (0x01)\\r\\n\\tmapping(address =\\u003e mapping(uint256 =\\u003e bytes1)) public signerNonceStatus;\\r\\n\\r\\n\\t// Mapping of signer addresses to an optionally set minimum valid nonce\\r\\n\\tmapping(address =\\u003e uint256) public signerMinimumNonce;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Contract Constructor\\r\\n\\t * @dev Sets domain for signature validation (EIP-712) and the ACO Factory and WETH\\r\\n\\t * @param _acoFactory ACO Factory address\\r\\n\\t * @param _weth WETH address\\r\\n\\t */\\r\\n\\tconstructor(address _acoFactory, address _weth) public {\\r\\n\\t\\t_domainSeparator = OTCTypes.hashDomain(\\r\\n\\t\\t\\tDOMAIN_NAME,\\r\\n\\t\\t\\tDOMAIN_VERSION,\\r\\n\\t\\t\\taddress(this)\\r\\n\\t\\t);\\r\\n\\t\\tacoFactory = IACOFactory(_acoFactory);\\r\\n\\t\\tweth = IWETH(_weth);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Receive ETH from WETH contract\\r\\n\\t */\\r\\n\\treceive() external payable {\\r\\n        require(msg.sender == address(weth), \\\"ACOOTC:: Only WETH\\\");\\r\\n    }\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Atomic Token Swap for an Ask Order\\r\\n\\t * @param order OTCTypes.AskOrder Order to settle\\r\\n\\t */\\r\\n\\tfunction swapAskOrder(OTCTypes.AskOrder calldata order) external {\\r\\n\\t\\t// Ensure the order is valid.\\r\\n\\t\\taddress finalSender = _baseSwapValidation(\\r\\n\\t\\t\\torder.expiry,\\r\\n\\t\\t\\torder.nonce,\\r\\n\\t\\t\\torder.signer.responsible,\\r\\n\\t\\t\\torder.sender.responsible,\\r\\n\\t\\t\\torder.affiliate.responsible,\\r\\n\\t\\t\\torder.signature.signatory,\\r\\n\\t\\t\\torder.signature.v\\r\\n\\t\\t);\\r\\n\\t\\t// Ensure the signature is valid whether it is provided.\\r\\n\\t\\trequire(order.signature.v == uint8(0) || isValidAskOrder(order), \\\"ACOOTC:: Signature invalid\\\");\\r\\n\\r\\n\\t\\tACOAssetHelper._callTransferFromERC20(order.sender.token, finalSender, order.signer.responsible, order.sender.amount);\\r\\n\\r\\n\\t\\taddress _aco = _transferAco(order.signer.responsible, finalSender, order.signer);\\r\\n\\r\\n\\t\\t// Transfer token from signer to affiliate if specified.\\r\\n\\t\\tif (order.affiliate.token != address(0)) {\\r\\n\\t\\t\\tACOAssetHelper._callTransferFromERC20(order.affiliate.token, order.signer.responsible, order.affiliate.responsible, order.affiliate.amount);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit Swap(\\r\\n\\t\\t\\torder.nonce,\\r\\n\\t\\t\\torder.signer.responsible,\\r\\n\\t\\t\\tfinalSender,\\r\\n\\t\\t\\ttrue,\\r\\n\\t\\t\\torder.signer.amount,\\r\\n\\t\\t\\t_aco,\\r\\n\\t\\t\\torder.sender.amount,\\r\\n\\t\\t\\torder.sender.token,\\r\\n\\t\\t\\torder.affiliate.responsible,\\r\\n\\t\\t\\torder.affiliate.amount,\\r\\n\\t\\t\\torder.affiliate.token\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @notice Atomic Token Swap for a Bid Order\\r\\n\\t * @param order OTCTypes.BidOrder Order to settle\\r\\n\\t */\\r\\n\\tfunction swapBidOrder(OTCTypes.BidOrder calldata order) external {\\r\\n\\t\\t// Ensure the order is valid.\\r\\n\\t\\taddress finalSender = _baseSwapValidation(\\r\\n\\t\\t\\torder.expiry,\\r\\n\\t\\t\\torder.nonce,\\r\\n\\t\\t\\torder.signer.responsible,\\r\\n\\t\\t\\torder.sender.responsible,\\r\\n\\t\\t\\torder.affiliate.responsible,\\r\\n\\t\\t\\torder.signature.signatory,\\r\\n\\t\\t\\torder.signature.v\\r\\n\\t\\t);\\r\\n\\t\\t// Ensure the signature is valid whether it is provided.\\r\\n\\t\\trequire(order.signature.v == uint8(0) || isValidBidOrder(order), \\\"ACOOTC:: Signature invalid\\\");\\r\\n\\r\\n\\t\\taddress _aco = _transferAco(finalSender, order.signer.responsible, order.sender);\\r\\n\\t\\t\\r\\n\\t\\tACOAssetHelper._callTransferFromERC20(order.signer.token, order.signer.responsible, finalSender, order.signer.amount);\\r\\n\\r\\n\\t\\t// Transfer token from signer to affiliate if specified.\\r\\n\\t\\tif (order.affiliate.token != address(0)) {\\r\\n\\t\\t\\tACOAssetHelper._callTransferFromERC20(order.affiliate.token, order.signer.responsible, order.affiliate.responsible, order.affiliate.amount);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit Swap(\\r\\n\\t\\t\\torder.nonce,\\r\\n\\t\\t\\torder.signer.responsible,\\r\\n\\t\\t\\tfinalSender,\\r\\n\\t\\t\\tfalse,\\r\\n\\t\\t\\torder.signer.amount,\\r\\n\\t\\t\\torder.signer.token,\\r\\n\\t\\t\\torder.sender.amount,\\r\\n\\t\\t\\t_aco,\\r\\n\\t\\t\\torder.affiliate.responsible,\\r\\n\\t\\t\\torder.affiliate.amount,\\r\\n\\t\\t\\torder.affiliate.token\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Cancel one or more open orders by nonce\\r\\n\\t * @dev Cancelled nonces are marked UNAVAILABLE (0x01)\\r\\n\\t * @dev Emits a Cancel event\\r\\n\\t * @dev Out of gas may occur in arrays of length \\u003e 400\\r\\n\\t * @param nonces uint256[] List of nonces to cancel\\r\\n\\t */\\r\\n\\tfunction cancel(uint256[] calldata nonces) external {\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c nonces.length; i++) {\\r\\n\\t\\t\\tif (signerNonceStatus[msg.sender][nonces[i]] == AVAILABLE) {\\r\\n\\t\\t\\t\\tsignerNonceStatus[msg.sender][nonces[i]] = UNAVAILABLE;\\r\\n\\t\\t\\t\\temit Cancel(nonces[i], msg.sender);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Cancels all orders below a nonce value\\r\\n\\t * @dev Emits a CancelUpTo event\\r\\n\\t * @param minimumNonce uint256 Minimum valid nonce\\r\\n\\t */\\r\\n\\tfunction cancelUpTo(uint256 minimumNonce) external {\\r\\n\\t\\tsignerMinimumNonce[msg.sender] = minimumNonce;\\r\\n\\t\\temit CancelUpTo(minimumNonce, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Authorize a delegated sender\\r\\n\\t * @dev Emits an AuthorizeSender event\\r\\n\\t * @param authorizedSender address Address to authorize\\r\\n\\t */\\r\\n\\tfunction authorizeSender(address authorizedSender) external {\\r\\n\\t\\trequire(msg.sender != authorizedSender, \\\"ACOOTC:: Self authorization\\\");\\r\\n\\t\\tif (!senderAuthorizations[msg.sender][authorizedSender]) {\\r\\n\\t\\t\\tsenderAuthorizations[msg.sender][authorizedSender] = true;\\r\\n\\t\\t\\temit AuthorizeSender(msg.sender, authorizedSender);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Authorize a delegated signer\\r\\n\\t * @dev Emits an AuthorizeSigner event\\r\\n\\t * @param authorizedSigner address Address to authorize\\r\\n\\t */\\r\\n\\tfunction authorizeSigner(address authorizedSigner) external {\\r\\n\\t\\trequire(msg.sender != authorizedSigner, \\\"ACOOTC:: Self authorization\\\");\\r\\n\\t\\tif (!signerAuthorizations[msg.sender][authorizedSigner]) {\\r\\n\\t\\t\\tsignerAuthorizations[msg.sender][authorizedSigner] = true;\\r\\n\\t\\t\\temit AuthorizeSigner(msg.sender, authorizedSigner);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Revoke an authorized sender\\r\\n\\t * @dev Emits a RevokeSender event\\r\\n\\t * @param authorizedSender address Address to revoke\\r\\n\\t */\\r\\n\\tfunction revokeSender(address authorizedSender) external {\\r\\n\\t\\tif (senderAuthorizations[msg.sender][authorizedSender]) {\\r\\n\\t\\t\\tdelete senderAuthorizations[msg.sender][authorizedSender];\\r\\n\\t\\t\\temit RevokeSender(msg.sender, authorizedSender);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Revoke an authorized signer\\r\\n\\t * @dev Emits a RevokeSigner event\\r\\n\\t * @param authorizedSigner address Address to revoke\\r\\n\\t */\\r\\n\\tfunction revokeSigner(address authorizedSigner) external {\\r\\n\\t\\tif (signerAuthorizations[msg.sender][authorizedSigner]) {\\r\\n\\t\\t\\tdelete signerAuthorizations[msg.sender][authorizedSigner];\\r\\n\\t\\t\\temit RevokeSigner(msg.sender, authorizedSigner);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n    /**\\r\\n     * @notice Validate signature using an EIP-712 typed data hash\\r\\n     * @param order OTCTypes.AskOrder Order to validate\\r\\n     * @return bool True if order has a valid signature\\r\\n     */\\r\\n\\tfunction isValidAskOrder(OTCTypes.AskOrder memory order) public view returns(bool) {\\r\\n\\t\\tbytes32 orderHash = OTCTypes.hashAskOrder(order, _domainSeparator);\\r\\n\\t\\treturn _isValid(orderHash, order.signature);\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @notice Validate signature using an EIP-712 typed data hash\\r\\n     * @param order OTCTypes.BidOrder Order to validate\\r\\n     * @return bool True if order has a valid signature\\r\\n     */\\r\\n\\tfunction isValidBidOrder(OTCTypes.BidOrder memory order) public view returns(bool) {\\r\\n\\t\\tbytes32 orderHash = OTCTypes.hashBidOrder(order, _domainSeparator);\\r\\n\\t\\treturn _isValid(orderHash, order.signature);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Determine whether a sender delegate is authorized\\r\\n\\t * @param authorizer address Address doing the authorization\\r\\n\\t * @param delegate address Address being authorized\\r\\n\\t * @return bool True if a delegate is authorized to send\\r\\n\\t */\\r\\n\\tfunction _isSenderAuthorized(address authorizer, address delegate) internal view returns(bool) {\\r\\n\\t\\treturn ((authorizer == delegate) || senderAuthorizations[authorizer][delegate]);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Determine whether a signer delegate is authorized\\r\\n\\t * @param authorizer address Address doing the authorization\\r\\n\\t * @param delegate address Address being authorized\\r\\n\\t * @return bool True if a delegate is authorized to sign\\r\\n\\t */\\r\\n\\tfunction _isSignerAuthorized(address authorizer, address delegate) internal view returns(bool) {\\r\\n\\t\\treturn ((authorizer == delegate) || signerAuthorizations[authorizer][delegate]);\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n     * @notice Validate signature using an EIP-712 typed data hash\\r\\n     * @param orderHash Hashed order to validate\\r\\n\\t * @param signature OTCTypes.Signature teh order signature\\r\\n     * @return bool True if order has a valid signature\\r\\n     */\\r\\n\\tfunction _isValid(bytes32 orderHash, OTCTypes.Signature memory signature) internal pure returns(bool) {\\r\\n\\t\\tif (signature.version == bytes1(0x01)) {\\r\\n\\t\\t\\treturn signature.signatory ==\\r\\n\\t\\t\\t\\tecrecover(\\r\\n\\t\\t\\t\\t\\torderHash,\\r\\n\\t\\t\\t\\t\\tsignature.v,\\r\\n\\t\\t\\t\\t\\tsignature.r,\\r\\n\\t\\t\\t\\t\\tsignature.s\\r\\n\\t\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\t\\tif (signature.version == bytes1(0x45)) {\\r\\n\\t\\t\\treturn signature.signatory ==\\r\\n\\t\\t\\t\\tecrecover(\\r\\n\\t\\t\\t\\t\\tkeccak256(\\r\\n\\t\\t\\t\\t\\t\\tabi.encodePacked(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n\\t\\t\\t\\t\\t\\t\\torderHash\\r\\n\\t\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t\\t),\\r\\n\\t\\t\\t\\t\\tsignature.v,\\r\\n\\t\\t\\t\\t\\tsignature.r,\\r\\n\\t\\t\\t\\t\\tsignature.s\\r\\n\\t\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @notice Validate all base data for a swap order\\r\\n     * @param expiry Order expiry time\\r\\n\\t * @param nonce Order expiry time\\r\\n\\t * @param signer Order signer responsible address\\r\\n\\t * @param sender Order sender responsible address\\r\\n\\t * @param affiliate Order affiliate responsible address\\r\\n\\t * @param signatory Order signatory address\\r\\n\\t * @param v Order `v` parameter on the signature\\r\\n     * @return The final sender address\\r\\n     */\\r\\n\\tfunction _baseSwapValidation(\\r\\n\\t\\tuint256 expiry,\\r\\n\\t\\tuint256 nonce,\\r\\n\\t\\taddress signer,\\r\\n\\t\\taddress sender,\\r\\n\\t\\taddress affiliate,\\r\\n\\t\\taddress signatory,\\r\\n\\t\\tuint8 v\\r\\n\\t) internal returns(address) {\\r\\n\\t\\t// Ensure the order is not expired.\\r\\n\\t\\trequire(expiry \\u003e block.timestamp, \\\"ACOOTC:: Order expired\\\");\\r\\n\\r\\n\\t\\t// Ensure the nonce is AVAILABLE (0x00).\\r\\n\\t\\trequire(signerNonceStatus[signer][nonce] == AVAILABLE, \\\"ACOOTC:: Order taken or cancelled\\\");\\r\\n\\r\\n\\t\\t// Ensure the order nonce is above the minimum.\\r\\n\\t\\trequire(nonce \\u003e= signerMinimumNonce[signer], \\\"ACOOTC:: Nonce too low\\\");\\r\\n\\t\\t\\r\\n\\t\\t// Ensure distinct addresses.\\r\\n\\t\\trequire(signer != affiliate, \\\"ACOOTC:: Self transfer\\\");\\r\\n\\r\\n\\t\\t// Mark the nonce UNAVAILABLE (0x01).\\r\\n\\t\\tsignerNonceStatus[signer][nonce] = UNAVAILABLE;\\r\\n\\r\\n\\t\\t// Validate the sender side of the trade.\\r\\n\\t\\taddress finalSender;\\r\\n\\t\\tif (sender == address(0)) {\\r\\n\\t\\t\\t// Sender is not specified. The msg.sender of the transaction becomes the sender of the order.\\r\\n\\t\\t\\tfinalSender = msg.sender;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// Sender is specified. If the msg.sender is not the specified sender, this determines whether the msg.sender is an authorized sender.\\r\\n\\t\\t\\trequire(_isSenderAuthorized(sender, msg.sender), \\\"ACOOTC:: Sender unauthorized\\\");\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// The msg.sender is authorized.\\r\\n\\t\\t\\tfinalSender = sender;\\r\\n\\t\\t}\\r\\n\\t\\t// Ensure distinct addresses.\\r\\n\\t\\trequire(signer != finalSender, \\\"ACOOTC:: Self transfer\\\");\\r\\n\\r\\n\\t\\t// Validate the signer side of the trade.\\r\\n\\t\\tif (v == 0) {\\r\\n\\t\\t\\t// Signature is not provided. The signer may have authorized the msg.sender to swap on its behalf, which does not require a signature.\\r\\n\\t\\t\\trequire(_isSignerAuthorized(signer, msg.sender), \\\"ACOOTC:: Signer unauthorized\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// The signature is provided. Determine whether the signer is authorized.\\r\\n\\t\\t\\trequire(_isSignerAuthorized(signer, signatory), \\\"ACOOTC:: Signer unauthorized\\\");\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\treturn finalSender;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n     * @notice Transfer an ACO token\\r\\n\\t * With the order ACO party parameters a new ACO token will be created \\r\\n\\t * The collateral is used to mint ACO and then those tokens are transferred\\r\\n     * @param from The ACO creator responsible\\r\\n\\t * @param to The ACO token destination\\r\\n\\t * @param data OTCTypes.PartyAco Order party parameters to the ACO token\\r\\n     * @return The created ACO address\\r\\n     */\\r\\n\\tfunction _transferAco(address from, address to, OTCTypes.PartyAco memory data) internal returns(address) {\\r\\n\\t\\taddress collateral;\\r\\n\\t\\tuint256 collateralAmount;\\r\\n\\t\\tif (data.isCall) {\\r\\n\\t\\t\\tcollateral = data.underlying;\\r\\n\\t\\t\\tcollateralAmount = data.amount;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tcollateral = data.strikeAsset;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tuint256 decimals = uint256(ACOAssetHelper._getAssetDecimals(data.underlying));\\r\\n\\t\\t\\t// Ensure the underlying decimals will not overflow.\\r\\n\\t\\t\\trequire(decimals \\u003c 78, \\\"ACOOTC:: Invalid underlying\\\");\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tcollateralAmount = data.amount.mul(data.strikePrice).div((10 ** decimals));\\r\\n\\t\\t}\\r\\n\\t\\t// Ensure the collateral amount is not zero.\\r\\n\\t\\trequire(collateralAmount \\u003e 0, \\\"ACOOTC:: Collateral amount is too low\\\");\\r\\n\\r\\n\\t\\tif (ACOAssetHelper._isEther(collateral)) {\\r\\n\\t\\t\\tIWETH _weth = weth;\\r\\n\\t\\t\\tACOAssetHelper._callTransferFromERC20(address(_weth), from, address(this), collateralAmount);\\r\\n\\t\\t\\t_weth.withdraw(collateralAmount);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tACOAssetHelper._callTransferFromERC20(collateral, from, address(this), collateralAmount);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\taddress aco = acoFactory.createAcoToken(\\r\\n\\t\\t\\tdata.underlying, \\r\\n\\t\\t\\tdata.strikeAsset, \\r\\n\\t\\t\\tdata.isCall, \\r\\n\\t\\t\\tdata.strikePrice, \\r\\n\\t\\t\\tdata.expiryTime, \\r\\n\\t\\t\\tuint256(100)\\r\\n\\t\\t);\\r\\n\\t\\t\\r\\n\\t\\tif (ACOAssetHelper._isEther(collateral)) {\\r\\n\\t\\t\\tIACOToken(aco).mintToPayable{value: collateralAmount}(from);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tACOAssetHelper._callApproveERC20(collateral, aco, collateralAmount);\\r\\n\\t\\t\\tIACOToken(aco).mintTo(from, collateralAmount);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tACOAssetHelper._callTransferERC20(aco, to, data.amount);\\r\\n\\t\\t\\r\\n\\t\\treturn aco;\\r\\n\\t}\\r\\n}\"},\"IACOFactory.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IACOFactory {\\r\\n\\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\\r\\n    function acoFee() external view returns(uint256);\\r\\n    function factoryAdmin() external view returns(address);\\r\\n    function acoTokenImplementation() external view returns(address);\\r\\n    function acoFeeDestination() external view returns(address);\\r\\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\\r\\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\\r\\n    function setFactoryAdmin(address newFactoryAdmin) external;\\r\\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\\r\\n    function setAcoFee(uint256 newAcoFee) external;\\r\\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\\r\\n}\"},\"IACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IACOToken is IERC20 {\\r\\n\\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function underlying() external view returns (address);\\r\\n    function strikeAsset() external view returns (address);\\r\\n    function feeDestination() external view returns (address);\\r\\n    function isCall() external view returns (bool);\\r\\n    function strikePrice() external view returns (uint256);\\r\\n    function expiryTime() external view returns (uint256);\\r\\n    function totalCollateral() external view returns (uint256);\\r\\n    function acoFee() external view returns (uint256);\\r\\n\\tfunction maxExercisedAccounts() external view returns (uint256);\\r\\n    function underlyingSymbol() external view returns (string memory);\\r\\n    function strikeAssetSymbol() external view returns (string memory);\\r\\n    function underlyingDecimals() external view returns (uint8);\\r\\n    function strikeAssetDecimals() external view returns (uint8);\\r\\n    function currentCollateral(address account) external view returns(uint256);\\r\\n    function unassignableCollateral(address account) external view returns(uint256);\\r\\n    function assignableCollateral(address account) external view returns(uint256);\\r\\n    function currentCollateralizedTokens(address account) external view returns(uint256);\\r\\n    function unassignableTokens(address account) external view returns(uint256);\\r\\n    function assignableTokens(address account) external view returns(uint256);\\r\\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\\r\\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\\r\\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\\r\\n    function numberOfAccountsWithCollateral() external view returns(uint256);\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\\r\\n    function collateral() external view returns(address);\\r\\n    function mintPayable() external payable returns(uint256);\\r\\n    function mintToPayable(address account) external payable returns(uint256);\\r\\n    function mint(uint256 collateralAmount) external returns(uint256);\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\\r\\n    function burn(uint256 tokenAmount) external returns(uint256);\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\\r\\n    function redeem() external returns(uint256);\\r\\n    function redeemFrom(address account) external returns(uint256);\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IWETH.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function withdraw(uint) external;\\r\\n}\"},\"OTCTypes.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nlibrary OTCTypes {\\r\\n    bytes constant internal EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\r\\n\\r\\n    bytes32 constant internal DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\\r\\n        \\\"EIP712Domain(\\\",\\r\\n            \\\"string name,\\\",\\r\\n            \\\"string version,\\\",\\r\\n            \\\"uint256 chainId,\\\",\\r\\n            \\\"address verifyingContract\\\",\\r\\n        \\\")\\\"\\r\\n    ));\\r\\n    \\r\\n    bytes32 constant internal ASK_ORDER_TYPEHASH = keccak256(abi.encodePacked(\\r\\n        \\\"AskOrder(\\\",\\r\\n            \\\"uint256 nonce,\\\",\\r\\n            \\\"uint256 expiry,\\\",\\r\\n            \\\"PartyAco signer,\\\",\\r\\n            \\\"PartyToken sender,\\\",\\r\\n            \\\"PartyToken affiliate\\\",\\r\\n        \\\")\\\",\\r\\n        \\\"PartyAco(\\\",\\r\\n            \\\"address responsible,\\\",              \\r\\n            \\\"uint256 amount,\\\",    \\r\\n            \\\"address underlying,\\\",\\r\\n            \\\"address strikeAsset,\\\",\\r\\n            \\\"bool isCall,\\\",\\r\\n            \\\"uint256 strikePrice,\\\",\\r\\n            \\\"uint256 expiryTime\\\",\\r\\n        \\\")\\\",\\r\\n        \\\"PartyToken(\\\",\\r\\n            \\\"address responsible,\\\",              \\r\\n            \\\"uint256 amount,\\\",    \\r\\n            \\\"address token\\\",\\r\\n        \\\")\\\"\\r\\n    ));\\r\\n    \\r\\n    bytes32 constant internal BID_ORDER_TYPEHASH = keccak256(abi.encodePacked(\\r\\n        \\\"BidOrder(\\\",\\r\\n            \\\"uint256 nonce,\\\",\\r\\n            \\\"uint256 expiry,\\\",\\r\\n            \\\"PartyToken signer,\\\",\\r\\n            \\\"PartyAco sender,\\\",\\r\\n            \\\"PartyToken affiliate\\\",\\r\\n        \\\")\\\",\\r\\n        \\\"PartyAco(\\\",\\r\\n            \\\"address responsible,\\\",              \\r\\n            \\\"uint256 amount,\\\",    \\r\\n            \\\"address underlying,\\\",\\r\\n            \\\"address strikeAsset,\\\",\\r\\n            \\\"bool isCall,\\\",\\r\\n            \\\"uint256 strikePrice,\\\",\\r\\n            \\\"uint256 expiryTime\\\",\\r\\n        \\\")\\\",\\r\\n        \\\"PartyToken(\\\",\\r\\n            \\\"address responsible,\\\",              \\r\\n            \\\"uint256 amount,\\\",    \\r\\n            \\\"address token\\\",\\r\\n        \\\")\\\"\\r\\n    ));\\r\\n    \\r\\n    bytes32 constant internal PARTY_ACO_TYPEHASH = keccak256(abi.encodePacked(\\r\\n        \\\"PartyAco(\\\",\\r\\n            \\\"address responsible,\\\",              \\r\\n            \\\"uint256 amount,\\\",    \\r\\n            \\\"address underlying,\\\",\\r\\n            \\\"address strikeAsset,\\\",\\r\\n            \\\"bool isCall,\\\",\\r\\n            \\\"uint256 strikePrice,\\\",\\r\\n            \\\"uint256 expiryTime\\\",\\r\\n        \\\")\\\"\\r\\n    ));\\r\\n    \\r\\n    bytes32 constant internal PARTY_TOKEN_TYPEHASH = keccak256(abi.encodePacked(\\r\\n        \\\"PartyToken(\\\",\\r\\n            \\\"address responsible,\\\",              \\r\\n            \\\"uint256 amount,\\\",    \\r\\n            \\\"address token\\\",\\r\\n        \\\")\\\"\\r\\n    ));\\r\\n    \\r\\n    struct AskOrder {\\r\\n        uint256 nonce;               \\r\\n        uint256 expiry;              \\r\\n        PartyAco signer;                \\r\\n        PartyToken sender;                 \\r\\n        PartyToken affiliate;             \\r\\n        Signature signature;         \\r\\n    }\\r\\n    \\r\\n    struct BidOrder {\\r\\n        uint256 nonce;               \\r\\n        uint256 expiry;              \\r\\n        PartyToken signer;                \\r\\n        PartyAco sender;                 \\r\\n        PartyToken affiliate;             \\r\\n        Signature signature;         \\r\\n    }\\r\\n    \\r\\n    struct PartyAco {                \\r\\n        address responsible;              \\r\\n        uint256 amount;     \\r\\n        address underlying;\\r\\n        address strikeAsset;\\r\\n        bool isCall;\\r\\n        uint256 strikePrice;\\r\\n        uint256 expiryTime;\\r\\n    }\\r\\n    \\r\\n    struct PartyToken {                \\r\\n        address responsible;              \\r\\n        uint256 amount;     \\r\\n        address token;\\r\\n    }\\r\\n    \\r\\n    struct Signature {\\r\\n        address signatory;            \\r\\n        address validator;            \\r\\n        bytes1 version;               \\r\\n        uint8 v;                      \\r\\n        bytes32 r;                    \\r\\n        bytes32 s;                   \\r\\n    }\\r\\n    \\r\\n    function hashAskOrder(\\r\\n        AskOrder memory order,\\r\\n        bytes32 domainSeparator\\r\\n    ) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\r\\n            EIP191_HEADER,\\r\\n            domainSeparator,\\r\\n            keccak256(abi.encode(\\r\\n                ASK_ORDER_TYPEHASH,\\r\\n                order.nonce,\\r\\n                order.expiry,\\r\\n                keccak256(abi.encode(\\r\\n                    PARTY_ACO_TYPEHASH,\\r\\n                    order.signer.responsible,\\r\\n                    order.signer.amount,\\r\\n                    order.signer.underlying,\\r\\n                    order.signer.strikeAsset,\\r\\n                    order.signer.isCall,\\r\\n                    order.signer.strikePrice,\\r\\n                    order.signer.expiryTime\\r\\n                )),\\r\\n                keccak256(abi.encode(\\r\\n                    PARTY_TOKEN_TYPEHASH,\\r\\n                    order.sender.responsible,\\r\\n                    order.sender.amount,\\r\\n                    order.sender.token\\r\\n                )),\\r\\n                keccak256(abi.encode(\\r\\n                    PARTY_TOKEN_TYPEHASH,\\r\\n                    order.affiliate.responsible,\\r\\n                    order.affiliate.amount,\\r\\n                    order.affiliate.token\\r\\n                ))\\r\\n            ))\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    function hashBidOrder(\\r\\n        BidOrder memory order,\\r\\n        bytes32 domainSeparator\\r\\n    ) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\r\\n            EIP191_HEADER,\\r\\n            domainSeparator,\\r\\n            keccak256(abi.encode(\\r\\n                BID_ORDER_TYPEHASH,\\r\\n                order.nonce,\\r\\n                order.expiry,\\r\\n                keccak256(abi.encode(\\r\\n                    PARTY_TOKEN_TYPEHASH,\\r\\n                    order.signer.responsible,\\r\\n                    order.signer.amount,\\r\\n                    order.signer.token\\r\\n                )),\\r\\n                keccak256(abi.encode(\\r\\n                    PARTY_ACO_TYPEHASH,\\r\\n                    order.sender.responsible,\\r\\n                    order.sender.amount,\\r\\n                    order.sender.underlying,\\r\\n                    order.sender.strikeAsset,\\r\\n                    order.sender.isCall,\\r\\n                    order.sender.strikePrice,\\r\\n                    order.sender.expiryTime\\r\\n                )),\\r\\n                keccak256(abi.encode(\\r\\n                    PARTY_TOKEN_TYPEHASH,\\r\\n                    order.affiliate.responsible,\\r\\n                    order.affiliate.amount,\\r\\n                    order.affiliate.token\\r\\n                ))\\r\\n            ))\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n    function hashDomain(\\r\\n        bytes memory name,\\r\\n        bytes memory version,\\r\\n        address verifyingContract\\r\\n    ) internal pure returns (bytes32) {\\r\\n        uint256 id;\\r\\n        assembly {\\r\\n            id := chainid()\\r\\n        }\\r\\n        return keccak256(abi.encode(\\r\\n                DOMAIN_TYPEHASH,\\r\\n                keccak256(name),\\r\\n                keccak256(version),\\r\\n                id,\\r\\n                verifyingContract\\r\\n            ));\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_acoFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedSender\",\"type\":\"address\"}],\"name\":\"AuthorizeSender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizedSigner\",\"type\":\"address\"}],\"name\":\"AuthorizeSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"CancelUpTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"revokedSender\",\"type\":\"address\"}],\"name\":\"RevokeSender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"revokedSigner\",\"type\":\"address\"}],\"name\":\"RevokeSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAskOrder\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"signerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signerToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"senderToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"affiliateAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"affiliateToken\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acoFactory\",\"outputs\":[{\"internalType\":\"contract IACOFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedSender\",\"type\":\"address\"}],\"name\":\"authorizeSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedSigner\",\"type\":\"address\"}],\"name\":\"authorizeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumNonce\",\"type\":\"uint256\"}],\"name\":\"cancelUpTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OTCTypes.PartyAco\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OTCTypes.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct OTCTypes.AskOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"isValidAskOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OTCTypes.PartyAco\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OTCTypes.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct OTCTypes.BidOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"isValidBidOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedSender\",\"type\":\"address\"}],\"name\":\"revokeSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizedSigner\",\"type\":\"address\"}],\"name\":\"revokeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"senderAuthorizations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signerAuthorizations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signerMinimumNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signerNonceStatus\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OTCTypes.PartyAco\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OTCTypes.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct OTCTypes.AskOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"swapAskOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"signer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OTCTypes.PartyAco\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"responsible\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct OTCTypes.PartyToken\",\"name\":\"affiliate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signatory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"version\",\"type\":\"bytes1\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OTCTypes.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct OTCTypes.BidOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"swapBidOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ACOOTC","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000176b98ab38d1ae8ff3f30bf07f9b93e26f559c17000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://99bfd1bb9150a10e9124dcdfc492f63c59ecb9112dac3c096d94b437e9f20031"}]}