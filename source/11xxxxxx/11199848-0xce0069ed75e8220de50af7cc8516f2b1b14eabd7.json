{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017-2020, bZeroX, LLC <https://bzx.network/>. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IWeth {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\ncontract IERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract IWethERC20 is IWeth, IERC20 {}\r\n\r\ncontract Constants {\r\n\r\n    uint256 internal constant WEI_PRECISION = 10**18;\r\n    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\r\n\r\n    uint256 internal constant DAYS_IN_A_YEAR = 365;\r\n    uint256 internal constant ONE_MONTH = 2628000; // approx. seconds in a month\r\n\r\n    string internal constant UserRewardsID = \"UserRewards\";\r\n\r\n    IWethERC20 public constant wethToken = IWethERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address public constant bzrxTokenAddress = 0x56d811088235F11C8920698a204A5010a788f4b3;\r\n    address public constant vbzrxTokenAddress = 0xB72B31907C1C95F3650b64b2469e08EdACeE5e8F;\r\n}\r\n\r\n/**\r\n * @dev Library for managing loan sets\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * Include with `using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;`.\r\n *\r\n */\r\nlibrary EnumerableBytes32Set {\r\n\r\n    struct Bytes32Set {\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) index;\r\n        bytes32[] values;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an address value to a set. O(1).\r\n     * Returns false if the value was already in the set.\r\n     */\r\n    function addAddress(Bytes32Set storage set, address addrvalue)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bytes32 value;\r\n        assembly {\r\n            value := addrvalue\r\n        }\r\n        return addBytes32(set, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     * Returns false if the value was already in the set.\r\n     */\r\n    function addBytes32(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (!contains(set, value)){\r\n            set.index[value] = set.values.push(value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an address value from a set. O(1).\r\n     * Returns false if the value was not present in the set.\r\n     */\r\n    function removeAddress(Bytes32Set storage set, address addrvalue)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bytes32 value;\r\n        assembly {\r\n            value := addrvalue\r\n        }\r\n        return removeBytes32(set, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     * Returns false if the value was not present in the set.\r\n     */\r\n    function removeBytes32(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (contains(set, value)){\r\n            uint256 toDeleteIndex = set.index[value] - 1;\r\n            uint256 lastIndex = set.values.length - 1;\r\n\r\n            // If the element we're deleting is the last one, we can just remove it without doing a swap\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set.values[lastIndex];\r\n\r\n                // Move the last value to the index where the deleted value is\r\n                set.values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\r\n            }\r\n\r\n            // Delete the index entry for the deleted value\r\n            delete set.index[value];\r\n\r\n            // Delete the old entry for the moved value\r\n            set.values.pop();\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set.index[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function containsAddress(Bytes32Set storage set, address addrvalue)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 value;\r\n        assembly {\r\n            value := addrvalue\r\n        }\r\n        return set.index[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array with all values in the set. O(N).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n\r\n     * WARNING: This function may run out of gas on large sets: use {length} and\r\n     * {get} instead in these cases.\r\n     */\r\n    function enumerate(Bytes32Set storage set, uint256 start, uint256 count)\r\n        internal\r\n        view\r\n        returns (bytes32[] memory output)\r\n    {\r\n        uint256 end = start + count;\r\n        require(end >= start, \"addition overflow\");\r\n        end = set.values.length < end ? set.values.length : end;\r\n        if (end == 0 || start >= end) {\r\n            return output;\r\n        }\r\n\r\n        output = new bytes32[](end-start);\r\n        for (uint256 i = start; i < end; i++) {\r\n            output[i-start] = set.values[i];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements on the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return set.values.length;\r\n    }\r\n\r\n   /** @dev Returns the element stored at position `index` in the set. O(1).\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function get(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return set.values[index];\r\n    }\r\n\r\n   /** @dev Returns the element stored at position `index` in the set. O(1).\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function getAddress(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 value = set.values[index];\r\n        address addrvalue;\r\n        assembly {\r\n            addrvalue := value\r\n        }\r\n        return addrvalue;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n    /// @dev Constant for locked guard state\r\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n    /**\r\n    * @dev We use a single lock for the whole contract.\r\n    */\r\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n    /**\r\n    * @dev Prevents a contract from calling itself, directly or indirectly.\r\n    * If you mark a function `nonReentrant`, you should also\r\n    * mark it `external`. Calling one `nonReentrant` function from\r\n    * another is not supported. Instead, you can implement a\r\n    * `private` function doing the actual work, and an `external`\r\n    * wrapper marked as `nonReentrant`.\r\n    */\r\n    modifier nonReentrant() {\r\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n        _;\r\n        reentrancyLock = REENTRANCY_GUARD_FREE;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n    */\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divCeil(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n    */\r\n    function divCeil(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = ((a - 1) / b) + 1;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanStruct {\r\n    struct Loan {\r\n        bytes32 id;                 // id of the loan\r\n        bytes32 loanParamsId;       // the linked loan params id\r\n        bytes32 pendingTradesId;    // the linked pending trades id\r\n        uint256 principal;          // total borrowed amount outstanding\r\n        uint256 collateral;         // total collateral escrowed for the loan\r\n        uint256 startTimestamp;     // loan start time\r\n        uint256 endTimestamp;       // for active loans, this is the expected loan end time, for in-active loans, is the actual (past) end time\r\n        uint256 startMargin;        // initial margin when the loan opened\r\n        uint256 startRate;          // reference rate when the loan opened for converting collateralToken to loanToken\r\n        address borrower;           // borrower of this loan\r\n        address lender;             // lender of this loan\r\n        bool active;                // if false, the loan has been fully closed\r\n    }\r\n}\r\n\r\ncontract LoanParamsStruct {\r\n    struct LoanParams {\r\n        bytes32 id;                 // id of loan params object\r\n        bool active;                // if false, this object has been disabled by the owner and can't be used for future loans\r\n        address owner;              // owner of this object\r\n        address loanToken;          // the token being loaned\r\n        address collateralToken;    // the required collateral token\r\n        uint256 minInitialMargin;   // the minimum allowed initial margin\r\n        uint256 maintenanceMargin;  // an unhealthy loan when current margin is at or below this value\r\n        uint256 maxLoanTerm;        // the maximum term for new loans (0 means there's no max term)\r\n    }\r\n}\r\n\r\ncontract OrderStruct {\r\n    struct Order {\r\n        uint256 lockedAmount;           // escrowed amount waiting for a counterparty\r\n        uint256 interestRate;           // interest rate defined by the creator of this order\r\n        uint256 minLoanTerm;            // minimum loan term allowed\r\n        uint256 maxLoanTerm;            // maximum loan term allowed\r\n        uint256 createdTimestamp;       // timestamp when this order was created\r\n        uint256 expirationTimestamp;    // timestamp when this order expires\r\n    }\r\n}\r\n\r\ncontract LenderInterestStruct {\r\n    struct LenderInterest {\r\n        uint256 principalTotal;     // total borrowed amount outstanding of asset\r\n        uint256 owedPerDay;         // interest owed per day for all loans of asset\r\n        uint256 owedTotal;          // total interest owed for all loans of asset (assuming they go to full term)\r\n        uint256 paidTotal;          // total interest paid so far for asset\r\n        uint256 updatedTimestamp;   // last update\r\n    }\r\n}\r\n\r\ncontract LoanInterestStruct {\r\n    struct LoanInterest {\r\n        uint256 owedPerDay;         // interest owed per day for loan\r\n        uint256 depositTotal;       // total escrowed interest for loan\r\n        uint256 updatedTimestamp;   // last update\r\n    }\r\n}\r\n\r\ncontract Objects is\r\n    LoanStruct,\r\n    LoanParamsStruct,\r\n    OrderStruct,\r\n    LenderInterestStruct,\r\n    LoanInterestStruct\r\n{}\r\n\r\ncontract State is Constants, Objects, ReentrancyGuard, Ownable {\r\n    using SafeMath for uint256;\r\n    using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;\r\n\r\n    address public priceFeeds;                                                              // handles asset reference price lookups\r\n    address public swapsImpl;                                                               // handles asset swaps using dex liquidity\r\n\r\n    mapping (bytes4 => address) public logicTargets;                                        // implementations of protocol functions\r\n\r\n    mapping (bytes32 => Loan) public loans;                                                 // loanId => Loan\r\n    mapping (bytes32 => LoanParams) public loanParams;                                      // loanParamsId => LoanParams\r\n\r\n    mapping (address => mapping (bytes32 => Order)) public lenderOrders;                    // lender => orderParamsId => Order\r\n    mapping (address => mapping (bytes32 => Order)) public borrowerOrders;                  // borrower => orderParamsId => Order\r\n\r\n    mapping (bytes32 => mapping (address => bool)) public delegatedManagers;                // loanId => delegated => approved\r\n\r\n    // Interest\r\n    mapping (address => mapping (address => LenderInterest)) public lenderInterest;         // lender => loanToken => LenderInterest object\r\n    mapping (bytes32 => LoanInterest) public loanInterest;                                  // loanId => LoanInterest object\r\n\r\n    // Internals\r\n    EnumerableBytes32Set.Bytes32Set internal logicTargetsSet;                               // implementations set\r\n    EnumerableBytes32Set.Bytes32Set internal activeLoansSet;                                // active loans set\r\n\r\n    mapping (address => EnumerableBytes32Set.Bytes32Set) internal lenderLoanSets;           // lender loans set\r\n    mapping (address => EnumerableBytes32Set.Bytes32Set) internal borrowerLoanSets;         // borrow loans set\r\n    mapping (address => EnumerableBytes32Set.Bytes32Set) internal userLoanParamSets;        // user loan params set\r\n\r\n    address public feesController;                                                          // address controlling fee withdrawals\r\n\r\n    uint256 public lendingFeePercent = 10 ether; // 10% fee                                 // fee taken from lender interest payments\r\n    mapping (address => uint256) public lendingFeeTokensHeld;                               // total interest fees received and not withdrawn per asset\r\n    mapping (address => uint256) public lendingFeeTokensPaid;                               // total interest fees withdraw per asset (lifetime fees = lendingFeeTokensHeld + lendingFeeTokensPaid)\r\n\r\n    uint256 public tradingFeePercent = 0.15 ether; // 0.15% fee                             // fee paid for each trade\r\n    mapping (address => uint256) public tradingFeeTokensHeld;                               // total trading fees received and not withdrawn per asset\r\n    mapping (address => uint256) public tradingFeeTokensPaid;                               // total trading fees withdraw per asset (lifetime fees = tradingFeeTokensHeld + tradingFeeTokensPaid)\r\n\r\n    uint256 public borrowingFeePercent = 0.09 ether; // 0.09% fee                           // origination fee paid for each loan\r\n    mapping (address => uint256) public borrowingFeeTokensHeld;                             // total borrowing fees received and not withdrawn per asset\r\n    mapping (address => uint256) public borrowingFeeTokensPaid;                             // total borrowing fees withdraw per asset (lifetime fees = borrowingFeeTokensHeld + borrowingFeeTokensPaid)\r\n\r\n    uint256 public protocolTokenHeld;                                                       // current protocol token deposit balance\r\n    uint256 public protocolTokenPaid;                                                       // lifetime total payout of protocol token\r\n\r\n    uint256 public affiliateFeePercent = 30 ether; // 30% fee share                         // fee share for affiliate program\r\n\r\n    mapping (address => mapping (address => uint256)) public liquidationIncentivePercent;   // percent discount on collateral for liquidators per loanToken and collateralToken\r\n\r\n    mapping (address => address) public loanPoolToUnderlying;                               // loanPool => underlying\r\n    mapping (address => address) public underlyingToLoanPool;                               // underlying => loanPool\r\n    EnumerableBytes32Set.Bytes32Set internal loanPoolsSet;                                  // loan pools set\r\n\r\n    mapping (address => bool) public supportedTokens;                                       // supported tokens for swaps\r\n\r\n    uint256 public maxDisagreement = 5 ether;                                               // % disagreement between swap rate and reference rate\r\n\r\n    uint256 public sourceBufferPercent = 5 ether;                                           // used to estimate kyber swap source amount\r\n\r\n    uint256 public maxSwapSize = 1500 ether;                                                // maximum supported swap size in ETH\r\n\r\n\r\n    function _setTarget(\r\n        bytes4 sig,\r\n        address target)\r\n        internal\r\n    {\r\n        logicTargets[sig] = target;\r\n\r\n        if (target != address(0)) {\r\n            logicTargetsSet.addBytes32(bytes32(sig));\r\n        } else {\r\n            logicTargetsSet.removeBytes32(bytes32(sig));\r\n        }\r\n    }\r\n}\r\n\r\ninterface IPriceFeeds {\r\n    function queryRate(\r\n        address sourceToken,\r\n        address destToken)\r\n        external\r\n        view\r\n        returns (uint256 rate, uint256 precision);\r\n\r\n    function queryPrecision(\r\n        address sourceToken,\r\n        address destToken)\r\n        external\r\n        view\r\n        returns (uint256 precision);\r\n\r\n    function queryReturn(\r\n        address sourceToken,\r\n        address destToken,\r\n        uint256 sourceAmount)\r\n        external\r\n        view\r\n        returns (uint256 destAmount);\r\n\r\n    function checkPriceDisagreement(\r\n        address sourceToken,\r\n        address destToken,\r\n        uint256 sourceAmount,\r\n        uint256 destAmount,\r\n        uint256 maxSlippage)\r\n        external\r\n        view\r\n        returns (uint256 sourceToDestSwapRate);\r\n\r\n    function amountInEth(\r\n        address Token,\r\n        uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256 ethAmount);\r\n\r\n    function getMaxDrawdown(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanAmount,\r\n        uint256 collateralAmount,\r\n        uint256 maintenanceMargin)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getCurrentMarginAndCollateralSize(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanAmount,\r\n        uint256 collateralAmount)\r\n        external\r\n        view\r\n        returns (uint256 currentMargin, uint256 collateralInEthAmount);\r\n\r\n    function getCurrentMargin(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanAmount,\r\n        uint256 collateralAmount)\r\n        external\r\n        view\r\n        returns (uint256 currentMargin, uint256 collateralToLoanRate);\r\n\r\n    function shouldLiquidate(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanAmount,\r\n        uint256 collateralAmount,\r\n        uint256 maintenanceMargin)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getFastGasPrice(\r\n        address payToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ncontract FeesEvents {\r\n\r\n    enum FeeType {\r\n        Lending,\r\n        Trading,\r\n        Borrowing,\r\n        SettleInterest\r\n    }\r\n\r\n    event PayLendingFee(\r\n        address indexed payer,\r\n        address indexed token,\r\n        uint256 amount\r\n    );\r\n\r\n    event SettleFeeRewardForInterestExpense(\r\n        address indexed payer,\r\n        address indexed token,\r\n        bytes32 indexed loanId,\r\n        uint256 amount\r\n    );\r\n\r\n    event PayTradingFee(\r\n        address indexed payer,\r\n        address indexed token,\r\n        bytes32 indexed loanId,\r\n        uint256 amount\r\n    );\r\n\r\n    event PayBorrowingFee(\r\n        address indexed payer,\r\n        address indexed token,\r\n        bytes32 indexed loanId,\r\n        uint256 amount\r\n    );\r\n\r\n    event EarnReward(\r\n        address indexed receiver,\r\n        bytes32 indexed loanId,\r\n        FeeType indexed feeType,\r\n        address token,\r\n        uint256 amount\r\n    );\r\n}\r\n\r\ncontract FeesHelper is State, FeesEvents {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // calculate trading fee\r\n    function _getTradingFee(\r\n        uint256 feeTokenAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return feeTokenAmount\r\n            .mul(tradingFeePercent)\r\n            .divCeil(WEI_PERCENT_PRECISION);\r\n    }\r\n\r\n    // calculate loan origination fee\r\n    function _getBorrowingFee(\r\n        uint256 feeTokenAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return feeTokenAmount\r\n            .mul(borrowingFeePercent)\r\n            .divCeil(WEI_PERCENT_PRECISION);\r\n    }\r\n\r\n    // settle trading fee\r\n    function _payTradingFee(\r\n        address user,\r\n        bytes32 loanId,\r\n        address feeToken,\r\n        uint256 tradingFee)\r\n        internal\r\n    {\r\n        if (tradingFee != 0) {\r\n            tradingFeeTokensHeld[feeToken] = tradingFeeTokensHeld[feeToken]\r\n                .add(tradingFee);\r\n\r\n            emit PayTradingFee(\r\n                user,\r\n                feeToken,\r\n                loanId,\r\n                tradingFee\r\n            );\r\n\r\n            _payFeeReward(\r\n                user,\r\n                loanId,\r\n                feeToken,\r\n                tradingFee,\r\n                FeeType.Trading\r\n            );\r\n        }\r\n    }\r\n\r\n    // settle loan origination fee\r\n    function _payBorrowingFee(\r\n        address user,\r\n        bytes32 loanId,\r\n        address feeToken,\r\n        uint256 borrowingFee)\r\n        internal\r\n    {\r\n        if (borrowingFee != 0) {\r\n            borrowingFeeTokensHeld[feeToken] = borrowingFeeTokensHeld[feeToken]\r\n                .add(borrowingFee);\r\n\r\n            emit PayBorrowingFee(\r\n                user,\r\n                feeToken,\r\n                loanId,\r\n                borrowingFee\r\n            );\r\n\r\n            _payFeeReward(\r\n                user,\r\n                loanId,\r\n                feeToken,\r\n                borrowingFee,\r\n                FeeType.Borrowing\r\n            );\r\n        }\r\n    }\r\n\r\n    // settle lender (interest) fee\r\n    function _payLendingFee(\r\n        address user,\r\n        address feeToken,\r\n        uint256 lendingFee)\r\n        internal\r\n    {\r\n        if (lendingFee != 0) {\r\n            lendingFeeTokensHeld[feeToken] = lendingFeeTokensHeld[feeToken]\r\n                .add(lendingFee);\r\n\r\n            emit PayLendingFee(\r\n                user,\r\n                feeToken,\r\n                lendingFee\r\n            );\r\n\r\n             //// NOTE: Lenders do not receive a fee reward ////\r\n        }\r\n    }\r\n\r\n    // settles and pays borrowers based on the fees generated by their interest payments\r\n    function _settleFeeRewardForInterestExpense(\r\n        LoanInterest storage loanInterestLocal,\r\n        bytes32 loanId,\r\n        address feeToken,\r\n        address user,\r\n        uint256 interestTime)\r\n        internal\r\n    {\r\n        uint256 updatedTimestamp = loanInterestLocal.updatedTimestamp;\r\n\r\n        uint256 interestExpenseFee;\r\n        if (updatedTimestamp != 0) {\r\n            // this represents the fee generated by a borrower's interest payment\r\n            interestExpenseFee = interestTime\r\n                .sub(updatedTimestamp)\r\n                .mul(loanInterestLocal.owedPerDay)\r\n                .mul(lendingFeePercent)\r\n                .div(1 days * WEI_PERCENT_PRECISION);\r\n        }\r\n\r\n        loanInterestLocal.updatedTimestamp = interestTime;\r\n\r\n        if (interestExpenseFee != 0) {\r\n            emit SettleFeeRewardForInterestExpense(\r\n                user,\r\n                feeToken,\r\n                loanId,\r\n                interestExpenseFee\r\n            );\r\n\r\n            _payFeeReward(\r\n                user,\r\n                loanId,\r\n                feeToken,\r\n                interestExpenseFee,\r\n                FeeType.SettleInterest\r\n            );\r\n        }\r\n    }\r\n\r\n    // pay protocolToken reward to user\r\n    function _payFeeReward(\r\n        address user,\r\n        bytes32 loanId,\r\n        address feeToken,\r\n        uint256 feeAmount,\r\n        FeeType feeType)\r\n        internal\r\n    {\r\n        // The protocol is designed to allow positions and loans to be closed, if for whatever reason\r\n        // the price lookup is failing, returning 0, or is otherwise paused. Therefore, we allow this\r\n        // call to fail silently, rather than revert, to allow the transaction to continue without a\r\n        // BZRX token reward.\r\n        uint256 rewardAmount;\r\n        address _priceFeeds = priceFeeds;\r\n        (bool success, bytes memory data) = _priceFeeds.staticcall(\r\n            abi.encodeWithSelector(\r\n                IPriceFeeds(_priceFeeds).queryReturn.selector,\r\n                feeToken,\r\n                bzrxTokenAddress, // price rewards using BZRX price rather than vesting token price\r\n                feeAmount / 2  // 50% of fee value\r\n            )\r\n        );\r\n        assembly {\r\n            if eq(success, 1) {\r\n                rewardAmount := mload(add(data, 32))\r\n            }\r\n        }\r\n\r\n        if (rewardAmount != 0) {\r\n            uint256 tokenBalance = protocolTokenHeld;\r\n            if (rewardAmount > tokenBalance) {\r\n                rewardAmount = tokenBalance;\r\n            }\r\n            if (rewardAmount != 0) {\r\n                protocolTokenHeld = tokenBalance\r\n                    .sub(rewardAmount);\r\n\r\n                bytes32 slot = keccak256(abi.encodePacked(user, UserRewardsID));\r\n                assembly {\r\n                    sstore(slot, add(sload(slot), rewardAmount))\r\n                }\r\n\r\n                emit EarnReward(\r\n                    user,\r\n                    loanId,\r\n                    feeType,\r\n                    vbzrxTokenAddress, // rewardToken\r\n                    rewardAmount\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract VaultController is Constants {\r\n    using SafeERC20 for IERC20;\r\n\r\n    event VaultDeposit(\r\n        address indexed asset,\r\n        address indexed from,\r\n        uint256 amount\r\n    );\r\n    event VaultWithdraw(\r\n        address indexed asset,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    function vaultEtherDeposit(\r\n        address from,\r\n        uint256 value)\r\n        internal\r\n    {\r\n        IWethERC20 _wethToken = wethToken;\r\n        _wethToken.deposit.value(value)();\r\n\r\n        emit VaultDeposit(\r\n            address(_wethToken),\r\n            from,\r\n            value\r\n        );\r\n    }\r\n\r\n    function vaultEtherWithdraw(\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n    {\r\n        if (value != 0) {\r\n            IWethERC20 _wethToken = wethToken;\r\n            uint256 balance = address(this).balance;\r\n            if (value > balance) {\r\n                _wethToken.withdraw(value - balance);\r\n            }\r\n            Address.sendValue(to, value);\r\n\r\n            emit VaultWithdraw(\r\n                address(_wethToken),\r\n                to,\r\n                value\r\n            );\r\n        }\r\n    }\r\n\r\n    function vaultDeposit(\r\n        address token,\r\n        address from,\r\n        uint256 value)\r\n        internal\r\n    {\r\n        if (value != 0) {\r\n            IERC20(token).safeTransferFrom(\r\n                from,\r\n                address(this),\r\n                value\r\n            );\r\n\r\n            emit VaultDeposit(\r\n                token,\r\n                from,\r\n                value\r\n            );\r\n        }\r\n    }\r\n\r\n    function vaultWithdraw(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n    {\r\n        if (value != 0) {\r\n            IERC20(token).safeTransfer(\r\n                to,\r\n                value\r\n            );\r\n\r\n            emit VaultWithdraw(\r\n                token,\r\n                to,\r\n                value\r\n            );\r\n        }\r\n    }\r\n\r\n    function vaultTransfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n    {\r\n        if (value != 0) {\r\n            if (from == address(this)) {\r\n                IERC20(token).safeTransfer(\r\n                    to,\r\n                    value\r\n                );\r\n            } else {\r\n                IERC20(token).safeTransferFrom(\r\n                    from,\r\n                    to,\r\n                    value\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function vaultApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n    {\r\n        if (value != 0 && IERC20(token).allowance(address(this), to) != 0) {\r\n            IERC20(token).safeApprove(to, 0);\r\n        }\r\n        IERC20(token).safeApprove(to, value);\r\n    }\r\n}\r\n\r\ncontract InterestUser is State, VaultController, FeesHelper {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function _payInterest(\r\n        address lender,\r\n        address interestToken)\r\n        internal\r\n    {\r\n        LenderInterest storage lenderInterestLocal = lenderInterest[lender][interestToken];\r\n\r\n        uint256 interestOwedNow = 0;\r\n        if (lenderInterestLocal.owedPerDay != 0 && lenderInterestLocal.updatedTimestamp != 0) {\r\n            interestOwedNow = block.timestamp\r\n                .sub(lenderInterestLocal.updatedTimestamp)\r\n                .mul(lenderInterestLocal.owedPerDay)\r\n                .div(1 days);\r\n\r\n            lenderInterestLocal.updatedTimestamp = block.timestamp;\r\n\r\n            if (interestOwedNow > lenderInterestLocal.owedTotal)\r\n\t            interestOwedNow = lenderInterestLocal.owedTotal;\r\n\r\n            if (interestOwedNow != 0) {\r\n                lenderInterestLocal.paidTotal = lenderInterestLocal.paidTotal\r\n                    .add(interestOwedNow);\r\n                lenderInterestLocal.owedTotal = lenderInterestLocal.owedTotal\r\n                    .sub(interestOwedNow);\r\n\r\n                _payInterestTransfer(\r\n                    lender,\r\n                    interestToken,\r\n                    interestOwedNow\r\n                );\r\n            }\r\n        } else {\r\n            lenderInterestLocal.updatedTimestamp = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _payInterestTransfer(\r\n        address lender,\r\n        address interestToken,\r\n        uint256 interestOwedNow)\r\n        internal\r\n    {\r\n        uint256 lendingFee = interestOwedNow\r\n            .mul(lendingFeePercent)\r\n            .divCeil(WEI_PERCENT_PRECISION);\r\n\r\n        _payLendingFee(\r\n            lender,\r\n            interestToken,\r\n            lendingFee\r\n        );\r\n\r\n        // transfers the interest to the lender, less the interest fee\r\n        vaultWithdraw(\r\n            interestToken,\r\n            lender,\r\n            interestOwedNow\r\n                .sub(lendingFee)\r\n        );\r\n    }\r\n}\r\n\r\ncontract LiquidationHelper is State {\r\n\r\n    function _getLiquidationAmounts(\r\n        uint256 principal,\r\n        uint256 collateral,\r\n        uint256 currentMargin,\r\n        uint256 maintenanceMargin,\r\n        uint256 collateralToLoanRate,\r\n        uint256 incentivePercent)\r\n        internal\r\n        view\r\n        returns (uint256 maxLiquidatable, uint256 maxSeizable)\r\n    {\r\n        if (currentMargin > maintenanceMargin || collateralToLoanRate == 0) {\r\n            return (maxLiquidatable, maxSeizable);\r\n        } else if (currentMargin <= incentivePercent) {\r\n            return (principal, collateral);\r\n        }\r\n\r\n        uint256 desiredMargin = maintenanceMargin\r\n            .add(5 ether); // 5 percentage points above maintenance\r\n\r\n        // maxLiquidatable = ((1 + desiredMargin)*principal - collateralToLoanRate*collateral) / (desiredMargin - incentivePercent)\r\n        maxLiquidatable = desiredMargin\r\n            .add(WEI_PERCENT_PRECISION)\r\n            .mul(principal)\r\n            .div(WEI_PERCENT_PRECISION);\r\n        maxLiquidatable = maxLiquidatable\r\n            .sub(\r\n                collateral\r\n                    .mul(collateralToLoanRate)\r\n                    .div(WEI_PRECISION)\r\n            );\r\n        maxLiquidatable = maxLiquidatable\r\n            .mul(WEI_PERCENT_PRECISION)\r\n            .div(\r\n                desiredMargin\r\n                    .sub(incentivePercent)\r\n            );\r\n        if (maxLiquidatable > principal) {\r\n            maxLiquidatable = principal;\r\n        }\r\n\r\n        // maxSeizable = maxLiquidatable * (1 + incentivePercent) / collateralToLoanRate\r\n        maxSeizable = maxLiquidatable\r\n            .mul(\r\n                incentivePercent\r\n                    .add(WEI_PERCENT_PRECISION)\r\n            );\r\n        maxSeizable = maxSeizable\r\n            .div(collateralToLoanRate)\r\n            .div(100);\r\n        if (maxSeizable > collateral) {\r\n            maxSeizable = collateral;\r\n        }\r\n\r\n        return (maxLiquidatable, maxSeizable);\r\n    }\r\n}\r\n\r\ncontract SwapsEvents {\r\n\r\n    event LoanSwap(\r\n        bytes32 indexed loanId,\r\n        address indexed sourceToken,\r\n        address indexed destToken,\r\n        address borrower,\r\n        uint256 sourceAmount,\r\n        uint256 destAmount\r\n    );\r\n\r\n    event ExternalSwap(\r\n        address indexed user,\r\n        address indexed sourceToken,\r\n        address indexed destToken,\r\n        uint256 sourceAmount,\r\n        uint256 destAmount\r\n    );\r\n}\r\n\r\ninterface ISwapsImpl {\r\n    function dexSwap(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        address receiverAddress,\r\n        address returnToSenderAddress,\r\n        uint256 minSourceTokenAmount,\r\n        uint256 maxSourceTokenAmount,\r\n        uint256 requiredDestTokenAmount)\r\n        external\r\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed);\r\n\r\n    function dexExpectedRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint256 sourceTokenAmount)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ncontract SwapsUser is State, SwapsEvents, FeesHelper {\r\n\r\n    function _loanSwap(\r\n        bytes32 loanId,\r\n        address sourceToken,\r\n        address destToken,\r\n        address user,\r\n        uint256 minSourceTokenAmount,\r\n        uint256 maxSourceTokenAmount,\r\n        uint256 requiredDestTokenAmount,\r\n        bool bypassFee,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed, uint256 sourceToDestSwapRate)\r\n    {\r\n        (destTokenAmountReceived, sourceTokenAmountUsed) = _swapsCall(\r\n            [\r\n                sourceToken,\r\n                destToken,\r\n                address(this), // receiver\r\n                address(this), // returnToSender\r\n                user\r\n            ],\r\n            [\r\n                minSourceTokenAmount,\r\n                maxSourceTokenAmount,\r\n                requiredDestTokenAmount\r\n            ],\r\n            loanId,\r\n            bypassFee,\r\n            loanDataBytes\r\n        );\r\n\r\n        // will revert if swap size too large\r\n        _checkSwapSize(sourceToken, sourceTokenAmountUsed);\r\n\r\n        // will revert if disagreement found\r\n        sourceToDestSwapRate = IPriceFeeds(priceFeeds).checkPriceDisagreement(\r\n            sourceToken,\r\n            destToken,\r\n            sourceTokenAmountUsed,\r\n            destTokenAmountReceived,\r\n            maxDisagreement\r\n        );\r\n\r\n        emit LoanSwap(\r\n            loanId,\r\n            sourceToken,\r\n            destToken,\r\n            user,\r\n            sourceTokenAmountUsed,\r\n            destTokenAmountReceived\r\n        );\r\n    }\r\n\r\n    function _swapsCall(\r\n        address[5] memory addrs,\r\n        uint256[3] memory vals,\r\n        bytes32 loanId,\r\n        bool miscBool, // bypassFee\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        //addrs[0]: sourceToken\r\n        //addrs[1]: destToken\r\n        //addrs[2]: receiver\r\n        //addrs[3]: returnToSender\r\n        //addrs[4]: user\r\n        //vals[0]:  minSourceTokenAmount\r\n        //vals[1]:  maxSourceTokenAmount\r\n        //vals[2]:  requiredDestTokenAmount\r\n\r\n        require(vals[0] != 0, \"sourceAmount == 0\");\r\n\r\n        uint256 destTokenAmountReceived;\r\n        uint256 sourceTokenAmountUsed;\r\n\r\n        uint256 tradingFee;\r\n        if (!miscBool) { // bypassFee\r\n            if (vals[2] == 0) {\r\n                // condition: vals[0] will always be used as sourceAmount\r\n\r\n                tradingFee = _getTradingFee(vals[0]);\r\n                if (tradingFee != 0) {\r\n                    _payTradingFee(\r\n                        addrs[4], // user\r\n                        loanId,\r\n                        addrs[0], // sourceToken\r\n                        tradingFee\r\n                    );\r\n\r\n                    vals[0] = vals[0]\r\n                        .sub(tradingFee);\r\n                }\r\n            } else {\r\n                // condition: unknown sourceAmount will be used\r\n\r\n                tradingFee = _getTradingFee(vals[2]);\r\n\r\n                if (tradingFee != 0) {\r\n                    vals[2] = vals[2]\r\n                        .add(tradingFee);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (vals[1] == 0) {\r\n            vals[1] = vals[0];\r\n        } else {\r\n            require(vals[0] <= vals[1], \"min greater than max\");\r\n        }\r\n\r\n        require(loanDataBytes.length == 0, \"invalid state\");\r\n        (destTokenAmountReceived, sourceTokenAmountUsed) = _swapsCall_internal(\r\n            addrs,\r\n            vals\r\n        );\r\n\r\n        if (vals[2] == 0) {\r\n            // there's no minimum destTokenAmount, but all of vals[0] (minSourceTokenAmount) must be spent, and amount spent can't exceed vals[0]\r\n            require(sourceTokenAmountUsed == vals[0], \"swap too large to fill\");\r\n\r\n            if (tradingFee != 0) {\r\n                sourceTokenAmountUsed = sourceTokenAmountUsed + tradingFee; // will never overflow\r\n            }\r\n        } else {\r\n            // there's a minimum destTokenAmount required, but sourceTokenAmountUsed won't be greater than vals[1] (maxSourceTokenAmount)\r\n            require(sourceTokenAmountUsed <= vals[1], \"swap fill too large\");\r\n            require(destTokenAmountReceived >= vals[2], \"insufficient swap liquidity\");\r\n\r\n            if (tradingFee != 0) {\r\n                _payTradingFee(\r\n                    addrs[4], // user\r\n                    loanId, // loanId,\r\n                    addrs[1], // destToken\r\n                    tradingFee\r\n                );\r\n\r\n                destTokenAmountReceived = destTokenAmountReceived - tradingFee; // will never overflow\r\n            }\r\n        }\r\n\r\n        return (destTokenAmountReceived, sourceTokenAmountUsed);\r\n    }\r\n\r\n    function _swapsCall_internal(\r\n        address[5] memory addrs,\r\n        uint256[3] memory vals)\r\n        internal\r\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed)\r\n    {\r\n        bytes memory data = abi.encodeWithSelector(\r\n            ISwapsImpl(swapsImpl).dexSwap.selector,\r\n            addrs[0], // sourceToken\r\n            addrs[1], // destToken\r\n            addrs[2], // receiverAddress\r\n            addrs[3], // returnToSenderAddress\r\n            vals[0],  // minSourceTokenAmount\r\n            vals[1],  // maxSourceTokenAmount\r\n            vals[2]   // requiredDestTokenAmount\r\n        );\r\n\r\n        bool success;\r\n        (success, data) = swapsImpl.delegatecall(data);\r\n        require(success, \"swap failed\");\r\n\r\n        (destTokenAmountReceived, sourceTokenAmountUsed) = abi.decode(data, (uint256, uint256));\r\n    }\r\n\r\n    function _swapsExpectedReturn(\r\n        address sourceToken,\r\n        address destToken,\r\n        uint256 sourceTokenAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tradingFee = _getTradingFee(sourceTokenAmount);\r\n        if (tradingFee != 0) {\r\n            sourceTokenAmount = sourceTokenAmount\r\n                .sub(tradingFee);\r\n        }\r\n\r\n        uint256 sourceToDestRate = ISwapsImpl(swapsImpl).dexExpectedRate(\r\n            sourceToken,\r\n            destToken,\r\n            sourceTokenAmount\r\n        );\r\n        uint256 sourceToDestPrecision = IPriceFeeds(priceFeeds).queryPrecision(\r\n            sourceToken,\r\n            destToken\r\n        );\r\n\r\n        return sourceTokenAmount\r\n            .mul(sourceToDestRate)\r\n            .div(sourceToDestPrecision);\r\n    }\r\n\r\n    function _checkSwapSize(\r\n        address tokenAddress,\r\n        uint256 amount)\r\n        internal\r\n        view\r\n    {\r\n        uint256 _maxSwapSize = maxSwapSize;\r\n        if (_maxSwapSize != 0) {\r\n            uint256 amountInEth;\r\n            if (tokenAddress == address(wethToken)) {\r\n                amountInEth = amount;\r\n            } else {\r\n                amountInEth = IPriceFeeds(priceFeeds).amountInEth(tokenAddress, amount);\r\n            }\r\n            require(amountInEth <= _maxSwapSize, \"swap too large\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanMaintenanceEvents {\r\n\r\n    event DepositCollateral(\r\n        address indexed user,\r\n        address indexed depositToken,\r\n        bytes32 indexed loanId,\r\n        uint256 depositAmount\r\n    );\r\n\r\n    event WithdrawCollateral(\r\n        address indexed user,\r\n        address indexed withdrawToken,\r\n        bytes32 indexed loanId,\r\n        uint256 withdrawAmount\r\n    );\r\n\r\n    event ExtendLoanDuration(\r\n        address indexed user,\r\n        address indexed depositToken,\r\n        bytes32 indexed loanId,\r\n        uint256 depositAmount,\r\n        uint256 collateralUsedAmount,\r\n        uint256 newEndTimestamp\r\n    );\r\n\r\n    event ReduceLoanDuration(\r\n        address indexed user,\r\n        address indexed withdrawToken,\r\n        bytes32 indexed loanId,\r\n        uint256 withdrawAmount,\r\n        uint256 newEndTimestamp\r\n    );\r\n\r\n    event ClaimReward(\r\n        address indexed user,\r\n        address indexed receiver,\r\n        address indexed token,\r\n        uint256 amount\r\n    );\r\n\r\n    enum LoanType {\r\n        All,\r\n        Margin,\r\n        NonMargin\r\n    }\r\n\r\n    struct LoanReturnData {\r\n        bytes32 loanId;\r\n        uint96 endTimestamp;\r\n        address loanToken;\r\n        address collateralToken;\r\n        uint256 principal;\r\n        uint256 collateral;\r\n        uint256 interestOwedPerDay;\r\n        uint256 interestDepositRemaining;\r\n        uint256 startRate; // collateralToLoanRate\r\n        uint256 startMargin;\r\n        uint256 maintenanceMargin;\r\n        uint256 currentMargin;\r\n        uint256 maxLoanTerm;\r\n        uint256 maxLiquidatable;\r\n        uint256 maxSeizable;\r\n    }\r\n}\r\n\r\ncontract LoanMaintenance is State, LoanMaintenanceEvents, VaultController, InterestUser, SwapsUser, LiquidationHelper {\r\n\r\n    function initialize(\r\n        address target)\r\n        external\r\n        onlyOwner\r\n    {\r\n        _setTarget(this.depositCollateral.selector, target);\r\n        _setTarget(this.withdrawCollateral.selector, target);\r\n        _setTarget(this.withdrawAccruedInterest.selector, target);\r\n        _setTarget(this.extendLoanDuration.selector, target);\r\n        _setTarget(this.reduceLoanDuration.selector, target);\r\n        _setTarget(this.claimRewards.selector, target);\r\n        _setTarget(this.rewardsBalanceOf.selector, target);\r\n        _setTarget(this.getLenderInterestData.selector, target);\r\n        _setTarget(this.getLoanInterestData.selector, target);\r\n        _setTarget(this.getUserLoans.selector, target);\r\n        _setTarget(this.getUserLoansCount.selector, target);\r\n        _setTarget(this.getLoan.selector, target);\r\n        _setTarget(this.getActiveLoans.selector, target);\r\n        _setTarget(this.getActiveLoansCount.selector, target);\r\n    }\r\n\r\n    function depositCollateral(\r\n        bytes32 loanId,\r\n        uint256 depositAmount) // must match msg.value if ether is sent\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        require(depositAmount != 0, \"depositAmount is 0\");\r\n\r\n        Loan storage loanLocal = loans[loanId];\r\n        require(loanLocal.active, \"loan is closed\");\r\n\r\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\r\n\r\n        address collateralToken = loanParamsLocal.collateralToken;\r\n        uint256 collateral = loanLocal.collateral;\r\n\r\n        require(msg.value == 0 || collateralToken == address(wethToken), \"wrong asset sent\");\r\n\r\n        collateral = collateral\r\n            .add(depositAmount);\r\n        loanLocal.collateral = collateral;\r\n\r\n        if (msg.value == 0) {\r\n            vaultDeposit(\r\n                collateralToken,\r\n                msg.sender,\r\n                depositAmount\r\n            );\r\n        } else {\r\n            require(msg.value == depositAmount, \"ether deposit mismatch\");\r\n            vaultEtherDeposit(\r\n                msg.sender,\r\n                msg.value\r\n            );\r\n        }\r\n\r\n        emit DepositCollateral(\r\n            loanLocal.borrower,\r\n            collateralToken,\r\n            loanId,\r\n            depositAmount\r\n        );\r\n    }\r\n\r\n    function withdrawCollateral(\r\n        bytes32 loanId,\r\n        address receiver,\r\n        uint256 withdrawAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 actualWithdrawAmount)\r\n    {\r\n        require(withdrawAmount != 0, \"withdrawAmount is 0\");\r\n        Loan storage loanLocal = loans[loanId];\r\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\r\n\r\n        require(loanLocal.active, \"loan is closed\");\r\n        require(\r\n            msg.sender == loanLocal.borrower ||\r\n            delegatedManagers[loanLocal.id][msg.sender],\r\n            \"unauthorized\"\r\n        );\r\n\r\n        address collateralToken = loanParamsLocal.collateralToken;\r\n        uint256 collateral = loanLocal.collateral;\r\n\r\n        uint256 maxDrawdown = IPriceFeeds(priceFeeds).getMaxDrawdown(\r\n            loanParamsLocal.loanToken,\r\n            collateralToken,\r\n            loanLocal.principal,\r\n            collateral,\r\n            loanParamsLocal.maintenanceMargin\r\n        );\r\n\r\n        if (withdrawAmount > maxDrawdown) {\r\n            actualWithdrawAmount = maxDrawdown;\r\n        } else {\r\n            actualWithdrawAmount = withdrawAmount;\r\n        }\r\n\r\n        collateral = collateral\r\n            .sub(actualWithdrawAmount, \"withdrawAmount too high\");\r\n        loanLocal.collateral = collateral;\r\n\r\n        if (collateralToken == address(wethToken)) {\r\n            vaultEtherWithdraw(\r\n                receiver,\r\n                actualWithdrawAmount\r\n            );\r\n        } else {\r\n            vaultWithdraw(\r\n                collateralToken,\r\n                receiver,\r\n                actualWithdrawAmount\r\n            );\r\n        }\r\n\r\n        emit WithdrawCollateral(\r\n            loanLocal.borrower,\r\n            collateralToken,\r\n            loanId,\r\n            withdrawAmount\r\n        );\r\n    }\r\n\r\n    function withdrawAccruedInterest(\r\n        address loanToken)\r\n        external\r\n    {\r\n        // pay outstanding interest to lender\r\n        _payInterest(\r\n            msg.sender, // lender\r\n            loanToken\r\n        );\r\n    }\r\n\r\n    function extendLoanDuration(\r\n        bytes32 loanId,\r\n        uint256 depositAmount,\r\n        bool useCollateral,\r\n        bytes calldata /*loanDataBytes*/) // for future use\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 secondsExtended)\r\n    {\r\n        require(depositAmount != 0, \"depositAmount is 0\");\r\n        Loan storage loanLocal = loans[loanId];\r\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\r\n\r\n        require(loanLocal.active, \"loan is closed\");\r\n        require(\r\n            !useCollateral ||\r\n            msg.sender == loanLocal.borrower ||\r\n            delegatedManagers[loanLocal.id][msg.sender],\r\n            \"unauthorized\"\r\n        );\r\n        require(loanParamsLocal.maxLoanTerm == 0, \"indefinite-term only\");\r\n        require(msg.value == 0 || (!useCollateral && loanParamsLocal.loanToken == address(wethToken)), \"wrong asset sent\");\r\n\r\n        // pay outstanding interest to lender\r\n        _payInterest(\r\n            loanLocal.lender,\r\n            loanParamsLocal.loanToken\r\n        );\r\n\r\n        LoanInterest storage loanInterestLocal = loanInterest[loanLocal.id];\r\n\r\n        _settleFeeRewardForInterestExpense(\r\n            loanInterestLocal,\r\n            loanLocal.id,\r\n            loanParamsLocal.loanToken,\r\n            loanLocal.borrower,\r\n            block.timestamp\r\n        );\r\n\r\n        // Handle back interest: calculates interest owned since the loan endtime passed but the loan remained open\r\n        uint256 backInterestOwed;\r\n        if (block.timestamp > loanLocal.endTimestamp) {\r\n            backInterestOwed = block.timestamp\r\n                .sub(loanLocal.endTimestamp);\r\n            backInterestOwed = backInterestOwed\r\n                .mul(loanInterestLocal.owedPerDay);\r\n            backInterestOwed = backInterestOwed\r\n                .div(1 days);\r\n\r\n            require(depositAmount > backInterestOwed, \"deposit cannot cover back interest\");\r\n        }\r\n\r\n        // deposit interest\r\n        uint256 collateralUsed;\r\n        if (useCollateral) {\r\n            collateralUsed = _doSwapWithCollateral(\r\n                loanLocal,\r\n                loanParamsLocal,\r\n                depositAmount\r\n            );\r\n        } else {\r\n            if (msg.value == 0) {\r\n                vaultDeposit(\r\n                    loanParamsLocal.loanToken,\r\n                    msg.sender,\r\n                    depositAmount\r\n                );\r\n            } else {\r\n                require(msg.value == depositAmount, \"ether deposit mismatch\");\r\n                vaultEtherDeposit(\r\n                    msg.sender,\r\n                    msg.value\r\n                );\r\n            }\r\n        }\r\n\r\n        if (backInterestOwed != 0) {\r\n            depositAmount = depositAmount\r\n                .sub(backInterestOwed);\r\n\r\n            // pay out backInterestOwed\r\n            _payInterestTransfer(\r\n                loanLocal.lender,\r\n                loanParamsLocal.loanToken,\r\n                backInterestOwed\r\n            );\r\n        }\r\n\r\n        secondsExtended = depositAmount\r\n            .mul(1 days)\r\n            .div(loanInterestLocal.owedPerDay);\r\n\r\n        loanLocal.endTimestamp = loanLocal.endTimestamp\r\n            .add(secondsExtended);\r\n\r\n        require(loanLocal.endTimestamp > block.timestamp &&\r\n               (loanLocal.endTimestamp - block.timestamp) > 1 hours,\r\n            \"loan too short\"\r\n        );\r\n\r\n        loanInterestLocal.depositTotal = loanInterestLocal.depositTotal\r\n            .add(depositAmount);\r\n\r\n        lenderInterest[loanLocal.lender][loanParamsLocal.loanToken].owedTotal = lenderInterest[loanLocal.lender][loanParamsLocal.loanToken].owedTotal\r\n            .add(depositAmount);\r\n\r\n        emit ExtendLoanDuration(\r\n            loanLocal.borrower,\r\n            loanParamsLocal.loanToken,\r\n            loanId,\r\n            depositAmount,\r\n            collateralUsed,\r\n            loanLocal.endTimestamp\r\n        );\r\n    }\r\n\r\n    function reduceLoanDuration(\r\n        bytes32 loanId,\r\n        address receiver,\r\n        uint256 withdrawAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 secondsReduced)\r\n    {\r\n        require(withdrawAmount != 0, \"withdrawAmount is 0\");\r\n        Loan storage loanLocal = loans[loanId];\r\n        LoanParams storage loanParamsLocal = loanParams[loanLocal.loanParamsId];\r\n\r\n        require(loanLocal.active, \"loan is closed\");\r\n        require(\r\n            msg.sender == loanLocal.borrower ||\r\n            delegatedManagers[loanLocal.id][msg.sender],\r\n            \"unauthorized\"\r\n        );\r\n        require(loanParamsLocal.maxLoanTerm == 0, \"indefinite-term only\");\r\n        require(loanLocal.endTimestamp > block.timestamp, \"loan term has ended\");\r\n\r\n        // pay outstanding interest to lender\r\n        _payInterest(\r\n            loanLocal.lender,\r\n            loanParamsLocal.loanToken\r\n        );\r\n\r\n        LoanInterest storage loanInterestLocal = loanInterest[loanLocal.id];\r\n\r\n        _settleFeeRewardForInterestExpense(\r\n            loanInterestLocal,\r\n            loanLocal.id,\r\n            loanParamsLocal.loanToken,\r\n            loanLocal.borrower,\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 interestDepositRemaining = loanLocal.endTimestamp\r\n            .sub(block.timestamp)\r\n            .mul(loanInterestLocal.owedPerDay)\r\n            .div(1 days);\r\n        require(withdrawAmount < interestDepositRemaining, \"withdraw amount too high\");\r\n\r\n        // withdraw interest\r\n        if (loanParamsLocal.loanToken == address(wethToken)) {\r\n            vaultEtherWithdraw(\r\n                receiver,\r\n                withdrawAmount\r\n            );\r\n        } else {\r\n            vaultWithdraw(\r\n                loanParamsLocal.loanToken,\r\n                receiver,\r\n                withdrawAmount\r\n            );\r\n        }\r\n\r\n        secondsReduced = withdrawAmount\r\n            .mul(1 days)\r\n            .div(loanInterestLocal.owedPerDay);\r\n\r\n        require (loanLocal.endTimestamp > secondsReduced, \"loan too short\");\r\n\r\n        loanLocal.endTimestamp = loanLocal.endTimestamp\r\n            .sub(secondsReduced);\r\n\r\n        require(loanLocal.endTimestamp > block.timestamp &&\r\n               (loanLocal.endTimestamp - block.timestamp) > 1 hours,\r\n            \"loan too short\"\r\n        );\r\n\r\n        loanInterestLocal.depositTotal = loanInterestLocal.depositTotal\r\n            .sub(withdrawAmount);\r\n\r\n        lenderInterest[loanLocal.lender][loanParamsLocal.loanToken].owedTotal = lenderInterest[loanLocal.lender][loanParamsLocal.loanToken].owedTotal\r\n            .sub(withdrawAmount);\r\n\r\n        emit ReduceLoanDuration(\r\n            loanLocal.borrower,\r\n            loanParamsLocal.loanToken,\r\n            loanId,\r\n            withdrawAmount,\r\n            loanLocal.endTimestamp\r\n        );\r\n    }\r\n\r\n    function claimRewards(\r\n        address receiver)\r\n        external\r\n        returns (uint256 claimAmount)\r\n    {\r\n        bytes32 slot = keccak256(abi.encodePacked(msg.sender, UserRewardsID));\r\n        assembly {\r\n            claimAmount := sload(slot)\r\n        }\r\n\r\n        if (claimAmount != 0) {\r\n            assembly {\r\n                sstore(slot, 0)\r\n            }\r\n\r\n            protocolTokenPaid = protocolTokenPaid\r\n                .add(claimAmount);\r\n\r\n            IERC20(vbzrxTokenAddress).transfer(\r\n                receiver,\r\n                claimAmount\r\n            );\r\n\r\n            emit ClaimReward(\r\n                msg.sender,\r\n                receiver,\r\n                vbzrxTokenAddress,\r\n                claimAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function rewardsBalanceOf(\r\n        address user)\r\n        external\r\n        view\r\n        returns (uint256 rewardsBalance)\r\n    {\r\n        bytes32 slot = keccak256(abi.encodePacked(user, UserRewardsID));\r\n        assembly {\r\n            rewardsBalance := sload(slot)\r\n        }\r\n    }\r\n\r\n    /// @dev Gets current lender interest data totals for all loans with a specific oracle and interest token\r\n    /// @param lender The lender address\r\n    /// @param loanToken The loan token address\r\n    /// @return interestPaid The total amount of interest that has been paid to a lender so far\r\n    /// @return interestPaidDate The date of the last interest pay out, or 0 if no interest has been withdrawn yet\r\n    /// @return interestOwedPerDay The amount of interest the lender is earning per day\r\n    /// @return interestUnPaid The total amount of interest the lender is owned and not yet withdrawn\r\n    /// @return interestFeePercent The fee retained by the protocol before interest is paid to the lender\r\n    /// @return principalTotal The total amount of outstading principal the lender has loaned\r\n    function getLenderInterestData(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid,\r\n            uint256 interestFeePercent,\r\n            uint256 principalTotal)\r\n    {\r\n        LenderInterest memory lenderInterestLocal = lenderInterest[lender][loanToken];\r\n\r\n        interestUnPaid = block.timestamp.sub(lenderInterestLocal.updatedTimestamp).mul(lenderInterestLocal.owedPerDay).div(1 days);\r\n        if (interestUnPaid > lenderInterestLocal.owedTotal)\r\n            interestUnPaid = lenderInterestLocal.owedTotal;\r\n\r\n        return (\r\n            lenderInterestLocal.paidTotal,\r\n            lenderInterestLocal.paidTotal != 0 ? lenderInterestLocal.updatedTimestamp : 0,\r\n            lenderInterestLocal.owedPerDay,\r\n            lenderInterestLocal.updatedTimestamp != 0 ? interestUnPaid : 0,\r\n            lendingFeePercent,\r\n            lenderInterestLocal.principalTotal\r\n        );\r\n    }\r\n\r\n    /// @dev Gets current interest data for a loan\r\n    /// @param loanId A unique id representing the loan\r\n    /// @return loanToken The loan token that interest is paid in\r\n    /// @return interestOwedPerDay The amount of interest the borrower is paying per day\r\n    /// @return interestDepositTotal The total amount of interest the borrower has deposited\r\n    /// @return interestDepositRemaining The amount of deposited interest that is not yet owed to a lender\r\n    function getLoanInterestData(\r\n        bytes32 loanId)\r\n        external\r\n        view\r\n        returns (\r\n            address loanToken,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestDepositTotal,\r\n            uint256 interestDepositRemaining)\r\n    {\r\n        loanToken = loanParams[loans[loanId].loanParamsId].loanToken;\r\n        interestOwedPerDay = loanInterest[loanId].owedPerDay;\r\n        interestDepositTotal = loanInterest[loanId].depositTotal;\r\n\r\n        uint256 endTimestamp = loans[loanId].endTimestamp;\r\n        uint256 interestTime = block.timestamp > endTimestamp ?\r\n            endTimestamp :\r\n            block.timestamp;\r\n        interestDepositRemaining = endTimestamp > interestTime ?\r\n            endTimestamp\r\n                .sub(interestTime)\r\n                .mul(interestOwedPerDay)\r\n                .div(1 days) :\r\n                0;\r\n    }\r\n\r\n    // Only returns data for loans that are active\r\n    // All(0): all loans\r\n    // Margin(1): margin trade loans\r\n    // NonMargin(2): non-margin trade loans\r\n    // only active loans are returned\r\n    function getUserLoans(\r\n        address user,\r\n        uint256 start,\r\n        uint256 count,\r\n        LoanType loanType,\r\n        bool isLender,\r\n        bool unsafeOnly)\r\n        external\r\n        view\r\n        returns (LoanReturnData[] memory loansData)\r\n    {\r\n        EnumerableBytes32Set.Bytes32Set storage set = isLender ?\r\n            lenderLoanSets[user] :\r\n            borrowerLoanSets[user];\r\n\r\n        uint256 end = start.add(count).min256(set.length());\r\n        if (start >= end) {\r\n            return loansData;\r\n        }\r\n        count = end-start;\r\n\r\n        uint256 idx = count;\r\n        LoanReturnData memory loanData;\r\n        loansData = new LoanReturnData[](idx);\r\n        for (uint256 i = --end; i >= start; i--) {\r\n            loanData = _getLoan(\r\n                set.get(i), // loanId\r\n                loanType,\r\n                unsafeOnly\r\n            );\r\n            if (loanData.loanId == 0) {\r\n                if (i == 0) {\r\n                    break;\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            loansData[count-(idx--)] = loanData;\r\n\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (idx != 0) {\r\n            count -= idx;\r\n            assembly {\r\n                mstore(loansData, count)\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUserLoansCount(\r\n        address user,\r\n        bool isLender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return isLender ?\r\n            lenderLoanSets[user].length() :\r\n            borrowerLoanSets[user].length();\r\n    }\r\n\r\n    function getLoan(\r\n        bytes32 loanId)\r\n        external\r\n        view\r\n        returns (LoanReturnData memory loanData)\r\n    {\r\n        return _getLoan(\r\n            loanId,\r\n            LoanType.All,\r\n            false // unsafeOnly\r\n        );\r\n    }\r\n\r\n    function getActiveLoans(\r\n        uint256 start,\r\n        uint256 count,\r\n        bool unsafeOnly)\r\n        external\r\n        view\r\n        returns (LoanReturnData[] memory loansData)\r\n    {\r\n        uint256 end = start.add(count).min256(activeLoansSet.length());\r\n        if (start >= end) {\r\n            return loansData;\r\n        }\r\n        count = end-start;\r\n\r\n        uint256 idx = count;\r\n        LoanReturnData memory loanData;\r\n        loansData = new LoanReturnData[](idx);\r\n        for (uint256 i = --end; i >= start; i--) {\r\n            loanData = _getLoan(\r\n                activeLoansSet.get(i), // loanId\r\n                LoanType.All,\r\n                unsafeOnly\r\n            );\r\n            if (loanData.loanId == 0) {\r\n                if (i == 0) {\r\n                    break;\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            loansData[count-(idx--)] = loanData;\r\n\r\n            if (i == 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (idx != 0) {\r\n            count -= idx;\r\n            assembly {\r\n                mstore(loansData, count)\r\n            }\r\n        }\r\n    }\r\n\r\n    function getActiveLoansCount()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return activeLoansSet.length();\r\n    }\r\n\r\n    function _getLoan(\r\n        bytes32 loanId,\r\n        LoanType loanType,\r\n        bool unsafeOnly)\r\n        internal\r\n        view\r\n        returns (LoanReturnData memory loanData)\r\n    {\r\n        Loan memory loanLocal = loans[loanId];\r\n        LoanParams memory loanParamsLocal = loanParams[loanLocal.loanParamsId];\r\n\r\n        if ((loanType == LoanType.Margin && loanParamsLocal.maxLoanTerm == 0) ||\r\n            (loanType == LoanType.NonMargin && loanParamsLocal.maxLoanTerm != 0)) {\r\n            return loanData;\r\n        }\r\n\r\n        LoanInterest memory loanInterestLocal = loanInterest[loanId];\r\n\r\n        (uint256 currentMargin, uint256 value) = IPriceFeeds(priceFeeds).getCurrentMargin( // currentMargin, collateralToLoanRate\r\n            loanParamsLocal.loanToken,\r\n            loanParamsLocal.collateralToken,\r\n            loanLocal.principal,\r\n            loanLocal.collateral\r\n        );\r\n\r\n        uint256 maxLiquidatable;\r\n        uint256 maxSeizable;\r\n        if (currentMargin <= loanParamsLocal.maintenanceMargin) {\r\n            (maxLiquidatable, maxSeizable) = _getLiquidationAmounts(\r\n                loanLocal.principal,\r\n                loanLocal.collateral,\r\n                currentMargin,\r\n                loanParamsLocal.maintenanceMargin,\r\n                value, // collateralToLoanRate\r\n                liquidationIncentivePercent[loanParamsLocal.loanToken][loanParamsLocal.collateralToken]\r\n            );\r\n        } else if (unsafeOnly) {\r\n            return loanData;\r\n        }\r\n\r\n        if (loanLocal.endTimestamp > block.timestamp) {\r\n            value = loanLocal.endTimestamp\r\n                .sub(block.timestamp)\r\n                .mul(loanInterestLocal.owedPerDay)\r\n                .div(1 days);\r\n        } else {\r\n            value = 0;\r\n        }\r\n\r\n        return LoanReturnData({\r\n            loanId: loanId,\r\n            endTimestamp: uint96(loanLocal.endTimestamp),\r\n            loanToken: loanParamsLocal.loanToken,\r\n            collateralToken: loanParamsLocal.collateralToken,\r\n            principal: loanLocal.principal,\r\n            collateral: loanLocal.collateral,\r\n            interestOwedPerDay: loanInterestLocal.owedPerDay,\r\n            interestDepositRemaining: value,\r\n            startRate: loanLocal.startRate,\r\n            startMargin: loanLocal.startMargin,\r\n            maintenanceMargin: loanParamsLocal.maintenanceMargin,\r\n            currentMargin: currentMargin,\r\n            maxLoanTerm: loanParamsLocal.maxLoanTerm,\r\n            maxLiquidatable: maxLiquidatable,\r\n            maxSeizable: maxSeizable\r\n        });\r\n    }\r\n\r\n    function _doSwapWithCollateral(\r\n        Loan storage loanLocal,\r\n        LoanParams memory loanParamsLocal,\r\n        uint256 depositAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // reverts in _loanSwap if amountNeeded can't be bought\r\n        (,uint256 sourceTokenAmountUsed,) = _loanSwap(\r\n            loanLocal.id,\r\n            loanParamsLocal.collateralToken,\r\n            loanParamsLocal.loanToken,\r\n            loanLocal.borrower,\r\n            loanLocal.collateral, // minSourceTokenAmount\r\n            0, // maxSourceTokenAmount (0 means minSourceTokenAmount)\r\n            depositAmount, // requiredDestTokenAmount (partial spend of loanLocal.collateral to fill this amount)\r\n            true, // bypassFee\r\n            \"\" // loanDataBytes\r\n        );\r\n        loanLocal.collateral = loanLocal.collateral\r\n            .sub(sourceTokenAmountUsed);\r\n\r\n        // ensure the loan is still healthy\r\n        (uint256 currentMargin,) = IPriceFeeds(priceFeeds).getCurrentMargin(\r\n            loanParamsLocal.loanToken,\r\n            loanParamsLocal.collateralToken,\r\n            loanLocal.principal,\r\n            loanLocal.collateral\r\n        );\r\n        require(\r\n            currentMargin > loanParamsLocal.maintenanceMargin,\r\n            \"unhealthy position\"\r\n        );\r\n\r\n        return sourceTokenAmountUsed;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"DepositCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"enum FeesEvents.FeeType\",\"name\":\"feeType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EarnReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralUsedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEndTimestamp\",\"type\":\"uint256\"}],\"name\":\"ExtendLoanDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"}],\"name\":\"ExternalSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"}],\"name\":\"LoanSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayBorrowingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayLendingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayTradingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEndTimestamp\",\"type\":\"uint256\"}],\"name\":\"ReduceLoanDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SettleFeeRewardForInterestExpense\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawCollateral\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliateFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"borrowerOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowingFeeTokensHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowingFeeTokensPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bzrxTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegatedManagers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useCollateral\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"extendLoanDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsExtended\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unsafeOnly\",\"type\":\"bool\"}],\"name\":\"getActiveLoans\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"endTimestamp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestDepositRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLiquidatable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSeizable\",\"type\":\"uint256\"}],\"internalType\":\"struct LoanMaintenanceEvents.LoanReturnData[]\",\"name\":\"loansData\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActiveLoansCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"}],\"name\":\"getLenderInterestData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestPaidDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestUnPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestFeePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalTotal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"}],\"name\":\"getLoan\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"endTimestamp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestDepositRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLiquidatable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSeizable\",\"type\":\"uint256\"}],\"internalType\":\"struct LoanMaintenanceEvents.LoanReturnData\",\"name\":\"loanData\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"}],\"name\":\"getLoanInterestData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interestOwedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestDepositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestDepositRemaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"enum LoanMaintenanceEvents.LoanType\",\"name\":\"loanType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isLender\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"unsafeOnly\",\"type\":\"bool\"}],\"name\":\"getUserLoans\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"endTimestamp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestDepositRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLiquidatable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSeizable\",\"type\":\"uint256\"}],\"internalType\":\"struct LoanMaintenanceEvents.LoanReturnData[]\",\"name\":\"loansData\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLender\",\"type\":\"bool\"}],\"name\":\"getUserLoansCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lenderInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principalTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owedTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lenderOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lendingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lendingFeeTokensHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lendingFeeTokensPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidationIncentivePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"loanInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owedPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"loanParams\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minInitialMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"loanPoolToUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"loans\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"loanParamsId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"pendingTradesId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"logicTargets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDisagreement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSwapSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFeeds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolTokenHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"reduceLoanDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsReduced\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rewardsBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sourceBufferPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapsImpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tradingFeeTokensHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tradingFeeTokensPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingToLoanPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vbzrxTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethToken\",\"outputs\":[{\"internalType\":\"contract IWethERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"}],\"name\":\"withdrawAccruedInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualWithdrawAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LoanMaintenance","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4dd2619eb8c94472debe9449f6a03c81639203bc76410cb8cff0ae719403a6cf"}]}