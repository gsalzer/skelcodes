{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n// File: contracts/lib/Ownable.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/iface/Wallet.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title Wallet\r\n/// @dev Base contract for smart wallets.\r\n///      Sub-contracts must NOT use non-default constructor to initialize\r\n///      wallet states, instead, `init` shall be used. This is to enable\r\n///      proxies to be deployed in front of the real wallet contract for\r\n///      saving gas.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ninterface Wallet\r\n{\r\n    function version() external pure returns (string memory);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    /// @dev Set a new owner.\r\n    function setOwner(address newOwner) external;\r\n\r\n    /// @dev Adds a new module. The `init` method of the module\r\n    ///      will be called with `address(this)` as the parameter.\r\n    ///      This method must throw if the module has already been added.\r\n    /// @param _module The module's address.\r\n    function addModule(address _module) external;\r\n\r\n    /// @dev Removes an existing module. This method must throw if the module\r\n    ///      has NOT been added or the module is the wallet's only module.\r\n    /// @param _module The module's address.\r\n    function removeModule(address _module) external;\r\n\r\n    /// @dev Checks if a module has been added to this wallet.\r\n    /// @param _module The module to check.\r\n    /// @return True if the module exists; False otherwise.\r\n    function hasModule(address _module) external view returns (bool);\r\n\r\n    /// @dev Binds a method from the given module to this\r\n    ///      wallet so the method can be invoked using this wallet's default\r\n    ///      function.\r\n    ///      Note that this method must throw when the given module has\r\n    ///      not been added to this wallet.\r\n    /// @param _method The method's 4-byte selector.\r\n    /// @param _module The module's address. Use address(0) to unbind the method.\r\n    function bindMethod(bytes4 _method, address _module) external;\r\n\r\n    /// @dev Returns the module the given method has been bound to.\r\n    /// @param _method The method's 4-byte selector.\r\n    /// @return _module The address of the bound module. If no binding exists,\r\n    ///                 returns address(0) instead.\r\n    function boundMethodModule(bytes4 _method) external view returns (address _module);\r\n\r\n    /// @dev Performs generic transactions. Any module that has been added to this\r\n    ///      wallet can use this method to transact on any third-party contract with\r\n    ///      msg.sender as this wallet itself.\r\n    ///\r\n    ///      Note: 1) this method must ONLY allow invocations from a module that has\r\n    ///      been added to this wallet. The wallet owner shall NOT be permitted\r\n    ///      to call this method directly. 2) Reentrancy inside this function should\r\n    ///      NOT cause any problems.\r\n    ///\r\n    /// @param mode The transaction mode, 1 for CALL, 2 for DELEGATECALL.\r\n    /// @param to The desitination address.\r\n    /// @param value The amount of Ether to transfer.\r\n    /// @param data The data to send over using `to.call{value: value}(data)`\r\n    /// @return returnData The transaction's return value.\r\n    function transact(\r\n        uint8    mode,\r\n        address  to,\r\n        uint     value,\r\n        bytes    calldata data\r\n        )\r\n        external\r\n        returns (bytes memory returnData);\r\n}\r\n\r\n// File: contracts/iface/Module.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n/// @title Module\r\n/// @dev Base contract for all smart wallet modules.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ninterface Module\r\n{\r\n    /// @dev Activates the module for the given wallet (msg.sender) after the module is added.\r\n    ///      Warning: this method shall ONLY be callable by a wallet.\r\n    function activate() external;\r\n\r\n    /// @dev Deactivates the module for the given wallet (msg.sender) before the module is removed.\r\n    ///      Warning: this method shall ONLY be callable by a wallet.\r\n    function deactivate() external;\r\n}\r\n\r\n// File: contracts/lib/ERC20.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract ERC20\r\n{\r\n    function totalSupply()\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint    value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    modifier nonReentrant()\r\n    {\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n        _guardValue = 1;\r\n        _;\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n// File: contracts/iface/ModuleRegistry.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title ModuleRegistry\r\n/// @dev A registry for modules.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ninterface ModuleRegistry\r\n{\r\n\t/// @dev Registers and enables a new module.\r\n    function registerModule(address module) external;\r\n\r\n    /// @dev Disables a module\r\n    function disableModule(address module) external;\r\n\r\n    /// @dev Returns true if the module is registered and enabled.\r\n    function isModuleEnabled(address module) external view returns (bool);\r\n\r\n    /// @dev Returns the list of enabled modules.\r\n    function enabledModules() external view returns (address[] memory _modules);\r\n\r\n    /// @dev Returns the number of enbaled modules.\r\n    function numOfEnabledModules() external view returns (uint);\r\n\r\n    /// @dev Returns true if the module is ever registered.\r\n    function isModuleRegistered(address module) external view returns (bool);\r\n}\r\n\r\n// File: contracts/base/Controller.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Controller\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract Controller\r\n{\r\n    function moduleRegistry()\r\n        external\r\n        view\r\n        virtual\r\n        returns (ModuleRegistry);\r\n\r\n    function walletFactory()\r\n        external\r\n        view\r\n        virtual\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/base/BaseWallet.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title BaseWallet\r\n/// @dev This contract provides basic implementation for a Wallet.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract BaseWallet is ReentrancyGuard, Wallet\r\n{\r\n    // WARNING: do not delete wallet state data to make this implementation\r\n    // compatible with early versions.\r\n    //\r\n    //  ----- DATA LAYOUT BEGINS -----\r\n    address internal _owner;\r\n\r\n    mapping (address => bool) private modules;\r\n\r\n    Controller public controller;\r\n\r\n    mapping (bytes4  => address) internal methodToModule;\r\n    //  ----- DATA LAYOUT ENDS -----\r\n\r\n    event OwnerChanged          (address newOwner);\r\n    event ControllerChanged     (address newController);\r\n    event ModuleAdded           (address module);\r\n    event ModuleRemoved         (address module);\r\n    event MethodBound           (bytes4  method, address module);\r\n    event WalletSetup           (address owner);\r\n\r\n    modifier onlyFromModule\r\n    {\r\n        require(modules[msg.sender], \"MODULE_UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromFactory\r\n    {\r\n        require(\r\n            msg.sender == controller.walletFactory(),\r\n            \"UNAUTHORIZED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev We need to make sure the Factory address cannot be changed without wallet owner's\r\n    ///      explicit authorization.\r\n    modifier onlyFromFactoryOrModule\r\n    {\r\n        require(\r\n            modules[msg.sender] || msg.sender == controller.walletFactory(),\r\n            \"UNAUTHORIZED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Set up this wallet by assigning an original owner\r\n    ///\r\n    ///      Note that calling this method more than once will throw.\r\n    ///\r\n    /// @param _initialOwner The owner of this wallet, must not be address(0).\r\n    function initOwner(\r\n        address _initialOwner\r\n        )\r\n        external\r\n        onlyFromFactory\r\n    {\r\n        require(controller != Controller(0), \"NO_CONTROLLER\");\r\n        require(_owner == address(0), \"INITIALIZED_ALREADY\");\r\n        require(_initialOwner != address(0), \"ZERO_ADDRESS\");\r\n\r\n        _owner = _initialOwner;\r\n        emit WalletSetup(_initialOwner);\r\n    }\r\n\r\n    /// @dev Set up this wallet by assigning a controller and initial modules.\r\n    ///\r\n    ///      Note that calling this method more than once will throw.\r\n    ///      And this method must be invoked before owner is initialized\r\n    ///\r\n    /// @param _controller The Controller instance.\r\n    /// @param _modules The initial modules.\r\n    function init(\r\n        Controller _controller,\r\n        address[]  calldata _modules\r\n        )\r\n        external\r\n    {\r\n        require(\r\n            _owner == address(0) &&\r\n            controller == Controller(0) &&\r\n            _controller != Controller(0),\r\n            \"CONTROLLER_INIT_FAILED\"\r\n        );\r\n\r\n        controller = _controller;\r\n\r\n        ModuleRegistry moduleRegistry = controller.moduleRegistry();\r\n        for (uint i = 0; i < _modules.length; i++) {\r\n            _addModule(_modules[i], moduleRegistry);\r\n        }\r\n    }\r\n\r\n    function owner()\r\n        override\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    function setOwner(address newOwner)\r\n        external\r\n        override\r\n        onlyFromModule\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        require(newOwner != address(this), \"PROHIBITED\");\r\n        require(newOwner != _owner, \"SAME_ADDRESS\");\r\n        _owner = newOwner;\r\n        emit OwnerChanged(newOwner);\r\n    }\r\n\r\n    function setController(Controller newController)\r\n        external\r\n        onlyFromModule\r\n    {\r\n        require(newController != controller, \"SAME_CONTROLLER\");\r\n        require(newController != Controller(0), \"INVALID_CONTROLLER\");\r\n        controller = newController;\r\n        emit ControllerChanged(address(newController));\r\n    }\r\n\r\n    function addModule(address _module)\r\n        external\r\n        override\r\n        onlyFromFactoryOrModule\r\n    {\r\n        _addModule(_module, controller.moduleRegistry());\r\n    }\r\n\r\n    function removeModule(address _module)\r\n        external\r\n        override\r\n        onlyFromModule\r\n    {\r\n        // Allow deactivate to fail to make sure the module can be removed\r\n        require(modules[_module], \"MODULE_NOT_EXISTS\");\r\n        try Module(_module).deactivate() {} catch {}\r\n        delete modules[_module];\r\n        emit ModuleRemoved(_module);\r\n    }\r\n\r\n    function hasModule(address _module)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return modules[_module];\r\n    }\r\n\r\n    function bindMethod(bytes4 _method, address _module)\r\n        external\r\n        override\r\n        onlyFromModule\r\n    {\r\n        require(_method != bytes4(0), \"BAD_METHOD\");\r\n        if (_module != address(0)) {\r\n            require(modules[_module], \"MODULE_UNAUTHORIZED\");\r\n        }\r\n\r\n        methodToModule[_method] = _module;\r\n        emit MethodBound(_method, _module);\r\n    }\r\n\r\n    function boundMethodModule(bytes4 _method)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return methodToModule[_method];\r\n    }\r\n\r\n    function transact(\r\n        uint8    mode,\r\n        address  to,\r\n        uint     value,\r\n        bytes    calldata data\r\n        )\r\n        external\r\n        override\r\n        onlyFromFactoryOrModule\r\n        returns (bytes memory returnData)\r\n    {\r\n        bool success;\r\n        (success, returnData) = _call(mode, to, value, data);\r\n\r\n        if (!success) {\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    receive()\r\n        external\r\n        payable\r\n    {\r\n    }\r\n\r\n    /// @dev This default function can receive Ether or perform queries to modules\r\n    ///      using bound methods.\r\n    fallback()\r\n        external\r\n        payable\r\n    {\r\n        address module = methodToModule[msg.sig];\r\n        require(modules[module], \"MODULE_UNAUTHORIZED\");\r\n\r\n        (bool success, bytes memory returnData) = module.call{value: msg.value}(msg.data);\r\n        assembly {\r\n            switch success\r\n            case 0 { revert(add(returnData, 32), mload(returnData)) }\r\n            default { return(add(returnData, 32), mload(returnData)) }\r\n        }\r\n    }\r\n\r\n    function _addModule(address _module, ModuleRegistry moduleRegistry)\r\n        internal\r\n    {\r\n        require(_module != address(0), \"NULL_MODULE\");\r\n        require(modules[_module] == false, \"MODULE_EXISTS\");\r\n        require(\r\n            moduleRegistry.isModuleEnabled(_module),\r\n            \"INVALID_MODULE\"\r\n        );\r\n        modules[_module] = true;\r\n        emit ModuleAdded(_module);\r\n        Module(_module).activate();\r\n    }\r\n\r\n    function _call(\r\n        uint8          mode,\r\n        address        target,\r\n        uint           value,\r\n        bytes calldata data\r\n        )\r\n        private\r\n        returns (\r\n            bool success,\r\n            bytes memory returnData\r\n        )\r\n    {\r\n        if (mode == 1) {\r\n            // solium-disable-next-line security/no-call-value\r\n            (success, returnData) = target.call{value: value}(data);\r\n        } else if (mode == 2) {\r\n            // solium-disable-next-line security/no-call-value\r\n            (success, returnData) = target.delegatecall(data);\r\n        } else if (mode == 3) {\r\n            require(value == 0, \"INVALID_VALUE\");\r\n            // solium-disable-next-line security/no-call-value\r\n            (success, returnData) = target.staticcall(data);\r\n        } else {\r\n            revert(\"UNSUPPORTED_MODE\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AddressSet.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title AddressSet\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract AddressSet\r\n{\r\n    struct Set\r\n    {\r\n        address[] addresses;\r\n        mapping (address => uint) positions;\r\n        uint count;\r\n    }\r\n    mapping (bytes32 => Set) private sets;\r\n\r\n    function addAddressToSet(\r\n        bytes32 key,\r\n        address addr,\r\n        bool    maintainList\r\n        ) internal\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.positions[addr] == 0, \"ALREADY_IN_SET\");\r\n\r\n        if (maintainList) {\r\n            require(set.addresses.length == set.count, \"PREVIOUSLY_NOT_MAINTAILED\");\r\n            set.addresses.push(addr);\r\n        } else {\r\n            require(set.addresses.length == 0, \"MUST_MAINTAIN\");\r\n        }\r\n\r\n        set.count += 1;\r\n        set.positions[addr] = set.count;\r\n    }\r\n\r\n    function removeAddressFromSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n    {\r\n        Set storage set = sets[key];\r\n        uint pos = set.positions[addr];\r\n        require(pos != 0, \"NOT_IN_SET\");\r\n\r\n        delete set.positions[addr];\r\n        set.count -= 1;\r\n\r\n        if (set.addresses.length > 0) {\r\n            address lastAddr = set.addresses[set.count];\r\n            if (lastAddr != addr) {\r\n                set.addresses[pos - 1] = lastAddr;\r\n                set.positions[lastAddr] = pos;\r\n            }\r\n            set.addresses.pop();\r\n        }\r\n    }\r\n\r\n    function removeSet(bytes32 key)\r\n        internal\r\n    {\r\n        delete sets[key];\r\n    }\r\n\r\n    function isAddressInSet(\r\n        bytes32 key,\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return sets[key].positions[addr] != 0;\r\n    }\r\n\r\n    function numAddressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        Set storage set = sets[key];\r\n        return set.count;\r\n    }\r\n\r\n    function addressesInSet(bytes32 key)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        Set storage set = sets[key];\r\n        require(set.count == set.addresses.length, \"NOT_MAINTAINED\");\r\n        return sets[key].addresses;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Claimable.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/OwnerManagable.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\ncontract OwnerManagable is Claimable, AddressSet\r\n{\r\n    bytes32 internal constant MANAGER = keccak256(\"__MANAGED__\");\r\n\r\n    event ManagerAdded  (address indexed manager);\r\n    event ManagerRemoved(address indexed manager);\r\n\r\n    modifier onlyManager\r\n    {\r\n        require(isManager(msg.sender), \"NOT_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrManager\r\n    {\r\n        require(msg.sender == owner || isManager(msg.sender), \"NOT_OWNER_OR_MANAGER\");\r\n        _;\r\n    }\r\n\r\n    constructor() Claimable() {}\r\n\r\n    /// @dev Gets the managers.\r\n    /// @return The list of managers.\r\n    function managers()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return addressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Gets the number of managers.\r\n    /// @return The numer of managers.\r\n    function numManagers()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(MANAGER);\r\n    }\r\n\r\n    /// @dev Checks if an address is a manger.\r\n    /// @param addr The address to check.\r\n    /// @return True if the address is a manager, False otherwise.\r\n    function isManager(address addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isAddressInSet(MANAGER, addr);\r\n    }\r\n\r\n    /// @dev Adds a new manager.\r\n    /// @param manager The new address to add.\r\n    function addManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        addManagerInternal(manager);\r\n    }\r\n\r\n    /// @dev Removes a manager.\r\n    /// @param manager The manager to remove.\r\n    function removeManager(address manager)\r\n        public\r\n        onlyOwner\r\n    {\r\n        removeAddressFromSet(MANAGER, manager);\r\n        emit ManagerRemoved(manager);\r\n    }\r\n\r\n    function addManagerInternal(address manager)\r\n        internal\r\n    {\r\n        addAddressToSet(MANAGER, manager, true);\r\n        emit ManagerAdded(manager);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AddressUtil.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title Utility Functions for addresses\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AddressUtil\r\n{\r\n    using AddressUtil for *;\r\n\r\n    function isContract(\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(addr) }\r\n        return (codehash != 0x0 &&\r\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n\r\n    function toPayable(\r\n        address addr\r\n        )\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return payable(addr);\r\n    }\r\n\r\n    // Works like address.send but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        address payable recipient = to.toPayable();\r\n        /* solium-disable-next-line */\r\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\"\");\r\n    }\r\n\r\n    // Works like address.transfer but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETHAndVerify(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        success = to.sendETH(amount, gasLimit);\r\n        require(success, \"TRANSFER_FAILURE\");\r\n    }\r\n\r\n    // Works like call but is slightly more efficient when data\r\n    // needs to be copied from memory to do the call.\r\n    function fastCall(\r\n        address to,\r\n        uint    gasLimit,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        if (to != address(0)) {\r\n            assembly {\r\n                // Do the call\r\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\r\n                // Copy the return data\r\n                let size := returndatasize()\r\n                returnData := mload(0x40)\r\n                mstore(returnData, size)\r\n                returndatacopy(add(returnData, 32), 0, size)\r\n                // Update free memory pointer\r\n                mstore(0x40, add(returnData, add(32, size)))\r\n            }\r\n        }\r\n    }\r\n\r\n    // Like fastCall, but throws when the call is unsuccessful.\r\n    function fastCallAndVerify(\r\n        address to,\r\n        uint    gasLimit,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bytes memory returnData)\r\n    {\r\n        bool success;\r\n        (success, returnData) = fastCall(to, gasLimit, value, data);\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(returnData, 32), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/EIP712.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\nlibrary EIP712\r\n{\r\n    struct Domain {\r\n        string  name;\r\n        string  version;\r\n        address verifyingContract;\r\n    }\r\n\r\n    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\r\n\r\n    function hash(Domain memory domain)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        uint _chainid;\r\n        assembly { _chainid := chainid() }\r\n\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(domain.name)),\r\n                keccak256(bytes(domain.version)),\r\n                _chainid,\r\n                domain.verifyingContract\r\n            )\r\n        );\r\n    }\r\n\r\n    function hashPacked(\r\n        bytes32 domainSeperator,\r\n        bytes   memory encodedData\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(EIP191_HEADER, domainSeperator, keccak256(encodedData))\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/Create2.sol\r\n\r\n// Taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/970f687f04d20e01138a3e8ccf9278b1d4b3997b/contracts/utils/Create2.sol\r\n\r\n\r\n/**\r\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\r\n * `CREATE2` can be used to compute in advance the address where a smart\r\n * contract will be deployed, which allows for interesting new mechanisms known\r\n * as 'counterfactual interactions'.\r\n *\r\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\r\n * information.\r\n */\r\nlibrary Create2 {\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\r\n     * will be deployed can be known in advance via {computeAddress}. Note that\r\n     * a contract cannot be deployed twice using the same salt.\r\n     */\r\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address payable) {\r\n        address payable addr;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \"CREATE2_FAILED\");\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecode`\r\n     * or `salt` will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\r\n        return computeAddress(salt, bytecode, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes memory bytecodeHash, address deployer) internal pure returns (address) {\r\n        bytes32 bytecodeHashHash = keccak256(bytecodeHash);\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHashHash)\r\n        );\r\n        return address(bytes20(_data << 96));\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/strings.sol\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\n\r\n\r\n/* solium-disable */\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (uint256(self) & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (uint256(self) & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (uint256(self) & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (uint256(self) & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (uint256(self) & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to kblock.timestamp whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(uint i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/ens/ENS.sol\r\n\r\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENS.sol\r\n// with few modifications.\r\n\r\n\r\n/**\r\n * ENS Registry interface.\r\n */\r\ninterface ENSRegistry {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n\r\n/**\r\n * ENS Resolver interface.\r\n */\r\nabstract contract ENSResolver {\r\n    function addr(bytes32 _node) public view virtual returns (address);\r\n    function setAddr(bytes32 _node, address _addr) public virtual;\r\n    function name(bytes32 _node) public view virtual returns (string memory);\r\n    function setName(bytes32 _node, string memory _name) public virtual;\r\n}\r\n\r\n/**\r\n * ENS Reverse Registrar interface.\r\n */\r\nabstract contract ENSReverseRegistrar {\r\n    function claim(address _owner) public virtual returns (bytes32 _node);\r\n    function claimWithResolver(address _owner, address _resolver) public virtual returns (bytes32);\r\n    function setName(string memory _name) public virtual returns (bytes32);\r\n    function node(address _addr) public view virtual returns (bytes32);\r\n}\r\n\r\n// File: contracts/thirdparty/ens/ENSConsumer.sol\r\n\r\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENSConsumer.sol\r\n// with few modifications.\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ENSConsumer\r\n * @dev Helper contract to resolve ENS names.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract ENSConsumer {\r\n\r\n    using strings for *;\r\n\r\n    // namehash('addr.reverse')\r\n    bytes32 public constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    // the address of the ENS registry\r\n    address immutable ensRegistry;\r\n\r\n    /**\r\n    * @dev No address should be provided when deploying on Mainnet to avoid storage cost. The\r\n    * contract will use the hardcoded value.\r\n    */\r\n    constructor(address _ensRegistry) {\r\n        ensRegistry = _ensRegistry;\r\n    }\r\n\r\n    /**\r\n    * @dev Resolves an ENS name to an address.\r\n    * @param _node The namehash of the ENS name.\r\n    */\r\n    function resolveEns(bytes32 _node) public view returns (address) {\r\n        address resolver = getENSRegistry().resolver(_node);\r\n        return ENSResolver(resolver).addr(_node);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the official ENS registry.\r\n    */\r\n    function getENSRegistry() public view returns (ENSRegistry) {\r\n        return ENSRegistry(ensRegistry);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the official ENS reverse registrar.\r\n    */\r\n    function getENSReverseRegistrar() public view returns (ENSReverseRegistrar) {\r\n        return ENSReverseRegistrar(getENSRegistry().owner(ADDR_REVERSE_NODE));\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/BytesUtil.sol\r\n\r\n//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n\r\nlibrary BytesUtil {\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\r\n        require(_bytes.length >= (_start + 3));\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes4;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function fastSHA256(\r\n        bytes memory data\r\n        )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32[] memory result = new bytes32[](1);\r\n        bool success;\r\n        assembly {\r\n             let ptr := add(data, 32)\r\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\r\n        }\r\n        require(success, \"SHA256_FAILED\");\r\n        return result[0];\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ERC1271.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\nabstract contract ERC1271 {\r\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\r\n\r\n    function isValidSignature(\r\n        bytes32      _hash,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes4 magicValueB32);\r\n}\r\n\r\n// File: contracts/lib/MathUint.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SignatureUtil.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title SignatureUtil\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @dev This method supports multihash standard. Each signature's last byte indicates\r\n///      the signature's type.\r\nlibrary SignatureUtil\r\n{\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n    using AddressUtil   for address;\r\n\r\n    enum SignatureType {\r\n        ILLEGAL,\r\n        INVALID,\r\n        EIP_712,\r\n        ETH_SIGN,\r\n        WALLET   // deprecated\r\n    }\r\n\r\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\r\n\r\n    function verifySignatures(\r\n        bytes32          signHash,\r\n        address[] memory signers,\r\n        bytes[]   memory signatures\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(signers.length == signatures.length, \"BAD_SIGNATURE_DATA\");\r\n        address lastSigner;\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            require(signers[i] > lastSigner, \"INVALID_SIGNERS_ORDER\");\r\n            lastSigner = signers[i];\r\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function verifySignature(\r\n        bytes32        signHash,\r\n        address        signer,\r\n        bytes   memory signature\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (signer == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        return signer.isContract()?\r\n            verifyERC1271Signature(signHash, signer, signature):\r\n            verifyEOASignature(signHash, signer, signature);\r\n    }\r\n\r\n    function recoverECDSASigner(\r\n        bytes32      signHash,\r\n        bytes memory signature\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        if (signature.length != 65) {\r\n            return address(0);\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8   v;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := and(mload(add(signature, 0x41)), 0xff)\r\n        }\r\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        if (v == 27 || v == 28) {\r\n            return ecrecover(signHash, v, r, s);\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    function verifyEOASignature(\r\n        bytes32        signHash,\r\n        address        signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        pure\r\n        returns (bool success)\r\n    {\r\n        if (signer == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint signatureTypeOffset = signature.length.sub(1);\r\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\r\n\r\n        // Strip off the last byte of the signature by updating the length\r\n        assembly {\r\n            mstore(signature, signatureTypeOffset)\r\n        }\r\n\r\n        if (signatureType == SignatureType.EIP_712) {\r\n            success = (signer == recoverECDSASigner(signHash, signature));\r\n        } else if (signatureType == SignatureType.ETH_SIGN) {\r\n            bytes32 hash = keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signHash)\r\n            );\r\n            success = (signer == recoverECDSASigner(hash, signature));\r\n        } else {\r\n            success = false;\r\n        }\r\n\r\n        // Restore the signature length\r\n        assembly {\r\n            mstore(signature, add(signatureTypeOffset, 1))\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function verifyERC1271Signature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            ERC1271.isValidSignature.selector,\r\n            signHash,\r\n            signature\r\n        );\r\n        (bool success, bytes memory result) = signer.staticcall(callData);\r\n        return (\r\n            success &&\r\n            result.length == 32 &&\r\n            result.toBytes4(0) == ERC1271_MAGICVALUE\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/ens/BaseENSManager.sol\r\n\r\n// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ArgentENSManager.sol\r\n// with few modifications.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface for an ENS Mananger.\r\n */\r\ninterface IENSManager {\r\n    function changeRootnodeOwner(address _newOwner) external;\r\n\r\n    function isAvailable(bytes32 _subnode) external view returns (bool);\r\n\r\n    function resolveName(address _wallet) external view returns (string memory);\r\n\r\n    function register(\r\n        address _wallet,\r\n        address _owner,\r\n        string  calldata _label,\r\n        bytes   calldata _approval\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title BaseENSManager\r\n * @dev Implementation of an ENS manager that orchestrates the complete\r\n * registration of subdomains for a single root (e.g. argent.eth).\r\n * The contract defines a manager role who is the only role that can trigger the registration of\r\n * a new subdomain.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract BaseENSManager is IENSManager, OwnerManagable, ENSConsumer {\r\n\r\n    using strings for *;\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n\r\n    // The managed root name\r\n    string public rootName;\r\n    // The managed root node\r\n    bytes32 public immutable rootNode;\r\n    // The address of the ENS resolver\r\n    address public ensResolver;\r\n\r\n    // *************** Events *************************** //\r\n\r\n    event RootnodeOwnerChange(bytes32 indexed _rootnode, address indexed _newOwner);\r\n    event ENSResolverChanged(address addr);\r\n    event Registered(address indexed _wallet, address _owner, string _ens);\r\n    event Unregistered(string _ens);\r\n\r\n    // *************** Constructor ********************** //\r\n\r\n    /**\r\n     * @dev Constructor that sets the ENS root name and root node to manage.\r\n     * @param _rootName The root name (e.g. argentx.eth).\r\n     * @param _rootNode The node of the root name (e.g. namehash(argentx.eth)).\r\n     */\r\n    constructor(string memory _rootName, bytes32 _rootNode, address _ensRegistry, address _ensResolver)\r\n        ENSConsumer(_ensRegistry)\r\n    {\r\n        rootName = _rootName;\r\n        rootNode = _rootNode;\r\n        ensResolver = _ensResolver;\r\n    }\r\n\r\n    // *************** External Functions ********************* //\r\n\r\n    /**\r\n     * @dev This function must be called when the ENS Manager contract is replaced\r\n     * and the address of the new Manager should be provided.\r\n     * @param _newOwner The address of the new ENS manager that will manage the root node.\r\n     */\r\n    function changeRootnodeOwner(address _newOwner) external override onlyOwner {\r\n        getENSRegistry().setOwner(rootNode, _newOwner);\r\n        emit RootnodeOwnerChange(rootNode, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Lets the owner change the address of the ENS resolver contract.\r\n     * @param _ensResolver The address of the ENS resolver contract.\r\n     */\r\n    function changeENSResolver(address _ensResolver) external onlyOwner {\r\n        require(_ensResolver != address(0), \"WF: address cannot be null\");\r\n        ensResolver = _ensResolver;\r\n        emit ENSResolverChanged(_ensResolver);\r\n    }\r\n\r\n    /**\r\n    * @dev Lets the manager assign an ENS subdomain of the root node to a target address.\r\n    * Registers both the forward and reverse ENS.\r\n    * @param _wallet The wallet which owns the subdomain.\r\n    * @param _owner The wallet's owner.\r\n    * @param _label The subdomain label.\r\n    * @param _approval The signature of _wallet, _owner and _label by a manager.\r\n    */\r\n    function register(\r\n        address _wallet,\r\n        address _owner,\r\n        string  calldata _label,\r\n        bytes   calldata _approval\r\n        )\r\n        external\r\n        override\r\n        onlyManager\r\n    {\r\n        verifyApproval(_wallet, _owner, _label, _approval);\r\n\r\n        ENSRegistry _ensRegistry = getENSRegistry();\r\n        ENSResolver _ensResolver = ENSResolver(ensResolver);\r\n        bytes32 labelNode = keccak256(abi.encodePacked(_label));\r\n        bytes32 node = keccak256(abi.encodePacked(rootNode, labelNode));\r\n        address currentOwner = _ensRegistry.owner(node);\r\n        require(currentOwner == address(0), \"AEM: _label is alrealdy owned\");\r\n\r\n        // Forward ENS\r\n        _ensRegistry.setSubnodeOwner(rootNode, labelNode, address(this));\r\n        _ensRegistry.setResolver(node, address(_ensResolver));\r\n        _ensRegistry.setOwner(node, _wallet);\r\n        _ensResolver.setAddr(node, _wallet);\r\n\r\n        // Reverse ENS\r\n        strings.slice[] memory parts = new strings.slice[](2);\r\n        parts[0] = _label.toSlice();\r\n        parts[1] = rootName.toSlice();\r\n        string memory name = \".\".toSlice().join(parts);\r\n        bytes32 reverseNode = getENSReverseRegistrar().node(_wallet);\r\n        _ensResolver.setName(reverseNode, name);\r\n\r\n        emit Registered(_wallet, _owner, name);\r\n    }\r\n\r\n    // *************** Public Functions ********************* //\r\n\r\n    /**\r\n    * @dev Resolves an address to an ENS name\r\n    * @param _wallet The ENS owner address\r\n    */\r\n    function resolveName(address _wallet) public view override returns (string memory) {\r\n        bytes32 reverseNode = getENSReverseRegistrar().node(_wallet);\r\n        return ENSResolver(ensResolver).name(reverseNode);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true is a given subnode is available.\r\n     * @param _subnode The target subnode.\r\n     * @return true if the subnode is available.\r\n     */\r\n    function isAvailable(bytes32 _subnode) public view override returns (bool) {\r\n        bytes32 node = keccak256(abi.encodePacked(rootNode, _subnode));\r\n        address currentOwner = getENSRegistry().owner(node);\r\n        if(currentOwner == address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function verifyApproval(\r\n        address _wallet,\r\n        address _owner,\r\n        string  calldata _label,\r\n        bytes   calldata _approval\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _wallet,\r\n                _owner,\r\n                _label\r\n            )\r\n        );\r\n\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                messageHash\r\n            )\r\n        );\r\n\r\n        address signer = SignatureUtil.recoverECDSASigner(hash, _approval);\r\n        require(isManager(signer), \"UNAUTHORIZED\");\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/thirdparty/proxy/CloneFactory.sol\r\n\r\n// This code is taken from https://eips.ethereum.org/EIPS/eip-1167\r\n// Modified to a library and generalized to support create/create2.\r\n\r\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2018 Murray Software, LLC.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\nlibrary CloneFactory {\r\n  function getByteCode(address target) internal pure returns (bytes memory byteCode) {\r\n    bytes20 targetBytes = bytes20(target);\r\n    assembly {\r\n      byteCode := mload(0x40)\r\n      mstore(byteCode, 0x37)\r\n\r\n      let clone := add(byteCode, 0x20)\r\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(clone, 0x14), targetBytes)\r\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n      mstore(0x40, add(byteCode, 0x60))\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/modules/base/MetaTxAware.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n/// @title MetaTxAware\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n///\r\n/// The design of this contract is inspired by GSN's contract codebase:\r\n/// https://github.com/opengsn/gsn/contracts\r\n///\r\n/// @dev Inherit this abstract contract to make a module meta-transaction\r\n///      aware. `msgSender()` shall be used to replace `msg.sender` for\r\n///      verifying permissions.\r\nabstract contract MetaTxAware\r\n{\r\n    using AddressUtil for address;\r\n    using BytesUtil   for bytes;\r\n\r\n    address public immutable metaTxForwarder;\r\n\r\n    constructor(address _metaTxForwarder)\r\n    {\r\n        metaTxForwarder = _metaTxForwarder;\r\n    }\r\n\r\n    modifier txAwareHashNotAllowed()\r\n    {\r\n        require(txAwareHash() == 0, \"INVALID_TX_AWARE_HASH\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Return's the function's logicial message sender. This method should be\r\n    // used to replace `msg.sender` for all meta-tx enabled functions.\r\n    function msgSender()\r\n        internal\r\n        view\r\n        returns (address payable)\r\n    {\r\n        if (msg.data.length >= 56 && msg.sender == metaTxForwarder) {\r\n            return msg.data.toAddress(msg.data.length - 52).toPayable();\r\n        } else {\r\n            return msg.sender;\r\n        }\r\n    }\r\n\r\n    function txAwareHash()\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        if (msg.data.length >= 56 && msg.sender == metaTxForwarder) {\r\n            return msg.data.toBytes32(msg.data.length - 32);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/iface/PriceOracle.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title PriceOracle\r\ninterface PriceOracle\r\n{\r\n    // @dev Return's the token's value in ETH\r\n    function tokenValue(address token, uint amount)\r\n        external\r\n        view\r\n        returns (uint value);\r\n}\r\n\r\n// File: contracts/base/DataStore.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title DataStore\r\n/// @dev Modules share states by accessing the same storage instance.\r\n///      Using ModuleStorage will achieve better module decoupling.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract DataStore\r\n{\r\n    modifier onlyWalletModule(address wallet)\r\n    {\r\n        requireWalletModule(wallet);\r\n        _;\r\n    }\r\n\r\n    function requireWalletModule(address wallet) view internal\r\n    {\r\n        require(Wallet(wallet).hasModule(msg.sender), \"UNAUTHORIZED\");\r\n    }\r\n}\r\n\r\n// File: contracts/stores/HashStore.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n/// @title HashStore\r\n/// @dev This store maintains all hashes for SignedRequest.\r\ncontract HashStore is DataStore\r\n{\r\n    // wallet => hash => consumed\r\n    mapping(address => mapping(bytes32 => bool)) public hashes;\r\n\r\n    constructor() {}\r\n\r\n    function verifyAndUpdate(address wallet, bytes32 hash)\r\n        external\r\n    {\r\n        require(!hashes[wallet][hash], \"HASH_EXIST\");\r\n        requireWalletModule(wallet);\r\n        hashes[wallet][hash] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/thirdparty/SafeCast.sol\r\n\r\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value < 2**96, \"SafeCast: value doesn\\'t fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint40 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint40).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     */\r\n    function toUint40(uint256 value) internal pure returns (uint40) {\r\n        require(value < 2**40, \"SafeCast: value doesn\\'t fit in 40 bits\");\r\n        return uint40(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/stores/QuotaStore.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title QuotaStore\r\n/// @dev This store maintains daily spending quota for each wallet.\r\n///      A rolling daily limit is used.\r\ncontract QuotaStore is DataStore\r\n{\r\n    using MathUint for uint;\r\n    using SafeCast for uint;\r\n\r\n    uint128 public constant MAX_QUOTA = uint128(-1);\r\n\r\n    // Optimized to fit into 64 bytes (2 slots)\r\n    struct Quota\r\n    {\r\n        uint128 currentQuota;\r\n        uint128 pendingQuota;\r\n        uint128 spentAmount;\r\n        uint64  spentTimestamp;\r\n        uint64  pendingUntil;\r\n    }\r\n\r\n    mapping (address => Quota) public quotas;\r\n\r\n    event QuotaScheduled(\r\n        address wallet,\r\n        uint    pendingQuota,\r\n        uint64  pendingUntil\r\n    );\r\n\r\n    constructor()\r\n        DataStore()\r\n    {\r\n    }\r\n\r\n    // 0 for newQuota indicates unlimited quota, or daily quota is disabled.\r\n    function changeQuota(\r\n        address wallet,\r\n        uint    newQuota,\r\n        uint    effectiveTime\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        require(newQuota <= MAX_QUOTA, \"INVALID_VALUE\");\r\n        if (newQuota == MAX_QUOTA) {\r\n            newQuota = 0;\r\n        }\r\n\r\n        quotas[wallet].currentQuota = currentQuota(wallet).toUint128();\r\n        quotas[wallet].pendingQuota = newQuota.toUint128();\r\n        quotas[wallet].pendingUntil = effectiveTime.toUint64();\r\n\r\n        emit QuotaScheduled(\r\n            wallet,\r\n            newQuota,\r\n            quotas[wallet].pendingUntil\r\n        );\r\n    }\r\n\r\n    function checkAndAddToSpent(\r\n        address     wallet,\r\n        address     token,\r\n        uint        amount,\r\n        PriceOracle priceOracle\r\n        )\r\n        external\r\n    {\r\n        Quota memory q = quotas[wallet];\r\n        uint available = _availableQuota(q);\r\n        if (available != MAX_QUOTA) {\r\n            uint value = (token == address(0)) ?\r\n                amount :\r\n                priceOracle.tokenValue(token, amount);\r\n            if (value > 0) {\r\n                require(available >= value, \"QUOTA_EXCEEDED\");\r\n                requireWalletModule(wallet);\r\n                _addToSpent(wallet, q, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addToSpent(\r\n        address wallet,\r\n        uint    amount\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        _addToSpent(wallet, quotas[wallet], amount);\r\n    }\r\n\r\n    // Returns 0 to indiciate unlimited quota\r\n    function currentQuota(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _currentQuota(quotas[wallet]);\r\n    }\r\n\r\n    // Returns 0 to indiciate unlimited quota\r\n    function pendingQuota(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            uint __pendingQuota,\r\n            uint __pendingUntil\r\n        )\r\n    {\r\n        return _pendingQuota(quotas[wallet]);\r\n    }\r\n\r\n    function spentQuota(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _spentQuota(quotas[wallet]);\r\n    }\r\n\r\n    function availableQuota(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _availableQuota(quotas[wallet]);\r\n    }\r\n\r\n    function hasEnoughQuota(\r\n        address wallet,\r\n        uint    requiredAmount\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _hasEnoughQuota(quotas[wallet], requiredAmount);\r\n    }\r\n\r\n    // Internal\r\n\r\n    function _currentQuota(Quota memory q)\r\n        private\r\n        view\r\n        returns (uint)\r\n    {\r\n        return q.pendingUntil <= block.timestamp ? q.pendingQuota : q.currentQuota;\r\n    }\r\n\r\n    function _pendingQuota(Quota memory q)\r\n        private\r\n        view\r\n        returns (\r\n            uint __pendingQuota,\r\n            uint __pendingUntil\r\n        )\r\n    {\r\n        if (q.pendingUntil > 0 && q.pendingUntil > block.timestamp) {\r\n            __pendingQuota = q.pendingQuota;\r\n            __pendingUntil = q.pendingUntil;\r\n        }\r\n    }\r\n\r\n    function _spentQuota(Quota memory q)\r\n        private\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint timeSinceLastSpent = block.timestamp.sub(q.spentTimestamp);\r\n        if (timeSinceLastSpent < 1 days) {\r\n            return uint(q.spentAmount).sub(timeSinceLastSpent.mul(q.spentAmount) / 1 days);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function _availableQuota(Quota memory q)\r\n        private\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint quota = _currentQuota(q);\r\n        if (quota == 0) {\r\n            return MAX_QUOTA;\r\n        }\r\n        uint spent = _spentQuota(q);\r\n        return quota > spent ? quota - spent : 0;\r\n    }\r\n\r\n    function _hasEnoughQuota(\r\n        Quota   memory q,\r\n        uint    requiredAmount\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _availableQuota(q) >= requiredAmount;\r\n    }\r\n\r\n    function _addToSpent(\r\n        address wallet,\r\n        Quota   memory q,\r\n        uint    amount\r\n        )\r\n        private\r\n    {\r\n        Quota storage s = quotas[wallet];\r\n        s.spentAmount = _spentQuota(q).add(amount).toUint128();\r\n        s.spentTimestamp = uint64(block.timestamp);\r\n    }\r\n}\r\n\r\n// File: contracts/stores/Data.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\nlibrary Data\r\n{\r\n    enum GuardianStatus {\r\n        REMOVE,    // Being removed or removed after validUntil timestamp\r\n        ADD        // Being added or added after validSince timestamp.\r\n    }\r\n\r\n    // Optimized to fit into 32 bytes (1 slot)\r\n    struct Guardian\r\n    {\r\n        address addr;\r\n        uint8   status;\r\n        uint64  timestamp; // validSince if status = ADD; validUntil if adding = REMOVE;\r\n    }\r\n}\r\n\r\n// File: contracts/stores/GuardianStore.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title GuardianStore\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract GuardianStore is DataStore\r\n{\r\n    using MathUint      for uint;\r\n    using SafeCast      for uint;\r\n\r\n    struct Wallet\r\n    {\r\n        address    inheritor;\r\n        uint32     inheritWaitingPeriod;\r\n        uint64     lastActive; // the latest timestamp the owner is considered to be active\r\n        bool       locked;\r\n\r\n        Data.Guardian[]            guardians;\r\n        mapping (address => uint)  guardianIdx;\r\n    }\r\n\r\n    mapping (address => Wallet) public wallets;\r\n\r\n    constructor() DataStore() {}\r\n\r\n    function isGuardian(\r\n        address wallet,\r\n        address addr,\r\n        bool    includePendingAddition\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Data.Guardian memory g = _getGuardian(wallet, addr);\r\n        return _isActiveOrPendingAddition(g, includePendingAddition);\r\n    }\r\n\r\n    function guardians(\r\n        address wallet,\r\n        bool    includePendingAddition\r\n        )\r\n        public\r\n        view\r\n        returns (Data.Guardian[] memory _guardians)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        _guardians = new Data.Guardian[](w.guardians.length);\r\n        uint index = 0;\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (_isActiveOrPendingAddition(g, includePendingAddition)) {\r\n                _guardians[index] = g;\r\n                index++;\r\n            }\r\n        }\r\n        assembly { mstore(_guardians, index) }\r\n    }\r\n\r\n    function numGuardians(\r\n        address wallet,\r\n        bool    includePendingAddition\r\n        )\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (_isActiveOrPendingAddition(g, includePendingAddition)) {\r\n                count++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeAllGuardians(address wallet)\r\n        external\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        uint size = w.guardians.length;\r\n        if (size == 0) return;\r\n\r\n        requireWalletModule(wallet);\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            delete w.guardianIdx[w.guardians[i].addr];\r\n        }\r\n        delete w.guardians;\r\n    }\r\n\r\n    function cancelPendingGuardians(address wallet)\r\n        external\r\n    {\r\n        bool cancelled = false;\r\n        Wallet storage w = wallets[wallet];\r\n        for (uint i = 0; i < w.guardians.length; i++) {\r\n            Data.Guardian memory g = w.guardians[i];\r\n            if (_isPendingAddition(g)) {\r\n                w.guardians[i].status = uint8(Data.GuardianStatus.REMOVE);\r\n                w.guardians[i].timestamp = 0;\r\n                cancelled = true;\r\n            }\r\n            if (_isPendingRemoval(g)) {\r\n                w.guardians[i].status = uint8(Data.GuardianStatus.ADD);\r\n                w.guardians[i].timestamp = 0;\r\n                cancelled = true;\r\n            }\r\n        }\r\n        if (cancelled) {\r\n            requireWalletModule(wallet);\r\n        }\r\n        _cleanRemovedGuardians(wallet, true);\r\n    }\r\n\r\n    function cleanRemovedGuardians(address wallet)\r\n        external\r\n    {\r\n        _cleanRemovedGuardians(wallet, true);\r\n    }\r\n\r\n    function addGuardian(\r\n        address wallet,\r\n        address addr,\r\n        uint    validSince,\r\n        bool    alwaysOverride\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n        returns (uint)\r\n    {\r\n        require(validSince >= block.timestamp, \"INVALID_VALID_SINCE\");\r\n        require(addr != address(0), \"ZERO_ADDRESS\");\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint pos = w.guardianIdx[addr];\r\n\r\n        if(pos == 0) {\r\n            // Add the new guardian\r\n            Data.Guardian memory g = Data.Guardian(\r\n                addr,\r\n                uint8(Data.GuardianStatus.ADD),\r\n                validSince.toUint64()\r\n            );\r\n            w.guardians.push(g);\r\n            w.guardianIdx[addr] = w.guardians.length;\r\n\r\n            _cleanRemovedGuardians(wallet, false);\r\n            return validSince;\r\n        }\r\n\r\n        Data.Guardian memory g = w.guardians[pos - 1];\r\n\r\n        if (_isRemoved(g)) {\r\n            w.guardians[pos - 1].status = uint8(Data.GuardianStatus.ADD);\r\n            w.guardians[pos - 1].timestamp = validSince.toUint64();\r\n            return validSince;\r\n        }\r\n\r\n        if (_isPendingRemoval(g)) {\r\n            w.guardians[pos - 1].status = uint8(Data.GuardianStatus.ADD);\r\n            w.guardians[pos - 1].timestamp = 0;\r\n            return 0;\r\n        }\r\n\r\n        if (_isPendingAddition(g)) {\r\n            if (!alwaysOverride) return g.timestamp;\r\n\r\n            w.guardians[pos - 1].timestamp = validSince.toUint64();\r\n            return validSince;\r\n        }\r\n\r\n        require(_isAdded(g), \"UNEXPECTED_RESULT\");\r\n        return 0;\r\n    }\r\n\r\n    function removeGuardian(\r\n        address wallet,\r\n        address addr,\r\n        uint    validUntil,\r\n        bool    alwaysOverride\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n        returns (uint)\r\n    {\r\n        require(validUntil >= block.timestamp, \"INVALID_VALID_UNTIL\");\r\n        require(addr != address(0), \"ZERO_ADDRESS\");\r\n\r\n        Wallet storage w = wallets[wallet];\r\n        uint pos = w.guardianIdx[addr];\r\n        require(pos > 0, \"GUARDIAN_NOT_EXISTS\");\r\n\r\n        Data.Guardian memory g = w.guardians[pos - 1];\r\n\r\n        if (_isAdded(g)) {\r\n            w.guardians[pos - 1].status = uint8(Data.GuardianStatus.REMOVE);\r\n            w.guardians[pos - 1].timestamp = validUntil.toUint64();\r\n            return validUntil;\r\n        }\r\n\r\n        if (_isPendingAddition(g)) {\r\n            w.guardians[pos - 1].status = uint8(Data.GuardianStatus.REMOVE);\r\n            w.guardians[pos - 1].timestamp = 0;\r\n            return 0;\r\n        }\r\n\r\n        if (_isPendingRemoval(g)) {\r\n            if (!alwaysOverride) return g.timestamp;\r\n\r\n            w.guardians[pos - 1].timestamp = validUntil.toUint64();\r\n            return validUntil;\r\n        }\r\n\r\n        require(_isRemoved(g), \"UNEXPECTED_RESULT\");\r\n        return 0;\r\n    }\r\n\r\n    // ---- internal functions ---\r\n\r\n    function _getGuardian(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        private\r\n        view\r\n        returns (Data.Guardian memory)\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        uint pos = w.guardianIdx[addr];\r\n        if (pos > 0) {\r\n            return w.guardians[pos - 1];\r\n        }\r\n    }\r\n\r\n    function _isAdded(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.status == uint8(Data.GuardianStatus.ADD) &&\r\n            guardian.timestamp <= block.timestamp;\r\n    }\r\n\r\n    function _isPendingAddition(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.status == uint8(Data.GuardianStatus.ADD) &&\r\n            guardian.timestamp > block.timestamp;\r\n    }\r\n\r\n    function _isRemoved(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardian.status == uint8(Data.GuardianStatus.REMOVE) &&\r\n            guardian.timestamp <= block.timestamp;\r\n    }\r\n\r\n    function _isPendingRemoval(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n         return guardian.status == uint8(Data.GuardianStatus.REMOVE) &&\r\n            guardian.timestamp > block.timestamp;\r\n    }\r\n\r\n    function _isActive(Data.Guardian memory guardian)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _isAdded(guardian) || _isPendingRemoval(guardian);\r\n    }\r\n\r\n    function _isActiveOrPendingAddition(\r\n        Data.Guardian memory guardian,\r\n        bool includePendingAddition\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _isActive(guardian) || includePendingAddition && _isPendingAddition(guardian);\r\n    }\r\n\r\n    function _cleanRemovedGuardians(\r\n        address wallet,\r\n        bool    force\r\n        )\r\n        private\r\n    {\r\n        Wallet storage w = wallets[wallet];\r\n        uint count = w.guardians.length;\r\n        if (!force && count < 10) return;\r\n\r\n        for (int i = int(count) - 1; i >= 0; i--) {\r\n            Data.Guardian memory g = w.guardians[uint(i)];\r\n            if (_isRemoved(g)) {\r\n                Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\r\n\r\n                if (g.addr != lastGuardian.addr) {\r\n                    w.guardians[uint(i)] = lastGuardian;\r\n                    w.guardianIdx[lastGuardian.addr] = uint(i) + 1;\r\n                }\r\n                w.guardians.pop();\r\n                delete w.guardianIdx[g.addr];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/stores/SecurityStore.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n/// @title SecurityStore\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract SecurityStore is GuardianStore\r\n{\r\n    using MathUint for uint;\r\n    using SafeCast for uint;\r\n\r\n    constructor() GuardianStore() {}\r\n\r\n    function setLock(\r\n        address wallet,\r\n        bool    locked\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].locked = locked;\r\n    }\r\n\r\n    function touchLastActive(address wallet)\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].lastActive = uint64(block.timestamp);\r\n    }\r\n\r\n    function touchLastActiveWhenRequired(\r\n        address wallet,\r\n        uint    minInternval\r\n        )\r\n        external\r\n    {\r\n        if (wallets[wallet].inheritor != address(0) &&\r\n            block.timestamp > lastActive(wallet) + minInternval) {\r\n            requireWalletModule(wallet);\r\n            wallets[wallet].lastActive = uint64(block.timestamp);\r\n        }\r\n    }\r\n\r\n    function setInheritor(\r\n        address wallet,\r\n        address who,\r\n        uint32 _inheritWaitingPeriod\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        wallets[wallet].inheritor = who;\r\n        wallets[wallet].inheritWaitingPeriod = _inheritWaitingPeriod;\r\n        wallets[wallet].lastActive = uint64(block.timestamp);\r\n    }\r\n\r\n    function isLocked(address wallet)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return wallets[wallet].locked;\r\n    }\r\n\r\n    function lastActive(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return wallets[wallet].lastActive;\r\n    }\r\n\r\n    function inheritor(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            address _who,\r\n            uint    _effectiveTimestamp\r\n        )\r\n    {\r\n        address _inheritor = wallets[wallet].inheritor;\r\n        if (_inheritor == address(0)) {\r\n             return (address(0), 0);\r\n        }\r\n\r\n        uint32 _inheritWaitingPeriod = wallets[wallet].inheritWaitingPeriod;\r\n        if (_inheritWaitingPeriod == 0) {\r\n            return (address(0), 0);\r\n        }\r\n\r\n        uint64 _lastActive = wallets[wallet].lastActive;\r\n\r\n        if (_lastActive == 0) {\r\n            _lastActive = uint64(block.timestamp);\r\n        }\r\n\r\n        _who = _inheritor;\r\n        _effectiveTimestamp = _lastActive + _inheritWaitingPeriod;\r\n    }\r\n}\r\n\r\n// File: contracts/stores/WhitelistStore.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title WhitelistStore\r\n/// @dev This store maintains a wallet's whitelisted addresses.\r\ncontract WhitelistStore is DataStore, AddressSet, OwnerManagable\r\n{\r\n    bytes32 internal constant DAPPS = keccak256(\"__DAPPS__\");\r\n\r\n    // wallet => whitelisted_addr => effective_since\r\n    mapping(address => mapping(address => uint)) public effectiveTimeMap;\r\n\r\n    event Whitelisted(\r\n        address wallet,\r\n        address addr,\r\n        bool    whitelisted,\r\n        uint    effectiveTime\r\n    );\r\n\r\n    event DappWhitelisted(\r\n        address addr,\r\n        bool    whitelisted\r\n    );\r\n\r\n    constructor() DataStore() {}\r\n\r\n    function addToWhitelist(\r\n        address wallet,\r\n        address addr,\r\n        uint    effectiveTime\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        addAddressToSet(_walletKey(wallet), addr, true);\r\n        uint effective = effectiveTime >= block.timestamp ? effectiveTime : block.timestamp;\r\n        effectiveTimeMap[wallet][addr] = effective;\r\n        emit Whitelisted(wallet, addr, true, effective);\r\n    }\r\n\r\n    function removeFromWhitelist(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        external\r\n        onlyWalletModule(wallet)\r\n    {\r\n        removeAddressFromSet(_walletKey(wallet), addr);\r\n        delete effectiveTimeMap[wallet][addr];\r\n        emit Whitelisted(wallet, addr, false, 0);\r\n    }\r\n\r\n    function addDapp(address addr)\r\n        external\r\n        onlyManager\r\n    {\r\n        addAddressToSet(DAPPS, addr, true);\r\n        emit DappWhitelisted(addr, true);\r\n    }\r\n\r\n    function removeDapp(address addr)\r\n        external\r\n        onlyManager\r\n    {\r\n        removeAddressFromSet(DAPPS, addr);\r\n        emit DappWhitelisted(addr, false);\r\n    }\r\n\r\n    function whitelist(address wallet)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory addresses,\r\n            uint[]    memory effectiveTimes\r\n        )\r\n    {\r\n        addresses = addressesInSet(_walletKey(wallet));\r\n        effectiveTimes = new uint[](addresses.length);\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            effectiveTimes[i] = effectiveTimeMap[wallet][addresses[i]];\r\n        }\r\n    }\r\n\r\n    function isWhitelisted(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (\r\n            bool isWhitelistedAndEffective,\r\n            uint effectiveTime\r\n        )\r\n    {\r\n        effectiveTime = effectiveTimeMap[wallet][addr];\r\n        isWhitelistedAndEffective = effectiveTime > 0 && effectiveTime <= block.timestamp;\r\n    }\r\n\r\n    function whitelistSize(address wallet)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(_walletKey(wallet));\r\n    }\r\n\r\n    function dapps()\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory addresses\r\n        )\r\n    {\r\n        return addressesInSet(DAPPS);\r\n    }\r\n\r\n    function isDapp(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isAddressInSet(DAPPS, addr);\r\n    }\r\n\r\n    function numDapps()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return numAddressesInSet(DAPPS);\r\n    }\r\n\r\n    function isDappOrWhitelisted(\r\n        address wallet,\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool res)\r\n    {\r\n        (res,) = isWhitelisted(wallet, addr);\r\n        return res || isAddressInSet(DAPPS, addr);\r\n    }\r\n\r\n    function _walletKey(address addr)\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\"__WHITELIST__\", addr));\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/modules/ControllerImpl.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ControllerImpl\r\n/// @dev Basic implementation of a Controller.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract ControllerImpl is Claimable, Controller\r\n{\r\n    HashStore           public immutable hashStore;\r\n    QuotaStore          public immutable quotaStore;\r\n    SecurityStore       public immutable securityStore;\r\n    WhitelistStore      public immutable whitelistStore;\r\n    ModuleRegistry      public immutable override moduleRegistry;\r\n    address             public override  walletFactory;\r\n    address             public immutable feeCollector;\r\n    BaseENSManager      public immutable ensManager;\r\n    PriceOracle         public priceOracle;\r\n\r\n    event AddressChanged(\r\n        string   name,\r\n        address  addr\r\n    );\r\n\r\n    constructor(\r\n        HashStore         _hashStore,\r\n        QuotaStore        _quotaStore,\r\n        SecurityStore     _securityStore,\r\n        WhitelistStore    _whitelistStore,\r\n        ModuleRegistry    _moduleRegistry,\r\n        address           _feeCollector,\r\n        BaseENSManager    _ensManager,\r\n        PriceOracle       _priceOracle\r\n        )\r\n    {\r\n        hashStore = _hashStore;\r\n        quotaStore = _quotaStore;\r\n        securityStore = _securityStore;\r\n        whitelistStore = _whitelistStore;\r\n        moduleRegistry = _moduleRegistry;\r\n\r\n        require(_feeCollector != address(0), \"ZERO_ADDRESS\");\r\n        feeCollector = _feeCollector;\r\n\r\n        ensManager = _ensManager;\r\n        priceOracle = _priceOracle;\r\n    }\r\n\r\n    function initWalletFactory(address _walletFactory)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(walletFactory == address(0), \"INITIALIZED_ALREADY\");\r\n        require(_walletFactory != address(0), \"ZERO_ADDRESS\");\r\n        walletFactory = _walletFactory;\r\n        emit AddressChanged(\"WalletFactory\", walletFactory);\r\n    }\r\n\r\n    function setPriceOracle(PriceOracle _priceOracle)\r\n        external\r\n        onlyOwner\r\n    {\r\n        priceOracle = _priceOracle;\r\n        emit AddressChanged(\"PriceOracle\", address(priceOracle));\r\n    }\r\n}\r\n\r\n// File: contracts/modules/core/WalletFactory.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title WalletFactory\r\n/// @dev A factory contract to create a new wallet by deploying a proxy\r\n///      in front of a real wallet.\r\n///\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract WalletFactory\r\n{\r\n    using AddressUtil for address;\r\n    using SignatureUtil for bytes32;\r\n\r\n    event BlankDeployed (address blank,  bytes32 version);\r\n    event BlankConsumed (address blank);\r\n    event WalletCreated (address wallet, string ensLabel, address owner, bool blankUsed);\r\n\r\n    string public constant WALLET_CREATION = \"WALLET_CREATION\";\r\n\r\n    bytes32 public constant CREATE_WALLET_TYPEHASH = keccak256(\r\n        \"createWallet(address owner,uint256 salt,address blankAddress,string ensLabel,bool ensRegisterReverse,address[] modules)\"\r\n    );\r\n\r\n    mapping(address => bytes32) blanks;\r\n\r\n    bytes32             public immutable DOMAIN_SEPERATOR;\r\n    ControllerImpl      public immutable controller;\r\n    address             public immutable walletImplementation;\r\n    bool                public immutable allowEmptyENS; // MUST be false in production\r\n\r\n    BaseENSManager      public immutable ensManager;\r\n    address             public immutable ensResolver;\r\n    ENSReverseRegistrar public immutable ensReverseRegistrar;\r\n\r\n    constructor(\r\n        ControllerImpl _controller,\r\n        address        _walletImplementation,\r\n        bool           _allowEmptyENS\r\n        )\r\n    {\r\n        DOMAIN_SEPERATOR = EIP712.hash(\r\n            EIP712.Domain(\"WalletFactory\", \"1.2.0\", address(this))\r\n        );\r\n        controller = _controller;\r\n        walletImplementation = _walletImplementation;\r\n        allowEmptyENS = _allowEmptyENS;\r\n\r\n        BaseENSManager _ensManager = _controller.ensManager();\r\n        ensManager = _ensManager;\r\n        ensResolver = _ensManager.ensResolver();\r\n        ensReverseRegistrar = _ensManager.getENSReverseRegistrar();\r\n    }\r\n\r\n    /// @dev Create a set of new wallet blanks to be used in the future.\r\n    /// @param modules The wallet's modules.\r\n    /// @param salts The salts that can be used to generate nice addresses.\r\n    function createBlanks(\r\n        address[] calldata modules,\r\n        uint[]    calldata salts\r\n        )\r\n        external\r\n    {\r\n        for (uint i = 0; i < salts.length; i++) {\r\n            _createBlank(modules, salts[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Create a new wallet by deploying a proxy.\r\n    /// @param _owner The wallet's owner.\r\n    /// @param _salt A salt to adjust address.\r\n    /// @param _ensLabel The ENS subdomain to register, use \"\" to skip.\r\n    /// @param _ensApproval The signature for ENS subdomain approval.\r\n    /// @param _ensRegisterReverse True to register reverse ENS.\r\n    /// @param _modules The wallet's modules.\r\n    /// @param _signature The wallet owner's signature.\r\n    /// @return _wallet The new wallet address\r\n    function createWallet(\r\n        address            _owner,\r\n        uint               _salt,\r\n        string    calldata _ensLabel,\r\n        bytes     calldata _ensApproval,\r\n        bool               _ensRegisterReverse,\r\n        address[] calldata _modules,\r\n        bytes     calldata _signature\r\n        )\r\n        external\r\n        payable\r\n        returns (address _wallet)\r\n    {\r\n        _validateRequest(\r\n            _owner,\r\n            _salt,\r\n            address(0),\r\n            _ensLabel,\r\n            _ensRegisterReverse,\r\n            _modules,\r\n            _signature\r\n        );\r\n\r\n        _wallet = _deploy(_modules, _owner, _salt);\r\n\r\n        _initializeWallet(\r\n            _wallet,\r\n            _owner,\r\n            _ensLabel,\r\n            _ensApproval,\r\n            _ensRegisterReverse,\r\n            false\r\n        );\r\n    }\r\n\r\n    /// @dev Create a new wallet by using a pre-deployed blank.\r\n    /// @param _owner The wallet's owner.\r\n    /// @param _blank The address of the blank to use.\r\n    /// @param _ensLabel The ENS subdomain to register, use \"\" to skip.\r\n    /// @param _ensApproval The signature for ENS subdomain approval.\r\n    /// @param _ensRegisterReverse True to register reverse ENS.\r\n    /// @param _modules The wallet's modules.\r\n    /// @param _signature The wallet owner's signature.\r\n    /// @return _wallet The new wallet address\r\n    function createWallet2(\r\n        address            _owner,\r\n        address            _blank,\r\n        string    calldata _ensLabel,\r\n        bytes     calldata _ensApproval,\r\n        bool               _ensRegisterReverse,\r\n        address[] calldata _modules,\r\n        bytes     calldata _signature\r\n        )\r\n        external\r\n        payable\r\n        returns (address _wallet)\r\n    {\r\n        _validateRequest(\r\n            _owner,\r\n            0,\r\n            _blank,\r\n            _ensLabel,\r\n            _ensRegisterReverse,\r\n            _modules,\r\n            _signature\r\n        );\r\n\r\n        _wallet = _consumeBlank(_blank, _modules);\r\n\r\n        _initializeWallet(\r\n            _wallet,\r\n            _owner,\r\n            _ensLabel,\r\n            _ensApproval,\r\n            _ensRegisterReverse,\r\n            true\r\n        );\r\n    }\r\n\r\n    function registerENS(\r\n        address         _wallet,\r\n        address         _owner,\r\n        string calldata _ensLabel,\r\n        bytes  calldata _ensApproval,\r\n        bool            _ensRegisterReverse\r\n        )\r\n        external\r\n    {\r\n        _registerENS(_wallet, _owner, _ensLabel, _ensApproval, _ensRegisterReverse);\r\n    }\r\n\r\n    function computeWalletAddress(address owner, uint salt)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _computeAddress(owner, salt);\r\n    }\r\n\r\n    function computeBlankAddress(uint salt)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _computeAddress(address(0), salt);\r\n    }\r\n\r\n    function getWalletCreationCode()\r\n        public\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return CloneFactory.getByteCode(walletImplementation);\r\n    }\r\n\r\n    function _consumeBlank(\r\n        address blank,\r\n        address[] calldata modules\r\n        )\r\n        internal\r\n        returns (address)\r\n    {\r\n        bytes32 version = keccak256(abi.encode(modules));\r\n        require(blanks[blank] == version, \"INVALID_ADOBE\");\r\n        delete blanks[blank];\r\n        emit BlankConsumed(blank);\r\n        return blank;\r\n    }\r\n\r\n    function _createBlank(\r\n        address[] calldata modules,\r\n        uint      salt\r\n        )\r\n        internal\r\n        returns (address blank)\r\n    {\r\n        blank = _deploy(modules, address(0), salt);\r\n        bytes32 version = keccak256(abi.encode(modules));\r\n        blanks[blank] = version;\r\n\r\n        emit BlankDeployed(blank, version);\r\n    }\r\n\r\n    function _deploy(\r\n        address[] calldata modules,\r\n        address            owner,\r\n        uint               salt\r\n        )\r\n        internal\r\n        returns (address payable wallet)\r\n    {\r\n        wallet = Create2.deploy(\r\n            keccak256(abi.encodePacked(WALLET_CREATION, owner, salt)),\r\n            CloneFactory.getByteCode(walletImplementation)\r\n        );\r\n\r\n        BaseWallet(wallet).init(controller, modules);\r\n    }\r\n\r\n    function _validateRequest(\r\n        address            _owner,\r\n        uint               _salt,\r\n        address            _blankAddress,\r\n        string    memory   _ensLabel,\r\n        bool               _ensRegisterReverse,\r\n        address[] memory   _modules,\r\n        bytes     memory   _signature\r\n        )\r\n        private\r\n        view\r\n    {\r\n        require(_owner != address(0) && !_owner.isContract(), \"INVALID_OWNER\");\r\n        require(_modules.length > 0, \"EMPTY_MODULES\");\r\n\r\n        bytes memory encodedRequest = abi.encode(\r\n            CREATE_WALLET_TYPEHASH,\r\n            _owner,\r\n            _salt,\r\n            _blankAddress,\r\n            keccak256(bytes(_ensLabel)),\r\n            _ensRegisterReverse,\r\n            keccak256(abi.encode(_modules))\r\n        );\r\n\r\n        bytes32 signHash = EIP712.hashPacked(DOMAIN_SEPERATOR, encodedRequest);\r\n        require(signHash.verifySignature(_owner, _signature), \"INVALID_SIGNATURE\");\r\n    }\r\n\r\n    function _initializeWallet(\r\n        address       _wallet,\r\n        address       _owner,\r\n        string memory _ensLabel,\r\n        bytes  memory _ensApproval,\r\n        bool          _ensRegisterReverse,\r\n        bool          _blankUsed\r\n        )\r\n        private\r\n    {\r\n        BaseWallet(_wallet.toPayable()).initOwner(_owner);\r\n\r\n        if (bytes(_ensLabel).length > 0) {\r\n            _registerENS(_wallet, _owner, _ensLabel, _ensApproval, _ensRegisterReverse);\r\n        } else {\r\n            require(allowEmptyENS, \"EMPTY_ENS_NOT_ALLOWED\");\r\n        }\r\n\r\n        emit WalletCreated(_wallet, _ensLabel, _owner, _blankUsed);\r\n    }\r\n\r\n    function _computeAddress(\r\n        address owner,\r\n        uint    salt\r\n        )\r\n        private\r\n        view\r\n        returns (address)\r\n    {\r\n        return Create2.computeAddress(\r\n            keccak256(abi.encodePacked(WALLET_CREATION, owner, salt)),\r\n            CloneFactory.getByteCode(walletImplementation)\r\n        );\r\n    }\r\n\r\n    function _registerENS(\r\n        address       wallet,\r\n        address       owner,\r\n        string memory ensLabel,\r\n        bytes  memory ensApproval,\r\n        bool          ensRegisterReverse\r\n        )\r\n        private\r\n    {\r\n        require(\r\n            bytes(ensLabel).length > 0 &&\r\n            ensApproval.length > 0,\r\n            \"INVALID_LABEL_OR_SIGNATURE\"\r\n        );\r\n\r\n        ensManager.register(wallet, owner, ensLabel, ensApproval);\r\n\r\n        if (ensRegisterReverse) {\r\n            bytes memory data = abi.encodeWithSelector(\r\n                ENSReverseRegistrar.claimWithResolver.selector,\r\n                address(0), // the owner of the reverse record\r\n                ensResolver\r\n            );\r\n\r\n            Wallet(wallet).transact(\r\n                uint8(1),\r\n                address(ensReverseRegistrar),\r\n                0, // value\r\n                data\r\n            );\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ControllerImpl\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_walletImplementation\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowEmptyENS\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"blank\",\"type\":\"address\"}],\"name\":\"BlankConsumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"blank\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"version\",\"type\":\"bytes32\"}],\"name\":\"BlankDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ensLabel\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"blankUsed\",\"type\":\"bool\"}],\"name\":\"WalletCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CREATE_WALLET_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPERATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_CREATION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowEmptyENS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"computeBlankAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"computeWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract ControllerImpl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"salts\",\"type\":\"uint256[]\"}],\"name\":\"createBlanks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ensLabel\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_ensApproval\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_ensRegisterReverse\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"createWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_blank\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ensLabel\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_ensApproval\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_ensRegisterReverse\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"createWallet2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensManager\",\"outputs\":[{\"internalType\":\"contract BaseENSManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensReverseRegistrar\",\"outputs\":[{\"internalType\":\"contract ENSReverseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWalletCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ensLabel\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_ensApproval\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_ensRegisterReverse\",\"type\":\"bool\"}],\"name\":\"registerENS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WalletFactory","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000243614cd87ec957c144a9f52098e63256c13ee91000000000000000000000000e5857440bbff64c98ceb70d650805e1e96adde7a0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ca05a8eba57f81068a12520d7d21315b1ca5835a3fb16ea914a1d80122ec6e16"}]}