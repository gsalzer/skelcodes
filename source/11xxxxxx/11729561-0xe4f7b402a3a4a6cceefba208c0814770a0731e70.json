{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {DAI, ETH} from \\\"../../constants/CTokens.sol\\\";\\nimport {\\n    CONNECT_MAKER,\\n    CONNECT_AAVE_V2,\\n    CONNECT_BASIC,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodeDepositAave,\\n    _encodeBorrowAave\\n} from \\\"../../functions/InstaDapp/connectors/FConnectAave.sol\\\";\\nimport {\\n    _encodeCalculateFee\\n} from \\\"../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToAave,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    BDebtBridgeFromMaker\\n} from \\\"../../contracts/Instadapp/connectors/base/BDebtBridgeFromMaker.sol\\\";\\nimport {\\n    _encodeBasicWithdraw\\n} from \\\"../../functions/InstaDapp/connectors/FConnectBasic.sol\\\";\\nimport {IOracleAggregator} from \\\"../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../vendor/Convert.sol\\\";\\nimport {GELATO_EXECUTOR_MODULE} from \\\"../../constants/CGelato.sol\\\";\\n\\ncontract MockConnectGelatoDataMakerToAave is BDebtBridgeFromMaker {\\n    // solhint-disable const-name-snakecase\\n    string public constant override name =\\n        \\\"MockConnectGelatoDataMakerToAave-v1.0\\\";\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    )\\n        BDebtBridgeFromMaker(\\n            __id,\\n            _oracleAggregator,\\n            __instaFeeCollector,\\n            __connectGelatoDebtBridgeFee\\n        )\\n    {}\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _mockRoute mock route Id.\\n    /// @param _vaultId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _colToken  vault's col token address .\\n    function getDataAndCastMakerToAave(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _mockRoute\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToAave(_vaultId, _colToken, _mockRoute);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToAave(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _mockRoute\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\\n\\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\\n        route = _mockRoute;\\n\\n        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\\n            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\\n                _getGelatoExecutorFees(_getGasCostMakerToAave(route)),\\n                ETH,\\n                DAI\\n            );\\n\\n        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _spellsMakerToAave(\\n                _vaultId,\\n                _colToken,\\n                daiToBorrow,\\n                _getMakerVaultCollateralBalance(_vaultId),\\n                gasFeesPaidFromDebt\\n            );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            daiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToAave(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _daiDebtAmt,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](8);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_AAVE_V2; // deposit\\n        targets[4] = CONNECT_AAVE_V2; // borrow\\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\\n        targets[7] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](8);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodeDepositAave(_colToken, _colToWithdrawFromMaker, 0, 0);\\n        datas[4] = _encodeBorrowAave(DAI, 0, 2, 600, 0); // Variable rate by default.\\n        datas[5] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectInstaPoolV2 {\\n    function flashBorrowAndCast(\\n        address token,\\n        uint256 amt,\\n        uint256 route,\\n        bytes memory data\\n    ) external payable;\\n\\n    function flashPayback(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/IInstaFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IInstaFeeCollector {\\n    function setFeeCollector(address payable _feeCollector) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function fee() external view returns (uint256);\\n\\n    function feeCollector() external view returns (address payable);\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// ETH\\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n// USD\\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n\"\r\n    },\r\n    \"contracts/constants/CInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// InstaDapp\\naddress constant INSTA_MEMORY = 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F;\\n\\n// Connectors\\naddress constant CONNECT_MAKER = 0xac02030d8a8F49eD04b2f52C394D3F901A10F8A9;\\naddress constant CONNECT_COMPOUND = 0x15FdD1e902cAC70786fe7D31013B1a806764B5a2;\\naddress constant INSTA_POOL_V2 = 0xeB4bf86589f808f90EEC8e964dBF16Bd4D284905;\\naddress constant CONNECT_AAVE_V2 = 0xBF6E4331ffd02F7043e62788FD272aeFc712f5ee;\\naddress constant CONNECT_DYDX = 0x6AF6C791c869DfA65f8A2fa042fA47D1535Bef25;\\naddress constant CONNECT_BASIC = 0xe5398f279175962E56fE4c5E0b62dc7208EF36c6;\\naddress constant CONNECT_FEE = 0xB99152F8073033B318C1Bfbfaaa582029e982CE9;\\n\\n// Insta Pool\\naddress constant INSTA_POOL_RESOLVER = 0xa004a5afBa04b74037E9E52bA1f7eb02b5E61509;\\nuint256 constant ROUTE_1_TOLERANCE = 1005e15;\\n\\n// Insta Mapping\\naddress constant INSTA_MAPPING = 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88;\\n\\naddress constant INSTA_MAKER_RESOLVER = 0x0A7008B38E7015F8C36A49eEbc32513ECA8801E5;\\n\"\r\n    },\r\n    \"contracts/functions/dapps/FMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {MCD_MANAGER} from \\\"../../constants/CMaker.sol\\\";\\nimport {INSTA_MAPPING} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    ITokenJoinInterface\\n} from \\\"../../interfaces/dapps/Maker/ITokenJoinInterface.sol\\\";\\nimport {IMcdManager} from \\\"../../interfaces/dapps/Maker/IMcdManager.sol\\\";\\nimport {InstaMapping} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {IVat} from \\\"../../interfaces/dapps/Maker/IVat.sol\\\";\\nimport {RAY, add, sub, mul} from \\\"../../vendor/DSMath.sol\\\";\\nimport {_stringToBytes32, _convertTo18} from \\\"../../vendor/Convert.sol\\\";\\n\\nfunction _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n    uint256 dai = vat.dai(urn);\\n\\n    uint256 rad = sub(mul(art, rate), dai);\\n    wad = rad / RAY;\\n\\n    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\\n}\\n\\nfunction _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, , , ) = vat.ilks(ilk);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n\\n    uint256 rad = mul(art, rate);\\n\\n    tab = rad / RAY;\\n    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\\n}\\n\\nfunction _getMakerVaultCollateralBalance(uint256 _vaultId)\\n    view\\n    returns (uint256)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    IVat vat = IVat(manager.vat());\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    (uint256 ink, ) = vat.urns(ilk, urn);\\n\\n    return ink;\\n}\\n\\nfunction _vaultWillBeSafe(\\n    uint256 _vaultId,\\n    uint256 _colAmt,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    require(_vaultId != 0, \\\"_vaultWillBeSafe: invalid vault id.\\\");\\n\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n\\n    ITokenJoinInterface tokenJoinContract =\\n        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\\n\\n    IVat vat = IVat(manager.vat());\\n    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\\n    (uint256 ink, uint256 art) = vat.urns(ilk, urn);\\n    uint256 dai = vat.dai(urn);\\n\\n    uint256 dink = _convertTo18(tokenJoinContract.dec(), _colAmt);\\n    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\\n\\n    ink = add(ink, dink);\\n    art = add(art, dart);\\n\\n    uint256 tab = mul(rate, art);\\n\\n    return tab <= mul(ink, spot);\\n}\\n\\nfunction _newVaultWillBeSafe(\\n    string memory _colType,\\n    uint256 _colAmt,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n    IVat vat = IVat(manager.vat());\\n\\n    bytes32 ilk = _stringToBytes32(_colType);\\n\\n    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\\n\\n    ITokenJoinInterface tokenJoinContract =\\n        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\\n\\n    uint256 ink = _convertTo18(tokenJoinContract.dec(), _colAmt);\\n    uint256 art = _getDebtAmt(_daiDebtAmt, 0, rate);\\n\\n    uint256 tab = mul(rate, art);\\n\\n    return tab <= mul(ink, spot);\\n}\\n\\nfunction _debtCeilingIsReachedNewVault(\\n    string memory _colType,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n    IVat vat = IVat(manager.vat());\\n\\n    bytes32 ilk = _stringToBytes32(_colType);\\n\\n    (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\\n    uint256 Line = vat.Line();\\n    uint256 debt = vat.debt();\\n\\n    uint256 dart = _getDebtAmt(_daiDebtAmt, 0, rate);\\n    uint256 dtab = mul(rate, dart);\\n\\n    debt = add(debt, dtab);\\n    Art = add(Art, dart);\\n\\n    return mul(Art, rate) > line || debt > Line;\\n}\\n\\nfunction _debtCeilingIsReached(uint256 _vaultId, uint256 _daiDebtAmt)\\n    view\\n    returns (bool)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n    IVat vat = IVat(manager.vat());\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n\\n    (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\\n    uint256 dai = vat.dai(urn);\\n    uint256 Line = vat.Line();\\n    uint256 debt = vat.debt();\\n\\n    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\\n    uint256 dtab = mul(rate, dart);\\n\\n    debt = add(debt, dtab);\\n    Art = add(Art, dart);\\n\\n    return mul(Art, rate) > line || debt > Line;\\n}\\n\\nfunction _debtIsDustNewVault(string memory _colType, uint256 _daiDebtAmt)\\n    view\\n    returns (bool)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n    IVat vat = IVat(manager.vat());\\n\\n    bytes32 ilk = _stringToBytes32(_colType);\\n\\n    (, uint256 rate, , , uint256 dust) = vat.ilks(ilk);\\n    uint256 art = _getDebtAmt(_daiDebtAmt, 0, rate);\\n\\n    uint256 tab = mul(rate, art);\\n\\n    return tab < dust;\\n}\\n\\nfunction _debtIsDust(uint256 _vaultId, uint256 _daiDebtAmt)\\n    view\\n    returns (bool)\\n{\\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\\n    IVat vat = IVat(manager.vat());\\n\\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\\n    (, uint256 art) = vat.urns(ilk, urn);\\n    (, uint256 rate, , , uint256 dust) = vat.ilks(ilk);\\n\\n    uint256 dai = vat.dai(urn);\\n    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\\n    art = add(art, dart);\\n    uint256 tab = mul(rate, art);\\n\\n    return tab < dust;\\n}\\n\\nfunction _getVaultData(IMcdManager _manager, uint256 _vault)\\n    view\\n    returns (bytes32 ilk, address urn)\\n{\\n    ilk = _manager.ilks(_vault);\\n    urn = _manager.urns(_vault);\\n}\\n\\nfunction _getDebtAmt(\\n    uint256 _amt,\\n    uint256 _dai,\\n    uint256 _rate\\n) pure returns (uint256 dart) {\\n    dart = sub(mul(_amt, RAY), _dai) / _rate;\\n    dart = mul(dart, _rate) < mul(_amt, RAY) ? dart + 1 : dart;\\n}\\n\\nfunction _isVaultOwner(uint256 _vaultId, address _owner) view returns (bool) {\\n    if (_vaultId == 0) return false;\\n\\n    try IMcdManager(MCD_MANAGER).owns(_vaultId) returns (address owner) {\\n        return _owner == owner;\\n    } catch Error(string memory error) {\\n        revert(string(abi.encodePacked(\\\"FMaker._isVaultOwner:\\\", error)));\\n    } catch {\\n        revert(\\\"FMaker._isVaultOwner:undefined\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FInstaPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\n\\nfunction _encodeFlashPayback(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashPayback.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectMaker\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectMaker.sol\\\";\\n\\nfunction _encodeOpenMakerVault(string memory _colType)\\n    pure\\n    returns (bytes memory)\\n{\\n    return abi.encodeWithSelector(IConnectMaker.open.selector, _colType);\\n}\\n\\nfunction _encodeBorrowMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.borrow.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodedDepositMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.deposit.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodePaybackMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.payback.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodedWithdrawMakerVault(\\n    uint256 _vaultId,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectMaker.withdraw.selector,\\n            _vaultId,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectAave\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectAave.sol\\\";\\n\\nfunction _encodeDepositAave(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectAave.deposit.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodeBorrowAave(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _rateMode, // 1 for Stable and 2 for variable\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectAave.borrow.selector,\\n            _token,\\n            _amt,\\n            _rateMode,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectDebtBridgeFee\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectDebtBridgeFee.sol\\\";\\n\\nfunction _encodeCalculateFee(\\n    uint256 _amount,\\n    uint256 _ftf,\\n    uint256 _fee,\\n    uint256 _getId,\\n    uint256 _setId,\\n    uint256 _setIdFee\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectDebtBridgeFee.calculateFee.selector,\\n            _amount,\\n            _ftf,\\n            _fee,\\n            _getId,\\n            _setId,\\n            _setIdFee\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/FGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {GELATO_GAS_PRICE_ORACLE} from \\\"../../constants/CGelato.sol\\\";\\nimport {mul} from \\\"../../vendor/DSMath.sol\\\";\\n\\nfunction _getGelatoGasPrice() view returns (uint256) {\\n    int256 oracleGasPrice = GELATO_GAS_PRICE_ORACLE.latestAnswer();\\n    if (oracleGasPrice <= 0) revert(\\\"_getGelatoGasPrice:0orBelow\\\");\\n    return uint256(oracleGasPrice);\\n}\\n\\nfunction _getGelatoExecutorFees(uint256 _gas) view returns (uint256) {\\n    return mul(_gas, _getGelatoGasPrice());\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/FGelatoDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {wmul, wdiv} from \\\"../../vendor/DSMath.sol\\\";\\nimport {\\n    INSTA_POOL_RESOLVER,\\n    ROUTE_1_TOLERANCE\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {DebtBridgeInputData} from \\\"../../structs/SDebtBridge.sol\\\";\\nimport {\\n    _canDoMakerToAaveDebtBridge,\\n    _canDoMakerToMakerDebtBridge,\\n    _canDoMakerToCompoundDebtBridge\\n} from \\\"./conditions/FCanDoRefinance.sol\\\";\\nimport {\\n    PROTOCOL,\\n    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER,\\n    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND,\\n    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE,\\n    FAST_TX_FEE,\\n    VAULT_CREATION_COST\\n} from \\\"../../constants/CDebtBridge.sol\\\";\\nimport {\\n    IInstaPoolResolver\\n} from \\\"../../interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\\\";\\nimport {_getMakerVaultDebt} from \\\"../dapps/FMaker.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"./FGelato.sol\\\";\\nimport {DAI, ETH} from \\\"../../constants/CTokens.sol\\\";\\nimport {IOracleAggregator} from \\\"../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../vendor/Convert.sol\\\";\\n\\nfunction _getFlashLoanRoute(address _debtToken, uint256 _debtAmt)\\n    view\\n    returns (uint256)\\n{\\n    IInstaPoolResolver.RouteData memory rData =\\n        IInstaPoolResolver(INSTA_POOL_RESOLVER).getTokenLimit(_debtToken);\\n\\n    if (rData.dydx > _debtAmt) return 0;\\n    if (rData.maker > _debtAmt) return 1;\\n    if (rData.compound > _debtAmt) return 2;\\n    if (rData.aave > _debtAmt) return 3;\\n    revert(\\\"FGelatoDebtBridge._getFlashLoanRoute: illiquid\\\");\\n}\\n\\nfunction _getDebtBridgeRoute(DebtBridgeInputData memory _data)\\n    view\\n    returns (PROTOCOL)\\n{\\n    if (_canDoMakerToAaveDebtBridge(_data)) return PROTOCOL.AAVE;\\n    else if (_canDoMakerToMakerDebtBridge(_data)) return PROTOCOL.MAKER;\\n    else if (_canDoMakerToCompoundDebtBridge(_data)) return PROTOCOL.COMPOUND;\\n    return PROTOCOL.NONE;\\n}\\n\\nfunction _getGasCostMakerToMaker(bool _newVault, uint256 _route)\\n    pure\\n    returns (uint256)\\n{\\n    _checkRouteIndex(\\n        _route,\\n        \\\"FGelatoDebtBridge._getGasCostMakerToMaker: invalid route index\\\"\\n    );\\n    return\\n        _getGasCostPremium(\\n            _newVault\\n                ? GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()[_route] +\\n                    VAULT_CREATION_COST\\n                : GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()[_route]\\n        );\\n}\\n\\nfunction _getGasCostMakerToCompound(uint256 _route) pure returns (uint256) {\\n    _checkRouteIndex(\\n        _route,\\n        \\\"FGelatoDebtBridge._getGasCostMakerToCompound: invalid route index\\\"\\n    );\\n    return\\n        _getGasCostPremium(\\n            GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND()[_route]\\n        );\\n}\\n\\nfunction _getGasCostMakerToAave(uint256 _route) pure returns (uint256) {\\n    _checkRouteIndex(\\n        _route,\\n        \\\"FGelatoDebtBridge._getGasCostMakerToAave: invalid route index\\\"\\n    );\\n    return\\n        _getGasCostPremium(\\n            GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE()[_route]\\n        );\\n}\\n\\nfunction _getGasCostPremium(uint256 _rawGasCost) pure returns (uint256) {\\n    return (_rawGasCost * (100 + FAST_TX_FEE)) / 100;\\n}\\n\\nfunction _getRealisedDebt(uint256 _debtToMove) pure returns (uint256) {\\n    return wmul(_debtToMove, ROUTE_1_TOLERANCE);\\n}\\n\\nfunction _checkRouteIndex(uint256 _route, string memory _revertMsg) pure {\\n    require(_route <= 4, _revertMsg);\\n}\\n\\nfunction _getMaxAmtToBorrowMakerToAave(\\n    uint256 _fromVaultId,\\n    uint256 _fees,\\n    address _oracleAggregator\\n) view returns (uint256) {\\n    uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\\n\\n    return\\n        _getMaxAmtToBorrow(\\n            wDaiToBorrow,\\n            _getGasCostMakerToAave(_getFlashLoanRoute(DAI, wDaiToBorrow)),\\n            _fees,\\n            _oracleAggregator\\n        );\\n}\\n\\nfunction _getMaxAmtToBorrowMakerToCompound(\\n    uint256 _fromVaultId,\\n    uint256 _fees,\\n    address _oracleAggregator\\n) view returns (uint256) {\\n    uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\\n\\n    return\\n        _getMaxAmtToBorrow(\\n            wDaiToBorrow,\\n            _getGasCostMakerToCompound(_getFlashLoanRoute(DAI, wDaiToBorrow)),\\n            _fees,\\n            _oracleAggregator\\n        );\\n}\\n\\nfunction _getMaxAmtToBorrowMakerToMaker(\\n    uint256 _fromVaultId,\\n    bool _newVault,\\n    uint256 _fees,\\n    address _oracleAggregator\\n) view returns (uint256) {\\n    uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\\n\\n    return\\n        _getMaxAmtToBorrow(\\n            wDaiToBorrow,\\n            _getGasCostMakerToMaker(\\n                _newVault,\\n                _getFlashLoanRoute(DAI, wDaiToBorrow)\\n            ),\\n            _fees,\\n            _oracleAggregator\\n        );\\n}\\n\\nfunction _getMaxAmtToBorrow(\\n    uint256 _wDaiToBorrow,\\n    uint256 _gasCost,\\n    uint256 _fees,\\n    address _oracleAggregator\\n) view returns (uint256) {\\n    (uint256 gasCostInDAI, uint256 decimals) =\\n        IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\\n            _getGelatoExecutorFees(_gasCost),\\n            ETH,\\n            DAI\\n        );\\n\\n    gasCostInDAI = _convertTo18(decimals, gasCostInDAI);\\n\\n    return _wDaiToBorrow + gasCostInDAI + wmul(_wDaiToBorrow, _fees);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/base/BDebtBridgeFromMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    DataFlow\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    _isVaultOwner,\\n    _getMakerVaultDebt\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\n\\nabstract contract BDebtBridgeFromMaker is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    string public constant OK = \\\"OK\\\";\\n    uint256 internal immutable _id;\\n    address public immutable oracleAggregator;\\n    address public immutable instaFeeCollector;\\n    address public immutable connectGelatoDataFromMakerAddr;\\n    address internal immutable _connectGelatoDebtBridgeFee;\\n\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    ) {\\n        _id = __id;\\n        oracleAggregator = _oracleAggregator;\\n        instaFeeCollector = __instaFeeCollector;\\n        _connectGelatoDebtBridgeFee = __connectGelatoDebtBridgeFee;\\n        connectGelatoDataFromMakerAddr = address(this);\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    // ====== ACTION TERMS CHECK ==========\\n    // Overriding IGelatoAction's function (optional)\\n    function termsOk(\\n        uint256, // taskReceipId\\n        address _dsa,\\n        bytes calldata _actionData,\\n        DataFlow,\\n        uint256, // value\\n        uint256 // cycleId\\n    ) public view returns (string memory) {\\n        uint256 vaultId = abi.decode(_actionData[4:36], (uint256));\\n\\n        if (vaultId == 0)\\n            return\\n                string(\\n                    abi.encodePacked(this.name(), \\\": Vault Id is not valid\\\")\\n                );\\n        if (!_isVaultOwner(vaultId, _dsa))\\n            return\\n                string(\\n                    abi.encodePacked(this.name(), \\\": Vault not owned by dsa\\\")\\n                );\\n        return OK;\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData =\\n            abi.encodeWithSelector(\\n                AccountInterface.cast.selector,\\n                targets,\\n                datas,\\n                msg.sender // msg.sender == GelatoCore\\n            );\\n\\n        (bool success, bytes memory returndata) =\\n            address(this).delegatecall(castData);\\n        if (!success) {\\n            returndata.revertWithError(\\n                string(\\n                    abi.encodePacked(\\n                        ConnectorInterface(connectGelatoDataFromMakerAddr)\\n                            .name(),\\n                        \\\"._cast:\\\"\\n                    )\\n                )\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectBasic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectBasic\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectBasic.sol\\\";\\n\\nfunction _encodeBasicWithdraw(\\n    address _erc20,\\n    uint256 _tokenAmt,\\n    address payable _to,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectBasic.withdraw.selector,\\n            _erc20,\\n            _tokenAmt,\\n            _to,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/gelato/IOracleAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IOracleAggregator {\\n    function getExpectedReturnAmount(\\n        uint256 amountIn,\\n        address inToken,\\n        address outToken\\n    ) external view returns (uint256 returnAmount, uint256 outTokenDecimals);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/Convert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {mul as _mul} from \\\"./DSMath.sol\\\";\\n\\nfunction _stringToBytes32(string memory str) pure returns (bytes32 result) {\\n    require(bytes(str).length != 0, \\\"string-empty\\\");\\n    assembly {\\n        result := mload(add(str, 32))\\n    }\\n}\\n\\nfunction _convertTo18(uint256 _dec, uint256 _amt) pure returns (uint256 amt) {\\n    amt = _mul(_amt, 10**(18 - _dec));\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IGelatoGasPriceOracle\\n} from \\\"../interfaces/gelato/IGelatoGasPriceOracle.sol\\\";\\n\\nIGelatoGasPriceOracle constant GELATO_GAS_PRICE_ORACLE = IGelatoGasPriceOracle(\\n    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\\n);\\n\\naddress constant GELATO_EXECUTOR_MODULE = 0x98edc8067Cc671BCAE82D36dCC609C3E4e078AC8;\\n\"\r\n    },\r\n    \"contracts/constants/CMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\naddress constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\\naddress constant JUG = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/ITokenJoinInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface ITokenJoinInterface {\\n    function dec() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IMcdManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IMcdManager {\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function vat() external view returns (address);\\n\\n    function owns(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/IInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n/// @notice Interface InstaDapp Index\\ninterface IndexInterface {\\n    function connectors(uint256 version) external view returns (address);\\n\\n    function list() external view returns (address);\\n}\\n\\n/// @notice Interface InstaDapp List\\ninterface ListInterface {\\n    function accountID(address _account) external view returns (uint64);\\n}\\n\\n/// @notice Interface InstaDapp InstaMemory\\ninterface MemoryInterface {\\n    function setUint(uint256 _id, uint256 _val) external;\\n\\n    function getUint(uint256 _id) external returns (uint256);\\n}\\n\\n/// @notice Interface InstaDapp Defi Smart Account wallet\\ninterface AccountInterface {\\n    function cast(\\n        address[] calldata _targets,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32[] memory responses);\\n\\n    function version() external view returns (uint256);\\n\\n    function isAuth(address user) external view returns (bool);\\n\\n    function shield() external view returns (bool);\\n}\\n\\ninterface ConnectorInterface {\\n    function connectorID() external view returns (uint256 _type, uint256 _id);\\n\\n    function name() external view returns (string memory);\\n}\\n\\ninterface InstaMapping {\\n    function gemJoinMapping(bytes32) external view returns (address);\\n\\n    function cTokenMapping(address) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IVat {\\n    function ilks(bytes32)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function dai(address) external view returns (uint256);\\n\\n    function urns(bytes32, address) external view returns (uint256, uint256);\\n\\n    function debt() external view returns (uint256);\\n\\n    // solhint-disable-next-line\\n    function Line() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: AGPL-3.0-or-later\\\"\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.0;\\n\\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\n\\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\n\\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nfunction imin(int256 x, int256 y) pure returns (int256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction imax(int256 x, int256 y) pure returns (int256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint256 constant WAD = 10**18;\\nuint256 constant RAY = 10**27;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, y), WAD / 2) / WAD;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction rmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, y), RAY / 2) / RAY;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, WAD), y / 2) / y;\\n}\\n\\n//rounds to zero if x*y < RAY / 2\\nfunction rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = add(mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction rpow(uint256 x, uint256 n) pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = rmul(z, x);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectMaker {\\n    function payback(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function borrow(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function open(string calldata colType)\\n        external\\n        payable\\n        returns (uint256 vault);\\n\\n    function withdraw(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        uint256 vault,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectAave {\\n    function borrow(\\n        address token,\\n        uint256 amt,\\n        uint256 _rateMode,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectDebtBridgeFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectDebtBridgeFee {\\n    function calculateFee(\\n        uint256 _amount,\\n        uint256 _ftf,\\n        uint256 _fee,\\n        uint256 _getId,\\n        uint256 _setId,\\n        uint256 _setIdFee\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/gelato/IGelatoGasPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IGelatoGasPriceOracle {\\n    function latestAnswer() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nstruct DebtBridgeInputData {\\n    address dsa;\\n    uint256 colAmt;\\n    address colToken;\\n    uint256 debtAmt;\\n    address oracleAggregator;\\n    uint256 makerDestVaultId;\\n    string makerDestColType;\\n    uint256 fees;\\n    uint256 flashRoute;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/FCanDoRefinance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {_isAaveLiquid} from \\\"./aave/FAaveHasLiquidity.sol\\\";\\nimport {_aavePositionWillBeSafe} from \\\"./aave/FAavePositionWillBeSafe.sol\\\";\\nimport {_isDebtAmtDust} from \\\"./maker/FIsDebtAmtDust.sol\\\";\\nimport {_isDebtCeilingReached} from \\\"./maker/FDebtCeilingIsReached.sol\\\";\\nimport {_destVaultWillBeSafe} from \\\"./maker/FDestVaultWillBeSafe.sol\\\";\\nimport {_cTokenHasLiquidity} from \\\"./compound/FCompoundHasLiquidity.sol\\\";\\nimport {\\n    _compoundPositionWillBeSafe\\n} from \\\"./compound/FCompoundPositionWillBeSafe.sol\\\";\\nimport {DebtBridgeInputData} from \\\"../../../structs/SDebtBridge.sol\\\";\\nimport {DAI} from \\\"../../../constants/CTokens.sol\\\";\\nimport {\\n    _getMaxAmtToBorrow,\\n    _getGasCostMakerToAave,\\n    _getGasCostMakerToCompound,\\n    _getGasCostMakerToMaker\\n} from \\\"../FGelatoDebtBridge.sol\\\";\\n\\nfunction _canDoMakerToAaveDebtBridge(DebtBridgeInputData memory _data)\\n    view\\n    returns (bool)\\n{\\n    _data.debtAmt = _getMaxAmtToBorrow(\\n        _data.debtAmt,\\n        _getGasCostMakerToAave(_data.flashRoute),\\n        _data.fees,\\n        _data.oracleAggregator\\n    );\\n    return\\n        _isAaveLiquid(DAI, _data.debtAmt) &&\\n        _aavePositionWillBeSafe(\\n            _data.dsa,\\n            _data.colAmt,\\n            _data.colToken,\\n            _data.debtAmt,\\n            _data.oracleAggregator\\n        );\\n}\\n\\nfunction _canDoMakerToMakerDebtBridge(DebtBridgeInputData memory _data)\\n    view\\n    returns (bool)\\n{\\n    _data.debtAmt = _getMaxAmtToBorrow(\\n        _data.debtAmt,\\n        _getGasCostMakerToMaker(_data.makerDestVaultId == 0, _data.flashRoute),\\n        _data.fees,\\n        _data.oracleAggregator\\n    );\\n    return\\n        !_isDebtAmtDust(\\n            _data.dsa,\\n            _data.makerDestVaultId,\\n            _data.makerDestColType,\\n            _data.debtAmt\\n        ) &&\\n        !_isDebtCeilingReached(\\n            _data.dsa,\\n            _data.makerDestVaultId,\\n            _data.makerDestColType,\\n            _data.debtAmt\\n        ) &&\\n        _destVaultWillBeSafe(\\n            _data.dsa,\\n            _data.makerDestVaultId,\\n            _data.makerDestColType,\\n            _data.colAmt,\\n            _data.debtAmt\\n        );\\n}\\n\\nfunction _canDoMakerToCompoundDebtBridge(DebtBridgeInputData memory _data)\\n    view\\n    returns (bool)\\n{\\n    _data.debtAmt = _getMaxAmtToBorrow(\\n        _data.debtAmt,\\n        _getGasCostMakerToCompound(_data.flashRoute),\\n        _data.fees,\\n        _data.oracleAggregator\\n    );\\n    return\\n        _cTokenHasLiquidity(DAI, _data.debtAmt) &&\\n        _compoundPositionWillBeSafe(\\n            _data.dsa,\\n            _data.colAmt,\\n            DAI,\\n            _data.debtAmt\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nenum PROTOCOL {AAVE, MAKER, COMPOUND, NONE}\\n\\nfunction GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()\\n    pure\\n    returns (uint256[4] memory)\\n{\\n    return [uint256(2519000), 3140500, 3971000, 4345000];\\n}\\n\\nfunction GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND()\\n    pure\\n    returns (uint256[4] memory)\\n{\\n    return [uint256(2028307), 2626711, 2944065, 3698800];\\n}\\n\\nfunction GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE()\\n    pure\\n    returns (uint256[4] memory)\\n{\\n    return [uint256(2358534), 2956937, 3381960, 4029400];\\n}\\n\\nuint256 constant FAST_TX_FEE = 30;\\nuint256 constant VAULT_CREATION_COST = 200000;\\nuint256 constant MAX_INSTA_FEE = 3e15;\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.8.0;\\n\\ninterface IInstaPoolResolver {\\n    struct RouteData {\\n        uint256 dydx;\\n        uint256 maker;\\n        uint256 compound;\\n        uint256 aave;\\n    }\\n\\n    function getTokenLimit(address token)\\n        external\\n        view\\n        returns (RouteData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/aave/FAaveHasLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {IERC20} from \\\"../../../../interfaces/dapps/IERC20.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {ILendingPool} from \\\"../../../../interfaces/dapps/Aave/ILendingPool.sol\\\";\\nimport {LENDING_POOL_ADDRESSES_PROVIDER} from \\\"../../../../constants/CAave.sol\\\";\\nimport {\\n    _getRealisedDebt\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {_getMakerVaultDebt} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\n\\nfunction _isAaveLiquid(address _debtToken, uint256 _debtAmt)\\n    view\\n    returns (bool)\\n{\\n    return\\n        IERC20(_debtToken).balanceOf(\\n            ILendingPool(\\n                ILendingPoolAddressesProvider(LENDING_POOL_ADDRESSES_PROVIDER)\\n                    .getLendingPool()\\n            )\\n                .getReserveData(_debtToken)\\n                .aTokenAddress\\n        ) > _debtAmt;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/aave/FAavePositionWillBeSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _getUserData,\\n    _getAssetLiquidationThreshold\\n} from \\\"../../../../functions/dapps/FAave.sol\\\";\\nimport {AaveUserData} from \\\"../../../../structs/SAave.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {wdiv, wmul, mul} from \\\"../../../../vendor/DSMath.sol\\\";\\nimport {\\n    IOracleAggregator\\n} from \\\"../../../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {ETH, DAI} from \\\"../../../../constants/CTokens.sol\\\";\\nimport {_convertTo18} from \\\"../../../../vendor/Convert.sol\\\";\\n\\nfunction _aavePositionWillBeSafe(\\n    address _dsa,\\n    uint256 _colAmt,\\n    address _colToken,\\n    uint256 _debtAmt,\\n    address _oracleAggregator\\n) view returns (bool) {\\n    uint256 _colAmtInETH;\\n    uint256 _decimals;\\n    IOracleAggregator oracleAggregator = IOracleAggregator(_oracleAggregator);\\n\\n    AaveUserData memory userData = _getUserData(_dsa);\\n\\n    if (_colToken == ETH) _colAmtInETH = _colAmt;\\n    else {\\n        (_colAmtInETH, _decimals) = oracleAggregator.getExpectedReturnAmount(\\n            _colAmt,\\n            _colToken,\\n            ETH\\n        );\\n\\n        _colAmtInETH = _convertTo18(_decimals, _colAmtInETH);\\n    }\\n\\n    (_debtAmt, _decimals) = oracleAggregator.getExpectedReturnAmount(\\n        _debtAmt,\\n        DAI,\\n        ETH\\n    );\\n    _debtAmt = _convertTo18(_decimals, _debtAmt);\\n\\n    //\\n    //                  __\\n    //                  \\\\\\n    //                  /__ (Collateral)i in ETH x (Liquidation Threshold)i\\n    //  HealthFactor =  _________________________________________________\\n    //\\n    //                  Total Borrows in ETH + Total Fees in ETH\\n    //\\n\\n    return\\n        wdiv(\\n            (\\n                (mul(\\n                    userData.currentLiquidationThreshold,\\n                    userData.totalCollateralETH\\n                ) + mul(_colAmtInETH, _getAssetLiquidationThreshold(_colToken)))\\n            ) / 1e4,\\n            userData.totalBorrowsETH + _debtAmt\\n        ) > 1e18;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/maker/FIsDebtAmtDust.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _debtIsDustNewVault,\\n    _debtIsDust,\\n    _isVaultOwner\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\n\\nfunction _isDebtAmtDust(\\n    address _dsa,\\n    uint256 _destVaultId,\\n    string memory _destColType,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\\n\\n    return _isDebtAmtDustExplicit(_destVaultId, _destColType, _daiDebtAmt);\\n}\\n\\nfunction _isDebtAmtDustExplicit(\\n    uint256 _destVaultId,\\n    string memory _destColType,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    return\\n        _destVaultId == 0\\n            ? _debtIsDustNewVault(_destColType, _daiDebtAmt)\\n            : _debtIsDust(_destVaultId, _daiDebtAmt);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/maker/FDebtCeilingIsReached.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _debtCeilingIsReachedNewVault,\\n    _debtCeilingIsReached,\\n    _isVaultOwner\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\n\\nfunction _isDebtCeilingReached(\\n    address _dsa,\\n    uint256 _destVaultId,\\n    string memory _destColType,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\\n\\n    return\\n        _debtCeilingIsReachedExplicit(_destVaultId, _destColType, _daiDebtAmt);\\n}\\n\\nfunction _debtCeilingIsReachedExplicit(\\n    uint256 _destVaultId,\\n    string memory _destColType,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    return\\n        _destVaultId == 0\\n            ? _debtCeilingIsReachedNewVault(_destColType, _daiDebtAmt)\\n            : _debtCeilingIsReached(_destVaultId, _daiDebtAmt);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/maker/FDestVaultWillBeSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _vaultWillBeSafe,\\n    _newVaultWillBeSafe,\\n    _isVaultOwner\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\n\\nfunction _destVaultWillBeSafe(\\n    address _dsa,\\n    uint256 _destVaultId,\\n    string memory _destColType,\\n    uint256 _colAmt,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\\n\\n    return\\n        _destVaultWillBeSafeExplicit(\\n            _destVaultId,\\n            _destColType,\\n            _colAmt,\\n            _daiDebtAmt\\n        );\\n}\\n\\nfunction _destVaultWillBeSafeExplicit(\\n    uint256 _destVaultId,\\n    string memory _destColType,\\n    uint256 _colAmt,\\n    uint256 _daiDebtAmt\\n) view returns (bool) {\\n    return\\n        _destVaultId == 0\\n            ? _newVaultWillBeSafe(_destColType, _colAmt, _daiDebtAmt)\\n            : _vaultWillBeSafe(_destVaultId, _colAmt, _daiDebtAmt);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/compound/FCompoundHasLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {ICToken} from \\\"../../../../interfaces/dapps/Compound/ICToken.sol\\\";\\nimport {_getCToken} from \\\"../../../dapps/FCompound.sol\\\";\\n\\nfunction _cTokenHasLiquidity(address _debtToken, uint256 _debtAmt)\\n    view\\n    returns (bool)\\n{\\n    return ICToken(_getCToken(_debtToken)).getCash() > _debtAmt;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/compound/FCompoundPositionWillBeSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {DAI} from \\\"../../../../constants/CTokens.sol\\\";\\nimport {\\n    _getCToken,\\n    _wouldCompoundAccountBeLiquid\\n} from \\\"../../../dapps/FCompound.sol\\\";\\n\\nfunction _compoundPositionWillBeSafe(\\n    address _dsa,\\n    uint256 _colAmt,\\n    address _debtToken,\\n    uint256 _debtAmt\\n) view returns (bool) {\\n    return\\n        _wouldCompoundAccountBeLiquid(\\n            _dsa,\\n            _colAmt,\\n            _getCToken(_debtToken),\\n            _debtAmt\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface ILendingPoolAddressesProvider {\\n    function getLendingPool() external view returns (address);\\n\\n    function getPriceOracle() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {ReserveData} from \\\"../../../structs/SAave.sol\\\";\\n\\ninterface ILendingPool {\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (ReserveData memory);\\n\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralETH,\\n            uint256 totalDebtETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    function getReservesList() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// Aave Lending Pool Addresses Provider\\naddress constant LENDING_POOL_ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\\naddress constant CHAINLINK_ETH_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\\naddress constant AAVE_PROTOCOL_DATA_PROVIDER = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;\\n\"\r\n    },\r\n    \"contracts/structs/SAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// ////////// LendingPool /////////////////\\nstruct AaveUserData {\\n    uint256 totalCollateralETH;\\n    uint256 totalBorrowsETH;\\n    uint256 availableBorrowsETH;\\n    uint256 currentLiquidationThreshold;\\n    uint256 ltv;\\n    uint256 healthFactor;\\n    uint256 ethPriceInUsd;\\n}\\n\\nstruct ReserveConfigurationMap {\\n    uint256 data;\\n}\\n\\nstruct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/dapps/FAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IAaveProtocolDataProvider\\n} from \\\"../../interfaces/dapps/Aave/IAaveProtocolDataProvider.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    ChainLinkInterface\\n} from \\\"../../interfaces/dapps/Aave/ChainLinkInterface.sol\\\";\\nimport {ILendingPool} from \\\"../../interfaces/dapps/Aave/ILendingPool.sol\\\";\\nimport {WETH, ETH} from \\\"../../constants/CTokens.sol\\\";\\nimport {AaveUserData} from \\\"../../structs/SAave.sol\\\";\\nimport {\\n    LENDING_POOL_ADDRESSES_PROVIDER,\\n    CHAINLINK_ETH_FEED,\\n    AAVE_PROTOCOL_DATA_PROVIDER\\n} from \\\"../../constants/CAave.sol\\\";\\nimport {ETH, WETH} from \\\"../../constants/CTokens.sol\\\";\\n\\nfunction _getEtherPrice() view returns (uint256 ethPrice) {\\n    ethPrice = uint256(ChainLinkInterface(CHAINLINK_ETH_FEED).latestAnswer());\\n}\\n\\nfunction _getUserData(address user)\\n    view\\n    returns (AaveUserData memory userData)\\n{\\n    (\\n        uint256 totalCollateralETH,\\n        uint256 totalDebtETH,\\n        uint256 availableBorrowsETH,\\n        uint256 currentLiquidationThreshold,\\n        uint256 ltv,\\n        uint256 healthFactor\\n    ) =\\n        ILendingPool(\\n            ILendingPoolAddressesProvider(LENDING_POOL_ADDRESSES_PROVIDER)\\n                .getLendingPool()\\n        )\\n            .getUserAccountData(user);\\n\\n    userData = AaveUserData(\\n        totalCollateralETH,\\n        totalDebtETH,\\n        availableBorrowsETH,\\n        currentLiquidationThreshold,\\n        ltv,\\n        healthFactor,\\n        _getEtherPrice()\\n    );\\n}\\n\\nfunction _getAssetLiquidationThreshold(address _token)\\n    view\\n    returns (uint256 liquidationThreshold)\\n{\\n    (, , liquidationThreshold, , , , , , , ) = IAaveProtocolDataProvider(\\n        AAVE_PROTOCOL_DATA_PROVIDER\\n    )\\n        .getReserveConfigurationData(_getTokenAddr(_token));\\n}\\n\\nfunction _getTokenAddr(address _token) pure returns (address) {\\n    return _token == ETH ? WETH : _token;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Aave/IAaveProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IAaveProtocolDataProvider {\\n    function getUserReserveData(address asset, address user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentStableDebt,\\n            uint256 currentVariableDebt,\\n            uint256 principalStableDebt,\\n            uint256 scaledVariableDebt,\\n            uint256 stableBorrowRate,\\n            uint256 liquidityRate,\\n            uint40 stableRateLastUpdated,\\n            bool usageAsCollateralEnabled\\n        );\\n\\n    function getReserveConfigurationData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256 decimals,\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            uint256 reserveFactor,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive,\\n            bool isFrozen\\n        );\\n\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256 availableLiquidity,\\n            uint256 totalStableDebt,\\n            uint256 totalVariableDebt,\\n            uint256 liquidityRate,\\n            uint256 variableBorrowRate,\\n            uint256 stableBorrowRate,\\n            uint256 averageStableBorrowRate,\\n            uint256 liquidityIndex,\\n            uint256 variableBorrowIndex,\\n            uint40 lastUpdateTimestamp\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Aave/ChainLinkInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface ChainLinkInterface {\\n    function latestAnswer() external view returns (int256);\\n\\n    function decimals() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Compound/ICToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface ICToken {\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getCash() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/dapps/FCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {CompData, AccountLiquidityLocalVars} from \\\"../../structs/SCompound.sol\\\";\\nimport {INSTA_MAPPING} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {COMPTROLLER} from \\\"../../constants/CCompound.sol\\\";\\nimport {InstaMapping} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {ICToken} from \\\"../../interfaces/dapps/Compound/ICToken.sol\\\";\\nimport {IComptroller} from \\\"../../interfaces/dapps/Compound/IComptroller.sol\\\";\\nimport {IPriceOracle} from \\\"../../interfaces/dapps/Compound/IPriceOracle.sol\\\";\\nimport {mul} from \\\"../../vendor/DSMath.sol\\\";\\n\\nfunction _getCToken(address _token) view returns (address) {\\n    return InstaMapping(INSTA_MAPPING).cTokenMapping(_token);\\n}\\n\\nfunction _wouldCompoundAccountBeLiquid(\\n    address _dsa,\\n    uint256 _colAmt,\\n    address _cTokenModify,\\n    uint256 _debtAmt\\n) view returns (bool) {\\n    AccountLiquidityLocalVars memory vars;\\n\\n    IComptroller comptroller = IComptroller(COMPTROLLER);\\n\\n    ICToken[] memory assets = comptroller.getAssetsIn(_dsa);\\n    for (uint256 i = 0; i < assets.length; i++) {\\n        ICToken asset = assets[i];\\n        // Read the balances and exchange rate from the cToken\\n        vars = _getAssetLiquidity(vars, _dsa, asset);\\n\\n        // Calculate effects of interacting with cTokenModify\\n        if (address(asset) == _cTokenModify) {\\n            vars.sumCollateral = mulScalarTruncateAddUInt(\\n                vars.tokensToDenom,\\n                _colAmt,\\n                vars.sumCollateral\\n            );\\n\\n            // borrow effect\\n            // sumBorrowPlusEffects += oraclePrice * debtAmt\\n            vars.sumBorrowPlusEffects = mulScalarTruncateAddUInt(\\n                vars.oraclePrice,\\n                _debtAmt,\\n                vars.sumBorrowPlusEffects\\n            );\\n        }\\n    }\\n\\n    if (assets.length == 0) {\\n        vars = _getAssetLiquidity(vars, _dsa, ICToken(_cTokenModify));\\n\\n        vars.sumCollateral = mulScalarTruncateAddUInt(\\n            vars.tokensToDenom,\\n            _colAmt,\\n            vars.sumCollateral\\n        );\\n\\n        vars.sumBorrowPlusEffects = mulScalarTruncateAddUInt(\\n            vars.oraclePrice,\\n            _debtAmt,\\n            vars.sumBorrowPlusEffects\\n        );\\n    }\\n\\n    return vars.sumCollateral > vars.sumBorrowPlusEffects;\\n}\\n\\nfunction _getAssetLiquidity(\\n    AccountLiquidityLocalVars memory vars,\\n    address _dsa,\\n    ICToken _asset\\n) view returns (AccountLiquidityLocalVars memory) {\\n    uint256 oErr;\\n    IComptroller comptroller = IComptroller(COMPTROLLER);\\n\\n    // Read the balances and exchange rate from the cToken\\n    (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRate) = ICToken(\\n        _asset\\n    )\\n        .getAccountSnapshot(_dsa);\\n    require(oErr == 0, \\\"_getAssetLiquidity: semi-opaque error code\\\");\\n    (, vars.collateralFactor, ) = (comptroller.markets(address(_asset)));\\n    vars.oraclePrice = IPriceOracle(IComptroller(COMPTROLLER).oracle())\\n        .getUnderlyingPrice(_asset);\\n    require(vars.oraclePrice != 0, \\\"\\\");\\n\\n    vars.tokensToDenom = mul_expScale(\\n        mul_expScale(vars.collateralFactor, vars.exchangeRate),\\n        vars.oraclePrice\\n    );\\n\\n    vars.sumCollateral = mulScalarTruncateAddUInt(\\n        vars.tokensToDenom,\\n        vars.cTokenBalance,\\n        vars.sumCollateral\\n    );\\n\\n    vars.sumBorrowPlusEffects = mulScalarTruncateAddUInt(\\n        vars.oraclePrice,\\n        vars.borrowBalance,\\n        vars.sumBorrowPlusEffects\\n    );\\n    return vars;\\n}\\n\\n// Compound Math Function\\n\\nfunction mulScalarTruncateAddUInt(\\n    uint256 _a,\\n    uint256 _b,\\n    uint256 _addend\\n) pure returns (uint256) {\\n    return mul_expScale(_a, _b) + _addend;\\n}\\n\\nfunction mul_expScale(uint256 _a, uint256 _b) pure returns (uint256) {\\n    return mul(_a, _b) / 1e18;\\n}\\n\\n// Compound Math Function\\n\"\r\n    },\r\n    \"contracts/structs/SCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nstruct AccountLiquidityLocalVars {\\n    uint256 sumCollateral;\\n    uint256 sumBorrowPlusEffects;\\n    uint256 cTokenBalance;\\n    uint256 borrowBalance;\\n    uint256 exchangeRateMantissa;\\n    uint256 oraclePriceMantissa;\\n    uint256 collateralFactor;\\n    uint256 exchangeRate;\\n    uint256 oraclePrice;\\n    uint256 tokensToDenom;\\n}\\n\\nstruct Market {\\n    bool isListed;\\n    uint256 collateralFactorMantissa;\\n    mapping(address => bool) accountMembership;\\n    bool isComped;\\n}\\n\\nstruct CompData {\\n    uint256 tokenPriceInEth;\\n    uint256 tokenPriceInUsd;\\n    uint256 exchangeRateStored;\\n    uint256 balanceOfUser;\\n    uint256 borrowBalanceStoredUser;\\n    uint256 supplyRatePerBlock;\\n    uint256 borrowRatePerBlock;\\n    uint256 collateralFactor;\\n    bool isComped;\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\naddress constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Compound/IComptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {ICToken} from \\\"./ICToken.sol\\\";\\nimport {Market} from \\\"../../../structs/SCompound.sol\\\";\\n\\ninterface IComptroller {\\n    function getAssetsIn(address account)\\n        external\\n        view\\n        returns (ICToken[] memory);\\n\\n    function oracle() external view returns (address);\\n\\n    function markets(address cToken)\\n        external\\n        view\\n        returns (\\n            bool isListed,\\n            uint256 collateralFactorMantissa,\\n            bool isComped\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Compound/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {ICToken} from \\\"./ICToken.sol\\\";\\n\\ninterface IPriceOracle {\\n    function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {IGelatoProviderModule} from \\\"../../gelato_provider_modules/IGelatoProviderModule.sol\\\";\\nimport {IGelatoCondition} from \\\"../../gelato_conditions/IGelatoCondition.sol\\\";\\n\\nstruct Provider {\\n    address addr;  //  if msg.sender == provider => self-Provider\\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\\n}\\n\\nstruct Condition {\\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\\n    bytes data;  // can be bytes32(0) for self-conditional Actions\\n}\\n\\nenum Operation { Call, Delegatecall }\\n\\nenum DataFlow { None, In, Out, InAndOut }\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions;  // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\\n}\\n\\nstruct TaskReceipt {\\n    uint256 id;\\n    address userProxy;\\n    Provider provider;\\n    uint256 index;\\n    Task[] tasks;\\n    uint256 expiryDate;\\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\\n    uint256 submissionsLeft;\\n}\\n\\ninterface IGelatoCore {\\n    event LogTaskSubmitted(\\n        uint256 indexed taskReceiptId,\\n        bytes32 indexed taskReceiptHash,\\n        TaskReceipt taskReceipt\\n    );\\n\\n    event LogExecSuccess(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorSuccessFee,\\n        uint256 sysAdminSuccessFee\\n    );\\n    event LogCanExecFailed(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        string reason\\n    );\\n    event LogExecReverted(\\n        address indexed executor,\\n        uint256 indexed taskReceiptId,\\n        uint256 executorRefund,\\n        string reason\\n    );\\n\\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\\n\\n    /// @notice API to query whether Task can be submitted successfully.\\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _userProxy The userProxy from which the task will be submitted.\\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\\n    function canSubmitTask(\\n        address _userProxy,\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice API to submit a single Task.\\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _task A Gelato Task object: provider, conditions, actions.\\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _cycles How many full cycles will be submitted\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    )\\n        external;\\n\\n\\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n    ///  the next one, after they have been executed.\\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\\n    ///  would be submitted, but not the second\\n    /// @param _provider Gelato Provider object: provider address and module.\\n    /// @param _tasks This can be a single task or a sequence of tasks.\\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\\n    ///  that should have occured once the cycle is complete:\\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\\n    ///  ...\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    )\\n        external;\\n\\n    // ================  Exec Suite =========================\\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\\n    ///   In the latter case Executors are refunded by the Task Provider.\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function exec(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel task\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _TR TaskReceipt: id, userProxy, Task.\\n    function cancelTask(TaskReceipt calldata _TR) external;\\n\\n    /// @notice Cancel multiple tasks at once\\n    /// @dev Callable only by userProxy or selected provider\\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\\n\\n    /// @notice Compute hash of task receipt\\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\\n    /// @return hash of taskReceipt\\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\\n\\n    // ================  Getters =========================\\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\\n    /// @return currentId currentId, last TaskReceiptId submitted\\n    function currentTaskReceiptId() external view returns(uint256);\\n\\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\\n    /// @return hash of taskReceipt\\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_provider_modules/IGelatoProviderModule.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\nimport {Action, Task} from \\\"../gelato_core/interfaces/IGelatoCore.sol\\\";\\n\\ninterface IGelatoProviderModule {\\n\\n    /// @notice Check if provider agrees to pay for inputted task receipt\\n    /// @dev Enables arbitrary checks by provider\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @return \\\"OK\\\" if provider agrees\\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\\n        external\\n        view\\n        returns(string memory);\\n\\n    /// @notice Convert action specific payload into proxy specific payload\\n    /// @dev Encoded multiple actions into a multisend\\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\\n    /// @return Encoded payload that will be used for low-level .call on user proxy\\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\\n    function execPayload(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task,\\n        uint256 _cycleId\\n    )\\n        external\\n        view\\n        returns(bytes memory, bool checkReturndata);\\n\\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_conditions/IGelatoCondition.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\npragma experimental ABIEncoderV2;\\n\\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\\n/// @notice all the APIs of GelatoConditionsStandard\\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\\ninterface IGelatoCondition {\\n\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\\n        external\\n        view\\n        returns(string memory);\\n}\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectBasic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectBasic {\\n    function withdraw(\\n        address _erc20,\\n        uint256 _tokenAmt,\\n        address payable _to,\\n        uint256 _getId,\\n        uint256 _setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {DAI, ETH} from \\\"../../../../../constants/CTokens.sol\\\";\\nimport {\\n    CONNECT_MAKER,\\n    INSTA_POOL_V2,\\n    CONNECT_BASIC,\\n    CONNECT_FEE\\n} from \\\"../../../../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _isVaultOwner\\n} from \\\"../../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault,\\n    _encodeOpenMakerVault,\\n    _encodedDepositMakerVault,\\n    _encodeBorrowMakerVault\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodeBasicWithdraw\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectBasic.sol\\\";\\nimport {\\n    _encodeCalculateFee\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\\\";\\nimport {\\n    _getGelatoExecutorFees\\n} from \\\"../../../../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getRealisedDebt\\n} from \\\"../../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {BDebtBridgeFromMaker} from \\\"../../base/BDebtBridgeFromMaker.sol\\\";\\nimport {\\n    IOracleAggregator\\n} from \\\"../../../../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../../../../vendor/Convert.sol\\\";\\nimport {GELATO_EXECUTOR_MODULE} from \\\"../../../../../constants/CGelato.sol\\\";\\n\\ncontract ConnectGelatoDataMakerToMaker is BDebtBridgeFromMaker {\\n    // solhint-disable const-name-snakecase\\n    string public constant override name = \\\"ConnectGelatoDataMakerToMaker-v3.0\\\";\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    )\\n        BDebtBridgeFromMaker(\\n            __id,\\n            _oracleAggregator,\\n            __instaFeeCollector,\\n            __connectGelatoDebtBridgeFee\\n        )\\n    {}\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _vaultBId Id of the vault B Collateral of the client.\\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\\n    function getDataAndCastMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        string calldata _colType\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToMaker(_vaultAId, _vaultBId, _colType);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        string calldata _colType\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        _vaultBId = _isVaultOwner(_vaultBId, address(this)) ? _vaultBId : 0;\\n\\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\\n        uint256 wColToWithdrawFromMaker =\\n            _getMakerVaultCollateralBalance(_vaultAId);\\n\\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\\n\\n        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\\n            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\\n                _getGelatoExecutorFees(\\n                    _getGasCostMakerToMaker(_vaultBId == 0, route)\\n                ),\\n                ETH,\\n                DAI\\n            );\\n\\n        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _vaultBId == 0\\n                ? _spellsMakerToNewMakerVault(\\n                    _vaultAId,\\n                    _colType,\\n                    daiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromDebt\\n                )\\n                : _spellsMakerToMaker(\\n                    _vaultAId,\\n                    _vaultBId,\\n                    daiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromDebt\\n                );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            daiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToNewMakerVault(\\n        uint256 _vaultAId,\\n        string calldata _colType,\\n        uint256 _daiDebtAmt,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](9);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_MAKER; // open new B vault\\n        targets[4] = CONNECT_MAKER; // deposit\\n        targets[5] = CONNECT_MAKER; // borrow\\n        targets[6] = CONNECT_BASIC; // user pay fee to fee collector\\n        targets[7] = CONNECT_BASIC; // user pay fast transaction fee to executor\\n        targets[8] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](9);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodeOpenMakerVault(_colType);\\n        datas[4] = _encodedDepositMakerVault(0, _colToWithdrawFromMaker, 0, 0);\\n        datas[5] = _encodeBorrowMakerVault(0, 0, 600, 0);\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[7] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[8] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\\n    }\\n\\n    function _spellsMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        uint256 _daiDebtAmt,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](8);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_MAKER; // deposit\\n        targets[4] = CONNECT_MAKER; // borrow\\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\\n        targets[7] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](8);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodedDepositMakerVault(\\n            _vaultBId,\\n            _colToWithdrawFromMaker,\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\\n        datas[5] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {DAI, ETH} from \\\"../../../../../constants/CTokens.sol\\\";\\nimport {\\n    CONNECT_MAKER,\\n    CONNECT_COMPOUND,\\n    INSTA_POOL_V2,\\n    CONNECT_BASIC,\\n    CONNECT_FEE\\n} from \\\"../../../../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodeDepositCompound,\\n    _encodeBorrowCompound\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectCompound.sol\\\";\\nimport {\\n    _encodeBasicWithdraw\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectBasic.sol\\\";\\nimport {\\n    _encodeCalculateFee\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\\\";\\nimport {\\n    _getGelatoExecutorFees\\n} from \\\"../../../../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {BDebtBridgeFromMaker} from \\\"../../base/BDebtBridgeFromMaker.sol\\\";\\nimport {\\n    IOracleAggregator\\n} from \\\"../../../../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../../../../vendor/Convert.sol\\\";\\nimport {GELATO_EXECUTOR_MODULE} from \\\"../../../../../constants/CGelato.sol\\\";\\n\\ncontract ConnectGelatoDataMakerToCompound is BDebtBridgeFromMaker {\\n    // solhint-disable const-name-snakecase\\n    string public constant override name =\\n        \\\"ConnectGelatoDataMakerToCompound-v1.0\\\";\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    )\\n        BDebtBridgeFromMaker(\\n            __id,\\n            _oracleAggregator,\\n            __instaFeeCollector,\\n            __connectGelatoDebtBridgeFee\\n        )\\n    {}\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultId Id of the unsafe vault of the client.\\n    /// @param _colToken  vault's col token address .\\n    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\\n        external\\n        payable\\n    {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToCompound(_vaultId, _colToken);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToCompound(uint256 _vaultId, address _colToken)\\n        internal\\n        view\\n        returns (address[] memory targets, bytes[] memory datas)\\n    {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\\n\\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\\n\\n        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\\n            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\\n                _getGelatoExecutorFees(_getGasCostMakerToCompound(route)),\\n                ETH,\\n                DAI\\n            );\\n\\n        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _spellsMakerToCompound(\\n                _vaultId,\\n                _colToken,\\n                daiToBorrow,\\n                _getMakerVaultCollateralBalance(_vaultId),\\n                gasFeesPaidFromDebt\\n            );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            daiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToCompound(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _daiDebtAmt,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](8);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_COMPOUND; // deposit\\n        targets[4] = CONNECT_COMPOUND; // borrow\\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\\n        targets[7] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](8);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodeDepositCompound(\\n            _colToken,\\n            _colToWithdrawFromMaker,\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowCompound(DAI, 0, 600, 0);\\n        datas[5] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectCompound\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectCompound.sol\\\";\\n\\nfunction _encodeDepositCompound(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectCompound.deposit.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\\nfunction _encodeBorrowCompound(\\n    address _token,\\n    uint256 _amt,\\n    uint256 _getId,\\n    uint256 _setId\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectCompound.borrow.selector,\\n            _token,\\n            _amt,\\n            _getId,\\n            _setId\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectCompound {\\n    function borrow(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {DAI, ETH} from \\\"../../../../../constants/CTokens.sol\\\";\\nimport {\\n    CONNECT_MAKER,\\n    CONNECT_AAVE_V2,\\n    CONNECT_BASIC,\\n    INSTA_POOL_V2\\n} from \\\"../../../../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodeDepositAave,\\n    _encodeBorrowAave\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectAave.sol\\\";\\nimport {\\n    _encodeCalculateFee\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\\\";\\nimport {\\n    _encodeBasicWithdraw\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectBasic.sol\\\";\\nimport {\\n    _getGelatoExecutorFees\\n} from \\\"../../../../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToAave,\\n    _getRealisedDebt\\n} from \\\"../../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {BDebtBridgeFromMaker} from \\\"../../base/BDebtBridgeFromMaker.sol\\\";\\nimport {\\n    IOracleAggregator\\n} from \\\"../../../../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../../../../vendor/Convert.sol\\\";\\nimport {GELATO_EXECUTOR_MODULE} from \\\"../../../../../constants/CGelato.sol\\\";\\n\\ncontract ConnectGelatoDataMakerToAave is BDebtBridgeFromMaker {\\n    // solhint-disable const-name-snakecase\\n    string public constant override name = \\\"ConnectGelatoDataMakerToAave-v1.0\\\";\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    )\\n        BDebtBridgeFromMaker(\\n            __id,\\n            _oracleAggregator,\\n            __instaFeeCollector,\\n            __connectGelatoDebtBridgeFee\\n        )\\n    {}\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _colToken  vault's col token address .\\n    function getDataAndCastMakerToAave(uint256 _vaultId, address _colToken)\\n        external\\n        payable\\n    {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToAave(_vaultId, _colToken);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToAave(uint256 _vaultId, address _colToken)\\n        internal\\n        view\\n        returns (address[] memory targets, bytes[] memory datas)\\n    {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\\n\\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\\n\\n        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\\n            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\\n                _getGelatoExecutorFees(_getGasCostMakerToAave(route)),\\n                ETH,\\n                DAI\\n            );\\n\\n        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _spellsMakerToAave(\\n                _vaultId,\\n                _colToken,\\n                daiToBorrow,\\n                _getMakerVaultCollateralBalance(_vaultId),\\n                gasFeesPaidFromDebt\\n            );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            daiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToAave(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _daiDebtAmt,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](8);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_AAVE_V2; // deposit\\n        targets[4] = CONNECT_AAVE_V2; // borrow\\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\\n        targets[7] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](8);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodeDepositAave(_colToken, _colToWithdrawFromMaker, 0, 0);\\n        datas[4] = _encodeBorrowAave(DAI, 0, 2, 600, 0); // Variable rate by default.\\n        datas[5] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {DAI, ETH} from \\\"../../constants/CTokens.sol\\\";\\nimport {\\n    CONNECT_MAKER,\\n    CONNECT_BASIC,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _isVaultOwner\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault,\\n    _encodedDepositMakerVault,\\n    _encodeBorrowMakerVault,\\n    _encodeOpenMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodeCalculateFee\\n} from \\\"../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    BDebtBridgeFromMaker\\n} from \\\"../../contracts/Instadapp/connectors/base/BDebtBridgeFromMaker.sol\\\";\\nimport {\\n    _encodeBasicWithdraw\\n} from \\\"../../functions/InstaDapp/connectors/FConnectBasic.sol\\\";\\nimport {IOracleAggregator} from \\\"../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../vendor/Convert.sol\\\";\\nimport {GELATO_EXECUTOR_MODULE} from \\\"../../constants/CGelato.sol\\\";\\n\\ncontract MockConnectGelatoDataMakerToMaker is BDebtBridgeFromMaker {\\n    // solhint-disable const-name-snakecase\\n    string public constant override name = \\\"ConnectGelatoDataMakerToMaker-v3.0\\\";\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    )\\n        BDebtBridgeFromMaker(\\n            __id,\\n            _oracleAggregator,\\n            __instaFeeCollector,\\n            __connectGelatoDebtBridgeFee\\n        )\\n    {}\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _mockRoute mock route Id.\\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _vaultBId Id of the vault B Collateral of the client.\\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\\n    function getDataAndCastMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        string calldata _colType,\\n        uint256 _mockRoute\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToMaker(_vaultAId, _vaultBId, _colType, _mockRoute);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        string calldata _colType,\\n        uint256 _mockRoute\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        _vaultBId = _isVaultOwner(_vaultBId, address(this)) ? _vaultBId : 0;\\n\\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\\n        uint256 wColToWithdrawFromMaker =\\n            _getMakerVaultCollateralBalance(_vaultAId);\\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\\n        route = _mockRoute;\\n\\n        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\\n            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\\n                _getGelatoExecutorFees(\\n                    _getGasCostMakerToMaker(_vaultBId == 0, route)\\n                ),\\n                ETH,\\n                DAI\\n            );\\n\\n        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _vaultBId == 0\\n                ? _spellsMakerToNewMakerVault(\\n                    _vaultAId,\\n                    _colType,\\n                    daiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromDebt\\n                )\\n                : _spellsMakerToMaker(\\n                    _vaultAId,\\n                    _vaultBId,\\n                    daiToBorrow,\\n                    wColToWithdrawFromMaker,\\n                    gasFeesPaidFromDebt\\n                );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            daiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToNewMakerVault(\\n        uint256 _vaultAId,\\n        string calldata _colType,\\n        uint256 _daiToBorrow,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](9);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_MAKER; // open new B vault\\n        targets[4] = CONNECT_MAKER; // deposit\\n        targets[5] = CONNECT_MAKER; // borrow\\n        targets[6] = CONNECT_BASIC; // user pay fee to fee collector\\n        targets[7] = CONNECT_BASIC; // user pay fast transaction fee to executor\\n        targets[8] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](9);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodeOpenMakerVault(_colType);\\n        datas[4] = _encodedDepositMakerVault(0, _colToWithdrawFromMaker, 0, 0);\\n        datas[5] = _encodeBorrowMakerVault(0, 0, 600, 0);\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[7] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[8] = _encodeFlashPayback(DAI, _daiToBorrow, 0, 0);\\n    }\\n\\n    function _spellsMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        uint256 _daiToBorrow,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](8);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_MAKER; // deposit\\n        targets[4] = CONNECT_MAKER; // borrow\\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\\n        targets[7] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](8);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultAId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodedDepositMakerVault(\\n            _vaultBId,\\n            _colToWithdrawFromMaker,\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\\n        datas[5] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[7] = _encodeFlashPayback(DAI, _daiToBorrow, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectInstaPoolV2\\n} from \\\"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {DAI, ETH} from \\\"../../constants/CTokens.sol\\\";\\nimport {\\n    CONNECT_MAKER,\\n    CONNECT_COMPOUND,\\n    CONNECT_BASIC,\\n    INSTA_POOL_V2\\n} from \\\"../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _encodeFlashPayback\\n} from \\\"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\\\";\\nimport {\\n    _encodePaybackMakerVault,\\n    _encodedWithdrawMakerVault\\n} from \\\"../../functions/InstaDapp/connectors/FConnectMaker.sol\\\";\\nimport {\\n    _encodeDepositCompound,\\n    _encodeBorrowCompound\\n} from \\\"../../functions/InstaDapp/connectors/FConnectCompound.sol\\\";\\nimport {\\n    _encodeCalculateFee\\n} from \\\"../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\\\";\\nimport {\\n    _encodeBasicWithdraw\\n} from \\\"../../functions/InstaDapp/connectors/FConnectBasic.sol\\\";\\nimport {_getGelatoExecutorFees} from \\\"../../functions/gelato/FGelato.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    BDebtBridgeFromMaker\\n} from \\\"../../contracts/Instadapp/connectors/base/BDebtBridgeFromMaker.sol\\\";\\nimport {IOracleAggregator} from \\\"../../interfaces/gelato/IOracleAggregator.sol\\\";\\nimport {_convertTo18} from \\\"../../vendor/Convert.sol\\\";\\nimport {GELATO_EXECUTOR_MODULE} from \\\"../../constants/CGelato.sol\\\";\\n\\ncontract MockConnectGelatoDataMakerToCompound is BDebtBridgeFromMaker {\\n    // solhint-disable-next-line const-name-snakecase\\n    string public constant override name =\\n        \\\"MockConnectGelatoDataMakerToCompound-v1.0\\\";\\n\\n    // solhint-disable no-empty-blocks\\n    constructor(\\n        uint256 __id,\\n        address _oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDebtBridgeFee\\n    )\\n        BDebtBridgeFromMaker(\\n            __id,\\n            _oracleAggregator,\\n            __instaFeeCollector,\\n            __connectGelatoDebtBridgeFee\\n        )\\n    {}\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultId Id of the unsafe vault of the client.\\n    /// @param _colToken  vault's col token address .\\n    function getDataAndCastMakerToCompound(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _mockRoute\\n    ) external payable {\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataMakerToCompound(_vaultId, _colToken, _mockRoute);\\n\\n        _cast(targets, datas);\\n    }\\n\\n    /* solhint-disable function-max-lines */\\n\\n    function _dataMakerToCompound(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _mockRoute\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](1);\\n        targets[0] = INSTA_POOL_V2;\\n\\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\\n\\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\\n        route = _mockRoute;\\n\\n        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\\n            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\\n                _getGelatoExecutorFees(_getGasCostMakerToCompound(route)),\\n                ETH,\\n                DAI\\n            );\\n\\n        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\\n\\n        (address[] memory _targets, bytes[] memory _datas) =\\n            _spellsMakerToCompound(\\n                _vaultId,\\n                _colToken,\\n                daiToBorrow,\\n                _getMakerVaultCollateralBalance(_vaultId),\\n                gasFeesPaidFromDebt\\n            );\\n\\n        datas = new bytes[](1);\\n        datas[0] = abi.encodeWithSelector(\\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\\n            DAI,\\n            daiToBorrow,\\n            route,\\n            abi.encode(_targets, _datas)\\n        );\\n    }\\n\\n    function _spellsMakerToCompound(\\n        uint256 _vaultId,\\n        address _colToken,\\n        uint256 _daiDebtAmt,\\n        uint256 _colToWithdrawFromMaker,\\n        uint256 _gasFeesPaidFromDebt\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        targets = new address[](8);\\n        targets[0] = CONNECT_MAKER; // payback\\n        targets[1] = CONNECT_MAKER; // withdraw\\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\\n        targets[3] = CONNECT_COMPOUND; // deposit\\n        targets[4] = CONNECT_COMPOUND; // borrow\\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\\n        targets[7] = INSTA_POOL_V2; // flashPayback\\n\\n        datas = new bytes[](8);\\n        datas[0] = _encodePaybackMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            600\\n        );\\n        datas[1] = _encodedWithdrawMakerVault(\\n            _vaultId,\\n            type(uint256).max,\\n            0,\\n            0\\n        );\\n        datas[2] = _encodeCalculateFee(\\n            0,\\n            _gasFeesPaidFromDebt,\\n            IInstaFeeCollector(instaFeeCollector).fee(),\\n            600,\\n            600,\\n            601\\n        );\\n        datas[3] = _encodeDepositCompound(\\n            _colToken,\\n            _colToWithdrawFromMaker,\\n            0,\\n            0\\n        );\\n        datas[4] = _encodeBorrowCompound(DAI, 0, 600, 0);\\n        datas[5] = _encodeBasicWithdraw(\\n            DAI,\\n            0,\\n            IInstaFeeCollector(instaFeeCollector).feeCollector(),\\n            601,\\n            0\\n        );\\n        datas[6] = _encodeBasicWithdraw(\\n            DAI,\\n            _gasFeesPaidFromDebt,\\n            payable(GELATO_EXECUTOR_MODULE),\\n            0,\\n            0\\n        );\\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {GelatoBytes} from \\\"../../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    AccountInterface,\\n    ConnectorInterface\\n} from \\\"../../../../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {\\n    DataFlow\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _isVaultOwner\\n} from \\\"../../../../../functions/dapps/FMaker.sol\\\";\\nimport {DebtBridgeInputData} from \\\"../../../../../structs/SDebtBridge.sol\\\";\\nimport {DAI} from \\\"../../../../../constants/CTokens.sol\\\";\\nimport {\\n    _getRealisedDebt,\\n    _getFlashLoanRoute\\n} from \\\"../../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {PROTOCOL} from \\\"../../../../../constants/CDebtBridge.sol\\\";\\nimport {\\n    _getDebtBridgeRoute\\n} from \\\"../../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    _encodeGetDataAndCastMakerToAave\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectGelatoDataMakerToAave.sol\\\";\\nimport {\\n    _encodeGetDataAndCastMakerToMaker\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectGelatoDataMakerToMaker.sol\\\";\\nimport {\\n    _encodeGetDataAndCastMakerToCompound\\n} from \\\"../../../../../functions/InstaDapp/connectors/FConnectGelatoDataMakerToCompound.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConnectGelatoDataMakerToX is ConnectorInterface {\\n    using GelatoBytes for bytes;\\n\\n    string public constant OK = \\\"OK\\\";\\n\\n    // solhint-disable const-name-snakecase\\n    string public constant override name = \\\"ConnectGelatoDataMakerToX-v1.0\\\";\\n    uint256 internal immutable _id;\\n    address public immutable oracleAggregator;\\n    address internal immutable _instaFeeCollector;\\n    address internal immutable _connectGelatoDataMakerToAave;\\n    address internal immutable _connectGelatoDataMakerToMaker;\\n    address internal immutable _connectGelatoDataMakerToCompound;\\n\\n    constructor(\\n        uint256 __id,\\n        address __oracleAggregator,\\n        address __instaFeeCollector,\\n        address __connectGelatoDataMakerToAave,\\n        address __connectGelatoDataMakerToMaker,\\n        address __connectGelatoDataMakerToCompound\\n    ) {\\n        _id = __id;\\n        oracleAggregator = __oracleAggregator;\\n        _instaFeeCollector = __instaFeeCollector;\\n        _connectGelatoDataMakerToAave = __connectGelatoDataMakerToAave;\\n        _connectGelatoDataMakerToMaker = __connectGelatoDataMakerToMaker;\\n        _connectGelatoDataMakerToCompound = __connectGelatoDataMakerToCompound;\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id); // Should put specific value.\\n    }\\n\\n    // ====== ACTION TERMS CHECK ==========\\n    // Overriding IGelatoAction's function (optional)\\n    function termsOk(\\n        uint256, // taskReceipId\\n        address _dsa,\\n        bytes calldata _actionData,\\n        DataFlow,\\n        uint256, // value\\n        uint256 // cycleId\\n    ) public view returns (string memory) {\\n        uint256 vaultAId = abi.decode(_actionData[4:36], (uint256));\\n\\n        if (vaultAId == 0)\\n            return \\\"ConnectGelatoDataMakerToMaker: Vault A Id is not valid\\\";\\n        if (!_isVaultOwner(vaultAId, _dsa))\\n            return \\\"ConnectGelatoDataMakerToMaker: Vault A not owned by dsa\\\";\\n        return OK;\\n    }\\n\\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\\n    /// @param _colToken The ETH-A collateral token.\\n    /// @param _makerDestVaultId Only for Maker: e.g. ETH-B vault of the client.\\n    /// @param _makerDestColType Only for Maker: colType of the new vault: e.g.ETH-B\\n    function getDataAndCastFromMaker(\\n        uint256 _vaultAId,\\n        address _colToken,\\n        uint256 _makerDestVaultId,\\n        string memory _makerDestColType\\n    ) external payable {\\n        uint256 debtAmt = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\\n        (address[] memory targets, bytes[] memory datas) =\\n            _dataFromMaker(\\n                _vaultAId,\\n                _colToken,\\n                DebtBridgeInputData({\\n                    dsa: address(this),\\n                    colAmt: _getMakerVaultCollateralBalance(_vaultAId),\\n                    colToken: _colToken,\\n                    debtAmt: debtAmt,\\n                    oracleAggregator: oracleAggregator,\\n                    makerDestVaultId: _makerDestVaultId,\\n                    makerDestColType: _makerDestColType,\\n                    fees: IInstaFeeCollector(_instaFeeCollector).fee(),\\n                    flashRoute: _getFlashLoanRoute(DAI, debtAmt)\\n                })\\n            );\\n\\n        _cast(targets, datas);\\n    }\\n\\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\\n        // Instapool V2 / FlashLoan call\\n        bytes memory castData =\\n            abi.encodeWithSelector(\\n                AccountInterface.cast.selector,\\n                targets,\\n                datas,\\n                msg.sender // msg.sender == GelatoCore\\n            );\\n\\n        (bool success, bytes memory returndata) =\\n            address(this).delegatecall(castData);\\n\\n        if (!success)\\n            returndata.revertWithError(\\\"ConnectGelatoDataMakerToX._cast:\\\");\\n    }\\n\\n    function _dataFromMaker(\\n        uint256 _vaultAId,\\n        address _colToken,\\n        DebtBridgeInputData memory _data\\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\\n        PROTOCOL protocol = _getDebtBridgeRoute(_data);\\n\\n        require(\\n            protocol != PROTOCOL.NONE,\\n            \\\"ConnectGelatoDataMakerToX._dataFromMaker: PROTOCOL.NONE\\\"\\n        );\\n\\n        targets = new address[](1);\\n        datas = new bytes[](1);\\n\\n        if (protocol == PROTOCOL.AAVE) {\\n            targets[0] = _connectGelatoDataMakerToAave;\\n            datas[0] = _encodeGetDataAndCastMakerToAave(_vaultAId, _colToken);\\n        } else if (protocol == PROTOCOL.MAKER) {\\n            targets[0] = _connectGelatoDataMakerToMaker;\\n            datas[0] = _encodeGetDataAndCastMakerToMaker(\\n                _vaultAId,\\n                _data.makerDestVaultId,\\n                _data.makerDestColType,\\n                _colToken\\n            );\\n        } else {\\n            targets[0] = _connectGelatoDataMakerToCompound;\\n            datas[0] = _encodeGetDataAndCastMakerToCompound(\\n                _vaultAId,\\n                _colToken\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectGelatoDataMakerToAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectGelatoDataMakerToAave\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToAave.sol\\\";\\n\\nfunction _encodeGetDataAndCastMakerToAave(uint256 _vaultId, address _colToken)\\n    pure\\n    returns (bytes memory)\\n{\\n    return\\n        abi.encodeWithSelector(\\n            IConnectGelatoDataMakerToAave.getDataAndCastMakerToAave.selector,\\n            _vaultId,\\n            _colToken\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectGelatoDataMakerToMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectGelatoDataMakerToMaker\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToMaker.sol\\\";\\n\\nfunction _encodeGetDataAndCastMakerToMaker(\\n    uint256 _vaultAId,\\n    uint256 _vaultBId,\\n    string memory _colType,\\n    address _colToken\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectGelatoDataMakerToMaker.getDataAndCastMakerToMaker.selector,\\n            _vaultAId,\\n            _vaultBId,\\n            _colType,\\n            _colToken\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectGelatoDataMakerToCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectGelatoDataMakerToCompound\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToCompound.sol\\\";\\n\\nfunction _encodeGetDataAndCastMakerToCompound(\\n    uint256 _vaultId,\\n    address _colToken\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectGelatoDataMakerToCompound\\n                .getDataAndCastMakerToCompound\\n                .selector,\\n            _vaultId,\\n            _colToken\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectGelatoDataMakerToAave {\\n    function getDataAndCastMakerToAave(uint256 _vaultId, address _colToken)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectGelatoDataMakerToMaker {\\n    function getDataAndCastMakerToMaker(\\n        uint256 _vaultAId,\\n        uint256 _vaultBId,\\n        string calldata _colType,\\n        address _colToken\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectGelatoDataMakerToCompound {\\n    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/InstaFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {Ownable} from \\\"../../vendor/openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\nimport {MAX_INSTA_FEE} from \\\"../../constants/CDebtBridge.sol\\\";\\n\\ncontract InstaFeeCollector is IInstaFeeCollector, Ownable {\\n    uint256 public override fee;\\n\\n    address payable public override feeCollector;\\n\\n    constructor(uint256 _fee, address payable _feeCollector) {\\n        fee = _fee;\\n        feeCollector = _feeCollector;\\n    }\\n\\n    function setFeeCollector(address payable _feeCollector)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        feeCollector = _feeCollector;\\n    }\\n\\n    function setFee(uint256 _fee) external override onlyOwner {\\n        require(\\n            _fee <= MAX_INSTA_FEE,\\n            \\\"InstaFeeCollector.setFee: New fee value is too high.\\\"\\n        );\\n        fee = _fee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/ConditionCanDoRefinance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    _getDebtBridgeRoute\\n} from \\\"../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {PROTOCOL} from \\\"../../../constants/CDebtBridge.sol\\\";\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\nimport {DebtBridgeInputData} from \\\"../../../structs/SDebtBridge.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _getFlashLoanRoute,\\n    _getRealisedDebt\\n} from \\\"../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {DAI} from \\\"../../../constants/CTokens.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionCanDoRefinance is GelatoConditionsStandard {\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        address _colToken,\\n        uint256 _makerDestVaultId,\\n        string calldata _makerDestColType\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.canDoRefinance.selector,\\n                _dsa,\\n                _fromVaultId,\\n                _colToken,\\n                _makerDestVaultId,\\n                _makerDestColType\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            address _dsa,\\n            uint256 _fromVaultId,\\n            address _colToken,\\n            uint256 _makerDestVaultId,\\n            string memory _makerDestColType\\n        ) =\\n            abi.decode(\\n                _conditionData[4:],\\n                (address, uint256, address, uint256, string)\\n            );\\n\\n        return\\n            canDoRefinance(\\n                _dsa,\\n                _fromVaultId,\\n                _colToken,\\n                _makerDestVaultId,\\n                _makerDestColType\\n            );\\n    }\\n\\n    function canDoRefinance(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        address _colToken,\\n        uint256 _makerDestVaultId,\\n        string memory _makerDestColType\\n    ) public view returns (string memory) {\\n        uint256 debtAmt = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\\n        return\\n            _getDebtBridgeRoute(\\n                DebtBridgeInputData({\\n                    dsa: _dsa,\\n                    colAmt: _getMakerVaultCollateralBalance(_fromVaultId),\\n                    colToken: _colToken,\\n                    debtAmt: debtAmt,\\n                    oracleAggregator: oracleAggregator,\\n                    makerDestVaultId: _makerDestVaultId,\\n                    makerDestColType: _makerDestColType,\\n                    fees: IInstaFeeCollector(instaFeeCollector).fee(),\\n                    flashRoute: _getFlashLoanRoute(DAI, debtAmt)\\n                })\\n            ) != PROTOCOL.NONE\\n                ? OK\\n                : \\\"CannotDoRefinance\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\nimport \\\"./IGelatoCondition.sol\\\";\\n\\nabstract contract GelatoConditionsStandard is IGelatoCondition {\\n    string internal constant OK = \\\"OK\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/compound/ConditionMakerToCompoundSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    _compoundPositionWillBeSafe\\n} from \\\"../../../../functions/gelato/conditions/compound/FCompoundPositionWillBeSafe.sol\\\";\\nimport {DAI} from \\\"../../../../constants/CTokens.sol\\\";\\nimport {\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _getMaxAmtToBorrowMakerToCompound\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionMakerToCompoundSafe is GelatoConditionsStandard {\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(address _dsa, uint256 _fromVaultId)\\n        public\\n        pure\\n        virtual\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodeWithSelector(\\n                this.compoundPositionWillBeSafe.selector,\\n                _dsa,\\n                _fromVaultId\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (address _dsa, uint256 _fromVaultId) =\\n            abi.decode(_conditionData[4:], (address, uint256));\\n\\n        return compoundPositionWillBeSafe(_dsa, _fromVaultId);\\n    }\\n\\n    function compoundPositionWillBeSafe(address _dsa, uint256 _fromVaultId)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return\\n            _compoundPositionWillBeSafe(\\n                _dsa,\\n                _getMakerVaultCollateralBalance(_fromVaultId),\\n                DAI,\\n                _getMaxAmtToBorrowMakerToCompound(\\n                    _fromVaultId,\\n                    IInstaFeeCollector(instaFeeCollector).fee(),\\n                    oracleAggregator\\n                )\\n            )\\n                ? OK\\n                : \\\"CompoundPositionsWillNotBeSafe\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/resolvers/MakerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _getMakerRawVaultDebt,\\n    _getMakerVaultDebt,\\n    _getMakerVaultCollateralBalance,\\n    _vaultWillBeSafe,\\n    _newVaultWillBeSafe,\\n    _stringToBytes32\\n} from \\\"../../functions/dapps/FMaker.sol\\\";\\nimport {MCD_MANAGER, JUG} from \\\"../../constants/CMaker.sol\\\";\\nimport {IMcdManager} from \\\"../../interfaces/dapps/Maker/IMcdManager.sol\\\";\\nimport {IVat} from \\\"../../interfaces/dapps/Maker/IVat.sol\\\";\\nimport {IJug} from \\\"../../interfaces/dapps/Maker/IJug.sol\\\";\\nimport {\\n    _isDebtAmtDustExplicit\\n} from \\\"../../functions/gelato/conditions/maker/FIsDebtAmtDust.sol\\\";\\nimport {\\n    _debtCeilingIsReachedExplicit\\n} from \\\"../../functions/gelato/conditions/maker/FDebtCeilingIsReached.sol\\\";\\nimport {rmul} from \\\"../../vendor/DSMath.sol\\\";\\n\\ncontract MakerResolver {\\n    /// @dev Return Debt in wad of the vault associated to the vaultId.\\n    function getMakerVaultRawDebt(uint256 _vaultId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getMakerRawVaultDebt(_vaultId);\\n    }\\n\\n    function getMakerVaultDebt(uint256 _vaultId) public view returns (uint256) {\\n        return _getMakerVaultDebt(_vaultId);\\n    }\\n\\n    /// @dev Return Collateral in wad of the vault associated to the vaultId.\\n    function getMakerVaultCollateralBalance(uint256 _vaultId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getMakerVaultCollateralBalance(_vaultId);\\n    }\\n\\n    function vaultWillBeSafe(\\n        uint256 _vaultId,\\n        uint256 _colAmt,\\n        uint256 _daiDebtAmt\\n    ) public view returns (bool) {\\n        return _vaultWillBeSafe(_vaultId, _colAmt, _daiDebtAmt);\\n    }\\n\\n    function newVaultWillBeSafe(\\n        string memory _colType,\\n        uint256 _colAmt,\\n        uint256 _daiDebtAmt\\n    ) public view returns (bool) {\\n        return _newVaultWillBeSafe(_colType, _colAmt, _daiDebtAmt);\\n    }\\n\\n    function getMaxDebtAmt(string memory _colType)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        IMcdManager manager = IMcdManager(MCD_MANAGER);\\n        IVat vat = IVat(manager.vat());\\n        IJug jug = IJug(JUG);\\n        bytes32 ilk = _stringToBytes32(_colType);\\n        (uint256 art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\\n\\n        (uint256 duty, uint256 rho) = jug.ilks(ilk);\\n        uint256 base = jug.base();\\n\\n        return\\n            (line -\\n                (art *\\n                    rmul(\\n                        // solhint-disable-next-line not-rely-on-time\\n                        rpow(base + duty, block.timestamp - rho, 10**27),\\n                        rate\\n                    ))) / 1e27;\\n    }\\n\\n    // solhint-disable function-max-lines, ordering\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 b\\n    ) public pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n                case 0 {\\n                    switch n\\n                        case 0 {\\n                            z := b\\n                        }\\n                        default {\\n                            z := 0\\n                        }\\n                }\\n                default {\\n                    switch mod(n, 2)\\n                        case 0 {\\n                            z := b\\n                        }\\n                        default {\\n                            z := x\\n                        }\\n                    let half := div(b, 2) // for rounding.\\n                    for {\\n                        n := div(n, 2)\\n                    } n {\\n                        n := div(n, 2)\\n                    } {\\n                        let xx := mul(x, x)\\n                        if iszero(eq(div(xx, x), x)) {\\n                            revert(0, 0)\\n                        }\\n                        let xxRound := add(xx, half)\\n                        if lt(xxRound, xx) {\\n                            revert(0, 0)\\n                        }\\n                        x := div(xxRound, b)\\n                        if mod(n, 2) {\\n                            let zx := mul(z, x)\\n                            if and(\\n                                iszero(iszero(x)),\\n                                iszero(eq(div(zx, x), z))\\n                            ) {\\n                                revert(0, 0)\\n                            }\\n                            let zxRound := add(zx, half)\\n                            if lt(zxRound, zx) {\\n                                revert(0, 0)\\n                            }\\n                            z := div(zxRound, b)\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n\\n    function debtAmtIsDust(\\n        uint256 _destVaultId,\\n        string memory _colType,\\n        uint256 _daiDebtAmt\\n    ) public view returns (bool) {\\n        return _isDebtAmtDustExplicit(_destVaultId, _colType, _daiDebtAmt);\\n    }\\n\\n    function debtCeilingIsReached(\\n        uint256 _destVaultId,\\n        string memory _destColType,\\n        uint256 _daiDebtAmt\\n    ) public view returns (bool) {\\n        return\\n            _debtCeilingIsReachedExplicit(\\n                _destVaultId,\\n                _destColType,\\n                _daiDebtAmt\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Maker/IJug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IJug {\\n    function ilks(bytes32 ilk) external view returns (uint256, uint256);\\n\\n    function base() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/debt_bridge/ConnectGelatoDebtBridgeFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    ConnectorInterface\\n} from \\\"../../../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {IInstaMemory} from \\\"../../../../interfaces/InstaDapp/IInstaMemory.sol\\\";\\nimport {INSTA_MEMORY} from \\\"../../../../constants/CInstaDapp.sol\\\";\\nimport {\\n    _getUint,\\n    _setUint\\n} from \\\"../../../../functions/InstaDapp/FInstaDapp.sol\\\";\\nimport {wmul} from \\\"../../../../vendor/DSMath.sol\\\";\\n\\ncontract ConnectGelatoDebtBridgeFee is ConnectorInterface {\\n    // solhint-disable const-name-snakecase\\n    string public constant override name = \\\"ConnectGelatoDebtBridgeFee-v1.0\\\";\\n    uint256 internal immutable _id;\\n\\n    constructor(uint256 __id) {\\n        _id = __id;\\n    }\\n\\n    /// @notice Function to compute Fee and borrow amount\\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\\n    /// @param _debt the amount of debt at the beginning\\n    /// @param _txFee  fast transaction fee of Gelato.\\n    /// @param _instaFeeFactor  instadapp fee.\\n    /// @param _getId  the amount storing Id in instaMemory.\\n    /// @param _setId  id to store total amount (e.g. debt or col to draw)\\n    /// @param _setIdInstaFee  id to store instaFee\\n    function calculateFee(\\n        uint256 _debt,\\n        uint256 _txFee,\\n        uint256 _instaFeeFactor,\\n        uint256 _getId,\\n        uint256 _setId,\\n        uint256 _setIdInstaFee\\n    ) external payable {\\n        _debt = _getUint(_getId, _debt);\\n\\n        uint256 instaFee = wmul(_debt, _instaFeeFactor);\\n\\n        _setUint(_setId, _debt + _txFee + instaFee); // Total amount to borrow.\\n        _setUint(_setIdInstaFee, instaFee);\\n    }\\n\\n    /// @dev Connector Details\\n    function connectorID()\\n        external\\n        view\\n        override\\n        returns (uint256 _type, uint256 id)\\n    {\\n        (_type, id) = (1, _id);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/IInstaMemory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IInstaMemory {\\n    function getUint(uint256 _id) external returns (uint256 _num);\\n\\n    function setUint(uint256 _id, uint256 _val) external;\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/FInstaDapp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {MemoryInterface} from \\\"../../interfaces/InstaDapp/IInstaDapp.sol\\\";\\nimport {INSTA_MEMORY} from \\\"../../constants/CInstaDapp.sol\\\";\\n\\nfunction _setUint(uint256 setId, uint256 val) {\\n    if (setId != 0) MemoryInterface(INSTA_MEMORY).setUint(setId, val);\\n}\\n\\nfunction _getUint(uint256 getId, uint256 val) returns (uint256 returnVal) {\\n    returnVal = getId == 0 ? val : MemoryInterface(INSTA_MEMORY).getUint(getId);\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/maker/FMakerVaultUnsafeOSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {wmul, wdiv} from \\\"../../../../vendor/DSMath.sol\\\";\\nimport {\\n    IInstaMakerResolver\\n} from \\\"../../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {INSTA_MAKER_RESOLVER} from \\\"../../../../constants/CInstaDapp.sol\\\";\\n\\nfunction _isVaultUnsafeOSM(\\n    uint256 _vaultId,\\n    address _priceOracle,\\n    bytes memory _oraclePayload,\\n    uint256 _minColRatio\\n) view returns (bool) {\\n    (bool success, bytes memory returndata) =\\n        _priceOracle.staticcall(_oraclePayload);\\n\\n    if (!success) {\\n        GelatoBytes.revertWithError(\\n            returndata,\\n            \\\"FMakerVaultUnsafeOSM._isVaultUnsafeOSM:oracle:\\\"\\n        );\\n    }\\n\\n    (bytes32 colPrice, bool hasNxt) = abi.decode(returndata, (bytes32, bool));\\n\\n    require(hasNxt, \\\"FMakerVaultUnsafeOSM._isVaultUnsafeOSM: !hasNxt\\\");\\n\\n    IInstaMakerResolver.VaultData memory vault =\\n        IInstaMakerResolver(INSTA_MAKER_RESOLVER).getVaultById(_vaultId);\\n\\n    return\\n        wdiv(wmul(vault.collateral, uint256(colPrice)), vault.debt) <\\n        _minColRatio;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IInstaMakerResolver {\\n    struct VaultData {\\n        uint256 id;\\n        address owner;\\n        string colType;\\n        uint256 collateral;\\n        uint256 art;\\n        uint256 debt;\\n        uint256 liquidatedCol;\\n        uint256 borrowRate;\\n        uint256 colPrice;\\n        uint256 liquidationRatio;\\n        address vaultAddress;\\n    }\\n\\n    function getVaultById(uint256 id) external view returns (VaultData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/resolvers/PriceOracleResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {Ownable} from \\\"../../vendor/openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\n\\n/// @title PriceOracleResolver\\n/// @notice Contract with convenience methods to retrieve oracle addresses or to mock test.\\n/// @dev Can be used to:\\n///  - Query oracle address for Gelato Condition payloads on frontend\\n///  - Test Conditions by using `getMockPrice(address _test)` as `oraclePayload`\\ncontract PriceOracleResolver is Ownable {\\n    using GelatoBytes for bytes;\\n\\n    mapping(string => address) public oracle;\\n    mapping(string => bytes) public oraclePayload;\\n    mapping(address => uint256) public mockPrice;\\n\\n    /// @notice Adds a new Oracle address\\n    /// @dev Only owner can call this, but existing oracle entries are immutable\\n    /// @param _oracle The descriptor of the oracle e.g. ETH/USD-Maker-v1\\n    /// @param _oracleAddress The address of the oracle contract\\n    /// @param _oraclePayload The payload with function selector for the oracle request.\\n    function addOracle(\\n        string memory _oracle,\\n        address _oracleAddress,\\n        bytes calldata _oraclePayload\\n    ) external onlyOwner {\\n        require(\\n            oracle[_oracle] == address(0),\\n            \\\"PriceOracleResolver.addOracle: set\\\"\\n        );\\n        oracle[_oracle] = _oracleAddress;\\n        oraclePayload[_oracle] = _oraclePayload;\\n    }\\n\\n    /// @notice Function that allows easy oracle data testing in production.\\n    /// @dev Your mock prices cannot be overriden by someone else.\\n    /// @param _mockPrice The mock data you want to test against.\\n    function setMockPrice(uint256 _mockPrice) public {\\n        mockPrice[msg.sender] = _mockPrice;\\n    }\\n\\n    /// @notice Use with setMockPrice for easy testing in production.\\n    /// @dev Encode oracle=PriceOracleResolver and oraclePayload=getMockPrice(tester)\\n    ///  to test your Conditions or Actions that make dynamic calls to price oracles.\\n    /// @param _tester The msg.sender during setMockPrice.\\n    /// @return The tester's mockPrice.\\n    function getMockPrice(address _tester) external view returns (uint256) {\\n        return mockPrice[_tester];\\n    }\\n\\n    /// @notice A generelized getter for a price supplied by an oracle contract.\\n    /// @dev The oracle returndata must be formatted as a single uint256.\\n    /// @param _oracle The descriptor of our oracle e.g. ETH/USD-Maker-v1\\n    /// @return The uint256 oracle price\\n    function getPrice(string memory _oracle) external view returns (uint256) {\\n        address oracleAddr = oracle[_oracle];\\n        if (oracleAddr == address(0))\\n            revert(\\\"PriceOracleResolver.getPrice: no oracle\\\");\\n        (bool success, bytes memory returndata) =\\n            oracleAddr.staticcall(oraclePayload[_oracle]);\\n        if (!success)\\n            returndata.revertWithError(\\\"PriceOracleResolver.getPrice:\\\");\\n        return abi.decode(returndata, (uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/gelato/conditions/maker/FMakerVaultUnsafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {wmul, wdiv} from \\\"../../../../vendor/DSMath.sol\\\";\\nimport {\\n    IInstaMakerResolver\\n} from \\\"../../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {INSTA_MAKER_RESOLVER} from \\\"../../../../constants/CInstaDapp.sol\\\";\\n\\nfunction _isVaultUnsafe(\\n    uint256 _vaultId,\\n    address _priceOracle,\\n    bytes memory _oraclePayload,\\n    uint256 _minColRatio\\n) view returns (bool) {\\n    (bool success, bytes memory returndata) =\\n        _priceOracle.staticcall(_oraclePayload);\\n\\n    if (!success) {\\n        GelatoBytes.revertWithError(\\n            returndata,\\n            \\\"ConditionMakerVaultUnsafe.isVaultUnsafe:oracle:\\\"\\n        );\\n    }\\n\\n    uint256 colPrice = abi.decode(returndata, (uint256));\\n\\n    IInstaMakerResolver.VaultData memory vault =\\n        IInstaMakerResolver(INSTA_MAKER_RESOLVER).getVaultById(_vaultId);\\n\\n    uint256 colRatio = wdiv(wmul(vault.collateral, colPrice), vault.debt);\\n\\n    return colRatio < _minColRatio;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/maker/ConditionMakerVaultUnsafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    _isVaultUnsafe\\n} from \\\"../../../../functions/gelato/conditions/maker/FMakerVaultUnsafe.sol\\\";\\n\\n/// @title ConditionMakerVaultUnsafe\\n/// @notice Condition tracking Maker vault collateralization safety requirements.\\n/// @author Gelato Team\\ncontract ConditionMakerVaultUnsafe is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    /// @notice Convenience function for off-chain _conditionData encoding\\n    /// @dev Use the return for your Task's Condition.data field off-chain.\\n    /// @return The encoded payload for your Task's Condition.data field.\\n    function getConditionData(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes calldata _oraclePayload,\\n        uint256 _minColRatio\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.isVaultUnsafe.selector,\\n                _vaultId,\\n                _priceOracle,\\n                _oraclePayload,\\n                _minColRatio\\n            );\\n    }\\n\\n    /// @notice Standard GelatoCore system function\\n    /// @dev A standard interface for GelatoCore to read Conditions\\n    /// @param _conditionData The data you get from `getConditionData()`\\n    /// @return OK if the Condition is there, else some error message.\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            uint256 _vaultID,\\n            address _priceOracle,\\n            bytes memory _oraclePayload,\\n            uint256 _minColRatio\\n        ) = abi.decode(_conditionData[4:], (uint256, address, bytes, uint256));\\n\\n        return\\n            isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio);\\n    }\\n\\n    /// @notice Specific implementation of this Condition's ok function\\n    /// @dev The price oracle must return a uint256 WAD (10**18) value.\\n    /// @param _vaultID The id of the Maker vault\\n    /// @param _priceOracle The price oracle contract to supply the collateral price\\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\\n    ///  method e.g. the selector for MakerOracle's read fn.\\n    /// @param _minColRatio The minimum collateral ratio measured in the price\\n    /// of the collateral as specified by the _priceOracle.\\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\\n    function isVaultUnsafe(\\n        uint256 _vaultID,\\n        address _priceOracle,\\n        bytes memory _oraclePayload,\\n        uint256 _minColRatio\\n    ) public view virtual returns (string memory) {\\n        return\\n            _isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio)\\n                ? OK\\n                : \\\"MakerVaultNotUnsafe\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/maker/ConditionMakerVaultUnsafeOSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    _isVaultUnsafeOSM\\n} from \\\"../../../../functions/gelato/conditions/maker/FMakerVaultUnsafeOSM.sol\\\";\\n\\n/// @title ConditionMakerVaultUnsafe\\n/// @notice Condition tracking Maker vault collateralization safety requirements.\\n/// @author Gelato Team\\ncontract ConditionMakerVaultUnsafeOSM is GelatoConditionsStandard {\\n    /// @notice Standard GelatoCore system function\\n    /// @dev A standard interface for GelatoCore to read Conditions\\n    /// @param _conditionData The data you get from `getConditionData()`\\n    /// @return OK if the Condition is there, else some error message.\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            uint256 _vaultID,\\n            address _priceOracle,\\n            bytes memory _oraclePayload,\\n            uint256 _minColRatio\\n        ) = abi.decode(_conditionData[4:], (uint256, address, bytes, uint256));\\n\\n        return\\n            isVaultUnsafeOSM(\\n                _vaultID,\\n                _priceOracle,\\n                _oraclePayload,\\n                _minColRatio\\n            );\\n    }\\n\\n    /// @notice Specific implementation of this Condition's ok function\\n    /// @dev The price oracle must return (bytes32, bool).\\n    /// @param _vaultID The id of the Maker vault\\n    /// @param _priceOracle The price oracle contract to supply the collateral price\\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\\n    ///  method e.g. the selector for MakerOracle's read fn.\\n    /// @param _minColRatio The minimum collateral ratio measured in the price\\n    /// of the collateral as specified by the _priceOracle.\\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\\n    function isVaultUnsafeOSM(\\n        uint256 _vaultID,\\n        address _priceOracle,\\n        bytes memory _oraclePayload,\\n        uint256 _minColRatio\\n    ) public view virtual returns (string memory) {\\n        return\\n            _isVaultUnsafeOSM(\\n                _vaultID,\\n                _priceOracle,\\n                _oraclePayload,\\n                _minColRatio\\n            )\\n                ? OK\\n                : \\\"MakerVaultNotUnsafe\\\";\\n    }\\n\\n    /// @notice Convenience function for off-chain _conditionData encoding\\n    /// @dev Use the return for your Task's Condition.data field off-chain.\\n    /// @return The encoded payload for your Task's Condition.data field.\\n    function getConditionData(\\n        uint256 _vaultId,\\n        address _priceOracle,\\n        bytes calldata _oraclePayload,\\n        uint256 _minColRatio\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.isVaultUnsafeOSM.selector,\\n                _vaultId,\\n                _priceOracle,\\n                _oraclePayload,\\n                _minColRatio\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/maker/ConditionMakerToMakerSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    _destVaultWillBeSafe\\n} from \\\"../../../../functions/gelato/conditions/maker/FDestVaultWillBeSafe.sol\\\";\\nimport {\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _getMaxAmtToBorrowMakerToMaker\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionMakerToMakerSafe is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string calldata _destColType\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.destVaultWillBeSafe.selector,\\n                _dsa,\\n                _fromVaultId,\\n                _destVaultId,\\n                _destColType\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            address _dsa,\\n            uint256 _fromVaultId,\\n            uint256 _destVaultId,\\n            string memory _destColType\\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\\n\\n        return\\n            destVaultWillBeSafe(_dsa, _fromVaultId, _destVaultId, _destColType);\\n    }\\n\\n    function destVaultWillBeSafe(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string memory _destColType\\n    ) public view returns (string memory) {\\n        return\\n            _destVaultWillBeSafe(\\n                _dsa,\\n                _destVaultId,\\n                _destColType,\\n                _getMakerVaultCollateralBalance(_fromVaultId),\\n                _getMaxAmtToBorrowMakerToMaker(\\n                    _fromVaultId,\\n                    _destVaultId == 0,\\n                    IInstaFeeCollector(instaFeeCollector).fee(),\\n                    oracleAggregator\\n                )\\n            )\\n                ? OK\\n                : \\\"DestVaultWillNotBeSafe\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/resolvers/CompoundResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _cTokenHasLiquidity\\n} from \\\"../../functions/gelato/conditions/compound/FCompoundHasLiquidity.sol\\\";\\nimport {\\n    _compoundPositionWillBeSafe\\n} from \\\"../../functions/gelato/conditions/compound/FCompoundPositionWillBeSafe.sol\\\";\\nimport {ICToken} from \\\"../../interfaces/dapps/Compound/ICToken.sol\\\";\\nimport {_getCToken} from \\\"../../functions/dapps/FCompound.sol\\\";\\n\\ncontract CompoundResolver {\\n    function compoundHasLiquidity(uint256 _amountToBorrow, address _debtToken)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _cTokenHasLiquidity(_debtToken, _amountToBorrow);\\n    }\\n\\n    function cTokenBalance(address _token) public view returns (uint256) {\\n        return ICToken(_getCToken(_token)).getCash();\\n    }\\n\\n    function compoundPositionWouldBeSafe(\\n        address _dsa,\\n        uint256 _colAmt,\\n        address _debtToken,\\n        uint256 _debtAmt\\n    ) public view returns (bool) {\\n        return _compoundPositionWillBeSafe(_dsa, _colAmt, _debtToken, _debtAmt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/compound/ConditionMakerToCompoundLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {DAI} from \\\"../../../../constants/CTokens.sol\\\";\\nimport {\\n    _cTokenHasLiquidity\\n} from \\\"../../../../functions/gelato/conditions/compound/FCompoundHasLiquidity.sol\\\";\\nimport {\\n    _getMaxAmtToBorrowMakerToCompound\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionMakerToCompoundLiquid is GelatoConditionsStandard {\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(uint256 _fromVaultId)\\n        public\\n        pure\\n        virtual\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodeWithSelector(\\n                this.cTokenHasLiquidity.selector,\\n                _fromVaultId\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        uint256 _fromVaultId = abi.decode(_conditionData[4:], (uint256));\\n\\n        return cTokenHasLiquidity(_fromVaultId);\\n    }\\n\\n    function cTokenHasLiquidity(uint256 _fromVaultId)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return\\n            _cTokenHasLiquidity(\\n                DAI,\\n                _getMaxAmtToBorrowMakerToCompound(\\n                    _fromVaultId,\\n                    IInstaFeeCollector(instaFeeCollector).fee(),\\n                    oracleAggregator\\n                )\\n            )\\n                ? OK\\n                : \\\"CompoundHasNotEnoughLiquidity\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/maker/ConditionMakerToMakerLiquid.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    _isDebtCeilingReached\\n} from \\\"../../../../functions/gelato/conditions/maker/FDebtCeilingIsReached.sol\\\";\\nimport {\\n    _getMaxAmtToBorrowMakerToMaker\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionMakerToMakerLiquid is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string calldata _destColType\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.isDebtCeilingReached.selector,\\n                _dsa,\\n                _fromVaultId,\\n                _destVaultId,\\n                _destColType\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            address _dsa,\\n            uint256 _fromVaultId,\\n            uint256 _destVaultId,\\n            string memory _destColType\\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\\n\\n        return\\n            isDebtCeilingReached(\\n                _dsa,\\n                _fromVaultId,\\n                _destVaultId,\\n                _destColType\\n            );\\n    }\\n\\n    function isDebtCeilingReached(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string memory _destColType\\n    ) public view returns (string memory) {\\n        return\\n            _isDebtCeilingReached(\\n                _dsa,\\n                _destVaultId,\\n                _destColType,\\n                _getMaxAmtToBorrowMakerToMaker(\\n                    _fromVaultId,\\n                    _destVaultId == 0,\\n                    IInstaFeeCollector(instaFeeCollector).fee(),\\n                    oracleAggregator\\n                )\\n            )\\n                ? \\\"MakerDebtCeilingReached\\\"\\n                : OK;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/maker/ConditionDebtAmtIsDust.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    _isDebtAmtDust\\n} from \\\"../../../../functions/gelato/conditions/maker/FIsDebtAmtDust.sol\\\";\\nimport {\\n    _getMakerVaultDebt,\\n    _isVaultOwner\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\n\\ncontract ConditionDebtAmtIsDust is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    function getConditionData(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string calldata _destColType\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.isDebtAmtDust.selector,\\n                _dsa,\\n                _fromVaultId,\\n                _destVaultId,\\n                _destColType\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (\\n            address _dsa,\\n            uint256 _fromVaultId,\\n            uint256 _destVaultId,\\n            string memory _destColType\\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\\n\\n        return isDebtAmtDust(_dsa, _fromVaultId, _destVaultId, _destColType);\\n    }\\n\\n    function isDebtAmtDust(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        uint256 _destVaultId,\\n        string memory _destColType\\n    ) public view returns (string memory) {\\n        return\\n            _isDebtAmtDust(\\n                _dsa,\\n                _destVaultId,\\n                _destColType,\\n                _getMakerVaultDebt(_fromVaultId)\\n            )\\n                ? \\\"DebtAmtIsDust\\\"\\n                : OK;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/resolvers/AaveResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {ILendingPool} from \\\"../../interfaces/dapps/Aave/ILendingPool.sol\\\";\\nimport {AaveUserData} from \\\"../../structs/SAave.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/dapps/IERC20.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {ILendingPool} from \\\"../../interfaces/dapps/Aave/ILendingPool.sol\\\";\\nimport {LENDING_POOL_ADDRESSES_PROVIDER} from \\\"../../constants/CAave.sol\\\";\\nimport {_getUserData} from \\\"../../functions/dapps/FAave.sol\\\";\\nimport {\\n    _isAaveLiquid\\n} from \\\"../../functions/gelato/conditions/aave/FAaveHasLiquidity.sol\\\";\\nimport {\\n    _aavePositionWillBeSafe\\n} from \\\"../../functions/gelato/conditions/aave/FAavePositionWillBeSafe.sol\\\";\\n\\ncontract AaveResolver {\\n    function getATokenUnderlyingBalance(address _underlying)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            IERC20(_underlying).balanceOf(\\n                ILendingPool(\\n                    ILendingPoolAddressesProvider(\\n                        LENDING_POOL_ADDRESSES_PROVIDER\\n                    )\\n                        .getLendingPool()\\n                )\\n                    .getReserveData(_underlying)\\n                    .aTokenAddress\\n            );\\n    }\\n\\n    function getPosition(address _dsa)\\n        public\\n        view\\n        returns (AaveUserData memory)\\n    {\\n        return _getUserData(_dsa);\\n    }\\n\\n    function hasLiquidity(address _debtToken, uint256 _debtAmt)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _isAaveLiquid(_debtToken, _debtAmt);\\n    }\\n\\n    function aavePositionWouldBeSafe(\\n        address _dsa,\\n        uint256 _colAmt,\\n        address _colToken,\\n        uint256 _debtAmt,\\n        address _oracleAggregator\\n    ) public view returns (bool) {\\n        return\\n            _aavePositionWillBeSafe(\\n                _dsa,\\n                _colAmt,\\n                _colToken,\\n                _debtAmt,\\n                _oracleAggregator\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/aave/ConditionMakerToAaveLiquid.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {GelatoBytes} from \\\"../../../../lib/GelatoBytes.sol\\\";\\nimport {\\n    _isAaveLiquid\\n} from \\\"../../../../functions/gelato/conditions/aave/FAaveHasLiquidity.sol\\\";\\nimport {DAI} from \\\"../../../../constants/CTokens.sol\\\";\\nimport {\\n    _getMaxAmtToBorrowMakerToAave\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionMakerToAaveLiquid is GelatoConditionsStandard {\\n    using GelatoBytes for bytes;\\n\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(uint256 _fromVaultId)\\n        public\\n        pure\\n        virtual\\n        returns (bytes memory)\\n    {\\n        return abi.encodeWithSelector(this.hasLiquidity.selector, _fromVaultId);\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        uint256 _fromVaultId = abi.decode(_conditionData[4:], (uint256));\\n\\n        return hasLiquidity(_fromVaultId);\\n    }\\n\\n    function hasLiquidity(uint256 _fromVaultId)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return\\n            _isAaveLiquid(\\n                DAI,\\n                _getMaxAmtToBorrowMakerToAave(\\n                    _fromVaultId,\\n                    IInstaFeeCollector(instaFeeCollector).fee(),\\n                    oracleAggregator\\n                )\\n            )\\n                ? OK\\n                : \\\"AaveIlliquid\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/conditions/aave/ConditionMakerToAaveSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    GelatoConditionsStandard\\n} from \\\"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\\\";\\nimport {\\n    _aavePositionWillBeSafe\\n} from \\\"../../../../functions/gelato/conditions/aave/FAavePositionWillBeSafe.sol\\\";\\nimport {\\n    _getMakerVaultCollateralBalance\\n} from \\\"../../../../functions/dapps/FMaker.sol\\\";\\nimport {\\n    _getMaxAmtToBorrowMakerToAave\\n} from \\\"../../../../functions/gelato/FGelatoDebtBridge.sol\\\";\\nimport {\\n    IInstaFeeCollector\\n} from \\\"../../../../interfaces/InstaDapp/IInstaFeeCollector.sol\\\";\\n\\ncontract ConditionMakerToAaveSafe is GelatoConditionsStandard {\\n    address public immutable instaFeeCollector;\\n    address public immutable oracleAggregator;\\n\\n    constructor(address _instaFeeCollector, address _oracleAggregator) {\\n        instaFeeCollector = _instaFeeCollector;\\n        oracleAggregator = _oracleAggregator;\\n    }\\n\\n    function getConditionData(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        address _colToken\\n    ) public pure virtual returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                this.aavePositionWillBeSafe.selector,\\n                _dsa,\\n                _fromVaultId,\\n                _colToken\\n            );\\n    }\\n\\n    function ok(\\n        uint256,\\n        bytes calldata _conditionData,\\n        uint256\\n    ) public view virtual override returns (string memory) {\\n        (address _dsa, uint256 _fromVaultId, address _colToken) =\\n            abi.decode(_conditionData[4:], (address, uint256, address));\\n\\n        return aavePositionWillBeSafe(_dsa, _fromVaultId, _colToken);\\n    }\\n\\n    function aavePositionWillBeSafe(\\n        address _dsa,\\n        uint256 _fromVaultId,\\n        address _colToken\\n    ) public view returns (string memory) {\\n        return\\n            _aavePositionWillBeSafe(\\n                _dsa,\\n                _getMakerVaultCollateralBalance(_fromVaultId),\\n                _colToken,\\n                _getMaxAmtToBorrowMakerToAave(\\n                    _fromVaultId,\\n                    IInstaFeeCollector(instaFeeCollector).fee(),\\n                    oracleAggregator\\n                ),\\n                oracleAggregator\\n            )\\n                ? OK\\n                : \\\"AavePositionWillNotBeSafe\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/gelato/MockDebtBridgeExecutorETHB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// import \\\"hardhat/console.sol\\\"; // Uncomment this line for using gasLeft Method\\nimport {\\n    TaskReceipt\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoCore\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoExecutors\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\\\";\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\n\\n/// @dev Automatic gas-reporting for Debt Bridge use case\\n//   via hardhat-gas-reporter\\ncontract MockDebtBridgeExecutorETHB {\\n    using GelatoBytes for bytes;\\n    address public gelatoCore;\\n\\n    constructor(address _gelatoCore) payable {\\n        gelatoCore = _gelatoCore;\\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\\n    }\\n\\n    function canExec(\\n        TaskReceipt calldata _taskReceipt,\\n        uint256 _gasLimit,\\n        uint256 _execTxGasPrice\\n    ) external view returns (string memory) {\\n        return\\n            IGelatoCore(gelatoCore).canExec(\\n                _taskReceipt,\\n                _gasLimit,\\n                _execTxGasPrice\\n            );\\n    }\\n\\n    function exec(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost for Task Execution %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute0: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute0AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute0AndOpenVault: %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n\\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute1: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute1AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute1AndOpenVault: %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n\\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute2: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute2AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute2AndOpenVault %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n\\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute3: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute3AndOpenVault(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\n        //     \\\"Gas Cost execViaRoute3AndOpenVAult: %s\\\",\\n        //     gasLeft - gasleft()\\n        // );\\n    }\\n}\\n\"\r\n    },\r\n    \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity >=0.6.10;\\n\\ninterface IGelatoExecutors {\\n    event LogExecutorStaked(address indexed executor, uint256 oldStake, uint256 newStake);\\n    event LogExecutorUnstaked(address indexed executor);\\n\\n    event LogExecutorBalanceWithdrawn(\\n        address indexed executor,\\n        uint256 withdrawAmount\\n    );\\n\\n    /// @notice Stake on Gelato to become a whitelisted executor\\n    /// @dev Msg.value has to be >= minExecutorStake\\n    function stakeExecutor() external payable;\\n\\n    /// @notice Unstake on Gelato to become de-whitelisted and withdraw minExecutorStake\\n    function unstakeExecutor() external;\\n\\n    /// @notice Re-assigns multiple providers to other executors\\n    /// @dev Executors must re-assign all providers before being able to unstake\\n    /// @param _providers List of providers to re-assign\\n    /// @param _newExecutor Address of new executor to assign providers to\\n    function multiReassignProviders(address[] calldata _providers, address _newExecutor)\\n        external;\\n\\n\\n    /// @notice Withdraw excess Execur Stake\\n    /// @dev Can only be called if executor is isExecutorMinStaked\\n    /// @param _withdrawAmount Amount to withdraw\\n    /// @return Amount that was actually withdrawn\\n    function withdrawExcessExecutorStake(uint256 _withdrawAmount) external returns(uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/gelato/MockDebtBridgeExecutorCompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// import \\\"hardhat/console.sol\\\"; // Uncomment this line for using gasLeft Method\\nimport {\\n    TaskReceipt\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoCore\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoExecutors\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\\\";\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\n\\n/// @dev Automatic gas-reporting for Debt Bridge use case\\n//   via hardhat-gas-reporter\\ncontract MockDebtBridgeExecutorCompound {\\n    using GelatoBytes for bytes;\\n    address public gelatoCore;\\n\\n    constructor(address _gelatoCore) payable {\\n        gelatoCore = _gelatoCore;\\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\\n    }\\n\\n    function canExec(\\n        TaskReceipt calldata _taskReceipt,\\n        uint256 _gasLimit,\\n        uint256 _execTxGasPrice\\n    ) external view returns (string memory) {\\n        return\\n            IGelatoCore(gelatoCore).canExec(\\n                _taskReceipt,\\n                _gasLimit,\\n                _execTxGasPrice\\n            );\\n    }\\n\\n    function stakeExecutor() external payable {\\n        IGelatoExecutors(gelatoCore).stakeExecutor();\\n    }\\n\\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute0: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute1: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute2: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute3: %s\\\", gasLeft - gasleft());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/gelato/MockDebtBridgeExecutorAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// import \\\"hardhat/console.sol\\\"; // Uncomment this line for using gasLeft Method\\nimport {\\n    TaskReceipt\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoCore\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\\\";\\nimport {\\n    IGelatoExecutors\\n} from \\\"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\\\";\\nimport {GelatoBytes} from \\\"../../lib/GelatoBytes.sol\\\";\\n\\n/// @dev Automatic gas-reporting for Debt Bridge use case\\n//   via hardhat-gas-reporter\\ncontract MockDebtBridgeExecutorAave {\\n    using GelatoBytes for bytes;\\n    address public gelatoCore;\\n\\n    constructor(address _gelatoCore) payable {\\n        gelatoCore = _gelatoCore;\\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\\n    }\\n\\n    function canExec(\\n        TaskReceipt calldata _taskReceipt,\\n        uint256 _gasLimit,\\n        uint256 _execTxGasPrice\\n    ) external view returns (string memory) {\\n        return\\n            IGelatoCore(gelatoCore).canExec(\\n                _taskReceipt,\\n                _gasLimit,\\n                _execTxGasPrice\\n            );\\n    }\\n\\n    function stakeExecutor() external payable {\\n        IGelatoExecutors(gelatoCore).stakeExecutor();\\n    }\\n\\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute0: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute1: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute2: %s\\\", gasLeft - gasleft());\\n    }\\n\\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\\n        // uint256 gasLeft = gasleft();\\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\\n        // console.log(\\\"Gas Cost execViaRoute3: %s\\\", gasLeft - gasleft());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/gelato/MockFGelatoDebtBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    _getFlashLoanRoute,\\n    _getGasCostMakerToMaker,\\n    _getGasCostMakerToCompound,\\n    _getRealisedDebt\\n} from \\\"../../functions/gelato/FGelatoDebtBridge.sol\\\";\\n\\ncontract FGelatoDebtBridgeMock {\\n    function getFlashLoanRoute(address _tokenA, uint256 _tokenADebtToMove)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getFlashLoanRoute(_tokenA, _tokenADebtToMove);\\n    }\\n\\n    function getGasCostMakerToMaker(bool _newVault, uint256 _route)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _getGasCostMakerToMaker(_newVault, _route);\\n    }\\n\\n    function getGasCostMakerToCompound(uint256 _route)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _getGasCostMakerToCompound(_route);\\n    }\\n\\n    function getRealisedDebt(uint256 _debtToMove)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _getRealisedDebt(_debtToMove);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/__mocks__/vendor/SelfDesruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ncontract SelfDestruct {\\n    function selfdest(address payable _transferTo) public payable {\\n        selfdestruct(_transferTo);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/gelato/ProviderModuleDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\n// solhint-disable\\n\\nenum Operation {Call, Delegatecall}\\n\\nenum DataFlow {None, In, Out, InAndOut}\\n\\ninterface IGelatoCondition {\\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\\n    ///  \\\"ok\\\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\\n    ///  source of Task identification.\\n    /// @param _conditionData This is the Condition.data field developers must encode their\\n    ///  Condition's specific parameters in.\\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\\n    function ok(\\n        uint256 _taskReceiptId,\\n        bytes calldata _conditionData,\\n        uint256 _cycleId\\n    ) external view returns (string memory);\\n}\\n\\nstruct Condition {\\n    IGelatoCondition inst; // can be AddressZero for self-conditional Actions\\n    bytes data; // can be bytes32(0) for self-conditional Actions\\n}\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions; // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit; // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil; // optional: 0 defaults to NO_CEIL\\n}\\n\\ninterface IGelatoProviderModule {\\n    /// @notice Check if provider agrees to pay for inputted task receipt\\n    /// @dev Enables arbitrary checks by provider\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @return \\\"OK\\\" if provider agrees\\n    function isProvided(\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task\\n    ) external view returns (string memory);\\n\\n    /// @notice Convert action specific payload into proxy specific payload\\n    /// @dev Encoded multiple actions into a multisend\\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\\n    /// @param _provider The account of the Provider who uses the ProviderModule.\\n    /// @param _task Gelato Task to be executed.\\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\\n    /// @return Encoded payload that will be used for low-level .call on user proxy\\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\\n    function execPayload(\\n        uint256 _taskReceiptId,\\n        address _userProxy,\\n        address _provider,\\n        Task calldata _task,\\n        uint256 _cycleId\\n    ) external view returns (bytes memory, bool checkReturndata);\\n\\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\\n}\\n\\nabstract contract GelatoProviderModuleStandard is IGelatoProviderModule {\\n    string internal constant OK = \\\"OK\\\";\\n\\n    function isProvided(\\n        address,\\n        address,\\n        Task calldata\\n    ) external view virtual override returns (string memory) {\\n        return OK;\\n    }\\n\\n    /// @dev Overriding fns should revert with the revertMsg they detected on the userProxy\\n    function execRevertCheck(bytes calldata) external pure virtual override {\\n        // By default no reverts detected => do nothing\\n    }\\n}\\n\\n/// @dev InstaDapp Index\\ninterface IndexInterface {\\n    function connectors(uint256 version) external view returns (address);\\n\\n    function list() external view returns (address);\\n}\\n\\n/// @dev InstaDapp List\\ninterface ListInterface {\\n    function accountID(address _account) external view returns (uint64);\\n}\\n\\n/// @dev InstaDapp Connectors\\ninterface ConnectorsInterface {\\n    function isConnector(address[] calldata logicAddr)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isStaticConnector(address[] calldata logicAddr)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\n/// @dev InstaDapp Defi Smart Account wallet\\ninterface AccountInterface {\\n    function version() external view returns (uint256);\\n\\n    function isAuth(address user) external view returns (bool);\\n\\n    function shield() external view returns (bool);\\n\\n    function cast(\\n        address[] calldata _targets,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32[] memory responses);\\n}\\n\\ncontract ProviderModuleDSA is GelatoProviderModuleStandard {\\n    IndexInterface public immutable index;\\n    address public immutable gelatoCore;\\n\\n    constructor(IndexInterface _index, address _gelatoCore) {\\n        index = _index;\\n        gelatoCore = _gelatoCore;\\n    }\\n\\n    // ================= GELATO PROVIDER MODULE STANDARD ================\\n    function isProvided(\\n        address _userProxy,\\n        address,\\n        Task calldata\\n    ) external view override returns (string memory) {\\n        // Verify InstaDapp account identity\\n        if (ListInterface(index.list()).accountID(_userProxy) == 0)\\n            return \\\"ProviderModuleDSA.isProvided:InvalidUserProxy\\\";\\n\\n        // Is GelatoCore authorized\\n        if (!AccountInterface(_userProxy).isAuth(gelatoCore))\\n            return \\\"ProviderModuleDSA.isProvided:GelatoCoreNotAuth\\\";\\n\\n        // @dev commented out for gas savings\\n\\n        // // Is connector valid\\n        // ConnectorsInterface connectors = ConnectorsInterface(index.connectors(\\n        //     AccountInterface(_userProxy).version()\\n        // ));\\n\\n        // address[] memory targets = new address[](_task.actions.length);\\n        // for (uint i = 0; i < _task.actions.length; i++)\\n        //     targets[i] = _task.actions[i].addr;\\n\\n        // bool isShield = AccountInterface(_userProxy).shield();\\n        // if (isShield)\\n        //     if (!connectors.isStaticConnector(targets))\\n        //         return \\\"ProviderModuleDSA.isProvided:not-static-connector\\\";\\n        // else\\n        //     if (!connectors.isConnector(targets))\\n        //         return \\\"ProviderModuleDSA.isProvided:not-connector\\\";\\n\\n        return OK;\\n    }\\n\\n    /// @dev DS PROXY ONLY ALLOWS DELEGATE CALL for single actions, that's why we also use multisend\\n    function execPayload(\\n        uint256,\\n        address,\\n        address,\\n        Task calldata _task,\\n        uint256\\n    ) external view override returns (bytes memory payload, bool) {\\n        address[] memory targets = new address[](_task.actions.length);\\n        for (uint256 i = 0; i < _task.actions.length; i++)\\n            targets[i] = _task.actions[i].addr;\\n\\n        bytes[] memory datas = new bytes[](_task.actions.length);\\n        for (uint256 i = 0; i < _task.actions.length; i++)\\n            datas[i] = _task.actions[i].data;\\n\\n        payload = abi.encodeWithSelector(\\n            AccountInterface.cast.selector,\\n            targets,\\n            datas,\\n            gelatoCore\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/Instadapp/connectors/ConnectGelato.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.0;\\n\\n// solhint-disable\\n\\n// Gelato Data Types\\nstruct Provider {\\n    address addr; //  if msg.sender == provider => self-Provider\\n    address module; //  e.g. DSA Provider Module\\n}\\n\\nstruct Condition {\\n    address inst; // can be AddressZero for self-conditional Actions\\n    bytes data; // can be bytes32(0) for self-conditional Actions\\n}\\n\\nenum Operation {Call, Delegatecall}\\n\\nenum DataFlow {None, In, Out, InAndOut}\\n\\nstruct Action {\\n    address addr;\\n    bytes data;\\n    Operation operation;\\n    DataFlow dataFlow;\\n    uint256 value;\\n    bool termsOkCheck;\\n}\\n\\nstruct Task {\\n    Condition[] conditions; // optional\\n    Action[] actions;\\n    uint256 selfProviderGasLimit; // optional: 0 defaults to gelatoMaxGas\\n    uint256 selfProviderGasPriceCeil; // optional: 0 defaults to NO_CEIL\\n}\\n\\nstruct TaskReceipt {\\n    uint256 id;\\n    address userProxy;\\n    Provider provider;\\n    uint256 index;\\n    Task[] tasks;\\n    uint256 expiryDate;\\n    uint256 cycleId; // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\\n    uint256 submissionsLeft;\\n}\\n\\nstruct TaskSpec {\\n    address[] conditions; // Address: optional AddressZero for self-conditional actions\\n    Action[] actions;\\n    uint256 gasPriceCeil;\\n}\\n\\n// Gelato Interface\\ninterface IGelatoInterface {\\n    /**\\n     * @dev API to submit a single Task.\\n     */\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    ) external;\\n\\n    /**\\n     * @dev A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\\n     * the next one, after they have been executed, where the total number of tasks can\\n     * be only be an even number\\n     */\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    ) external;\\n\\n    /**\\n     * @dev A Gelato Task Chain consists of 1 or more Tasks that automatically submit\\n     * the next one, after they have been executed, where the total number of tasks can\\n     * be an odd number\\n     */\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    ) external;\\n\\n    /**\\n     * @dev Cancel multiple tasks at once\\n     */\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\\n\\n    /**\\n     * @dev Whitelist new executor, TaskSpec(s) and Module(s) in one tx\\n     */\\n    function multiProvide(\\n        address _executor,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules\\n    ) external payable;\\n\\n    /**\\n     * @dev De-Whitelist TaskSpec(s), Module(s) and withdraw funds from gelato in one tx\\n     */\\n    function multiUnprovide(\\n        uint256 _withdrawAmount,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules\\n    ) external;\\n}\\n\\ninterface MemoryInterface {\\n    function setUint(uint256 _id, uint256 _val) external;\\n\\n    function getUint(uint256 _id) external returns (uint256);\\n}\\n\\nabstract contract Helpers {\\n    uint256 internal immutable _id;\\n\\n    constructor(uint256 id) {\\n        _id = id;\\n    }\\n\\n    /**\\n     * @dev Return Memory Variable Address\\n     */\\n    function getMemoryAddr() internal pure returns (address) {\\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\\n    }\\n\\n    /**\\n     * @dev Set Uint value in InstaMemory Contract.\\n     */\\n    function setUint(uint256 setId, uint256 val) internal {\\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\\n    }\\n\\n    /**\\n     * @dev Get Uint value from InstaMemory Contract.\\n     */\\n    function getUint(uint256 getId, uint256 val)\\n        internal\\n        returns (uint256 returnVal)\\n    {\\n        returnVal = getId == 0\\n            ? val\\n            : MemoryInterface(getMemoryAddr()).getUint(getId);\\n    }\\n\\n    /**\\n     * @dev Connector Details\\n     */\\n    function connectorID() public view returns (uint256 _type, uint256 id) {\\n        (_type, id) = (1, _id);\\n    }\\n}\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"math-not-safe\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"sub-overflow\\\");\\n    }\\n}\\n\\nabstract contract GelatoHelpers is Helpers, DSMath {\\n    /**\\n     * @dev Return Gelato Core Address\\n     */\\n    function getGelatoCoreAddr() internal pure returns (address) {\\n        return 0x025030BdAa159f281cAe63873E68313a703725A5; // Gelato Core address\\n    }\\n\\n    /**\\n     * @dev Return Instapp DSA Provider Module Address\\n     */\\n    function getInstadappProviderModuleAddr() internal pure returns (address) {\\n        return 0x0C25452d20cdFeEd2983fa9b9b9Cf4E81D6f2fE2; // ProviderModuleDSA Address\\n    }\\n}\\n\\nabstract contract GelatoResolver is GelatoHelpers {\\n    event LogMultiProvide(\\n        address indexed executor,\\n        TaskSpec[] indexed taskspecs,\\n        address[] indexed modules,\\n        uint256 ethToDeposit,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event LogSubmitTask(\\n        Provider indexed provider,\\n        Task indexed task,\\n        uint256 indexed expiryDate,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event LogSubmitTaskCycle(\\n        Provider indexed provider,\\n        Task[] indexed tasks,\\n        uint256 indexed expiryDate,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event LogSubmitTaskChain(\\n        Provider indexed provider,\\n        Task[] indexed tasks,\\n        uint256 indexed expiryDate,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event LogMultiUnprovide(\\n        TaskSpec[] indexed taskspecs,\\n        address[] indexed modules,\\n        uint256 ethToWithdraw,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event LogMultiCancelTasks(\\n        TaskReceipt[] indexed taskReceipt,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    // ===== Gelato ENTRY APIs ======\\n\\n    /**\\n     * @dev Enables first time users to  pre-fund eth, whitelist an executor & register the\\n     * ProviderModuleDSA.sol to be able to use Gelato\\n     * @param _executor address of single execot node or gelato'S decentralized execution market\\n     * @param _taskSpecs enables external providers to whitelist TaskSpecs on gelato\\n     * @param _modules address of ProviderModuleDSA\\n     * @param _ethToDeposit amount of eth to deposit on Gelato, only for self-providers\\n     */\\n    function multiProvide(\\n        address _executor,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules,\\n        uint256 _ethToDeposit,\\n        uint256 _getId,\\n        uint256 _setId\\n    ) external payable {\\n        uint256 ethToDeposit = getUint(_getId, _ethToDeposit);\\n        ethToDeposit = ethToDeposit == type(uint256).max\\n            ? address(this).balance\\n            : ethToDeposit;\\n\\n        IGelatoInterface(getGelatoCoreAddr()).multiProvide{value: ethToDeposit}(\\n            _executor,\\n            _taskSpecs,\\n            _modules\\n        );\\n\\n        setUint(_setId, ethToDeposit);\\n\\n        emit LogMultiProvide(\\n            _executor,\\n            _taskSpecs,\\n            _modules,\\n            ethToDeposit,\\n            _getId,\\n            _setId\\n        );\\n    }\\n\\n    /**\\n     * @dev Submits a single, one-time task to Gelato\\n     * @param _provider Consists of proxy module address (DSA) and provider address ()\\n     * who will pay for the transaction execution\\n     * @param _task Task specifying the condition and the action connectors\\n     * @param _expiryDate Default 0, othweise timestamp after which the task expires\\n     */\\n    function submitTask(\\n        Provider calldata _provider,\\n        Task calldata _task,\\n        uint256 _expiryDate\\n    ) external payable {\\n        IGelatoInterface(getGelatoCoreAddr()).submitTask(\\n            _provider,\\n            _task,\\n            _expiryDate\\n        );\\n\\n        emit LogSubmitTask(_provider, _task, _expiryDate, 0, 0);\\n    }\\n\\n    /**\\n     * @dev Submits single or mulitple Task Sequences to Gelato\\n     * @param _provider Consists of proxy module address (DSA) and provider address ()\\n     * who will pay for the transaction execution\\n     * @param _tasks A sequence of Tasks, can be a single or multiples\\n     * @param _expiryDate Default 0, othweise timestamp after which the task expires\\n     * @param _cycles How often the Task List should be executed, e.g. 5 times\\n     */\\n    function submitTaskCycle(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _cycles\\n    ) external payable {\\n        IGelatoInterface(getGelatoCoreAddr()).submitTaskCycle(\\n            _provider,\\n            _tasks,\\n            _expiryDate,\\n            _cycles\\n        );\\n\\n        emit LogSubmitTaskCycle(_provider, _tasks, _expiryDate, 0, 0);\\n    }\\n\\n    /**\\n     * @dev Submits single or mulitple Task Chains to Gelato\\n     * @param _provider Consists of proxy module address (DSA) and provider address ()\\n     * who will pay for the transaction execution\\n     * @param _tasks A sequence of Tasks, can be a single or multiples\\n     * @param _expiryDate Default 0, othweise timestamp after which the task expires\\n     * @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\\n     * that should have occured once the cycle is complete\\n     */\\n    function submitTaskChain(\\n        Provider calldata _provider,\\n        Task[] calldata _tasks,\\n        uint256 _expiryDate,\\n        uint256 _sumOfRequestedTaskSubmits\\n    ) external payable {\\n        IGelatoInterface(getGelatoCoreAddr()).submitTaskChain(\\n            _provider,\\n            _tasks,\\n            _expiryDate,\\n            _sumOfRequestedTaskSubmits\\n        );\\n\\n        emit LogSubmitTaskChain(_provider, _tasks, _expiryDate, 0, 0);\\n    }\\n\\n    // ===== Gelato EXIT APIs ======\\n\\n    /**\\n     * @dev Withdraws funds from Gelato, de-whitelists TaskSpecs and Provider Modules\\n     * in one tx\\n     * @param _withdrawAmount Amount of ETH to withdraw from Gelato\\n     * @param _taskSpecs List of Task Specs to de-whitelist, default empty []\\n     * @param _modules List of Provider Modules to de-whitelist, default empty []\\n     */\\n    function multiUnprovide(\\n        uint256 _withdrawAmount,\\n        TaskSpec[] calldata _taskSpecs,\\n        address[] calldata _modules,\\n        uint256 _getId,\\n        uint256 _setId\\n    ) external payable {\\n        uint256 withdrawAmount = getUint(_getId, _withdrawAmount);\\n        uint256 balanceBefore = address(this).balance;\\n\\n        IGelatoInterface(getGelatoCoreAddr()).multiUnprovide(\\n            withdrawAmount,\\n            _taskSpecs,\\n            _modules\\n        );\\n\\n        uint256 actualWithdrawAmount =\\n            sub(address(this).balance, balanceBefore);\\n\\n        setUint(_setId, actualWithdrawAmount);\\n\\n        emit LogMultiUnprovide(\\n            _taskSpecs,\\n            _modules,\\n            actualWithdrawAmount,\\n            _getId,\\n            _setId\\n        );\\n    }\\n\\n    /**\\n     * @dev Cancels outstanding Tasks\\n     * @param _taskReceipts List of Task Receipts to cancel\\n     */\\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts)\\n        external\\n        payable\\n    {\\n        IGelatoInterface(getGelatoCoreAddr()).multiCancelTasks(_taskReceipts);\\n\\n        emit LogMultiCancelTasks(_taskReceipts, 0, 0);\\n    }\\n}\\n\\ncontract ConnectGelato is GelatoResolver {\\n    string public name = \\\"ConnectGelato-v2.0\\\";\\n\\n    constructor(uint256 _id) Helpers(_id) {}\\n}\\n\"\r\n    },\r\n    \"contracts/functions/InstaDapp/connectors/FConnectFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {\\n    IConnectFee\\n} from \\\"../../../interfaces/InstaDapp/connectors/IConnectFee.sol\\\";\\n\\nfunction _encodeCalculateFee(\\n    uint256 _amount,\\n    uint256 _fee,\\n    uint256 _getId,\\n    uint256 _setId,\\n    uint256 _setIdFee\\n) pure returns (bytes memory) {\\n    return\\n        abi.encodeWithSelector(\\n            IConnectFee.calculateFee.selector,\\n            _amount,\\n            _fee,\\n            _getId,\\n            _setId,\\n            _setIdFee\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectFee {\\n    function calculateFee(\\n        uint256 _amount,\\n        uint256 _fee,\\n        uint256 _getId,\\n        uint256 _setId,\\n        uint256 _setIdFee\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Aave/IAavePriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IAavePriceOracle {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n\\n    function getAssetsPrices(address[] calldata _assets)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function getSourceOfAsset(address _asset) external view returns (uint256);\\n\\n    function getFallbackOracle() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Chainlink/IAggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IAggregatorV3Interface {\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundID,\\n            int256 price,\\n            uint256 startedAt,\\n            uint256 timeStamp,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestAnswer() external view returns (int256);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Dydx/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nstruct Price {\\n    uint256 value;\\n}\\n\\nstruct Value {\\n    uint256 value;\\n}\\n\\ninterface IPriceOracle {\\n    /**\\n     * Get the price of a token\\n     *\\n     * @param  token  The ERC20 token address of the market\\n     * @return        The USD price of a base unit of the token, then multiplied by 10^36.\\n     *                So a USD-stable coin with 18 decimal places would return 10^18.\\n     *                This is the price of the base unit rather than the price of a \\\"human-readable\\\"\\n     *                token amount. Every ERC20 may have a different number of decimals.\\n     */\\n    function getPrice(address token) external view returns (Price memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/dapps/Dydx/ISoloMargin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {IPriceOracle, Price, Value} from \\\"./IPriceOracle.sol\\\";\\n\\nstruct Index {\\n    uint96 borrow;\\n    uint96 supply;\\n    uint32 lastUpdate;\\n}\\n\\nstruct MarketInfo {\\n    Price price;\\n    Index index;\\n}\\nstruct Par {\\n    bool sign;\\n    uint128 value;\\n}\\n\\nstruct Wei {\\n    bool sign;\\n    uint256 value;\\n}\\n\\ninterface ISoloMargin {\\n    function getMarginRatio() external view returns (uint256);\\n\\n    function getMarketPriceOracle(uint256 _marketId)\\n        external\\n        view\\n        returns (IPriceOracle);\\n\\n    function getMarketTokenAddress(uint256 _marketId)\\n        external\\n        view\\n        returns (address);\\n\\n    function getNumMarkets() external view returns (uint256);\\n\\n    function getMarketPrice(uint256 _marketId)\\n        external\\n        view\\n        returns (Price memory);\\n\\n    function getMarketCurrentIndex(uint256 _marketId)\\n        external\\n        view\\n        returns (Index memory);\\n\\n    function getAccountPar(address _account, uint256 _m)\\n        external\\n        view\\n        returns (Par memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InstaDapp/connectors/IConnectDydx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IConnectDydx {\\n    function borrow(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n\\n    function deposit(\\n        address token,\\n        uint256 amt,\\n        uint256 getId,\\n        uint256 setId\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nlibrary GelatoString {\\n    function startsWithOK(string memory _str) internal pure returns (bool) {\\n        if (\\n            bytes(_str).length >= 2 &&\\n            bytes(_str)[0] == \\\"O\\\" &&\\n            bytes(_str)[1] == \\\"K\\\"\\n        ) return true;\\n        return false;\\n    }\\n\\n    function revertWithInfo(string memory _error, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        revert(string(abi.encodePacked(_tracingInfo, _error)));\\n    }\\n\\n    function returnWithInfo(string memory _error, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_tracingInfo, _error));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(\\n            !(a == -1 && b == _INT256_MIN),\\n            \\\"SignedSafeMath: multiplication overflow\\\"\\n        );\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(\\n            !(b == -1 && a == _INT256_MIN),\\n            \\\"SignedSafeMath: division overflow\\\"\\n        );\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require(\\n            (b >= 0 && c <= a) || (b < 0 && c > a),\\n            \\\"SignedSafeMath: subtraction overflow\\\"\\n        );\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require(\\n            (b >= 0 && c >= a) || (b < 0 && c < a),\\n            \\\"SignedSafeMath: addition overflow\\\"\\n        );\\n\\n        return c;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"__id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracleAggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__instaFeeCollector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__connectGelatoDebtBridgeFee\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OK\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectGelatoDataFromMakerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_colToken\",\"type\":\"address\"}],\"name\":\"getDataAndCastMakerToCompound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instaFeeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAggregator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dsa\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_actionData\",\"type\":\"bytes\"},{\"internalType\":\"enum DataFlow\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"termsOk\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectGelatoDataMakerToCompound","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000005000000000000000000000000064f31d46c52bbde223d863b11dab9327ab1414e90000000000000000000000000c159985e905ea1a3da7305d70583dd618862cf40000000000000000000000009b6eeb49390626dec7b3785d38879746923b308e","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3de76218f003464d0f3e98d9b9afc343cc7d375f4212f204e4f27f9dfb9cd244"}]}