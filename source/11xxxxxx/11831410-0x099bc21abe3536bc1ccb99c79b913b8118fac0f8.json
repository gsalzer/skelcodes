{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n                                       `.-:+osyhhhhhhyso+:-.`\r\n                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\r\n                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\r\n                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\r\n                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\r\n                         `omNNNNNNdo-`                        `-odNNNNNNmo`\r\n                        :dNNNNNNh/`                              `/hNNNNNNd:\r\n                      `oNNNNNNh:                     /-/.           :hNNNNNNo`\r\n                     `yNNNNNm+`                      mNNm-           `+mNNNNNy`\r\n                    `hNNNNNd-                        hNNNm.            -dNNNNNh`\r\n                    yNNNNNd.                         .ymNNh             .dNNNNNy\r\n                   /NNNNNm.                            -mNNys+.          .mNNNNN/\r\n                  `mNNNNN:                           `:hNNNNNNNs`         :NNNNNm`\r\n                  /NNNNNh                          `+dNNNNNNNNNNd.         hNNNNN/\r\n                  yNNNNN/               .:+syyhhhhhmNNNNNNNNNNNNNm`        /NNNNNy\r\n                  dNNNNN.            `+dNNNNNNNNNNNNNNNNNNNNNNNmd+         .NNNNNd\r\n                  mNNNNN`           -dNNNNNNNNNNNNNNNNNNNNNNm-             `NNNNNm\r\n                  dNNNNN.          -NNNNNNNNNNNNNNNNNNNNNNNN+              .NNNNNd\r\n                  yNNNNN/          dNNNNNNNNNNNNNNNNNNNNNNNN:              /NNNNNy\r\n                  /NNNNNh         .NNNNNNNNNNNNNNNNNNNNNNNNd`              hNNNNN/\r\n                  `mNNNNN:        -NNNNNNNNNNNNNNNNNNNNNNNh.              :NNNNNm`\r\n                   /NNNNNm.       `NNNNNNNNNNNNNNNNNNNNNh:               .mNNNNN/\r\n                    yNNNNNd.      .yNNNNNNNNNNNNNNNdmNNN/               .dNNNNNy\r\n                    `hNNNNNd-    `dmNNNNNNNNNNNNdo-`.hNNh              -dNNNNNh`\r\n                     `yNNNNNm+`   oNNmmNNNNNNNNNy.   `sNNdo.         `+mNNNNNy`\r\n                      `oNNNNNNh:   ....++///+++++.     -+++.        :hNNNNNNo`\r\n                        :dNNNNNNh/`                              `/hNNNNNNd:\r\n                         `omNNNNNNdo-`                        `-odNNNNNNmo`\r\n                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\r\n                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\r\n                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\r\n                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\r\n                                       `.-:+yourewelcome+:-.`\r\n /$$$$$$$  /$$                                               /$$      /$$\r\n| $$__  $$| $$                                              | $$$    /$$$\r\n| $$  \\ $$| $$  /$$$$$$  /$$   /$$ /$$   /$$  /$$$$$$$      | $$$$  /$$$$  /$$$$$$  /$$$$$$$   /$$$$$$  /$$   /$$\r\n| $$$$$$$/| $$ /$$__  $$|  $$ /$$/| $$  | $$ /$$_____/      | $$ $$/$$ $$ /$$__  $$| $$__  $$ /$$__  $$| $$  | $$\r\n| $$____/ | $$| $$$$$$$$ \\  $$$$/ | $$  | $$|  $$$$$$       | $$  $$$| $$| $$  \\ $$| $$  \\ $$| $$$$$$$$| $$  | $$\r\n| $$      | $$| $$_____/  >$$  $$ | $$  | $$ \\____  $$      | $$\\  $ | $$| $$  | $$| $$  | $$| $$_____/| $$  | $$\r\n| $$      | $$|  $$$$$$$ /$$/\\  $$|  $$$$$$/ /$$$$$$$/      | $$ \\/  | $$|  $$$$$$/| $$  | $$|  $$$$$$$|  $$$$$$$\r\n|__/      |__/ \\_______/|__/  \\__/ \\______/ |_______/       |__/     |__/ \\______/ |__/  |__/ \\_______/ \\____  $$\r\n                                                                                                        /$$  | $$\r\n                                                                                                       |  $$$$$$/\r\n                                                                                                       \\______/\r\n*/\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface WrappedETH {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n\r\n}\r\n\r\ninterface UniswapFactory{\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface LPERC20{\r\n\r\n    function token0() external view returns(address);\r\n    function token1() external view returns(address);\r\n}\r\n\r\n\r\n\r\ninterface SushiV2{\r\n\r\n\r\n   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\r\n   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\r\n   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\r\n   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\r\n\r\n   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract WrapAndUnWrap{\r\n\r\n  using SafeMath\r\n    for uint256;\r\n\r\n  address payable public owner;\r\n  //placehodler token address for specifying eth tokens\r\n  address public ETH_TOKEN_ADDRESS  = address(0x0);\r\n  address public WETH_TOKEN_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  WrappedETH wethToken = WrappedETH(WETH_TOKEN_ADDRESS);\r\n  uint256 approvalAmount = 1000000000000000000000000000000;\r\n  uint256 longTimeFromNow = 1000000000000000000000000000;\r\n  address sushiAddress = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\r\n  address uniFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n  SushiV2 sushiExchange = SushiV2(sushiAddress);\r\n  UniswapFactory factory = UniswapFactory(uniFactoryAddress);\r\n  mapping (address => address[]) public lpTokenAddressToPairs;\r\n  mapping(string=>address) public stablecoins;\r\n  mapping(address=>mapping(address=>address[])) public presetPaths;\r\n  bool public changeRecpientIsOwner;\r\n  uint256 public fee = 0;\r\n  uint256 public maxfee = 0;\r\n\r\n\r\n  modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only owner can call this function.\"\r\n        );\r\n        _;\r\n}\r\n\r\n    fallback() external payable {\r\n    }\r\n\r\n  constructor() public payable {\r\n         stablecoins[\"DAI\"] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n         stablecoins[\"USDT\"] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n         stablecoins[\"USDC\"] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n         changeRecpientIsOwner = false;\r\n        owner= msg.sender;\r\n\r\n  }\r\n\r\n  function wrap(address sourceToken, address[] memory destinationTokens, uint256 amount) public payable returns(address, uint256){\r\n\r\n\r\n    ERC20 sToken = ERC20(sourceToken);\r\n    ERC20 dToken = ERC20(destinationTokens[0]);\r\n\r\n      if(destinationTokens.length==1){\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer 1\");\r\n          if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\r\n                  sToken.approve(sushiAddress, amount.mul(3));\r\n            }\r\n        }\r\n\r\n        conductUniswap(sourceToken, destinationTokens[0], amount);\r\n        uint256 thisBalance = dToken.balanceOf(address(this));\r\n        dToken.transfer(msg.sender, thisBalance);\r\n        return (destinationTokens[0], thisBalance);\r\n\r\n      }\r\n\r\n      else{\r\n\r\n        bool updatedweth =false;\r\n        if(sourceToken == ETH_TOKEN_ADDRESS){\r\n          WrappedETH sToken1 = WrappedETH(WETH_TOKEN_ADDRESS);\r\n          sToken1.deposit{value:msg.value}();\r\n          sToken = ERC20(WETH_TOKEN_ADDRESS);\r\n          amount = msg.value;\r\n          sourceToken = WETH_TOKEN_ADDRESS;\r\n          updatedweth =true;\r\n        }\r\n\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS && updatedweth==false){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  2\");\r\n          if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\r\n                  sToken.approve(sushiAddress, amount.mul(3));\r\n            }\r\n        }\r\n\r\n        if(destinationTokens[0] == ETH_TOKEN_ADDRESS){\r\n              destinationTokens[0] = WETH_TOKEN_ADDRESS;\r\n        }\r\n        if(destinationTokens[1] == ETH_TOKEN_ADDRESS){\r\n            destinationTokens[1] = WETH_TOKEN_ADDRESS;\r\n        }\r\n\r\n\r\n\r\n        if(sourceToken !=destinationTokens[0]){\r\n            conductUniswap(sourceToken, destinationTokens[0], amount.div(2));\r\n        }\r\n        if(sourceToken !=destinationTokens[1]){\r\n\r\n            conductUniswap(sourceToken, destinationTokens[1], amount.div(2));\r\n        }\r\n\r\n        ERC20 dToken2 = ERC20(destinationTokens[1]);\r\n        uint256 dTokenBalance = dToken.balanceOf(address(this));\r\n        uint256 dTokenBalance2 = dToken2.balanceOf(address(this));\r\n\r\n        if(dToken.allowance(address(this), sushiAddress) < dTokenBalance.mul(2)){\r\n             dToken.approve(sushiAddress, dTokenBalance.mul(3));\r\n        }\r\n\r\n        if(dToken2.allowance(address(this), sushiAddress) < dTokenBalance2.mul(2)){\r\n            dToken2.approve(sushiAddress, dTokenBalance2.mul(3));\r\n        }\r\n\r\n        (,,uint liquidityCoins)  = sushiExchange.addLiquidity(destinationTokens[0],destinationTokens[1], dTokenBalance, dTokenBalance2, 1,1, address(this), longTimeFromNow);\r\n\r\n        address thisPairAddress = factory.getPair(destinationTokens[0],destinationTokens[1]);\r\n        ERC20 lpToken = ERC20(thisPairAddress);\r\n        lpTokenAddressToPairs[thisPairAddress] =[destinationTokens[0], destinationTokens[1]];\r\n        uint256 thisBalance =lpToken.balanceOf(address(this));\r\n\r\n        if(fee>0){\r\n            uint256 totalFee = (thisBalance.mul(fee)).div(10000);\r\n            if(totalFee >0){\r\n                lpToken.transfer(owner, totalFee);\r\n            }\r\n            thisBalance =lpToken.balanceOf(address(this));\r\n            lpToken.transfer(msg.sender, thisBalance);\r\n\r\n        }\r\n        else{\r\n            lpToken.transfer(msg.sender, thisBalance);\r\n        }\r\n\r\n\r\n        //transfer any change to changeRecipient (from a pair imbalance. Should never be more than a few basis points)\r\n        address changeRecipient = msg.sender;\r\n        if(changeRecpientIsOwner == true){\r\n            changeRecipient = owner;\r\n        }\r\n        if(dToken.balanceOf(address(this)) >0){\r\n            dToken.transfer(changeRecipient, dToken.balanceOf(address(this)));\r\n        }\r\n        if(dToken2.balanceOf(address(this)) >0){\r\n            dToken2.transfer(changeRecipient, dToken2.balanceOf(address(this)));\r\n        }\r\n\r\n        return (thisPairAddress,thisBalance) ;\r\n      }\r\n\r\n\r\n\r\n    }\r\n\r\n    function updateStableCoinAddress(string memory coinName, address newAddress) public onlyOwner returns(bool){\r\n        stablecoins[coinName] = newAddress;\r\n        return true;\r\n\r\n    }\r\n\r\n    function updatePresetPaths(address sellToken, address buyToken, address[] memory newPath ) public onlyOwner returns(bool){\r\n        presetPaths[sellToken][buyToken] = newPath;\r\n        return true;\r\n    }\r\n\r\n    //owner can turn on ability to collect a small fee from trade imbalances on LP conversions\r\n    function updateChangeRecipientBool(bool changeRecpientIsOwnerBool ) public onlyOwner returns(bool){\r\n        changeRecpientIsOwner = changeRecpientIsOwnerBool;\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n      function unwrap(address sourceToken, address destinationToken, uint256 amount) public payable returns( uint256){\r\n\r\n        address originalDestinationToken = destinationToken;\r\n        ERC20 sToken = ERC20(sourceToken);\r\n        if(destinationToken == ETH_TOKEN_ADDRESS){\r\n            destinationToken = WETH_TOKEN_ADDRESS;\r\n        }\r\n        ERC20 dToken = ERC20(destinationToken);\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  3 unwrapping\");\r\n        }\r\n\r\n        LPERC20 thisLpInfo = LPERC20(sourceToken);\r\n        lpTokenAddressToPairs[sourceToken] = [thisLpInfo.token0(), thisLpInfo.token1()];\r\n\r\n          if(lpTokenAddressToPairs[sourceToken].length !=0){\r\n            if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\r\n                  sToken.approve(sushiAddress, amount.mul(3));\r\n            }\r\n\r\n          sushiExchange.removeLiquidity(lpTokenAddressToPairs[sourceToken][0], lpTokenAddressToPairs[sourceToken][1], amount, 0,0, address(this), longTimeFromNow);\r\n\r\n          ERC20 pToken1 = ERC20(lpTokenAddressToPairs[sourceToken][0]);\r\n          ERC20 pToken2 = ERC20(lpTokenAddressToPairs[sourceToken][1]);\r\n\r\n          uint256 pTokenBalance = pToken1.balanceOf(address(this));\r\n          uint256 pTokenBalance2 = pToken2.balanceOf(address(this));\r\n\r\n           if(pToken1.allowance(address(this), sushiAddress) < pTokenBalance.mul(2)){\r\n                  pToken1.approve(sushiAddress, pTokenBalance.mul(3));\r\n            }\r\n\r\n            if(pToken2.allowance(address(this), sushiAddress) < pTokenBalance2.mul(2)){\r\n                  pToken2.approve(sushiAddress, pTokenBalance2.mul(3));\r\n            }\r\n\r\n          if(lpTokenAddressToPairs[sourceToken][0] != destinationToken){\r\n              conductUniswap(lpTokenAddressToPairs[sourceToken][0], destinationToken, pTokenBalance);\r\n          }\r\n          if(lpTokenAddressToPairs[sourceToken][1] != destinationToken){\r\n              conductUniswap(lpTokenAddressToPairs[sourceToken][1], destinationToken, pTokenBalance2);\r\n          }\r\n\r\n\r\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\r\n\r\n          if(originalDestinationToken == ETH_TOKEN_ADDRESS){\r\n              wethToken.withdraw(destinationTokenBalance);\r\n              if(fee >0){\r\n                  uint256 totalFee = (address(this).balance.mul(fee)).div(10000);\r\n                  if(totalFee >0){\r\n                      owner.transfer(totalFee);\r\n                  }\r\n                  msg.sender.transfer(address(this).balance);\r\n              }\r\n              else{\r\n                msg.sender.transfer(address(this).balance);\r\n              }\r\n          }\r\n          else{\r\n              if(fee >0){\r\n                   uint256 totalFee = (destinationTokenBalance.mul(fee)).div(10000);\r\n                   if(totalFee >0){\r\n                       dToken.transfer(owner, totalFee);\r\n                   }\r\n                   destinationTokenBalance = dToken.balanceOf(address(this));\r\n                   dToken.transfer(msg.sender, destinationTokenBalance);\r\n\r\n              }\r\n              else{\r\n               dToken.transfer(msg.sender, destinationTokenBalance);\r\n              }\r\n          }\r\n\r\n\r\n          return destinationTokenBalance;\r\n\r\n        }\r\n\r\n        else{\r\n\r\n            if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\r\n                  sToken.approve(sushiAddress, amount.mul(3));\r\n            }\r\n            if(sourceToken != destinationToken){\r\n                conductUniswap(sourceToken, destinationToken, amount);\r\n            }\r\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\r\n          dToken.transfer(msg.sender, destinationTokenBalance);\r\n          return destinationTokenBalance;\r\n        }\r\n\r\n      }\r\n\r\n  function updateOwnerAddress(address payable newOwner) onlyOwner public returns (bool){\r\n     owner = newOwner;\r\n     return true;\r\n   }\r\n\r\n   function updateSushiExchange(address newAddress ) public onlyOwner returns (bool){\r\n\r\n    sushiExchange = SushiV2( newAddress);\r\n    sushiAddress = newAddress;\r\n    return true;\r\n\r\n  }\r\n\r\n  function updateUniswapFactory(address newAddress ) public onlyOwner returns (bool){\r\n\r\n   factory = UniswapFactory( newAddress);\r\n   uniFactoryAddress = newAddress;\r\n   return true;\r\n\r\n }\r\n\r\n\r\n  function conductUniswap(address sellToken, address buyToken, uint amount) internal returns (uint256 amounts1){\r\n\r\n            if(sellToken ==ETH_TOKEN_ADDRESS && buyToken == WETH_TOKEN_ADDRESS){\r\n                wethToken.deposit{value:msg.value}();\r\n            }\r\n            else if(sellToken == address(0x0)){\r\n\r\n               // address [] memory addresses = new address[](2);\r\n               address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\r\n                //addresses[0] = WETH_TOKEN_ADDRESS;\r\n                //addresses[1] = buyToken;\r\n                sushiExchange.swapExactETHForTokens{value:msg.value}(0, addresses, address(this), 1000000000000000 );\r\n\r\n            }\r\n\r\n            else if(sellToken == WETH_TOKEN_ADDRESS){\r\n                wethToken.withdraw(amount);\r\n\r\n                //address [] memory addresses = new address[](2);\r\n                address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\r\n                //addresses[0] = WETH_TOKEN_ADDRESS;\r\n                //addresses[1] = buyToken;\r\n                sushiExchange.swapExactETHForTokens{value:amount}(0, addresses, address(this), 1000000000000000 );\r\n\r\n            }\r\n\r\n\r\n\r\n            else{\r\n\r\n          address [] memory addresses = getBestPath(sellToken, buyToken, amount);\r\n           uint256 [] memory amounts = conductUniswapT4T(addresses, amount );\r\n           uint256 resultingTokens = amounts[amounts.length-1];\r\n           return resultingTokens;\r\n            }\r\n    }\r\n\r\n\r\n    //gets the best path to route the transaction on Uniswap\r\n    function getBestPath(address sellToken, address buyToken, uint256 amount) public view returns (address[] memory){\r\n\r\n        address [] memory defaultPath =new address[](2);\r\n        defaultPath[0]=sellToken;\r\n        defaultPath[1] = buyToken;\r\n\r\n\r\n        if(presetPaths[sellToken][buyToken].length !=0){\r\n            return presetPaths[sellToken][buyToken];\r\n        }\r\n\r\n\r\n        if(sellToken == stablecoins[\"DAI\"] || sellToken == stablecoins[\"USDC\"] || sellToken == stablecoins[\"USDT\"]){\r\n            return defaultPath;\r\n        }\r\n        if(buyToken == stablecoins[\"DAI\"] || buyToken == stablecoins[\"USDC\"] || buyToken == stablecoins[\"USDT\"]){\r\n            return defaultPath;\r\n        }\r\n\r\n\r\n\r\n        address[] memory daiPath = new address[](3);\r\n        address[] memory usdcPath =new address[](3);\r\n        address[] memory usdtPath =new address[](3);\r\n\r\n        daiPath[0] = sellToken;\r\n        daiPath[1] = stablecoins[\"DAI\"];\r\n        daiPath[2] = buyToken;\r\n\r\n        usdcPath[0] = sellToken;\r\n        usdcPath[1] = stablecoins[\"USDC\"];\r\n        usdcPath[2] = buyToken;\r\n\r\n        usdtPath[0] = sellToken;\r\n        usdtPath[1] = stablecoins[\"USDT\"];\r\n        usdtPath[2] = buyToken;\r\n\r\n\r\n        uint256 directPathOutput =  getPriceFromUniswap(defaultPath, amount)[1];\r\n\r\n\r\n        uint256[] memory daiPathOutputRaw = getPriceFromUniswap(daiPath, amount);\r\n        uint256[]  memory usdtPathOutputRaw = getPriceFromUniswap(usdtPath, amount);\r\n        uint256[]  memory usdcPathOutputRaw = getPriceFromUniswap(usdcPath, amount);\r\n\r\n        //uint256 directPathOutput = directPathOutputRaw[directPathOutputRaw.length-1];\r\n        uint256 daiPathOutput = daiPathOutputRaw[daiPathOutputRaw.length-1];\r\n        uint256 usdtPathOutput = usdtPathOutputRaw[usdtPathOutputRaw.length-1];\r\n        uint256 usdcPathOutput = usdcPathOutputRaw[usdcPathOutputRaw.length-1];\r\n\r\n        uint256 bestPathOutput = directPathOutput;\r\n        address[] memory bestPath = new address[](2);\r\n        address[] memory bestPath3 = new address[](3);\r\n        //return defaultPath;\r\n        bestPath = defaultPath;\r\n\r\n        bool isTwoPath = true;\r\n\r\n        if(directPathOutput < daiPathOutput){\r\n            isTwoPath=false;\r\n            bestPathOutput = daiPathOutput;\r\n            bestPath3 = daiPath;\r\n        }\r\n        if(bestPathOutput < usdcPathOutput){\r\n            isTwoPath=false;\r\n            bestPathOutput = usdcPathOutput;\r\n            bestPath3 = usdcPath;\r\n        }\r\n         if(bestPathOutput < usdtPathOutput){\r\n             isTwoPath=false;\r\n            bestPathOutput = usdtPathOutput;\r\n            bestPath3 = usdtPath;\r\n        }\r\n\r\n        require(bestPathOutput >0, \"This trade will result in getting zero tokens back. Reverting\");\r\n\r\n        if(isTwoPath==true){\r\n              return bestPath;\r\n        }\r\n        else{\r\n            return bestPath3;\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    function getPriceFromUniswap(address  [] memory theAddresses, uint amount) public view returns (uint256[] memory amounts1){\r\n\r\n\r\n        try sushiExchange.getAmountsOut(amount,theAddresses ) returns (uint256[] memory amounts){\r\n            return amounts;\r\n        }\r\n        catch  {\r\n            uint256 [] memory amounts2= new uint256[](2);\r\n            amounts2[0]=0;\r\n            amounts2[1]=0;\r\n            return amounts2;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function conductUniswapT4T(address  [] memory theAddresses, uint amount) internal returns (uint256[] memory amounts1){\r\n\r\n           uint256 deadline = 1000000000000000;\r\n           uint256 [] memory amounts =  sushiExchange.swapExactTokensForTokens(amount, 0, theAddresses, address(this),deadline );\r\n           return amounts;\r\n\r\n    }\r\n\r\n    function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\r\n\r\n      if (address(token) == ETH_TOKEN_ADDRESS) {\r\n          destination.transfer(amount);\r\n      }\r\n      else {\r\n          ERC20 tokenToken = ERC20(token);\r\n          require(tokenToken.transfer(destination, amount));\r\n      }\r\n      return true;\r\n  }\r\n\r\n\r\n  function setFee(uint256 newFee) public onlyOwner returns (bool){\r\n    require(newFee<=maxfee, \"Admin cannot set the fee higher than the current maxfee\");\r\n    fee = newFee;\r\n    return true;\r\n  }\r\n\r\n\r\n  function setMaxFee(uint256 newMax) public onlyOwner returns (bool){\r\n    require(maxfee==0, \"Admin can only set max fee once and it is perm\");\r\n    maxfee = newMax;\r\n    return true;\r\n  }\r\n\r\n  function addLPPair(address lpAddress, address token1, address token2) onlyOwner public returns (bool){\r\n      lpTokenAddressToPairs[lpAddress] = [token1, token2];\r\n      return true;\r\n  }\r\n\r\n  function getLPTokenByPair(address token1, address token2) view public returns (address lpAddr){\r\n      address thisPairAddress = factory.getPair(token1,token2);\r\n      return thisPairAddress;\r\n  }\r\n\r\n   function getUserTokenBalance(address userAddress, address tokenAddress) public view returns (uint256){\r\n    ERC20 token = ERC20(tokenAddress);\r\n    return token.balanceOf(userAddress);\r\n\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ETH_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"addLPPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"adminEmergencyWithdrawTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeRecpientIsOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBestPath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"getLPTokenByPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lpAddr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"theAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPriceFromUniswap\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts1\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpTokenAddressToPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"presetPaths\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"stablecoins\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"changeRecpientIsOwnerBool\",\"type\":\"bool\"}],\"name\":\"updateChangeRecipientBool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"updateOwnerAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"newPath\",\"type\":\"address[]\"}],\"name\":\"updatePresetPaths\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"coinName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateStableCoinAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateSushiExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"destinationTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"WrapAndUnWrap","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b3583819a5a2e184174c8a3799b7516840a210e22e57bb4106c5363290728155"}]}