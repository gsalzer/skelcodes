{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title MetaGovernorUNI\r\n * @dev Meta-governance contract for Uniswap's GovernorAlpha.\r\n *\r\n * This contract enables NDX holders to vote, by simple majority, on how to cast\r\n * votes for Uniswap governance proposals.\r\n *\r\n * Each Uniswap proposal is wrapped as a meta proposal, which has an endBlock which\r\n * ends some number of blocks prior to the end of the real proposal in order to give\r\n * NDX holders time to cast meta votes prior to casting votes for the entire dao.\r\n *\r\n * This contract counts voting power from users the same way as the typical GovernorAlpha,\r\n * which is to call getPriorVotes to check the delegation a voting account held at the time\r\n * the external proposal began.\r\n *\r\n * Once a meta proposal has ended, it may be executed to cast votes on Uniswap. If the proposal\r\n * has more votes in favor than against, it will cast votes supporting the proposal. Otherwise,\r\n * it will cast votes against the proposal.\r\n *\r\n * This contract may not be used to submit proposals to Uniswap, only to vote on them.\r\n */\r\ncontract MetaGovernorUNI {\r\n  /** @dev The name of this contract */\r\n  string public constant name = \"Indexed UNI Meta Governor\";\r\n\r\n  /**\r\n   * @dev The number of blocks subtracted from the endBlock of an external\r\n   * proposal to set the end block of a meta proposal.\r\n   */\r\n  uint32 public immutable votingGracePeriod;\r\n\r\n  /** @dev The address of the Indexed governance token */\r\n  NdxInterface public immutable ndx;\r\n\r\n\r\n  /** @dev The address of the UNI GovernorAlpha */\r\n  IGovernorAlpha public immutable uniGovernor;\r\n\r\n  /**\r\n   * @param startBlock The block at which voting begins: holders must delegate their votes prior to this block\r\n   * @param endBlock The block at which voting ends: votes must be cast prior to this block\r\n   * @param forVotes Current number of votes in favor of this proposal\r\n   * @param againstVotes Current number of votes in opposition to this proposal\r\n   * @param voteSubmitted Flag marking whether the vote has been cast on the external governor\r\n   * @param receipts Receipts of ballots for the entire set of voters\r\n   */\r\n  struct MetaProposal {\r\n    uint32 startBlock;\r\n    uint32 endBlock;\r\n    uint96 forVotes;\r\n    uint96 againstVotes;\r\n    bool voteSubmitted;\r\n    mapping(address => Receipt) receipts;\r\n  }\r\n\r\n  /**\r\n   * @dev Possible states that a meta proposal may be in\r\n   */\r\n  enum MetaProposalState {\r\n    Active,\r\n    Defeated,\r\n    Succeeded,\r\n    Executed\r\n  }\r\n\r\n  mapping(uint256 => MetaProposal) public proposals;\r\n\r\n  /**\r\n   * @dev Ballot receipt record for a voter\r\n   * @param hasVoted Whether or not a vote has been cast\r\n   * @param support Whether or not the voter supports the proposal\r\n   * @param votes The number of votes the voter had, which were cast\r\n   */\r\n  struct Receipt {\r\n    bool hasVoted;\r\n    bool support;\r\n    uint96 votes;\r\n  }\r\n\r\n  /**\r\n   * @dev An event emitted when a vote has been cast on a proposal\r\n   */\r\n  event MetaVoteCast(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint256 votes\r\n  );\r\n\r\n  event ExternalVoteSubmitted(\r\n    uint256 proposalId,\r\n    bool support\r\n  );\r\n\r\n  constructor(address ndx_, address uniGovernor_, uint32 votingGracePeriod_) public {\r\n    ndx = NdxInterface(ndx_);\r\n    uniGovernor = IGovernorAlpha(uniGovernor_);\r\n    votingGracePeriod = votingGracePeriod_;\r\n  }\r\n\r\n  function getReceipt(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    returns (Receipt memory)\r\n  {\r\n    return proposals[proposalId].receipts[voter];\r\n  }\r\n\r\n  function submitExternalVote(uint256 proposalId) external {\r\n    MetaProposal storage proposal = proposals[proposalId];\r\n    MetaProposalState state = _state(proposal);\r\n    require(\r\n      state == MetaProposalState.Succeeded || state == MetaProposalState.Defeated,\r\n      \"MetaGovernorUNI::submitExternalVote: proposal must be in Succeeded or Defeated state to execute\"\r\n    );\r\n    proposal.voteSubmitted = true;\r\n    bool support = state == MetaProposalState.Succeeded;\r\n    uniGovernor.castVote(proposalId, support);\r\n    emit ExternalVoteSubmitted(proposalId, support);\r\n  }\r\n\r\n  function _getMetaProposal(uint256 proposalId) internal returns (MetaProposal storage) {\r\n    // Get the meta proposal if it exists, else initialize the block fields using the external proposal.\r\n    MetaProposal storage proposal = proposals[proposalId];\r\n    if (proposal.startBlock == 0) {\r\n      IGovernorAlpha.Proposal memory externalProposal = uniGovernor.proposals(proposalId);\r\n      proposal.startBlock = safe32(externalProposal.startBlock);\r\n      proposal.endBlock = sub32(safe32(externalProposal.endBlock), votingGracePeriod);\r\n    }\r\n    return proposal;\r\n  }\r\n\r\n  function castVote(uint256 proposalId, bool support) external {\r\n    MetaProposal storage proposal = _getMetaProposal(proposalId);\r\n    require(\r\n      _state(proposal) == MetaProposalState.Active,\r\n      \"MetaGovernorUNI::_castVote: meta proposal not active\"\r\n    );\r\n    Receipt storage receipt = proposal.receipts[msg.sender];\r\n    require(\r\n      receipt.hasVoted == false,\r\n      \"MetaGovernorUNI::_castVote: voter already voted\"\r\n    );\r\n    uint96 votes = ndx.getPriorVotes(msg.sender, proposal.startBlock);\r\n    require(\r\n      votes > 0,\r\n      \"MetaGovernorUNI::_castVote: caller has no delegated NDX\"\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = add96(proposal.forVotes, votes);\r\n    } else {\r\n      proposal.againstVotes = add96(proposal.againstVotes, votes);\r\n    }\r\n\r\n    receipt.hasVoted = true;\r\n    receipt.support = support;\r\n    receipt.votes = votes;\r\n\r\n    emit MetaVoteCast(msg.sender, proposalId, support, votes);\r\n  }\r\n\r\n  function state(uint256 proposalId) external view returns (MetaProposalState) {\r\n    MetaProposal storage proposal = proposals[proposalId];\r\n    return _state(proposal);\r\n  }\r\n\r\n  function _state(MetaProposal storage proposal) internal view returns (MetaProposalState) {\r\n    require(\r\n      proposal.startBlock != 0 && block.number > proposal.startBlock,\r\n      \"MetaGovernorUNI::_state: meta proposal does not exist or is not ready\"\r\n    );\r\n    if (block.number <= proposal.endBlock) {\r\n      return MetaProposalState.Active;\r\n    } else if (proposal.voteSubmitted) {\r\n      return MetaProposalState.Executed;\r\n    } else if (proposal.forVotes > proposal.againstVotes) {\r\n      return MetaProposalState.Succeeded;\r\n    }\r\n    return MetaProposalState.Defeated;\r\n  }\r\n\r\n  function add96(uint96 a, uint96 b) internal pure returns (uint96) {\r\n    uint96 c = a + b;\r\n    require(c >= a, \"addition overflow\");\r\n    return c;\r\n  }\r\n\r\n  function safe32(uint256 a) internal pure returns (uint32) {\r\n    require(a <= uint32(-1), \"uint32 overflow\");\r\n    return uint32(a);\r\n  }\r\n\r\n  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    require(b <= a, \"subtraction underflow\");\r\n    return a - b;\r\n  }\r\n}\r\n\r\n\r\ninterface IGovernorAlpha {\r\n  struct Proposal {\r\n    uint256 id;\r\n    address proposer;\r\n    uint256 eta;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool canceled;\r\n    bool executed;\r\n  }\r\n\r\n  function proposals(uint256 proposalId) external view returns (Proposal memory);\r\n\r\n  function castVote(uint256 proposalId, bool support) external;\r\n}\r\n\r\n\r\ninterface NdxInterface {\r\n  function getPriorVotes(address account, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint96);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ndx_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniGovernor_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"votingGracePeriod_\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"ExternalVoteSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"MetaVoteCast\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"internalType\":\"struct MetaGovernorUNI.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ndx\",\"outputs\":[{\"internalType\":\"contract NdxInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"forVotes\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"againstVotes\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"voteSubmitted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum MetaGovernorUNI.MetaProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"submitExternalVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniGovernor\",\"outputs\":[{\"internalType\":\"contract IGovernorAlpha\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingGracePeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MetaGovernorUNI","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000086772b1409b61c639eaac9ba0acfbb6e238e5f830000000000000000000000005e4be8bc9637f0eaa1a755019e06a68ce081d58f00000000000000000000000000000000000000000000000000000000000005a0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d02ae45bcae967b40e50e41dbbcbaa1e270f840dd10ed4db4140180321931ce1"}]}