{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n *  Program Name    : DappIncubator\r\n *  Website         : https://www.dappincubator.com\r\n *  Telegram        : https://t.me/dappincubatorofficial\r\n *  Concept         : High Return On Investment\r\n *  Category        : Passive Income\r\n *  Risk Category   : High Risk\r\n **/\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n     /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    \r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract DappIncubator is Ownable, ReentrancyGuard {\r\n    \r\n    /**\r\n     * @dev Structure to hold tokens supplu and dividend per share against collateral.\r\n     */\r\n    struct TokenLedger {\r\n        uint supply;\r\n        uint dividend;\r\n        uint initialPrice;\r\n        uint incrementPrice;\r\n    }\r\n    \r\n    /**\r\n     * @dev Structure to hold collateral balalnce of wallet.\r\n     */\r\n    struct BalanceLedger {\r\n        uint tokenBalance;\r\n        uint referralBalance;\r\n        int payOut;\r\n    }\r\n    \r\n    /**\r\n     * @dev mapping to store all active contract addresses and wallet addresses. This will be used to check if contract address and wallet address already part of system.\r\n     */\r\n    mapping(address => bool) contractAddressRecord;\r\n    mapping(address => bool) walletAddressRecord;\r\n    \r\n    uint constant magnitude = 1e18 ;\r\n    uint constant dividendFee = 10;\r\n    \r\n    /**\r\n     * @dev structure mapping created for storing balance and token information.\r\n     */\r\n    mapping (address => mapping(address => BalanceLedger)) balanceLedger;\r\n    mapping(address => TokenLedger) tokenLedger;\r\n    \r\n    /**\r\n     * @dev events to register information about collateral buy, sell, reinvest and token withdraw.\r\n     */\r\n     \r\n    event onTokenOnboard(address indexed contractAddress, uint initialPrice, uint incrementPrice);\r\n    event onPurchase(address indexed walletAddress, address indexed contractAddress, uint incomingTokenAmount, uint collateralMinted, address indexed referredBy);\r\n    event onSell(address indexed walletAddress, address indexed contractAddress, uint tokenAmountToReceiver, uint collateralBurned);\r\n    event onReinvest(address indexed walletAddress, address indexed contractAddress, uint reInvestTokenAmount, uint collateralMinted);\r\n    event onWithdraw(address indexed walletAddress, address indexed contractAddress, uint amountToWithdraw);\r\n    event onTransfer(address indexed contractAddress, address indexed from,address indexed to,uint256 tokens);\r\n    \r\n    /**\r\n     * @dev function to add ERC-20 Token to ecosystem.\r\n     */\r\n     function tokenOnboard(address contractAddress, uint initialPrice, uint incrementPrice) public nonReentrant onlyOwner returns(bool)\r\n     {\r\n         if(contractAddressRecord[contractAddress] == false)\r\n         {\r\n            contractAddressRecord[contractAddress] = true;\r\n            tokenLedger[contractAddress].initialPrice = initialPrice;\r\n            tokenLedger[contractAddress].incrementPrice = incrementPrice;\r\n            tokenLedger[contractAddress].supply = 0;\r\n            tokenLedger[contractAddress].dividend = 0;\r\n            \r\n            emit onTokenOnboard(contractAddress, initialPrice, incrementPrice);\r\n            \r\n            return true;\r\n         }\r\n         \r\n     }\r\n    \r\n    \r\n    /**\r\n     * @dev function to purchase collateral by sending Ethereum.\r\n     */\r\n    function buy(address _referredBy) public nonReentrant payable returns(uint256)\r\n    {\r\n        require(msg.value>0);\r\n        require(contractAddressRecord[address(0)] == true);\r\n        \r\n        // if first investment from user then activate wallet address in system.\r\n        if(walletAddressRecord[msg.sender] == false){\r\n            walletAddressRecord[msg.sender] = true;\r\n        }\r\n        \r\n        uint256 collateAmount = purchaseCollate(address(0), msg.value, _referredBy);\r\n        return collateAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to purchase collateral by sending any ERC-20 Tokens except Ethereum.\r\n     */\r\n    function buy(address contractAddress, uint256 tokenAmount, address _referredBy) public nonReentrant returns(uint256)\r\n    {\r\n        \r\n        // transfer token to system from user wallet\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(tokenAmount > 0);\r\n        require(ERC20(contractAddress).allowance(msg.sender, address(this)) >= tokenAmount);\r\n        require(ERC20(contractAddress).transferFrom(msg.sender, address(this), tokenAmount));\r\n        \r\n        \r\n        \r\n        // if first investment from user then activate wallet address in system.\r\n        if(walletAddressRecord[msg.sender] == false){\r\n            walletAddressRecord[msg.sender] = true;\r\n        }\r\n        \r\n        uint256 collateAmount = purchaseCollate(contractAddress,tokenAmount, _referredBy);\r\n        return collateAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to purchase collateral by sending Ethereum directly to smart contract address.\r\n     */\r\n    fallback() nonReentrant payable external\r\n    {\r\n        require(msg.value > 0);\r\n        require(contractAddressRecord[address(0)] == true);\r\n        \r\n        // if first investment from user then activate wallet address in system.\r\n        if(walletAddressRecord[msg.sender] == false){\r\n            walletAddressRecord[msg.sender] = true;\r\n        }\r\n        purchaseCollate(address(0), msg.value, address(0));\r\n    }\r\n    \r\n    /**\r\n     * @dev function to convert all dividend to collateral.\r\n     */\r\n    function reinvest(address contractAddress) public nonReentrant\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(walletAddressRecord[msg.sender] == true);\r\n        \r\n        // fetch dividends\r\n        uint256 _dividends = myDividends(contractAddress, false); // retrieve ref. bonus later in the code\r\n        \r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        balanceLedger[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\r\n        \r\n        // retrieve ref. bonus\r\n        _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance;\r\n        \r\n        balanceLedger[_customerAddress][contractAddress].referralBalance = 0;\r\n        \r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _collate = purchaseCollate(contractAddress, _dividends, address(0));\r\n        \r\n        // fire event\r\n        emit onReinvest(_customerAddress, contractAddress, _dividends, _collate);\r\n    }\r\n    \r\n    /**\r\n     * @dev function to sell collateral and withdraw tokens.\r\n     */\r\n    function exit(address contractAddress) public nonReentrant\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(walletAddressRecord[msg.sender] == true);\r\n        \r\n        // get token count for caller & sell them all\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = balanceLedger[_customerAddress][contractAddress].tokenBalance;\r\n        if(_tokens > 0) sell(contractAddress, _tokens);\r\n    \r\n        withdraw(contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev function to withdraw tokens, dividend and referralBalance.\r\n     */\r\n    function withdraw(address contractAddress) public nonReentrant\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(walletAddressRecord[msg.sender] == true);\r\n        \r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends(contractAddress, false); // get ref. bonus later in the code\r\n        \r\n        // update dividend tracker\r\n        balanceLedger[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\r\n        \r\n        // add ref. bonus\r\n        _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance;\r\n        balanceLedger[_customerAddress][contractAddress].referralBalance = 0;\r\n        \r\n        // delivery service\r\n        if (contractAddress == address(0)){\r\n            payable(address(_customerAddress)).transfer(_dividends);\r\n        }\r\n        else{\r\n            ERC20(contractAddress).transfer(_customerAddress,_dividends);\r\n        }\r\n        \r\n        \r\n        // fire event\r\n        emit onWithdraw(_customerAddress, contractAddress, _dividends);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Transfer collateral from the caller to a new holder.\r\n     * Remember, there's a 10% fee here as well.\r\n     */\r\n    function transfer(address contractAddress, address toAddress, uint256 amountOfCollate) public returns(bool)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(walletAddressRecord[_customerAddress] == true);\r\n        require(amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance);\r\n        \r\n        if(walletAddressRecord[toAddress] == false){\r\n            walletAddressRecord[toAddress] = true;\r\n        }\r\n        \r\n        // withdraw all outstanding dividends first\r\n        if(myDividends(contractAddress, true) > 0) withdraw(contractAddress);\r\n        \r\n        // calculate divident fees, tokens to transfer\r\n        uint256 _tokenFee = SafeMath.div(amountOfCollate, dividendFee);\r\n        uint256 _taxedTokens = SafeMath.sub(amountOfCollate, _tokenFee);\r\n        uint256 _dividends = collateralToToken_(contractAddress, _tokenFee);\r\n  \r\n        // burn the fee tokens\r\n        tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _tokenFee);\r\n\r\n        // exchange tokens\r\n        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, amountOfCollate);\r\n        balanceLedger[toAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[toAddress][contractAddress].tokenBalance, _taxedTokens);\r\n        \r\n        // update dividend trackers\r\n        balanceLedger[_customerAddress][contractAddress].payOut -= (int256) (tokenLedger[contractAddress].dividend * amountOfCollate);\r\n        balanceLedger[toAddress][contractAddress].payOut += (int256) (tokenLedger[contractAddress].dividend * _taxedTokens);\r\n        \r\n        // disperse dividends among holders\r\n        tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply);\r\n        \r\n        // emit transfer events\r\n        emit onTransfer(contractAddress, _customerAddress, toAddress, _taxedTokens);\r\n        \r\n        return true;\r\n\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev function to sell collatral.\r\n     */\r\n    function sell(address contractAddress, uint256 _amountOfCollate) public\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(walletAddressRecord[msg.sender] == true);\r\n      \r\n        address _customerAddress = msg.sender;\r\n       \r\n        require(_amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance);\r\n        \r\n        uint256 _collates = _amountOfCollate;\r\n        uint256 _tokens = collateralToToken_(contractAddress, _collates);\r\n        uint256 _dividends = SafeMath.div(_tokens, dividendFee);\r\n        uint256 _taxedToken = SafeMath.sub(_tokens, _dividends);\r\n        \r\n        // burn the sold tokens\r\n        tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _collates);\r\n        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, _collates);\r\n        \r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (tokenLedger[contractAddress].dividend * _collates + (_taxedToken * magnitude));\r\n        balanceLedger[_customerAddress][contractAddress].payOut -= _updatedPayouts;       \r\n        \r\n        // dividing by zero is a bad idea\r\n        if (tokenLedger[contractAddress].supply > 0) {\r\n            // update the amount of dividends per token\r\n            tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply);\r\n        }\r\n        \r\n        // fire event\r\n        emit onSell(_customerAddress, contractAddress, _taxedToken, _collates);\r\n    }\r\n        \r\n    /**\r\n     * @dev function to get current purchase price of single collateral.\r\n     */\r\n    function buyPrice(address contractAddress) public view returns(uint currentBuyPrice) {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        if(tokenLedger[contractAddress].supply == 0){\r\n            return tokenLedger[contractAddress].initialPrice + tokenLedger[contractAddress].incrementPrice;\r\n        } else {\r\n            uint256 _token = collateralToToken_(contractAddress, 1e18);\r\n            uint256 _dividends = SafeMath.div(_token, dividendFee);\r\n            uint256 _taxedToken = SafeMath.add(_token, _dividends);\r\n            return _taxedToken;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev function to get current sell price of single collateral.\r\n     */\r\n    function sellPrice(address contractAddress) public view returns(uint) {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        if(tokenLedger[contractAddress].supply == 0){\r\n            return tokenLedger[contractAddress].initialPrice - tokenLedger[contractAddress].incrementPrice;\r\n        } else {\r\n            uint256 _token = collateralToToken_(contractAddress, 1e18);\r\n            uint256 _dividends = SafeMath.div(_token, dividendFee);\r\n            uint256 _taxedToken = SafeMath.sub(_token, _dividends);\r\n            return _taxedToken;\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev function to calculate collateral price based on an amount of incoming token\r\n     * It's an scientific algorithm;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function tokentoCollateral_(address contractAddress, uint amount) internal view returns(uint)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenLedger[contractAddress].initialPrice * 1e18;\r\n        uint256 tokenSupply_ = tokenLedger[contractAddress].supply;\r\n        uint tokenPriceIncremental_ = tokenLedger[contractAddress].incrementPrice;\r\n        \r\n        uint256 _tokensReceived = \r\n         (\r\n            (\r\n                // underflow attempts BTFO\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(amount * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n  \r\n        return _tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to calculate token price based on an amount of incoming collateral\r\n     * It's an scientific algorithm;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function collateralToToken_(address contractAddress, uint256 _tokens) internal view returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = _tokens + 1e18 ;\r\n        uint256 _tokenSupply = tokenLedger[contractAddress].supply + 1e18;\r\n        uint256 tokenPriceInitial_ = tokenLedger[contractAddress].initialPrice;\r\n        uint tokenPriceIncremental_ = tokenLedger[contractAddress].incrementPrice;\r\n        \r\n        uint256 _etherReceived =\r\n        (\r\n            // underflow attempts BTFO\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n                        )-tokenPriceIncremental_\r\n                    )*(tokens_ - 1e18)\r\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n            )\r\n        /1e18);\r\n        \r\n        return _etherReceived;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to calculate amount of collateral received after sending tokens\r\n     */\r\n    function calculateCollateReceived(address contractAddress, uint256 _tokenAmount) public view returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        uint256 _dividends = SafeMath.div(_tokenAmount, dividendFee);\r\n        uint256 _taxedToken = SafeMath.sub(_tokenAmount, _dividends);\r\n        uint256 _amountOfCollatral = tokentoCollateral_(contractAddress, _taxedToken);\r\n        \r\n        return _amountOfCollatral;\r\n    }\r\n     \r\n    /**\r\n     * @dev function to calculate amount of tokens received after sending collateral\r\n     */\r\n    function calculateTokenReceived(address contractAddress, uint256 _collateToSell) public view returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        require(_collateToSell <= tokenLedger[contractAddress].supply);\r\n        \r\n        uint256 _token = collateralToToken_(contractAddress, _collateToSell);\r\n        uint256 _dividends = SafeMath.div(_token, dividendFee);\r\n        uint256 _taxedToken = SafeMath.sub(_token, _dividends);\r\n        return _taxedToken;\r\n    }  \r\n    \r\n    /**\r\n     * @dev function to process purchase of collateral and update user balance, dividend\r\n     */\r\n    function purchaseCollate(address contractAddress, uint256 _incomingToken, address _referredBy) internal returns(uint256)\r\n    {\r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        uint256 _undividedDividends = SafeMath.div(_incomingToken, dividendFee);\r\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _taxedToken = SafeMath.sub(_incomingToken, _undividedDividends);\r\n        uint256 _amountOfCollate = tokentoCollateral_(contractAddress,_taxedToken);\r\n        uint256 _fee = _dividends * magnitude;\r\n \r\n      \r\n        require(_amountOfCollate > 0 && (SafeMath.add(_amountOfCollate,tokenLedger[contractAddress].supply) > tokenLedger[contractAddress].supply));\r\n        \r\n        // is the user referred by a karmalink?\r\n        if(\r\n            // is this a referred purchase?\r\n            _referredBy != address(0) &&\r\n            \r\n            // no cheating!\r\n            _referredBy != _customerAddress &&\r\n            \r\n            walletAddressRecord[_referredBy] == true\r\n        ){\r\n            // wealth redistribution\r\n            balanceLedger[_referredBy][contractAddress].referralBalance = SafeMath.add(balanceLedger[_referredBy][contractAddress].referralBalance, _referralBonus);\r\n        } else {\r\n            // no ref purchase\r\n            // add the referral bonus back to the global dividends cake\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n        \r\n        // we can't give people infinite ethereum\r\n        if(tokenLedger[contractAddress].supply > 0){\r\n            \r\n            // add tokens to the pool\r\n            tokenLedger[contractAddress].supply = SafeMath.add(tokenLedger[contractAddress].supply, _amountOfCollate);\r\n \r\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            tokenLedger[contractAddress].dividend += (_dividends * magnitude / (tokenLedger[contractAddress].supply));\r\n            \r\n            // calculate the amount of tokens the customer receives over his purchase \r\n            _fee = _fee - (_fee-(_amountOfCollate * (_dividends * magnitude / (tokenLedger[contractAddress].supply))));\r\n        \r\n        } else {\r\n            // add tokens to the pool\r\n            tokenLedger[contractAddress].supply = _amountOfCollate;\r\n        }\r\n        \r\n        // update circulating supply & the ledger address for the customer\r\n        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[_customerAddress][contractAddress].tokenBalance, _amountOfCollate);\r\n        \r\n        int256 _updatedPayouts = (int256) ((tokenLedger[contractAddress].dividend * _amountOfCollate) - _fee);\r\n        balanceLedger[_customerAddress][contractAddress].payOut += _updatedPayouts;\r\n        \r\n        // fire event\r\n        emit onPurchase(_customerAddress, contractAddress, _incomingToken, _amountOfCollate, _referredBy);\r\n        \r\n        return _amountOfCollate;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to get tokens contract hold\r\n     */\r\n    function totalTokenBalance(address contractAddress) public view returns(uint)\r\n    {   \r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        if (contractAddress== address(0)){\r\n            return address(this).balance;\r\n        }\r\n        else{\r\n            return ERC20(contractAddress).balanceOf(address(this));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev function to retrieve the total token supply.\r\n     */\r\n    function totalSupply(address contractAddress) public view returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        return tokenLedger[contractAddress].supply;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens(address contractAddress) public view returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(contractAddress, _customerAddress);\r\n    }\r\n    \r\n    /**\r\n     * @dev function to retrieve the dividends owned by the caller.\r\n      */ \r\n    function myDividends(address contractAddress, bool _includeReferralBonus) public view returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        address _customerAddress = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(contractAddress,_customerAddress) + balanceLedger[_customerAddress][contractAddress].referralBalance : dividendsOf(contractAddress, _customerAddress) ;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address contractAddress, address _customerAddress) view public returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        return balanceLedger[_customerAddress][contractAddress].tokenBalance;\r\n    }\r\n    \r\n    /**\r\n     * @dev function to retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address contractAddress, address _customerAddress) view public returns(uint256)\r\n    {\r\n        require(contractAddressRecord[contractAddress] == true);\r\n        \r\n        return (uint256) ((int256)(tokenLedger[contractAddress].dividend * balanceLedger[_customerAddress][contractAddress].tokenBalance) - balanceLedger[_customerAddress][contractAddress].payOut) / magnitude;\r\n    }\r\n    \r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev interface to process transfer of ERC20 tokens\r\n */ \r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender,    uint _value);\r\n    event Transfer(address indexed _from, address indexed _to, uint    _value);\r\n}\r\n\r\n/**\r\n * @dev safemath library to avoid mathematical overflow error\r\n */ \r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n   \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reInvestTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountToReceiver\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralBurned\",\"type\":\"uint256\"}],\"name\":\"onSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incrementPrice\",\"type\":\"uint256\"}],\"name\":\"onTokenOnboard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBuyPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"calculateCollateReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateToSell\",\"type\":\"uint256\"}],\"name\":\"calculateTokenReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfCollate\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incrementPrice\",\"type\":\"uint256\"}],\"name\":\"tokenOnboard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"totalTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOfCollate\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DappIncubator","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://df34393191f84ab2b773c1687e684401beb686b1c377acef5662cefb8788074a"}]}