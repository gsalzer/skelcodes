{"status":"1","message":"OK","result":[{"SourceCode":"{\"FREXA1404TestToken.sol\":{\"content\":\"pragma solidity ^0.4.4;\\nimport \\\"./Whitelist.sol\\\";\\n\\n//standard ERC20 implementation\\ncontract ERC20 {\\n\\n    /// @return total amount of tokens\\n    function totalSupply() constant returns (uint256 supply) {}\\n\\n    /// @param _owner The address from which the balance will be retrieved\\n    /// @return The balance\\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\\n\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _value) returns (bool success) {}\\n\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n    /// @param _from The address of the sender\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\\n\\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _value The amount of wei to be approved for transfer\\n    /// @return Whether the approval was successful or not\\n    function approve(address _spender, uint256 _value) returns (bool success) {}\\n\\n    /// @param _owner The address of the account owning tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return Amount of remaining tokens allowed to spent\\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    \\n}\\n\\ncontract StandardToken is ERC20 {\\n\\n    function transfer(address _to, uint256 _value) returns (bool success) {\\n        //Default assumes totalSupply can\\u0027t be over max (2^256 - 1).\\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\\u0027t wrap.\\n        //Replace the if with this one instead.\\n        //if (balances[msg.sender] \\u003e= _value \\u0026\\u0026 balances[_to] + _value \\u003e balances[_to]) {\\n        if (balances[msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\n            balances[msg.sender] -= _value;\\n            balances[_to] += _value;\\n            Transfer(msg.sender, _to, _value);\\n            return true;\\n        } else { return false; }\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\\n        if (balances[_from] \\u003e= _value \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _value \\u0026\\u0026 balances[_to] + _value \\u003e balances[_to]) {\\n        //if (balances[_from] \\u003e= _value \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\n            balances[_to] += _value;\\n            balances[_from] -= _value;\\n            allowed[_from][msg.sender] -= _value;\\n            Transfer(_from, _to, _value);\\n            return true;\\n        } else { return false; }\\n    }\\n\\n    function balanceOf(address _owner) constant returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    function approve(address _spender, uint256 _value) returns (bool success) {\\n        allowed[msg.sender][_spender] = _value;\\n        Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\\n      return allowed[_owner][_spender];\\n    }\\n\\n    mapping (address =\\u003e uint256) balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n    uint256 public totalSupply;\\n}\\n\\n//extend ERC20 with ERC1404 standard\\ncontract ERC1404 is ERC20 {\\n    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\\n    /// @param from Sending address\\n    /// @param to Receiving address\\n    /// @param value Amount of tokens being transferred\\n    /// @return Code by which to reference message for rejection reasoning\\n    /// @dev Overwrite with your custom transfer restriction logic\\n    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8);\\n\\n    /// @notice Returns a human-readable message for a given restriction code\\n    /// @param restrictionCode Identifier for looking up a message\\n    /// @return Text showing the restriction\\u0027s reasoning\\n    /// @dev Overwrite with your custom message and restrictionCode handling\\n    function messageForTransferRestriction (uint8 restrictionCode) public view returns (string);\\n}\\n\\n//begin ERC-1404 Custom Implementation\\n/**\\n * An `ERC20` compatible token that that posits a standardized interface\\n * for issuing tokens with transfer restrictions.\\n *\\n * Implementation Details.\\n *\\n * An implementation of this token standard SHOULD provide the following:\\n *\\n * `name` - for use by wallets and exchanges.\\n * `symbol` - for use by wallets and exchanges.\\n * `decimals` - for use by wallets and exchanges\\n * `totalSupply` - for use by wallets and exchanges \\n *\\n * The implementation MUST take care to implement desired\\n * transfer restriction logic correctly.\\n */\\n\\n/// @title Reference implementation for the ERC-1404 token\\n/// @notice This implementation has a transfer restriction that prevents token holders from sending to the zero address\\n/// @dev Ref https://github.com/ethereum/EIPs/pull/SRS\\ncontract ERC1404CustomImpl is ERC1404, StandardToken, Whitelist {\\n    /// @notice Restriction codes and messages as constant variables\\n    /// @dev Holding restriction codes and messages as constants is not required by the standard\\n    string public constant UNKNOWN_MESSAGE = \\\"UNKNOWN\\\";\\n    uint8 public constant SUCCESS_CODE = 0;\\n    string public constant SUCCESS_MESSAGE = \\\"SUCCESS\\\";\\n    uint8 public constant ZERO_ADDRESS_RESTRICTION_CODE = 1;\\n    string public constant ZERO_ADDRESS_RESTRICTION_MESSAGE = \\\"ILLEGAL_TRANSFER_TO_ZERO_ADDRESS\\\";\\n    uint8 public constant SEND_NOT_ALLOWED_CODE = 2;\\n    string public constant SEND_NOT_ALLOWED_MESSAGE = \\\"ILLEGAL_TRANSFER_SENDING_ACCOUNT_NOT_WHITELISTED\\\";\\n    uint8 public constant RECEIVE_NOT_ALLOWED_CODE = 3;\\n    string public constant RECEIVE_NOT_ALLOWED_MESSAGE = \\\"ILLEGAL_TRANSFER_RECEIVING_ACCOUNT_NOT_WHITELISTED\\\";\\n\\n\\n    /// @notice Checks if a transfer is restricted, reverts if it is\\n    /// @param from Sending address\\n    /// @param to Receiving address\\n    /// @param value Amount of tokens being transferred\\n    /// @dev Defining this modifier is not required by the standard, using detectTransferRestriction and appropriately emitting TransferRestricted is however\\n    modifier notRestricted (address from, address to, uint256 value) {\\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\\n        require(restrictionCode == SUCCESS_CODE, messageForTransferRestriction(restrictionCode));\\n        _;\\n    }\\n\\n    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\\n    /// @param from Sending address\\n    /// @param to Receiving address\\n    /// @param value Amount of tokens being transferred\\n    /// @return Code by which to reference message for rejection reasoning\\n    /// @dev Overwrite with your custom transfer restriction logic\\n    function detectTransferRestriction (address from, address to, uint256 value)\\n        public view returns (uint8 restrictionCode)\\n    {\\n        restrictionCode = SUCCESS_CODE; // successful transfer\\n        \\n        if (to == address(0x0)) {\\n            restrictionCode = ZERO_ADDRESS_RESTRICTION_CODE; // illegal transfer to zero address\\n        } else if (!isWhitelisted(from)) {\\n            restrictionCode = SEND_NOT_ALLOWED_CODE; // sender address not whitelisted\\n        } else if (!isWhitelisted(to)) {\\n            restrictionCode = RECEIVE_NOT_ALLOWED_CODE; // receiver address not whitelisted\\n        }\\n    }\\n\\n    /// @notice Returns a human-readable message for a given restriction code\\n    /// @param restrictionCode Identifier for looking up a message\\n    /// @return Text showing the restriction\\u0027s reasoning\\n    /// @dev Overwrite with your custom message and restrictionCode handling\\n    function messageForTransferRestriction (uint8 restrictionCode)\\n        public view returns (string message)\\n    {\\n        message = UNKNOWN_MESSAGE;\\n        if (restrictionCode == SUCCESS_CODE) {\\n            message = SUCCESS_MESSAGE;\\n        } else if (restrictionCode == ZERO_ADDRESS_RESTRICTION_CODE) {\\n            message = ZERO_ADDRESS_RESTRICTION_MESSAGE;\\n        } else if (restrictionCode == SEND_NOT_ALLOWED_CODE) {\\n            message = SEND_NOT_ALLOWED_MESSAGE;\\n        } else if (restrictionCode == RECEIVE_NOT_ALLOWED_CODE) {\\n            message = RECEIVE_NOT_ALLOWED_MESSAGE;\\n        }\\n    }\\n\\n    /// @notice Subclass implementation of StandardToken\\u0027s ERC20 transfer method\\n    /// @param to Receiving address\\n    /// @param value Amount of tokens being transferred\\n    /// @return Transfer success status\\n    /// @dev Must compare the return value of detectTransferRestriction to 0\\n    function transfer (address to, uint256 value)\\n        public notRestricted(msg.sender, to, value) returns (bool)\\n    {\\n        return super.transfer(to, value);\\n    }\\n  \\n    /// @notice Subclass implementation of StandardToken\\u0027s ERC20 transferFrom method\\n    /// @param from Sending address\\n    /// @param to Receiving address\\n    /// @param value Amount of tokens being transferred\\n    /// @return Transfer success status\\n    /// @dev Must compare the return value of detectTransferRestriction to 0\\n    function transferFrom (address from, address to, uint256 value)\\n        public notRestricted(from, to, value) returns (bool)\\n    {\\n        return super.transferFrom(from, to, value);\\n    }\\n}\\n\\n//name this contract whatever you\\u0027d like\\ncontract FREXATestToken2 is ERC1404CustomImpl {\\n\\n    function () {\\n        //if ether is sent to this address, send it back.\\n        throw;\\n    }\\n\\n    /* Public variables of the token */\\n\\n    /*\\n    NOTE:\\n    The following variables are OPTIONAL vanities. One does not have to include them.\\n    They allow one to customise the token contract \\u0026 in no way influences the core functionality.\\n    Some wallets/interfaces might not even bother to look at this information.\\n    */\\n    string public name;                   //fancy name: eg Simon Bucks\\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\\u0027s like comparing 1 wei to 1 ether.\\n    string public symbol;                 //An identifier: eg SBX\\n    string public version = \\u0027H1.2.2\\u0027;       //human 0.1 standard. Just an arbitrary versioning scheme.\\n\\n//\\n// CHANGE THESE VALUES FOR YOUR TOKEN\\n//\\n\\n//make sure this function name matches the contract name above. So if you\\u0027re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\\n\\n    function FREXATestToken2(\\n        ) {\\n        balances[msg.sender] = 10000;               // Give the creator all initial tokens (100000 for example)\\n        totalSupply = 10000;                        // Update total supply (100000 for example)\\n        name = \\\"FREXA ERC-1404 Test\\\";                                   // Set the name for display purposes\\n        decimals = 0;                            // Amount of decimals for display purposes\\n        symbol = \\\"FRXT2\\\";                               // Set the symbol for display purposes\\n        addAddressToWhitelist(msg.sender);\\n    }\\n\\n    /* Approves and then calls the receiving contract */\\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\\n        allowed[msg.sender][_spender] = _value;\\n        Approval(msg.sender, _spender, _value);\\n\\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\\u0027t have to include a contract in here just for this.\\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\\n        if(!_spender.call(bytes4(bytes32(sha3(\\\"receiveApproval(address,uint256,address,bytes)\\\"))), msg.sender, _value, this, _extraData)) { throw; }\\n        return true;\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.21;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  function Ownable() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n}\\n\"},\"Whitelist.sol\":{\"content\":\"pragma solidity ^0.4.21;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/**\\n * @title Whitelist\\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\\n * @dev This simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Whitelist is Ownable {\\n  mapping(address =\\u003e bool) public whitelist;\\n\\n  event WhitelistedAddressAdded(address addr);\\n  event WhitelistedAddressRemoved(address addr);\\n\\n  /**\\n   * @dev Throws if called by any account that\\u0027s not whitelisted.\\n   */\\n  modifier onlyWhitelisted() {\\n    require(whitelist[msg.sender]);\\n    _;\\n  }\\n\\n  /**\\n   * @dev check if an address is on the whitelist\\n   * @param addr address\\n   * @return true if the address was on the whitelist, false if the address was not in the whitelist\\n   */\\n  function isWhitelisted(address addr) onlyOwner public returns(bool onWhitelist) {\\n    onWhitelist = whitelist[addr];\\n  }\\n\\n  /**\\n   * @dev add an address to the whitelist\\n   * @param addr address\\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\\n   */\\n  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\\n    if (!whitelist[addr]) {\\n      whitelist[addr] = true;\\n      emit WhitelistedAddressAdded(addr);\\n      success = true;\\n    }\\n  }\\n\\n  /**\\n   * @dev add addresses to the whitelist\\n   * @param addrs addresses\\n   * @return true if at least one address was added to the whitelist,\\n   * false if all addresses were already in the whitelist\\n   */\\n  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\\n    for (uint256 i = 0; i \\u003c addrs.length; i++) {\\n      if (addAddressToWhitelist(addrs[i])) {\\n        success = true;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev remove an address from the whitelist\\n   * @param addr address\\n   * @return true if the address was removed from the whitelist,\\n   * false if the address wasn\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\\n    if (whitelist[addr]) {\\n      whitelist[addr] = false;\\n      emit WhitelistedAddressRemoved(addr);\\n      success = true;\\n    }\\n  }\\n\\n  /**\\n   * @dev remove addresses from the whitelist\\n   * @param addrs addresses\\n   * @return true if at least one address was removed from the whitelist,\\n   * false if all addresses weren\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\\n    for (uint256 i = 0; i \\u003c addrs.length; i++) {\\n      if (removeAddressFromWhitelist(addrs[i])) {\\n        success = true;\\n      }\\n    }\\n  }\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUCCESS_CODE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"onWhitelist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RECEIVE_NOT_ALLOWED_MESSAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SEND_NOT_ALLOWED_MESSAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_ADDRESS_RESTRICTION_MESSAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SEND_NOT_ALLOWED_CODE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"restrictionCode\",\"type\":\"uint8\"}],\"name\":\"messageForTransferRestriction\",\"outputs\":[{\"name\":\"message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_ADDRESS_RESTRICTION_CODE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RECEIVE_NOT_ALLOWED_CODE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNKNOWN_MESSAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"detectTransferRestriction\",\"outputs\":[{\"name\":\"restrictionCode\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUCCESS_MESSAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FREXATestToken2","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d04737775bc0704b175fe61a3217f41103dc821b7f67d7b181e6f15595655034"}]}