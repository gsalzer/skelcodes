{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.4;\r\n\r\ncontract Token {\r\n\r\n    function balanceOf(address _owner) virtual public returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) virtual public returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) virtual public view returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n\r\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) override view public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) override view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public circulatingSupply;\r\n}\r\n\r\ncontract ZuckBucks2 is StandardToken {\r\n    /* Public variables of the token */\r\n\r\n    string public name;                     // Zuck Bucks 2: Seize the Diem\r\n    uint256 public decimals;                // 18 decimals\r\n    string public symbol;                   // ZUCC\r\n    address payable private owner;          // Contract creator\r\n    uint public totalSupply;                // 60 million tokens possible to be mined, 1.5 million premined for ZBUX-ZUCC swaps\r\n    uint public minimum_contribution;       // Require that at least 0.001 ETH is sent, 0.001 ETH = 1 tick\r\n    uint256 public starting_giveaway;       // Start by giving away 100 ZUCC\r\n    uint256 public halving_tick;            // Halvings occur every 300,000 \"ticks\" (mining events)\r\n    uint256 public halving_number;          // Number of halvings that have occured (starts at 0)\r\n    uint256 public giveaway_count;          // Number of ticks (mining events) that have occured\r\n    \r\n    StandardToken private ZBUX;\r\n    \r\n    // \"Mining\" function\r\n    receive() external payable {\r\n        // Only 32 halvings can occur.\r\n        require(halving_number < 33);\r\n        \r\n        // Only transfer if you send 0.001 ETH or more\r\n        require(msg.value >= minimum_contribution);\r\n        \r\n        // Increment ticks (mining events) in 0.001 ETH increments\r\n        uint256 eth_multiplier = uint(msg.value / minimum_contribution);\r\n        \r\n        // Transfer half the ETH to the owner (for exchange listing fees)\r\n        owner.transfer(msg.value / 2);\r\n        \r\n        // If a halving event occurs...\r\n        if(uint(giveaway_count / halving_tick) < uint((giveaway_count + eth_multiplier) / halving_tick)) triggerHalving(eth_multiplier);\r\n        \r\n        // Increment the number of giveaways\r\n        giveaway_count += eth_multiplier;\r\n\r\n        // Calculate the next giveaway amount\r\n        uint256 giveaway_value = (starting_giveaway * ((10**decimals) / (2**halving_number))) * eth_multiplier;\r\n\r\n        // \"Mine\" ZUCC to the sender and increment the circulating supply\r\n        balances[msg.sender] += giveaway_value;\r\n        circulatingSupply += giveaway_value;\r\n        emit Transfer(address(0), msg.sender, giveaway_value);\r\n    }\r\n    \r\n    // Trigger a halving\r\n    function triggerHalving(uint _eth_multiplier) private {\r\n        // Set the halving number (how many halvings have occurred)\r\n        halving_number = uint((giveaway_count + _eth_multiplier) / halving_tick);\r\n        \r\n        // EMIT ETH to the winning miner\r\n        msg.sender.transfer(address(this).balance);\r\n        \r\n    }\r\n\r\n    function calculateReward(uint _sentETH) public view returns (uint256 reward) {\r\n        // Increment ticks (mining events) in 0.001 ETH increments\r\n        uint256 eth_multiplier = uint(_sentETH / minimum_contribution);\r\n        uint256 _halving_number;\r\n        \r\n        // If a halving event occurs...\r\n        if(uint(giveaway_count / halving_tick) < uint((giveaway_count + eth_multiplier) / halving_tick)) _halving_number = uint((giveaway_count + eth_multiplier) / halving_tick);\r\n        \r\n\r\n        // Calculate the next giveaway amount\r\n        return (starting_giveaway * ((10**decimals) / (2**_halving_number))) * eth_multiplier;\r\n    }\r\n    \r\n    function swapFromZBUX(uint _sentZBUX) public {\r\n        require(_sentZBUX >= 1, \"Must swap at least one ZBUX.\");\r\n        \r\n        ZBUX.transferFrom(msg.sender, address(0), _sentZBUX);\r\n        \r\n        uint giveaway_value = _sentZBUX * (10**decimals);\r\n        \r\n        // \"Mine\" ZUCC to the sender and increment the circulating supply\r\n        balances[msg.sender] += giveaway_value;\r\n        balances[owner] -= giveaway_value;\r\n        circulatingSupply += giveaway_value;\r\n        emit Transfer(owner, msg.sender, giveaway_value);\r\n        \r\n    }\r\n\r\n    constructor() {\r\n        totalSupply             = 61500000000000000000000000;       // TOTAL POSSIBLE TOKENS\r\n        minimum_contribution    = 1000000000000000;\r\n        balances[msg.sender]    = 1500000000000000000000000;        // SEND OWNER PREMINE\r\n        circulatingSupply       = 0;\r\n        name                    = \"Zuck Bucks 2: Seize the Diem\";\r\n        decimals                = 18;\r\n        symbol                  = \"ZUCC\";\r\n        starting_giveaway       = 100;\r\n        owner                   = msg.sender;\r\n        giveaway_count          = 0;\r\n        halving_tick            = 300000;\r\n        halving_number          = 0;\r\n        ZBUX                    = StandardToken(0x7090a6e22c838469c9E67851D6489ba9c933a43F);\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sentETH\",\"type\":\"uint256\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveaway_count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halving_number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halving_tick\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum_contribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starting_giveaway\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sentZBUX\",\"type\":\"uint256\"}],\"name\":\"swapFromZBUX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ZuckBucks2","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e24b8be5517288f8685ac07d5e8fed1118c6de18cc7928b3cdf075b9bd76bf00"}]}