{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IGovernance.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IGovernance { \r\n\r\n    event Proposal(\r\n        address indexed proposalOwner,\r\n        uint256 indexed proposalId,\r\n        uint256 dateAdd,\r\n        string proposalTitle,\r\n        string proposalSD,\r\n        string proposalDescHash\r\n    );\r\n\r\n    event Solution(\r\n        uint256 indexed proposalId,\r\n        address indexed solutionOwner,\r\n        uint256 indexed solutionId,\r\n        string solutionDescHash,\r\n        uint256 dateAdd\r\n    );\r\n\r\n    event Vote(\r\n        address indexed from,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed voteId,\r\n        uint256 dateAdd,\r\n        uint256 solutionChosen\r\n    );\r\n\r\n    event RewardClaimed(\r\n        address indexed member,\r\n        uint gbtReward\r\n    );\r\n\r\n    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \r\n    event VoteCast (uint256 proposalId);\r\n\r\n    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \r\n    ///      call any offchain actions\r\n    event ProposalAccepted (uint256 proposalId);\r\n\r\n    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\r\n    event CloseProposalOnTime (\r\n        uint256 indexed proposalId,\r\n        uint256 time\r\n    );\r\n\r\n    /// @dev ActionSuccess event is called whenever an onchain action is executed.\r\n    event ActionSuccess (\r\n        uint256 proposalId\r\n    );\r\n\r\n    /// @dev Creates a new proposal\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    function createProposal(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint _categoryId\r\n    ) \r\n        external;\r\n\r\n    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    function categorizeProposal(\r\n        uint _proposalId, \r\n        uint _categoryId,\r\n        uint _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev Submit proposal with solution\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Creates a new proposal with solution and votes for the solution\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Casts vote\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external;\r\n\r\n    function closeProposal(uint _proposalId) external;\r\n\r\n    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \r\n\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalReward\r\n        );\r\n\r\n    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\r\n\r\n    function allowedToCatgorize() public view returns(uint roleId);\r\n\r\n    /**\r\n     * @dev Gets length of propsal\r\n     * @return length of propsal\r\n     */\r\n    function getProposalLength() external view returns(uint);\r\n\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/Governed.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMaster {\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    function dAppToken() public view returns(address);\r\n    function isInternal(address _address) public view returns(bool);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IToken {\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    \r\n     /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param sender address The address which you want to send tokens from\r\n    * @param recipient address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IMarket.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarket {\r\n\r\n    enum PredictionStatus {\r\n      Live,\r\n      InSettlement,\r\n      Cooling,\r\n      InDispute,\r\n      Settled\r\n    }\r\n\r\n    struct MarketData {\r\n      uint64 startTime;\r\n      uint64 predictionTime;\r\n      uint64 neutralMinValue;\r\n      uint64 neutralMaxValue;\r\n    }\r\n\r\n    struct MarketSettleData {\r\n      uint64 WinningOption;\r\n      uint64 settleTime;\r\n    }\r\n\r\n    MarketSettleData public marketSettleData;\r\n\r\n    MarketData public marketData;\r\n\r\n    function WinningOption() public view returns(uint256);\r\n\r\n    function marketCurrency() public view returns(bytes32);\r\n\r\n    function getMarketFeedData() public view returns(uint8, bytes32, address);\r\n\r\n    function settleMarket() external;\r\n    \r\n    function getTotalStakedValueInPLOT() external view returns(uint256);\r\n\r\n    /**\r\n    * @dev Initialize the market.\r\n    * @param _startTime The time at which market will create.\r\n    * @param _predictionTime The time duration of market.\r\n    * @param _minValue The minimum value of middle option range.\r\n    * @param _maxValue The maximum value of middle option range.\r\n    */\r\n    function initiate(uint64 _startTime, uint64 _predictionTime, uint64 _minValue, uint64 _maxValue) public payable;\r\n\r\n    /**\r\n    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\r\n    * @param accepted The flag defining that the dispute raised is accepted or not \r\n    * @param finalResult The final correct value of market currency.\r\n    */\r\n    function resolveDispute(bool accepted, uint256 finalResult) external payable;\r\n\r\n    /**\r\n    * @dev Gets the market data.\r\n    * @return _marketCurrency bytes32 representing the currency or stock name of the market.\r\n    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\r\n    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\r\n    * @return _optionPrice uint[] memory representing the option price of each option ranges of the market.\r\n    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\r\n    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\r\n    * @return _predictionType uint representing the type of market.\r\n    * @return _expireTime uint representing the expire time of the market.\r\n    * @return _predictionStatus uint representing the status of the market.\r\n    */\r\n    function getData() external view \r\n    \treturns (\r\n    \t\tbytes32 _marketCurrency,uint[] memory minvalue,uint[] memory maxvalue,\r\n        \tuint[] memory _optionPrice, uint[] memory _ethStaked, uint[] memory _plotStaked,uint _predictionType,\r\n        \tuint _expireTime, uint _predictionStatus\r\n        );\r\n\r\n    // /**\r\n    // * @dev Gets the pending return.\r\n    // * @param _user The address to specify the return of.\r\n    // * @return uint representing the pending return amount.\r\n    // */\r\n    // function getPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens);\r\n\r\n    /**\r\n    * @dev Claim the return amount of the specified address.\r\n    * @param _user The address to query the claim return amount of.\r\n    * @return Flag, if 0:cannot claim, 1: Already Claimed, 2: Claimed\r\n    */\r\n    function claimReturn(address payable _user) public returns(uint256);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/Iupgradable.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract Iupgradable {\r\n\r\n    /**\r\n     * @dev change master address\r\n     */\r\n    function setMasterAddress() public;\r\n}\r\n\r\n// File: contracts/interfaces/IMarketUtility.sol\r\n\r\npragma solidity 0.5.7;\r\ncontract IMarketUtility {\r\n\r\n    function initialize(address payable[] calldata _addressParams, address _initiater) external;\r\n\r\n\t/**\r\n     * @dev to Set authorized address to update parameters \r\n     */\r\n    function setAuthorizedAddres() public;\r\n\r\n\t/**\r\n     * @dev to update uint parameters in Market Config \r\n     */\r\n    function updateUintParameters(bytes8 code, uint256 value) external;\r\n\r\n    /**\r\n     * @dev to Update address parameters in Market Config \r\n     */\r\n    function updateAddressParameters(bytes8 code, address payable value) external;\r\n \r\n     /**\r\n    * @dev Get Parameters required to initiate market\r\n    * @return Addresses of tokens to be distributed as incentives\r\n    * @return Cool down time for market\r\n    * @return Rate\r\n    * @return Commission percent for predictions with ETH\r\n    * @return Commission percent for predictions with PLOT\r\n    **/\r\n    function getMarketInitialParams() public view returns(address[] memory, uint , uint, uint, uint);\r\n\r\n    function getAssetPriceUSD(address _currencyAddress) external view returns(uint latestAnswer);\r\n    \r\n    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8);\r\n\r\n    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function update() external;\r\n    \r\n    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied);\r\n    \r\n    /**\r\n     * @dev Get basic market details\r\n     * @return Minimum amount required to predict in market\r\n     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\r\n     * @return Decimal points for prediction positions\r\n     **/\r\n    function getBasicMarketDetails()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function getDisputeResolutionParams() public view returns (uint256);\r\n    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice);\r\n\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getSettlemetPrice(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId);\r\n\r\n    /**\r\n     * @dev Get value of provided currency address in ETH\r\n     * @param _currencyAddress Address of currency\r\n     * @param _amount Amount of provided currency\r\n     * @return Value of provided amount in ETH\r\n     **/\r\n    function getAssetValueETH(address _currencyAddress, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256 tokenEthValue);\r\n}\r\n\r\n// File: contracts/MarketRegistry.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketRegistry is Governed, Iupgradable {\r\n\r\n    using SafeMath for *; \r\n\r\n    enum MarketType {\r\n      HourlyMarket,\r\n      DailyMarket,\r\n      WeeklyMarket\r\n    }\r\n\r\n    struct MarketTypeData {\r\n      uint64 predictionTime;\r\n      uint64 optionRangePerc;\r\n    }\r\n\r\n    struct MarketCurrency {\r\n      address marketImplementation;\r\n      uint8 decimals;\r\n    }\r\n\r\n    struct MarketCreationData {\r\n      uint64 initialStartTime;\r\n      address marketAddress;\r\n      address penultimateMarket;\r\n    }\r\n\r\n    struct DisputeStake {\r\n      uint64 proposalId;\r\n      address staker;\r\n      uint256 stakeAmount;\r\n      uint256 ethDeposited;\r\n      uint256 tokenDeposited;\r\n    }\r\n\r\n    struct MarketData {\r\n      bool isMarket;\r\n      DisputeStake disputeStakes;\r\n    }\r\n\r\n    struct UserData {\r\n      uint256 lastClaimedIndex;\r\n      uint256 marketsCreated;\r\n      uint256 totalEthStaked;\r\n      uint256 totalPlotStaked;\r\n      address[] marketsParticipated;\r\n      mapping(address => bool) marketsParticipatedFlag;\r\n    }\r\n\r\n    uint internal marketCreationIncentive;\r\n    \r\n    mapping(address => MarketData) marketData;\r\n    mapping(address => UserData) userData;\r\n    mapping(uint256 => mapping(uint256 => MarketCreationData)) public marketCreationData;\r\n    mapping(uint64 => address) disputeProposalId;\r\n\r\n    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address internal marketInitiater;\r\n    address public tokenController;\r\n\r\n    MarketCurrency[] marketCurrencies;\r\n    MarketTypeData[] marketTypes;\r\n\r\n    bool public marketCreationPaused;\r\n\r\n    IToken public plotToken;\r\n    IMarketUtility public marketUtility;\r\n    IGovernance internal governance;\r\n    IMaster ms;\r\n\r\n\r\n    event MarketQuestion(address indexed marketAdd, bytes32 stockName, uint256 indexed predictionType, uint256 startTime);\r\n    event PlacePrediction(address indexed user,uint256 value, uint256 predictionPoints, address predictionAsset,uint256 prediction,address indexed marketAdd,uint256 _leverage);\r\n    event MarketResult(address indexed marketAdd, uint256[] totalReward, uint256 winningOption, uint256 closeValue, uint256 roundId);\r\n    event Claimed(address indexed marketAdd, address indexed user, uint256[] reward, address[] _predictionAssets, uint256 incentive, address incentiveToken);\r\n    event MarketTypes(uint256 indexed index, uint64 predictionTime, uint64 optionRangePerc);\r\n    event MarketCurrencies(uint256 indexed index, address marketImplementation,  address feedAddress, bytes32 currencyName);\r\n    event DisputeRaised(address indexed marketAdd, address raisedBy, uint64 proposalId, uint256 proposedValue);\r\n    event DisputeResolved(address indexed marketAdd, bool status);\r\n\r\n    /**\r\n    * @dev Checks if given addres is valid market address.\r\n    */\r\n    function isMarket(address _address) public view returns(bool) {\r\n      return marketData[_address].isMarket;\r\n    }\r\n\r\n    function isWhitelistedSponsor(address _address) public view returns(bool) {\r\n      return ms.whitelistedSponsor(_address);\r\n    }\r\n\r\n    /**\r\n    * @dev Initialize the PlotX MarketRegistry.\r\n    * @param _defaultAddress Address authorized to start initial markets\r\n    * @param _marketUtility The address of market config.\r\n    * @param _plotToken The instance of PlotX token.\r\n    */\r\n    function initiate(address _defaultAddress, address _marketUtility, address _plotToken, address payable[] memory _configParams) public {\r\n      require(address(ms) == msg.sender);\r\n      marketCreationIncentive = 50 ether;\r\n      plotToken = IToken(_plotToken);\r\n      address tcAddress = ms.getLatestAddress(\"TC\");\r\n      tokenController = tcAddress;\r\n      marketUtility = IMarketUtility(_generateProxy(_marketUtility));\r\n      marketUtility.initialize(_configParams, _defaultAddress);\r\n      marketInitiater = _defaultAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Start the initial market.\r\n    */\r\n    function addInitialMarketTypesAndStart(uint64 _marketStartTime, address _ethMarketImplementation, address _btcMarketImplementation) external {\r\n      require(marketInitiater == msg.sender);\r\n      require(marketTypes.length == 0);\r\n      _addNewMarketCurrency(_ethMarketImplementation);\r\n      _addNewMarketCurrency(_btcMarketImplementation);\r\n      _addMarket(1 hours, 50);\r\n      _addMarket(24 hours, 200);\r\n      _addMarket(7 days, 500);\r\n\r\n      for(uint256 i = 0;i < marketTypes.length; i++) {\r\n          marketCreationData[i][0].initialStartTime = _marketStartTime;\r\n          marketCreationData[i][1].initialStartTime = _marketStartTime;\r\n          createMarket(i, 0);\r\n          createMarket(i, 1);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Add new market type.\r\n    * @param _predictionTime The time duration of market.\r\n    * @param _marketStartTime The time at which market will create.\r\n    * @param _optionRangePerc Option range percent of neutral min, max options (raised by 2 decimals)\r\n    */\r\n    function addNewMarketType(uint64 _predictionTime, uint64 _marketStartTime, uint64 _optionRangePerc) external onlyAuthorizedToGovern {\r\n      require(_marketStartTime > now);\r\n      uint256 _marketType = marketTypes.length;\r\n      _addMarket(_predictionTime, _optionRangePerc);\r\n      for(uint256 j = 0;j < marketCurrencies.length; j++) {\r\n        marketCreationData[_marketType][j].initialStartTime = _marketStartTime;\r\n        createMarket(_marketType, j);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add market type\r\n    * @param _predictionTime The time duration of market.\r\n    * @param _optionRangePerc Option range percent of neutral min, max options (raised by 2 decimals)\r\n    */\r\n    function _addMarket(uint64 _predictionTime, uint64 _optionRangePerc) internal {\r\n      uint256 _marketType = marketTypes.length;\r\n      marketTypes.push(MarketTypeData(_predictionTime, _optionRangePerc));\r\n      emit MarketTypes(_marketType, _predictionTime, _optionRangePerc);\r\n    }\r\n\r\n    /**\r\n    * @dev Add new market currency.\r\n    */\r\n    function addNewMarketCurrency(address _marketImplementation, uint64 _marketStartTime) external onlyAuthorizedToGovern {\r\n      uint256 _marketCurrencyIndex = marketCurrencies.length;\r\n      _addNewMarketCurrency(_marketImplementation);\r\n      for(uint256 j = 0;j < marketTypes.length; j++) {\r\n        marketCreationData[j][_marketCurrencyIndex].initialStartTime = _marketStartTime;\r\n        createMarket(j, _marketCurrencyIndex);\r\n      }\r\n    }\r\n\r\n    function _addNewMarketCurrency(address _marketImplementation) internal {\r\n      uint256 _marketCurrencyIndex = marketCurrencies.length;\r\n      (, bytes32 _currencyName, address _priceFeed) = IMarket(_marketImplementation).getMarketFeedData();\r\n      uint8 _decimals = marketUtility.getPriceFeedDecimals(_priceFeed);\r\n      marketCurrencies.push(MarketCurrency(_marketImplementation, _decimals));\r\n      emit MarketCurrencies(_marketCurrencyIndex, _marketImplementation, _priceFeed, _currencyName);\r\n    }\r\n\r\n    /**\r\n    * @dev Update the implementations of the market.\r\n    */\r\n    function updateMarketImplementations(uint256[] calldata _currencyIndexes, address[] calldata _marketImplementations) external onlyAuthorizedToGovern {\r\n      require(_currencyIndexes.length == _marketImplementations.length);\r\n      for(uint256 i = 0;i< _currencyIndexes.length; i++) {\r\n        (, , address _priceFeed) = IMarket(_marketImplementations[i]).getMarketFeedData();\r\n        uint8 _decimals = marketUtility.getPriceFeedDecimals(_priceFeed);\r\n        marketCurrencies[_currencyIndexes[i]] = MarketCurrency(_marketImplementations[i], _decimals);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrade the implementations of the contract.\r\n    * @param _proxyAddress the proxy address.\r\n    * @param _newImplementation Address of new implementation contract\r\n    */\r\n    function upgradeContractImplementation(address payable _proxyAddress, address _newImplementation) \r\n        external onlyAuthorizedToGovern\r\n    {\r\n      require(_newImplementation != address(0));\r\n      OwnedUpgradeabilityProxy tempInstance \r\n          = OwnedUpgradeabilityProxy(_proxyAddress);\r\n      tempInstance.upgradeTo(_newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the master address and update it's instance\r\n     */\r\n    function setMasterAddress() public {\r\n      OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\r\n      require(msg.sender == proxy.proxyOwner(),\"Sender is not proxy owner.\");\r\n      ms = IMaster(msg.sender);\r\n      masterAddress = msg.sender;\r\n      governance = IGovernance(ms.getLatestAddress(\"GV\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Creates the new market.\r\n    * @param _marketType The type of the market.\r\n    * @param _marketCurrencyIndex the index of market currency.\r\n    */\r\n    function _createMarket(uint256 _marketType, uint256 _marketCurrencyIndex, uint64 _minValue, uint64 _maxValue, uint64 _marketStartTime, bytes32 _currencyName) internal {\r\n      require(!marketCreationPaused);\r\n      MarketTypeData memory _marketTypeData = marketTypes[_marketType];\r\n      address payable _market = _generateProxy(marketCurrencies[_marketCurrencyIndex].marketImplementation);\r\n      marketData[_market].isMarket = true;\r\n      IMarket(_market).initiate(_marketStartTime, _marketTypeData.predictionTime, _minValue, _maxValue);\r\n      emit MarketQuestion(_market, _currencyName, _marketType, _marketStartTime);\r\n      (marketCreationData[_marketType][_marketCurrencyIndex].penultimateMarket, marketCreationData[_marketType][_marketCurrencyIndex].marketAddress) =\r\n       (marketCreationData[_marketType][_marketCurrencyIndex].marketAddress, _market);\r\n    }\r\n\r\n    /**\r\n    * @dev Creates the new market\r\n    * @param _marketType The type of the market.\r\n    * @param _marketCurrencyIndex the index of market currency.\r\n    */\r\n    function createMarket(uint256 _marketType, uint256 _marketCurrencyIndex) public payable{\r\n      address penultimateMarket = marketCreationData[_marketType][_marketCurrencyIndex].penultimateMarket;\r\n      if(penultimateMarket != address(0)) {\r\n        IMarket(penultimateMarket).settleMarket();\r\n      }\r\n      if(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress != address(0)) {\r\n        (,,,,,,,, uint _status) = getMarketDetails(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress);\r\n        require(_status >= uint(IMarket.PredictionStatus.InSettlement));\r\n      }\r\n      (uint8 _roundOfToNearest, bytes32 _currencyName, address _priceFeed) = IMarket(marketCurrencies[_marketCurrencyIndex].marketImplementation).getMarketFeedData();\r\n      marketUtility.update();\r\n      uint64 _marketStartTime = calculateStartTimeForMarket(_marketType, _marketCurrencyIndex);\r\n      uint64 _optionRangePerc = marketTypes[_marketType].optionRangePerc;\r\n      uint currentPrice = marketUtility.getAssetPriceUSD(_priceFeed);\r\n      _optionRangePerc = uint64(currentPrice.mul(_optionRangePerc.div(2)).div(10000));\r\n      uint64 _decimals = marketCurrencies[_marketCurrencyIndex].decimals;\r\n      uint64 _minValue = uint64((ceil(currentPrice.sub(_optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\r\n      uint64 _maxValue = uint64((ceil(currentPrice.add(_optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\r\n      _createMarket(_marketType, _marketCurrencyIndex, _minValue, _maxValue, _marketStartTime, _currencyName);\r\n      userData[msg.sender].marketsCreated++;\r\n    }\r\n\r\n    /**\r\n    * @dev function to reward user for initiating market creation calls\r\n    */\r\n    function claimCreationReward() external {\r\n      require(userData[msg.sender].marketsCreated > 0);\r\n      uint256 pendingReward = marketCreationIncentive.mul(userData[msg.sender].marketsCreated);\r\n      require(plotToken.balanceOf(address(this)) > pendingReward);\r\n      delete userData[msg.sender].marketsCreated;\r\n      _transferAsset(address(plotToken), msg.sender, pendingReward);\r\n    }\r\n\r\n    function calculateStartTimeForMarket(uint256 _marketType, uint256 _marketCurrencyIndex) public view returns(uint64 _marketStartTime) {\r\n      address previousMarket = marketCreationData[_marketType][_marketCurrencyIndex].marketAddress;\r\n      if(previousMarket != address(0)) {\r\n        (_marketStartTime, , , ) = IMarket(previousMarket).marketData();\r\n      } else {\r\n        _marketStartTime = marketCreationData[_marketType][_marketCurrencyIndex].initialStartTime;\r\n      }\r\n      uint predictionTime = marketTypes[_marketType].predictionTime;\r\n      if(now > _marketStartTime.add(predictionTime)) {\r\n        uint noOfMarketsSkipped = ((now).sub(_marketStartTime)).div(predictionTime);\r\n       _marketStartTime = uint64(_marketStartTime.add(noOfMarketsSkipped.mul(predictionTime)));\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Updates Flag to pause creation of market.\r\n    */\r\n    function pauseMarketCreation() external onlyAuthorizedToGovern {\r\n      require(!marketCreationPaused);\r\n        marketCreationPaused = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Updates Flag to resume creation of market.\r\n    */\r\n    function resumeMarketCreation() external onlyAuthorizedToGovern {\r\n      require(marketCreationPaused);\r\n        marketCreationPaused = false;\r\n    }\r\n\r\n    /**\r\n    * @dev Create proposal if user wants to raise the dispute.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    * @param action The encoded action for solution.\r\n    * @param _stakeForDispute The token staked to raise the diospute.\r\n    * @param _user The address who raises the dispute.\r\n    */\r\n    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory action, uint256 _stakeForDispute, address _user, uint256 _ethSentToPool, uint256 _tokenSentToPool, uint256 _proposedValue) public {\r\n      require(isMarket(msg.sender));\r\n      uint64 proposalId = uint64(governance.getProposalLength());\r\n      marketData[msg.sender].disputeStakes = DisputeStake(proposalId, _user, _stakeForDispute, _ethSentToPool, _tokenSentToPool);\r\n      disputeProposalId[proposalId] = msg.sender;\r\n      governance.createProposalwithSolution(proposalTitle, proposalTitle, description, 10, solutionHash, action);\r\n      emit DisputeRaised(msg.sender, _user, proposalId, _proposedValue);\r\n    }\r\n\r\n    /**\r\n    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\r\n    * @param _marketAddress The address specify the market.\r\n    * @param _result The final result of the market.\r\n    */\r\n    function resolveDispute(address payable _marketAddress, uint256 _result) external onlyAuthorizedToGovern {\r\n      uint256 ethDepositedInPool = marketData[_marketAddress].disputeStakes.ethDeposited;\r\n      uint256 plotDepositedInPool = marketData[_marketAddress].disputeStakes.tokenDeposited;\r\n      uint256 stakedAmount = marketData[_marketAddress].disputeStakes.stakeAmount;\r\n      address payable staker = address(uint160(marketData[_marketAddress].disputeStakes.staker));\r\n      address plotTokenAddress = address(plotToken);\r\n      _transferAsset(plotTokenAddress, _marketAddress, plotDepositedInPool);\r\n      IMarket(_marketAddress).resolveDispute.value(ethDepositedInPool)(true, _result);\r\n      emit DisputeResolved(_marketAddress, true);\r\n      _transferAsset(plotTokenAddress, staker, stakedAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Burns the tokens of member who raised the dispute, if dispute is rejected.\r\n    * @param _proposalId Id of dispute resolution proposal\r\n    */\r\n    function burnDisputedProposalTokens(uint _proposalId) external onlyAuthorizedToGovern {\r\n      address disputedMarket = disputeProposalId[uint64(_proposalId)];\r\n      IMarket(disputedMarket).resolveDispute(false, 0);\r\n      emit DisputeResolved(disputedMarket, false);\r\n      uint _stakedAmount = marketData[disputedMarket].disputeStakes.stakeAmount;\r\n      plotToken.burn(_stakedAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Claim the pending return of the market.\r\n    * @param maxRecords Maximum number of records to claim reward for\r\n    */\r\n    function claimPendingReturn(uint256 maxRecords) external {\r\n      uint256 i;\r\n      uint len = userData[msg.sender].marketsParticipated.length;\r\n      uint lastClaimed = len;\r\n      uint count;\r\n      for(i = userData[msg.sender].lastClaimedIndex; i < len && count < maxRecords; i++) {\r\n        if(IMarket(userData[msg.sender].marketsParticipated[i]).claimReturn(msg.sender) > 0) {\r\n          count++;\r\n        } else {\r\n          if(lastClaimed == len) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n      if(lastClaimed == len) {\r\n        lastClaimed = i;\r\n      }\r\n      userData[msg.sender].lastClaimedIndex = lastClaimed;\r\n    }\r\n\r\n    function () external payable {\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Transfer `_amount` number of market registry assets contract to `_to` address\r\n    */\r\n    function transferAssets(address _asset, address payable _to, uint _amount) external onlyAuthorizedToGovern {\r\n      _transferAsset(_asset, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the assets to specified address.\r\n    * @param _asset The asset transfer to the specific address.\r\n    * @param _recipient The address to transfer the asset of\r\n    * @param _amount The amount which is transfer.\r\n    */\r\n    function _transferAsset(address _asset, address payable _recipient, uint256 _amount) internal {\r\n      if(_amount > 0) { \r\n        if(_asset == ETH_ADDRESS) {\r\n          _recipient.transfer(_amount);\r\n        } else {\r\n          require(IToken(_asset).transfer(_recipient, _amount));\r\n        }\r\n      }\r\n    }\r\n\r\n    function updateUintParameters(bytes8 code, uint256 value) external onlyAuthorizedToGovern {\r\n      if(code == \"MCRINC\") { // Incentive to be distributed to user for market creation\r\n        marketCreationIncentive = value;\r\n      } else {\r\n        marketUtility.updateUintParameters(code, value);\r\n      }\r\n    }\r\n\r\n    function updateConfigAddressParameters(bytes8 code, address payable value) external onlyAuthorizedToGovern {\r\n      marketUtility.updateAddressParameters(code, value);\r\n    }\r\n\r\n    /**\r\n     * @dev to generater proxy \r\n     * @param _contractAddress of the proxy\r\n     */\r\n    function _generateProxy(address _contractAddress) internal returns(address payable) {\r\n        OwnedUpgradeabilityProxy tempInstance = new OwnedUpgradeabilityProxy(_contractAddress);\r\n        return address(tempInstance);\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the MarketResult event.\r\n    * @param _totalReward The amount of reward to be distribute.\r\n    * @param winningOption The winning option of the market.\r\n    * @param closeValue The closing value of the market currency.\r\n    */\r\n    function callMarketResultEvent(uint256[] calldata _totalReward, uint256 winningOption, uint256 closeValue, uint _roundId) external {\r\n      require(isMarket(msg.sender));\r\n      emit MarketResult(msg.sender, _totalReward, winningOption, closeValue, _roundId);\r\n    }\r\n    \r\n    /**\r\n    * @dev Emits the PlacePrediction event and sets the user data.\r\n    * @param _user The address who placed prediction.\r\n    * @param _value The amount of ether user staked.\r\n    * @param _predictionPoints The positions user will get.\r\n    * @param _predictionAsset The prediction assets user will get.\r\n    * @param _prediction The option range on which user placed prediction.\r\n    * @param _leverage The leverage selected by user at the time of place prediction.\r\n    */\r\n    function setUserGlobalPredictionData(address _user,uint256 _value, uint256 _predictionPoints, address _predictionAsset, uint256 _prediction, uint256 _leverage) external {\r\n      require(isMarket(msg.sender));\r\n      if(_predictionAsset == ETH_ADDRESS) {\r\n        userData[_user].totalEthStaked = userData[_user].totalEthStaked.add(_value);\r\n      } else {\r\n        userData[_user].totalPlotStaked = userData[_user].totalPlotStaked.add(_value);\r\n      }\r\n      if(!userData[_user].marketsParticipatedFlag[msg.sender]) {\r\n        userData[_user].marketsParticipated.push(msg.sender);\r\n        userData[_user].marketsParticipatedFlag[msg.sender] = true;\r\n      }\r\n      emit PlacePrediction(_user, _value, _predictionPoints, _predictionAsset, _prediction, msg.sender,_leverage);\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the claimed event.\r\n    * @param _user The address who claim their reward.\r\n    * @param _reward The reward which is claimed by user.\r\n    * @param predictionAssets The prediction assets of user.\r\n    * @param incentives The incentives of user.\r\n    * @param incentiveToken The incentive tokens of user.\r\n    */\r\n    function callClaimedEvent(address _user ,uint[] calldata _reward, address[] calldata predictionAssets, uint incentives, address incentiveToken) external {\r\n      require(isMarket(msg.sender));\r\n      emit Claimed(msg.sender, _user, _reward, predictionAssets, incentives, incentiveToken);\r\n    }\r\n\r\n    /**\r\n    * @dev Get uint config parameters\r\n    */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint256 value) {\r\n      if(code == \"MCRINC\") {\r\n        codeVal = code;\r\n        value = marketCreationIncentive;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the market details of the specified address.\r\n    * @param _marketAdd The market address to query the details of market.\r\n    * @return _feedsource bytes32 representing the currency or stock name of the market.\r\n    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\r\n    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\r\n    * @return optionprice uint[] memory representing the option price of each option ranges of the market.\r\n    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\r\n    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\r\n    * @return _predictionType uint representing the type of market.\r\n    * @return _expireTime uint representing the expire time of the market.\r\n    * @return _predictionStatus uint representing the status of the market.\r\n    */\r\n    function getMarketDetails(address _marketAdd)public view returns\r\n    (bytes32 _feedsource,uint256[] memory minvalue,uint256[] memory maxvalue,\r\n      uint256[] memory optionprice,uint256[] memory _ethStaked, uint256[] memory _plotStaked,uint256 _predictionType,uint256 _expireTime, uint256 _predictionStatus){\r\n      return IMarket(_marketAdd).getData();\r\n    }\r\n\r\n    /**\r\n    * @dev Get total assets staked by user in PlotX platform\r\n    * @return _plotStaked Total PLOT staked by user\r\n    * @return _ethStaked Total ETH staked by user\r\n    */\r\n    function getTotalAssetStakedByUser(address _user) external view returns(uint256 _plotStaked, uint256 _ethStaked) {\r\n      return (userData[_user].totalPlotStaked, userData[_user].totalEthStaked);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the market details of the specified user address.\r\n    * @param user The address to query the details of market.\r\n    * @param fromIndex The index to query the details from.\r\n    * @param toIndex The index to query the details to\r\n    * @return _market address[] memory representing the address of the market.\r\n    * @return _winnigOption uint256[] memory representing the winning option range of the market.\r\n    */\r\n    function getMarketDetailsUser(address user, uint256 fromIndex, uint256 toIndex) external view returns\r\n    (address[] memory _market, uint256[] memory _winnigOption){\r\n      uint256 totalMarketParticipated = userData[user].marketsParticipated.length;\r\n      if(totalMarketParticipated > 0 && fromIndex < totalMarketParticipated) {\r\n        uint256 _toIndex = toIndex;\r\n        if(_toIndex >= totalMarketParticipated) {\r\n          _toIndex = totalMarketParticipated - 1;\r\n        }\r\n        _market = new address[](_toIndex.sub(fromIndex).add(1));\r\n        _winnigOption = new uint256[](_toIndex.sub(fromIndex).add(1));\r\n        for(uint256 i = fromIndex; i <= _toIndex; i++) {\r\n          _market[i] = userData[user].marketsParticipated[i];\r\n          (_winnigOption[i], ) = IMarket(_market[i]).marketSettleData();\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the addresses of open markets.\r\n    * @return _openMarkets address[] memory representing the open market addresses.\r\n    * @return _marketTypes uint256[] memory representing the open market types.\r\n    */\r\n    function getOpenMarkets() external view returns(address[] memory _openMarkets, uint256[] memory _marketTypes, bytes32[] memory _marketCurrencies) {\r\n      uint256  count = 0;\r\n      uint256 marketTypeLength = marketTypes.length;\r\n      uint256 marketCurrencyLength = marketCurrencies.length;\r\n      _openMarkets = new address[]((marketTypeLength).mul(marketCurrencyLength));\r\n      _marketTypes = new uint256[]((marketTypeLength).mul(marketCurrencyLength));\r\n      _marketCurrencies = new bytes32[]((marketTypeLength).mul(marketCurrencyLength));\r\n      for(uint256 i = 0; i< marketTypeLength; i++) {\r\n        for(uint256 j = 0; j< marketCurrencyLength; j++) {\r\n          _openMarkets[count] = marketCreationData[i][j].marketAddress;\r\n          _marketTypes[count] = i;\r\n          _marketCurrencies[count] = IMarket(marketCurrencies[j].marketImplementation).marketCurrency();\r\n          count++;\r\n        }\r\n      }\r\n    }\r\n\r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n        return ((a + m - 1) / m) * m;\r\n    }\r\n\r\n    // /**\r\n    // * @dev Calculates the user pending return amount.\r\n    // * @param _user The address to query the pending return amount of.\r\n    // * @return pendingReturn uint256 representing the pending return amount of user.\r\n    // * @return incentive uint256 representing the incentive.\r\n    // */\r\n    // function calculateUserPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens) {\r\n    //   uint256 _return;\r\n    //   uint256 _incentive;\r\n    //   for(uint256 i = lastClaimedIndex[_user]; i < marketsParticipated[_user].length; i++) {\r\n    //     // pendingReturn = pendingReturn.add(marketsParticipated[_user][i].call(abi.encodeWithSignature(\"getPendingReturn(uint256)\", _user)));\r\n    //     (_return, _incentive) = IMarket(marketsParticipated[_user][i]).getPendingReturn(_user);\r\n    //     pendingReturn = pendingReturn.add(_return);\r\n    //     incentive = incentive.add(_incentive);\r\n    //   }\r\n    // }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IChainLinkOracle.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ninterface IChainLinkOracle\r\n{\r\n\t/**\r\n    * @dev Gets the latest answer of chainLink oracle.\r\n    * @return int256 representing the latest answer of chainLink oracle.\r\n    */\r\n\tfunction latestAnswer() external view returns (int256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  \tfunction latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    ); \r\n}\r\n\r\n// File: contracts/external/openzeppelin-solidity/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/MarketRegistryNew.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketRegistryNew is MarketRegistry {\r\n\r\n    uint256 internal maxGasPrice;\r\n    IChainLinkOracle public clGasPriceAggregator;\r\n    struct MarketCreationRewardUserData {\r\n      uint incentives;\r\n      uint lastClaimedIndex;\r\n      address[] marketsCreated;\r\n    }\r\n\r\n    struct MarketCreationRewardData {\r\n      uint ethIncentive;\r\n      uint plotIncentive;\r\n      uint rewardPoolSharePerc;\r\n      address createdBy;\r\n    }\r\n\r\n    uint256 maxRewardPoolPercForMC;\r\n    uint256 minRewardPoolPercForMC;\r\n    uint256 plotStakeForRewardPoolShare;\r\n    uint256 rewardPoolShareThreshold;\r\n\r\n    mapping(address => MarketCreationRewardUserData) internal marketCreationRewardUserData; //Of user\r\n    mapping(address => MarketCreationRewardData) internal marketCreationRewardData; //Of user\r\n    mapping(uint256 => bool) internal marketCreationPausedOfType;\r\n    event MarketCreatorRewardPoolShare(address indexed createdBy, address indexed marketAddress, uint256 plotIncentive, uint256 ethIncentive);\r\n    event MarketCreationReward(address indexed createdBy, address marketAddress, uint256 plotIncentive, uint256 gasUsed, uint256 gasCost, uint256 gasPriceConsidered, uint256 gasPriceGiven, uint256 maxGasCap, uint256 rewardPoolSharePerc);\r\n    event ClaimedMarketCreationReward(address indexed user, uint256 ethIncentive, uint256 plotIncentive);\r\n\r\n    /**\r\n    * @dev Set initial market creation incentive params.\r\n    */\r\n    function setGasPriceAggAndMaxGas(address _clGasPriceAggregator) external {\r\n      require(address(clGasPriceAggregator) == address(0));\r\n      require(msg.sender == marketInitiater);\r\n      clGasPriceAggregator = IChainLinkOracle(_clGasPriceAggregator);\r\n      maxGasPrice = 100 * 10**9;\r\n      maxRewardPoolPercForMC = 500; // Raised by 2 decimals\r\n      minRewardPoolPercForMC = 50; // Raised by 2 decimals\r\n      plotStakeForRewardPoolShare = 25000 ether;\r\n      rewardPoolShareThreshold = 1 ether;\r\n    }\r\n\r\n    /**\r\n    * @dev Creates the new market\r\n    * @param _marketType The type of the market.\r\n    * @param _marketCurrencyIndex the index of market currency.\r\n    */\r\n    function createMarket(uint256 _marketType, uint256 _marketCurrencyIndex) public payable{\r\n      require(!marketCreationPausedOfType[_marketType]);\r\n      uint256 gasProvided = gasleft();\r\n      address penultimateMarket = marketCreationData[_marketType][_marketCurrencyIndex].penultimateMarket;\r\n      if(penultimateMarket != address(0)) {\r\n        IMarket(penultimateMarket).settleMarket();\r\n      }\r\n      if(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress != address(0)) {\r\n        (,,,,,,,, uint _status) = getMarketDetails(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress);\r\n        require(_status >= uint(IMarket.PredictionStatus.InSettlement));\r\n      }\r\n      (uint8 _roundOfToNearest, bytes32 _currencyName, address _priceFeed) = IMarket(marketCurrencies[_marketCurrencyIndex].marketImplementation).getMarketFeedData();\r\n      marketUtility.update();\r\n      uint64 _marketStartTime = calculateStartTimeForMarket(_marketType, _marketCurrencyIndex);\r\n      uint64 _optionRangePerc = marketTypes[_marketType].optionRangePerc;\r\n      uint currentPrice = marketUtility.getAssetPriceUSD(_priceFeed);\r\n      _optionRangePerc = uint64(currentPrice.mul(_optionRangePerc.div(2)).div(10000));\r\n      uint64 _decimals = marketCurrencies[_marketCurrencyIndex].decimals;\r\n      uint64 _minValue = uint64((ceil(currentPrice.sub(_optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\r\n      uint64 _maxValue = uint64((ceil(currentPrice.add(_optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\r\n      _createMarket(_marketType, _marketCurrencyIndex, _minValue, _maxValue, _marketStartTime, _currencyName);\r\n      _checkIfCreatorStaked(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress);\r\n      marketCreationRewardUserData[msg.sender].marketsCreated.push(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress);\r\n      uint256 gasUsed = gasProvided - gasleft();\r\n      _calculateIncentive(gasUsed, _marketType, _marketCurrencyIndex);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate user incentive for market creation\r\n    */\r\n    function _calculateIncentive(uint256 gasUsed, uint256 _marketType, uint256 _marketCurrencyIndex) internal{\r\n      address _marketAddress = marketCreationData[_marketType][_marketCurrencyIndex].marketAddress;\r\n      //Adding buffer gas for below calculations\r\n      gasUsed = gasUsed + 38500;\r\n      uint256 gasPrice = _checkGasPrice();\r\n      uint256 gasCost = gasUsed.mul(gasPrice);\r\n      (, uint256 incentive) = marketUtility.getValueAndMultiplierParameters(ETH_ADDRESS, gasCost);\r\n      marketCreationRewardUserData[msg.sender].incentives = marketCreationRewardUserData[msg.sender].incentives.add(incentive);\r\n      emit MarketCreationReward(msg.sender, _marketAddress, incentive, gasUsed, gasCost, gasPrice, tx.gasprice, maxGasPrice, marketCreationRewardData[_marketAddress].rewardPoolSharePerc);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate market reward pool share percent to be rewarded to market creator\r\n    */\r\n    function _checkIfCreatorStaked(address _market) internal {\r\n      uint256 tokensLocked = ITokenController(tokenController).tokensLockedAtTime(msg.sender, \"SM\", now);\r\n      marketCreationRewardData[_market].createdBy = msg.sender;\r\n      //Intentionally performed mul operation after div, to get absolute value instead of decimals\r\n      marketCreationRewardData[_market].rewardPoolSharePerc\r\n       = Math.min(\r\n          maxRewardPoolPercForMC,\r\n          minRewardPoolPercForMC + tokensLocked.div(plotStakeForRewardPoolShare).mul(minRewardPoolPercForMC)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Toggle Market creation of `_marketType` Type.\r\n    */\r\n    function toggleMarketCreationType(uint256 _marketType, bool _flag) external onlyAuthorizedToGovern {\r\n      require(marketCreationPausedOfType[_marketType] != _flag);\r\n      marketCreationPausedOfType[_marketType] = _flag;\r\n    }\r\n\r\n    /**\r\n    * @dev Get market reward pool share percent to be rewarded to market creator\r\n    */\r\n    function getMarketCreatorRPoolShareParams(address _market) external view returns(uint256, uint256) {\r\n      return (marketCreationRewardData[_market].rewardPoolSharePerc, rewardPoolShareThreshold);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate gas price for market creation incentives\r\n    */\r\n    function _checkGasPrice() internal view returns(uint256) {\r\n      uint fastGas = uint(clGasPriceAggregator.latestAnswer());\r\n      uint fastGasWithMaxDeviation = fastGas.mul(125).div(100);\r\n      return Math.min(Math.min(tx.gasprice,fastGasWithMaxDeviation), maxGasPrice);\r\n    }\r\n\r\n    /**\r\n    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\r\n    * @param _marketAddress The address specify the market.\r\n    * @param _result The final result of the market.\r\n    */\r\n    function resolveDispute(address payable _marketAddress, uint256 _result) external onlyAuthorizedToGovern {\r\n      uint256 ethDepositedInPool = marketData[_marketAddress].disputeStakes.ethDeposited;\r\n      uint256 plotDepositedInPool = marketData[_marketAddress].disputeStakes.tokenDeposited;\r\n      uint256 stakedAmount = marketData[_marketAddress].disputeStakes.stakeAmount;\r\n      address payable staker = address(uint160(marketData[_marketAddress].disputeStakes.staker));\r\n      address plotTokenAddress = address(plotToken);\r\n      plotDepositedInPool = plotDepositedInPool.add(marketCreationRewardData[_marketAddress].plotIncentive);\r\n      ethDepositedInPool = ethDepositedInPool.add(marketCreationRewardData[_marketAddress].ethIncentive);\r\n      delete marketCreationRewardData[_marketAddress].plotIncentive;\r\n      delete marketCreationRewardData[_marketAddress].ethIncentive;\r\n      _transferAsset(plotTokenAddress, _marketAddress, plotDepositedInPool);\r\n      IMarket(_marketAddress).resolveDispute.value(ethDepositedInPool)(true, _result);\r\n      emit DisputeResolved(_marketAddress, true);\r\n      _transferAsset(plotTokenAddress, staker, stakedAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev function to reward user for initiating market creation calls as per the new incetive calculations\r\n    */\r\n    function claimCreationRewardV2(uint256 _maxRecords) external {\r\n      uint256 pendingPLOTReward = marketCreationRewardUserData[msg.sender].incentives;\r\n      delete marketCreationRewardUserData[msg.sender].incentives;\r\n      (uint256 ethIncentive, uint256 plotIncentive) = _getRewardPoolIncentives(_maxRecords);\r\n      pendingPLOTReward = pendingPLOTReward.add(plotIncentive);\r\n      require(pendingPLOTReward > 0 || ethIncentive > 0, \"No pending\");\r\n      _transferAsset(address(plotToken), msg.sender, pendingPLOTReward);\r\n      _transferAsset(ETH_ADDRESS, msg.sender, ethIncentive);\r\n      emit ClaimedMarketCreationReward(msg.sender, ethIncentive, pendingPLOTReward);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate market reward pool share incentives for market creator\r\n    */\r\n    function _getRewardPoolIncentives(uint256 _maxRecords) internal returns(uint256 ethIncentive, uint256 plotIncentive) {\r\n      MarketCreationRewardUserData storage rewardData = marketCreationRewardUserData[msg.sender];\r\n      uint256 len = rewardData.marketsCreated.length;\r\n      uint lastClaimed = len;\r\n      uint256 count;\r\n      uint256 i;\r\n      for(i = rewardData.lastClaimedIndex;i < len && count < _maxRecords; i++) {\r\n        MarketCreationRewardData storage marketData = marketCreationRewardData[rewardData.marketsCreated[i]];\r\n        ( , , , , , , , , uint _predictionStatus) = IMarket(rewardData.marketsCreated[i]).getData();\r\n        if(_predictionStatus == uint(IMarket.PredictionStatus.Settled)) {\r\n          ethIncentive = ethIncentive.add(marketData.ethIncentive);\r\n          plotIncentive = plotIncentive.add(marketData.plotIncentive);\r\n          delete marketData.ethIncentive;\r\n          delete marketData.plotIncentive;\r\n          count++;\r\n        } else {\r\n          if(lastClaimed == len) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n      if(lastClaimed == len) {\r\n        lastClaimed = i;\r\n      }\r\n      rewardData.lastClaimedIndex = lastClaimed;\r\n    }\r\n\r\n    /**\r\n    * @dev function to get pending reward of user for initiating market creation calls as per the new incetive calculations\r\n    * @param _user Address of user for whom pending rewards to be checked\r\n    * @return plotIncentive Incentives given for creating market as per the gas consumed\r\n    * @return pendingPLOTReward PLOT Reward pool share of markets created by user\r\n    * @return pendingETHReward ETH Reward pool share of markets created by user\r\n    */\r\n    function getPendingMarketCreationRewards(address _user) external view returns(uint256 plotIncentive, uint256 pendingPLOTReward, uint256 pendingETHReward){\r\n      plotIncentive = marketCreationRewardUserData[_user].incentives;\r\n      (pendingETHReward, pendingPLOTReward) = _getPendingRewardPoolIncentives(_user);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate market reward pool share incentives for market creator\r\n    */\r\n    function _getPendingRewardPoolIncentives(address _user) internal view returns(uint256 ethIncentive, uint256 plotIncentive) {\r\n      MarketCreationRewardUserData memory rewardData = marketCreationRewardUserData[_user];\r\n      uint256 len = rewardData.marketsCreated.length;\r\n      for(uint256 i = rewardData.lastClaimedIndex;i < len; i++) {\r\n        MarketCreationRewardData memory marketData = marketCreationRewardData[rewardData.marketsCreated[i]];\r\n        if(marketData.ethIncentive > 0 || marketData.plotIncentive > 0) {\r\n          ( , , , , , , , , uint _predictionStatus) = IMarket(rewardData.marketsCreated[i]).getData();\r\n          if(_predictionStatus == uint(IMarket.PredictionStatus.Settled)) {\r\n            ethIncentive = ethIncentive.add(marketData.ethIncentive);\r\n            plotIncentive = plotIncentive.add(marketData.plotIncentive);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the MarketResult event.\r\n    * @param _totalReward The amount of reward to be distribute.\r\n    * @param winningOption The winning option of the market.\r\n    * @param closeValue The closing value of the market currency.\r\n    */\r\n    function callMarketResultEventAndSetIncentives(uint256[] calldata _totalReward, uint256[] calldata marketCreatorIncentive, uint256 winningOption, uint256 closeValue, uint _roundId) external {\r\n      require(isMarket(msg.sender));\r\n      marketCreationRewardData[msg.sender].plotIncentive = marketCreatorIncentive[0];\r\n      marketCreationRewardData[msg.sender].ethIncentive = marketCreatorIncentive[1];\r\n      emit MarketCreatorRewardPoolShare(marketCreationRewardData[msg.sender].createdBy, msg.sender, marketCreatorIncentive[0], marketCreatorIncentive[1]);\r\n      emit MarketResult(msg.sender, _totalReward, winningOption, closeValue, _roundId);\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev function to update address parameters of market\r\n    */\r\n    function updateConfigAddressParameters(bytes8 code, address payable value) external onlyAuthorizedToGovern {\r\n      if(code == \"GASAGG\") { // Incentive to be distributed to user for market creation\r\n        clGasPriceAggregator = IChainLinkOracle(value);\r\n      } else {\r\n        marketUtility.updateAddressParameters(code, value);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev function to update integer parameters of market\r\n    */\r\n    function updateUintParameters(bytes8 code, uint256 value) external onlyAuthorizedToGovern {\r\n      if(code == \"MCRINC\") { // Incentive to be distributed to user for market creation\r\n        marketCreationIncentive = value;\r\n      } else if(code == \"MAXGAS\") { // Maximum gas upto which is considered while calculating market creation incentives\r\n        maxGasPrice = value;\r\n      } else if(code == \"MAXRPSP\") { // Max Reward Pool percent for market creator\r\n        maxRewardPoolPercForMC = value;\r\n      } else if(code == \"MINRPSP\") { // Min Reward Pool percent for market creator\r\n        minRewardPoolPercForMC = value;\r\n      } else if(code == \"PSFRPS\") { // Reward Pool percent for market creator\r\n        plotStakeForRewardPoolShare = value;\r\n      } else if(code == \"RPSTH\") { // Reward Pool percent for market creator\r\n        rewardPoolShareThreshold = value;\r\n      } else {\r\n        marketUtility.updateUintParameters(code, value);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Get uint config parameters\r\n    */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint256 value) {\r\n      codeVal = code;\r\n      if(code == \"MCRINC\") {\r\n        value = marketCreationIncentive;\r\n      } else if(code == \"MAXGAS\") {\r\n        value = maxGasPrice;\r\n      } else if(code == \"MAXRPSP\") {\r\n        value = maxRewardPoolPercForMC;\r\n      } else if(code == \"MINRPSP\") {\r\n        value = minRewardPoolPercForMC;\r\n      } else if(code == \"PSFRPS\") {\r\n        value = plotStakeForRewardPoolShare;\r\n      } else if(code == \"RPSTH\") {\r\n        value = rewardPoolShareThreshold;\r\n      }\r\n    }\r\n\r\n    function addInitialMarketTypesAndStart(uint64 _marketStartTime, address _ethMarketImplementation, address _btcMarketImplementation) external {\r\n      revert(\"Deprecated\");\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getOpenMarkets\",\"outputs\":[{\"name\":\"_openMarkets\",\"type\":\"address[]\"},{\"name\":\"_marketTypes\",\"type\":\"uint256[]\"},{\"name\":\"_marketCurrencies\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketAddress\",\"type\":\"address\"},{\"name\":\"_result\",\"type\":\"uint256\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimCreationReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseMarketCreation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultAddress\",\"type\":\"address\"},{\"name\":\"_marketUtility\",\"type\":\"address\"},{\"name\":\"_plotToken\",\"type\":\"address\"},{\"name\":\"_configParams\",\"type\":\"address[]\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelistedSponsor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketCreationData\",\"outputs\":[{\"name\":\"initialStartTime\",\"type\":\"uint64\"},{\"name\":\"marketAddress\",\"type\":\"address\"},{\"name\":\"penultimateMarket\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"plotToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"isAuthorizedToGovern\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketUtility\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketCreationPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clGasPriceAggregator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAssets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketType\",\"type\":\"uint256\"},{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"toggleMarketCreationType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"getMarketDetailsUser\",\"outputs\":[{\"name\":\"_market\",\"type\":\"address[]\"},{\"name\":\"_winnigOption\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"}],\"name\":\"getUintParameters\",\"outputs\":[{\"name\":\"codeVal\",\"type\":\"bytes8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"updateConfigAddressParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currencyIndexes\",\"type\":\"uint256[]\"},{\"name\":\"_marketImplementations\",\"type\":\"address[]\"}],\"name\":\"updateMarketImplementations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketStartTime\",\"type\":\"uint64\"},{\"name\":\"_ethMarketImplementation\",\"type\":\"address\"},{\"name\":\"_btcMarketImplementation\",\"type\":\"address\"}],\"name\":\"addInitialMarketTypesAndStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_predictionPoints\",\"type\":\"uint256\"},{\"name\":\"_predictionAsset\",\"type\":\"address\"},{\"name\":\"_prediction\",\"type\":\"uint256\"},{\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"setUserGlobalPredictionData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPendingMarketCreationRewards\",\"outputs\":[{\"name\":\"plotIncentive\",\"type\":\"uint256\"},{\"name\":\"pendingPLOTReward\",\"type\":\"uint256\"},{\"name\":\"pendingETHReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes8\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"burnDisputedProposalTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_market\",\"type\":\"address\"}],\"name\":\"getMarketCreatorRPoolShareParams\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalReward\",\"type\":\"uint256[]\"},{\"name\":\"winningOption\",\"type\":\"uint256\"},{\"name\":\"closeValue\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"callMarketResultEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeMarketCreation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketAdd\",\"type\":\"address\"}],\"name\":\"getMarketDetails\",\"outputs\":[{\"name\":\"_feedsource\",\"type\":\"bytes32\"},{\"name\":\"minvalue\",\"type\":\"uint256[]\"},{\"name\":\"maxvalue\",\"type\":\"uint256[]\"},{\"name\":\"optionprice\",\"type\":\"uint256[]\"},{\"name\":\"_ethStaked\",\"type\":\"uint256[]\"},{\"name\":\"_plotStaked\",\"type\":\"uint256[]\"},{\"name\":\"_predictionType\",\"type\":\"uint256\"},{\"name\":\"_expireTime\",\"type\":\"uint256\"},{\"name\":\"_predictionStatus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketType\",\"type\":\"uint256\"},{\"name\":\"_marketCurrencyIndex\",\"type\":\"uint256\"}],\"name\":\"createMarket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_reward\",\"type\":\"uint256[]\"},{\"name\":\"predictionAssets\",\"type\":\"address[]\"},{\"name\":\"incentives\",\"type\":\"uint256\"},{\"name\":\"incentiveToken\",\"type\":\"address\"}],\"name\":\"callClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketImplementation\",\"type\":\"address\"},{\"name\":\"_marketStartTime\",\"type\":\"uint64\"}],\"name\":\"addNewMarketCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxyAddress\",\"type\":\"address\"},{\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeContractImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clGasPriceAggregator\",\"type\":\"address\"}],\"name\":\"setGasPriceAggAndMaxGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxRecords\",\"type\":\"uint256\"}],\"name\":\"claimCreationRewardV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_predictionTime\",\"type\":\"uint64\"},{\"name\":\"_marketStartTime\",\"type\":\"uint64\"},{\"name\":\"_optionRangePerc\",\"type\":\"uint64\"}],\"name\":\"addNewMarketType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalReward\",\"type\":\"uint256[]\"},{\"name\":\"marketCreatorIncentive\",\"type\":\"uint256[]\"},{\"name\":\"winningOption\",\"type\":\"uint256\"},{\"name\":\"closeValue\",\"type\":\"uint256\"},{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"callMarketResultEventAndSetIncentives\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalTitle\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"solutionHash\",\"type\":\"string\"},{\"name\":\"action\",\"type\":\"bytes\"},{\"name\":\"_stakeForDispute\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_ethSentToPool\",\"type\":\"uint256\"},{\"name\":\"_tokenSentToPool\",\"type\":\"uint256\"},{\"name\":\"_proposedValue\",\"type\":\"uint256\"}],\"name\":\"createGovernanceProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTotalAssetStakedByUser\",\"outputs\":[{\"name\":\"_plotStaked\",\"type\":\"uint256\"},{\"name\":\"_ethStaked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketType\",\"type\":\"uint256\"},{\"name\":\"_marketCurrencyIndex\",\"type\":\"uint256\"}],\"name\":\"calculateStartTimeForMarket\",\"outputs\":[{\"name\":\"_marketStartTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxRecords\",\"type\":\"uint256\"}],\"name\":\"claimPendingReturn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"createdBy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"marketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"plotIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethIncentive\",\"type\":\"uint256\"}],\"name\":\"MarketCreatorRewardPoolShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"createdBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"marketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"plotIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasPriceConsidered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasPriceGiven\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxGasCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardPoolSharePerc\",\"type\":\"uint256\"}],\"name\":\"MarketCreationReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"plotIncentive\",\"type\":\"uint256\"}],\"name\":\"ClaimedMarketCreationReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"marketAdd\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stockName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"predictionType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"MarketQuestion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"predictionPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"predictionAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prediction\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"marketAdd\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_leverage\",\"type\":\"uint256\"}],\"name\":\"PlacePrediction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"marketAdd\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalReward\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"winningOption\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closeValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"MarketResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"marketAdd\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_predictionAssets\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"incentive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"incentiveToken\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"predictionTime\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"optionRangePerc\",\"type\":\"uint64\"}],\"name\":\"MarketTypes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"marketImplementation\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feedAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyName\",\"type\":\"bytes32\"}],\"name\":\"MarketCurrencies\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"marketAdd\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"raisedBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proposalId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"proposedValue\",\"type\":\"uint256\"}],\"name\":\"DisputeRaised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"marketAdd\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"}]","ContractName":"MarketRegistryNew","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0276401bdde657b510a7c106be1bba25ab5a9f33b9a9bfec98c44558c8bf6b46"}]}