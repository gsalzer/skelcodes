{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\nimport { ITokenManager, IERC20, ISafeMath } from \\u0027./Interfaces.sol\\u0027;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Implementation of ERC20 Standard\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract ERC20 is IERC20 {\\r\\n    string public _symbol;\\r\\n    string public _name;\\r\\n    uint8 public _decimals;\\r\\n    uint public _totalSupply;\\r\\n\\r\\n    // For each person map between their address and the number of tokens they have\\r\\n    mapping(address =\\u003e uint) balances;\\r\\n    // To transfer erc20 token, give contract permission to transfer. Maps from your address to address of transfer target and amount to transfer.\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\r\\n\\r\\n    ISafeMath immutable public safemath;\\r\\n\\r\\n    constructor(string memory symbol, string memory name, uint8 decimals, uint total_supply, ISafeMath safemath_contract) {\\r\\n        _symbol = symbol;\\r\\n        _name = name;\\r\\n        _decimals = decimals;\\r\\n        _totalSupply = total_supply;\\r\\n        safemath = safemath_contract;\\r\\n    }\\r\\n\\r\\n    //Returns decimals that this token uses.\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n\\r\\n    //Returns the token name\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n\\r\\n    //Returns the symbol\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Return total supply\\r\\n    function totalSupply() public override view returns (uint) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Return the token balance for account tokenOwner\\r\\n    function balanceOf(address _token_owner) public override view returns (uint balance) {\\r\\n        return balances[_token_owner];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer the balance from token owner\\u0027s account to to account\\r\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transfer(address _to, uint _num_tokens) public override returns (bool success) {\\r\\n        require(_num_tokens \\u003c= balances[msg.sender], \\\"You are trying to transfer more tokens than you have\\\");\\r\\n\\r\\n        balances[msg.sender] = safemath.sub(balances[msg.sender], _num_tokens);\\r\\n        balances[_to] = safemath.add(balances[_to], _num_tokens);\\r\\n        emit Transfer(msg.sender, _to, _num_tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for spender to transferFrom(...) tokens\\r\\n    // from the token owner\\u0027s account\\r\\n    //\\r\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n    // recommends that there are no checks for the approval double-spend attack\\r\\n    // as this should be implemented in user interfaces\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approve(address spender, uint tokens) public override returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Non-standard approval function that takes care of the potential double-spend issue\\r\\n    // If a user wants to ensure that the double spend issue doesn\\u0027t become a problem, they can choose\\r\\n    // to use this function instead of the standard approve function.\\r\\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool success) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        allowed[msg.sender][_spender] = safemath.add(oldValue, _addedValue);\\r\\n        emit Approval(msg.sender, _spender, safemath.add(oldValue, _addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Non-standard approval function that takes care of the potential double-spend issue\\r\\n    // If a user wants to ensure that the double spend issue doesn\\u0027t become a problem, they can choose\\r\\n    // to use this function instead of the standard approve function.\\r\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool success) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        allowed[msg.sender][_spender] = safemath.sub(oldValue, _subtractedValue);\\r\\n        emit Approval(msg.sender, _spender, safemath.sub(oldValue, _subtractedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer tokens from the from account to the to account\\r\\n    //\\r\\n    // The calling account must already have sufficient tokens approve(...)-d\\r\\n    // for spending from the from account and\\r\\n    // - From account must have sufficient balance to transfer\\r\\n    // - Spender must have sufficient allowance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\\r\\n        balances[from] = safemath.sub(balances[from], tokens);\\r\\n        allowed[from][msg.sender] = safemath.sub(allowed[from][msg.sender], tokens);\\r\\n        balances[to] = safemath.add(balances[to], tokens);\\r\\n        emit Transfer(from, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Returns the amount of tokens approved by the owner that can be\\r\\n    // transferred to the spender\\u0027s account\\r\\n    // ------------------------------------------------------------------------\\r\\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\\r\\n        return allowed[tokenOwner][spender];\\r\\n    }\\r\\n\\r\\n}\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\n\\r\\ninterface ITokenManager {\\r\\n    function payout(string calldata quarter, address recipient, uint amount) external returns (bool success);\\r\\n}\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// ERC Token Standard #20 Interface\\r\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n// ----------------------------------------------------------------------------\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface ISafeMath {\\r\\n    function add(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function sub(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function mul(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function div(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function min(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function mod(uint256 a, uint256 b) external pure returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IKladeDiffToken {\\r\\n    function set_payout(uint payout) external;\\r\\n    function mint_tokens(address token_recipient, uint256 numToMint) external returns (bool success);\\r\\n}\\r\\n\\r\\ninterface IChainlinkOracle {\\r\\n    function latestRoundData() external view returns (\\r\\n          uint80,\\r\\n          int256,\\r\\n          uint256,\\r\\n          uint256,\\r\\n          uint80\\r\\n    );\\r\\n}\"},\"TokenManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\nimport { IERC20, ISafeMath, IKladeDiffToken } from \\u0027./Interfaces.sol\\u0027;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// This contract is used to \\\"manage\\\" Klade Tokens. Specifically you can use\\r\\n// it to mint tokens for any quarter and it holds the collateral you send over\\r\\n// until payouts are taken, at which point the Klade Tokens can take the collateral\\r\\n// and send it to the token holders as payout.\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract TokenManager {\\r\\n    address public immutable KladeAddress1;\\r\\n    address public immutable KladeAddress2;\\r\\n    ISafeMath public immutable safemath;\\r\\n    IERC20 public immutable wbtc;\\r\\n\\r\\n    uint public uncollected_fees = 0;\\r\\n    uint public constant fee = 640; // Fee per 0.1 pairs minted in satoshis\\r\\n\\r\\n    struct quarter_data_component {\\r\\n        address AlphaToken;\\r\\n        address OmegaToken;\\r\\n        uint required_collateral; // Required Collateral for 0.1 pairs minted in satoshis\\r\\n        uint total_collateral_backing;\\r\\n    }\\r\\n\\r\\n    mapping(string =\\u003e quarter_data_component) public quarter_data;\\r\\n    mapping(string =\\u003e bool) public quarter_set;\\r\\n\\r\\n    constructor(address klade_address1, address klade_address2, ISafeMath safemath_contract, IERC20 wbtc_contract) {\\r\\n        KladeAddress1 = klade_address1;\\r\\n        KladeAddress2 = klade_address2;\\r\\n        safemath = safemath_contract;\\r\\n        wbtc = wbtc_contract;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * Adds token data for a quarter.\\r\\n     * Require #1: Ensures that once a quarter\\u0027s data is set, it cannot be changed.\\r\\n     * Require #2: Function can only be called by Klade\\r\\n     * The quarter string will follow the format \\\"Q12021\\\".\\r\\n     * required_collateral should be the required collateral for 0.1 pairs of Klade Tokens in WBTC units\\r\\n     * @param quarter string - String representing Quarter that token will be added for - ie Q12021 for Quarter 1 of 2021\\r\\n     * @param alpha_token_address address - Address of Klade Alpha Token\\r\\n     * @param omega_token_address address - Address of Klade Omega Token\\r\\n     * @param required_collateral uint - Required collateral to mint one pair of Klade Alpha/Omega Token\\r\\n     */\\r\\n    function add_new_token_pair(string calldata quarter, address alpha_token_address, address omega_token_address, uint required_collateral) external {\\r\\n        require(!quarter_set[quarter], \\\"Quarter Already Set\\\");\\r\\n        require(msg.sender == KladeAddress1 || msg.sender == KladeAddress2, \\\"Only Klade can add token pairs\\\");\\r\\n        quarter_data[quarter] = quarter_data_component(alpha_token_address, omega_token_address, required_collateral, 0);\\r\\n        quarter_set[quarter] = true;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  This function requires the user to send over wBTC in order to mint (_numToMint/10) pairs of tokens for the given\\r\\n     * quarter. Ex. _numPairsToMint is set to 100, the recipients will each be credited with 10 alpha and omega tokens respectively.\\r\\n     * @param quarter string - String representing Quarter that token will be added for - ie Q12021 for Quarter 1 of 2021\\r\\n     * @param _alpha_token_recipient address - Address of Klade Alpha Token receiver\\r\\n     * @param _omega_token_recipient address - Address of Klade Omega Token receiver\\r\\n     * @param _numPairsToMint uint - Number of Klade Alpha/Omega pairs to mint\\r\\n     */\\r\\n    function mint_tokens(string calldata quarter, address _alpha_token_recipient, address _omega_token_recipient, uint256 _numPairsToMint) external {\\r\\n        require(quarter_set[quarter], \\\"Quarter not set\\\");\\r\\n\\r\\n        uint collateral = safemath.mul(_numPairsToMint, quarter_data[quarter].required_collateral);\\r\\n        uint minting_fees = safemath.mul(_numPairsToMint, fee);\\r\\n\\r\\n        require(wbtc.transferFrom(msg.sender, address(this), safemath.add(collateral, minting_fees)));\\r\\n        quarter_data[quarter].total_collateral_backing = safemath.add(collateral, quarter_data[quarter].total_collateral_backing);\\r\\n\\r\\n        IKladeDiffToken alpha_token = IKladeDiffToken(quarter_data[quarter].AlphaToken);\\r\\n        IKladeDiffToken omega_token = IKladeDiffToken(quarter_data[quarter].OmegaToken);\\r\\n\\r\\n        // if either mint fails then the whole transaction is reverted\\r\\n        uint units_to_mint = safemath.mul(10**17, _numPairsToMint);\\r\\n        require(alpha_token.mint_tokens(_alpha_token_recipient, units_to_mint));\\r\\n        require(omega_token.mint_tokens(_omega_token_recipient, units_to_mint));\\r\\n        uncollected_fees = safemath.add(uncollected_fees, minting_fees);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /**\\r\\n     * This function can only be called by a registered Klade Token\\r\\n     * The payout will be sent to payout_recipient\\r\\n     * impossible that a token can claim collateral from another quarter. \\r\\n     * Line 100 reverts if amount \\u003e quarter_data[quarter].total_collateral_backing\\r\\n     * @param quarter string - String representing Quarter that token will be added for - ie Q12021 for Quarter 1 of 2021\\r\\n     * @param recipient address - The recipient of the WBTC payout\\r\\n     * @param amount uint - amount of WBTC to payout\\r\\n     */\\r\\n    function payout(string calldata quarter, address recipient, uint amount) external returns (bool success) {\\r\\n        require(quarter_set[quarter], \\\"Quarter not set\\\");\\r\\n        require(quarter_data[quarter].AlphaToken == msg.sender || quarter_data[quarter].OmegaToken == msg.sender, \\\"Only Alpha and Omega can transfer payout\\\");\\r\\n        quarter_data[quarter].total_collateral_backing = safemath.sub(quarter_data[quarter].total_collateral_backing, amount);\\r\\n        require(wbtc.transfer(recipient, amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Klade can collect fees\\r\\n    function collect_fees() external {\\r\\n        require(msg.sender == KladeAddress1 || msg.sender == KladeAddress2, \\\"Only Klade wallets can collect minting fees\\\");\\r\\n        uint to_pay = uncollected_fees;\\r\\n        uncollected_fees = 0;\\r\\n        require(wbtc.transfer(msg.sender, to_pay), \\\"Failed to send minting fees\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Don\\u0027t accept ETH\\r\\n    // ------------------------------------------------------------------------\\r\\n    fallback () external payable {\\r\\n        revert();\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"klade_address1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"klade_address2\",\"type\":\"address\"},{\"internalType\":\"contract ISafeMath\",\"name\":\"safemath_contract\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"wbtc_contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"KladeAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KladeAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"quarter\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"alpha_token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"omega_token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required_collateral\",\"type\":\"uint256\"}],\"name\":\"add_new_token_pair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collect_fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"quarter\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_alpha_token_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_omega_token_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numPairsToMint\",\"type\":\"uint256\"}],\"name\":\"mint_tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"quarter\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"quarter_data\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"AlphaToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"OmegaToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required_collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_collateral_backing\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"quarter_set\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safemath\",\"outputs\":[{\"internalType\":\"contract ISafeMath\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uncollected_fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbtc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenManager","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a61a62352faf6ad883a8d36975cf39cdeb477d25000000000000000000000000e4147a2b5bac2d1b9fa23a1c0d477700af590280000000000000000000000000fd629b1fbc77644b23287f8acd0aea58ac695c350000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://577ebd0eebf6beb59441e31631edc30009ba1c6eb35c77c7ac95257afa9b3e2b"}]}