{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.4;\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IESDS {\r\n    function redeemCoupons(uint _epoch, uint _couponAmount) external;\r\n    function transferCoupons(address _sender, address _recipient, uint _epoch, uint _amount) external;\r\n    function totalRedeemable() external view returns (uint);\r\n    function epoch() external view returns (uint);\r\n    function balanceOfCoupons(address _account, uint _epoch) external view returns (uint);\r\n    function advance() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n}\r\n\r\ninterface ICHI {\r\n    function freeFromUpTo(address _addr, uint _amount) external returns (uint);\r\n}\r\n\r\n// @notice Lets anybody trustlessly redeem coupons on anyone else's behalf for a fee.\r\n//    Requires that the coupon holder has previously approved this contract via the ESDS `approveCoupons` function.\r\n// @dev Bots should scan for the `CouponApproval` event emitted by the ESDS `approveCoupons` function to find out which \r\n//    users have approved this contract to redeem their coupons.\r\n// @dev This contract's API should be backwards compatible with other CouponClippers.\r\ncontract CouponClipper {\r\n    using SafeMath for uint;\r\n\r\n    IERC20 constant private ESD = IERC20(0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723);\r\n    IESDS constant private ESDS = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\r\n    ICHI  constant private CHI = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n\r\n    // HOUSE_RATE_HALVING_AMNT -- Every time a bot brings in 100000ESD for the house, the house's\r\n    // rate will be cut in half *for that bot and that bot alone*:\r\n    // * 50.0% of offer for 0 -> 100000ESD\r\n    // * 25.0% of offer 100000ESD -> 200000ESD\r\n    // * 12.5% of offer 200000ESD -> 300000ESD\r\n    // ...\r\n    uint constant private HOUSE_RATE_HALVING_AMNT = 100000e18;\r\n    uint constant private HOUSE_RATE = 5000; // 50% -- initial portion of the offer taken by house\r\n    uint constant private MAX_OFFER = 10000; // 100% -- obviously you can't offer more than 100%\r\n    \r\n    address public house = 0x871ee4648d0FBB08F39857F41da256659Eab6334; // collector of house take\r\n\r\n    // The basis points offered by coupon holders to have their coupons redeemed -- default is 200 bps (2.0%)\r\n    // E.g., offers[_user] = 500 indicates that _user will pay 500 basis points (5%) to the caller\r\n    mapping(address => uint) private offers;\r\n    // The cumulative revenue (in ESD) earned by the house because of a given bot's hard work. Any time\r\n    // this value crosses a multiple of 100000, the house's take rate will be halved.\r\n    // NOTE: This advantage is non-transferrable. Bots are encouraged to keep their address constant\r\n    mapping(address => uint) private houseTakes;\r\n    \r\n    event SetOffer(address indexed user, uint offer);\r\n    \r\n    // frees CHI from msg.sender to reduce gas costs\r\n    // requires that msg.sender has approved this contract to use their CHI\r\n    modifier useCHI {\r\n        uint gasStart = gasleft();\r\n        _;\r\n        uint gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);\r\n        CHI.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n    }\r\n\r\n    // @notice Gets the number of basis points the _user is offering the bots\r\n    // @param _user The account whose offer we're looking up.\r\n    // @return The number of basis points the account is offering to have their coupons redeemed\r\n    function getOffer(address _user) public view returns (uint) {\r\n        return offers[_user];\r\n    }\r\n\r\n    // @notice Allows msg.sender to change the number of basis points they are offering.\r\n    // @dev _newOffer must be no more than 10_000 (100%)\r\n    // @dev A user's offer cannot be *decreased* during the 15 minutes before the epoch advance (frontrun protection)\r\n    // @param _offer The number of basis points msg.sender wants to offer to have their coupons redeemed.\r\n    function setOffer(uint _newOffer) external {\r\n        require(_newOffer <= MAX_OFFER, \"Clipper: Offer too high\");\r\n\r\n        if (_newOffer < offers[msg.sender]) {\r\n            uint nextEpochStartTime = getEpochStartTime(ESDS.epoch() + 1);\r\n            uint timeUntilNextEpoch = nextEpochStartTime.sub(block.timestamp);\r\n            require(timeUntilNextEpoch > 15 minutes, \"Clipper: Wait until next epoch\");\r\n        }\r\n        \r\n        offers[msg.sender] = _newOffer;\r\n        emit SetOffer(msg.sender, _newOffer);\r\n    }\r\n    \r\n    // @notice Internal logic used to redeem coupons on the coupon holder's bahalf\r\n    // @param _user Address of the user holding the coupons (and who has approved this contract)\r\n    // @param _epoch The epoch in which the _user purchased the coupons\r\n    // @param _couponAmount The number of coupons to redeem (18 decimals)\r\n    // @return the fee (in ESD) owned to the bot (msg.sender)\r\n    function _redeem(address _user, uint _epoch, uint _couponAmount) internal returns (uint) {\r\n        // pull user's coupons into this contract (requires that the user has approved this contract)\r\n        try ESDS.transferCoupons(_user, address(this), _epoch, _couponAmount) {\r\n            // redeem the coupons for ESD\r\n            try ESDS.redeemCoupons(_epoch, _couponAmount) {\r\n                // compute fees\r\n                uint fee = _couponAmount.mul(getOffer(_user)).div(10_000);\r\n                // send the ESD to the user\r\n                ESD.transfer(_user, _couponAmount.sub(fee)); // @audit-info : reverts on failure\r\n\r\n                // (x >> y) is equivalent to (x / 2**y) for positive integers\r\n                uint houseRate = HOUSE_RATE >> houseTakes[tx.origin].div(HOUSE_RATE_HALVING_AMNT);\r\n                uint houseFee = fee.mul(houseRate).div(10_000);\r\n                houseTakes[tx.origin] = houseTakes[tx.origin].add(houseFee);\r\n\r\n                // return the bot fee\r\n                return fee.sub(houseFee);\r\n            } catch {\r\n                // In this block the transfer succeeded but redemption failed, so we need to undo the transfer!!\r\n                ESDS.transferCoupons(address(this), _user, _epoch, _couponAmount);\r\n                return 0;\r\n            }\r\n        } catch {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // @notice Internal logic used to redeem coupons on the coupon holder's bahalf\r\n    // @param _users Addresses of users holding the coupons (and who has approved this contract)\r\n    // @param _epochs The epochs in which the _users purchased the coupons\r\n    // @param _couponAmounts The numbers of coupons to redeem (18 decimals)\r\n    // @return the total fee (in ESD) owned to the bot (msg.sender)\r\n    function _redeemMany(address[] calldata _users, uint[] calldata _epochs, uint[] calldata _couponAmounts) internal returns (uint) {\r\n        // 0 by default, would cost extra gas to make that explicit\r\n        uint botFee;\r\n\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            botFee = botFee.add(_redeem(_users[i], _epochs[i], _couponAmounts[i]));\r\n        }\r\n\r\n        return botFee;\r\n    }\r\n    \r\n    // @notice Allows anyone to redeem coupons for ESD on the coupon-holder's bahalf\r\n    // @dev Backwards compatible with CouponClipper V1.\r\n    function redeem(address _user, uint _epoch, uint _couponAmount) external {\r\n        ESD.transfer(msg.sender, _redeem(_user, _epoch, _couponAmount));\r\n    }\r\n\r\n    function redeemMany(address[] calldata _users, uint[] calldata _epochs, uint[] calldata _couponAmounts) external {\r\n        ESD.transfer(msg.sender, _redeemMany(_users, _epochs, _couponAmounts));\r\n    }\r\n    \r\n    // @notice Advances the epoch (if needed) and redeems the max amount of coupons possible\r\n    //    Also frees CHI tokens to save on gas (requires that msg.sender has CHI tokens in their\r\n    //    account and has approved this contract to spend their CHI).\r\n    // @param _user The user whose coupons will attempt to be redeemed\r\n    // @param _epoch The epoch in which the coupons were created\r\n    // @param _targetEpoch The epoch that is about to be advanced _to_.\r\n    //    E.g., if the current epoch is 220 and we are about to advance to to epoch 221, then _targetEpoch\r\n    //    would be set to 221. The _targetEpoch is the epoch in which the coupon redemption will be attempted.\r\n    function advanceAndRedeem(address _user, uint _epoch, uint _targetEpoch) external useCHI {\r\n        // End execution early if tx is mined too early\r\n        if (block.timestamp < getEpochStartTime(_targetEpoch)) return;\r\n        \r\n        // advance epoch if it has not already been advanced \r\n        if (ESDS.epoch() != _targetEpoch) ESDS.advance();\r\n        \r\n        // get max redeemable amount\r\n        uint totalRedeemable = ESDS.totalRedeemable();\r\n        if (totalRedeemable == 0) return; // no coupons to redeem\r\n        uint userBalance = ESDS.balanceOfCoupons(_user, _epoch);\r\n        if (userBalance == 0) return; // no coupons to redeem\r\n        uint maxRedeemableAmount = totalRedeemable < userBalance ? totalRedeemable : userBalance;\r\n        \r\n        // attempt to redeem coupons\r\n        ESD.transfer(msg.sender, _redeem(_user, _epoch, maxRedeemableAmount));\r\n    }\r\n\r\n    // @notice Advances the epoch (if needed) and redeems the max amount of coupons possible\r\n    //    Also frees CHI tokens to save on gas (requires that msg.sender has CHI tokens in their\r\n    //    account and has approved this contract to spend their CHI).\r\n    // @param _users The users whose coupons will attempt to be redeemed\r\n    // @param _epochs The epochs in which the coupons were created\r\n    // @param _targetEpoch The epoch that is about to be advanced _to_.\r\n    //    E.g., if the current epoch is 220 and we are about to advance to to epoch 221, then _targetEpoch\r\n    //    would be set to 221. The _targetEpoch is the epoch in which the coupon redemption will be attempted.\r\n    function advanceAndRedeemMany(address[] calldata _users, uint[] calldata _epochs, uint _targetEpoch) external useCHI {\r\n        // End execution early if tx is mined too early\r\n        if (block.timestamp < getEpochStartTime(_targetEpoch)) return;\r\n\r\n        // Advance the epoch if necessary\r\n        if (ESDS.epoch() != _targetEpoch) ESDS.advance();\r\n        \r\n        // 0 by default, would cost extra gas to make that explicit\r\n        uint botFee;\r\n        uint amtToRedeem;\r\n        uint totalRedeemable = ESDS.totalRedeemable();\r\n\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            if (totalRedeemable == 0) break;\r\n\r\n            amtToRedeem = ESDS.balanceOfCoupons(_users[i], _epochs[i]);\r\n            if (totalRedeemable < amtToRedeem) amtToRedeem = totalRedeemable;\r\n\r\n            botFee = botFee.add(_redeem(_users[i], _epochs[i], amtToRedeem));\r\n            totalRedeemable = totalRedeemable.sub(amtToRedeem);\r\n        }\r\n\r\n        ESD.transfer(msg.sender, botFee);\r\n    }\r\n\r\n    \r\n    // @notice Returns the timestamp at which the _targetEpoch starts\r\n    function getEpochStartTime(uint _targetEpoch) public pure returns (uint) {\r\n        return _targetEpoch.sub(106).mul(28800).add(1602201600);\r\n    }\r\n    \r\n    // @notice Allows house address to change the house address\r\n    function changeHouseAddress(address _newAddress) external {\r\n        require(msg.sender == house);\r\n        house = _newAddress;\r\n    }\r\n\r\n    // @notice Allows house to withdraw accumulated fees\r\n    function withdraw(address _token, uint _amount) external {\r\n        IERC20(_token).transfer(house, _amount);\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b) internal pure returns (uint) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer\",\"type\":\"uint256\"}],\"name\":\"SetOffer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetEpoch\",\"type\":\"uint256\"}],\"name\":\"advanceAndRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_epochs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_targetEpoch\",\"type\":\"uint256\"}],\"name\":\"advanceAndRedeemMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeHouseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetEpoch\",\"type\":\"uint256\"}],\"name\":\"getEpochStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"house\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_couponAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_epochs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_couponAmounts\",\"type\":\"uint256[]\"}],\"name\":\"redeemMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newOffer\",\"type\":\"uint256\"}],\"name\":\"setOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CouponClipper","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"1337","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fe98b1de64f303149da6a5839410edc661c64b9e11090d773ab22ebce11be013"}]}