{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity = 0.7.0;\r\n\r\n\r\ninterface PoolFactory {\r\n    event PoolCreatedEvent(address tokenA, address tokenB, bool aIsWETH, address indexed pool);\r\n\r\n    function getPool(address tokenA, address tokenB) external returns (address);\r\n    function findPool(address tokenA, address tokenB) external view returns (address);\r\n    function pools(uint poolIndex) external view returns (address pool);\r\n    function getPoolCount() external view returns (uint);\r\n}\r\n\r\ninterface ERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool success);\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function transfer(address to, uint256 value) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ninterface ActivityMeter {\r\n    event Deposit(address indexed user, address indexed pool, uint amount);\r\n    event Withdraw(address indexed user, address indexed pool, uint amount);\r\n\r\n    function actualizeUserPool(uint endPeriod, address user, address pool) external returns (uint ethLocked, uint mintedAmount) ;  \r\n    function deposit(address pool, uint128 amount) external returns (uint ethLocked, uint mintedAmount);\r\n    function withdraw(address pool, uint128 amount) external returns (uint ethLocked, uint mintedAmount);\r\n    function actualizeUserPools() external returns (uint ethLocked, uint mintedAmount);\r\n    function liquidityEthPriceChanged(uint effectiveTime, uint availableBalanceEth, uint totalSupply) external;\r\n    function effectivePeriod(uint effectiveTime) external view returns (uint periodNumber, uint quantaElapsed);\r\n    function governanceRouter() external view returns (GovernanceRouter);\r\n    function userEthLocked(address user) external view returns (uint ethLockedPeriod, uint ethLocked, uint totalEthLocked);\r\n    \r\n    function ethLockedHistory(uint period) external view returns (uint ethLockedTotal);\r\n\r\n    function poolsPriceHistory(uint period, address pool) external view returns (\r\n        uint cumulativeEthPrice,\r\n        uint240 lastEthPrice,\r\n        uint16 timeRef\r\n    );\r\n\r\n    function userPoolsSummaries(address user, address pool) external view returns (\r\n        uint144 cumulativeAmountLocked,\r\n        uint16 amountChangeQuantaElapsed,\r\n\r\n        uint128 lastAmountLocked,\r\n        uint16 firstPeriod,\r\n        uint16 lastPriceRecord,\r\n        uint16 earnedForPeriod\r\n    );\r\n\r\n    function userPools(address user, uint poolIndex) external view returns (address pool);\r\n    function userPoolsLength(address user) external view returns (uint length);\r\n\r\n    function userSummaries(address user) external view returns (\r\n        uint128 ethLocked,\r\n        uint16 ethLockedPeriod,\r\n        uint16 firstPeriod\r\n    );\r\n    \r\n    function poolSummaries(address pool) external view returns (\r\n        uint16 lastPriceRecord\r\n    );\r\n    \r\n    function users(uint userIndex) external view returns (address user);\r\n    function usersLength() external view returns (uint);\r\n}\r\n\r\ninterface Minter is ERC20 {\r\n    event Mint(address indexed to, uint256 value, uint indexed period, uint userEthLocked, uint totalEthLocked);\r\n\r\n    function governanceRouter() external view returns (GovernanceRouter);\r\n    function mint(address to, uint period, uint128 userEthLocked, uint totalEthLocked) external returns (uint amount);\r\n    function userTokensToClaim(address user) external view returns (uint amount);\r\n    function periodTokens(uint period) external pure returns (uint128);\r\n    function periodDecayK() external pure returns (uint decayK);\r\n    function initialPeriodTokens() external pure returns (uint128);\r\n}\r\n\r\ninterface WETH is ERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface GovernanceRouter {\r\n    event GovernanceApplied(uint packedGovernance);\r\n    event GovernorChanged(address covernor);\r\n    event ProtocolFeeReceiverChanged(address protocolFeeReceiver);\r\n    event PoolFactoryChanged(address poolFactory);\r\n\r\n    function schedule() external returns(uint timeZero, uint miningPeriod);\r\n    function creator() external returns(address);\r\n    function weth() external returns(WETH);\r\n\r\n    function activityMeter() external returns(ActivityMeter);\r\n    function setActivityMeter(ActivityMeter _activityMeter) external;\r\n\r\n    function minter() external returns(Minter);\r\n    function setMinter(Minter _minter) external;\r\n\r\n    function poolFactory() external returns(PoolFactory);\r\n    function setPoolFactory(PoolFactory _poolFactory) external;\r\n\r\n    function protocolFeeReceiver() external returns(address);\r\n    function setProtocolFeeReceiver(address _protocolFeeReceiver) external;\r\n\r\n    function governance() external view returns (address _governor, uint96 _defaultGovernancePacked);\r\n    function setGovernor(address _governor) external;\r\n    function applyGovernance(uint96 _defaultGovernancePacked) external;\r\n}\r\n\r\ninterface LiquidityPool is ERC20 {\r\n    enum MintReason { DEPOSIT, PROTOCOL_FEE, INITIAL_LIQUIDITY }\r\n    event Mint(address indexed to, uint256 value, MintReason reason);\r\n\r\n    // ORDER_CLOSED reasons are all odd, other reasons are even\r\n    // it allows to check ORDER_CLOSED reasons as (reason & ORDER_CLOSED) != 0\r\n    enum BreakReason { \r\n        NONE,        ORDER_CLOSED, \r\n        ORDER_ADDED, ORDER_CLOSED_BY_STOP_LOSS, \r\n        SWAP,        ORDER_CLOSED_BY_REQUEST,\r\n        MINT,        ORDER_CLOSED_BY_HISTORY_LIMIT,\r\n        BURN,        ORDER_CLOSED_BY_GOVERNOR\r\n    }\r\n\r\n    function poolBalances() external view returns (\r\n        uint balanceALocked,\r\n        uint poolFlowSpeedA, // flow speed: (amountAIn * 2^32)/second\r\n\r\n        uint balanceBLocked,\r\n        uint poolFlowSpeedB, // flow speed: (amountBIn * 2^32)/second\r\n\r\n        uint totalBalanceA,\r\n        uint totalBalanceB,\r\n\r\n        uint delayedSwapsIncome,\r\n        uint rootKLastTotalSupply\r\n    );\r\n\r\n    function governanceRouter() external returns (GovernanceRouter);\r\n    function minimumLiquidity() external returns (uint);\r\n    function aIsWETH() external returns (bool);\r\n\r\n    function mint(address to) external returns (uint liquidityOut);\r\n    function burn(address to, bool extractETH) external returns (uint amountAOut, uint amountBOut);\r\n    function swap(address to, bool extractETH, uint amountAOut, uint amountBOut, bytes calldata externalData) external returns (uint amountAIn, uint amountBIn);\r\n\r\n    function tokenA() external view returns (ERC20);\r\n    function tokenB() external view returns (ERC20);\r\n}\r\n\r\ninterface DelayedExchangePool is LiquidityPool {\r\n    event FlowBreakEvent( \r\n        address sender, \r\n        // total balance contains 128 bit of totalBalanceA and 128 bit of totalBalanceB\r\n        uint totalBalance, \r\n        // contains 128 bits of rootKLast and 128 bits of totalSupply\r\n        uint rootKLastTotalSupply, \r\n        uint indexed orderId,\r\n        // breakHash is computed over all fields below\r\n        \r\n        bytes32 lastBreakHash,\r\n        // availableBalance consists of 128 bits of availableBalanceA and 128 bits of availableBalanceB\r\n        uint availableBalance, \r\n        // flowSpeed consists of 144 bits of poolFlowSpeedA and 112 higher bits of poolFlowSpeedB\r\n        uint flowSpeed,\r\n        // others consists of 32 lower bits of poolFlowSpeedB, 16 bit of notFee, 64 bit of time, 64 bit of orderId, 76 higher bits of packed and 4 bit of reason (BreakReason)\r\n        uint others      \r\n    );\r\n\r\n    event OrderClaimedEvent(uint indexed orderId, address to);\r\n    event OperatingInInvalidState(uint location, uint invalidStateReason);\r\n    event GovernanceApplied(uint packedGovernance);\r\n    \r\n    function addOrder(\r\n        address owner, uint orderFlags, uint prevByStopLoss, uint prevByTimeout, \r\n        uint stopLossAmount, uint period\r\n    ) external returns (uint id);\r\n\r\n    // availableBalance contains 128 bits of availableBalanceA and 128 bits of availableBalanceB\r\n    // delayedSwapsIncome contains 128 bits of delayedSwapsIncomeA and 128 bits of delayedSwapsIncomeB\r\n    function processDelayedOrders() external returns (uint availableBalance, uint delayedSwapsIncome, uint packed);\r\n\r\n    function claimOrder (\r\n        bytes32 previousBreakHash,\r\n        // see LiquifyPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaksHistory\r\n    ) external returns (address owner, uint amountAOut, uint amountBOut);\r\n\r\n    function applyGovernance(uint packedGovernanceFields) external;\r\n    function sync() external;\r\n    function closeOrder(uint id) external;\r\n\r\n    function poolQueue() external view returns (\r\n        uint firstByTokenAStopLoss, uint lastByTokenAStopLoss, // linked list of orders sorted by (amountAIn/stopLossAmount) ascending\r\n        uint firstByTokenBStopLoss, uint lastByTokenBStopLoss, // linked list of orders sorted by (amountBIn/stopLossAmount) ascending\r\n    \r\n        uint firstByTimeout, uint lastByTimeout // linked list of orders sorted by timeouts ascending\r\n    );\r\n\r\n    function lastBreakHash() external view returns (bytes32);\r\n\r\n    function poolState() external view returns (\r\n        bytes32 _prevBlockBreakHash,\r\n        uint packed, // see Liquifi.PoolState for details\r\n        uint notFee,\r\n\r\n        uint lastBalanceUpdateTime,\r\n        uint nextBreakTime,\r\n        uint maxHistory,\r\n        uint ordersToClaimCount,\r\n        uint breaksCount\r\n    );\r\n\r\n    function findOrder(uint orderId) external view returns (        \r\n        uint nextByTimeout, uint prevByTimeout,\r\n        uint nextByStopLoss, uint prevByStopLoss,\r\n        \r\n        uint stopLossAmount,\r\n        uint amountIn,\r\n        uint period,\r\n        \r\n        address owner,\r\n        uint timeout,\r\n        uint flags\r\n    );\r\n}\r\n\r\nenum ConvertETH { NONE, IN_ETH, OUT_ETH }\r\n\r\ninterface PoolRegister {\r\n    event Mint(address token1, uint amount1, address token2, uint amount2, uint liquidityOut, address to, ConvertETH convertETH);\r\n    event Burn(address token1, uint amount1, address token2, uint amount2, uint liquidityIn, address to, ConvertETH convertETH);\r\n    event Swap(address tokenIn, uint amountIn, address tokenOut, uint amountOut, address to, ConvertETH convertETH, uint fee);\r\n    event DelayedSwap(address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, ConvertETH convertETH, uint16 period, uint64 orderId);\r\n    event OrderClaimed(uint orderId, address tokenA, uint amountAOut, address tokenB, uint amountBOut, address to);\r\n\r\n    function factory() external view returns (PoolFactory);\r\n    function weth() external view returns (WETH);\r\n    \r\n    function deposit(address token1, uint amount1, address token2, uint amount2, address to, uint timeout) \r\n        external returns (uint liquidityOut, uint amount1Used, uint amount2Used);\r\n    function depositWithETH(address token, uint amount, address to, uint timeout) \r\n        payable external returns (uint liquidityOut, uint amountETHUsed, uint amountTokenUsed);\r\n    \r\n    function withdraw(address token1, address token2, uint liquidity, address to, uint timeout) external returns (uint amount1, uint amount2);\r\n    function withdrawWithETH(address token1, uint liquidityIn, address to, uint timeout) external returns (uint amount1, uint amountETH);\r\n\r\n    function swap(address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, uint timeout) external returns (uint amountOut);\r\n    function swapFromETH(address tokenOut, uint minAmountOut, address to, uint timeout) payable external returns (uint amountOut);\r\n    function swapToETH(address tokenIn, uint amountIn, uint minAmountOut, address to, uint timeout) external returns (uint amountETHOut);\r\n\r\n    function delayedSwap(\r\n        address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, uint timeout,\r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) external returns (uint orderId);\r\n    function delayedSwapFromETH(\r\n        address tokenOut, uint minAmountOut, address to, uint timeout, \r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) external payable returns (uint orderId);\r\n    function delayedSwapToETH(address tokenIn, uint amountIn, uint minAmountOut, address to, uint timeout,\r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) external returns (uint orderId);\r\n\r\n    function processDelayedOrders(address token1, address token2, uint timeout) external returns (uint availableBalanceA, uint availableBalanceB);\r\n\r\n    function claimOrder(\r\n        address tokenIn, address tokenOut,\r\n        bytes32 previousBreakHash,\r\n        // see LiquifyPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaksHistory,\r\n        uint timeout\r\n    ) external returns (address to, uint amountOut, uint amountRefund);\r\n\r\n    function claimOrderWithETH(\r\n        address token,\r\n        bytes32 previousBreakHash,\r\n        // see LiquifyPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaksHistory,\r\n        uint timeout\r\n    ) external returns (address to, uint amountOut, uint amountRefund);\r\n}\r\n\r\nlibrary Liquifi {\r\n    enum Flag { \r\n        // padding 8 bits\r\n        PAD1, PAD2, PAD3, PAD4, PAD5, PAD6, PAD7, PAD8,\r\n        // transient flags\r\n        HASH_DIRTY, BALANCE_A_DIRTY, BALANCE_B_DIRTY, TOTALS_DIRTY, QUEUE_STOPLOSS_DIRTY, QUEUE_TIMEOUT_DIRTY, MUTEX, INVALID_STATE,\r\n        TOTAL_SUPPLY_DIRTY, SWAPS_INCOME_DIRTY, RESERVED1, RESERVED2,\r\n        // persistent flags set by governance\r\n        POOL_LOCKED, ARBITRAGEUR_FULL_FEE, GOVERNANCE_OVERRIDEN\r\n    }\r\n\r\n    struct PoolBalances { // optimized for storage\r\n        // saved on BALANCE_A_DIRTY in exit()\r\n        uint112 balanceALocked;\r\n        uint144 poolFlowSpeedA; // flow speed: (amountAIn * 2^32)/second\r\n\r\n        // saved on BALANCE_B_DIRTY in exit()\r\n        uint112 balanceBLocked;\r\n        uint144 poolFlowSpeedB; // flow speed: (amountBIn * 2^32)/second\r\n        \r\n        // saved on TOTALS_DIRTY in exit()\r\n        uint128 totalBalanceA;\r\n        uint128 totalBalanceB;\r\n\r\n        // saved on SWAPS_INCOME_DIRTY in exit()\r\n        // contains 128 bits of delayedSwapsIncomeA and 128 bits of delayedSwapsIncomeB\r\n        uint delayedSwapsIncome;\r\n        \r\n        // saved on TOTAL_SUPPLY_DIRTY in exit()\r\n        // contains 128 bits of rootKLast and 128 bits of totalSupply\r\n        // rootKLast = sqrt(availableBalanceA * availableBalanceB), as of immediately after the most recent liquidity event\r\n        uint rootKLastTotalSupply;\r\n    }\r\n\r\n    struct PoolState { // optimized for storage\r\n        // saved on HASH_DIRTY in exit()\r\n        bytes32 lastBreakHash;\r\n\r\n        // saved on QUEUE_STOPLOSS_DIRTY in exit()\r\n        uint64 firstByTokenAStopLoss; uint64 lastByTokenAStopLoss; // linked list of orders sorted by (amountAIn/stopLossAmount) ascending\r\n        uint64 firstByTokenBStopLoss; uint64 lastByTokenBStopLoss; // linked list of orders sorted by (amountBIn/stopLossAmount) ascending\r\n\r\n        // saved on QUEUE_TIMEOUT_DIRTY in exit()\r\n        uint64 firstByTimeout; uint64 lastByTimeout; // linked list of orders sorted by timeouts ascending\r\n        // this field contains\r\n        // 8 bits of instantSwapFee\r\n        // 8 bits of desiredOrdersFee\r\n        // 8 bits of protocolFee\r\n        // 32 bits of maxPeriod\r\n        // 16 bits of desiredMaxHistory\r\n        // 4 bits of persistent flags\r\n        // 12 bits of transient flags\r\n        // 8 bits of transient invalidStateReason (ErrorArg)\r\n        // Packing reduces stack depth and helps in governance\r\n        uint96 packed; // not saved in exit(), saved only by governance\r\n        uint16 notFee; // not saved in exit()\r\n\r\n        // This word is always saved in exit()\r\n        uint64 lastBalanceUpdateTime;\r\n        uint64 nextBreakTime;\r\n        uint32 maxHistory;\r\n        uint32 ordersToClaimCount;\r\n        uint64 breaksCount; // counter with increments of 2. 1st bit is used as mutex flag\r\n    }\r\n\r\n    enum OrderFlag { \r\n        NONE, IS_TOKEN_A, EXTRACT_ETH\r\n    }\r\n\r\n    struct Order { // optimized for storage, fits into 3 words\r\n        // Also closing hash is saved in this word on order close.\r\n        // Closing hash always has last bit = 1, I.e. prevByStopLoss & 1 == 1\r\n        uint64 nextByTimeout; uint64 prevByTimeout;\r\n        uint64 nextByStopLoss; uint64 prevByStopLoss;\r\n        \r\n        // mostly used together\r\n        uint112 stopLossAmount;\r\n        uint112 amountIn;\r\n        uint32 period;\r\n\r\n        address owner;\r\n        uint64 timeout;\r\n        uint8 flags;\r\n    }\r\n\r\n    struct OrderClaim { //in-memory only\r\n        uint amountOut;\r\n        uint orderFlowSpeed;\r\n        uint orderId;\r\n        uint flags;\r\n        uint closeReason;\r\n        uint previousAvailableBalance;\r\n        uint previousFlowSpeed;\r\n        uint previousOthers;\r\n    }\r\n\r\n    enum Error { \r\n        A_MUL_OVERFLOW, \r\n        B_ADD_OVERFLOW, \r\n        C_TOO_BIG_TIME_VALUE, \r\n        D_TOO_BIG_PERIOD_VALUE,\r\n        E_TOO_BIG_AMOUNT_VALUE,\r\n        F_ZERO_AMOUNT_VALUE,\r\n        G_ZERO_PERIOD_VALUE,\r\n        H_BALANCE_AFTER_BREAK,\r\n        I_BALANCE_OF_SAVED_UPD,\r\n        J_INVALID_POOL_STATE,\r\n        K_TOO_BIG_TOTAL_VALUE,\r\n        L_INSUFFICIENT_LIQUIDITY,\r\n        M_EMPTY_LIST,\r\n        N_BAD_LENGTH,\r\n        O_HASH_MISMATCH,\r\n        P_ORDER_NOT_CLOSED,\r\n        Q_ORDER_NOT_ADDED,\r\n        R_INCOMPLETE_HISTORY,\r\n        S_REENTRANCE_NOT_SUPPORTED,\r\n        T_INVALID_TOKENS_PAIR,\r\n        U_TOKEN_TRANSFER_FAILED,\r\n        V_ORDER_NOT_EXIST,\r\n        W_DIV_BY_ZERO,\r\n        X_ORDER_ALREADY_CLOSED,\r\n        Y_UNAUTHORIZED_SENDER,\r\n        Z_TOO_BIG_FLOW_SPEED_VALUE\r\n    }\r\n\r\n    enum ErrorArg {\r\n        A_NONE,\r\n        B_IN_AMOUNT,\r\n        C_OUT_AMOUNT,\r\n        D_STOP_LOSS_AMOUNT,\r\n        E_IN_ADD_ORDER,\r\n        F_IN_SWAP,\r\n        G_IN_COMPUTE_AVAILABLE_BALANCE,\r\n        H_IN_BREAKS_HISTORY,\r\n        I_USER_DATA,\r\n        J_IN_ORDER,\r\n        K_IN_MINT,\r\n        L_IN_BURN,\r\n        M_IN_CLAIM_ORDER,\r\n        N_IN_PROCESS_DELAYED_ORDERS,\r\n        O_TOKEN_A,\r\n        P_TOKEN_B,\r\n        Q_TOKEN_ETH,\r\n        R_IN_CLOSE_ORDER,\r\n        S_BY_GOVERNANCE,\r\n        T_FEE_CHANGED_WITH_ORDERS_OPEN,\r\n        U_BAD_EXCHANGE_RATE,\r\n        V_INSUFFICIENT_TOTAL_BALANCE,\r\n        W_POOL_LOCKED,\r\n        X_TOTAL_SUPPLY\r\n    }\r\n\r\n    // this methods allows to pass some information in 'require' calls without storing strings in contract bytecode \r\n    // messages will be like \"FAIL https://err.liquifi.org/XY\" where X and Y are error and errorArg from respective enums\r\n    function _require(bool condition, Error error, ErrorArg errorArg) internal pure {\r\n        if (condition) return;\r\n        { // new scope to not waste message memory if condition is satisfied \r\n            // FAIL https://err.liquifi.org/__\r\n            bytes memory message = \"\\x46\\x41\\x49\\x4c\\x20\\x68\\x74\\x74\\x70\\x73\\x3a\\x2f\\x2f\\x65\\x72\\x72\\x2e\\x6c\\x69\\x71\\x75\\x69\\x66\\x69\\x2e\\x6f\\x72\\x67\\x2f\\x5f\\x5f\";\r\n            \r\n            message[29] = bytes1(65 + uint8(error));\r\n            message[30] = bytes1(65 + uint8(errorArg));\r\n            require(false, string(message));\r\n        }\r\n    }\r\n\r\n    uint64 constant maxTime = ~uint64(0);\r\n\r\n    function trimTime(uint time) internal pure returns (uint64 trimmedTime) {\r\n        Liquifi._require(time <= maxTime, Liquifi.Error.C_TOO_BIG_TIME_VALUE, Liquifi.ErrorArg.A_NONE);\r\n        return uint64(time);\r\n    }\r\n\r\n    function trimPeriod(uint period, Liquifi.ErrorArg periodType) internal pure returns (uint32 trimmedPeriod) {\r\n        Liquifi._require(period <= ~uint32(0), Liquifi.Error.D_TOO_BIG_PERIOD_VALUE, periodType);\r\n        return uint32(period);\r\n    }\r\n\r\n    function trimAmount(uint amount, Liquifi.ErrorArg amountType) internal pure returns (uint112 trimmedAmount) {\r\n        Liquifi._require(amount <= ~uint112(0), Liquifi.Error.E_TOO_BIG_AMOUNT_VALUE, amountType);\r\n        return uint112(amount);\r\n    }\r\n\r\n\r\n    function trimTotal(uint amount, Liquifi.ErrorArg amountType) internal pure returns (uint128 trimmedAmount) {\r\n        Liquifi._require(amount <= ~uint128(0), Liquifi.Error.K_TOO_BIG_TOTAL_VALUE, amountType);\r\n        return uint128(amount);\r\n    }\r\n\r\n    function trimFlowSpeed(uint amount, Liquifi.ErrorArg amountType) internal pure returns (uint144 trimmedAmount) {\r\n        Liquifi._require(amount <= ~uint144(0), Liquifi.Error.Z_TOO_BIG_FLOW_SPEED_VALUE, amountType);\r\n        return uint144(amount);\r\n    }\r\n\r\n    function checkFlag(PoolState memory _state, Flag flag) internal pure returns(bool) {\r\n        return _state.packed & uint96(1 << uint(flag)) != 0;\r\n    }\r\n\r\n    function setFlag(PoolState memory _state, Flag flag) internal pure {\r\n        _state.packed = _state.packed | uint96(1 << uint(flag));\r\n    }\r\n\r\n    function clearFlag(PoolState memory _state, Flag flag) internal pure {\r\n        _state.packed = _state.packed & ~uint96(1 << uint(flag));\r\n    }\r\n\r\n    function unpackGovernance(PoolState memory _state) internal pure returns(\r\n        uint instantSwapFee, uint desiredOrdersFee, uint protocolFee, uint maxPeriod, uint desiredMaxHistory\r\n    ) {\r\n        desiredMaxHistory = uint16(_state.packed >> 24);\r\n        maxPeriod = uint32(_state.packed >> 40);\r\n        protocolFee = uint8(_state.packed >> 72);\r\n        desiredOrdersFee = uint8(_state.packed >> 80);\r\n        instantSwapFee = uint8(_state.packed >> 88);\r\n    }\r\n\r\n    function setInvalidState(PoolState memory _state, Liquifi.ErrorArg reason) internal pure {\r\n        setFlag(_state, Liquifi.Flag.INVALID_STATE);\r\n        uint oldReason = uint8(_state.packed);\r\n        if (uint(reason) > oldReason) {\r\n            _state.packed = _state.packed & ~uint96(~uint8(0)) | uint96(reason);\r\n        }\r\n    }\r\n\r\n    function checkInvalidState(PoolState memory _state) internal pure returns (Liquifi.ErrorArg reason) {\r\n        reason = Liquifi.ErrorArg.A_NONE;\r\n        if (checkFlag(_state, Liquifi.Flag.INVALID_STATE)) {\r\n            return Liquifi.ErrorArg(uint8(_state.packed));\r\n        }\r\n    }\r\n\r\n    function isTokenAIn(uint orderFlags) internal pure returns (bool) {\r\n        return orderFlags & uint(Liquifi.OrderFlag.IS_TOKEN_A) != 0;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    \r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = x > y ? x : y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = x < y ? x : y;\r\n    }\r\n\r\n    function sqrt(uint x) internal pure returns (uint result) {\r\n        uint y = x;\r\n        result = (x + 1) / 2;\r\n        while (result < y) {\r\n            y = result;\r\n            result = (x / result + result) / 2;\r\n        }\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        Liquifi._require(y == 0 || (z = x * y) / y == x, Liquifi.Error.A_MUL_OVERFLOW, Liquifi.ErrorArg.A_NONE);\r\n    }\r\n\r\n    function mulWithClip(uint x, uint y, uint maxValue) internal pure returns (uint z) {\r\n        if (y != 0 && ((z = x * y) / y != x || z > maxValue)) {\r\n            z = maxValue;\r\n        }\r\n    }\r\n\r\n    function subWithClip(uint x, uint y) internal pure returns (uint z) {\r\n        if ((z = x - y) > x) {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        Liquifi._require((z = x + y) >= x, Liquifi.Error.B_ADD_OVERFLOW, Liquifi.ErrorArg.A_NONE);\r\n    }\r\n\r\n    function addWithClip(uint x, uint y, uint maxValue) internal pure returns (uint z) {\r\n        if ((z = x + y) < x || z > maxValue) {\r\n            z = maxValue;\r\n        }\r\n    }\r\n\r\n    // function div(uint x, uint y, Liquifi.ErrorArg scope) internal pure returns (uint z) {\r\n    //     Liquifi._require(y != 0, Liquifi.Error.R_DIV_BY_ZERO, scope);\r\n    //     z = x / y;\r\n    // }\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n//import { Debug } from \"./libraries/Debug.sol\";\r\ncontract LiquifiPoolRegister is PoolRegister {\r\n    PoolFactory public immutable override factory;\r\n    WETH public immutable override weth;\r\n\r\n    using Math for uint256;\r\n\r\n    modifier beforeTimeout(uint timeout) {\r\n        require(timeout >= block.timestamp, 'LIQUIFI: EXPIRED CALL');\r\n        _;\r\n    }\r\n\r\n    constructor (address _governanceRouter) public {\r\n        factory = GovernanceRouter(_governanceRouter).poolFactory();\r\n        weth = GovernanceRouter(_governanceRouter).weth();\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == address(weth));\r\n    }\r\n\r\n    function smartTransferFrom(address token, address to, uint value, ConvertETH convertETH) internal {\r\n        address from = (token == address(weth) && convertETH == ConvertETH.IN_ETH) ? address(this) : msg.sender;\r\n\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\r\n            ERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'LIQUIFI: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function smartTransfer(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(\r\n            ERC20.transfer.selector, to, value));\r\n        success = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n        require(success, \"LIQUIFI: TOKEN_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function smartTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'LIQUIFI: ETH_TRANSFER_FAILED');\r\n    }\r\n\r\n    // Registry always creates pools with tokens in proper order\r\n    function properOrder(address tokenA, address tokenB) view private returns (bool) {\r\n        return (tokenA == address(weth) ? address(0) : tokenA) < (tokenB == address(weth) ? address(0) : tokenB);\r\n    }\r\n\r\n    function _deposit(address token1, uint amount1, address token2, uint amount2, address to, ConvertETH convertETH, uint timeout) \r\n        private beforeTimeout(timeout) returns (uint liquidityOut, uint amountA, uint amountB) {\r\n        address pool;\r\n        {\r\n            (address tokenA, address tokenB) = properOrder(token1, token2) ? (token1, token2) : (token2, token1);\r\n            (amountA, amountB) = properOrder(token1, token2) ? (amount1, amount2) : (amount2, amount1);\r\n            pool = factory.getPool(tokenA, tokenB);\r\n        }\r\n        uint availableBalanceA;\r\n        uint availableBalanceB;\r\n        {\r\n            (uint availableBalance, , ) = DelayedExchangePool(pool).processDelayedOrders();\r\n            availableBalanceA = uint128(availableBalance >> 128);\r\n            availableBalanceB = uint128(availableBalance);\r\n        }\r\n        \r\n        if (availableBalanceA != 0 && availableBalanceB != 0) {\r\n            uint amountBOptimal = amountA.mul(availableBalanceB) / availableBalanceA;\r\n            if (amountBOptimal <= amountB) {\r\n                //require(amountBOptimal >= amountBMin, 'LIQUIFI: INSUFFICIENT_B_AMOUNT');\r\n                amountB = amountBOptimal;\r\n            } else {\r\n                uint amountAOptimal = amountB.mul(availableBalanceA) / availableBalanceB;\r\n                assert(amountAOptimal <= amountA);\r\n                //require(amountAOptimal >= amountAMin, 'LIQUIFI: INSUFFICIENT_A_AMOUNT');\r\n                amountA = amountAOptimal;\r\n            }\r\n        }\r\n\r\n        (amount1, amount2) = properOrder(token1, token2) ? (amountA, amountB) : (amountB, amountA);\r\n\r\n        smartTransferFrom(token1, pool, amount1, convertETH);\r\n        smartTransferFrom(token2, pool, amount2, convertETH);\r\n        liquidityOut = DelayedExchangePool(pool).mint(to);\r\n        emit Mint(token1, amount1, token2, amount2, liquidityOut, to, convertETH);\r\n    }\r\n\r\n    function deposit(address token1, uint amount1, address token2, uint amount2, address to, uint timeout) \r\n        external override returns (uint liquidityOut, uint amount1Used, uint amount2Used) {\r\n        uint amountA;\r\n        uint amountB;\r\n        (liquidityOut, amountA, amountB) = _deposit(token1, amount1, token2, amount2, to, ConvertETH.NONE, timeout);\r\n        (amount1Used, amount2Used) = properOrder(token1, token2) ? (amountA, amountB) : (amountB, amountA);\r\n    }\r\n\r\n    function depositWithETH(address token, uint amount, address to, uint timeout) \r\n        payable external override returns (uint liquidityOut, uint amountETHUsed, uint amountTokenUsed) {\r\n        uint amountETH = msg.value;\r\n        weth.deposit{value: amountETH}();\r\n        require(weth.approve(address(this), amountETH), \"LIQUIFI: WETH_APPROVAL_FAILED\");\r\n        (liquidityOut, amountETHUsed, amountTokenUsed) = _deposit(address(weth), amountETH, token, amount, to, ConvertETH.IN_ETH, timeout);\r\n        \r\n        if (amountETH > amountETHUsed) {\r\n            uint refundETH = amountETH - amountETH;\r\n            weth.withdraw(refundETH);\r\n            smartTransferETH(msg.sender, refundETH);\r\n        }\r\n    }\r\n\r\n    function _withdraw(address token1, address token2, uint liquidityIn, address to, ConvertETH convertETH, uint timeout) \r\n        private beforeTimeout(timeout) returns (uint amount1, uint amount2) {\r\n        address pool = factory.findPool(token1, token2);\r\n        require(pool != address(0), \"LIQIFI: WITHDRAW_FROM_INVALID_POOL\");\r\n        require(\r\n            DelayedExchangePool(pool).transferFrom(msg.sender, pool, liquidityIn),\r\n            \"LIQIFI: TRANSFER_FROM_FAILED\"\r\n        );\r\n        (uint amountA, uint amountB) = DelayedExchangePool(pool).burn(to, convertETH == ConvertETH.OUT_ETH);\r\n        (amount1, amount2) = properOrder(token1, token2) ? (amountA, amountB) : (amountB, amountA);\r\n        emit Burn(token1, amount1, token2, amount2, liquidityIn, to, convertETH);\r\n    }\r\n\r\n    function withdraw(address token1, address token2, uint liquidityIn, address to, uint timeout) \r\n        external override returns (uint amount1, uint amount2) {\r\n        return _withdraw(token1, token2, liquidityIn, to, ConvertETH.NONE, timeout);\r\n    }\r\n\r\n    function withdrawWithETH(address token, uint liquidityIn, address to, uint timeout) \r\n        external override returns (uint amountToken, uint amountETH) {\r\n        (amountETH, amountToken) = _withdraw(address(weth), token, liquidityIn, to, ConvertETH.OUT_ETH, timeout);\r\n    }\r\n\r\n    function _swap(address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, ConvertETH convertETH, uint timeout) \r\n        private beforeTimeout(timeout) returns (uint amountOut) {\r\n        address pool = factory.findPool(tokenIn, tokenOut);\r\n        require(pool != address(0), \"LIQIFI: SWAP_ON_INVALID_POOL\");\r\n\r\n        smartTransferFrom(tokenIn, pool, amountIn, convertETH);\r\n        \r\n        bool isTokenAIn = properOrder(tokenIn, tokenOut);\r\n        (uint amountAOut, uint amountBOut, uint fee) = getAmountsOut(pool, isTokenAIn, amountIn, minAmountOut);\r\n        DelayedExchangePool(pool).swap(to, convertETH == ConvertETH.OUT_ETH, amountAOut, amountBOut, new bytes(0));\r\n        amountOut = isTokenAIn ? amountBOut : amountAOut;\r\n        emit Swap(tokenIn, amountIn, tokenOut, amountOut, to, convertETH, fee);\r\n    }\r\n\r\n    function swap(address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, uint timeout) \r\n        external override returns (uint amountOut) {\r\n        return _swap(tokenIn, amountIn, tokenOut, minAmountOut, to, ConvertETH.NONE, timeout);\r\n    }\r\n\r\n    function swapFromETH(address tokenOut, uint minAmountOut, address to, uint timeout) \r\n        external payable override returns (uint amountOut) {\r\n        uint amountETH = msg.value;\r\n        weth.deposit{value: amountETH}();\r\n        require(weth.approve(address(this), amountETH), \"LIQUIFI: WETH_APPROVAL_FAILED\");\r\n        \r\n        return _swap(address(weth), amountETH, tokenOut, minAmountOut, to, ConvertETH.IN_ETH, timeout);\r\n    }\r\n\r\n    function swapToETH(address tokenIn, uint amountIn, uint minAmountOut, address to, uint timeout) \r\n        external override returns (uint amountETHOut) {\r\n        amountETHOut = _swap(tokenIn, amountIn, address(weth), minAmountOut, to, ConvertETH.OUT_ETH, timeout);\r\n    }\r\n\r\n    function _delayedSwap(\r\n        address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, ConvertETH convertETH, uint time, \r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) private beforeTimeout(time) returns (uint orderId) {\r\n        time -= block.timestamp; // reuse variable to reduce stack size\r\n\r\n        address pool = factory.findPool(tokenIn, tokenOut);\r\n        require(pool != address(0), \"LIQIFI: DELAYED_SWAP_ON_INVALID_POOL\");\r\n        smartTransferFrom(tokenIn, pool, amountIn, convertETH);\r\n        \r\n\r\n        uint orderFlags = 0;\r\n        if (properOrder(tokenIn, tokenOut)) {\r\n            orderFlags |= 1; // IS_TOKEN_A\r\n        }\r\n        if (convertETH == ConvertETH.OUT_ETH) {\r\n            orderFlags |= 2; // EXTRACT_ETH\r\n        }\r\n        orderId = DelayedExchangePool(pool).addOrder(to, orderFlags, prevByStopLoss, prevByTimeout, minAmountOut, time);\r\n        // TODO: add optional checking if prevByStopLoss/prevByTimeout matched provided values\r\n        DelayedSwap(tokenIn, amountIn, tokenOut, minAmountOut, to, convertETH, uint16(time), uint64(orderId));\r\n    }\r\n\r\n    function delayedSwap(\r\n        address tokenIn, uint amountIn, address tokenOut, uint minAmountOut, address to, uint timeout, \r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) external override returns (uint orderId) {\r\n        require(tokenOut != address(0), \"LIQUIFI: INVALID TOKEN OUT\");\r\n        return _delayedSwap(tokenIn, amountIn, tokenOut, minAmountOut, to, ConvertETH.NONE, timeout, prevByStopLoss, prevByTimeout);\r\n    }\r\n\r\n    function delayedSwapFromETH(\r\n        address tokenOut, uint minAmountOut, address to, uint timeout, \r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) external payable override returns (uint orderId) {\r\n        uint amountETH = msg.value;\r\n        weth.deposit{value: amountETH}();\r\n        require(weth.approve(address(this), amountETH), \"LIQUIFI: WETH_APPROVAL_FAILED\");\r\n\r\n        return _delayedSwap(address(weth), amountETH, tokenOut, minAmountOut, to, ConvertETH.IN_ETH, timeout, prevByStopLoss, prevByTimeout);\r\n    }\r\n\r\n    function delayedSwapToETH(address tokenIn, uint amountIn, uint minAmountOut, address to, uint timeout,\r\n        uint prevByStopLoss, uint prevByTimeout\r\n    ) external override returns (uint orderId) {\r\n        orderId = _delayedSwap(tokenIn, amountIn, address(weth), minAmountOut, to, ConvertETH.OUT_ETH, timeout, prevByStopLoss, prevByTimeout);\r\n    }\r\n\r\n    function processDelayedOrders(address token1, address token2, uint timeout) \r\n        external override beforeTimeout(timeout) returns (uint availableBalance1, uint availableBalance2) {\r\n        address pool = factory.findPool(token1, token2);\r\n        require(pool != address(0), \"LIQIFI: PROCESS_DELAYED_ORDERS_ON_INVALID_POOL\");\r\n        uint availableBalance;\r\n        (availableBalance, , ) = DelayedExchangePool(pool).processDelayedOrders();\r\n        uint availableBalanceA = uint128(availableBalance >> 128);\r\n        uint availableBalanceB = uint128(availableBalance);\r\n        (availableBalance1, availableBalance2) = properOrder(token1, token2) ? (availableBalanceA, availableBalanceB) : (availableBalanceB, availableBalanceA);\r\n    }\r\n\r\n    function _claimOrder(\r\n        address token1, address token2,\r\n        bytes32 previousBreakHash,\r\n        // see LiquifyPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaks,\r\n        uint timeout\r\n    ) private beforeTimeout(timeout) returns (address to, uint amountAOut, uint amountBOut) {\r\n        address pool = factory.findPool(token1, token2);\r\n        require(pool != address(0), \"LIQIFI: CLAIM_ORDER_ON_INVALID_POOL\");\r\n        (to, amountAOut, amountBOut) = DelayedExchangePool(pool).claimOrder(previousBreakHash, breaks);\r\n        (address tokenA, address tokenB) = properOrder(token1, token2) ? (token1, token2) : (token2, token1);\r\n        uint orderId = uint64(breaks[2] >> 80);\r\n        emit OrderClaimed(orderId, tokenA, amountAOut, tokenB, amountBOut, to);\r\n    }\r\n    \r\n    function claimOrder(\r\n        address tokenIn, address tokenOut,\r\n        bytes32 previousBreakHash,\r\n        // data from FlowBreakEvent events should be passed in this array\r\n        // first event is the one related to order creation (having finalizing orderId and reason = ORDER_ADDED)\r\n        // last event is the one related to order closing  (having finalizing orderId and reason = ORDER_TIMEOUT|ORDER_STOP_LOSS)\r\n        // 3 256bit variable per event are packed in one list to reduce stack depth: \r\n        // availableBalance (0), flowSpeed (1), others (2)\r\n        // availableBalance consists of 128 bits of availableBalanceA and 128 bits of availableBalanceB\r\n        // flowSpeed consists of 144 bits of poolFlowSpeedA and 112 higher bits of poolFlowSpeedB\r\n        // others consists of 32 lower bits of poolFlowSpeedB, 16 bit of notFee, 64 bit of time, 64 bit of orderId, 76 higher bits of packed and 4 bit of reason (BreakReason)\r\n        uint[] calldata breaksHistory,\r\n        uint timeout\r\n    ) external override returns (address to, uint amountOut, uint amountRefund) {\r\n        uint amountAOut;\r\n        uint amountBOut;\r\n        (to, amountAOut, amountBOut) = _claimOrder(tokenIn, tokenOut, previousBreakHash, breaksHistory, timeout);\r\n        (amountOut, amountRefund) = properOrder(tokenIn, tokenOut) ? (amountBOut, amountAOut) : (amountAOut, amountBOut);\r\n    }\r\n\r\n    function claimOrderWithETH(\r\n        address token,\r\n        bytes32 previousBreakHash,\r\n        // see LiquifyPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaksHistory,\r\n        uint timeout\r\n    ) external override returns (address to, uint amountETHOut, uint amountTokenOut) {\r\n        return _claimOrder(address(weth), token, previousBreakHash, breaksHistory, timeout);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint balanceIn, uint balanceOut, uint notFee) private pure returns (uint amountOut) {\r\n        require(balanceOut > 0, 'LIQIFI: INSUFFICIENT_LIQUIDITY_OUT');\r\n        require(balanceIn > 0, 'LIQIFI: INSUFFICIENT_LIQUIDITY_IN');\r\n        uint amountInWithFee = amountIn.mul(notFee);\r\n        uint numerator = amountInWithFee.mul(balanceOut);\r\n        uint denominator = balanceIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function getAmountsOut(address pool, bool isTokenAIn, uint amountIn, uint minAmountOut) private returns (uint amountAOut, uint amountBOut, uint fee) {\r\n        (uint availableBalance, uint delayedSwapsIncome, uint packed) = DelayedExchangePool(pool).processDelayedOrders();\r\n        uint availableBalanceA = uint128(availableBalance >> 128);\r\n        uint availableBalanceB = uint128(availableBalance);\r\n        (uint instantSwapFee) = unpackGovernance(packed);\r\n\r\n        uint amountOut;\r\n        if (isTokenAIn) {\r\n            amountOut = getAmountOut(amountIn, availableBalanceA, availableBalanceB, 1000);\r\n            if (swapPaysFee(availableBalance, delayedSwapsIncome, 0, amountOut)) {\r\n                amountOut = getAmountOut(amountIn, availableBalanceA, availableBalanceB, 1000 - instantSwapFee);\r\n                fee = instantSwapFee;\r\n            }    \r\n            amountBOut = amountOut;\r\n        } else { \r\n            amountOut = getAmountOut(amountIn, availableBalanceB, availableBalanceA, 1000);\r\n            if (swapPaysFee(availableBalance, delayedSwapsIncome, amountOut, 0)) {\r\n                amountOut = getAmountOut(amountIn, availableBalanceB, availableBalanceA, 1000 - instantSwapFee);\r\n                fee = instantSwapFee;\r\n            }\r\n            amountAOut = amountOut;\r\n        }\r\n        require(amountOut >= minAmountOut, \"LIQIFI: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function swapPaysFee(uint availableBalance, uint delayedSwapsIncome, uint amountAOut, uint amountBOut) private pure returns (bool) {\r\n        uint availableBalanceA = uint128(availableBalance >> 128);\r\n        uint availableBalanceB = uint128(availableBalance);\r\n\r\n        uint delayedSwapsIncomeA = uint128(delayedSwapsIncome >> 128);\r\n        uint delayedSwapsIncomeB = uint128(delayedSwapsIncome);\r\n        \r\n        uint exceedingAIncome = availableBalanceB == 0 ? 0 : uint(delayedSwapsIncomeA).subWithClip(uint(delayedSwapsIncomeB) * availableBalanceA / availableBalanceB);\r\n        uint exceedingBIncome = availableBalanceA == 0 ? 0 : uint(delayedSwapsIncomeB).subWithClip(uint(delayedSwapsIncomeA) * availableBalanceB / availableBalanceA);\r\n        \r\n        return amountAOut > exceedingAIncome || amountBOut > exceedingBIncome;\r\n    }\r\n\r\n    function unpackGovernance(uint packed) internal pure returns(\r\n        uint8 instantSwapFee\r\n    ) {\r\n        instantSwapFee = uint8(packed >> 88);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governanceRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ConvertETH\",\"name\":\"convertETH\",\"type\":\"uint8\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ConvertETH\",\"name\":\"convertETH\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"period\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"orderId\",\"type\":\"uint64\"}],\"name\":\"DelayedSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ConvertETH\",\"name\":\"convertETH\",\"type\":\"uint8\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OrderClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ConvertETH\",\"name\":\"convertETH\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"previousBreakHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"breaksHistory\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"claimOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRefund\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"previousBreakHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"breaksHistory\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"claimOrderWithETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountETHOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByTimeout\",\"type\":\"uint256\"}],\"name\":\"delayedSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByTimeout\",\"type\":\"uint256\"}],\"name\":\"delayedSwapFromETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByTimeout\",\"type\":\"uint256\"}],\"name\":\"delayedSwapToETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Used\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount2Used\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"depositWithETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract PoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"processDelayedOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableBalance1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBalance2\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"swapFromETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"swapToETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETHOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract WETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"withdrawWithETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LiquifiPoolRegister","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000ad8674bc5727976f092027343244ebec2f961b58","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dbb2cf2ad2d07062238c512bcb749d4a1b53ffd63965413478150cfb2fd70900"}]}