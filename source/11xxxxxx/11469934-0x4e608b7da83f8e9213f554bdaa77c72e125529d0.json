{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/GPv2AllowanceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity ^0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./libraries/GPv2TradeExecution.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Allowance Manager Contract\\n/// @author Gnosis Developers\\ncontract GPv2AllowanceManager {\\n    using GPv2TradeExecution for GPv2TradeExecution.Data;\\n\\n    /// @dev The recipient of all transfers made by the allowance manager. The\\n    /// recipient is set at creation time and cannot change.\\n    address private immutable recipient;\\n\\n    constructor() {\\n        recipient = msg.sender;\\n    }\\n\\n    /// @dev Modifier that ensures that a function can only be called by the\\n    /// recipient of this contract.\\n    modifier onlyRecipient {\\n        require(msg.sender == recipient, \\\"GPv2: not allowance recipient\\\");\\n        _;\\n    }\\n\\n    /// @dev Transfers all sell amounts for the executed trades from their\\n    /// owners to the caller.\\n    ///\\n    /// This function reverts if:\\n    /// - The caller is not the recipient of the allowance manager\\n    /// - Any ERC20 transfer fails\\n    ///\\n    /// @param trades The executed trades whose sell amounts need to be\\n    /// transferred in.\\n    function transferIn(GPv2TradeExecution.Data[] calldata trades)\\n        external\\n        onlyRecipient\\n    {\\n        for (uint256 i = 0; i < trades.length; i++) {\\n            GPv2TradeExecution.transferSellAmountToRecipient(\\n                trades[i],\\n                msg.sender\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/GPv2Settlement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity ^0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./GPv2AllowanceManager.sol\\\";\\nimport \\\"./interfaces/GPv2Authentication.sol\\\";\\nimport \\\"./libraries/GPv2Encoding.sol\\\";\\nimport \\\"./libraries/GPv2TradeExecution.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Settlement Contract\\n/// @author Gnosis Developers\\ncontract GPv2Settlement {\\n    using GPv2Encoding for bytes;\\n    using GPv2TradeExecution for GPv2TradeExecution.Data;\\n    using SafeMath for uint256;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 private constant DOMAIN_NAME = keccak256(\\\"Gnosis Protocol\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 private constant DOMAIN_VERSION = keccak256(\\\"v2\\\");\\n\\n    /// @dev The number of basis points to make up 100%.\\n    uint256 private constant BPS_BASE = 10000;\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// GPv2 contracts.\\n    bytes32 public immutable domainSeparator;\\n\\n    /// @dev The authenticator is used to determine who can call the settle function.\\n    /// That is, only authorised solvers have the ability to invoke settlements.\\n    /// Any valid authenticator implements an isSolver method called by the onlySolver\\n    /// modifier below.\\n    GPv2Authentication private immutable authenticator;\\n\\n    /// @dev The allowance manager which has access to EOA order funds. This\\n    /// contract is created during deployment\\n    GPv2AllowanceManager public immutable allowanceManager;\\n\\n    /// @dev Map each user order by UID to the amount that has been filled so\\n    /// far. If this amount is larger than or equal to the amount traded in the\\n    /// order (amount sold for sell orders, amount bought for buy orders) then\\n    /// the order cannot be traded anymore. If the order is fill or kill, then\\n    /// this value is only used to determine whether the order has already been\\n    /// executed.\\n    mapping(bytes => uint256) public filledAmount;\\n\\n    /// @dev Event emitted for each executed trade.\\n    event Trade(\\n        address indexed owner,\\n        IERC20 sellToken,\\n        IERC20 buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        uint256 feeAmount,\\n        bytes orderUid\\n    );\\n\\n    constructor(GPv2Authentication authenticator_) {\\n        authenticator = authenticator_;\\n\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n        allowanceManager = new GPv2AllowanceManager();\\n    }\\n\\n    /// @dev This modifier is called by settle function to block any non-listed\\n    /// senders from settling batches.\\n    modifier onlySolver {\\n        require(authenticator.isSolver(msg.sender), \\\"GPv2: not a solver\\\");\\n        _;\\n    }\\n\\n    /// @dev Settle the specified orders at a clearing price. Note that it is\\n    /// the responsibility of the caller to ensure that all GPv2 invariants are\\n    /// upheld for the input settlement, otherwise this call will revert.\\n    /// Namely:\\n    /// - The fee factor cannot lead to fees > 0.1%\\n    /// - All orders are valid and signed\\n    /// - Accounts have sufficient balance and approval.\\n    /// - Settlement contract has sufficient balance to execute trades. Note\\n    ///   this implies that the accumulated fees held in the contract can also\\n    ///   be used for settlement. This is OK since:\\n    ///   - Solvers need to be authorized\\n    ///   - Misbehaving solvers will be slashed for abusing accumulated fees for\\n    ///     settlement\\n    ///   - Critically, user orders are entirely protected\\n    ///\\n    /// Note that some parameters are encoded as packed bytes in order to save\\n    /// calldata gas. For more information on encoding format consult the\\n    /// [`GPv2Encoding`] library.\\n    ///\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// Orders and interactions encode tokens as indices into this array.\\n    /// @param clearingPrices An array of clearing prices where the `i`-th price\\n    /// is for the `i`-th token in the [`tokens`] array.\\n    /// @param encodedTrades Encoded trades for signed EOA orders.\\n    /// @param encodedInteractions Encoded smart contract interactions.\\n    /// @param encodedOrderRefunds Encoded order refunds for clearing storage\\n    /// related to invalid orders.\\n    function settle(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        bytes calldata encodedTrades,\\n        bytes calldata encodedInteractions,\\n        bytes calldata encodedOrderRefunds\\n    ) external onlySolver {\\n        GPv2TradeExecution.Data[] memory executedTrades =\\n            computeTradeExecutions(tokens, clearingPrices, encodedTrades);\\n        allowanceManager.transferIn(executedTrades);\\n\\n        executeInteractions(encodedInteractions);\\n\\n        transferOut(executedTrades);\\n\\n        require(encodedOrderRefunds.length == 0, \\\"not yet implemented\\\");\\n    }\\n\\n    /// @dev Invalidate onchain an order that has been signed offline.\\n    /// @param orderUid The unique identifier of the order that is to be made\\n    /// invalid after calling this function. The user that created the order\\n    /// must be the the sender of this message. See [`extractOrderUidParams`]\\n    /// for details on orderUid.\\n    function invalidateOrder(bytes calldata orderUid) external {\\n        (, address owner, ) = orderUid.extractOrderUidParams();\\n        require(owner == msg.sender, \\\"GPv2: caller does not own order\\\");\\n        filledAmount[orderUid] = uint256(-1);\\n    }\\n\\n    /// @dev Process all trades for EOA orders one at a time returning the\\n    /// computed net in and out transfers for the trades.\\n    ///\\n    /// This method reverts if processing of any single trade fails. See\\n    /// [`processOrder`] for more details.\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// @param clearingPrices An array of token clearing prices.\\n    /// @param encodedTrades Encoded trades for signed EOA orders.\\n    /// @return executedTrades Array of executed trades.\\n    function computeTradeExecutions(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        bytes calldata encodedTrades\\n    ) internal returns (GPv2TradeExecution.Data[] memory executedTrades) {\\n        uint256 tradeCount = encodedTrades.tradeCount();\\n        executedTrades = new GPv2TradeExecution.Data[](tradeCount);\\n\\n        GPv2Encoding.Trade memory trade;\\n        for (uint256 i = 0; i < tradeCount; i++) {\\n            encodedTrades.tradeAtIndex(i).decodeTrade(\\n                domainSeparator,\\n                tokens,\\n                trade\\n            );\\n            computeTradeExecution(\\n                trade,\\n                clearingPrices[trade.sellTokenIndex],\\n                clearingPrices[trade.buyTokenIndex],\\n                executedTrades[i]\\n            );\\n        }\\n    }\\n\\n    /// @dev Compute the in and out transfer amounts for a single EOA order\\n    /// trade. This function reverts if:\\n    /// - The order has expired\\n    /// - The order's limit price is not respected.\\n    ///\\n    /// @param trade The trade to process.\\n    /// @param sellPrice The price of the order's sell token.\\n    /// @param buyPrice The price of the order's buy token.\\n    /// @param executedTrade Memory location for computed executed trade data.\\n    function computeTradeExecution(\\n        GPv2Encoding.Trade memory trade,\\n        uint256 sellPrice,\\n        uint256 buyPrice,\\n        GPv2TradeExecution.Data memory executedTrade\\n    ) internal {\\n        GPv2Encoding.Order memory order = trade.order;\\n        // NOTE: Currently, the above instantiation allocates an uninitialized\\n        // `Order` that gets never used. Adjust the free memory pointer to free\\n        // the unused memory by subtracting `sizeof(Order) == 288` bytes.\\n        // <https://solidity.readthedocs.io/en/v0.7.5/internals/layout_in_memory.html>\\n        // TODO: Remove this once the following fix is merged and released:\\n        // <https://github.com/ethereum/solidity/pull/10341>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(0x40, sub(mload(0x40), 288))\\n        }\\n\\n        // solhint-disable-next-line not-rely-on-time\\n        require(order.validTo >= block.timestamp, \\\"GPv2: order expired\\\");\\n\\n        executedTrade.owner = trade.owner;\\n        executedTrade.sellToken = order.sellToken;\\n        executedTrade.buyToken = order.buyToken;\\n\\n        // NOTE: The following computation is derived from the equation:\\n        // ```\\n        // amount_x * price_x = amount_y * price_y\\n        // ```\\n        // Intuitively, if a chocolate bar is 0,50€ and a beer is 4€, 1 beer\\n        // is roughly worth 8 chocolate bars (`1 * 4 = 8 * 0.5`). From this\\n        // equation, we can derive:\\n        // - The limit price for selling `x` and buying `y` is respected iff\\n        // ```\\n        // limit_x * price_x >= limit_y * price_y\\n        // ```\\n        // - The executed amount of token `y` given some amount of `x` and\\n        //   clearing prices is:\\n        // ```\\n        // amount_y = amount_x * price_x / price_y\\n        // ```\\n\\n        require(\\n            order.sellAmount.mul(sellPrice) >= order.buyAmount.mul(buyPrice),\\n            \\\"GPv2: limit price not respected\\\"\\n        );\\n\\n        uint256 executedSellAmount;\\n        uint256 executedBuyAmount;\\n        uint256 executedFeeAmount;\\n        uint256 currentFilledAmount;\\n\\n        // NOTE: Don't use `SafeMath.div` or `SafeMath.sub` anywhere here as it\\n        // allocates a string even if it does not revert. Additionally, `div`\\n        // only checks that the divisor is non-zero and `revert`s in that case\\n        // instead of consuming all of the remaining transaction gas when\\n        // dividing by zero, so no extra checks are needed for those operations.\\n\\n        if (order.kind == GPv2Encoding.ORDER_KIND_SELL) {\\n            if (order.partiallyFillable) {\\n                executedSellAmount = trade.executedAmount;\\n                executedFeeAmount =\\n                    order.feeAmount.mul(executedSellAmount) /\\n                    order.sellAmount;\\n            } else {\\n                executedSellAmount = order.sellAmount;\\n                executedFeeAmount = order.feeAmount;\\n            }\\n\\n            executedBuyAmount = executedSellAmount.mul(sellPrice) / buyPrice;\\n\\n            currentFilledAmount = filledAmount[trade.orderUid].add(\\n                executedSellAmount\\n            );\\n            require(\\n                currentFilledAmount <= order.sellAmount,\\n                \\\"GPv2: order filled\\\"\\n            );\\n        } else {\\n            if (order.partiallyFillable) {\\n                executedBuyAmount = trade.executedAmount;\\n                executedFeeAmount =\\n                    order.feeAmount.mul(executedBuyAmount) /\\n                    order.buyAmount;\\n            } else {\\n                executedBuyAmount = order.buyAmount;\\n                executedFeeAmount = order.feeAmount;\\n            }\\n\\n            executedSellAmount = executedBuyAmount.mul(buyPrice) / sellPrice;\\n\\n            currentFilledAmount = filledAmount[trade.orderUid].add(\\n                executedBuyAmount\\n            );\\n            require(\\n                currentFilledAmount <= order.buyAmount,\\n                \\\"GPv2: order filled\\\"\\n            );\\n        }\\n\\n        require(trade.feeDiscount <= BPS_BASE, \\\"GPv2: invalid fee discount\\\");\\n        executedFeeAmount =\\n            executedFeeAmount.mul(BPS_BASE - trade.feeDiscount) /\\n            BPS_BASE;\\n\\n        executedTrade.sellAmount = executedSellAmount.add(executedFeeAmount);\\n        executedTrade.buyAmount = executedBuyAmount;\\n\\n        filledAmount[trade.orderUid] = currentFilledAmount;\\n        emit Trade(\\n            executedTrade.owner,\\n            executedTrade.sellToken,\\n            executedTrade.buyToken,\\n            executedTrade.sellAmount,\\n            executedTrade.buyAmount,\\n            executedFeeAmount,\\n            trade.orderUid\\n        );\\n    }\\n\\n    /// @dev Execute a list of arbitrary contract calls from this contract.\\n    /// @param encodedInteractions The encoded list of interactions that will be\\n    /// executed.\\n    function executeInteractions(bytes calldata encodedInteractions) internal {\\n        // Note: at every decoding step, the content of this variable is\\n        // replaced with the latest decoded interaction.\\n        GPv2Encoding.Interaction memory interaction;\\n\\n        bytes calldata remainingEncodedInteractions = encodedInteractions;\\n        while (remainingEncodedInteractions.length != 0) {\\n            remainingEncodedInteractions = remainingEncodedInteractions\\n                .decodeInteraction(interaction);\\n            executeInteraction(interaction);\\n        }\\n    }\\n\\n    /// @dev Allows settlement function to make arbitrary contract executions.\\n    /// @param interaction contains address and calldata of the contract interaction.\\n    function executeInteraction(GPv2Encoding.Interaction memory interaction)\\n        internal\\n    {\\n        // To prevent possible attack on user funds, we explicitly disable\\n        // interactions with AllowanceManager contract.\\n        require(\\n            interaction.target != address(allowanceManager),\\n            \\\"GPv2: forbidden interaction\\\"\\n        );\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory response) =\\n            (interaction.target).call(interaction.callData);\\n        // solhint-enable avoid-low-level-calls\\n\\n        // TODO - concatenate the following reponse \\\"GPv2: Failed Interaction\\\"\\n        // This is the topic of https://github.com/gnosis/gp-v2-contracts/issues/240\\n        if (!success) {\\n            // Assembly used to revert with correctly encoded error message.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                revert(add(response, 0x20), mload(response))\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers all buy amounts for the executed trades from the\\n    /// settlement contract to the order owners. This function reverts if any of\\n    /// the ERC20 operations fail.\\n    ///\\n    /// @param trades The executed trades whose buy amounts need to be\\n    /// transferred out.\\n    function transferOut(GPv2TradeExecution.Data[] memory trades) internal {\\n        for (uint256 i = 0; i < trades.length; i++) {\\n            trades[i].transferBuyAmountToOwner();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/GPv2Authentication.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity ^0.7.5;\\n\\n/// @title Gnosis Protocol v2 Authentication Interface\\n/// @author Gnosis Developers\\ninterface GPv2Authentication {\\n    /// @dev determines whether the provided address is an authenticated solver.\\n    /// @param prospectiveSolver the address of prospective solver.\\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\\n    function isSolver(address prospectiveSolver) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/contracts/libraries/GPv2Encoding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity ^0.7.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Encoding Library.\\n/// @author Gnosis Developers\\nlibrary GPv2Encoding {\\n    /// @dev A struct representing an order containing all order parameters that\\n    /// are signed by a user for submitting to GP.\\n    struct Order {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        uint32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n    }\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant ORDER_KIND_SELL =\\n        hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant ORDER_KIND_BUY =\\n        hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The order EIP-712 type hash for the [`Order`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"uint32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant ORDER_TYPE_HASH =\\n        hex\\\"b2b38b9dcbdeb41f7ad71dea9aed79fb47f7bbc3436576fe994b43d5b16ecdec\\\";\\n\\n    /// @dev A struct representing a trade to be executed as part a batch\\n    /// settlement.\\n    struct Trade {\\n        Order order;\\n        uint8 sellTokenIndex;\\n        uint8 buyTokenIndex;\\n        uint256 executedAmount;\\n        uint16 feeDiscount;\\n        address owner;\\n        bytes orderUid;\\n    }\\n\\n    /// @dev The stride of an encoded trade.\\n    uint256 private constant TRADE_STRIDE = 206;\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 private constant ORDER_UID_LENGTH = 56;\\n\\n    /// @dev A struct representing arbitrary contract interactions.\\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\\n    struct Interaction {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    /// @dev Returns the number of trades encoded in a calldata byte array.\\n    ///\\n    /// This method reverts if the encoded trades are malformed, i.e. the total\\n    /// length is not a multiple of the stride of a single trade.\\n    /// @param encodedTrades The encoded trades.\\n    /// @return count The total number of trades encoded in the specified bytes.\\n    function tradeCount(bytes calldata encodedTrades)\\n        internal\\n        pure\\n        returns (uint256 count)\\n    {\\n        require(\\n            encodedTrades.length % TRADE_STRIDE == 0,\\n            \\\"GPv2: malformed trade data\\\"\\n        );\\n        count = encodedTrades.length / TRADE_STRIDE;\\n    }\\n\\n    /// @dev Returns a calldata slice to an encoded trade at the specified\\n    /// index.\\n    ///\\n    /// Note that this method does not check that the index is within the bounds\\n    /// of the specified encoded trades, as reading calldata out of bounds just\\n    /// produces 0's and will just decode to an invalid trade that will either\\n    /// fail to recover an address or recover a bogus one.\\n    function tradeAtIndex(bytes calldata encodedTrades, uint256 index)\\n        internal\\n        pure\\n        returns (bytes calldata encodedTrade)\\n    {\\n        // NOTE: Use assembly to slice the calldata bytes without generating\\n        // code for bounds checking.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            encodedTrade.offset := add(\\n                encodedTrades.offset,\\n                mul(index, TRADE_STRIDE)\\n            )\\n            encodedTrade.length := TRADE_STRIDE\\n        }\\n    }\\n\\n    /// @dev Decodes a trade with a signed order from calldata into memory.\\n    ///\\n    /// Trades are tightly packed and compress some data such as the order's buy\\n    /// and sell tokens to reduce calldata size and associated gas costs. As\\n    /// such it is not identical to the decoded [`Trade`] and contains the\\n    /// following fields:\\n    ///\\n    /// ```\\n    /// struct EncodedTrade {\\n    ///     uint8 sellTokenIndex;\\n    ///     uint8 buyTokenIndex;\\n    ///     uint256 sellAmount;\\n    ///     uint256 buyAmount;\\n    ///     uint32 validTo;\\n    ///     uint32 appData;\\n    ///     uint256 feeAmount;\\n    ///     uint8 flags;\\n    ///     uint256 executedAmount;\\n    ///     uint16 feeDiscount;\\n    ///     Signature {\\n    ///         uint8 v;\\n    ///         bytes32 r;\\n    ///         bytes32 s;\\n    ///     } signature;\\n    /// }\\n    /// ```\\n    ///\\n    /// Order flags are used to encode additional order parameters such as the\\n    /// kind of order, either a sell or a buy order, as well as whether the\\n    /// order is partially fillable or if it is a \\\"fill-or-kill\\\" order. As the\\n    /// most likely values are fill-or-kill sell orders, the flags are chosen\\n    /// such that `0x00` represents this kind of order. The flags byte uses has\\n    /// the following format:\\n    /// ```\\n    /// bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\n    /// ----+-----------------------+---+---+\\n    ///     |        unsused        | * | * |\\n    ///                               |   |\\n    ///                               |   +---- order kind bit, 0 for a sell\\n    ///                               |         order and 1 for a buy order\\n    ///                               |\\n    ///                               +-------- order fill bit, 0 for fill-or-\\n    ///                                         kill and 1 for a partially\\n    ///                                         fillable order\\n    /// ```\\n    ///\\n    /// Order signatures support two schemes:\\n    /// - EIP-712 for signing typed data, this is the default scheme that will\\n    ///   be used when recovering the signing address from the signature.\\n    /// - Generic message signature, this scheme will be used **only** if the\\n    ///   `v` signature parameter's most significant bit is set. This is done as\\n    ///   there are only two possible values `v` can have: 27 or 28, which only\\n    ///   take up the lower 5 bits of the `uint8`.\\n    ///\\n    /// @param domainSeparator The domain separator used for signing the order.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the encoded order parameters map to tokens in this array.\\n    /// @param encodedTrade The trade as encoded calldata bytes.\\n    /// @param trade The memory location to decode trade to.\\n    function decodeTrade(\\n        bytes calldata encodedTrade,\\n        bytes32 domainSeparator,\\n        IERC20[] calldata tokens,\\n        Trade memory trade\\n    ) internal pure {\\n        uint8 sellTokenIndex;\\n        uint8 buyTokenIndex;\\n        uint32 validTo;\\n        uint256 flags;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        // NOTE: Use assembly to efficiently decode packed data. Memory structs\\n        // in Solidity aren't packed, so the `Order` fields are in order at 32\\n        // byte increments.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // order = trade.order\\n            let order := mload(trade)\\n\\n            // sellTokenIndex = uint8(encodedTrade[0])\\n            sellTokenIndex := shr(248, calldataload(encodedTrade.offset))\\n            // buyTokenIndex = uint8(encodedTrade[1])\\n            buyTokenIndex := shr(248, calldataload(add(encodedTrade.offset, 1)))\\n            // order.sellAmount = uint256(encodedTrade[2:34])\\n            mstore(add(order, 64), calldataload(add(encodedTrade.offset, 2)))\\n            // order.buyAmount = uint256(encodedTrade[34:66])\\n            mstore(add(order, 96), calldataload(add(encodedTrade.offset, 34)))\\n            // order.validTo = uint32(encodedTrade[66:70])\\n            validTo := shr(224, calldataload(add(encodedTrade.offset, 66)))\\n            // order.appData = uint32(encodedTrade[70:74])\\n            mstore(\\n                add(order, 160),\\n                shr(224, calldataload(add(encodedTrade.offset, 70)))\\n            )\\n            // order.feeAmount = uint256(encodedTrade[74:106])\\n            mstore(add(order, 192), calldataload(add(encodedTrade.offset, 74)))\\n            // flags = uint8(encodedTrade[106])\\n            flags := shr(248, calldataload(add(encodedTrade.offset, 106)))\\n            // trade.executedAmount = uint256(encodedTrade[107:139])\\n            mstore(add(trade, 96), calldataload(add(encodedTrade.offset, 107)))\\n            // trade.feeDiscount = uint256(encodedTrade[139:141])\\n            mstore(\\n                add(trade, 128),\\n                shr(240, calldataload(add(encodedTrade.offset, 139)))\\n            )\\n            // v = uint8(encodedTrade[141])\\n            v := shr(248, calldataload(add(encodedTrade.offset, 141)))\\n            // r = uint256(encodedTrade[142:174])\\n            r := calldataload(add(encodedTrade.offset, 142))\\n            // s = uint256(encodedTrade[174:206])\\n            s := calldataload(add(encodedTrade.offset, 174))\\n        }\\n\\n        trade.order.sellToken = tokens[sellTokenIndex];\\n        trade.order.buyToken = tokens[buyTokenIndex];\\n        trade.order.validTo = validTo;\\n        if (flags & 0x01 == 0) {\\n            trade.order.kind = ORDER_KIND_SELL;\\n        } else {\\n            trade.order.kind = ORDER_KIND_BUY;\\n        }\\n        trade.order.partiallyFillable = flags & 0x02 != 0;\\n\\n        trade.sellTokenIndex = sellTokenIndex;\\n        trade.buyTokenIndex = buyTokenIndex;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. The hash is\\n        // computed from the order type hash concatenated with the ABI encoded\\n        // order fields for a total of `10 * sizeof(uint) = 320` bytes.\\n        // Fortunately, since Solidity memory structs **are not** packed, they\\n        // are already laid out in memory exactly as is needed to compute the\\n        // struct hash, just requiring the order type hash to be temporarily\\n        // writen to the memory slot coming right before the order data.\\n        bytes32 orderDigest;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(mload(trade), 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, ORDER_TYPE_HASH)\\n            orderDigest := keccak256(dataStart, 320)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Solidity allocates, but does not free, memory when:\\n        // - calling the ABI encoding methods\\n        // - calling the `ecrecover` precompile.\\n        // However, we can restore the free memory pointer to before we made\\n        // allocations to effectively free the memory. This is safe as the\\n        // memory used can be discarded, and the memory pointed to by the free\\n        // memory pointer **does not have to point to zero-ed out memory**.\\n        // <https://solidity.readthedocs.io/en/v0.7.5/internals/layout_in_memory.html>\\n        uint256 freeMemoryPointer;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            freeMemoryPointer := mload(0x40)\\n        }\\n\\n        bytes32 signingDigest;\\n        if (v & 0x80 == 0) {\\n            // NOTE: The most significant bit **is not set**, so the order is\\n            // signed using the EIP-712 sheme, the signing hash is of:\\n            // `\\\"\\\\x19\\\\x01\\\" || domainSeparator || orderDigest`.\\n            signingDigest = keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, orderDigest)\\n            );\\n        } else {\\n            // NOTE: The most significant bit **is set**, so the order is signed\\n            // using generic message scheme, the signing hash is of:\\n            // `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" || length || data` where the\\n            // length is a constant 64 bytes and the data is defined as:\\n            // `domainSeparator || orderDigest`.\\n            signingDigest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n64\\\",\\n                    domainSeparator,\\n                    orderDigest\\n                )\\n            );\\n        }\\n\\n        address owner = ecrecover(signingDigest, v & 0x1f, r, s);\\n        require(owner != address(0), \\\"GPv2: invalid signature\\\");\\n\\n        trade.owner = owner;\\n\\n        // NOTE: Restore the free memory pointer to free temporary memory.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(0x40, freeMemoryPointer)\\n        }\\n\\n        // NOTE: Initialize the memory for the order UID if required.\\n        if (trade.orderUid.length != ORDER_UID_LENGTH) {\\n            trade.orderUid = new bytes(ORDER_UID_LENGTH);\\n        }\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // orderUid = trade.orderUid.dataOffset\\n            let orderUid := add(mload(add(trade, 192)), 32)\\n            mstore(add(orderUid, 24), validTo)\\n            mstore(add(orderUid, 20), owner)\\n            mstore(orderUid, orderDigest)\\n        }\\n    }\\n\\n    /// @dev Decodes an interaction from calldata into memory.\\n    ///\\n    /// An encoded interaction has three components: the target address, the data\\n    /// length, and the actual interaction data of variable size.\\n    ///\\n    /// ```\\n    /// struct EncodedInteraction {\\n    ///     address target;\\n    ///     uint24 dataLength;\\n    ///     bytes callData;\\n    /// }\\n    /// ```\\n    ///\\n    /// All entries are tightly packed together in this order in the encoded\\n    /// calldata. Example:\\n    ///\\n    /// input:    0x73c14081446bd1e4eb165250e826e80c5a523783000010000102030405060708090a0b0c0d0e0f\\n    /// decoding:   [...............target.................][leng][............data..............]\\n    /// stride:                                          20     3    (defined in length field) 16\\n    ///\\n    /// This function enforces that the encoded data stores enough bytes to\\n    /// cover the full length of the decoded interaction.\\n    ///\\n    /// The size of `dataLength` limits the maximum calldata that can be used in\\n    /// an interaction. Based on the current rules of the Ethereum protocol,\\n    /// this length is enough to include any valid transaction: an extra\\n    /// calldata byte costs at least 4 gas, and the maximum gas spent in a block\\n    /// is 12.5M. This gives an upper bound on the calldata that can be included\\n    /// in a block of\\n    ///   3.125.000 < 16.777.216 = 2**(3*8) .\\n    ///\\n    /// @param encodedInteractions The interactions as encoded calldata bytes.\\n    /// @param interaction The memory location to decode the interaction to.\\n    /// @return remainingEncodedInteractions The part of encodedInteractions that\\n    /// has not been decoded after this function is executed.\\n    function decodeInteraction(\\n        bytes calldata encodedInteractions,\\n        Interaction memory interaction\\n    ) internal pure returns (bytes calldata remainingEncodedInteractions) {\\n        uint256 dataLength;\\n\\n        // Note: use assembly to efficiently decode packed data and store the\\n        // target address.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // interaction.target = address(encodedInteractions[0])\\n            mstore(\\n                interaction,\\n                shr(96, calldataload(encodedInteractions.offset))\\n            )\\n\\n            // dataLength = uint24(encodedInteractions[1])\\n            dataLength := shr(\\n                232,\\n                calldataload(add(encodedInteractions.offset, 20))\\n            )\\n        }\\n\\n        // Safety: dataLength fits a uint24, no overflow is possible.\\n        uint256 encodedInteractionSize = 20 + 3 + dataLength;\\n        require(\\n            encodedInteractions.length >= encodedInteractionSize,\\n            \\\"GPv2: invalid interaction\\\"\\n        );\\n\\n        bytes calldata interactionCallData;\\n        // Note: assembly is used to split the calldata into two components, one\\n        // being the calldata of the current interaction and the other being the\\n        // encoded bytes of the remaining interactions.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            interactionCallData.offset := add(encodedInteractions.offset, 23)\\n            interactionCallData.length := dataLength\\n\\n            remainingEncodedInteractions.offset := add(\\n                encodedInteractions.offset,\\n                encodedInteractionSize\\n            )\\n            remainingEncodedInteractions.length := sub(\\n                encodedInteractions.length,\\n                encodedInteractionSize\\n            )\\n        }\\n\\n        // Solidity takes care of copying the calldata slice into memory.\\n        interaction.callData = interactionCallData;\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(bytes calldata orderUid)\\n        internal\\n        pure\\n        returns (\\n            bytes32 orderDigest,\\n            address owner,\\n            uint32 validTo\\n        )\\n    {\\n        require(orderUid.length == 32 + 20 + 4, \\\"GPv2: invalid uid\\\");\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/libraries/GPv2TradeExecution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity ^0.7.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Trade Execution\\n/// @author Gnosis Developers\\nlibrary GPv2TradeExecution {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Executed trade data.\\n    struct Data {\\n        address owner;\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n    }\\n\\n    /// @dev Executes the trade's sell amount, transferring it from the trade's\\n    /// owner to the specified recipient.\\n    function transferSellAmountToRecipient(\\n        Data calldata trade,\\n        address recipient\\n    ) internal {\\n        trade.sellToken.safeTransferFrom(\\n            trade.owner,\\n            recipient,\\n            trade.sellAmount\\n        );\\n    }\\n\\n    /// @dev Executes the trade's buy amount, transferring it to the trade's\\n    /// owner from the caller's address.\\n    function transferBuyAmountToOwner(Data memory trade) internal {\\n        trade.buyToken.safeTransfer(trade.owner, trade.buyAmount);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract GPv2Authentication\",\"name\":\"authenticator_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"orderUid\",\"type\":\"bytes\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowanceManager\",\"outputs\":[{\"internalType\":\"contract GPv2AllowanceManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"filledAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"orderUid\",\"type\":\"bytes\"}],\"name\":\"invalidateOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"clearingPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"encodedTrades\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedInteractions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedOrderRefunds\",\"type\":\"bytes\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GPv2Settlement","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"00000000000000000000000060027a9c1ef06ee9890f086b05a4acc6cd041d62","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}