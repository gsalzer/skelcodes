{"status":"1","message":"OK","result":[{"SourceCode":"// Price Oracle for Stabinol Token\r\n// This contract uses both Chainlink and Uniswap to obtain the token price\r\n// It initially uses 10 minute averages but can be updated on the fly by governance\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n  function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\ninterface UniswapV2Pair {\r\n    function price0CumulativeLast() external view returns (uint256);\r\n    function price1CumulativeLast() external view returns (uint256);\r\n    function getReserves() external view returns (uint112, uint112, uint32);\r\n}\r\n\r\ncontract StabinolPriceOracle {\r\n\r\n    address public owner;\r\n    bool private _firstCapture = true;\r\n    uint256 private _stolUSDPrice = 0;\r\n    uint256 private _stolPriceWindow = 0; // The time period this price was calculated over, determines its weight\r\n    uint256 private _tokenIndex = 0;\r\n    uint256 public lastSTOLPriceUpdate; // The last time the price was updated\r\n    uint256 public updateFrequency = 10 minutes; // Oracle can be updated at least every 10 minutes\r\n    \r\n    address constant CHAINLINK_ETH_ORACLE = address(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n    uint256 constant DIVISION_FACTOR = 100000;\r\n    \r\n    // TWAP details\r\n    address public stolLiquidity;\r\n    uint256 private lastTWAPCumulativePrice;\r\n    uint32 private lastTWAPBlockTime;\r\n    uint256 private lastTWAPPrice;\r\n    \r\n    // Events\r\n    event NoLiquidity();\r\n    event FirstPriceCapture(); // First time price update is called, must wait til another time to update\r\n    event FailedPriceCapture(); // Not quick enough price movement for a twap to be calculated\r\n    \r\n    constructor(address _lp, uint256 _index) public {\r\n        owner = msg.sender;\r\n        stolLiquidity = _lp; // This is the address to the Uniswap pair\r\n        _tokenIndex = _index; // STOL could be in either position 1 or position 2\r\n    }\r\n    \r\n    modifier onlyGovernance() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function getETHUSD() public view returns (uint256) {\r\n        // Returns this price with 18 decimal places\r\n        AggregatorV3Interface ethOracle = AggregatorV3Interface(CHAINLINK_ETH_ORACLE);\r\n        ( , int intEthPrice, , , ) = ethOracle.latestRoundData(); // We only want the answer \r\n        return uint256(intEthPrice) * 1e10;\r\n    }\r\n    \r\n    function getLatestSTOLUSD() external view returns (uint256) {\r\n        // Returns the stored price\r\n        return _stolUSDPrice;\r\n    }\r\n    \r\n    function governanceChangeFrequency(uint256 _freq) external onlyGovernance {\r\n        updateFrequency = _freq;\r\n    }\r\n    \r\n    function updateSTOLPrice() external {\r\n        if(now < lastSTOLPriceUpdate + updateFrequency){ return; } // Do nothing if update is called too soon\r\n        uint256 period = now - lastSTOLPriceUpdate; // Get the time between the last update and now\r\n        lastSTOLPriceUpdate = now;\r\n        // We will use a combination of the Twap and weighted averages to determine the current price\r\n        UniswapV2Pair pair = UniswapV2Pair(stolLiquidity);\r\n        (, uint112 reserve1, uint32 _blockTime) = pair.getReserves();\r\n        if(reserve1 == 0){\r\n            // Liquidity is gone/non-existant, can't update the price\r\n            // Reset the oracle\r\n            _stolUSDPrice = 0;\r\n            _stolPriceWindow = 0;\r\n            lastTWAPBlockTime = 0;\r\n            lastTWAPCumulativePrice = 0;\r\n            _firstCapture = true;\r\n            emit NoLiquidity();\r\n            return;\r\n        }\r\n        if(lastTWAPBlockTime != _blockTime){\r\n            // Uniswap twap price has updated, update our twap price\r\n            if(_firstCapture == true){\r\n                // Never had a price before, save the price accumulators\r\n                if(_tokenIndex == 0){\r\n                    lastTWAPCumulativePrice = pair.price0CumulativeLast();\r\n                }else{\r\n                    lastTWAPCumulativePrice = pair.price1CumulativeLast();\r\n                }\r\n                lastTWAPBlockTime = _blockTime;\r\n                _firstCapture = false;\r\n                emit FirstPriceCapture();\r\n                return;\r\n            }else{\r\n                // We already have a price cumulative, capture a new price\r\n                uint256 cumuPrice = 0;\r\n                if(_tokenIndex == 0){\r\n                    cumuPrice = pair.price0CumulativeLast();\r\n                }else{\r\n                    cumuPrice = pair.price1CumulativeLast();\r\n                }\r\n                // This is price in relationship to base pair\r\n                lastTWAPPrice = ((cumuPrice - lastTWAPCumulativePrice) / (_blockTime - lastTWAPBlockTime) * 1e18) >> 112;\r\n                lastTWAPCumulativePrice = cumuPrice;\r\n                lastTWAPBlockTime = _blockTime;\r\n            }\r\n        }\r\n        if(lastTWAPPrice == 0){\r\n            // Still no price calculation possible since no action on trading pair since last call\r\n            emit FailedPriceCapture();\r\n            return;\r\n        }\r\n        if(_stolPriceWindow == 0){\r\n            // First time price is calculated, set it to the twap price in USD\r\n            _stolPriceWindow = updateFrequency;\r\n            // Now calculate USD price from ETH Price\r\n            _stolUSDPrice = getETHUSD() / 1e10 * lastTWAPPrice / 1e8;\r\n        }else{\r\n            // There is already a price window and price, use weighted averages to determine the weight\r\n            uint256 price = getETHUSD() / 1e10 * lastTWAPPrice / 1e8;\r\n            _stolUSDPrice = (_stolUSDPrice * (_stolPriceWindow * DIVISION_FACTOR / (_stolPriceWindow + period)) / DIVISION_FACTOR);\r\n            _stolUSDPrice += (price * (period * DIVISION_FACTOR / (_stolPriceWindow + period)) / DIVISION_FACTOR);\r\n            _stolPriceWindow = period; // Set the window to the new period\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FailedPriceCapture\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FirstPriceCapture\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NoLiquidity\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getETHUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestSTOLUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_freq\",\"type\":\"uint256\"}],\"name\":\"governanceChangeFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSTOLPriceUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stolLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateSTOLPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StabinolPriceOracle","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000bd13d3297570885ed73ee93d3e929fe1e5b233f00000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8abad09b568741219efa39c643dab847e6495f8fc6f11313cddca4c5b9c63568"}]}