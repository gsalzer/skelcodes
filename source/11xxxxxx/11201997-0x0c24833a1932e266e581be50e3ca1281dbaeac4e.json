{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/AlpacaToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: SEE LICENSE FILE\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n\\n// AlpacaToken with Governance.\\ncontract AlpacaToken is ERC20(\\\"AlpacaToken\\\", \\\"PACA\\\"), Ownable {\\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\\n    function mint(address _to, uint256 _amount) public onlyOwner {\\n        _mint(_to, _amount);\\n        _moveDelegates(address(0), _delegates[_to], _amount);\\n    }\\n\\n    // Modified from Sushi with delegate issues fixed, basicially just Compound\\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\\n\\n    /// @dev A record of each accounts delegate\\n    mapping (address => address) internal _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n\\n      /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @dev modified from OpenZeppelin to move delegates when tokens are transferred\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _moveDelegates(_delegates[msg.sender], _delegates[recipient], amount);\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev modified from OpenZeppelin to move delegates when tokens are transferred\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _moveDelegates(_delegates[sender], _delegates[recipient], amount);\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, allowance(sender, msg.sender).sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegator The address to get delegatee for\\n     */\\n    function delegates(address delegator)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return _delegates[delegator];\\n    }\\n\\n   /**\\n    * @notice Delegate votes from `msg.sender` to `delegatee`\\n    * @param delegatee The address to delegate votes to\\n    */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint nonce,\\n        uint expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n    {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name())),\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                delegatee,\\n                nonce,\\n                expiry\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                structHash\\n            )\\n        );\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"SUSHI::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"SUSHI::delegateBySig: invalid nonce\\\");\\n        require(now <= expiry, \\\"SUSHI::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(blockNumber < block.number, \\\"SUSHI::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee)\\n        internal\\n    {\\n        address currentDelegate = _delegates[delegator];\\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                // decrease old representative\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                // increase new representative\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    )\\n        internal\\n    {\\n        uint32 blockNumber = safe32(block.number, \\\"SUSHI::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/CRPFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Needed to handle structures externally\\npragma experimental ABIEncoderV2;\\n\\n// Imports\\n\\nimport \\\"./ConfigurableRightsPool.sol\\\";\\n\\n// Contracts\\n\\n/**\\n * @author Balancer Labs\\n * @title Configurable Rights Pool Factory - create parameterized smart pools\\n * @dev Rights are held in a corresponding struct in ConfigurableRightsPool\\n *      Index values are as follows:\\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\\n *                            by default, it is off on initialization and can only be turned on\\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\\n *      4: canWhitelistLPs - if set, only whitelisted addresses can join pools\\n *                           (enables private pools with more than one LP)\\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\\n */\\ncontract CRPFactory {\\n    // State variables\\n\\n    // Keep a list of all Configurable Rights Pools\\n    mapping(address=>bool) private _isCrp;\\n\\n    // Event declarations\\n\\n\\n    // Function declarations\\n\\n    /**\\n     * @notice Create a new CRP\\n     * @dev emits a LogNewCRP event\\n     * @param factoryAddress - the BFactory instance used to create the underlying pool\\n     * @param poolParams - struct containing the names, tokens, weights, balances, and swap fee\\n     * @param rights - struct of permissions, configuring this CRP instance (see above for definitions)\\n     */\\n    function newCrp(\\n        address factoryAddress,\\n        ConfigurableRightsPool.PoolParams calldata poolParams,\\n        RightsManager.Rights calldata rights\\n    )\\n        external\\n        returns (ConfigurableRightsPool)\\n    {\\n        require(poolParams.constituentTokens.length >= BalancerConstants.MIN_ASSET_LIMIT, \\\"ERR_TOO_FEW_TOKENS\\\");\\n\\n        // Arrays must be parallel\\n        require(poolParams.tokenBalances.length == poolParams.constituentTokens.length, \\\"ERR_START_BALANCES_MISMATCH\\\");\\n        require(poolParams.tokenWeights.length == poolParams.constituentTokens.length, \\\"ERR_START_WEIGHTS_MISMATCH\\\");\\n\\n        ConfigurableRightsPool crp = new ConfigurableRightsPool(\\n            factoryAddress,\\n            poolParams,\\n            rights\\n        );\\n\\n\\n        crp.setController(msg.sender);\\n\\n        return crp;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/ConfigurableRightsPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Needed to handle structures externally\\npragma experimental ABIEncoderV2;\\n\\n// Imports\\n\\nimport \\\"./IBFactory.sol\\\";\\nimport \\\"./PCToken.sol\\\";\\nimport \\\"./utils/BalancerReentrancyGuard.sol\\\";\\nimport \\\"./utils/BalancerOwnable.sol\\\";\\n\\n// Interfaces\\n\\n// Libraries\\nimport { RightsManager } from \\\"../libraries/RightsManager.sol\\\";\\nimport \\\"../libraries/SmartPoolManager.sol\\\";\\nimport \\\"../libraries/SafeApprove.sol\\\";\\n\\n// Contracts\\n\\n/**\\n * @author Balancer Labs\\n * @title Smart Pool with customizable features\\n * @notice PCToken is the \\\"Balancer Smart Pool\\\" token (transferred upon finalization)\\n * @dev Rights are defined as follows (index values into the array)\\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\\n *                            by default, it is off on initialization and can only be turned on\\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\\n *      4: canWhitelistLPs - can restrict LPs to a whitelist\\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\\n *\\n * Note that functions called on bPool and bFactory may look like internal calls,\\n *   but since they are contracts accessed through an interface, they are really external.\\n * To make this explicit, we could write \\\"IBPool(address(bPool)).function()\\\" everywhere,\\n *   instead of \\\"bPool.function()\\\".\\n */\\ncontract ConfigurableRightsPool is PCToken, BalancerOwnable, BalancerReentrancyGuard {\\n    using BalancerSafeMath for uint;\\n    using SafeApprove for IERC20;\\n\\n    // Type declarations\\n\\n    struct PoolParams {\\n        // Balancer Pool Token (representing shares of the pool)\\n        string poolTokenSymbol;\\n        string poolTokenName;\\n        // Tokens inside the Pool\\n        address[] constituentTokens;\\n        uint[] tokenBalances;\\n        uint[] tokenWeights;\\n        uint swapFee;\\n    }\\n\\n    // State variables\\n\\n    IBFactory public bFactory;\\n    IBPool public bPool;\\n\\n    // Struct holding the rights configuration\\n    RightsManager.Rights public rights;\\n\\n    // Hold the parameters used in updateWeightsGradually\\n    SmartPoolManager.GradualUpdateParams public gradualUpdate;\\n\\n    // This is for adding a new (currently unbound) token to the pool\\n    // It's a two-step process: commitAddToken(), then applyAddToken()\\n    SmartPoolManager.NewTokenParams public newToken;\\n\\n    // Fee is initialized on creation, and can be changed if permission is set\\n    // Only needed for temporary storage between construction and createPool\\n    // Thereafter, the swap fee should always be read from the underlying pool\\n    uint private _initialSwapFee;\\n\\n    // Store the list of tokens in the pool, and balances\\n    // NOTE that the token list is *only* used to store the pool tokens between\\n    //   construction and createPool - thereafter, use the underlying BPool's list\\n    //   (avoids synchronization issues)\\n    address[] private _initialTokens;\\n    uint[] private _initialBalances;\\n\\n    // Enforce a minimum time between the start and end blocks\\n    uint public minimumWeightChangeBlockPeriod;\\n    // Enforce a mandatory wait time between updates\\n    // This is also the wait time between committing and applying a new token\\n    uint public addTokenTimeLockInBlocks;\\n\\n\\n    // Fee payout settings\\n    address public feeTo;\\n    uint public fracFeePaidOut;  // fraction of fee paid out from pool\\n    address public exitFeeTo;\\n    // Token that LP shares to be paid out should be converted to\\n    // Set to address(0) if we want payout LP shares instead\\n    address public payoutToken;\\n\\n    // Event declarations\\n\\n    // Anonymous logger event - can only be filtered by contract address\\n\\n    event LogCall(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes data\\n    ) anonymous;\\n\\n    event LogJoin(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint tokenAmountIn\\n    );\\n\\n    event LogExit(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint tokenAmountOut\\n    );\\n\\n    event CapChanged(\\n        address indexed caller,\\n        uint oldCap,\\n        uint newCap\\n    );\\n\\n    event NewTokenCommitted(\\n        address indexed token,\\n        address indexed pool,\\n        address indexed caller\\n    );\\n\\n    event LogFeeMint(\\n        address indexed feeTo,\\n        uint shares\\n    );\\n\\n    // event EventPrint(string printStr);\\n\\n    // Modifiers\\n\\n    modifier logs() {\\n        emit LogCall(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    // Mark functions that require delegation to the underlying Pool\\n    modifier needsBPool() {\\n        require(address(bPool) != address(0), \\\"ERR_NOT_CREATED\\\");\\n        _;\\n    }\\n\\n    modifier lockUnderlyingPool() {\\n        // Turn off swapping on the underlying pool during joins\\n        // Otherwise tokens with callbacks would enable attacks involving simultaneous swaps and joins\\n        bool origSwapState = bPool.isPublicSwap();\\n        bPool.setPublicSwap(false);\\n        _;\\n        bPool.setPublicSwap(origSwapState);\\n    }\\n\\n    // Default values for these variables (used only in updateWeightsGradually), set in the constructor\\n    // Pools without permission to update weights cannot use them anyway, and should call\\n    //   the default createPool() function.\\n    // To override these defaults, pass them into the overloaded createPool()\\n    // Period is in blocks; 500 blocks ~ 2 hours; 90,000 blocks ~ 2 weeks\\n    uint public constant DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD = 90000;\\n    uint public constant DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS = 500;\\n\\n    // Function declarations\\n\\n    /**\\n     * @notice Construct a new Configurable Rights Pool (wrapper around BPool)\\n     * @dev _initialTokens and _swapFee are only used for temporary storage between construction\\n     *      and create pool, and should not be used thereafter! _initialTokens is destroyed in\\n     *      createPool to prevent this, and _swapFee is kept in sync (defensively), but\\n     *      should never be used except in this constructor and createPool()\\n     * @param factoryAddress - the BPoolFactory used to create the underlying pool\\n     * @param poolParams - struct containing pool parameters\\n     * @param rightsStruct - Set of permissions we are assigning to this smart pool\\n     */\\n    constructor(\\n        address factoryAddress,\\n        PoolParams memory poolParams,\\n        RightsManager.Rights memory rightsStruct\\n    )\\n        public\\n        PCToken(poolParams.poolTokenSymbol, poolParams.poolTokenName)\\n    {\\n        // We don't have a pool yet; check now or it will fail later (in order of likelihood to fail)\\n        // (and be unrecoverable if they don't have permission set to change it)\\n        // Most likely to fail, so check first\\n        require(poolParams.swapFee >= BalancerConstants.MIN_FEE, \\\"ERR_INVALID_SWAP_FEE\\\");\\n        require(poolParams.swapFee <= BalancerConstants.MAX_FEE, \\\"ERR_INVALID_SWAP_FEE\\\");\\n\\n        // Arrays must be parallel\\n        require(poolParams.tokenBalances.length == poolParams.constituentTokens.length, \\\"ERR_START_BALANCES_MISMATCH\\\");\\n        require(poolParams.tokenWeights.length == poolParams.constituentTokens.length, \\\"ERR_START_WEIGHTS_MISMATCH\\\");\\n        // Cannot have too many or too few - technically redundant, since BPool.bind() would fail later\\n        // But if we don't check now, we could have a useless contract with no way to create a pool\\n\\n        require(poolParams.constituentTokens.length >= BalancerConstants.MIN_ASSET_LIMIT, \\\"ERR_TOO_FEW_TOKENS\\\");\\n        // No bound on max tokens in Alpaca\\n        // Governance determines how many and which tokens are included\\n        // require(poolParams.constituentTokens.length <= BalancerConstants.MAX_ASSET_LIMIT, \\\"ERR_TOO_MANY_TOKENS\\\");\\n        // There are further possible checks (e.g., if they use the same token twice), but\\n        // we can let bind() catch things like that (i.e., not things that might reasonably work)\\n\\n        SmartPoolManager.verifyTokenCompliance(poolParams.constituentTokens);\\n\\n        bFactory = IBFactory(factoryAddress);\\n        rights = rightsStruct;\\n        _initialTokens = poolParams.constituentTokens;\\n        _initialBalances = poolParams.tokenBalances;\\n        _initialSwapFee = poolParams.swapFee;\\n\\n        // These default block time parameters can be overridden in createPool\\n        minimumWeightChangeBlockPeriod = DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD;\\n        addTokenTimeLockInBlocks = DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS;\\n        \\n        gradualUpdate.startWeights = poolParams.tokenWeights;\\n        // Initializing (unnecessarily) for documentation - 0 means no gradual weight change has been initiated\\n        gradualUpdate.startBlock = 0;\\n\\n        // Future: add new config variables to constructor\\n        // setFeeTo(_feeTo);\\n        // setFracFeePaidOut(_feeToPct);\\n        // setPayoutToken(_payOutToken);\\n        // setExitFee(_exitFee);\\n        // setExitFeeTo(_exitFeeTo);\\n        // setController(rancher);\\n    }\\n\\n    // External functions\\n\\n    /**\\n     * @notice Set the swap fee on the underlying pool\\n     * @dev Keep the local version and core in sync (see below)\\n     *      bPool is a contract interface; function calls on it are external\\n     * @param swapFee in Wei\\n     */\\n    function setSwapFee(uint swapFee)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canChangeSwapFee, \\\"ERR_NOT_CONFIGURABLE_SWAP_FEE\\\");\\n\\n        // Future: make _mintFee() a decorator\\n        _mintFee();\\n\\n        // Underlying pool will check against min/max fee\\n        bPool.setSwapFee(swapFee);\\n    }\\n\\n    /**\\n     * @notice Set the exit fee on the underlying pool\\n     * @dev _mintFee() included as a protective measure\\n     * @param exitFee in Wei\\n     */\\n    function setExitFee(uint exitFee)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        _mintFee();\\n        // Underlying pool will check against min/max fee\\n        bPool.setExitFee(exitFee);\\n    }\\n\\n    /**\\n     * @notice Getter for the publicSwap field on the underlying pool\\n     * @dev viewLock, because setPublicSwap is lock\\n     *      bPool is a contract interface; function calls on it are external\\n     * @return Current value of isPublicSwap\\n     */\\n    function isPublicSwap()\\n        external\\n        view\\n        viewlock\\n        needsBPool\\n        virtual\\n        returns (bool)\\n    {\\n        return bPool.isPublicSwap();\\n    }\\n\\n\\n\\n    /**\\n     * @notice Set the public swap flag on the underlying pool\\n     * @dev If this smart pool has canPauseSwapping enabled, we can turn publicSwap off if it's already on\\n     *      Note that if they turn swapping off - but then finalize the pool - finalizing will turn the\\n     *      swapping back on. They're not supposed to finalize the underlying pool... would defeat the\\n     *      smart pool functions. (Only the owner can finalize the pool - which is this contract -\\n     *      so there is no risk from outside.)\\n     *\\n     *      bPool is a contract interface; function calls on it are external\\n     * @param publicSwap new value of the swap\\n     */\\n    function setPublicSwap(bool publicSwap)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canPauseSwapping, \\\"ERR_NOT_PAUSABLE_SWAP\\\");\\n\\n        bPool.setPublicSwap(publicSwap);\\n    }\\n\\n    /**\\n     * @notice Create a new Smart Pool - and set the block period time parameters\\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\\n     *      Can be changed if the canChangeSwapFee permission is enabled\\n     *      Time parameters will be fixed at these values\\n     *\\n     *      If this contract doesn't have canChangeWeights permission - or you want to use the default\\n     *      values, the block time arguments are not needed, and you can just call the single-argument\\n     *      createPool()\\n     * @param initialSupply - Starting token balance\\n     * @param minimumWeightChangeBlockPeriodParam - Enforce a minimum time between the start and end blocks\\n     * @param addTokenTimeLockInBlocksParam - Enforce a mandatory wait time between updates\\n     *                                   This is also the wait time between committing and applying a new token\\n     */\\n    function createPool(\\n        uint initialSupply,\\n        uint minimumWeightChangeBlockPeriodParam,\\n        uint addTokenTimeLockInBlocksParam\\n    )\\n        external\\n        onlyOwner\\n        logs\\n        lock\\n        virtual\\n    {\\n        require (minimumWeightChangeBlockPeriodParam >= addTokenTimeLockInBlocksParam,\\n                \\\"ERR_INCONSISTENT_TOKEN_TIME_LOCK\\\");\\n \\n        minimumWeightChangeBlockPeriod = minimumWeightChangeBlockPeriodParam;\\n        addTokenTimeLockInBlocks = addTokenTimeLockInBlocksParam;\\n\\n        createPoolInternal(initialSupply);\\n    }\\n\\n    /**\\n     * @notice Create a new Smart Pool\\n     * @dev Delegates to internal function\\n     * @param initialSupply starting token balance\\n     */\\n    function createPool(uint initialSupply)\\n        external\\n        onlyOwner\\n        logs\\n        lock\\n        virtual\\n    {\\n        createPoolInternal(initialSupply);\\n    }\\n\\n    /**\\n     * @notice Update the weight of an existing token\\n     * @dev Notice Balance is not an input (like with rebind on BPool) since we will require prices not to change\\n     *      This is achieved by forcing balances to change proportionally to weights, so that prices don't change\\n     *      If prices could be changed, this would allow the controller to drain the pool by arbing price changes\\n     * @param token - token to be reweighted\\n     * @param newWeight - new weight of the token\\n    */\\n    function updateWeight(address token, uint newWeight)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canChangeWeights, \\\"ERR_NOT_CONFIGURABLE_WEIGHTS\\\");\\n\\n        // We don't want people to set weights manually if there's a block-based update in progress\\n        require(gradualUpdate.startBlock == 0, \\\"ERR_NO_UPDATE_DURING_GRADUAL\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n        SmartPoolManager.updateWeight(IConfigurableRightsPool(address(this)), bPool, token, newWeight);\\n    }\\n\\n    /**\\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\\n     *         through external calls to pokeWeights\\n     * @dev Must call pokeWeights at least once past the end for it to do the final update\\n     *      and enable calling this again.\\n     *      It is possible to call updateWeightsGradually during an update in some use cases\\n     *      For instance, setting newWeights to currentWeights to stop the update where it is\\n     * @param newWeights - final weights we want to get to. Note that the ORDER (and number) of\\n     *                     tokens can change if you have added or removed tokens from the pool\\n     *                     It ensures the counts are correct, but can't help you with the order!\\n     *                     You can get the underlying BPool (it's public), and call \\n     *                     getCurrentTokens() to see the current ordering, if you're not sure\\n     * @param startBlock - when weights should start to change\\n     * @param endBlock - when weights will be at their final values\\n    */\\n    function updateWeightsGradually(\\n        uint[] calldata newWeights,\\n        uint startBlock,\\n        uint endBlock\\n    )\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canChangeWeights, \\\"ERR_NOT_CONFIGURABLE_WEIGHTS\\\");\\n         // Don't start this when we're in the middle of adding a new token\\n        require(!newToken.isCommitted, \\\"ERR_PENDING_TOKEN_ADD\\\");\\n        \\n        _mintFee();\\n\\n        // Library computes the startBlock, computes startWeights as the current\\n        // denormalized weights of the core pool tokens.\\n        SmartPoolManager.updateWeightsGradually(\\n            bPool,\\n            gradualUpdate,\\n            newWeights,\\n            startBlock,\\n            endBlock,\\n            minimumWeightChangeBlockPeriod\\n        );\\n    }\\n\\n    /**\\n     * @notice External function called to make the contract update weights according to plan\\n     * @dev Still works if we poke after the end of the period; also works if the weights don't change\\n     *      Resets if we are poking beyond the end, so that we can do it again\\n    */\\n    function pokeWeights()\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canChangeWeights, \\\"ERR_NOT_CONFIGURABLE_WEIGHTS\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n        SmartPoolManager.pokeWeights(bPool, gradualUpdate);\\n    }\\n\\n    /**\\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\\n     *         number of blocks to actually add the token\\n     *\\n     * @dev The purpose of this two-stage commit is to give warning of a potentially dangerous\\n     *      operation. A malicious pool operator could add a large amount of a low-value token,\\n     *      then drain the pool through price manipulation. Of course, there are many\\n     *      legitimate purposes, such as adding additional collateral tokens.\\n     *\\n     * @param token - the token to be added\\n     * @param balance - how much to be added\\n     * @param denormalizedWeight - the desired token weight\\n     */\\n    function commitAddToken(\\n        address token,\\n        uint balance,\\n        uint denormalizedWeight\\n    )\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canAddRemoveTokens, \\\"ERR_CANNOT_ADD_REMOVE_TOKENS\\\");\\n\\n        // Can't do this while a progressive update is happening\\n        require(gradualUpdate.startBlock == 0, \\\"ERR_NO_UPDATE_DURING_GRADUAL\\\");\\n\\n        SmartPoolManager.verifyTokenCompliance(token);\\n\\n        emit NewTokenCommitted(token, address(this), msg.sender);\\n\\n        // Delegate to library to save space\\n        SmartPoolManager.commitAddToken(\\n            bPool,\\n            token,\\n            balance,\\n            denormalizedWeight,\\n            newToken\\n        );\\n    }\\n\\n    /**\\n     * @notice Add the token previously committed (in commitAddToken) to the pool\\n     */\\n    function applyAddToken()\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n        virtual\\n    {\\n        // require(rights.canAddRemoveTokens, \\\"ERR_CANNOT_ADD_REMOVE_TOKENS\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n        SmartPoolManager.applyAddToken(\\n            IConfigurableRightsPool(address(this)),\\n            bPool,\\n            addTokenTimeLockInBlocks,\\n            newToken\\n        );\\n    }\\n\\n     /**\\n     * @notice Remove a token from the pool\\n     * @dev bPool is a contract interface; function calls on it are external\\n     * @param token - token to remove\\n     */\\n    function removeToken(address token)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n    {\\n        // It's possible to have remove rights without having add rights\\n        // require(rights.canAddRemoveTokens,\\\"ERR_CANNOT_ADD_REMOVE_TOKENS\\\");\\n        // After createPool, token list is maintained in the underlying BPool\\n        require(!newToken.isCommitted, \\\"ERR_REMOVE_WITH_ADD_PENDING\\\");\\n        // Prevent removing during an update (or token lists can get out of sync)\\n        require(gradualUpdate.startBlock == 0, \\\"ERR_NO_UPDATE_DURING_GRADUAL\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n        SmartPoolManager.removeToken(IConfigurableRightsPool(address(this)), bPool, token);\\n    } \\n\\n    /**\\n     * @notice Join a pool\\n     * @dev Emits a LogJoin event (for each token)\\n     *      bPool is a contract interface; function calls on it are external\\n     * @param poolAmountOut - number of pool tokens to receive\\n     * @param maxAmountsIn - Max amount of asset tokens to spend\\n     */\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        lockUnderlyingPool\\n    {\\n        // require(!rights.canWhitelistLPs,\\n        //         \\\"ERR_NOT_ON_WHITELIST\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n\\n        // Library computes actualAmountsIn, and does many validations\\n        // Cannot call the push/pull/min from an external library for\\n        // any of these pool functions. Since msg.sender can be anybody,\\n        // they must be internal\\n        uint[] memory actualAmountsIn = SmartPoolManager.joinPool(\\n                                            IConfigurableRightsPool(address(this)),\\n                                            bPool,\\n                                            poolAmountOut,\\n                                            maxAmountsIn\\n                                        );\\n\\n        // After createPool, token list is maintained in the underlying BPool\\n        address[] memory poolTokens = bPool.getCurrentTokens();\\n\\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            address t = poolTokens[i];\\n            uint tokenAmountIn = actualAmountsIn[i];\\n\\n            emit LogJoin(msg.sender, t, tokenAmountIn);\\n\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem pool tokens for underlying assets\\n     * @dev Emits a LogExit event for each token\\n     *      bPool is a contract interface; function calls on it are external\\n     * @param poolAmountIn - amount of pool tokens to redeem\\n     * @param minAmountsOut - minimum amount of asset tokens to receive\\n     */\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        lockUnderlyingPool\\n    {\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n\\n        // Library computes actualAmountsOut, and does many validations\\n        // Also computes the exitFee and pAiAfterExitFee\\n        (uint exitFee,\\n         uint pAiAfterExitFee,\\n         uint[] memory actualAmountsOut) = SmartPoolManager.exitPool(\\n                                               IConfigurableRightsPool(address(this)),\\n                                               bPool,\\n                                               poolAmountIn,\\n                                               minAmountsOut\\n                                           );\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(exitFeeTo, exitFee);\\n        _burnPoolShare(pAiAfterExitFee);\\n\\n        // After createPool, token list is maintained in the underlying BPool\\n        address[] memory poolTokens = bPool.getCurrentTokens();\\n\\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            address t = poolTokens[i];\\n            uint tokenAmountOut = actualAmountsOut[i];\\n\\n            emit LogExit(msg.sender, t, tokenAmountOut);\\n\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n    }\\n\\n    /**\\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\\n     *         System calculates the pool token amount\\n     * @dev emits a LogJoin event\\n     * @param tokenIn - which token we're transferring in\\n     * @param tokenAmountIn - amount of deposit\\n     * @param minPoolAmountOut - minimum of pool tokens to receive\\n     * @return poolAmountOut - amount of pool tokens minted and transferred\\n     */\\n    function joinswapExternAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        uint minPoolAmountOut\\n    )\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        returns (uint poolAmountOut)\\n    {\\n        // require(!rights.canWhitelistLPs, \\n        //         \\\"ERR_NOT_ON_WHITELIST\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n        poolAmountOut = SmartPoolManager.joinswapExternAmountIn(\\n                            IConfigurableRightsPool(address(this)),\\n                            bPool,\\n                            tokenIn,\\n                            tokenAmountIn,\\n                            minPoolAmountOut\\n                        );\\n\\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        // Update the running fraction of the pool attributable to accumulated fees\\n        uint fracPoolFeesTrade = bPool.calcFracPoolFeesFromPoolJoin(tokenIn, tokenAmountIn);\\n        bPool.updateFracPoolFees(fracPoolFeesTrade);\\n\\n        return poolAmountOut;\\n    }\\n\\n    /**\\n     * @notice Join by swapping an external token in (must be present in the pool)\\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\\n     * @dev emits a LogJoin event\\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\\n     * @param poolAmountOut - amount of pool tokens to be received\\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\\n     */\\n    function joinswapPoolAmountOut(\\n        address tokenIn,\\n        uint poolAmountOut,\\n        uint maxAmountIn\\n    )\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        returns (uint tokenAmountIn)\\n    {\\n        // require(!rights.canWhitelistLPs,\\n        //         \\\"ERR_NOT_ON_WHITELIST\\\");\\n\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n        tokenAmountIn = SmartPoolManager.joinswapPoolAmountOut(\\n                            IConfigurableRightsPool(address(this)),\\n                            bPool,\\n                            tokenIn,\\n                            poolAmountOut,\\n                            maxAmountIn\\n                        );\\n\\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        // Update the running fraction of the pool attributable to accumulated fees\\n        uint fracPoolFeesTrade = bPool.calcFracPoolFeesFromPoolJoin(tokenIn, tokenAmountIn);\\n        bPool.updateFracPoolFees(fracPoolFeesTrade);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\\n     * @dev Emits a LogExit event for the token\\n     * @param tokenOut - which token the caller wants to receive\\n     * @param poolAmountIn - amount of pool tokens to redeem\\n     * @param minAmountOut - minimum asset tokens to receive\\n     * @return tokenAmountOut - amount of asset tokens returned\\n     */\\n    function exitswapPoolAmountIn(\\n        address tokenOut,\\n        uint poolAmountIn,\\n        uint minAmountOut\\n    )\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        returns (uint tokenAmountOut)\\n    {\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n\\n        // Calculates final amountOut, and the fee and final amount in\\n        (uint exitFee,\\n         uint amountOut) = SmartPoolManager.exitswapPoolAmountIn(\\n                               IConfigurableRightsPool(address(this)),\\n                               bPool,\\n                               tokenOut,\\n                               poolAmountIn,\\n                               minAmountOut\\n                           );\\n\\n        tokenAmountOut = amountOut;\\n        uint pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\\n\\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(pAiAfterExitFee);\\n        // _pushPoolShare(address(bFactory), exitFee);\\n        _pushPoolShare(exitFeeTo, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        // Update the running fraction of the pool attributable to accumulated fees\\n        uint fracPoolFeesTrade = bPool.calcFracPoolFeesFromPoolExit(tokenOut, tokenAmountOut);\\n        bPool.updateFracPoolFees(fracPoolFeesTrade);\\n\\n        return tokenAmountOut;\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\\n     *         Asset must be present in the pool\\n     * @dev Emits a LogExit event for the token\\n     * @param tokenOut - which token the caller wants to receive\\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\\n     * @return poolAmountIn - amount of pool tokens redeemed\\n     */\\n    function exitswapExternAmountOut(\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPoolAmountIn\\n    )\\n        external\\n        logs\\n        lock\\n        needsBPool\\n        returns (uint poolAmountIn)\\n    {\\n        _mintFee();\\n\\n        // Delegate to library to save space\\n\\n        // Calculates final amounts in, accounting for the exit fee\\n        (uint exitFee,\\n         uint amountIn) = SmartPoolManager.exitswapExternAmountOut(\\n                              IConfigurableRightsPool(address(this)),\\n                              bPool,\\n                              tokenOut,\\n                              tokenAmountOut,\\n                              maxPoolAmountIn\\n                          );\\n\\n        poolAmountIn = amountIn;\\n        uint pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\\n\\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(pAiAfterExitFee);\\n        // _pushPoolShare(address(bFactory), exitFee);\\n        _pushPoolShare(exitFeeTo, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        // Update the running fraction of the pool attributable to accumulated fees\\n        uint fracPoolFeesTrade = bPool.calcFracPoolFeesFromPoolExit(tokenOut, tokenAmountOut);\\n        bPool.updateFracPoolFees(fracPoolFeesTrade);\\n        \\n        return poolAmountIn;\\n    }\\n\\n    /**\\n     * @notice Get the denormalized weight of a token\\n     * @dev viewlock to prevent calling if it's being updated\\n     * @return token weight\\n     */\\n    function getDenormalizedWeight(address token)\\n        external\\n        view\\n        viewlock\\n        needsBPool\\n        returns (uint)\\n    {\\n        return bPool.getDenormalizedWeight(token);\\n    }\\n\\n    // /**\\n    //  * @notice Getter for the RightsManager contract\\n    //  * @dev Convenience function to get the address of the RightsManager library (so clients can check version)\\n    //  * @return address of the RightsManager library\\n    // */\\n    // function getRightsManagerVersion() external pure returns (address) {\\n    //     return address(RightsManager);\\n    // }\\n\\n    /**\\n     * @notice Getter for the BalancerSafeMath contract\\n     * @dev Convenience function to get the address of the BalancerSafeMath library (so clients can check version)\\n     * @return address of the BalancerSafeMath library\\n    */\\n    function getBalancerSafeMathVersion() external pure returns (address) {\\n        return address(BalancerSafeMath);\\n    }\\n\\n    /**\\n     * @notice Getter for the SmartPoolManager contract\\n     * @dev Convenience function to get the address of the SmartPoolManager library (so clients can check version)\\n     * @return address of the SmartPoolManager library\\n    */\\n    function getSmartPoolManagerVersion() external pure returns (address) {\\n        return address(SmartPoolManager);\\n    }\\n\\n    // Public functions\\n\\n    // \\\"Public\\\" versions that can safely be called from SmartPoolManager\\n    // Allows only the contract itself to call them (not the controller or any external account)\\n\\n    function mintPoolShareFromLib(uint amount) public {\\n        require (msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _mint(amount);\\n    }\\n\\n    function pushPoolShareFromLib(address to, uint amount) public {\\n        require (msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _push(to, amount);\\n    }\\n\\n    function pullPoolShareFromLib(address from, uint amount) public  {\\n        require (msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _pull(from, amount);\\n    }\\n\\n    function burnPoolShareFromLib(uint amount) public  {\\n        require (msg.sender == address(this), \\\"ERR_NOT_CONTROLLER\\\");\\n\\n        _burn(amount);\\n    }\\n\\n    // Internal functions\\n\\n    // Lint wants the function to have a leading underscore too\\n    /* solhint-disable private-vars-leading-underscore */\\n\\n    /**\\n     * @notice Create a new Smart Pool\\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\\n     *      Can be changed if the canChangeSwapFee permission is enabled\\n     * @param initialSupply starting token balance\\n     */\\n    function createPoolInternal(uint initialSupply) internal {\\n        require(address(bPool) == address(0), \\\"ERR_IS_CREATED\\\");\\n        require(initialSupply >= BalancerConstants.MIN_POOL_SUPPLY, \\\"ERR_INIT_SUPPLY_MIN\\\");\\n        require(initialSupply <= BalancerConstants.MAX_POOL_SUPPLY, \\\"ERR_INIT_SUPPLY_MAX\\\");\\n\\n\\n        // There is technically reentrancy here, since we're making external calls and\\n        // then transferring tokens. However, the external calls are all to the underlying BPool\\n\\n        // To the extent possible, modify state variables before calling functions\\n        _mintPoolShare(initialSupply);\\n        _pushPoolShare(msg.sender, initialSupply);\\n\\n        // Deploy new BPool (bFactory and bPool are interfaces; all calls are external)\\n        bPool = bFactory.newBPool();\\n\\n        for (uint i = 0; i < _initialTokens.length; i++) {\\n            address t = _initialTokens[i];\\n            uint bal = _initialBalances[i];\\n            uint denorm = gradualUpdate.startWeights[i];\\n\\n            bool returnValue = IERC20(t).transferFrom(msg.sender, address(this), bal);\\n            require(returnValue, \\\"ERR_ERC20_FALSE\\\");\\n\\n            returnValue = IERC20(t).safeApprove(address(bPool), BalancerConstants.MAX_UINT);\\n            require(returnValue, \\\"ERR_ERC20_FALSE\\\");\\n\\n            bPool.bind(t, bal, denorm);\\n        }\\n\\n        while (_initialTokens.length > 0) {\\n            // Modifying state variable after external calls here,\\n            // but not essential, so not dangerous\\n            _initialTokens.pop();\\n        }\\n\\n        // Set fee to the initial value set in the constructor\\n        // Hereafter, read the swapFee from the underlying pool, not the local state variable\\n        bPool.setSwapFee(_initialSwapFee);\\n        bPool.setPublicSwap(true);\\n\\n        // \\\"destroy\\\" the temporary swap fee (like _initialTokens above) in case a subclass tries to use it\\n        _initialSwapFee = 0;\\n    }\\n\\n    /* solhint-enable private-vars-leading-underscore */\\n\\n    // Rebind BPool and pull tokens from address\\n    // bPool is a contract interface; function calls on it are external\\n    function _pullUnderlying(address erc20, address from, uint amount) internal needsBPool {\\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n        uint tokenBalance = bPool.getBalance(erc20);\\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\\n\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n        bPool.rebind(erc20, BalancerSafeMath.badd(tokenBalance, amount), tokenWeight);\\n    }\\n\\n    // Rebind BPool and push tokens to address\\n    // bPool is a contract interface; function calls on it are external\\n    function _pushUnderlying(address erc20, address to, uint amount) internal needsBPool {\\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\\n        uint tokenBalance = bPool.getBalance(erc20);\\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\\n        bPool.rebind(erc20, BalancerSafeMath.bsub(tokenBalance, amount), tokenWeight);\\n\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n\\n    /*\\n        Mint shares to pay off accumulated fees not paid to LPs\\n        Fees MUST be distributed when ANY of the following happen:\\n\\n        1. the weights change (since formula depends on weights)\\n        2. someone adds or removes liquidity from the pool (since this changes share supply)\\n        3. any of the upstream variables change:\\n            a. bPool._swapFee (maybe not needed, but included to be safe)\\n            b. fracFeePaidOut\\n            c. feeTo\\n\\n        Let \\n            G_{t1,t2} = the total accumulated fees between t1 and t2\\n            s_t = # of LP shares at time t\\n            sigma_t = # of LP shares issue to owner of fees not paid to LPs at distribution time t\\n            lambda = fraction of fees not paid to LPs\\n        \\n        Then\\n            s_t2 = s_t1 + sigma_t2\\n            lambda * G_{t1,t2} = sigma_t2 / s_t2 = sigma_t2 / (s_t1 + sigma_t2)\\n            sigma_t2 = ( lambda * G_{t1,t2} * s_t1 ) / ( 1 - lambda * G_{t1,t2} )\\n    */\\n    function _mintFee()\\n        internal\\n    {\\n        if (feeTo != address(0)) {\\n            if (fracFeePaidOut != 0) {\\n                uint fracPoolFees = bPool.getFracPoolFees();\\n                if (fracPoolFees != 0) {\\n                    uint pctPoolToPayOut = BalancerSafeMath.bmul(fracFeePaidOut, fracPoolFees); // gas savings\\n                    uint numerator = BalancerSafeMath.bmul(pctPoolToPayOut, varTotalSupply);\\n                    uint denominator = BalancerSafeMath.bsub(BalancerConstants.BONE, pctPoolToPayOut);\\n                    uint newShares = BalancerSafeMath.bdiv(numerator, denominator);\\n                    \\n                    if (newShares > 0) {\\n                        emit LogFeeMint(feeTo, newShares);\\n                        \\n                        // convert to payout tokens\\n                        if (payoutToken != address(0)) {\\n                            require(bPool.isBound(payoutToken), \\\"ERR_NOT_BOUND\\\");\\n\\n                            // function calcSingleOutGivenPoolIn(\\n                            //     uint tokenBalanceOut,\\n                            //     uint tokenWeightOut,\\n                            //     uint poolSupply,\\n                            //     uint totalWeight,\\n                            //     uint poolAmountIn,\\n                            //     uint swapFee,\\n                            //     uint exitFee\\n                            // )\\n                            uint tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\\n                                                bPool.getBalance(payoutToken),\\n                                                bPool.getDenormalizedWeight(payoutToken),\\n                                                this.totalSupply(),\\n                                                bPool.getTotalDenormalizedWeight(),\\n                                                newShares,\\n                                                0,      // Swap fee is 0 for fee payouts\\n                                                0       // Exit fee set to 0\\n                                            );\\n                            _pushUnderlying(payoutToken, feeTo, tokenAmountOut);\\n                        }\\n                        // If payoutToken not set, don't convert, just issue shares\\n                        // *** Make sure that feeTo can accept shares **\\n                        else {\\n                            _mintPoolShare(newShares);\\n                            _pushPoolShare(feeTo, newShares);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // Reset the fraction of pool attributable to fees\\n        // Do this every time to prevent weird overflow\\n        bPool.resetFracPoolFees();\\n    }\\n\\n    /*\\n        Manually trigger _mintFee\\n    */\\n    function mintFee()\\n        external\\n        lock\\n    {\\n        _mintFee();\\n    }\\n\\n    /**\\n     * @notice Set the the address that receives the fee not given to the LPs\\n     */\\n    function setFeeTo(address t)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n    {\\n        _mintFee();\\n        feeTo = t;\\n    }\\n\\n    /**\\n     * @notice Set the the address that receives exit fees\\n     */\\n    function setExitFeeTo(address t)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n    {\\n        exitFeeTo = t;\\n    }\\n\\n\\n    /**\\n     * @notice Set the the address that receives the fee not given to the LPs\\n     */\\n    function setFracFeePaidOut(uint frac)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n    {\\n        _mintFee();\\n        fracFeePaidOut = frac;\\n    }\\n\\n    /**\\n     * @notice Set the token that the paid out fee is converted to before payout\\n     * @dev Set to address(0) if we want to payout pool shares instead\\n     */\\n    function setPayoutToken(address erc20)\\n        external\\n        logs\\n        lock\\n        onlyOwner\\n        needsBPool\\n    {\\n        if (erc20 != address(0)) {\\n            require(bPool.isBound(erc20), \\\"ERR_NOT_BOUND\\\");\\n        }\\n        payoutToken = erc20;\\n    }\\n\\n\\n    // Wrappers around corresponding core functions\\n    function _mint(uint amount) internal override {\\n        super._mint(amount);\\n    }\\n\\n    function _mintPoolShare(uint amount) internal {\\n        _mint(amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount) internal {\\n        _push(to, amount);\\n    }\\n\\n    function _pullPoolShare(address from, uint amount) internal  {\\n        _pull(from, amount);\\n    }\\n\\n    function _burnPoolShare(uint amount) internal  {\\n        _burn(amount);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/IBFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\ninterface IBPool {\\n    function rebind(address token, uint balance, uint denorm) external;\\n    function setSwapFee(uint swapFee) external;\\n    function setPublicSwap(bool publicSwap) external;\\n    function bind(address token, uint balance, uint denorm) external;\\n    function unbind(address token) external;\\n    function gulp(address token) external;\\n    function isBound(address token) external view returns(bool);\\n    function getBalance(address token) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n    function getSwapFee() external view returns (uint);\\n    function getFracPoolFees() external view returns (uint);\\n    function calcFracPoolFeesFromSwap(address tokenIn, uint tokenAmountIn) external view returns (uint);\\n    function calcFracPoolFeesFromPoolJoin(address tokenIn, uint tokenAmountIn) external view returns (uint);\\n    function calcFracPoolFeesFromPoolExit(address tokenOut, uint tokenAmountOutAfterFees) external view returns (uint);\\n    function updateFracPoolFees(uint fracPoolFeesTrade) external;\\n    function resetFracPoolFees() external;\\n    function isPublicSwap() external view returns (bool);\\n    function getDenormalizedWeight(address token) external view returns (uint);\\n    function getTotalDenormalizedWeight() external view returns (uint);\\n    // solhint-disable-next-line func-name-mixedcase\\n    function EXIT_FEE() external view returns (uint);\\n    function getExitFee() external view returns (uint);\\n    function setExitFee(uint exitFee) external;\\n \\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        external pure\\n        returns (uint poolAmountOut);\\n\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee    )\\n        external pure\\n        returns (uint tokenAmountIn);\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee,\\n        uint exitFee\\n    )\\n        external pure\\n        returns (uint tokenAmountOut);\\n\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee,\\n        uint exitFee\\n    )\\n        external pure\\n        returns (uint poolAmountIn);\\n\\n    function getCurrentTokens()\\n        external view\\n        returns (address[] memory tokens);\\n}\\n\\ninterface IBFactory {\\n    function newBPool() external returns (IBPool);\\n    function setBLabs(address b) external;\\n    function collect(IBPool pool) external;\\n    function isBPool(address b) external view returns (bool);\\n    function getBLabs() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/Migrator.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: SEE LICENSE FILE\\npragma solidity 0.6.12;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./uniswapv2/interfaces/IUniswapIERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../libraries/BalancerConstants.sol\\\";\\nimport \\\"./CRPFactory.sol\\\";\\nimport \\\"./AlpacaToken.sol\\\";\\ninterface IMasterRancher {\\n\\n    function requestToMint(uint256 _amount) external returns (uint256 amount_minted);\\n\\n}\\n\\ncontract Migrator {\\n    using SafeMath for uint256;\\n    IMasterRancher public masterRancher;\\n    address public uniswapFactory; //\\n    address BFactoryAddress;\\n    address CRPFactoryAddress;\\n    uint256 public notBeforeBlock;\\n    uint256 public desiredLiquidity = uint256(-1);\\n    uint256 public totalWeth;\\n    uint256 public totalWethforShares;\\n    uint256 public pacaWethValueForShares;\\n    // address public wethAddr = address(\\n    //     0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n    // );\\n    address public wethAddr;\\n    address public pacaAddr;\\n    uint256 public initialTotalLPSupply;\\n    bool public setWethComplete;\\n    ConfigurableRightsPool.PoolParams public omniPoolParams;\\n    ConfigurableRightsPool public pacaOmniPool;\\n    RightsManager.Rights public permissions;\\n    CRPFactory crpFact;\\n    /// @notice each token's balance and weight\\n    struct tokenInfo {\\n        uint256 balance;\\n        uint256 wethValue;\\n        uint256 shares;\\n        bool exists;\\n    }\\n\\n    uint256 public totalTokens;\\n    /// @notice input into the final omniPool\\n    mapping(address => tokenInfo) public omniPool;\\n\\n    mapping(uint256 => address) public tokenHolder;\\n\\n    constructor(\\n        IMasterRancher _rancher,\\n        address _oldFactory,\\n        address _bFactory,\\n        address _crpFactory,\\n        address _weth,\\n        address _paca,\\n        uint256 _notBeforeBlock\\n    ) public {\\n        masterRancher = _rancher;\\n        uniswapFactory = _oldFactory;\\n        BFactoryAddress = _bFactory;\\n        notBeforeBlock = _notBeforeBlock;\\n        CRPFactoryAddress = _crpFactory;\\n        totalWeth = 0;\\n        totalTokens = 0;\\n        crpFact = CRPFactory(CRPFactoryAddress);\\n\\n        // set up WETH as base asset\\n        wethAddr = _weth;\\n        // set up PACA address\\n        pacaAddr = _paca;\\n        omniPool[wethAddr].exists = true;\\n        tokenHolder[totalTokens] = wethAddr;\\n        totalTokens++;\\n        setWethComplete = true;\\n\\n        permissions = RightsManager.Rights({\\n            canPauseSwapping: true,\\n            canChangeSwapFee: true,\\n            canChangeWeights: true,\\n            canAddRemoveTokens: true,\\n            canWhitelistLPs: false,\\n            canChangeCap: false\\n        });\\n\\n        omniPoolParams.poolTokenSymbol = \\\"ALP\\\";\\n        omniPoolParams.poolTokenName = \\\"AlpacaSwap Liquidity Pool Token\\\";\\n        //is this correct?\\n        //toWei(\\\"0.002\\\") = 0.2%\\n        //BONE is 1 WEI so 1/1000 = 0.001\\n        omniPoolParams.swapFee = (BalancerConstants.BONE / 1000) * 2;\\n    }\\n\\n    // Log the address of each new smart pool, and its creator\\n    event LogNewDomesticate(\\n        address indexed tokenAddress,\\n        uint256 indexed tokenAmount,\\n        uint256 indexed wethAmount\\n    );\\n\\n    event LogNewBalance(\\n        uint256 indexed wethBalance,\\n        uint256 indexed tokenBalance,\\n        uint256 indexed tokenWethValue\\n    );\\n\\n    event LogNewCrp(address indexed caller, address indexed pool);\\n\\n    // Unlike SushiSwap, for each pair we do:\\n    // Step 1: Retrieve the pair form the proper swap pool\\n    // Step 2: transfer tokens to pair and burn.\\n    // Step 3: track the relative weight. this is tricky.\\n    // After all pairs are burned we:\\n    // mint liquidity shares accordingly\\n    // we need to modify how each individual user's shares calculated from multiple _pid into one big pool\\n    // Create the ultimate omniswap pool\\n\\n    //note the actual contracts start with Uniswaps in poolInfo, during migration this is swapped out to be Sushi's\\n\\n    //do not create uniswap pair here as we are not depositing them into the same pair, we are creating an omnipool.\\n    //only supports whitelisted pairs currently. time to demosticate the wild stuff in other pools\\n    function domesticate(IUniswapV2Pair orig)\\n        public\\n        returns (\\n            bool result,\\n            uint256 index,\\n            uint256 legacyTotalsupply\\n        )\\n    {\\n        //note that sushi and uni have different underlaying impl for IUniswapV2Pair\\n        require(msg.sender == address(masterRancher), \\\"you are not the rancher\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n        require(orig.factory() == uniswapFactory, \\\"not from old factory\\\");\\n        require(setWethComplete, \\\"set weth address\\\");\\n        address token0 = orig.token0();\\n        address token1 = orig.token1();\\n        address otherTokenAddr;\\n        uint256 otherTokenAmount;\\n        uint256 wethAmount;\\n        uint256 lp = orig.balanceOf(msg.sender);\\n        uint256 current_index;\\n        AlpacaToken pacaToken;\\n        if (lp == 0) return (false, 0, 0);\\n\\n        if (token0 == wethAddr || token1 == wethAddr) {\\n            //migrator does not check whether the tokens are intended for the pool, its rancher's job\\n            //transfer to this contract first to lock in the balances\\n            //migrator needs to be approved first before sending\\n\\n            // Note: Uniswap has a balanced pool,\\n            // so the value of the non-WETH token in WETH is equal to the number of WETH\\n            orig.transferFrom(msg.sender, address(orig), lp);\\n            (uint256 amount0, uint256 amount1) = orig.burn(address(this));\\n            if (token0 == wethAddr) {\\n                otherTokenAddr = token1;\\n                otherTokenAmount = amount1;\\n                wethAmount = amount0;\\n                if (omniPool[token1].exists == false) {\\n                    tokenHolder[totalTokens] = token1;\\n                    current_index = totalTokens;\\n                    totalTokens++;\\n                    omniPool[token1].exists = true;\\n                }\\n            } else {\\n                otherTokenAddr = token0;\\n                otherTokenAmount = amount0;\\n                wethAmount = amount1;\\n                if (omniPool[token0].exists == false) {\\n                    tokenHolder[totalTokens] = token0;\\n                    current_index = totalTokens;\\n                    totalTokens++;\\n                    omniPool[token0].exists = true;\\n                }\\n            }\\n            tokenInfo storage wethToken = omniPool[wethAddr];\\n            tokenInfo storage otherToken = omniPool[otherTokenAddr];\\n            wethToken.balance = wethToken.balance.add(wethAmount);\\n            wethToken.wethValue = wethToken.wethValue.add(wethAmount);\\n            otherToken.balance = otherToken.balance.add(otherTokenAmount);\\n            otherToken.wethValue = otherToken.wethValue.add(wethAmount);\\n            // totalWethforShares = totalWeth = totalWeth.add(wethAmount).add(wethAmount);\\n            totalWethforShares = totalWethforShares.add(wethAmount).add(wethAmount);\\n            totalWeth = totalWeth.add(wethAmount).add(wethAmount);\\n\\n            // B O N U S  P A C A\\n            // a special treat for the ranch hands\\n            if (token0 == pacaAddr || token1 == pacaAddr) {\\n                //during migration, we are inflating the total supply of PACA by 50% and adding it to the pool\\n                pacaToken = AlpacaToken((token0 == pacaAddr ? token0 : token1));\\n                uint256 amountToInflate = pacaToken.totalSupply().div(2);\\n                //request MasterRancher to mint the tokens and assign to migrator.\\n                uint256 pacaInflated = masterRancher.requestToMint(amountToInflate);\\n                require(pacaInflated == amountToInflate, \\\"rancher has gone insane\\\");\\n                uint256 additionalPACAWethValue = pacaInflated.mul(wethAmount).div(otherTokenAmount);\\n                otherToken.balance = otherToken.balance.add(pacaInflated);\\n                pacaWethValueForShares = otherToken.wethValue;\\n                otherToken.wethValue = otherToken.wethValue.add(additionalPACAWethValue);\\n                //we are not modifying totalWethforShares because the inflated PACAs are implicitly owned by everyone\\n                totalWeth = totalWeth.add(additionalPACAWethValue);\\n            }\\n\\n            emit LogNewDomesticate(\\n                otherTokenAddr,\\n                otherTokenAmount,\\n                wethAmount\\n            );\\n            emit LogNewBalance(\\n                wethToken.balance,\\n                otherToken.balance,\\n                otherToken.wethValue\\n            );\\n\\n            return (true, current_index, lp);\\n        }\\n        return (false, 0, 0);\\n\\n    }\\n\\n    // Only Alpacas are allowed on the ranch\\n    // Liquidate unsupported tokens for WETH and give it to the ranch,\\n    // where it will be owned equally by the ranch hands\\n    // Intended mostly for UNI earned by LP tokens deposited in MasterRancher\\n    // Inspired by SushiMaker\\n    function liquidateNonalpaca(address token) public {\\n        // get pair\\n        IUniswapV2Pair pair = IUniswapV2Pair(IUniswapV2Factory(uniswapFactory).getPair(token, wethAddr));\\n        if (address(pair) == address(0)) {\\n            return;\\n        }\\n\\n        // calculate amounts in and out\\n        (uint reserve0, uint reserve1,) = pair.getReserves();\\n        address token0 = pair.token0();\\n        (uint reserveIn, uint reserveOut) = token0 == token ? (reserve0, reserve1) : (reserve1, reserve0);\\n        uint amountIn = IERC20(token).balanceOf(address(this));\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        uint amountOut = numerator / denominator;\\n\\n        // execute swap\\n        (uint amount0Out, uint amount1Out) = token0 == token ? (uint(0), amountOut) : (amountOut, uint(0));\\n        IERC20(token).transfer(address(pair), amountIn);\\n        pair.swap(amount0Out, amount1Out, address(this), new bytes(0));\\n\\n        // we are not modifying totalWethforShares because the WETH acquired\\n        // from liquidating non-alpacas is implicitly owned by everyone\\n        totalWeth = totalWeth.add(amountOut);\\n    }\\n\\n    function retrieveShares(uint256 index) external view returns (uint256 shares) {\\n        require(omniPool[tokenHolder[index]].exists, \\\"invalid index\\\");\\n        return omniPool[tokenHolder[index]].shares;\\n    }\\n\\n    /*\\n    1. calculate weights\\n    2. add in PACAs\\n    3. create omniPool\\n    4. start Pool\\n    */\\n    function establishTokenSetting() external {\\n        require(msg.sender == address(masterRancher), \\\"you are not the rancher\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n        uint256 currentWeight = 0;\\n\\n        tokenInfo storage token;\\n        initialTotalLPSupply = totalWethforShares < BalancerConstants.MIN_POOL_SUPPLY\\n            ? BalancerConstants.MIN_POOL_SUPPLY\\n            : totalWethforShares;\\n\\n        for (uint256 i = 0; i < totalTokens; i++) {\\n            token = omniPool[tokenHolder[i]];\\n            if (token.exists == false) continue;\\n\\n            //note that these division will floor, but it doesn't matter much.\\n            omniPoolParams.constituentTokens.push(tokenHolder[i]);\\n            omniPoolParams.tokenBalances.push(token.balance);\\n            currentWeight = (\\n                    token.wethValue.mul(BalancerConstants.MAX_WEIGHT)\\n                ).div(totalWeth);\\n            omniPoolParams.tokenWeights.push(currentWeight);\\n\\n            // there will be minor slippage since we don't know if rounding is happening but should be very minor\\n            if (tokenHolder[i] != wethAddr)\\n            if(tokenHolder[i] == pacaAddr)\\n            {\\n            token.shares = (\\n                    (pacaWethValueForShares.mul(initialTotalLPSupply)).mul(2)\\n                ).div(totalWethforShares);\\n            }\\n            else\\n            {\\n            token.shares = (\\n                    (token.wethValue.mul(initialTotalLPSupply)).mul(2)\\n                ).div(totalWethforShares);\\n            }\\n\\n            require(\\n                currentWeight >= BalancerConstants.MIN_WEIGHT,\\n                \\\"do you math?\\\"\\n            );\\n        }\\n    }\\n\\n    function establishRanch() external returns (IERC20 alp) {\\n        require(msg.sender == address(masterRancher), \\\"you are not the rancher\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n        tokenInfo storage token;\\n\\n        pacaOmniPool = crpFact.newCrp(\\n            BFactoryAddress,\\n            omniPoolParams,\\n            permissions\\n        );\\n\\n        //approve all assets:\\n        for (uint256 i = 0; i < totalTokens; i++) {\\n            token = omniPool[tokenHolder[i]];\\n            if (token.exists == false) continue;\\n            //this will work because the amount of ERC20 does not change after we burn the LP in domesticate\\n            IERC20Uniswap(tokenHolder[i]).approve(\\n                address(pacaOmniPool),\\n                token.balance\\n            );\\n        }\\n\\n        return pacaOmniPool;\\n    }\\n\\n    function startRanch(\\n        address _feeTo,\\n        uint256 _feeToPct,\\n        address _exitFeeTo,\\n        uint256 _exitFee,\\n        address _payOutToken,\\n        address _controller\\n    ) external {\\n        require(msg.sender == address(masterRancher), \\\"you are not the rancher\\\");\\n        require(block.number >= notBeforeBlock, \\\"too early to migrate\\\");\\n\\n        pacaOmniPool.createPool(initialTotalLPSupply);\\n        pacaOmniPool.approve(address(masterRancher), initialTotalLPSupply);\\n        pacaOmniPool.transfer(address(masterRancher), initialTotalLPSupply);\\n\\n        pacaOmniPool.setFeeTo(_feeTo);\\n        pacaOmniPool.setFracFeePaidOut(_feeToPct);\\n        pacaOmniPool.setPayoutToken(_payOutToken);\\n        pacaOmniPool.setExitFee(_exitFee);\\n        pacaOmniPool.setExitFeeTo(_exitFeeTo);\\n        pacaOmniPool.setController(_controller);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/PCToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Imports\\n\\nimport \\\"../libraries/BalancerSafeMath.sol\\\";\\nimport \\\"../libraries/BalancerConstants.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// Contracts\\n\\n/* solhint-disable func-order */\\n\\n/**\\n * @author Balancer Labs\\n * @title Highly opinionated token implementation\\n*/\\ncontract PCToken is IERC20 {\\n    using BalancerSafeMath for uint;\\n\\n    // State variables\\n    string public constant NAME = \\\"AlpacaSwap OmniPool\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    // No leading underscore per naming convention (non-private)\\n    // Cannot call totalSupply (name conflict)\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    uint internal varTotalSupply;\\n\\n    mapping(address => uint) private _balance;\\n    mapping(address => mapping(address => uint)) private _allowance;\\n\\n    string private _symbol;\\n    string private _name;\\n\\n    // Event declarations\\n\\n    // See definitions above; must be redeclared to be emitted from this contract\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    // Function declarations\\n\\n    /**\\n     * @notice Base token constructor\\n     * @param tokenSymbol - the token symbol\\n     */\\n    constructor (string memory tokenSymbol, string memory tokenName) public {\\n        _symbol = tokenSymbol;\\n        _name = tokenName;\\n    }\\n\\n    // External functions\\n\\n    /**\\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\\n     * @param owner - owner of the tokens\\n     * @param spender - entity allowed to spend the tokens\\n     * @return uint - remaining amount spender is allowed to transfer\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Getter for current account balance\\n     * @param account - address we're checking the balance of\\n     * @return uint - token balance in the account\\n     */\\n    function balanceOf(address account) external view override returns (uint) {\\n        return _balance[account];\\n    }\\n\\n    /**\\n     * @notice Approve owner (sender) to spend a certain amount\\n     * @dev emits an Approval event\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        /* In addition to the increase/decreaseApproval functions, could\\n           avoid the \\\"approval race condition\\\" by only allowing calls to approve\\n           when the current approval amount is 0\\n        \\n           require(_allowance[msg.sender][spender] == 0, \\\"ERR_RACE_CONDITION\\\");\\n\\n           Some token contracts (e.g., KNC), already revert if you call approve \\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\\n           and safeApprove function when adding tokens to the pool.\\n        */\\n\\n        _allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\\n     * @dev emits an Approval event\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function increaseApproval(address spender, uint amount) external returns (bool) {\\n        _allowance[msg.sender][spender] = BalancerSafeMath.badd(_allowance[msg.sender][spender], amount);\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\\n     * @dev emits an Approval event\\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     * @return bool - result of the approval (will always be true if it doesn't revert)\\n     */\\n    function decreaseApproval(address spender, uint amount) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][spender];\\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\\n        if (amount >= oldValue) {\\n            _allowance[msg.sender][spender] = 0;\\n        } else {\\n            _allowance[msg.sender][spender] = BalancerSafeMath.bsub(oldValue, amount);\\n        }\\n\\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer the given amount from sender (caller) to recipient\\n     * @dev _move emits a Transfer event if successful\\n     * @param recipient - entity receiving the tokens\\n     * @param amount - number of tokens being transferred\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\n     */\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n\\n        _move(msg.sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer the given amount from sender to recipient\\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\\n     * @param recipient - recipient of the tokens\\n     * @param amount - number of tokens being transferred\\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\\n     */\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\n        require(recipient != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \\\"ERR_PCTOKEN_BAD_CALLER\\\");\\n\\n        _move(sender, recipient, amount);\\n\\n        // memoize for gas optimization\\n        uint oldAllowance = _allowance[sender][msg.sender];\\n\\n        // If the sender is not the caller, adjust the allowance by the amount transferred\\n        if (msg.sender != sender && oldAllowance != uint(-1)) {\\n            _allowance[sender][msg.sender] = BalancerSafeMath.bsub(oldAllowance, amount);\\n\\n            emit Approval(msg.sender, recipient, _allowance[sender][msg.sender]);\\n        }\\n\\n        return true;\\n    }\\n\\n    // public functions\\n\\n    /**\\n     * @notice Getter for the total supply\\n     * @dev declared external for gas optimization\\n     * @return uint - total number of tokens in existence\\n     */\\n    function totalSupply() external view override returns (uint) {\\n        return varTotalSupply;\\n    }\\n\\n    // Public functions\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     *      We allow the user to set this name (as well as the symbol).\\n     *      Alternatives are 1) A fixed string (original design)\\n     *                       2) A fixed string plus the user-defined symbol\\n     *                          return string(abi.encodePacked(NAME, \\\"-\\\", _symbol));\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external pure returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // internal functions\\n\\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\\n    // Emit a transfer amount from the null address to this contract\\n    function _mint(uint amount) internal virtual {\\n        _balance[address(this)] = BalancerSafeMath.badd(_balance[address(this)], amount);\\n        varTotalSupply = BalancerSafeMath.badd(varTotalSupply, amount);\\n\\n        emit Transfer(address(0), address(this), amount);\\n    }\\n\\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\\n    // Emit a transfer amount from this contract to the null address\\n    function _burn(uint amount) internal virtual {\\n        // Can't burn more than we have\\n        // Remove require for gas optimization - bsub will revert on underflow\\n        // require(_balance[address(this)] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n\\n        _balance[address(this)] = BalancerSafeMath.bsub(_balance[address(this)], amount);\\n        varTotalSupply = BalancerSafeMath.bsub(varTotalSupply, amount);\\n\\n        emit Transfer(address(this), address(0), amount);\\n    }\\n\\n    // Transfer tokens from sender to recipient\\n    // Adjust balances, and emit a Transfer event\\n    function _move(address sender, address recipient, uint amount) internal virtual {\\n        // Can't send more than sender has\\n        // Remove require for gas optimization - bsub will revert on underflow\\n        // require(_balance[sender] >= amount, \\\"ERR_INSUFFICIENT_BAL\\\");\\n\\n        _balance[sender] = BalancerSafeMath.bsub(_balance[sender], amount);\\n        _balance[recipient] = BalancerSafeMath.badd(_balance[recipient], amount);\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // Transfer from this contract to recipient\\n    // Emits a transfer event if successful\\n    function _push(address recipient, uint amount) internal {\\n        _move(address(this), recipient, amount);\\n    }\\n\\n    // Transfer from recipient to this contract\\n    // Emits a transfer event if successful\\n    function _pull(address sender, uint amount) internal {\\n        _move(sender, address(this), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/uniswapv2/interfaces/IUniswapIERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: SEE LICENSE FILE\\npragma solidity >=0.5.0;\\n\\ninterface IERC20Uniswap {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: SEE LICENSE FILE\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: SEE LICENSE FILE\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/utils/BalancerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract BalancerOwnable {\\n    // State variables\\n\\n    address private _owner;\\n\\n    // Event declarations\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    // Modifiers\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"ERR_NOT_CONTROLLER\\\");\\n        _;\\n    }\\n\\n    // Function declarations\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     *         Can only be called by the current owner\\n     * @dev external for gas optimization\\n     * @param newOwner - address of new owner\\n     */\\n    function setController(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"ERR_ZERO_ADDRESS\\\");\\n\\n        emit OwnershipTransferred(_owner, newOwner);\\n\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner\\n     * @dev external for gas optimization\\n     * @return address - of the owner (AKA controller)\\n     */\\n    function getController() external view returns (address) {\\n        return _owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/contracts/utils/BalancerReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @author Balancer Labs (and OpenZeppelin)\\n * @title Protect against reentrant calls (and also selectively protect view functions)\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {_lock_} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `_lock_` guard, functions marked as\\n * `_lock_` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `_lock_` entry\\n * points to them.\\n *\\n * Also adds a _lockview_ modifier, which doesn't create a lock, but fails\\n *   if another _lock_ call is in progress\\n */\\ncontract BalancerReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint private constant _NOT_ENTERED = 1;\\n    uint private constant _ENTERED = 2;\\n\\n    uint private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `_lock_` function from another `_lock_`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `_lock_` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier lock() {\\n        // On the first call to _lock_, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ERR_REENTRY\\\");\\n\\n        // Any calls to _lock_ after this point will fail\\n        _status = _ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Also add a modifier that doesn't create a lock, but protects functions that\\n     *      should not be called while a _lock_ function is running\\n     */\\n     modifier viewlock() {\\n        require(_status != _ENTERED, \\\"ERR_REENTRY_VIEW\\\");\\n        _;\\n     }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/interfaces/IConfigurableRightsPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Interface declarations\\n\\n// Introduce to avoid circularity (otherwise, the CRP and SmartPoolManager include each other)\\n// Removing circularity allows flattener tools to work, which enables Etherscan verification\\ninterface IConfigurableRightsPool {\\n    function mintPoolShareFromLib(uint amount) external;\\n    function pushPoolShareFromLib(address to, uint amount) external;\\n    function pullPoolShareFromLib(address from, uint amount) external;\\n    function burnPoolShareFromLib(uint amount) external;\\n    function totalSupply() external view returns (uint);\\n    function getController() external view returns (address);\\n}\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/BalancerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @author Balancer Labs\\n * @title Put all the constants in one place\\n */\\n\\nlibrary BalancerConstants {\\n    // State variables (must be constant in a library)\\n    // Note: any changes need to also be reflected in BConst.sol\\n\\n    // B \\\"ONE\\\" - all math is in the \\\"realm\\\" of 10 ** 18;\\n    // where numeric 1 = 10 ** 18\\n    uint public constant BONE = 10**18;\\n    uint public constant MIN_WEIGHT = BONE;                 // Future: make configurable to allow more weight granularity\\n    uint public constant MAX_WEIGHT = BONE * 1000;          // Future: make configurable to allow more weight granularity\\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 1000;    // Future: make configurable to allow more weight granularity\\n    uint public constant MIN_BALANCE = BONE / 10**6;\\n    uint public constant MAX_BALANCE = BONE * 10**12;\\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\\n    uint public constant MIN_FEE = BONE / 10**6;\\n    uint public constant MAX_FEE = BONE / 10;\\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n    // uint public constant EXIT_FEE = 0;                   // moved to configurable param\\n    uint public constant MAX_IN_RATIO = BONE / 2;\\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\\n    uint public constant MIN_ASSET_LIMIT = 2;\\n    // uint public constant MAX_ASSET_LIMIT = 8;            // not included - determined implicitly by governance\\n    uint public constant MAX_UINT = uint(-1);\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/BalancerSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n\\n// Imports\\n\\nimport \\\"./BalancerConstants.sol\\\";\\n\\n/**\\n * @author Balancer Labs\\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\\n */\\nlibrary BalancerSafeMath {\\n    /**\\n     * @notice Safe addition\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev if we are adding b to a, the resulting sum must be greater than a\\n     * @return - sum of operands; throws if overflow\\n     */\\n    function badd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction, and check that it produces a positive value\\n     *      (i.e., a - b is valid if b <= a)\\n     * @return - a - b; throws if underflow\\n     */\\n    function bsub(uint a, uint b) internal pure returns (uint) {\\n        (uint c, bool negativeResult) = bsubSign(a, b);\\n        require(!negativeResult, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe signed subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction\\n     * @return - difference between a and b, and a flag indicating a negative result\\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\\n     */\\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\n        if (b <= a) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Safe multiplication\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Multiply safely (and efficiently), rounding down\\n     * @return - product of operands; throws if overflow or rounding error\\n     */\\n    function bmul(uint a, uint b) internal pure returns (uint) {\\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // Standard overflow check: a/a*b=b\\n        uint c0 = a * b;\\n        require(c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n\\n        // Round to 0 if x*y < BONE/2?\\n        uint c1 = c0 + (BalancerConstants.BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BalancerConstants.BONE;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe division\\n     * @param dividend - first operand\\n     * @param divisor - second operand\\n     * @dev Divide safely (and efficiently), rounding down\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_DIV_ZERO\\\");\\n\\n        // Gas optimization\\n        if (dividend == 0){\\n            return 0;\\n        }\\n\\n        uint c0 = dividend * BalancerConstants.BONE;\\n        require(c0 / dividend == BalancerConstants.BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n\\n        uint c1 = c0 + (divisor / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n\\n        uint c2 = c1 / divisor;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer modulo\\n     * @dev Returns the remainder of dividing two unsigned integers.\\n     *      Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * @param dividend - first operand\\n     * @param divisor - second operand -- cannot be zero\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_MODULO_BY_ZERO\\\");\\n\\n        return dividend % divisor;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer max\\n     * @dev Returns the greater of the two input values\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the maximum of a and b\\n     */\\n    function bmax(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer min\\n     * @dev returns b, if b < a; otherwise returns a\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the lesser of the two input values\\n     */\\n    function bmin(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer average\\n     * @dev Guard against (a+b) overflow by dividing each operand separately\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the average of the two values\\n     */\\n    function baverage(uint a, uint b) internal pure returns (uint) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n\\n    /**\\n     * @notice Babylonian square root implementation\\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n     * @param y - operand\\n     * @return z - the square root result\\n     */\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        }\\n        else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/RightsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Needed to handle structures externally\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @author Balancer Labs\\n * @title Manage Configurable Rights for the smart pool\\n *      canPauseSwapping - can setPublicSwap back to false after turning it on\\n *                         by default, it is off on initialization and can only be turned on\\n *      canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\\n *      canChangeWeights - can bind new token weights (allowed by default in base pool)\\n *      canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\\n *      canWhitelistLPs - can limit liquidity providers to a given set of addresses\\n *      canChangeCap - can change the BSP cap (max # of pool tokens)\\n */\\nlibrary RightsManager {\\n\\n    // Type declarations\\n\\n    enum Permissions { PAUSE_SWAPPING,\\n                       CHANGE_SWAP_FEE,\\n                       CHANGE_WEIGHTS,\\n                       ADD_REMOVE_TOKENS,\\n                       WHITELIST_LPS,\\n                       CHANGE_CAP }\\n\\n    struct Rights {\\n        bool canPauseSwapping;\\n        bool canChangeSwapFee;\\n        bool canChangeWeights;\\n        bool canAddRemoveTokens;\\n        bool canWhitelistLPs;\\n        bool canChangeCap;\\n    }\\n\\n    // State variables (can only be constants in a library)\\n    bool public constant DEFAULT_CAN_PAUSE_SWAPPING = false;\\n    bool public constant DEFAULT_CAN_CHANGE_SWAP_FEE = true;\\n    bool public constant DEFAULT_CAN_CHANGE_WEIGHTS = true;\\n    bool public constant DEFAULT_CAN_ADD_REMOVE_TOKENS = false;\\n    bool public constant DEFAULT_CAN_WHITELIST_LPS = false;\\n    bool public constant DEFAULT_CAN_CHANGE_CAP = false;\\n\\n    // Functions\\n\\n    /**\\n     * @notice create a struct from an array (or return defaults)\\n     * @dev If you pass an empty array, it will construct it using the defaults\\n     * @param a - array input\\n     * @return Rights struct\\n     */ \\n    function constructRights(bool[] calldata a) external pure returns (Rights memory) {\\n        if (a.length == 0) {\\n            return Rights(DEFAULT_CAN_PAUSE_SWAPPING,\\n                          DEFAULT_CAN_CHANGE_SWAP_FEE,\\n                          DEFAULT_CAN_CHANGE_WEIGHTS,\\n                          DEFAULT_CAN_ADD_REMOVE_TOKENS,\\n                          DEFAULT_CAN_WHITELIST_LPS,\\n                          DEFAULT_CAN_CHANGE_CAP);\\n        }\\n        else {\\n            return Rights(a[0], a[1], a[2], a[3], a[4], a[5]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Convert rights struct to an array (e.g., for events, GUI)\\n     * @dev avoids multiple calls to hasPermission\\n     * @param rights - the rights struct to convert\\n     * @return boolean array containing the rights settings\\n     */\\n    function convertRights(Rights calldata rights) external pure returns (bool[] memory) {\\n        bool[] memory result = new bool[](6);\\n\\n        result[0] = rights.canPauseSwapping;\\n        result[1] = rights.canChangeSwapFee;\\n        result[2] = rights.canChangeWeights;\\n        result[3] = rights.canAddRemoveTokens;\\n        result[4] = rights.canWhitelistLPs;\\n        result[5] = rights.canChangeCap;\\n\\n        return result;\\n    }\\n\\n    // Though it is actually simple, the number of branches triggers code-complexity\\n    /* solhint-disable code-complexity */\\n\\n    /**\\n     * @notice Externally check permissions using the Enum\\n     * @param self - Rights struct containing the permissions\\n     * @param permission - The permission to check\\n     * @return Boolean true if it has the permission\\n     */\\n    function hasPermission(Rights calldata self, Permissions permission) external pure returns (bool) {\\n        if (Permissions.PAUSE_SWAPPING == permission) {\\n            return self.canPauseSwapping;\\n        }\\n        else if (Permissions.CHANGE_SWAP_FEE == permission) {\\n            return self.canChangeSwapFee;\\n        }\\n        else if (Permissions.CHANGE_WEIGHTS == permission) {\\n            return self.canChangeWeights;\\n        }\\n        else if (Permissions.ADD_REMOVE_TOKENS == permission) {\\n            return self.canAddRemoveTokens;\\n        }\\n        else if (Permissions.WHITELIST_LPS == permission) {\\n            return self.canWhitelistLPs;\\n        }\\n        else if (Permissions.CHANGE_CAP == permission) {\\n            return self.canChangeCap;\\n        }\\n    }\\n\\n    /* solhint-enable code-complexity */\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/SafeApprove.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Imports\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// Libraries\\n\\n/**\\n * @author PieDAO (ported to Balancer Labs)\\n * @title SafeApprove - set approval for tokens that require 0 prior approval\\n * @dev Perhaps to address the known ERC20 race condition issue\\n *      See https://github.com/crytic/not-so-smart-contracts/tree/master/race_condition\\n *      Some tokens - notably KNC - only allow approvals to be increased from 0\\n */\\nlibrary SafeApprove {\\n    /**\\n     * @notice handle approvals of tokens that require approving from a base of 0\\n     * @param token - the token we're approving\\n     * @param spender - entity the owner (sender) is approving to spend his tokens\\n     * @param amount - number of tokens being approved\\n     */\\n    function safeApprove(IERC20 token, address spender, uint amount) internal returns (bool) {\\n        uint currentAllowance = token.allowance(address(this), spender);\\n\\n        // Do nothing if allowance is already set to this value\\n        if(currentAllowance == amount) {\\n            return true;\\n        }\\n\\n        // If approval is not zero reset it to zero first\\n        if(currentAllowance != 0) {\\n            return token.approve(spender, 0);\\n        }\\n\\n        // do the actual approval\\n        return token.approve(spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/bob/Projects/alpaca_doomsday/alpaca-core/libraries/SmartPoolManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Needed to pass in structs\\npragma experimental ABIEncoderV2;\\n\\n// Imports\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interfaces/IConfigurableRightsPool.sol\\\";\\nimport \\\"../contracts/IBFactory.sol\\\";\\nimport \\\"./BalancerConstants.sol\\\";\\nimport \\\"./BalancerSafeMath.sol\\\";\\nimport \\\"./SafeApprove.sol\\\";\\n\\n\\n/**\\n * @author Balancer Labs\\n * @title Factor out the weight updates\\n */\\nlibrary SmartPoolManager {\\n    // Type declarations\\n\\n    struct NewTokenParams {\\n        address addr;\\n        bool isCommitted;\\n        uint commitBlock;\\n        uint denorm;\\n        uint balance;\\n    }\\n\\n    // For blockwise, automated weight updates\\n    // Move weights linearly from startWeights to endWeights,\\n    // between startBlock and endBlock\\n    struct GradualUpdateParams {\\n        uint startBlock;\\n        uint endBlock;\\n        uint[] startWeights;\\n        uint[] endWeights;\\n    }\\n\\n    // updateWeight and pokeWeights are unavoidably long\\n    /* solhint-disable function-max-lines */\\n\\n    /**\\n     * @notice Update the weight of an existing token\\n     * @dev Refactored to library to make CRPFactory deployable\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param token - token to be reweighted\\n     * @param newWeight - new weight of the token\\n    */\\n    function updateWeight(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address token,\\n        uint newWeight\\n    )\\n        external\\n    {\\n        require(newWeight >= BalancerConstants.MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(newWeight <= BalancerConstants.MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n\\n        uint currentWeight = bPool.getDenormalizedWeight(token);\\n        // Save gas; return immediately on NOOP\\n        if (currentWeight == newWeight) {\\n             return;\\n        }\\n\\n        uint currentBalance = bPool.getBalance(token);\\n        uint totalSupply = self.totalSupply();\\n        uint totalWeight = bPool.getTotalDenormalizedWeight();\\n        uint poolShares;\\n        uint deltaBalance;\\n        uint deltaWeight;\\n        uint newBalance;\\n\\n        if (newWeight < currentWeight) {\\n            // This means the controller will withdraw tokens to keep price\\n            // So they need to redeem PCTokens\\n            deltaWeight = BalancerSafeMath.bsub(currentWeight, newWeight);\\n\\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\\n            poolShares = BalancerSafeMath.bmul(totalSupply,\\n                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\\n\\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\\n            deltaBalance = BalancerSafeMath.bmul(currentBalance,\\n                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\\n\\n            // New balance cannot be lower than MIN_BALANCE\\n            newBalance = BalancerSafeMath.bsub(currentBalance, deltaBalance);\\n\\n            require(newBalance >= BalancerConstants.MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n            // First get the tokens from this contract (Pool Controller) to msg.sender\\n            bPool.rebind(token, newBalance, newWeight);\\n\\n            // Now with the tokens this contract can send them to msg.sender\\n            bool xfer = IERC20(token).transfer(msg.sender, deltaBalance);\\n            require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n\\n            self.pullPoolShareFromLib(msg.sender, poolShares);\\n            self.burnPoolShareFromLib(poolShares);\\n        }\\n        else {\\n            // This means the controller will deposit tokens to keep the price.\\n            // They will be minted and given PCTokens\\n            deltaWeight = BalancerSafeMath.bsub(newWeight, currentWeight);\\n\\n            require(BalancerSafeMath.badd(totalWeight, deltaWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\\n                    \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n\\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\\n            poolShares = BalancerSafeMath.bmul(totalSupply,\\n                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\\n            deltaBalance = BalancerSafeMath.bmul(currentBalance,\\n                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\\n\\n            // First gets the tokens from msg.sender to this contract (Pool Controller)\\n            bool xfer = IERC20(token).transferFrom(msg.sender, address(this), deltaBalance);\\n            require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n\\n            // Now with the tokens this contract can bind them to the pool it controls\\n            bPool.rebind(token, BalancerSafeMath.badd(currentBalance, deltaBalance), newWeight);\\n\\n            self.mintPoolShareFromLib(poolShares);\\n            self.pushPoolShareFromLib(msg.sender, poolShares);\\n        }\\n    }\\n\\n    /**\\n     * @notice External function called to make the contract update weights according to plan\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param gradualUpdate - gradual update parameters from the CRP\\n    */\\n    function pokeWeights(\\n        IBPool bPool,\\n        GradualUpdateParams storage gradualUpdate\\n    )\\n        external\\n    {\\n        // Do nothing if we call this when there is no update plan\\n        if (gradualUpdate.startBlock == 0) {\\n            return;\\n        }\\n\\n        // Error to call it before the start of the plan\\n        require(block.number >= gradualUpdate.startBlock, \\\"ERR_CANT_POKE_YET\\\");\\n        // Proposed error message improvement\\n        // require(block.number >= startBlock, \\\"ERR_NO_HOKEY_POKEY\\\");\\n\\n        // This allows for pokes after endBlock that get weights to endWeights\\n        // Get the current block (or the endBlock, if we're already past the end)\\n        uint currentBlock;\\n        if (block.number > gradualUpdate.endBlock) {\\n            currentBlock = gradualUpdate.endBlock;\\n        }\\n        else {\\n            currentBlock = block.number;\\n        }\\n\\n        uint blockPeriod = BalancerSafeMath.bsub(gradualUpdate.endBlock, gradualUpdate.startBlock);\\n        uint blocksElapsed = BalancerSafeMath.bsub(currentBlock, gradualUpdate.startBlock);\\n        uint weightDelta;\\n        uint deltaPerBlock;\\n        uint newWeight;\\n\\n        address[] memory tokens = bPool.getCurrentTokens();\\n\\n        // This loop contains external calls\\n        // External calls are to math libraries or the underlying pool, so low risk\\n        for (uint i = 0; i < tokens.length; i++) {\\n            // Make sure it does nothing if the new and old weights are the same (saves gas)\\n            // It's a degenerate case if they're *all* the same, but you certainly could have\\n            // a plan where you only change some of the weights in the set\\n            if (gradualUpdate.startWeights[i] != gradualUpdate.endWeights[i]) {\\n                if (gradualUpdate.endWeights[i] < gradualUpdate.startWeights[i]) {\\n                    // We are decreasing the weight\\n\\n                    // First get the total weight delta\\n                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\\n                                                        gradualUpdate.endWeights[i]);\\n                    // And the amount it should change per block = total change/number of blocks in the period\\n                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\\n\\n                     // newWeight = startWeight - (blocksElapsed * deltaPerBlock)\\n                    newWeight = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\\n                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\\n                }\\n                else {\\n                    // We are increasing the weight\\n\\n                    // First get the total weight delta\\n                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.endWeights[i],\\n                                                        gradualUpdate.startWeights[i]);\\n                    // And the amount it should change per block = total change/number of blocks in the period\\n                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\\n\\n                     // newWeight = startWeight + (blocksElapsed * deltaPerBlock)\\n                    newWeight = BalancerSafeMath.badd(gradualUpdate.startWeights[i],\\n                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\\n                }\\n\\n                uint bal = bPool.getBalance(tokens[i]);\\n\\n                bPool.rebind(tokens[i], bal, newWeight);\\n            }\\n        }\\n\\n        // Reset to allow add/remove tokens, or manual weight updates\\n        if (block.number >= gradualUpdate.endBlock) {\\n            gradualUpdate.startBlock = 0;\\n        }\\n    }\\n\\n    /* solhint-enable function-max-lines */\\n\\n    /**\\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\\n     *         number of blocks to actually add the token\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param token - the token to be added\\n     * @param balance - how much to be added\\n     * @param denormalizedWeight - the desired token weight\\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\\n     */\\n    function commitAddToken(\\n        IBPool bPool,\\n        address token,\\n        uint balance,\\n        uint denormalizedWeight,\\n        NewTokenParams storage newToken\\n    )\\n        external\\n    {\\n        require(!bPool.isBound(token), \\\"ERR_IS_BOUND\\\");\\n\\n        require(denormalizedWeight <= BalancerConstants.MAX_WEIGHT, \\\"ERR_WEIGHT_ABOVE_MAX\\\");\\n        require(denormalizedWeight >= BalancerConstants.MIN_WEIGHT, \\\"ERR_WEIGHT_BELOW_MIN\\\");\\n        require(BalancerSafeMath.badd(bPool.getTotalDenormalizedWeight(),\\n                                      denormalizedWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\\n                \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        require(balance >= BalancerConstants.MIN_BALANCE, \\\"ERR_BALANCE_BELOW_MIN\\\");\\n\\n        newToken.addr = token;\\n        newToken.balance = balance;\\n        newToken.denorm = denormalizedWeight;\\n        newToken.commitBlock = block.number;\\n        newToken.isCommitted = true;\\n    }\\n\\n    /**\\n     * @notice Add the token previously committed (in commitAddToken) to the pool\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param addTokenTimeLockInBlocks -  Wait time between committing and applying a new token\\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\\n     */\\n    function applyAddToken(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        uint addTokenTimeLockInBlocks,\\n        NewTokenParams storage newToken\\n    )\\n        external\\n    {\\n        require(newToken.isCommitted, \\\"ERR_NO_TOKEN_COMMIT\\\");\\n        require(BalancerSafeMath.bsub(block.number, newToken.commitBlock) >= addTokenTimeLockInBlocks,\\n                                      \\\"ERR_TIMELOCK_STILL_COUNTING\\\");\\n\\n        uint totalSupply = self.totalSupply();\\n\\n        // poolShares = totalSupply * newTokenWeight / totalWeight\\n        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply, newToken.denorm),\\n                                                bPool.getTotalDenormalizedWeight());\\n\\n        // Clear this to allow adding more tokens\\n        newToken.isCommitted = false;\\n\\n        // First gets the tokens from msg.sender to this contract (Pool Controller)\\n        bool returnValue = IERC20(newToken.addr).transferFrom(self.getController(), address(self), newToken.balance);\\n        require(returnValue, \\\"ERR_ERC20_FALSE\\\");\\n\\n        // Now with the tokens this contract can bind them to the pool it controls\\n        // Approves bPool to pull from this controller\\n        // Approve unlimited, same as when creating the pool, so they can join pools later\\n        returnValue = SafeApprove.safeApprove(IERC20(newToken.addr), address(bPool), BalancerConstants.MAX_UINT);\\n        require(returnValue, \\\"ERR_ERC20_FALSE\\\");\\n\\n        bPool.bind(newToken.addr, newToken.balance, newToken.denorm);\\n\\n        self.mintPoolShareFromLib(poolShares);\\n        self.pushPoolShareFromLib(msg.sender, poolShares);\\n    }\\n\\n     /**\\n     * @notice Remove a token from the pool\\n     * @dev Logic in the CRP controls when ths can be called. There are two related permissions:\\n     *      AddRemoveTokens - which allows removing down to the underlying BPool limit of two\\n     *      RemoveAllTokens - which allows completely draining the pool by removing all tokens\\n     *                        This can result in a non-viable pool with 0 or 1 tokens (by design),\\n     *                        meaning all swapping or binding operations would fail in this state\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param token - token to remove\\n     */\\n    function removeToken(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address token\\n    )\\n        external\\n    {\\n        uint totalSupply = self.totalSupply();\\n\\n        // poolShares = totalSupply * tokenWeight / totalWeight\\n        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply,\\n                                                                      bPool.getDenormalizedWeight(token)),\\n                                                bPool.getTotalDenormalizedWeight());\\n\\n        // this is what will be unbound from the pool\\n        // Have to get it before unbinding\\n        uint balance = bPool.getBalance(token);\\n\\n        // Unbind and get the tokens out of balancer pool\\n        bPool.unbind(token);\\n\\n        // Now with the tokens this contract can send them to msg.sender\\n        bool xfer = IERC20(token).transfer(self.getController(), balance);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n\\n        self.pullPoolShareFromLib(self.getController(), poolShares);\\n        self.burnPoolShareFromLib(poolShares);\\n    }\\n\\n    /**\\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\\n     * @dev Will revert if invalid\\n     * @param token - The prospective token to verify\\n     */\\n    function verifyTokenCompliance(address token) external {\\n        verifyTokenComplianceInternal(token);\\n    }\\n\\n    /**\\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\\n     * @dev Will revert if invalid - overloaded to save space in the main contract\\n     * @param tokens - The prospective tokens to verify\\n     */\\n    function verifyTokenCompliance(address[] calldata tokens) external {\\n        for (uint i = 0; i < tokens.length; i++) {\\n            verifyTokenComplianceInternal(tokens[i]);\\n         }\\n    }\\n\\n    /**\\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\\n     *         through external cals to pokeWeights\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param newWeights - final weights we want to get to\\n     * @param startBlock - when weights should start to change\\n     * @param endBlock - when weights will be at their final values\\n     * @param minimumWeightChangeBlockPeriod - needed to validate the block period\\n    */\\n    function updateWeightsGradually(\\n        IBPool bPool,\\n        GradualUpdateParams storage gradualUpdate,\\n        uint[] calldata newWeights,\\n        uint startBlock,\\n        uint endBlock,\\n        uint minimumWeightChangeBlockPeriod\\n    )\\n        external\\n    {\\n        require(block.number < endBlock, \\\"ERR_GRADUAL_UPDATE_TIME_TRAVEL\\\");\\n\\n        if (block.number > startBlock) {\\n            // This means the weight update should start ASAP\\n            // Moving the start block up prevents a big jump/discontinuity in the weights\\n            gradualUpdate.startBlock = block.number;\\n        }\\n        else{\\n            gradualUpdate.startBlock = startBlock;\\n        }\\n\\n        // Enforce a minimum time over which to make the changes\\n        // The also prevents endBlock <= startBlock\\n        require(BalancerSafeMath.bsub(endBlock, gradualUpdate.startBlock) >= minimumWeightChangeBlockPeriod,\\n                \\\"ERR_WEIGHT_CHANGE_TIME_BELOW_MIN\\\");\\n\\n        address[] memory tokens = bPool.getCurrentTokens();\\n\\n        // Must specify weights for all tokens\\n        require(newWeights.length == tokens.length, \\\"ERR_START_WEIGHTS_MISMATCH\\\");\\n\\n        uint weightsSum = 0;\\n        gradualUpdate.startWeights = new uint[](tokens.length);\\n\\n        // Check that endWeights are valid now to avoid reverting in a future pokeWeights call\\n        //\\n        // This loop contains external calls\\n        // External calls are to math libraries or the underlying pool, so low risk\\n        for (uint i = 0; i < tokens.length; i++) {\\n            require(newWeights[i] <= BalancerConstants.MAX_WEIGHT, \\\"ERR_WEIGHT_ABOVE_MAX\\\");\\n            require(newWeights[i] >= BalancerConstants.MIN_WEIGHT, \\\"ERR_WEIGHT_BELOW_MIN\\\");\\n\\n            weightsSum = BalancerSafeMath.badd(weightsSum, newWeights[i]);\\n            gradualUpdate.startWeights[i] = bPool.getDenormalizedWeight(tokens[i]);\\n        }\\n        require(weightsSum <= BalancerConstants.MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n\\n        gradualUpdate.endBlock = endBlock;\\n        gradualUpdate.endWeights = newWeights;\\n    }\\n\\n    /**\\n     * @notice Join a pool\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param poolAmountOut - number of pool tokens to receive\\n     * @param maxAmountsIn - Max amount of asset tokens to spend\\n     * @return actualAmountsIn - calculated values of the tokens to pull in\\n     */\\n    function joinPool(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        uint poolAmountOut,\\n        uint[] calldata maxAmountsIn\\n    )\\n         external\\n         view\\n         returns (uint[] memory actualAmountsIn)\\n    {\\n        address[] memory tokens = bPool.getCurrentTokens();\\n\\n        require(maxAmountsIn.length == tokens.length, \\\"ERR_AMOUNTS_MISMATCH\\\");\\n\\n        uint poolTotal = self.totalSupply();\\n        // Subtract  1 to ensure any rounding errors favor the pool\\n        uint ratio = BalancerSafeMath.bdiv(poolAmountOut,\\n                                           BalancerSafeMath.bsub(poolTotal, 1));\\n\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        // We know the length of the array; initialize it, and fill it below\\n        // Cannot do \\\"push\\\" in memory\\n        actualAmountsIn = new uint[](tokens.length);\\n\\n        // This loop contains external calls\\n        // External calls are to math libraries or the underlying pool, so low risk\\n        for (uint i = 0; i < tokens.length; i++) {\\n            address t = tokens[i];\\n            uint bal = bPool.getBalance(t);\\n            // Add 1 to ensure any rounding errors favor the pool\\n            uint tokenAmountIn = BalancerSafeMath.bmul(ratio,\\n                                                       BalancerSafeMath.badd(bal, 1));\\n\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n\\n            actualAmountsIn[i] = tokenAmountIn;\\n        }\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem pool tokens for underlying assets\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param poolAmountIn - amount of pool tokens to redeem\\n     * @param minAmountsOut - minimum amount of asset tokens to receive\\n     * @return exitFee - calculated exit fee\\n     * @return pAiAfterExitFee - final amount in (after accounting for exit fee)\\n     * @return actualAmountsOut - calculated amounts of each token to pull\\n     */\\n    function exitPool(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        uint poolAmountIn,\\n        uint[] calldata minAmountsOut\\n    )\\n        external\\n        view\\n        returns (uint exitFee, uint pAiAfterExitFee, uint[] memory actualAmountsOut)\\n    {\\n        address[] memory tokens = bPool.getCurrentTokens();\\n\\n        require(minAmountsOut.length == tokens.length, \\\"ERR_AMOUNTS_MISMATCH\\\");\\n\\n        uint poolTotal = self.totalSupply();\\n\\n        // Calculate exit fee and the final amount in\\n        // exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, bPool.getExitFee());\\n        pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\\n\\n        uint ratio = BalancerSafeMath.bdiv(pAiAfterExitFee,\\n                                           BalancerSafeMath.badd(poolTotal, 1));\\n\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        actualAmountsOut = new uint[](tokens.length);\\n\\n        // This loop contains external calls\\n        // External calls are to math libraries or the underlying pool, so low risk\\n        for (uint i = 0; i < tokens.length; i++) {\\n            address t = tokens[i];\\n            uint bal = bPool.getBalance(t);\\n            // Subtract 1 to ensure any rounding errors favor the pool\\n            uint tokenAmountOut = BalancerSafeMath.bmul(ratio,\\n                                                        BalancerSafeMath.bsub(bal, 1));\\n\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n\\n            actualAmountsOut[i] = tokenAmountOut;\\n        }\\n    }\\n\\n    /**\\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\\n     *         System calculates the pool token amount\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param tokenIn - which token we're transferring in\\n     * @param tokenAmountIn - amount of deposit\\n     * @param minPoolAmountOut - minimum of pool tokens to receive\\n     * @return poolAmountOut - amount of pool tokens minted and transferred\\n     */\\n    function joinswapExternAmountIn(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        uint minPoolAmountOut\\n    )\\n        external\\n        view\\n        returns (uint poolAmountOut)\\n    {\\n        require(bPool.isBound(tokenIn), \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\\n                                                       BalancerConstants.MAX_IN_RATIO),\\n                                                       \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        poolAmountOut = bPool.calcPoolOutGivenSingleIn(\\n                            bPool.getBalance(tokenIn),\\n                            bPool.getDenormalizedWeight(tokenIn),\\n                            self.totalSupply(),\\n                            bPool.getTotalDenormalizedWeight(),\\n                            tokenAmountIn,\\n                            bPool.getSwapFee()\\n                        );\\n\\n        require(poolAmountOut >= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n    }\\n\\n    /**\\n     * @notice Join by swapping an external token in (must be present in the pool)\\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\\n     * @param poolAmountOut - amount of pool tokens to be received\\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\\n     */\\n    function joinswapPoolAmountOut(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address tokenIn,\\n        uint poolAmountOut,\\n        uint maxAmountIn\\n    )\\n        external\\n        view\\n        returns (uint tokenAmountIn)\\n    {\\n        require(bPool.isBound(tokenIn), \\\"ERR_NOT_BOUND\\\");\\n\\n        tokenAmountIn = bPool.calcSingleInGivenPoolOut(\\n                            bPool.getBalance(tokenIn),\\n                            bPool.getDenormalizedWeight(tokenIn),\\n                            self.totalSupply(),\\n                            bPool.getTotalDenormalizedWeight(),\\n                            poolAmountOut,\\n                            bPool.getSwapFee()\\n                        );\\n\\n        require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\\n                                                       BalancerConstants.MAX_IN_RATIO),\\n                                                       \\\"ERR_MAX_IN_RATIO\\\");\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param tokenOut - which token the caller wants to receive\\n     * @param poolAmountIn - amount of pool tokens to redeem\\n     * @param minAmountOut - minimum asset tokens to receive\\n     * @return exitFee - calculated exit fee\\n     * @return tokenAmountOut - amount of asset tokens returned\\n     */\\n    function exitswapPoolAmountIn(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address tokenOut,\\n        uint poolAmountIn,\\n        uint minAmountOut\\n    )\\n        external\\n        view\\n        returns (uint exitFee, uint tokenAmountOut)\\n    {\\n        require(bPool.isBound(tokenOut), \\\"ERR_NOT_BOUND\\\");\\n\\n        uint exitFeePct = bPool.getExitFee();\\n\\n        tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\\n                            bPool.getBalance(tokenOut),\\n                            bPool.getDenormalizedWeight(tokenOut),\\n                            self.totalSupply(),\\n                            bPool.getTotalDenormalizedWeight(),\\n                            poolAmountIn,\\n                            bPool.getSwapFee(),\\n                            exitFeePct\\n                        );\\n\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\\n                                                        BalancerConstants.MAX_OUT_RATIO),\\n                                                        \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        // exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, exitFeePct);\\n    }\\n\\n    /**\\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\\n     *         Asset must be present in the pool\\n     * @param self - ConfigurableRightsPool instance calling the library\\n     * @param bPool - Core BPool the CRP is wrapping\\n     * @param tokenOut - which token the caller wants to receive\\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\\n     * @return exitFee - calculated exit fee\\n     * @return poolAmountIn - amount of pool tokens redeemed\\n     */\\n    function exitswapExternAmountOut(\\n        IConfigurableRightsPool self,\\n        IBPool bPool,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPoolAmountIn\\n    )\\n        external\\n        view\\n        returns (uint exitFee, uint poolAmountIn)\\n    {\\n        require(bPool.isBound(tokenOut), \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\\n                                                        BalancerConstants.MAX_OUT_RATIO),\\n                                                        \\\"ERR_MAX_OUT_RATIO\\\");\\n        uint exitFeePct = bPool.getExitFee();\\n\\n        poolAmountIn = bPool.calcPoolInGivenSingleOut(\\n                            bPool.getBalance(tokenOut),\\n                            bPool.getDenormalizedWeight(tokenOut),\\n                            self.totalSupply(),\\n                            bPool.getTotalDenormalizedWeight(),\\n                            tokenAmountOut,\\n                            bPool.getSwapFee(),\\n                            exitFeePct\\n                        );\\n\\n        require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(poolAmountIn <= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        // exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, exitFeePct);\\n    }\\n\\n    // Internal functions\\n\\n    // Check for zero transfer, and make sure it returns true to returnValue\\n    function verifyTokenComplianceInternal(address token) internal {\\n        bool returnValue = IERC20(token).transfer(msg.sender, 0);\\n        require(returnValue, \\\"ERR_NONCONFORMING_TOKEN\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IMasterRancher\",\"name\":\"_rancher\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_crpFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paca\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_notBeforeBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"wethBalance\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenWethValue\",\"type\":\"uint256\"}],\"name\":\"LogNewBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"LogNewCrp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"wethAmount\",\"type\":\"uint256\"}],\"name\":\"LogNewDomesticate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"desiredLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"orig\",\"type\":\"address\"}],\"name\":\"domesticate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"legacyTotalsupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"establishRanch\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"alp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"establishTokenSetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialTotalLPSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"liquidateNonalpaca\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterRancher\",\"outputs\":[{\"internalType\":\"contract IMasterRancher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notBeforeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"omniPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"omniPoolParams\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"poolTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"poolTokenName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pacaAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pacaOmniPool\",\"outputs\":[{\"internalType\":\"contract ConfigurableRightsPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pacaWethValueForShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permissions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canPauseSwapping\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canChangeSwapFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canChangeWeights\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canAddRemoveTokens\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canWhitelistLPs\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canChangeCap\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"retrieveShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setWethComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeToPct\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_exitFeeTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_exitFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payOutToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"startRanch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWethforShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Migrator","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003f1962cefc8fdfd21b9034e66a7d8ddafa14f36d0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000fc3a5d65e7d4ef05421a242015f8fecd94db05b9000000000000000000000000874699f0f18b8a8c7471eb09a4f134de38186f55000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000580b2ebfb318613f89ec7668e79fae45dbdbe4bf0000000000000000000000000000000000000000000000000000000000acc290","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}