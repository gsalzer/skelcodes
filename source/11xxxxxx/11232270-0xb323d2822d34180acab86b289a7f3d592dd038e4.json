{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.6.2;\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\t   Libraries\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\nlibrary SafeMath {\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;}\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");}\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;}\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {return 0;}\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;}\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");}\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;}\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");}\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;}\r\n}\r\n\r\n\r\nlibrary Math {\r\n\tfunction max(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? y : x;\r\n    }\r\n\t\r\n\tfunction min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\t  Interfaces\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction addInitialLiquidity() external payable;\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 {\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ninterface IApprover {\r\n    function viewTotalExpLpBalance() external view returns (uint256);\r\n    function approveStake(address who, uint256 lpAmount) external returns (uint256);\r\n    function doRefund(address who, uint256 refundAmount) external;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\tVault Contract\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\ncontract LogVault {\r\n    using SafeMath for uint256;\r\n\r\n\taddress internal immutable FACTORY;\r\n\taddress internal immutable UNIROUTER;\r\n    address internal immutable WETH;\r\n\taddress internal immutable LOG;\r\n\taddress internal immutable LOGxWETH;\r\n\taddress internal immutable APPROVER;\r\n\taddress internal immutable ADMIN_ADDRESS;\r\n\r\n    constructor(address _FACTORY, address _UNIROUTER, address _LOG, address _APPROVER, address _LOGxWETH) public {\r\n        FACTORY = _FACTORY;\r\n        UNIROUTER = _UNIROUTER;\r\n        WETH = IUniswapV2Router02(_UNIROUTER).WETH();\r\n        LOG = _LOG;\r\n        APPROVER = _APPROVER;\r\n\t\tLOGxWETH = _LOGxWETH;\r\n\t\tADMIN_ADDRESS = msg.sender;\r\n    }\r\n\r\n\t//store values of ln(x) multiplied by 1e6\r\n\tuint[10] lnValues = [0, 693147, 1098612, 1386294, 1609437, 1791759, 1945910, 2079441, 2197224, 2302585];\r\n\r\n\t//initial liquidity info\r\n\tuint public constant \tmaxContributionETH \t\t= \t1000000000000000000; \t    //1 ETH\r\n\tuint public constant \tinitialLiquidityETH \t= \t50000000000000000000; \t    //50 ETH\r\n\tuint private constant \tinitialLiquidityLOG \t= \t27182000000000000000000; \t//27182 LOG\r\n\r\n\tuint private \tinitialLP \t\t\t\t= \tMath.sqrt(initialLiquidityLOG.mul(initialLiquidityETH)).div(2);\t//1165.8219907985620016/2  UNI-V2 LP tokens\r\n\r\n\tuint private \tstakingStartTime \t\t= \t27182818284;\r\n\tbool public \tallowStake \t\t\t\t= \tfalse;\r\n\tbool public \tliquidityAdded \t\t\t= \tfalse;\r\n\r\n\t//vault reward info\r\n\tuint256 private pendingRewards;\r\n\tuint256 public rewardAmount;\r\n\tuint256 public totalPoints;\r\n\tuint256 public logPerPoint;\r\n\r\n\t//dev fee, 4.5% of rewards\r\n\tuint256 private devFee = 45;\r\n\tuint256 private pendingDevRewards;\r\n\r\n\t//user info\r\n\tstruct UserInfo {\r\n\t\tuint256 timePooled;\r\n\t\tuint256 lockupSeconds;\r\n\t\tuint256 lockupWeeks;\r\n\r\n\t\tuint256 ETHContributed;\r\n\t\tuint256 LPTokenBalance;\r\n\t\tuint256 points;\r\n\t\tuint256 logDebt;\r\n\r\n\t\tuint256 logReward;\r\n\t}\r\n\r\n\tmapping(address => UserInfo) public userInfo;\r\n\r\n\r\n    //info about EXP LP stakers\r\n\taddress[] public expStaker;\r\n\tmapping(address => bool) public stakerInList;\r\n\r\n    mapping (address => uint256) public expLpBalances;\r\n    mapping (address => uint256) public expLpLockup;\r\n\r\n    receive() external payable {\r\n\t\tif(msg.sender != UNIROUTER){\r\n\t\t\tstakeETH(1);\r\n\t\t}\r\n    }\r\n\r\n    event AssignLP(address indexed owner, uint userLogLp);\r\n\r\n    event DepositETH(address indexed owner, uint amount, uint lockup, uint lpTokenGot);\r\n    event DepositLP(address indexed owner, uint amount, uint lockup);\r\n    event DepositExpLP(address indexed owner, uint amount, uint lockup);\r\n\r\n    event WithdrawLP(address indexed owner, uint amount);\r\n    event WithdrawLOG(address indexed caller, address indexed owner, uint amount);\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\tAdmin functions\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\t//ADMIN-function: allow staking\r\n\tfunction allowStaking() public {\r\n\t    require(msg.sender == ADMIN_ADDRESS, \"Caller is not admin.\");\r\n\t    allowStake = true;\r\n\t}\r\n\r\n\r\n\t//ADMIN-function: create uniswap pair\r\n    function addInitialLiquidity() public {\r\n\t\trequire(!liquidityAdded, \"Uniswap pair has already been created.\");\r\n\t\trequire(msg.sender == ADMIN_ADDRESS, \"Caller is not admin.\");\r\n\t\trequire(address(this).balance >= initialLiquidityETH);\r\n\r\n\t\t//add liquidity to uniswap pair\r\n        IERC20(LOG).addInitialLiquidity{value: initialLiquidityETH}();\r\n\t\tliquidityAdded = true;\r\n\r\n\t\t//get total LP amounts\r\n\t\tuint256 expLpTotal = IApprover(APPROVER).viewTotalExpLpBalance();\r\n\t\tuint256 logLpTotal = initialLP.mul(15).div(100);\r\n\r\n\t\t//assign lp tokens to expLP stakers\r\n\t\taddress user;\r\n\t\tuint256 userLogLp;\r\n\t\tuint256 userShare;\r\n\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < expStaker.length; i++) {\r\n\r\n\t\t    //get user info\r\n\t\t    user = expStaker[i];\r\n\r\n\t\t    //user share and user amount\r\n\t\t    userShare = expLpBalances[user].mul(1e12).div(expLpTotal);\r\n\t\t    userLogLp = logLpTotal.mul(userShare).div(1e12);\r\n\r\n\t\t\t//reset user balance\r\n\t\t\texpLpBalances[user] = 0;\r\n\r\n\t\t\t// if LOG amount is greater than 0, update user info\r\n\t\t\tif (userLogLp > 0) {\r\n\t\t\t\tupdateUser(user, expLpLockup[user], userLogLp);\r\n\t\t\t\temit AssignLP(user, userLogLp);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//set start time and allow stake again\r\n\t\tstakingStartTime = block.timestamp;\r\n\t\tallowStake = true;\r\n    }\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\tMiscellaneous\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\t//function to send ether\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n\r\n\t//calc optimal fraction of ETH to swap for token based on 0.3% Uniswap fee, 9 decimals precision\r\n\t//a amount of ether available to buy\r\n\t//b amount of ether in liquidity pool\r\n\tfunction calcEthBuy(uint a, uint b) internal pure returns(uint fraction) {\r\n\t\tuint sqroot = Math.sqrt((a.mul(a).mul(9)).add(b.mul(a).mul(4e6)).add(b.mul(b).mul(4e6)));\r\n\t\tuint x = (sqroot.add(a.mul(3)).sub(b.mul(2000))).mul(1e18).div(a.mul(2000));\r\n\r\n\t\treturn x.mul(a).div(1e18);\r\n\t}\r\n\r\n\r\n\tfunction calcLockupMulti(uint256 lockupWeeks) internal view returns(uint256 lockupMulti){\r\n\t\t//get lockup multiplier\r\n\t\tlockupMulti = lockupWeeks > 10 ? lnValues[9] : lnValues[lockupWeeks.sub(1)];\r\n\t\tlockupMulti = lockupMulti.add(1e6);\r\n\t}\r\n\r\n\r\n\t//claim refund of initial contribution if no uniswap pair is created within 1 week\r\n\tfunction refundInitial() public {\r\n\t\trequire(!liquidityAdded, \"Uniswap pair created, no refunds possible.\");\r\n\r\n\t\t//get user info\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\tuint refundAmount = user.ETHContributed;\r\n\r\n\t\trequire(block.timestamp >= user.timePooled + 1 weeks, \"Refund will be possible 1 week after your contribution.\");\r\n\t\trequire(refundAmount > 0, \"You have not contributed anything.\");\r\n\r\n\t\t//update values\r\n\t\tuser.timePooled = 0;\r\n\t\tuser.lockupSeconds = 0;\r\n\t\tuser.lockupWeeks = 0;\r\n\t\tuser.LPTokenBalance = 0;\r\n\t\tuser.ETHContributed = 0;\r\n\t\tuser.points = 0;\r\n\r\n\t\t//send ETH back to staker\r\n\t\tsendValue(msg.sender, refundAmount);\r\n\t}\r\n\r\n\t//claim refund of initial EXP LP contribution if no uniswap pair is created within 1 week\r\n\tfunction refundInitialLP() public {\r\n\t\trequire(!liquidityAdded, \"Uniswap pair created, no refunds possible.\");\r\n\r\n\t\t//get user info\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\tuint refundAmount = expLpBalances[msg.sender];\r\n\r\n\t\trequire(block.timestamp >= user.timePooled + 1 weeks, \"Refund will be possible 1 week after your contribution.\");\r\n\t\trequire(refundAmount > 0, \"You have not contributed anything.\");\r\n\r\n\t\t//update values\r\n\t\tuser.timePooled = 0;\r\n\t\tuser.lockupSeconds = 0;\r\n\t\tuser.lockupWeeks = 0;\r\n\t\tuser.LPTokenBalance = 0;\r\n\t\tuser.ETHContributed = 0;\r\n\t\tuser.points = 0;\r\n\r\n\t\texpLpBalances[msg.sender] = 0;\r\n\t\texpLpLockup[msg.sender] = 0;\r\n\r\n\t\t//send LP back to staker\r\n\t\tIApprover(APPROVER).doRefund(msg.sender, refundAmount);\r\n\t}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\t Vault Logic\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\t//function to keep track of pending rewards, called on token transfer\r\n    function addRewards(uint256 newRewards) public {\r\n\t\trequire(msg.sender == LOG, \"Can only be called from within LOG token transfers.\");\r\n\r\n        if(newRewards > 0) {\r\n\r\n            uint256 diff = 0;\r\n            uint256 currentReward = rewardAmount.add(newRewards);\r\n            //check if there have been LOG tokens sent directly to Vault\r\n            if (currentReward < IERC20(LOG).balanceOf(address(this))) {\r\n                diff = IERC20(LOG).balanceOf(address(this)).sub(currentReward);\r\n            }\r\n            pendingRewards = pendingRewards.add(newRewards).add(diff);\r\n            updateRewards();\r\n        }\r\n    }\r\n\r\n\r\n\t//update pending rewards and current LOG per point\r\n\tfunction updateRewards() internal {\r\n\r\n\t\tif (pendingRewards > 0) {\r\n\t\t\tif (totalPoints != 0) {\r\n\t\t\t    //update total reward amount\r\n\t\t\t    rewardAmount = rewardAmount.add(pendingRewards);\r\n\r\n\t\t\t\tuint256 logDevFee = pendingRewards.mul(devFee).div(1000);\r\n\t\t\t\tuint256 logReward = pendingRewards.sub(logDevFee);\r\n\r\n\t\t\t\tpendingDevRewards = pendingDevRewards.add(logDevFee);\r\n\t\t\t\tlogPerPoint = logPerPoint.add(logReward.mul(1e12).div(totalPoints));\r\n\r\n\t\t\t\t//reset pending rewards\r\n\t\t\t\tpendingRewards = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//update user information\r\n\tfunction updateUser(address who, uint256 lockup, uint256 lpTokenGot) internal {\r\n\t\tUserInfo storage user = userInfo[who];\r\n\r\n\t\t//store time information\r\n        user.timePooled = block.timestamp;\r\n\r\n\t\t//if msg.sender is already staking and new lockup time is higher than previous one, replace it\r\n\t\tif (user.lockupSeconds < lockup.mul(1 weeks)) {\r\n\t\t\tuser.lockupSeconds = lockup.mul(1 weeks);\r\n\t\t\tuser.lockupWeeks = lockup;\r\n\t\t}\r\n\r\n\t\t//get lockup multiplier\r\n\t\tuint256 lockupMulti = calcLockupMulti(user.lockupWeeks);\r\n\r\n\t\t//assign LP tokens\r\n        user.LPTokenBalance = user.LPTokenBalance.add(lpTokenGot);\r\n\r\n\t\t//assign points based on LP and lockup time\r\n\t\tuint256 userPointsBefore = user.points;\r\n        user.points = user.LPTokenBalance.mul(lockupMulti).div(1e6);\r\n\t\ttotalPoints = totalPoints.add(user.points).sub(userPointsBefore);\r\n\r\n\t\t//remember log debt to calculate future rewards\r\n\t\tuser.logDebt = user.points.mul(logPerPoint).div(1e12);\r\n\t}\r\n\r\n\r\n\t//update pending user rewards\r\n\tfunction updatePending(address who) internal {\r\n\t\tUserInfo storage user = userInfo[who];\r\n\r\n\t\t//assign pending log rewards\r\n\t\tuint256 pendingLog = user.points.mul(logPerPoint).div(1e12).sub(user.logDebt);\r\n\t\tuser.logReward = user.logReward.add(pendingLog);\r\n\t}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\tStake functions\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\t//stake LP tokens\r\n\tfunction stakeLP(uint256 lockup, uint256 amount) public {\r\n\t\trequire(lockup >= 1, \"You must lock liquidity at least one week.\");\r\n\t\trequire(lockup <= 52, \"Maximum lockup is 52 weeks.\");\r\n\t\trequire(amount > 0, \"You need to stake at least 1 wei.\");\r\n\r\n\t\t//if uniswap pair created stake normally\r\n\t\tif (liquidityAdded) {\r\n\t\t\tupdateRewards();\r\n\t\t\tupdatePending(msg.sender);\r\n\t\t\tstakeLogLP(lockup, amount);\r\n\t\t} else {\r\n\t\t\tstakeExpLP(lockup, amount);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//stake EXP LP pre uniswap pair creation\r\n\tfunction stakeExpLP(uint256 lockup, uint256 lpAmount) internal {\r\n\r\n\t\t//call Approver contract to check allowance\r\n\t\tuint256 validAmount = IApprover(APPROVER).approveStake(msg.sender, lpAmount);\r\n\r\n\t\texpLpBalances[msg.sender] = expLpBalances[msg.sender].add(validAmount);\r\n        expLpLockup[msg.sender] = lockup;\r\n\r\n\t\t//remember user if not in expStaker list yet\r\n\t\tif (!stakerInList[msg.sender]) {\r\n\t\t    expStaker.push(msg.sender);\r\n\t\t    stakerInList[msg.sender] = true;\r\n\t\t}\r\n\r\n\t\temit DepositExpLP(msg.sender, lpAmount, lockup);\r\n\t}\r\n\r\n\r\n\t//stake LOG LP post uniswap pair creation\r\n\tfunction stakeLogLP(uint256 lockup, uint256 lpAmount) internal {\r\n\r\n\t\t//get lp from user - lp tokens need to be approved by user first\r\n\t\trequire(IERC20(LOGxWETH).transferFrom(msg.sender, address(this), lpAmount), \"Token transfer failed.\");\r\n\r\n\t\t//update user variables\r\n\t\tupdateUser(msg.sender, lockup, lpAmount);\r\n\r\n\t\temit DepositLP(msg.sender, lpAmount, lockup);\r\n\t}\r\n\r\n\r\n\t//stake ETH\r\n\tfunction stakeETH(uint256 lockup) public payable {\r\n\t\trequire(allowStake, \"Staking has not been activated yet.\");\r\n\t\trequire(lockup >= 1, \"You must lock liquidity at least one week.\");\r\n\t\trequire(lockup <= 52, \"Maximum lockup is 52 weeks.\");\r\n\t\trequire(msg.value > 0, \"You need to send ETH to stake.\");\r\n\r\n\t\tuint lpTokenGot;\r\n\r\n\t\t//if uniswap pair created stake normally\r\n\t\tif (liquidityAdded) {\r\n\t\t\tupdateRewards();\r\n\t\t\tupdatePending(msg.sender);\r\n\t\t\tlpTokenGot = stakeUniswap();\r\n\t\t} else {\r\n\t\t\tlpTokenGot = stakeInitial();\r\n\t\t}\r\n\r\n\t\t//update user variables\r\n\t\tupdateUser(msg.sender, lockup, lpTokenGot);\r\n\r\n\t\temit DepositETH(msg.sender, msg.value, lockup, lpTokenGot);\r\n\t}\r\n\r\n\r\n\t//staking pre uniswap pair creation\r\n\tfunction stakeInitial() internal returns (uint256 lpTokenGot){\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.ETHContributed < maxContributionETH, \"You cannot contribute more than 1 ETH during initial staking.\");\r\n\r\n\t\tuint currentEthBalance = (address(this).balance).sub(msg.value);\r\n\t\trequire(currentEthBalance < initialLiquidityETH, \"Initial Liquidity Target reached. Please wait for Uniswap pair creation.\");\r\n\r\n\t\tuint validAmount;\r\n\t\t//maximum amount to be contributed\r\n\t\tuint maxAmount = Math.min(initialLiquidityETH.sub(currentEthBalance), maxContributionETH.sub(user.ETHContributed));\r\n\r\n\r\n\t\t//check total contribution\r\n\t\tif (msg.value > maxAmount) {\r\n\t\t\tvalidAmount = maxAmount;\r\n\t\t\t//assign contributed ETH\r\n\t\t\tuser.ETHContributed = user.ETHContributed.add(validAmount);\r\n\t\t\t//return remaining eth\r\n\t\t\tsendValue(msg.sender, (msg.value).sub(validAmount));\r\n\t\t} else {\r\n\t\t\tvalidAmount = msg.value;\r\n\t\t\t//assign contributed ETH\r\n\t\t\tuser.ETHContributed = user.ETHContributed.add(validAmount);\r\n\t\t}\r\n\r\n\t\t//disable staking if target is reached\r\n\t\tif (address(this).balance >= initialLiquidityETH) {\r\n\t\t    allowStake = false;\r\n\t\t}\r\n\r\n\t\t//share of initial liquidity, 2 decimals precision\r\n\t\tuint lpShare = uint(10000).mul(validAmount).div(initialLiquidityETH);\r\n\r\n\t\t//amount of LP tokens\r\n\t\tlpTokenGot = initialLP.mul(lpShare).mul(85).div(1000000);\r\n\t}\r\n\r\n\r\n\t//staking post uniswap pair creation\r\n    function stakeUniswap() internal returns (uint256){\r\n\r\n\t\t//get liquidity pool information\r\n        uint ethAmount = IERC20(WETH).balanceOf(LOGxWETH); //WETH in Uniswap\r\n\r\n        //get current LOG amount held by vault\r\n        uint logAmountBefore = IERC20(LOG).balanceOf(address(this));\r\n\r\n\t\t//calc optimal amount of ETH to\r\n\t\tuint ethBuy = calcEthBuy(address(this).balance, ethAmount);\r\n\r\n\t\t//define swap path: ETH->WETH->LOG\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = WETH;\r\n\t\tpath[1] = LOG;\r\n\t\t//swap ETH for LOG\r\n\t\tIUniswapV2Router02(UNIROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethBuy}(1, path, address(this), block.timestamp + 30 minutes);\r\n\r\n\t\t//get amount of LOG bought\r\n        uint logAmount = IERC20(LOG).balanceOf(address(this)).sub(logAmountBefore);\r\n\r\n\t\t//if buy of LOG was successfull, add liquidity\r\n\t\trequire(logAmount > 0, \"LOG Buy was not successfull.\");\r\n\t\trequire(IERC20(LOG).approve(UNIROUTER, logAmount), \"Approve failed.\");\r\n\r\n\t\t(uint logAdded , , uint lpTokenGot) = IUniswapV2Router02(UNIROUTER).addLiquidityETH{value: address(this).balance}(LOG, logAmount, 1, 1, address(this), block.timestamp + 15 minutes);\r\n\r\n\t\t//add log dust to pending rewards\r\n\t\tpendingRewards = pendingRewards.add(logAmount.sub(logAdded));\r\n\r\n\t\treturn lpTokenGot;\r\n    }\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\tWithdraw functions\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\t//Withdraw LP tokens\r\n    function withdrawLP(uint amount) public {\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\r\n        require(Math.max(user.timePooled, stakingStartTime) + user.lockupSeconds <= block.timestamp, \"You must wait longer.\");\r\n\t\trequire(user.LPTokenBalance >= amount, \"Amount needs to be less than or equal to what is available.\");\r\n\t\trequire(amount > 0, \"You need to withdraw at least 1 wei.\");\r\n\r\n\t\t//update vault rewards\r\n\t\tupdateRewards();\r\n\t\t//update user rewards\r\n\t\tupdatePending(msg.sender);\r\n\r\n        //update LPTokenBalance\r\n        user.LPTokenBalance = user.LPTokenBalance.sub(amount);\r\n\r\n\t\t// update points\r\n\t\tuint256 lockupMulti = calcLockupMulti(user.lockupWeeks);\r\n\t\tuint256 userPointsBefore = user.points;\r\n        user.points = user.LPTokenBalance.mul(lockupMulti).div(1000000);\r\n\t\ttotalPoints = totalPoints.sub(userPointsBefore.sub(user.points));\r\n\r\n        //send LP to user\r\n        require(IERC20(LOGxWETH).transfer(msg.sender, amount), \"LP Token transfer failed.\");\r\n\r\n\t\t//update user logDebt and reset lockup time\r\n\t\tuser.logDebt = user.points.mul(logPerPoint).div(1e12);\r\n\t\tuser.lockupSeconds = 0;\r\n\r\n\t\temit WithdrawLP(msg.sender, amount);\r\n    }\r\n\r\n\r\n\t//Withdraw rewarded LOG, can be called by anyone for anyone to avoid LOG getting stuck in the Vault\r\n    function withdrawLOG(address who) public {\r\n\t\tUserInfo storage user = userInfo[who];\r\n\r\n\t\t//update vault rewards\r\n\t\tupdateRewards();\r\n\t\t//update user rewards\r\n\t\tupdatePending(who);\r\n\r\n\t\tuint256 amount = user.logReward;\r\n\t\trequire(amount > 0, \"Withdraw amount needs to be at least 1 wei.\");\r\n\r\n\t\t//transfer all LOG rewards to user\r\n\t\tuser.logReward = 0;\r\n\t\trewardAmount = rewardAmount.sub(amount);\r\n\t\tIERC20(LOG).transfer(who, amount);\r\n\r\n\t\t//update user logDebt\r\n\t\tuser.logDebt = user.points.mul(logPerPoint).div(1e12);\r\n\r\n\t\temit WithdrawLOG(msg.sender, who, amount);\r\n    }\r\n\r\n\r\n\t//Withdraw Dev Reward, can be called by anyone to avoid LOG getting stuck in the Vault\r\n\tfunction withdrawDevReward() public {\r\n\t\trequire(pendingDevRewards > 0, \"Withdraw amount needs to be at least 1 wei.\");\r\n\r\n\t\t//transfer all LOG to ADMIN_ADDRESS\r\n\t\tuint256 amount = pendingDevRewards;\r\n\t\tpendingDevRewards = 0;\r\n\t\trewardAmount = rewardAmount.sub(amount);\r\n\t\tIERC20(LOG).transfer(ADMIN_ADDRESS, amount);\r\n\t}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\tView functions\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n\t//get total value locked (TVL)\r\n    function viewTotalValueLocked() public view returns (uint, uint) {\r\n\r\n        uint wethPool = IERC20(WETH).balanceOf(LOGxWETH); //WETH in uniswap pool\r\n        uint logPool = IERC20(LOG).balanceOf(LOGxWETH); //LOG in uniswap pool\r\n\t\tuint lpTokenAmount = IERC20(LOGxWETH).balanceOf(address(this)); //lp token held by contract\r\n\r\n\t\tuint wethShare = wethPool.mul(lpTokenAmount).div(IERC20(LOGxWETH).totalSupply());\r\n\t\tuint logShare = logPool.mul(lpTokenAmount).div(IERC20(LOGxWETH).totalSupply());\r\n\r\n        return (wethShare, logShare);\r\n    }\r\n\r\n\r\n\t//get ETH/LOG price\r\n\tfunction viewPoolInfo() public view returns (uint, uint) {\r\n\t\tuint wethPool = IERC20(WETH).balanceOf(LOGxWETH); //WETH in uniswap pool\r\n        uint logPool = IERC20(LOG).balanceOf(LOGxWETH); //LOG in uniswap pool\r\n\r\n\t\treturn (wethPool, logPool);\r\n\t}\r\n\r\n\r\n\t//get token release time\r\n\tfunction viewTokenReleaseTime(address who) public view returns (uint) {\r\n\t\tUserInfo storage user = userInfo[who];\r\n\r\n\t\tif (user.lockupSeconds == 0) {\r\n\t\t    return 0;\r\n\t\t} else {\r\n\t\t    return (Math.max(user.timePooled, stakingStartTime) + user.lockupSeconds);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//get user LOG amount\r\n\tfunction viewUserLogAmount(address who) public view returns (uint) {\r\n\t    UserInfo storage user = userInfo[who];\r\n\r\n\t\tuint256 pendingLog = user.points.mul(logPerPoint).div(1e12).sub(user.logDebt);\r\n\t\treturn user.logReward.add(pendingLog);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_FACTORY\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_UNIROUTER\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_LOG\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_APPROVER\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_LOGxWETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userLogLp\",\"type\":\"uint256\"}],\"name\":\"AssignLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockup\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenGot\",\"type\":\"uint256\"}],\"name\":\"DepositETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockup\",\"type\":\"uint256\"}],\"name\":\"DepositExpLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockup\",\"type\":\"uint256\"}],\"name\":\"DepositLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLOG\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLP\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addInitialLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewards\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"expLpBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"expLpLockup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"expStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logPerPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxContributionETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundInitial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundInitialLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockup\",\"type\":\"uint256\"}],\"name\":\"stakeETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockup\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerInList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timePooled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupWeeks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ETHContributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LPTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"logDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"logReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"viewTokenReleaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewTotalValueLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"viewUserLogAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDevReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"withdrawLOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"LogVault","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000001f547d872e0e6d94a2b7b6eb76718baa109f3c140000000000000000000000000268f2a9bee078581bc662c26966971f9ac322f2000000000000000000000000ee6b0df0db776e98e0f71d7d03e45b7f03596df2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6d2cedf8002def443cf90baf8c108355a70f6abdf8ee86812f0eea0acd225208"}]}