{"status":"1","message":"OK","result":[{"SourceCode":"{\"RiseRebaser.sol\":{\"content\":\"/* \\r\\n   SPDX-License-Identifier: MIT\\r\\n   https://riseprotocol.io\\r\\n   Copyright 2020\\r\\n*/\\r\\n\\r\\npragma solidity 0.6.6;\\r\\n\\r\\nimport \\\"./RiseSafeMath.sol\\\";\\r\\n        \\r\\ninterface UniswapPairContract {\\r\\n  \\r\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n  }\\r\\n        \\r\\n\\r\\ninterface RiseTokenInterface {\\r\\n   \\r\\n    //Public functions\\r\\n    function maxScalingFactor() external view returns (uint256);\\r\\n    function RiseScalingFactor() external view returns (uint256);\\r\\n    //rebase permissioned\\r\\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\\r\\n}\\r\\n\\r\\ncontract RiseRebaser {\\r\\n\\r\\n    using RiseSafeMath for uint256;\\r\\n\\r\\n    modifier onlyGov() {\\r\\n        require(msg.sender == gov);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n \\r\\n    /// @notice an event emitted when deviationThreshold is changed\\r\\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\\r\\n\\r\\n    /// @notice Governance address\\r\\n    address public gov;\\r\\n\\r\\n  \\r\\n    /// @notice Spreads out getting to the target price\\r\\n    uint256 public rebaseLag;\\r\\n\\r\\n    /// @notice Peg target\\r\\n    uint256 public targetRate;\\r\\n    \\r\\n    // If the current exchange rate is within this fractional percentage from the target, no supply\\r\\n    // adjustment is performed.\\r\\n    uint256 public deviationThreshold;\\r\\n\\r\\n    /// @notice More than this much time must pass between rebase operations.\\r\\n    uint256 public minRebaseTimeIntervalSec;\\r\\n\\r\\n    /// @notice Block timestamp of last rebase operation\\r\\n    uint256 public lastRebaseTimestampSec;\\r\\n\\r\\n    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\\r\\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\\r\\n    uint256 public rebaseWindowOffsetSec;\\r\\n\\r\\n    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\\r\\n    uint256 public rebaseWindowLengthSec;\\r\\n\\r\\n    /// @notice The number of rebase cycles since inception\\r\\n    uint256 public epoch;\\r\\n\\t\\r\\n\\t/// @notice The number of consecutive days where price is under 5% of peg\\r\\n\\tuint256 public nepoch;\\r\\n\\r\\n    address public RiseAddress;\\r\\n   \\r\\n    address public uniswap_Rise_eth_pair;\\r\\n    \\r\\n    mapping(address =\\u003e bool) public whitelistFrom;\\r\\n    \\r\\n   \\r\\n\\r\\n    constructor(\\r\\n        address RiseAddress_,\\r\\n        address RiseETHPair_\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n          minRebaseTimeIntervalSec = 23 hours;\\r\\n          rebaseWindowOffsetSec = 0;\\r\\n       \\r\\n          // Default target rate of 0.01 ETH\\r\\n          targetRate = 10**7;\\r\\n\\r\\n          // Default lag of 5\\r\\n          rebaseLag = 5;\\r\\n\\r\\n          // 5%\\r\\n          deviationThreshold = 5;\\r\\n\\r\\n          // 24 hours\\r\\n          rebaseWindowLengthSec = 24 hours;\\r\\n          \\r\\n          uniswap_Rise_eth_pair = RiseETHPair_;\\r\\n          RiseAddress = RiseAddress_;\\r\\n\\r\\n          gov = msg.sender;\\r\\n    }\\r\\n\\r\\n  \\r\\n  \\r\\n    function checkIndexDelta() public view returns (uint256) {\\r\\n\\t\\t uint256 _exchangeRate = getPrice();\\r\\n\\r\\n        (uint256 _offPegPerc, bool _positive) = computeOffPegPerc(_exchangeRate);\\r\\n\\r\\n        uint256 _indexDelta = _offPegPerc;\\r\\n\\t\\t\\r\\n\\t\\tif(_positive){\\r\\n        _indexDelta = _indexDelta.div(rebaseLag);\\r\\n\\t\\t}\\r\\n\\t\\treturn _indexDelta;\\r\\n\\t}\\r\\n    \\r\\n     function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyGov {\\r\\n        whitelistFrom[_addr] = _whitelisted;\\r\\n    }\\r\\n    \\r\\n    \\r\\n     function _isWhitelisted(address _from) internal view returns (bool) {\\r\\n        return whitelistFrom[_from];\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\r\\n     *\\r\\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\\r\\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\r\\n     *      and targetRate is 1e18\\r\\n     */\\r\\n    function rebase()\\r\\n        public\\r\\n    {\\r\\n        // EOA only\\r\\n        require(msg.sender == tx.origin);\\r\\n        require(_isWhitelisted(msg.sender));\\r\\n        // ensure rebasing at correct time\\r\\n        _inRebaseWindow();\\r\\n        \\r\\n\\r\\n        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) \\u003c now);\\r\\n\\r\\n        // Snap the rebase time to the start of this window.\\r\\n        lastRebaseTimestampSec = now;\\r\\n\\r\\n        // get price from uniswap v2;\\r\\n        uint256 exchangeRate = getPrice();\\r\\n\\r\\n        // calculates % change to supply\\r\\n        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\\r\\n\\r\\n        uint256 indexDelta = offPegPerc;\\r\\n\\r\\n        // Apply the Dampening factor for positive rebases\\r\\n\\t\\tif(positive) {\\r\\n        indexDelta = indexDelta.div(rebaseLag);\\r\\n\\t\\t}\\r\\n\\t\\t// Increase epoch if positive or neutral rebase. Snap nepoch back to 0.\\r\\n\\t\\tif (positive || indexDelta == 0) {\\r\\n\\t\\tepoch = epoch.add(1);\\r\\n\\t\\tnepoch = 0;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t// Increase nepoch if price below 5% of peg\\r\\n\\t\\tif (!positive) {\\r\\n\\t\\t\\tepoch = epoch.add(1);\\r\\n\\t\\t\\tnepoch = nepoch.add(1);\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n        RiseTokenInterface Rise = RiseTokenInterface(RiseAddress);\\r\\n\\r\\n        if (positive) {\\r\\n            require(Rise.RiseScalingFactor().mul(uint256(10**9).add(indexDelta)).div(10**9) \\u003c Rise.maxScalingFactor(), \\\"new scaling factor will be too big\\\");\\r\\n        }\\r\\n\\t\\t\\r\\n        // Positive rebase.\\r\\n\\t\\tif (positive) {\\r\\n        Rise.rebase(epoch, indexDelta, positive);\\r\\n        assert(Rise.RiseScalingFactor() \\u003c= Rise.maxScalingFactor());\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t//Supply adjustment only if nepoch = 3. After adjustment, snap nepoch back to 0.\\r\\n\\t\\tif (!positive \\u0026\\u0026 nepoch == 3) {\\r\\n\\t\\t\\t\\tRise.rebase(epoch, indexDelta, positive);\\r\\n\\t\\t\\t\\tnepoch = 0;\\r\\n\\t\\t\\t}\\r\\n  }\\r\\n  \\r\\n \\r\\n      function getPrice() public view returns (uint256) {\\r\\n        (uint RiseReserve, uint ethReserve, ) = UniswapPairContract(uniswap_Rise_eth_pair).getReserves();\\r\\n        uint RisePrice = ethReserve.div(RiseReserve);\\r\\n        return RisePrice;\\r\\n    }\\r\\n\\r\\n    function setDeviationThreshold(uint256 deviationThreshold_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(deviationThreshold \\u003e 0);\\r\\n        uint256 oldDeviationThreshold = deviationThreshold;\\r\\n        deviationThreshold = deviationThreshold_;\\r\\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the rebase lag parameter.\\r\\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\\r\\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\\r\\n               correction is applied on each rebase cycle.\\r\\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\\r\\n     * @param rebaseLag_ The new rebase lag parameter.\\r\\n     */\\r\\n     \\r\\n     \\r\\n    function setRebaseLag(uint256 rebaseLag_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(rebaseLag_ \\u003e 0);\\r\\n        rebaseLag = rebaseLag_;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    /**\\r\\n     * @notice Sets the targetRate parameter.\\r\\n     * @param targetRate_ The new target rate parameter.\\r\\n     */\\r\\n     \\r\\n     \\r\\n    function setTargetRate(uint256 targetRate_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(targetRate_ \\u003e 0);\\r\\n        targetRate = targetRate_;\\r\\n    }\\r\\n    \\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @notice Sets the parameters which control the timing and frequency of\\r\\n     *         rebase operations.\\r\\n     *         a) the minimum time period that must elapse between rebase cycles.\\r\\n     *         b) the rebase window offset parameter.\\r\\n     *         c) the rebase window length parameter.\\r\\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\\r\\n     *        operations, in seconds.\\r\\n     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\\r\\n              the rebase interval, where the rebase window begins.\\r\\n     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\\r\\n     */\\r\\n    function setRebaseTimingParameters(\\r\\n        uint256 minRebaseTimeIntervalSec_,\\r\\n        uint256 rebaseWindowOffsetSec_,\\r\\n        uint256 rebaseWindowLengthSec_)\\r\\n        external\\r\\n        onlyGov\\r\\n    {\\r\\n        require(minRebaseTimeIntervalSec_ \\u003e 0);\\r\\n        require(rebaseWindowOffsetSec_ \\u003c minRebaseTimeIntervalSec_);\\r\\n\\r\\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\r\\n        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\\r\\n        rebaseWindowLengthSec = rebaseWindowLengthSec_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return If the latest block timestamp is within the rebase time window it, returns true.\\r\\n     *         Otherwise, returns false.\\r\\n     */\\r\\n    function inRebaseWindow() public view returns (bool) {\\r\\n\\r\\n        // rebasing is delayed until there is a liquid market\\r\\n        _inRebaseWindow();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _inRebaseWindow() internal view {\\r\\n        require(now.mod(minRebaseTimeIntervalSec) \\u003e= rebaseWindowOffsetSec, \\\"too early\\\");\\r\\n        require(now.mod(minRebaseTimeIntervalSec) \\u003c (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \\\"too late\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Computes in % how far off market is from peg\\r\\n     */\\r\\n    function computeOffPegPerc(uint256 rate)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        if (withinDeviationThreshold(rate)) {\\r\\n            return (0, false);\\r\\n        }\\r\\n\\r\\n        // indexDelta =  (rate - targetRate) / targetRate\\r\\n        if (rate \\u003e targetRate) {\\r\\n            return (rate.sub(targetRate).mul(10**9).div(targetRate), true);\\r\\n        } else {\\r\\n            return (targetRate.sub(rate).mul(10**9).div(targetRate), false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param rate The current exchange rate, an 18 decimal fixed point number.\\r\\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\\r\\n     *         Otherwise, returns false.\\r\\n     */\\r\\n    function withinDeviationThreshold(uint256 rate)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\\r\\n            .div(100);\\r\\n\\r\\n        return (rate \\u003c targetRate \\u0026\\u0026 targetRate.sub(rate) \\u003c absoluteDeviationThreshold);\\r\\n    }\\r\\n}\"},\"RiseSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary RiseSafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256)\\r\\n    {\\r\\n        uint256 c = add(a,m);\\r\\n        uint256 d = sub(c,1);\\r\\n        return mul(div(d,m),m);\\r\\n    }\\r\\n\\r\\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\\r\\n        require(y != 0, \\\"Div by zero\\\");\\r\\n        uint256 r = x / y;\\r\\n        if (x % y != 0) {\\r\\n            r = r + 1;\\r\\n        }\\r\\n\\r\\n        return r;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"RiseAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RiseETHPair_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeviationThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeviationThreshold\",\"type\":\"uint256\"}],\"name\":\"NewDeviationThreshold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RiseAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkIndexDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deviationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inRebaseWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nepoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseWindowLengthSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseWindowOffsetSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviationThreshold_\",\"type\":\"uint256\"}],\"name\":\"setDeviationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseLag_\",\"type\":\"uint256\"}],\"name\":\"setRebaseLag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRebaseTimeIntervalSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowOffsetSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowLengthSec_\",\"type\":\"uint256\"}],\"name\":\"setRebaseTimingParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetRate_\",\"type\":\"uint256\"}],\"name\":\"setTargetRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap_Rise_eth_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RiseRebaser","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003fa807b6f8d4c407e6e605368f4372d14658b38c0000000000000000000000005777af58135e1ffebdf925da447030f9595e30c4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0def5130c805ab4e1f651c10cb9462f4928b10e46af7d93612b7bdf0043d5ace"}]}