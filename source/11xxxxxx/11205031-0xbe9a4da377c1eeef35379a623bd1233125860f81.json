{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\ninterface ZapperFactory {\r\n    function ZapIn(\r\n        address _toWhomToIssue,\r\n        address _FromTokenContractAddress,\r\n        address _ToUnipoolToken0,\r\n        address _ToUnipoolToken1,\r\n        uint256 _amount,\r\n        uint256 _minPoolTokens\r\n    ) external payable returns (uint256);\r\n}\r\n\r\n\r\ninterface UniswapPair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function decimals() public view returns(uint);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n}\r\n\r\n\r\ncontract AdminRole {\r\n\r\n    mapping (address => bool) adminGroup;\r\n    address payable owner;\r\n\r\n    constructor () public {\r\n        adminGroup[msg.sender] = true;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyAdmin() {\r\n        require(\r\n            isAdmin(msg.sender),\r\n            \"The caller is not Admin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(\r\n            owner == msg.sender,\r\n            \"The caller is not Owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function addAdmin(address addr) external onlyAdmin {\r\n        adminGroup[addr] = true;\r\n    }\r\n    function delAdmin(address addr) external onlyAdmin {\r\n        adminGroup[addr] = false;\r\n    }\r\n\r\n    function isAdmin(address addr) public view returns(bool) {\r\n        return adminGroup[addr];\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract Withdrawable is AdminRole {\r\n    /*\r\n     * External Function to withdraw founds -> Gas or Tokens\r\n     */\r\n    function withdrawTo (address payable dst, uint founds, address token) external onlyAdmin {\r\n        if (token == address(0))\r\n            require (address(this).balance >= founds);\r\n        else {\r\n            ERC20 erc20 = ERC20(token);\r\n            require (erc20.balanceOf(address(this)) >= founds);\r\n        }\r\n        sendFounds(dst,founds, token);\r\n    }\r\n\r\n    /*\r\n     * Function to send founds -> Gas or Tokens\r\n     */\r\n    function sendFounds(address payable dst, uint amount, address token) internal returns(bool) {\r\n        ERC20 erc20;\r\n        if (token == address(0))\r\n            require(address(dst).send(amount), \"Impossible send founds\");\r\n        else {\r\n            erc20 = ERC20(token);\r\n            require(erc20.transfer(dst, amount), \"Impossible send founds\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Split is Withdrawable {\r\n    address factoryAddress = 0xE83554B397BdA8ECAE7FEE5aeE532e83Ee9eB29D;\r\n\r\n    \r\n    function changeFactory(address _factory) external onlyAdmin {\r\n        factoryAddress = _factory;\r\n    }\r\n    \r\n    function split(address _FromTokenContractAddress, uint256 amount, address[] calldata pairs) external {\r\n        uint256 len = pairs.length;\r\n        ERC20 token = ERC20(_FromTokenContractAddress);\r\n        \r\n        /*\r\n         * Minimo un elemento\r\n         */\r\n        require(len != 0, \"Pairs MUST have at least 1 element\");\r\n        \r\n        /*\r\n         * Amount mayor a 0, pero es menos costoso preguntar por != 0\r\n         */\r\n        require(amount != 0, \"Amount MUST be greater than zero\");\r\n\r\n        /*\r\n         * Primero transferimos los fondos totales al contrato\r\n         */\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"Unable to transferFrom()\");\r\n\r\n        /*\r\n         * Habilitamos al contrato que distribuye a que use nuestros fondos\r\n         */\r\n        require(token.approve(factoryAddress, amount), \"Unable to appove()\");\r\n       \r\n        /*\r\n         * Dividir el total en la cantidad de pair\r\n         */\r\n        uint256 local_amount = amount / len;\r\n        uint256 i;\r\n        for ( i = 0; i < len; i++) {\r\n            require(deposit(_FromTokenContractAddress, local_amount, pairs[i]) != 0, \"Deposit Fail\");\r\n        }\r\n       \r\n    }\r\n    \r\n    \r\n    function deposit(address _from, uint256 _amount, address _pair) internal returns(uint256) {\r\n        ZapperFactory factory = ZapperFactory(factoryAddress);    \r\n        UniswapPair pair = UniswapPair(_pair);\r\n        address token0 = pair.token0();\r\n        address token1 = pair.token1();\r\n        \r\n        return factory.ZapIn(\r\n            msg.sender,\r\n            _from,\r\n            token0,\r\n            token1,\r\n            _amount,\r\n            0\r\n        );\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"changeFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"delAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_FromTokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"split\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"founds\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Split","CompilerVersion":"v0.5.14+commit.01f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://27dc5ee19588cee525291401fa3858b73a0134a584736a3674e9961a6f500fdf"}]}