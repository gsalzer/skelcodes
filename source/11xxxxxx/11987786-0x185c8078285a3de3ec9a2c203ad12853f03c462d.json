{"status":"1","message":"OK","result":[{"SourceCode":"{\"IMasksMetadataStore.sol\":{\"content\":\"pragma solidity ^0.7.0;\\n\\ninterface IMasksMetadataStore {\\n    function getIPFSHashHexAtIndex(uint index) external view returns (bytes memory);\\n    function getTraitBytesAtIndex(uint index) external view returns (bytes3);\\n}\"},\"IMasksMinimalForRegistry.sol\":{\"content\":\"pragma solidity ^0.7.0;\\n\\ninterface IMasksMinimalForRegistry {\\n\\n    function startingIndex() external view returns (uint256);\\n    function MAX_NFT_SUPPLY() external view returns (uint256);\\n}\"},\"MasksRegistry.sol\":{\"content\":\"pragma solidity ^0.7.0;\\n\\nimport \\\"./IMasksMetadataStore.sol\\\";\\nimport \\\"./IMasksMinimalForRegistry.sol\\\";\\n\\ncontract MasksRegistry {\\n    // Public variables\\n\\n    //Constants\\n    address public constant MASKS_CONTRACT = 0xC2C747E0F7004F9E8817Db2ca4997657a7746928;\\n    address public constant DATASTORE_CONTRACT = 0x7327DbF06b1FcB0D190533fDD244B52361f0d241;\\n\\n    uint256 public startingIndexFromMasksContract;\\n    uint256 public maxMasksSupply;\\n\\n    // Internal variables\\n    bytes internal constant _ALPHABET = \\\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\\";\\n\\n    constructor() {\\n        startingIndexFromMasksContract = IMasksMinimalForRegistry(MASKS_CONTRACT).startingIndex();\\n        maxMasksSupply = IMasksMinimalForRegistry(MASKS_CONTRACT).MAX_NFT_SUPPLY();\\n    }\\n\\n    function getTraitsOfMaskId(uint256 maskId)\\n        public\\n        view\\n        returns (\\n            string memory character,\\n            string memory mask,\\n            string memory eyeColor,\\n            string memory skinColor,\\n            string memory item\\n        )\\n    {\\n        require(maskId \\u003c maxMasksSupply, \\\"Mask ID must be less than 16384\\\");\\n\\n        // Derives the index of the image in the original sequence assigned to the Mask ID\\n        uint256 correspondingOriginalSequenceIndex =\\n            (maskId + startingIndexFromMasksContract) % maxMasksSupply;\\n\\n        bytes3 traitBytes = IMasksMetadataStore(DATASTORE_CONTRACT).getTraitBytesAtIndex(\\n            correspondingOriginalSequenceIndex)\\n        ;\\n\\n        character = _extractCharacterTrait(traitBytes);\\n        mask = _extractMaskTrait(traitBytes);\\n        eyeColor = _extractEyeColorTrait(traitBytes);\\n        skinColor = _extractSkinColorTrait(traitBytes);\\n        item = _extractItemTrait(traitBytes);\\n    }\\n\\n    function getIPFSHashOfMaskId(uint256 maskId)\\n        public\\n        view\\n        returns (string memory ipfsHash)\\n    {\\n        require(maskId \\u003c maxMasksSupply, \\\"Mask ID must be less than 16384\\\");\\n\\n        // Derives the index of the image in the original sequence assigned to the Mask ID\\n        uint256 correspondingOriginalSequenceIndex =\\n            (maskId + startingIndexFromMasksContract) % maxMasksSupply;\\n\\n        ipfsHash = _getIPFSHashOfIndexInOriginalSequence(\\n            correspondingOriginalSequenceIndex\\n        );\\n    }\\n\\n    function _extractCharacterTrait(bytes3 traitBytes)\\n        internal\\n        pure\\n        returns (string memory character)\\n    {\\n        bytes1 characterBits = traitBytes[0] \\u0026 0x0F;\\n\\n        if (characterBits == 0x00) {\\n            character = \\\"Female\\\";\\n        } else if (characterBits == 0x01) {\\n            character = \\\"Golden Robot\\\";\\n        } else if (characterBits == 0x02) {\\n            character = \\\"Male\\\";\\n        } else if (characterBits == 0x03) {\\n            character = \\\"Mystical\\\";\\n        } else if (characterBits == 0x04) {\\n            character = \\\"Puppet\\\";\\n        } else if (characterBits == 0x05) {\\n            character = \\\"Robot\\\";\\n        }\\n    }\\n\\n    function _extractMaskTrait(bytes3 traitBytes)\\n        internal\\n        pure\\n        returns (string memory mask)\\n    {\\n        bytes1 maskBits = traitBytes[1] \\u003e\\u003e 4;\\n\\n        if (maskBits == 0x00) {\\n            mask = \\\"Abstract\\\";\\n        } else if (maskBits == 0x01) {\\n            mask = \\\"African\\\";\\n        } else if (maskBits == 0x02) {\\n            mask = \\\"Animal\\\";\\n        } else if (maskBits == 0x03) {\\n            mask = \\\"Aztec\\\";\\n        } else if (maskBits == 0x04) {\\n            mask = \\\"Basic\\\";\\n        } else if (maskBits == 0x05) {\\n            mask = \\\"Chinese\\\";\\n        } else if (maskBits == 0x06) {\\n            mask = \\\"Crayon\\\";\\n        } else if (maskBits == 0x07) {\\n            mask = \\\"Doodle\\\";\\n        } else if (maskBits == 0x08) {\\n            mask = \\\"Hawaiian\\\";\\n        } else if (maskBits == 0x09) {\\n            mask = \\\"Indian\\\";\\n        } else if (maskBits == 0x0A) {\\n            mask = \\\"Mexican\\\";\\n        } else if (maskBits == 0x0B) {\\n            mask = \\\"Pixel\\\";\\n        } else if (maskBits == 0x0C) {\\n            mask = \\\"Steampunk\\\";\\n        } else if (maskBits == 0x0D) {\\n            mask = \\\"Street\\\";\\n        } else if (maskBits == 0x0E) {\\n            mask = \\\"Unique\\\";\\n        } else if (maskBits == 0x0F) {\\n            mask = \\\"Unmasked\\\";\\n        }\\n    }\\n\\n    function _extractEyeColorTrait(bytes3 traitBytes)\\n        internal\\n        pure\\n        returns (string memory eyeColor)\\n    {\\n        bytes1 eyeColorBits = traitBytes[1] \\u0026 0x0F;\\n\\n        if (eyeColorBits == 0x00) {\\n            eyeColor = \\\"Blue\\\";\\n        } else if (eyeColorBits == 0x01) {\\n            eyeColor = \\\"Dark\\\";\\n        } else if (eyeColorBits == 0x02) {\\n            eyeColor = \\\"Freak\\\";\\n        } else if (eyeColorBits == 0x03) {\\n            eyeColor = \\\"Glass\\\";\\n        } else if (eyeColorBits == 0x04) {\\n            eyeColor = \\\"Green\\\";\\n        } else if (eyeColorBits == 0x05) {\\n            eyeColor = \\\"Heterochromatic\\\";\\n        } else if (eyeColorBits == 0x06) {\\n            eyeColor = \\\"Mystical\\\";\\n        } else if (eyeColorBits == 0x07) {\\n            eyeColor = \\\"Painted\\\";\\n        }\\n    }\\n\\n    function _extractSkinColorTrait(bytes3 traitBytes)\\n        internal\\n        pure\\n        returns (string memory skinColor)\\n    {\\n        bytes1 skinColorBits = traitBytes[2] \\u003e\\u003e 4;\\n\\n        if (skinColorBits == 0x00) {\\n            skinColor = \\\"Blue\\\";\\n        } else if (skinColorBits == 0x01) {\\n            skinColor = \\\"Dark\\\";\\n        } else if (skinColorBits == 0x02) {\\n            skinColor = \\\"Freak\\\";\\n        } else if (skinColorBits == 0x03) {\\n            skinColor = \\\"Gold\\\";\\n        } else if (skinColorBits == 0x04) {\\n            skinColor = \\\"Gray\\\";\\n        } else if (skinColorBits == 0x05) {\\n            skinColor = \\\"Light\\\";\\n        } else if (skinColorBits == 0x06) {\\n            skinColor = \\\"Mystical\\\";\\n        } else if (skinColorBits == 0x07) {\\n            skinColor = \\\"Steel\\\";\\n        } else if (skinColorBits == 0x08) {\\n            skinColor = \\\"Transparent\\\";\\n        } else if (skinColorBits == 0x09) {\\n            skinColor = \\\"Wood\\\";\\n        }\\n    }\\n\\n    function _extractItemTrait(bytes3 traitBytes)\\n        internal\\n        pure\\n        returns (string memory item)\\n    {\\n        bytes1 itemBits = traitBytes[2] \\u0026 0x0F;\\n\\n        if (itemBits == 0x00) {\\n            item = \\\"Book\\\";\\n        } else if (itemBits == 0x01) {\\n            item = \\\"Bottle\\\";\\n        } else if (itemBits == 0x02) {\\n            item = \\\"Golden Toilet Paper\\\";\\n        } else if (itemBits == 0x03) {\\n            item = \\\"Mirror\\\";\\n        } else if (itemBits == 0x04) {\\n            item = \\\"No Item\\\";\\n        } else if (itemBits == 0x05) {\\n            item = \\\"Shadow Monkey\\\";\\n        } else if (itemBits == 0x06) {\\n            item = \\\"Toilet Paper\\\";\\n        }\\n    }\\n\\n    function _getIPFSHashOfIndexInOriginalSequence(uint256 index)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return\\n            _toBase58(\\n                IMasksMetadataStore(DATASTORE_CONTRACT).getIPFSHashHexAtIndex(index)\\n            );\\n    }\\n\\n    // Source: verifyIPFS (https://github.com/MrChico/verifyIPFS/blob/master/contracts/verifyIPFS.sol)\\n    // @author Martin Lundfall (martin.lundfall@consensys.net)\\n    // @dev Converts hex string to base 58\\n    function _toBase58(bytes memory source)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (source.length == 0) return new string(0);\\n        uint8[] memory digits = new uint8[](46);\\n        digits[0] = 0;\\n        uint8 digitlength = 1;\\n        for (uint256 i = 0; i \\u003c source.length; ++i) {\\n            uint256 carry = uint8(source[i]);\\n            for (uint256 j = 0; j \\u003c digitlength; ++j) {\\n                carry += uint256(digits[j]) * 256;\\n                digits[j] = uint8(carry % 58);\\n                carry = carry / 58;\\n            }\\n\\n            while (carry \\u003e 0) {\\n                digits[digitlength] = uint8(carry % 58);\\n                digitlength++;\\n                carry = carry / 58;\\n            }\\n        }\\n        return string(_toAlphabet(_reverse(_truncate(digits, digitlength))));\\n    }\\n\\n    function _truncate(uint8[] memory array, uint8 length)\\n        internal\\n        pure\\n        returns (uint8[] memory)\\n    {\\n        uint8[] memory output = new uint8[](length);\\n        for (uint256 i = 0; i \\u003c length; i++) {\\n            output[i] = array[i];\\n        }\\n        return output;\\n    }\\n\\n    function _reverse(uint8[] memory input)\\n        internal\\n        pure\\n        returns (uint8[] memory)\\n    {\\n        uint8[] memory output = new uint8[](input.length);\\n        for (uint256 i = 0; i \\u003c input.length; i++) {\\n            output[i] = input[input.length - 1 - i];\\n        }\\n        return output;\\n    }\\n\\n    function _toAlphabet(uint8[] memory indices)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory output = new bytes(indices.length);\\n        for (uint256 i = 0; i \\u003c indices.length; i++) {\\n            output[i] = _ALPHABET[indices[i]];\\n        }\\n        return output;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DATASTORE_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASKS_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maskId\",\"type\":\"uint256\"}],\"name\":\"getIPFSHashOfMaskId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maskId\",\"type\":\"uint256\"}],\"name\":\"getTraitsOfMaskId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"character\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"mask\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"eyeColor\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"skinColor\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"item\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMasksSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingIndexFromMasksContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MasksRegistry","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a134511c6503343fb034740a63981dce263843744c30efc884f0c540611bc037"}]}