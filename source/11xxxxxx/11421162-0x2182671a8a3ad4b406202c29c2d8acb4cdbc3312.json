{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function approve(address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract MetaWallet {\r\n    \r\n    string public constant name = \"MetaWallet\";\r\n    \r\n    address private _owner0;\r\n    address private _owner1;\r\n    \r\n    address private _pendingOwner0;\r\n    address private _pendingOwner1;\r\n    \r\n    constructor(address owner0, address owner1) public {\r\n        _owner0 = owner0;\r\n        _owner1 = owner1;\r\n    }\r\n    \r\n    // @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the execute struct used by the contract\r\n    bytes32 public constant EXECUTE_TYPEHASH = keccak256(\"Execute(address to,uint value,bytes data,uint nonces,uint deadline)\");\r\n\r\n    /// @notice The EIP-712 typehash for the send struct used by the contract\r\n    bytes32 public constant SEND_TYPEHASH = keccak256(\"Send(address to,uint value,uint nonces,uint deadline)\");\r\n\r\n    /// @notice The EIP-712 typehash for the transfer struct used by the contract\r\n    bytes32 public constant TRANSFER_TYPEHASH = keccak256(\"Transfer(address token,address to,uint value,uint nonces,uint deadline)\");\r\n\r\n    /// @notice The EIP-712 typehash for the approve struct used by the contract\r\n    bytes32 public constant APPROVE_TYPEHASH = keccak256(\"Approve(address token,address to,uint value,uint nonces,uint deadline)\");\r\n    \r\n    function transferOwnership(address _newOwner) external {\r\n        require(msg.sender == _owner0 || msg.sender == _owner1, \"MetaWallet::transferOwnership: !owner\");\r\n        if (msg.sender == _owner0) {\r\n            _pendingOwner0 = _newOwner;\r\n        } else if (msg.sender == _owner1) {\r\n            _pendingOwner1 = _newOwner;\r\n        }\r\n    }\r\n    \r\n    function acceptOwnership() external {\r\n        require(msg.sender == _pendingOwner0 || msg.sender == _pendingOwner1, \"MetaWallet::acceptOwnership: !pendingOwner\");\r\n        if (msg.sender == _pendingOwner0) {\r\n            _owner0 = _pendingOwner0;\r\n        } else if (msg.sender == _pendingOwner1) {\r\n            _owner1 = _pendingOwner1;\r\n        }\r\n    }\r\n    \r\n    /// @notice A record of states for signing / validating signatures\r\n    uint public nonces;\r\n    \r\n    fallback() external {}\r\n    \r\n    function send(address payable to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool, bytes memory) {\r\n        require(_verify(keccak256(abi.encode(SEND_TYPEHASH, to, value, nonces++, deadline)), deadline, v, r, s));\r\n        return to.call{value: value}(\"\");\r\n    }\r\n    \r\n    function transfer(address token, address to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {\r\n        require(_verify(keccak256(abi.encode(TRANSFER_TYPEHASH, token, to, value, nonces++, deadline)), deadline, v, r, s));\r\n        return IERC20(token).transfer(to, value);\r\n    }\r\n    \r\n    function approve(address token, address to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {\r\n        require(_verify(keccak256(abi.encode(APPROVE_TYPEHASH, token, to, value, nonces++, deadline)), deadline, v, r, s));\r\n        return IERC20(token).approve(to, value);\r\n    }\r\n    \r\n    function _verify(bytes32 structHash, uint deadline, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this)));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        return ((signatory == _owner0 || signatory == _owner1) && now <= deadline);\r\n    }\r\n    \r\n    struct stack {\r\n        address recipients;\r\n        uint values;\r\n        bytes datas;\r\n        uint deadlines; \r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n    \r\n    function batch(stack[] calldata stacks) external returns (bool[] memory results, bytes[] memory responses) {\r\n        for (uint i = 0; i < stacks.length; i++) {\r\n            (results[i], responses[i]) = _exec(stacks[i].recipients, stacks[i].values, stacks[i].datas, stacks[i].deadlines, stacks[i].v, stacks[i].r, stacks[i].s);\r\n        }\r\n    }\r\n    \r\n    function execute(address to, uint value, bytes calldata data, uint deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool, bytes memory) {\r\n        return _exec(to, value, data, deadline, v, r, s);\r\n    }\r\n    \r\n    function _exec(address to, uint value, bytes memory data, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool, bytes memory) {\r\n        require(_verify(keccak256(abi.encode(EXECUTE_TYPEHASH, to, value, data, nonces++, deadline)), deadline, v, r, s));\r\n        return to.call{value: value}(data);\r\n    }\r\n    \r\n    function _getChainId() internal pure returns (uint) {\r\n        uint chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n\r\ncontract MetaWalletFactory {\r\n    \r\n    struct stack {\r\n        address wallet;\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n        uint deadline; \r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n    \r\n    struct id {\r\n        uint index0;\r\n        address owner0;\r\n        uint index1;\r\n        address owner1;\r\n    }\r\n    \r\n    mapping(address => address[]) public lookups;\r\n    mapping(address => id) public indexes;\r\n    \r\n    function lookup(address wallet) external view returns (uint index0, address owner0, uint index1, address owner1) {\r\n        return (indexes[wallet].index0, indexes[wallet].owner0, indexes[wallet].index1, indexes[wallet].owner1);\r\n    }\r\n    \r\n    function wallet(address owner, uint index) external view returns (address) {\r\n        return lookups[owner][index];\r\n    }\r\n    \r\n    function wallets(address owner) external view returns (address[] memory) {\r\n        return lookups[owner];\r\n    }\r\n    \r\n    function createWallet(address _owner0, address _owner1) external {\r\n        address _wallet = address(new MetaWallet(_owner0, _owner1));\r\n        indexes[_wallet] = id(lookups[_owner0].length, _owner0, lookups[_owner1].length, _owner1);\r\n        lookups[_owner0].push(_wallet);\r\n        lookups[_owner1].push(_wallet);\r\n        \r\n    }\r\n    \r\n    function batch(stack[] calldata stacks) external returns (bool[] memory results, bytes[] memory responses) {\r\n        for (uint i = 0; i < stacks.length; i++) {\r\n            (results[i], responses[i]) = MetaWallet(stacks[i].wallet).execute(stacks[i].to, stacks[i].value, stacks[i].data, stacks[i].deadline, stacks[i].v, stacks[i].r, stacks[i].s);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct MetaWalletFactory.stack[]\",\"name\":\"stacks\",\"type\":\"tuple[]\"}],\"name\":\"batch\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"results\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"responses\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner1\",\"type\":\"address\"}],\"name\":\"createWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index0\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"lookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index0\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lookups\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MetaWalletFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1c09ca692b4819ab04c888c192cf73ec535b6c2f8a76624c48a5cccdd80e3564"}]}