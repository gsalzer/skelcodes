{"status":"1","message":"OK","result":[{"SourceCode":"// The Component Protocol is fork of the Shell Protocol\r\n// Original source code link: https://github.com/cowri/shell-solidity-v1\r\n\r\npragma solidity >0.4.13 >=0.4.23 >=0.5.0 <0.6.0 >=0.5.7 <0.6.0;\r\n\r\n////// lib/abdk-libraries-solidity/src/ABDKMath64x64.sol\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /**\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n////// src/interfaces/IAssimilator.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\ninterface IAssimilator {\r\n    function intakeRaw (uint256 amount) external returns (int128);\r\n    function intakeRawAndGetBalance (uint256 amount) external returns (int128, int128);\r\n    function intakeNumeraire (int128 amount) external returns (uint256);\r\n    function outputRaw (address dst, uint256 amount) external returns (int128);\r\n    function outputRawAndGetBalance (address dst, uint256 amount) external returns (int128, int128);\r\n    function outputNumeraire (address dst, int128 amount) external returns (uint256);\r\n    function viewRawAmount (int128) external view returns (uint256);\r\n    function viewNumeraireAmount (uint256) external view returns (int128);\r\n    function viewNumeraireBalance (address) external view returns (int128);\r\n    function viewNumeraireAmountAndBalance (address, uint256) external view returns (int128, int128);\r\n}\r\n////// src/Assimilators.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nlibrary Assimilators {\r\n\r\n    using ABDKMath64x64 for int128;\r\n    IAssimilator constant iAsmltr = IAssimilator(address(0));\r\n\r\n    function delegate(address _callee, bytes memory _data) internal returns (bytes memory) {\r\n\r\n        (bool _success, bytes memory returnData_) = _callee.delegatecall(_data);\r\n\r\n        assembly { if eq(_success, 0) { revert(add(returnData_, 0x20), returndatasize()) } }\r\n\r\n        return returnData_;\r\n\r\n    }\r\n\r\n    function viewRawAmount (address _assim, int128 _amt) internal view returns (uint256 amount_) {\r\n\r\n        amount_ = IAssimilator(_assim).viewRawAmount(_amt);\r\n\r\n    }\r\n\r\n    function viewNumeraireAmount (address _assim, uint256 _amt) internal view returns (int128 amt_) {\r\n\r\n        amt_ = IAssimilator(_assim).viewNumeraireAmount(_amt);\r\n\r\n    }\r\n\r\n    function viewNumeraireAmountAndBalance (address _assim, uint256 _amt) internal view returns (int128 amt_, int128 bal_) {\r\n\r\n        ( amt_, bal_ ) = IAssimilator(_assim).viewNumeraireAmountAndBalance(address(this), _amt);\r\n\r\n    }\r\n\r\n    function viewNumeraireBalance (address _assim) internal view returns (int128 bal_) {\r\n\r\n        bal_ = IAssimilator(_assim).viewNumeraireBalance(address(this));\r\n\r\n    }\r\n\r\n    function intakeRaw (address _assim, uint256 _amt) internal returns (int128 amt_) {\r\n\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.intakeRaw.selector, _amt);\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (int128));\r\n\r\n    }\r\n\r\n    function intakeRawAndGetBalance (address _assim, uint256 _amt) internal returns (int128 amt_, int128 bal_) {\r\n\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.intakeRawAndGetBalance.selector, _amt);\r\n\r\n        ( amt_, bal_ ) = abi.decode(delegate(_assim, data), (int128,int128));\r\n\r\n    }\r\n\r\n    function intakeNumeraire (address _assim, int128 _amt) internal returns (uint256 amt_) {\r\n\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.intakeNumeraire.selector, _amt);\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (uint256));\r\n\r\n    }\r\n\r\n    function outputRaw (address _assim, address _dst, uint256 _amt) internal returns (int128 amt_ ) {\r\n\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.outputRaw.selector, _dst, _amt);\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (int128));\r\n\r\n        amt_ = amt_.neg();\r\n\r\n    }\r\n\r\n    function outputRawAndGetBalance (address _assim, address _dst, uint256 _amt) internal returns (int128 amt_, int128 bal_) {\r\n\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.outputRawAndGetBalance.selector, _dst, _amt);\r\n\r\n        ( amt_, bal_ ) = abi.decode(delegate(_assim, data), (int128,int128));\r\n\r\n        amt_ = amt_.neg();\r\n\r\n    }\r\n\r\n    function outputNumeraire (address _assim, address _dst, int128 _amt) internal returns (uint256 amt_) {\r\n\r\n        bytes memory data = abi.encodeWithSelector(iAsmltr.outputNumeraire.selector, _dst, _amt.abs());\r\n\r\n        amt_ = abi.decode(delegate(_assim, data), (uint256));\r\n\r\n    }\r\n\r\n}\r\n\r\nlibrary UnsafeMath64x64 {\r\n\r\n  /**\r\n   * Calculate x * y rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n\r\n  function us_mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n\r\n  function us_div (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = (int256 (x) << 64) / y;\r\n    return int128 (result);\r\n  }\r\n\r\n}\r\n\r\nlibrary PartitionedLiquidity {\r\n\r\n    using ABDKMath64x64 for uint;\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n\r\n    event PoolPartitioned(bool);\r\n\r\n    event PartitionRedeemed(address indexed token, address indexed redeemer, uint value);\r\n\r\n    int128 constant ONE = 0x10000000000000000;\r\n\r\n    function partition (\r\n        ComponentStorage.Component storage component,\r\n        mapping (address => ComponentStorage.PartitionTicket) storage partitionTickets\r\n    ) external {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        ComponentStorage.PartitionTicket storage totalSupplyTicket = partitionTickets[address(this)];\r\n\r\n        totalSupplyTicket.initialized = true;\r\n\r\n        for (uint i = 0; i < _length; i++) totalSupplyTicket.claims.push(component.totalSupply);\r\n\r\n        emit PoolPartitioned(true);\r\n\r\n    }\r\n\r\n    function viewPartitionClaims (\r\n        ComponentStorage.Component storage component,\r\n        mapping (address => ComponentStorage.PartitionTicket) storage partitionTickets,\r\n        address _addr\r\n    ) external view returns (\r\n        uint[] memory claims_\r\n    ) {\r\n\r\n        ComponentStorage.PartitionTicket storage ticket = partitionTickets[_addr];\r\n\r\n        if (ticket.initialized) return ticket.claims;\r\n\r\n        uint _length = component.assets.length;\r\n        claims_ = new uint[](_length);\r\n        uint _balance = component.balances[msg.sender];\r\n\r\n        for (uint i = 0; i < _length; i++) claims_[i] = _balance;\r\n\r\n        return claims_;\r\n\r\n    }\r\n\r\n    function partitionedWithdraw (\r\n        ComponentStorage.Component storage component,\r\n        mapping (address => ComponentStorage.PartitionTicket) storage partitionTickets,\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _withdrawals\r\n    ) external returns (\r\n        uint[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n        uint _balance = component.balances[msg.sender];\r\n\r\n        ComponentStorage.PartitionTicket storage totalSuppliesTicket = partitionTickets[address(this)];\r\n        ComponentStorage.PartitionTicket storage ticket = partitionTickets[msg.sender];\r\n\r\n        if (!ticket.initialized) {\r\n\r\n            for (uint i = 0; i < _length; i++) ticket.claims.push(_balance);\r\n            ticket.initialized = true;\r\n\r\n        }\r\n\r\n        _length = _derivatives.length;\r\n\r\n        uint[] memory withdrawals_ = new uint[](_length);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            ComponentStorage.Assimilator memory _assim = component.assimilators[_derivatives[i]];\r\n\r\n            require(totalSuppliesTicket.claims[_assim.ix] >= _withdrawals[i], \"Component/burn-exceeds-total-supply\");\r\n\r\n            require(ticket.claims[_assim.ix] >= _withdrawals[i], \"Component/insufficient-balance\");\r\n\r\n            require(_assim.addr != address(0), \"Component/unsupported-asset\");\r\n\r\n            int128 _reserveBalance = Assimilators.viewNumeraireBalance(_assim.addr);\r\n\r\n            int128 _multiplier = _withdrawals[i].divu(1e18)\r\n                .div(totalSuppliesTicket.claims[_assim.ix].divu(1e18));\r\n\r\n            totalSuppliesTicket.claims[_assim.ix] = totalSuppliesTicket.claims[_assim.ix] - _withdrawals[i];\r\n\r\n            ticket.claims[_assim.ix] = ticket.claims[_assim.ix] - _withdrawals[i];\r\n\r\n            uint _withdrawal = Assimilators.outputNumeraire(\r\n                _assim.addr,\r\n                msg.sender,\r\n                _reserveBalance.mul(_multiplier)\r\n            );\r\n\r\n            withdrawals_[i] = _withdrawal;\r\n\r\n            emit PartitionRedeemed(_derivatives[i], msg.sender, withdrawals_[i]);\r\n\r\n        }\r\n\r\n        return withdrawals_;\r\n\r\n    }\r\n\r\n}\r\n\r\nlibrary ProportionalLiquidity {\r\n\r\n    using ABDKMath64x64 for uint;\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    int128 constant ONE = 0x10000000000000000;\r\n    int128 constant ONE_WEI = 0x12;\r\n\r\n    function proportionalDeposit (\r\n        ComponentStorage.Component storage component,\r\n        uint256 _deposit\r\n    ) external returns (\r\n        uint256 components_,\r\n        uint[] memory\r\n    ) {\r\n\r\n        int128 __deposit = _deposit.divu(1e18);\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        uint[] memory deposits_ = new uint[](_length);\r\n\r\n        ( int128 _oGLiq, int128[] memory _oBals ) = getGrossLiquidityAndBalances(component);\r\n\r\n        if (_oGLiq == 0) {\r\n\r\n            for (uint i = 0; i < _length; i++) {\r\n\r\n                deposits_[i] = Assimilators.intakeNumeraire(component.assets[i].addr, __deposit.mul(component.weights[i]));\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n            int128 _multiplier = __deposit.div(_oGLiq);\r\n\r\n            for (uint i = 0; i < _length; i++) {\r\n\r\n                deposits_[i] = Assimilators.intakeNumeraire(component.assets[i].addr, _oBals[i].mul(_multiplier));\r\n\r\n            }\r\n\r\n        }\r\n\r\n        int128 _totalComponents = component.totalSupply.divu(1e18);\r\n\r\n        int128 _newComponents = _totalComponents > 0\r\n            ? __deposit.div(_oGLiq).mul(_totalComponents)\r\n            : __deposit;\r\n\r\n        requireLiquidityInvariant(\r\n            component,\r\n          _totalComponents,\r\n          _newComponents,\r\n            _oGLiq,\r\n            _oBals\r\n        );\r\n\r\n        mint(component, msg.sender, components_ = _newComponents.mulu(1e18));\r\n\r\n        return (components_, deposits_);\r\n\r\n    }\r\n\r\n\r\n    function viewProportionalDeposit (\r\n        ComponentStorage.Component storage component,\r\n        uint256 _deposit\r\n    ) external view returns (\r\n        uint components_,\r\n        uint[] memory\r\n    ) {\r\n\r\n        int128 __deposit = _deposit.divu(1e18);\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        ( int128 _oGLiq, int128[] memory _oBals ) = getGrossLiquidityAndBalances(component);\r\n\r\n        uint[] memory deposits_ = new uint[](_length);\r\n\r\n        if (_oGLiq == 0) {\r\n\r\n            for (uint i = 0; i < _length; i++) {\r\n\r\n                deposits_[i] = Assimilators.viewRawAmount(\r\n                    component.assets[i].addr,\r\n                    __deposit.mul(component.weights[i])\r\n                );\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n            int128 _multiplier = __deposit.div(_oGLiq);\r\n\r\n            for (uint i = 0; i < _length; i++) {\r\n\r\n                deposits_[i] = Assimilators.viewRawAmount(\r\n                    component.assets[i].addr,\r\n                    _oBals[i].mul(_multiplier)\r\n                );\r\n\r\n            }\r\n\r\n        }\r\n\r\n        int128 _totalComponents = component.totalSupply.divu(1e18);\r\n\r\n        int128 _newComponents = _totalComponents > 0\r\n            ? __deposit.div(_oGLiq).mul(_totalComponents)\r\n            : __deposit;\r\n\r\n        components_ = _newComponents.mulu(1e18);\r\n\r\n        return (components_, deposits_ );\r\n\r\n    }\r\n\r\n    function proportionalWithdraw (\r\n        ComponentStorage.Component storage component,\r\n        uint256 _withdrawal\r\n    ) external returns (\r\n        uint[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        ( int128 _oGLiq, int128[] memory _oBals ) = getGrossLiquidityAndBalances(component);\r\n\r\n        uint[] memory withdrawals_ = new uint[](_length);\r\n\r\n        int128 _totalComponents = component.totalSupply.divu(1e18);\r\n        int128 __withdrawal = _withdrawal.divu(1e18);\r\n\r\n        int128 _multiplier = __withdrawal\r\n            .mul(ONE - component.epsilon)\r\n            .div(_totalComponents);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            withdrawals_[i] = Assimilators.outputNumeraire(\r\n                component.assets[i].addr,\r\n                msg.sender,\r\n                _oBals[i].mul(_multiplier)\r\n            );\r\n\r\n        }\r\n\r\n        requireLiquidityInvariant(\r\n            component,\r\n          _totalComponents,\r\n            __withdrawal.neg(),\r\n            _oGLiq,\r\n            _oBals\r\n        );\r\n\r\n        burn(component, msg.sender, _withdrawal);\r\n\r\n        return withdrawals_;\r\n\r\n    }\r\n\r\n    function viewProportionalWithdraw (\r\n        ComponentStorage.Component storage component,\r\n        uint256 _withdrawal\r\n    ) external view returns (\r\n        uint[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        ( , int128[] memory _oBals ) = getGrossLiquidityAndBalances(component);\r\n\r\n        uint[] memory withdrawals_ = new uint[](_length);\r\n\r\n        int128 _multiplier = _withdrawal.divu(1e18)\r\n            .mul(ONE - component.epsilon)\r\n            .div(component.totalSupply.divu(1e18));\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            withdrawals_[i] = Assimilators.viewRawAmount(component.assets[i].addr, _oBals[i].mul(_multiplier));\r\n\r\n        }\r\n\r\n        return withdrawals_;\r\n\r\n    }\r\n\r\n    function getGrossLiquidityAndBalances (\r\n        ComponentStorage.Component storage component\r\n    ) internal view returns (\r\n        int128 grossLiquidity_,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        int128[] memory balances_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            int128 _bal = Assimilators.viewNumeraireBalance(component.assets[i].addr);\r\n\r\n            balances_[i] = _bal;\r\n            grossLiquidity_ += _bal;\r\n\r\n        }\r\n\r\n        return (grossLiquidity_, balances_);\r\n\r\n    }\r\n\r\n    function requireLiquidityInvariant (\r\n        ComponentStorage.Component storage component,\r\n        int128 _components,\r\n        int128 _newComponents,\r\n        int128 _oGLiq,\r\n        int128[] memory _oBals\r\n    ) private view {\r\n\r\n        ( int128 _nGLiq, int128[] memory _nBals ) = getGrossLiquidityAndBalances(component);\r\n\r\n        int128 _beta = component.beta;\r\n        int128 _delta = component.delta;\r\n        int128[] memory _weights = component.weights;\r\n\r\n        int128 _omega = ComponentMath.calculateFee(_oGLiq, _oBals, _beta, _delta, _weights);\r\n\r\n        int128 _psi = ComponentMath.calculateFee(_nGLiq, _nBals, _beta, _delta, _weights);\r\n\r\n        ComponentMath.enforceLiquidityInvariant(_components, _newComponents, _oGLiq, _nGLiq, _omega, _psi);\r\n\r\n    }\r\n\r\n    function burn (ComponentStorage.Component storage component, address account, uint256 amount) private {\r\n\r\n        component.balances[account] = burn_sub(component.balances[account], amount);\r\n\r\n        component.totalSupply = burn_sub(component.totalSupply, amount);\r\n\r\n        emit Transfer(msg.sender, address(0), amount);\r\n\r\n    }\r\n\r\n    function mint (ComponentStorage.Component storage component, address account, uint256 amount) private {\r\n\r\n        component.totalSupply = mint_add(component.totalSupply, amount);\r\n\r\n        component.balances[account] = mint_add(component.balances[account], amount);\r\n\r\n        emit Transfer(address(0), msg.sender, amount);\r\n\r\n    }\r\n\r\n    function mint_add(uint x, uint y) private pure returns (uint z) {\r\n\r\n        require((z = x + y) >= x, \"Component/mint-overflow\");\r\n\r\n    }\r\n\r\n    function burn_sub(uint x, uint y) private pure returns (uint z) {\r\n\r\n        require((z = x - y) <= x, \"Component/burn-underflow\");\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\nlibrary SelectiveLiquidity {\r\n\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    int128 constant ONE = 0x10000000000000000;\r\n\r\n    function selectiveDeposit (\r\n        ComponentStorage.Component storage component,\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts,\r\n        uint _minComponents\r\n    ) external returns (\r\n        uint components_\r\n    ) {\r\n\r\n        (   int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _oBals,\r\n            int128[] memory _nBals ) = getLiquidityDepositData(component, _derivatives, _amounts);\r\n\r\n        int128 _components = ComponentMath.calculateLiquidityMembrane(component, _oGLiq, _nGLiq, _oBals, _nBals);\r\n\r\n        components_ = _components.mulu(1e18);\r\n\r\n        require(_minComponents < components_, \"Component/under-minimum-components\");\r\n\r\n        mint(component, msg.sender, components_);\r\n\r\n    }\r\n\r\n    function viewSelectiveDeposit (\r\n        ComponentStorage.Component storage component,\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts\r\n    ) external view returns (\r\n        uint components_\r\n    ) {\r\n\r\n        (   int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _oBals,\r\n            int128[] memory _nBals ) = viewLiquidityDepositData(component, _derivatives, _amounts);\r\n\r\n        int128 _components = ComponentMath.calculateLiquidityMembrane(component, _oGLiq, _nGLiq, _oBals, _nBals);\r\n\r\n        components_ = _components.mulu(1e18);\r\n\r\n    }\r\n\r\n    function selectiveWithdraw (\r\n        ComponentStorage.Component storage component,\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts,\r\n        uint _maxComponents\r\n    ) external returns (\r\n        uint256 components_\r\n    ) {\r\n\r\n        (   int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _oBals,\r\n            int128[] memory _nBals ) = getLiquidityWithdrawData(component, _derivatives, msg.sender, _amounts);\r\n\r\n        int128 _components = ComponentMath.calculateLiquidityMembrane(component, _oGLiq, _nGLiq, _oBals, _nBals);\r\n\r\n        _components = _components.neg().us_mul(ONE + component.epsilon);\r\n\r\n        components_ = _components.mulu(1e18);\r\n\r\n        require(components_ < _maxComponents, \"Component/above-maximum-components\");\r\n\r\n        burn(component, msg.sender, components_);\r\n\r\n    }\r\n\r\n    function viewSelectiveWithdraw (\r\n        ComponentStorage.Component storage component,\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts\r\n    ) external view returns (\r\n        uint components_\r\n    ) {\r\n\r\n        (   int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _oBals,\r\n            int128[] memory _nBals ) = viewLiquidityWithdrawData(component, _derivatives, _amounts);\r\n\r\n        int128 _components = ComponentMath.calculateLiquidityMembrane(component, _oGLiq, _nGLiq, _oBals, _nBals);\r\n\r\n        _components = _components.neg().us_mul(ONE + component.epsilon);\r\n\r\n        components_ = _components.mulu(1e18);\r\n\r\n    }\r\n\r\n    function getLiquidityDepositData (\r\n        ComponentStorage.Component storage component,\r\n        address[] memory _derivatives,\r\n        uint[] memory _amounts\r\n    ) private returns (\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.weights.length;\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _derivatives.length; i++) {\r\n\r\n            ComponentStorage.Assimilator memory _assim = component.assimilators[_derivatives[i]];\r\n\r\n            require(_assim.addr != address(0), \"Component/unsupported-derivative\");\r\n\r\n            if ( nBals_[_assim.ix] == 0 && 0 == oBals_[_assim.ix]) {\r\n\r\n                ( int128 _amount, int128 _balance ) = Assimilators.intakeRawAndGetBalance(_assim.addr, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = _balance;\r\n\r\n                oBals_[_assim.ix] = _balance.sub(_amount);\r\n\r\n            } else {\r\n\r\n                int128 _amount = Assimilators.intakeRaw(_assim.addr, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = nBals_[_assim.ix].add(_amount);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return completeLiquidityData(component, oBals_, nBals_);\r\n\r\n    }\r\n\r\n    function getLiquidityWithdrawData (\r\n        ComponentStorage.Component storage component,\r\n        address[] memory _derivatives,\r\n        address _rcpnt,\r\n        uint[] memory _amounts\r\n    ) private returns (\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.weights.length;\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _derivatives.length; i++) {\r\n\r\n            ComponentStorage.Assimilator memory _assim = component.assimilators[_derivatives[i]];\r\n\r\n            require(_assim.addr != address(0), \"Component/unsupported-derivative\");\r\n\r\n            if ( nBals_[_assim.ix] == 0 && 0 == oBals_[_assim.ix]) {\r\n\r\n                ( int128 _amount, int128 _balance ) = Assimilators.outputRawAndGetBalance(_assim.addr, _rcpnt, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = _balance;\r\n                oBals_[_assim.ix] = _balance.sub(_amount);\r\n\r\n            } else {\r\n\r\n                int128 _amount = Assimilators.outputRaw(_assim.addr, _rcpnt, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = nBals_[_assim.ix].add(_amount);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return completeLiquidityData(component, oBals_, nBals_);\r\n\r\n    }\r\n\r\n    function viewLiquidityDepositData (\r\n        ComponentStorage.Component storage component,\r\n        address[] memory _derivatives,\r\n        uint[] memory _amounts\r\n    ) private view returns (\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _derivatives.length; i++) {\r\n\r\n            ComponentStorage.Assimilator memory _assim = component.assimilators[_derivatives[i]];\r\n\r\n            require(_assim.addr != address(0), \"Component/unsupported-derivative\");\r\n\r\n            if ( nBals_[_assim.ix] == 0 && 0 == oBals_[_assim.ix]) {\r\n\r\n                ( int128 _amount, int128 _balance ) = Assimilators.viewNumeraireAmountAndBalance(_assim.addr, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = _balance.add(_amount);\r\n\r\n                oBals_[_assim.ix] = _balance;\r\n\r\n            } else {\r\n\r\n                int128 _amount = Assimilators.viewNumeraireAmount(_assim.addr, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = nBals_[_assim.ix].add(_amount);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return completeLiquidityData(component, oBals_, nBals_);\r\n\r\n    }\r\n\r\n    function viewLiquidityWithdrawData (\r\n        ComponentStorage.Component storage component,\r\n        address[] memory _derivatives,\r\n        uint[] memory _amounts\r\n    ) private view returns (\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _derivatives.length; i++) {\r\n\r\n            ComponentStorage.Assimilator memory _assim = component.assimilators[_derivatives[i]];\r\n\r\n            require(_assim.addr != address(0), \"Component/unsupported-derivative\");\r\n\r\n            if ( nBals_[_assim.ix] == 0 && 0 == oBals_[_assim.ix]) {\r\n\r\n                ( int128 _amount, int128 _balance ) = Assimilators.viewNumeraireAmountAndBalance(_assim.addr, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = _balance.sub(_amount);\r\n\r\n                oBals_[_assim.ix] = _balance;\r\n\r\n            } else {\r\n\r\n                int128 _amount = Assimilators.viewNumeraireAmount(_assim.addr, _amounts[i]);\r\n\r\n                nBals_[_assim.ix] = nBals_[_assim.ix].sub(_amount);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return completeLiquidityData(component, oBals_, nBals_);\r\n\r\n    }\r\n\r\n    function completeLiquidityData (\r\n        ComponentStorage.Component storage component,\r\n        int128[] memory oBals_,\r\n        int128[] memory nBals_\r\n    ) private view returns (\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = oBals_.length;\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            if (oBals_[i] == 0 && 0 == nBals_[i]) {\r\n\r\n                nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(component.assets[i].addr);\r\n\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n\r\n        }\r\n\r\n        return ( oGLiq_, nGLiq_, oBals_, nBals_ );\r\n\r\n    }\r\n\r\n    function burn (ComponentStorage.Component storage component, address account, uint256 amount) private {\r\n\r\n        component.balances[account] = burn_sub(component.balances[account], amount);\r\n\r\n        component.totalSupply = burn_sub(component.totalSupply, amount);\r\n\r\n        emit Transfer(msg.sender, address(0), amount);\r\n\r\n    }\r\n\r\n    function mint (ComponentStorage.Component storage component, address account, uint256 amount) private {\r\n\r\n        component.totalSupply = mint_add(component.totalSupply, amount);\r\n\r\n        component.balances[account] = mint_add(component.balances[account], amount);\r\n\r\n        emit Transfer(address(0), msg.sender, amount);\r\n\r\n    }\r\n\r\n    function mint_add(uint x, uint y) private pure returns (uint z) {\r\n        require((z = x + y) >= x, \"Component/mint-overflow\");\r\n    }\r\n\r\n    function burn_sub(uint x, uint y) private pure returns (uint z) {\r\n        require((z = x - y) <= x, \"Component/burn-underflow\");\r\n    }\r\n\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nlibrary Components {\r\n\r\n    using ABDKMath64x64 for int128;\r\n\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function add(uint x, uint y, string memory errorMessage) private pure returns (uint z) {\r\n        require((z = x + y) >= x, errorMessage);\r\n    }\r\n\r\n    function sub(uint x, uint y, string memory errorMessage) private pure returns (uint z) {\r\n        require((z = x - y) <= x, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(ComponentStorage.Component storage component, address recipient, uint256 amount) external returns (bool) {\r\n        _transfer(component, msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(ComponentStorage.Component storage component, address spender, uint256 amount) external returns (bool) {\r\n        _approve(component, msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`\r\n     */\r\n    function transferFrom(ComponentStorage.Component storage component, address sender, address recipient, uint256 amount) external returns (bool) {\r\n        _transfer(component, sender, recipient, amount);\r\n        _approve(component, sender, msg.sender, sub(component.allowances[sender][msg.sender], amount, \"Component/insufficient-allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(ComponentStorage.Component storage component, address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(component, msg.sender, spender, add(component.allowances[msg.sender][spender], addedValue, \"Component/approval-overflow\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(ComponentStorage.Component storage component, address spender, uint256 subtractedValue) external returns (bool) {\r\n        _approve(component, msg.sender, spender, sub(component.allowances[msg.sender][spender], subtractedValue, \"Component/allowance-decrease-underflow\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is public function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(ComponentStorage.Component storage component, address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        component.balances[sender] = sub(component.balances[sender], amount, \"Component/insufficient-balance\");\r\n        component.balances[recipient] = add(component.balances[recipient], amount, \"Component/transfer-overflow\");\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\r\n     *\r\n     * This is public function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(ComponentStorage.Component storage component, address _owner, address spender, uint256 amount) private {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        component.allowances[_owner][spender] = amount;\r\n        emit Approval(_owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\nlibrary Swaps {\r\n\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n\r\n    event Trade(address indexed trader, address indexed origin, address indexed target, uint256 originAmount, uint256 targetAmount);\r\n\r\n    int128 constant ONE = 0x10000000000000000;\r\n\r\n    function getOriginAndTarget (\r\n        ComponentStorage.Component storage component,\r\n        address _o,\r\n        address _t\r\n    ) private view returns (\r\n        ComponentStorage.Assimilator memory,\r\n        ComponentStorage.Assimilator memory\r\n    ) {\r\n\r\n        ComponentStorage.Assimilator memory o_ = component.assimilators[_o];\r\n        ComponentStorage.Assimilator memory t_ = component.assimilators[_t];\r\n\r\n        require(o_.addr != address(0), \"Component/origin-not-supported\");\r\n        require(t_.addr != address(0), \"Component/target-not-supported\");\r\n\r\n        return ( o_, t_ );\r\n\r\n    }\r\n\r\n\r\n    function originSwap (\r\n        ComponentStorage.Component storage component,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _originAmount,\r\n        address _recipient\r\n    ) external returns (\r\n        uint256 tAmt_\r\n    ) {\r\n\r\n        (   ComponentStorage.Assimilator memory _o,\r\n            ComponentStorage.Assimilator memory _t  ) = getOriginAndTarget(component, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix) return Assimilators.outputNumeraire(_t.addr, _recipient, Assimilators.intakeRaw(_o.addr, _originAmount));\r\n\r\n        (   int128 _amt,\r\n            int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _oBals,\r\n            int128[] memory _nBals ) = getOriginSwapData(component, _o.ix, _t.ix, _o.addr, _originAmount);\r\n\r\n        _amt = ComponentMath.calculateTrade(component, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _t.ix);\r\n\r\n        settleProtocolShare(component, _t.addr, _amt);\r\n\r\n        _amt = component.epsilon.us_mul(component.sigma);\r\n\r\n        tAmt_ = Assimilators.outputNumeraire(_t.addr, _recipient, _amt);\r\n\r\n        emit Trade(msg.sender, _origin, _target, _originAmount, tAmt_);\r\n\r\n    }\r\n\r\n    function viewOriginSwap (\r\n        ComponentStorage.Component storage component,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _originAmount\r\n    ) external view returns (\r\n        uint256 tAmt_\r\n    ) {\r\n\r\n        (   ComponentStorage.Assimilator memory _o,\r\n            ComponentStorage.Assimilator memory _t  ) = getOriginAndTarget(component, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix) return Assimilators.viewRawAmount(_t.addr, Assimilators.viewNumeraireAmount(_o.addr, _originAmount));\r\n\r\n        (   int128 _amt,\r\n            int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _nBals,\r\n            int128[] memory _oBals ) = viewOriginSwapData(component, _o.ix, _t.ix, _originAmount, _o.addr);\r\n\r\n        _amt = ComponentMath.calculateTrade(component, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _t.ix);\r\n\r\n        _amt = _amt.us_mul(ONE - component.epsilon);\r\n\r\n        tAmt_ = Assimilators.viewRawAmount(_t.addr, _amt.abs());\r\n\r\n    }\r\n\r\n    function targetSwap (\r\n        ComponentStorage.Component storage component,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _targetAmount,\r\n        address _recipient\r\n    ) external returns (\r\n        uint256 oAmt_\r\n    ) {\r\n\r\n        (   ComponentStorage.Assimilator memory _o,\r\n            ComponentStorage.Assimilator memory _t  ) = getOriginAndTarget(component, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix) return Assimilators.intakeNumeraire(_o.addr, Assimilators.outputRaw(_t.addr, _recipient, _targetAmount));\r\n\r\n        (   int128 _amt,\r\n            int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _oBals,\r\n            int128[] memory _nBals) = getTargetSwapData(component, _t.ix, _o.ix, _t.addr, _recipient, _targetAmount);\r\n\r\n        _amt = ComponentMath.calculateTrade(component, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _o.ix);\r\n\r\n        int128 _amtWFee = _amt.us_mul(ONE + component.epsilon);\r\n\r\n        oAmt_ = Assimilators.intakeNumeraire(_o.addr, _amtWFee);\r\n\r\n        settleProtocolShare(component, _o.addr, _amtWFee);\r\n\r\n        emit Trade(msg.sender, _origin, _target, oAmt_, _targetAmount);\r\n\r\n    }\r\n\r\n    function viewTargetSwap (\r\n        ComponentStorage.Component storage component,\r\n        address _origin,\r\n        address _target,\r\n        uint256 _targetAmount\r\n    ) external view returns (\r\n        uint256 oAmt_\r\n    ) {\r\n\r\n        (   ComponentStorage.Assimilator memory _o,\r\n            ComponentStorage.Assimilator memory _t  ) = getOriginAndTarget(component, _origin, _target);\r\n\r\n        if (_o.ix == _t.ix) return Assimilators.viewRawAmount(_o.addr, Assimilators.viewNumeraireAmount(_t.addr, _targetAmount));\r\n\r\n        (   int128 _amt,\r\n            int128 _oGLiq,\r\n            int128 _nGLiq,\r\n            int128[] memory _nBals,\r\n            int128[] memory _oBals ) = viewTargetSwapData(component, _t.ix, _o.ix, _targetAmount, _t.addr);\r\n\r\n        _amt = ComponentMath.calculateTrade(component, _oGLiq, _nGLiq, _oBals, _nBals, _amt, _o.ix);\r\n\r\n        _amt = _amt.us_mul(ONE + component.epsilon);\r\n\r\n        oAmt_ = Assimilators.viewRawAmount(_o.addr, _amt);\r\n\r\n    }\r\n\r\n    function getOriginSwapData (\r\n        ComponentStorage.Component storage component,\r\n        uint _inputIx,\r\n        uint _outputIx,\r\n        address _assim,\r\n        uint _amt\r\n    ) private returns (\r\n        int128 amt_,\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        ComponentStorage.Assimilator[] memory _reserves = component.assets;\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(_reserves[i].addr);\r\n            else {\r\n\r\n                int128 _bal;\r\n                ( amt_, _bal ) = Assimilators.intakeRawAndGetBalance(_assim, _amt);\r\n\r\n                oBals_[i] = _bal.sub(amt_);\r\n                nBals_[i] = _bal;\r\n\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return ( amt_, oGLiq_, nGLiq_, oBals_, nBals_ );\r\n\r\n    }\r\n\r\n    function getTargetSwapData (\r\n        ComponentStorage.Component storage component,\r\n        uint _inputIx,\r\n        uint _outputIx,\r\n        address _assim,\r\n        address _recipient,\r\n        uint _amt\r\n    ) private returns (\r\n        int128 amt_,\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        int128[] memory oBals_ = new int128[](_length);\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        ComponentStorage.Assimilator[] memory _reserves = component.assets;\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(_reserves[i].addr);\r\n            else {\r\n\r\n                int128 _bal;\r\n                ( amt_, _bal ) = Assimilators.outputRawAndGetBalance(_assim, _recipient, _amt);\r\n\r\n                oBals_[i] = _bal.sub(amt_);\r\n                nBals_[i] = _bal;\r\n\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return ( amt_, oGLiq_, nGLiq_, oBals_, nBals_ );\r\n\r\n    }\r\n\r\n    function viewOriginSwapData (\r\n        ComponentStorage.Component storage component,\r\n        uint _inputIx,\r\n        uint _outputIx,\r\n        uint _amt,\r\n        address _assim\r\n    ) private view returns (\r\n        int128 amt_,\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        int128[] memory oBals_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(component.assets[i].addr);\r\n            else {\r\n\r\n                int128 _bal;\r\n                ( amt_, _bal ) = Assimilators.viewNumeraireAmountAndBalance(_assim, _amt);\r\n\r\n                oBals_[i] = _bal;\r\n                nBals_[i] = _bal.add(amt_);\r\n\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n        return ( amt_, oGLiq_, nGLiq_, nBals_, oBals_ );\r\n\r\n    }\r\n\r\n    function viewTargetSwapData (\r\n        ComponentStorage.Component storage component,\r\n        uint _inputIx,\r\n        uint _outputIx,\r\n        uint _amt,\r\n        address _assim\r\n    ) private view returns (\r\n        int128 amt_,\r\n        int128 oGLiq_,\r\n        int128 nGLiq_,\r\n        int128[] memory,\r\n        int128[] memory\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n        int128[] memory nBals_ = new int128[](_length);\r\n        int128[] memory oBals_ = new int128[](_length);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            if (i != _inputIx) nBals_[i] = oBals_[i] = Assimilators.viewNumeraireBalance(component.assets[i].addr);\r\n            else {\r\n\r\n                int128 _bal;\r\n                ( amt_, _bal ) = Assimilators.viewNumeraireAmountAndBalance(_assim, _amt);\r\n                amt_ = amt_.neg();\r\n\r\n                oBals_[i] = _bal;\r\n                nBals_[i] = _bal.add(amt_);\r\n\r\n            }\r\n\r\n            oGLiq_ += oBals_[i];\r\n            nGLiq_ += nBals_[i];\r\n\r\n        }\r\n\r\n        nGLiq_ = nGLiq_.sub(amt_);\r\n        nBals_[_outputIx] = ABDKMath64x64.sub(nBals_[_outputIx], amt_);\r\n\r\n\r\n        return ( amt_, oGLiq_, nGLiq_, nBals_, oBals_ );\r\n\r\n    }\r\n\r\n  function settleProtocolShare(\r\n    ComponentStorage.Component storage component,\r\n    address _assim,\r\n    int128 _amt\r\n  ) internal {\r\n\r\n    int128 _prtclShr = _amt.us_mul(component.epsilon.us_mul(component.sigma));\r\n    Assimilators.outputNumeraire(_assim, component.protocol, _prtclShr);\r\n\r\n  }\r\n\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nlibrary ViewLiquidity {\r\n\r\n    using ABDKMath64x64 for int128;\r\n\r\n    function viewLiquidity (\r\n        ComponentStorage.Component storage component\r\n    ) external view returns (\r\n        uint total_,\r\n        uint[] memory individual_\r\n    ) {\r\n\r\n        uint _length = component.assets.length;\r\n\r\n        individual_ = new uint[](_length);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            uint _liquidity = Assimilators.viewNumeraireBalance(component.assets[i].addr).mulu(1e18);\r\n\r\n            total_ += _liquidity;\r\n            individual_[i] = _liquidity;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\ncontract ComponentStorage {\r\n\r\n    address public owner;\r\n\r\n    string  public constant name = \"Component LP Token\";\r\n    string  public constant symbol = \"CMP-LP\";\r\n    uint8   public constant decimals = 18;\r\n\r\n    Component public component;\r\n\r\n    struct Component {\r\n        int128 alpha;\r\n        int128 beta;\r\n        int128 delta;\r\n        int128 epsilon;\r\n        int128 lambda;\r\n        int128 sigma;\r\n        int128[] weights;\r\n        uint totalSupply;\r\n        address protocol;\r\n        Assimilator[] assets;\r\n        mapping (address => Assimilator) assimilators;\r\n        mapping (address => uint) balances;\r\n        mapping (address => mapping (address => uint)) allowances;\r\n    }\r\n\r\n    struct Assimilator {\r\n        address addr;\r\n        uint8 ix;\r\n    }\r\n\r\n    mapping (address => PartitionTicket) public partitionTickets;\r\n\r\n    struct PartitionTicket {\r\n        uint[] claims;\r\n        bool initialized;\r\n    }\r\n\r\n    address[] public derivatives;\r\n    address[] public numeraires;\r\n    address[] public reserves;\r\n\r\n    bool public partitioned = false;\r\n\r\n    bool public frozen = false;\r\n\r\n    bool internal notEntered = true;\r\n\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nlibrary ComponentMath {\r\n\r\n    int128 constant ONE = 0x10000000000000000;\r\n    int128 constant MAX = 0x4000000000000000; // .25 in layman's terms\r\n    int128 constant MAX_DIFF = -0x10C6F7A0B5EE;\r\n    int128 constant ONE_WEI = 0x12;\r\n\r\n    using ABDKMath64x64 for int128;\r\n    using UnsafeMath64x64 for int128;\r\n    using ABDKMath64x64 for uint256;\r\n\r\n    function calculateFee (\r\n        int128 _gLiq,\r\n        int128[] memory _bals,\r\n        int128 _beta,\r\n        int128 _delta,\r\n        int128[] memory _weights\r\n    ) internal pure returns (int128 psi_) {\r\n\r\n        uint _length = _bals.length;\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            int128 _ideal = _gLiq.us_mul(_weights[i]);\r\n\r\n            psi_ += calculateMicroFee(_bals[i], _ideal, _beta, _delta);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function calculateMicroFee (\r\n        int128 _bal,\r\n        int128 _ideal,\r\n        int128 _beta,\r\n        int128 _delta\r\n    ) private pure returns (int128 fee_) {\r\n\r\n        if (_bal < _ideal) {\r\n\r\n            int128 _threshold = _ideal.us_mul(ONE - _beta);\r\n\r\n            if (_bal < _threshold) {\r\n\r\n                int128 _feeMargin = _threshold - _bal;\r\n\r\n                fee_ = _feeMargin.us_div(_ideal);\r\n                fee_ = fee_.us_mul(_delta);\r\n\r\n                if (fee_ > MAX) fee_ = MAX;\r\n\r\n                fee_ = fee_.us_mul(_feeMargin);\r\n\r\n            } else fee_ = 0;\r\n\r\n        } else {\r\n\r\n            int128 _threshold = _ideal.us_mul(ONE + _beta);\r\n\r\n            if (_bal > _threshold) {\r\n\r\n                int128 _feeMargin = _bal - _threshold;\r\n\r\n                fee_ = _feeMargin.us_div(_ideal);\r\n                fee_ = fee_.us_mul(_delta);\r\n\r\n                if (fee_ > MAX) fee_ = MAX;\r\n\r\n                fee_ = fee_.us_mul(_feeMargin);\r\n\r\n            } else fee_ = 0;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function calculateTrade (\r\n        ComponentStorage.Component storage component,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128[] memory _oBals,\r\n        int128[] memory _nBals,\r\n        int128 _inputAmt,\r\n        uint _outputIndex\r\n    ) internal view returns (int128 outputAmt_) {\r\n\r\n        outputAmt_ = - _inputAmt;\r\n\r\n        int128 _lambda = component.lambda;\r\n        int128 _beta = component.beta;\r\n        int128 _delta = component.delta;\r\n        int128[] memory _weights = component.weights;\r\n\r\n        int128 _omega = calculateFee(_oGLiq, _oBals, _beta, _delta, _weights);\r\n        int128 _psi;\r\n\r\n        for (uint i = 0; i < 32; i++) {\r\n\r\n            _psi = calculateFee(_nGLiq, _nBals, _beta, _delta, _weights);\r\n\r\n            if (( outputAmt_ = _omega < _psi\r\n                    ? - ( _inputAmt + _omega - _psi )\r\n                    : - ( _inputAmt + _lambda.us_mul(_omega - _psi) )\r\n                ) / 1e13 == outputAmt_ / 1e13 ) {\r\n\r\n                _nGLiq = _oGLiq + _inputAmt + outputAmt_;\r\n\r\n                _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;\r\n\r\n                enforceHalts(component, _oGLiq, _nGLiq, _oBals, _nBals, _weights);\r\n\r\n                enforceSwapInvariant(_oGLiq, _omega, _nGLiq, _psi);\r\n\r\n                return outputAmt_;\r\n\r\n            } else {\r\n\r\n                _nGLiq = _oGLiq + _inputAmt + outputAmt_;\r\n\r\n                _nBals[_outputIndex] = _oBals[_outputIndex].add(outputAmt_);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        revert(\"Component/swap-convergence-failed\");\r\n\r\n    }\r\n\r\n    function enforceSwapInvariant (\r\n        int128 _oGLiq,\r\n        int128 _omega,\r\n        int128 _nGLiq,\r\n        int128 _psi\r\n    ) private pure {\r\n\r\n        int128 _nextUtil = _nGLiq - _psi;\r\n\r\n        int128 _prevUtil = _oGLiq - _omega;\r\n\r\n        int128 _diff = _nextUtil - _prevUtil;\r\n\r\n        require(0 < _diff || _diff >= MAX_DIFF, \"Component/swap-invariant-violation\");\r\n\r\n    }\r\n\r\n    function calculateLiquidityMembrane (\r\n        ComponentStorage.Component storage component,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128[] memory _oBals,\r\n        int128[] memory _nBals\r\n    ) internal view returns (int128 components_) {\r\n\r\n        enforceHalts(component, _oGLiq, _nGLiq, _oBals, _nBals, component.weights);\r\n\r\n        int128 _omega;\r\n        int128 _psi;\r\n\r\n        {\r\n\r\n            int128 _beta = component.beta;\r\n            int128 _delta = component.delta;\r\n            int128[] memory _weights = component.weights;\r\n\r\n            _omega = calculateFee(_oGLiq, _oBals, _beta, _delta, _weights);\r\n            _psi = calculateFee(_nGLiq, _nBals, _beta, _delta, _weights);\r\n\r\n        }\r\n\r\n        int128 _feeDiff = _psi.sub(_omega);\r\n        int128 _liqDiff = _nGLiq.sub(_oGLiq);\r\n        int128 _oUtil = _oGLiq.sub(_omega);\r\n        int128 _totalComponents = component.totalSupply.divu(1e18);\r\n        int128 _componentMultiplier;\r\n\r\n        if (_totalComponents == 0) {\r\n\r\n            components_ = _nGLiq.sub(_psi);\r\n\r\n        } else if (_feeDiff >= 0) {\r\n\r\n            _componentMultiplier = _liqDiff.sub(_feeDiff).div(_oUtil);\r\n\r\n        } else {\r\n\r\n            _componentMultiplier = _liqDiff.sub(component.lambda.mul(_feeDiff));\r\n\r\n            _componentMultiplier = _componentMultiplier.div(_oUtil);\r\n\r\n        }\r\n\r\n        if (_totalComponents != 0) {\r\n\r\n            components_ = _totalComponents.us_mul(_componentMultiplier);\r\n\r\n            enforceLiquidityInvariant(_totalComponents, components_, _oGLiq, _nGLiq, _omega, _psi);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function enforceLiquidityInvariant (\r\n        int128 _totalComponents,\r\n        int128 _newComponents,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128 _omega,\r\n        int128 _psi\r\n    ) internal pure {\r\n\r\n        if (_totalComponents == 0 || 0 == _totalComponents + _newComponents) return;\r\n\r\n        int128 _prevUtilPerComponent = _oGLiq\r\n            .sub(_omega)\r\n            .div(_totalComponents);\r\n\r\n        int128 _nextUtilPerComponent = _nGLiq\r\n            .sub(_psi)\r\n            .div(_totalComponents.add(_newComponents));\r\n\r\n        int128 _diff = _nextUtilPerComponent - _prevUtilPerComponent;\r\n\r\n        require(0 < _diff || _diff >= MAX_DIFF, \"Component/liquidity-invariant-violation\");\r\n\r\n    }\r\n\r\n    function enforceHalts (\r\n        ComponentStorage.Component storage component,\r\n        int128 _oGLiq,\r\n        int128 _nGLiq,\r\n        int128[] memory _oBals,\r\n        int128[] memory _nBals,\r\n        int128[] memory _weights\r\n    ) private view {\r\n\r\n        uint256 _length = _nBals.length;\r\n        int128 _alpha = component.alpha;\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n\r\n            int128 _nIdeal = _nGLiq.us_mul(_weights[i]);\r\n\r\n            if (_nBals[i] > _nIdeal) {\r\n\r\n                int128 _upperAlpha = ONE + _alpha;\r\n\r\n                int128 _nHalt = _nIdeal.us_mul(_upperAlpha);\r\n\r\n                if (_nBals[i] > _nHalt){\r\n\r\n                    int128 _oHalt = _oGLiq.us_mul(_weights[i]).us_mul(_upperAlpha);\r\n\r\n                    if (_oBals[i] < _oHalt) revert(\"Component/upper-halt\");\r\n                    if (_nBals[i] - _nHalt > _oBals[i] - _oHalt) revert(\"Component/upper-halt\");\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                int128 _lowerAlpha = ONE - _alpha;\r\n\r\n                int128 _nHalt = _nIdeal.us_mul(_lowerAlpha);\r\n\r\n                if (_nBals[i] < _nHalt){\r\n\r\n                    int128 _oHalt = _oGLiq.us_mul(_weights[i]).us_mul(_lowerAlpha);\r\n\r\n                    if (_oBals[i] > _oHalt) revert(\"Component/lower-halt\");\r\n                    if (_nHalt - _nBals[i] > _oHalt - _oBals[i]) revert(\"Component/lower-halt\");\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n////// src/Orchestrator.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nlibrary Orchestrator {\r\n\r\n    using ABDKMath64x64 for int128;\r\n    using ABDKMath64x64 for uint256;\r\n\r\n    int128 constant ONE_WEI = 0x12;\r\n\r\n    event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\r\n\r\n    event AssetIncluded(address indexed numeraire, address indexed reserve, uint weight);\r\n\r\n    event AssimilatorIncluded(address indexed derivative, address indexed numeraire, address indexed reserve, address assimilator);\r\n\r\n    function setParams (\r\n        ComponentStorage.Component storage component,\r\n        uint256 _alpha,\r\n        uint256 _beta,\r\n        uint256 _feeAtHalt,\r\n        uint256 _epsilon,\r\n        uint256 _lambda,\r\n        uint256 _sigma,\r\n        address _protocol\r\n    ) external {\r\n\r\n        require(0 < _alpha && _alpha < 1e18, \"Component/parameter-invalid-alpha\");\r\n\r\n        require(0 <= _beta && _beta < _alpha, \"Component/parameter-invalid-beta\");\r\n\r\n        require(_feeAtHalt <= .5e18, \"Component/parameter-invalid-max\");\r\n\r\n        require(0 <= _epsilon && _epsilon <= .02e18, \"Component/parameter-invalid-epsilon\");\r\n\r\n        require(0 <= _lambda && _lambda <= 1e18, \"Component/parameter-invalid-lambda\");\r\n\r\n        require(0 <= _sigma && _sigma <= .5e18, \"Component/parameter-invalid-sigma\");\r\n\r\n        int128 _omega = getFee(component);\r\n\r\n        component.alpha = (_alpha + 1).divu(1e18);\r\n\r\n        component.beta = (_beta + 1).divu(1e18);\r\n\r\n        component.delta = ( _feeAtHalt ).divu(1e18).div(uint(2).fromUInt().mul(component.alpha.sub(component.beta))) + ONE_WEI;\r\n\r\n        component.epsilon = (_epsilon + 1).divu(1e18);\r\n\r\n        component.lambda = (_lambda + 1).divu(1e18);\r\n\r\n        component.sigma = (_sigma + 1).divu(1e18);\r\n\r\n        component.protocol = _protocol;\r\n\r\n        int128 _psi = getFee(component);\r\n\r\n        require(_omega >= _psi, \"Component/parameters-increase-fee\");\r\n\r\n        emit ParametersSet(_alpha, _beta, component.delta.mulu(1e18), _epsilon, _lambda);\r\n\r\n    }\r\n\r\n    function getFee (\r\n        ComponentStorage.Component storage component\r\n    ) private view returns (\r\n        int128 fee_\r\n    ) {\r\n\r\n        int128 _gLiq;\r\n\r\n        int128[] memory _bals = new int128[](component.assets.length);\r\n\r\n        for (uint i = 0; i < _bals.length; i++) {\r\n\r\n            int128 _bal = Assimilators.viewNumeraireBalance(component.assets[i].addr);\r\n\r\n            _bals[i] = _bal;\r\n\r\n            _gLiq += _bal;\r\n\r\n        }\r\n\r\n        fee_ = ComponentMath.calculateFee(_gLiq, _bals, component.beta, component.delta, component.weights);\r\n\r\n    }\r\n\r\n\r\n    function initialize (\r\n        ComponentStorage.Component storage component,\r\n        address[] storage numeraires,\r\n        address[] storage reserves,\r\n        address[] storage derivatives,\r\n        address[] calldata _assets,\r\n        uint[] calldata _assetWeights,\r\n        address[] calldata _derivativeAssimilators\r\n    ) external {\r\n\r\n        for (uint i = 0; i < _assetWeights.length; i++) {\r\n\r\n            uint ix = i*5;\r\n\r\n            numeraires.push(_assets[ix]);\r\n            derivatives.push(_assets[ix]);\r\n\r\n            reserves.push(_assets[2+ix]);\r\n            if (_assets[ix] != _assets[2+ix]) derivatives.push(_assets[2+ix]);\r\n\r\n            includeAsset(\r\n                component,\r\n                _assets[ix],   // numeraire\r\n                _assets[1+ix], // numeraire assimilator\r\n                _assets[2+ix], // reserve\r\n                _assets[3+ix], // reserve assimilator\r\n                _assets[4+ix], // reserve approve to\r\n                _assetWeights[i]\r\n            );\r\n\r\n        }\r\n\r\n        for (uint i = 0; i < _derivativeAssimilators.length / 5; i++) {\r\n\r\n            uint ix = i * 5;\r\n\r\n            derivatives.push(_derivativeAssimilators[ix]);\r\n\r\n            includeAssimilator(\r\n                component,\r\n                _derivativeAssimilators[ix],   // derivative\r\n                _derivativeAssimilators[1+ix], // numeraire\r\n                _derivativeAssimilators[2+ix], // reserve\r\n                _derivativeAssimilators[3+ix], // assimilator\r\n                _derivativeAssimilators[4+ix]  // derivative approve to\r\n            );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function includeAsset (\r\n        ComponentStorage.Component storage component,\r\n        address _numeraire,\r\n        address _numeraireAssim,\r\n        address _reserve,\r\n        address _reserveAssim,\r\n        address _reserveApproveTo,\r\n        uint256 _weight\r\n    ) private {\r\n\r\n        require(_numeraire != address(0), \"Component/numeraire-cannot-be-zeroth-adress\");\r\n\r\n        require(_numeraireAssim != address(0), \"Component/numeraire-assimilator-cannot-be-zeroth-adress\");\r\n\r\n        require(_reserve != address(0), \"Component/reserve-cannot-be-zeroth-adress\");\r\n\r\n        require(_reserveAssim != address(0), \"Component/reserve-assimilator-cannot-be-zeroth-adress\");\r\n\r\n        require(_weight < 1e18, \"Component/weight-must-be-less-than-one\");\r\n\r\n        if (_numeraire != _reserve) safeApprove(_numeraire, _reserveApproveTo, uint(-1));\r\n\r\n        ComponentStorage.Assimilator storage _numeraireAssimilator = component.assimilators[_numeraire];\r\n\r\n        _numeraireAssimilator.addr = _numeraireAssim;\r\n\r\n        _numeraireAssimilator.ix = uint8(component.assets.length);\r\n\r\n        ComponentStorage.Assimilator storage _reserveAssimilator = component.assimilators[_reserve];\r\n\r\n        _reserveAssimilator.addr = _reserveAssim;\r\n\r\n        _reserveAssimilator.ix = uint8(component.assets.length);\r\n\r\n        int128 __weight = _weight.divu(1e18).add(uint256(1).divu(1e18));\r\n\r\n        component.weights.push(__weight);\r\n\r\n        component.assets.push(_numeraireAssimilator);\r\n\r\n        emit AssetIncluded(_numeraire, _reserve, _weight);\r\n\r\n        emit AssimilatorIncluded(_numeraire, _numeraire, _reserve, _numeraireAssim);\r\n\r\n        if (_numeraireAssim != _reserveAssim) {\r\n\r\n            emit AssimilatorIncluded(_reserve, _numeraire, _reserve, _reserveAssim);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function includeAssimilator (\r\n        ComponentStorage.Component storage component,\r\n        address _derivative,\r\n        address _numeraire,\r\n        address _reserve,\r\n        address _assimilator,\r\n        address _derivativeApproveTo\r\n    ) private {\r\n\r\n        require(_derivative != address(0), \"Component/derivative-cannot-be-zeroth-address\");\r\n\r\n        require(_numeraire != address(0), \"Component/numeraire-cannot-be-zeroth-address\");\r\n\r\n        require(_reserve != address(0), \"Component/numeraire-cannot-be-zeroth-address\");\r\n\r\n        require(_assimilator != address(0), \"Component/assimilator-cannot-be-zeroth-address\");\r\n\r\n        safeApprove(_numeraire, _derivativeApproveTo, uint(-1));\r\n\r\n        ComponentStorage.Assimilator storage _numeraireAssim = component.assimilators[_numeraire];\r\n\r\n        component.assimilators[_derivative] = ComponentStorage.Assimilator(_assimilator, _numeraireAssim.ix);\r\n\r\n        emit AssimilatorIncluded(_derivative, _numeraire, _reserve, _assimilator);\r\n\r\n    }\r\n\r\n    function safeApprove (\r\n        address _token,\r\n        address _spender,\r\n        uint256 _value\r\n    ) private {\r\n\r\n        ( bool success, ) = _token.call(abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value));\r\n\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n    }\r\n\r\n    function viewComponent(\r\n        ComponentStorage.Component storage component\r\n    ) external view returns (\r\n        uint alpha_,\r\n        uint beta_,\r\n        uint delta_,\r\n        uint epsilon_,\r\n        uint lambda_\r\n    ) {\r\n\r\n        alpha_ = component.alpha.mulu(1e18);\r\n\r\n        beta_ = component.beta.mulu(1e18);\r\n\r\n        delta_ = component.delta.mulu(1e18);\r\n\r\n        epsilon_ = component.epsilon.mulu(1e18);\r\n\r\n        lambda_ = component.lambda.mulu(1e18);\r\n\r\n    }\r\n\r\n}\r\n\r\ninterface IFreeFromUpTo {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\ncontract Component is ComponentStorage {\r\n\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n\r\n    event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\r\n\r\n    event AssetIncluded(address indexed numeraire, address indexed reserve, uint weight);\r\n\r\n    event AssimilatorIncluded(address indexed derivative, address indexed numeraire, address indexed reserve, address assimilator);\r\n\r\n    event PartitionRedeemed(address indexed token, address indexed redeemer, uint value);\r\n\r\n    event PoolPartitioned(bool partitioned);\r\n\r\n    event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event FrozenSet(bool isFrozen);\r\n\r\n    event Trade(address indexed trader, address indexed origin, address indexed target, uint256 originAmount, uint256 targetAmount);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n\r\n    modifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41130);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n\r\n        require(msg.sender == owner, \"Component/caller-is-not-owner\");\r\n        _;\r\n\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n\r\n        require(notEntered, \"Component/re-entered\");\r\n        notEntered = false;\r\n        _;\r\n        notEntered = true;\r\n\r\n    }\r\n\r\n    modifier transactable () {\r\n\r\n        require(!frozen, \"Component/frozen-only-allowing-proportional-withdraw\");\r\n        _;\r\n\r\n    }\r\n\r\n    modifier unpartitioned () {\r\n\r\n        require(!partitioned, \"Component/pool-partitioned\");\r\n        _;\r\n\r\n    }\r\n\r\n    modifier isPartitioned () {\r\n\r\n        require(partitioned, \"Component/pool-not-partitioned\");\r\n        _;\r\n\r\n    }\r\n\r\n    modifier deadline (uint _deadline) {\r\n\r\n        require(block.timestamp < _deadline, \"Component/tx-deadline-passed\");\r\n        _;\r\n\r\n    }\r\n\r\n    constructor (\r\n        address[] memory _assets,\r\n        uint[] memory _assetWeights,\r\n        address[] memory _derivativeAssimilators\r\n    ) public {\r\n\r\n        owner = msg.sender;\r\n        emit OwnershipTransfered(address(0), msg.sender);\r\n\r\n        Orchestrator.initialize(\r\n            component,\r\n            numeraires,\r\n            reserves,\r\n            derivatives,\r\n            _assets,\r\n            _assetWeights,\r\n            _derivativeAssimilators\r\n        );\r\n\r\n    }\r\n\r\n    /// @notice sets the parameters for the pool\r\n    /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\r\n    /// @param _beta the value for beta must be less than alpha and greater than 0\r\n    /// @param _feeAtHalt the maximum value for the fee at the halt point\r\n    /// @param _epsilon the base fee for the pool\r\n    /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\r\n    /// @param _sigma the protocol fee for the pool\r\n    /// @param _protocol the protocol fee distribution address\r\n    function setParams (\r\n        uint _alpha,\r\n        uint _beta,\r\n        uint _feeAtHalt,\r\n        uint _epsilon,\r\n        uint _lambda,\r\n        uint _sigma,\r\n        address _protocol\r\n    ) external onlyOwner {\r\n\r\n        Orchestrator.setParams(component, _alpha, _beta, _feeAtHalt, _epsilon, _lambda, _sigma, _protocol);\r\n\r\n    }\r\n\r\n    /// @notice excludes an assimilator from the component\r\n    /// @param _derivative the address of the assimilator to exclude\r\n    function excludeDerivative (\r\n        address _derivative\r\n    ) external onlyOwner {\r\n\r\n        for (uint i = 0; i < numeraires.length; i++) {\r\n\r\n            if (_derivative == numeraires[i]) revert(\"Component/cannot-delete-numeraire\");\r\n            if (_derivative == reserves[i]) revert(\"Component/cannot-delete-reserve\");\r\n\r\n        }\r\n\r\n        delete component.assimilators[_derivative];\r\n\r\n    }\r\n\r\n    /// @notice view the current parameters of the component\r\n    /// @return alpha_ the current alpha value\r\n    /// @return beta_ the current beta value\r\n    /// @return delta_ the current delta value\r\n    /// @return epsilon_ the current epsilon value\r\n    /// @return lambda_ the current lambda value\r\n    /// @return omega_ the current omega value\r\n    function viewComponent() external view returns (\r\n        uint alpha_,\r\n        uint beta_,\r\n        uint delta_,\r\n        uint epsilon_,\r\n        uint lambda_\r\n    ) {\r\n\r\n        return Orchestrator.viewComponent(component);\r\n\r\n    }\r\n\r\n    function setFrozen (bool _toFreezeOrNotToFreeze) external onlyOwner {\r\n\r\n        emit FrozenSet(_toFreezeOrNotToFreeze);\r\n\r\n        frozen = _toFreezeOrNotToFreeze;\r\n\r\n    }\r\n\r\n    function transferOwnership (address _newOwner) external onlyOwner {\r\n\r\n        emit OwnershipTransfered(owner, _newOwner);\r\n\r\n        owner = _newOwner;\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice swap a dynamic origin amount for a fixed target amount\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _originAmount the origin amount\r\n    /// @param _minTargetAmount the minimum target amount\r\n    /// @param _deadline deadline in block number after which the trade will not execute\r\n    /// @return targetAmount_ the amount of target that has been swapped for the origin amount\r\n    function originSwap (\r\n        address _origin,\r\n        address _target,\r\n        uint _originAmount,\r\n        uint _minTargetAmount,\r\n        uint _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (\r\n        uint targetAmount_\r\n    ) {\r\n\r\n        targetAmount_ = Swaps.originSwap(component, _origin, _target, _originAmount, msg.sender);\r\n\r\n        require(targetAmount_ > _minTargetAmount, \"Component/below-min-target-amount\");\r\n\r\n    }\r\n\r\n    function originSwapDiscountCHI (\r\n        address _origin,\r\n        address _target,\r\n        uint _originAmount,\r\n        uint _minTargetAmount,\r\n        uint _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant discountCHI returns (\r\n        uint targetAmount_\r\n    ) {\r\n\r\n        targetAmount_ = Swaps.originSwap(component, _origin, _target, _originAmount, msg.sender);\r\n\r\n        require(targetAmount_ > _minTargetAmount, \"Component/below-min-target-amount\");\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice view how much target amount a fixed origin amount will swap for\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _originAmount the origin amount\r\n    /// @return targetAmount_ the target amount that would have been swapped for the origin amount\r\n    function viewOriginSwap (\r\n        address _origin,\r\n        address _target,\r\n        uint _originAmount\r\n    ) external view transactable returns (\r\n        uint targetAmount_\r\n    ) {\r\n\r\n        targetAmount_ = Swaps.viewOriginSwap(component, _origin, _target, _originAmount);\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice swap a dynamic origin amount for a fixed target amount\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _maxOriginAmount the maximum origin amount\r\n    /// @param _targetAmount the target amount\r\n    /// @param _deadline deadline in block number after which the trade will not execute\r\n    /// @return originAmount_ the amount of origin that has been swapped for the target\r\n    function targetSwap (\r\n        address _origin,\r\n        address _target,\r\n        uint _maxOriginAmount,\r\n        uint _targetAmount,\r\n        uint _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (\r\n        uint originAmount_\r\n    ) {\r\n\r\n        originAmount_ = Swaps.targetSwap(component, _origin, _target, _targetAmount, msg.sender);\r\n\r\n        require(originAmount_ < _maxOriginAmount, \"Component/above-max-origin-amount\");\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice view how much of the origin currency the target currency will take\r\n    /// @param _origin the address of the origin\r\n    /// @param _target the address of the target\r\n    /// @param _targetAmount the target amount\r\n    /// @return originAmount_ the amount of target that has been swapped for the origin\r\n    function viewTargetSwap (\r\n        address _origin,\r\n        address _target,\r\n        uint _targetAmount\r\n    ) external view transactable returns (\r\n        uint originAmount_\r\n    ) {\r\n\r\n        originAmount_ = Swaps.viewTargetSwap(component, _origin, _target, _targetAmount);\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice selectively deposit any supported stablecoin flavor into the contract in return for corresponding amount of component tokens\r\n    /// @param _derivatives an array containing the addresses of the flavors being deposited into\r\n    /// @param _amounts an array containing the values of the flavors you wish to deposit into the contract. each amount should have the same index as the flavor it is meant to deposit\r\n    /// @param _minComponents minimum acceptable amount of components\r\n    /// @param _deadline deadline for tx\r\n    /// @return componentsToMint_ the amount of components to mint for the deposited stablecoin flavors\r\n    function selectiveDeposit (\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts,\r\n        uint _minComponents,\r\n        uint _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (\r\n        uint componentsMinted_\r\n    ) {\r\n\r\n        componentsMinted_ = SelectiveLiquidity.selectiveDeposit(component, _derivatives, _amounts, _minComponents);\r\n\r\n    }\r\n\r\n    /// @author james folew http://github.com/realisation\r\n    /// @notice view how many component tokens a deposit will mint\r\n    /// @param _derivatives an array containing the addresses of the flavors being deposited into\r\n    /// @param _amounts an array containing the values of the flavors you wish to deposit into the contract. each amount should have the same index as the flavor it is meant to deposit\r\n    /// @return componentsToMint_ the amount of components to mint for the deposited stablecoin flavors\r\n    function viewSelectiveDeposit (\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts\r\n    ) external view transactable returns (\r\n        uint componentsToMint_\r\n    ) {\r\n\r\n        componentsToMint_ = SelectiveLiquidity.viewSelectiveDeposit(component, _derivatives, _amounts);\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\r\n    /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst the numeraire assets of the pool\r\n    /// @return componentsToMint_ the amount of components you receive in return for your deposit\r\n    /// @return deposits_ the amount deposited for each numeraire\r\n    function proportionalDeposit (\r\n        uint _deposit,\r\n        uint _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (\r\n        uint componentsMinted_,\r\n        uint[] memory deposits_\r\n    ) {\r\n\r\n        return ProportionalLiquidity.proportionalDeposit(component, _deposit);\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice view deposits and components minted a given deposit would return\r\n    /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the prevailing proportions of the numeraire assets of the pool\r\n    /// @return componentsToMint_ the amount of components you receive in return for your deposit\r\n    /// @return deposits_ the amount deposited for each numeraire\r\n    function viewProportionalDeposit (\r\n        uint _deposit\r\n    ) external view transactable returns (\r\n        uint componentsToMint_,\r\n        uint[] memory depositsToMake_\r\n    ) {\r\n\r\n        return ProportionalLiquidity.viewProportionalDeposit(component, _deposit);\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice selectively withdrawal any supported stablecoin flavor from the contract by burning a corresponding amount of component tokens\r\n    /// @param _derivatives an array of flavors to withdraw from the reserves\r\n    /// @param _amounts an array of amounts to withdraw that maps to _flavors\r\n    /// @param _maxComponents the maximum amount of components you want to burn\r\n    /// @param _deadline timestamp after which the transaction is no longer valid\r\n    /// @return componentsBurned_ the corresponding amount of component tokens to withdraw the specified amount of specified flavors\r\n    function selectiveWithdraw (\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts,\r\n        uint _maxComponents,\r\n        uint _deadline\r\n    ) external deadline(_deadline) transactable nonReentrant returns (\r\n        uint componentsBurned_\r\n    ) {\r\n\r\n        componentsBurned_ = SelectiveLiquidity.selectiveWithdraw(component, _derivatives, _amounts, _maxComponents);\r\n\r\n    }\r\n\r\n    /// @author james foley http://github.com/realisation\r\n    /// @notice view how many component tokens a withdraw will consume\r\n    /// @param _derivatives an array of flavors to withdraw from the reserves\r\n    /// @param _amounts an array of amounts to withdraw that maps to _flavors\r\n    /// @return componentsBurned_ the corresponding amount of component tokens to withdraw the specified amount of specified flavors\r\n    function viewSelectiveWithdraw (\r\n        address[] calldata _derivatives,\r\n        uint[] calldata _amounts\r\n    ) external view transactable returns (\r\n        uint componentsToBurn_\r\n    ) {\r\n\r\n        componentsToBurn_ = SelectiveLiquidity.viewSelectiveWithdraw(component, _derivatives, _amounts);\r\n\r\n    }\r\n\r\n    /// @author  james foley http://github.com/realisation\r\n    /// @notice  withdrawas amount of component tokens from the the pool equally from the numeraire assets of the pool with no slippage\r\n    /// @param   _componentsToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the numeraire assets of the pool\r\n    /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\r\n    function proportionalWithdraw (\r\n        uint _componentsToBurn,\r\n        uint _deadline\r\n    ) external deadline(_deadline) unpartitioned nonReentrant returns (\r\n        uint[] memory withdrawals_\r\n    ) {\r\n\r\n        return ProportionalLiquidity.proportionalWithdraw(component, _componentsToBurn);\r\n\r\n    }\r\n\r\n    function supportsInterface (\r\n        bytes4 _interface\r\n    ) public pure returns (\r\n        bool supports_\r\n    ) {\r\n\r\n        supports_ = this.supportsInterface.selector == _interface  // erc165\r\n            || bytes4(0x7f5828d0) == _interface                   // eip173\r\n            || bytes4(0x36372b07) == _interface;                 // erc20\r\n\r\n    }\r\n\r\n    /// @author  james foley http://github.com/realisation\r\n    /// @notice  withdrawals amount of component tokens from the the pool equally from the numeraire assets of the pool with no slippage\r\n    /// @param   _componentsToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the numeraire assets of the pool\r\n    /// @return withdrawalsToHappen_ the amonts of numeraire assets withdrawn from the pool\r\n    function viewProportionalWithdraw (\r\n        uint _componentsToBurn\r\n    ) external view unpartitioned returns (\r\n        uint[] memory withdrawalsToHappen_\r\n    ) {\r\n\r\n        return ProportionalLiquidity.viewProportionalWithdraw(component, _componentsToBurn);\r\n\r\n    }\r\n\r\n    function partition () external onlyOwner {\r\n\r\n        require(frozen, \"Component/must-be-frozen\");\r\n\r\n        PartitionedLiquidity.partition(component, partitionTickets);\r\n\r\n        partitioned = true;\r\n\r\n    }\r\n\r\n    /// @author  james foley http://github.com/realisation\r\n    /// @notice  withdraws amount of component tokens from the the pool equally from the numeraire assets of the pool with no slippage\r\n    /// @param _tokens an array of the numeraire assets you will withdraw\r\n    /// @param _amounts an array of the amounts in terms of partitioned shels you want to withdraw from that numeraire partition\r\n    /// @return withdrawals_ the amounts of the numeraire assets withdrawn\r\n    function partitionedWithdraw (\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _amounts\r\n    ) external isPartitioned returns (\r\n        uint256[] memory withdrawals_\r\n    ) {\r\n\r\n        return PartitionedLiquidity.partitionedWithdraw(component, partitionTickets, _tokens, _amounts);\r\n\r\n    }\r\n\r\n    /// @author  james foley http://github.com/realisation\r\n    /// @notice  views the balance of the users partition ticket\r\n    /// @param _addr the address whose balances in partitioned components to be seen\r\n    /// @return claims_ the remaining claims in terms of partitioned components the address has in its partition ticket\r\n    function viewPartitionClaims (\r\n        address _addr\r\n    ) external view isPartitioned returns (\r\n        uint[] memory claims_\r\n    ) {\r\n\r\n        return PartitionedLiquidity.viewPartitionClaims(component, partitionTickets, _addr);\r\n\r\n    }\r\n\r\n    /// @notice transfers component tokens\r\n    /// @param _recipient the address of where to send the component tokens\r\n    /// @param _amount the amount of component tokens to send\r\n    /// @return success_ the success bool of the call\r\n    function transfer (\r\n        address _recipient,\r\n        uint _amount\r\n    ) public nonReentrant returns (\r\n        bool success_\r\n    ) {\r\n\r\n        require(!partitionTickets[msg.sender].initialized, \"Component/no-transfers-once-partitioned\");\r\n\r\n        success_ = Components.transfer(component, _recipient, _amount);\r\n\r\n    }\r\n\r\n    /// @notice transfers component tokens from one address to another address\r\n    /// @param _sender the account from which the component tokens will be sent\r\n    /// @param _recipient the account to which the component tokens will be sent\r\n    /// @param _amount the amount of component tokens to transfer\r\n    /// @return success_ the success bool of the call\r\n    function transferFrom (\r\n        address _sender,\r\n        address _recipient,\r\n        uint _amount\r\n    ) public nonReentrant returns (\r\n        bool success_\r\n    ) {\r\n\r\n        require(!partitionTickets[_sender].initialized, \"Component/no-transfers-once-partitioned\");\r\n\r\n        success_ = Components.transferFrom(component, _sender, _recipient, _amount);\r\n\r\n    }\r\n\r\n    /// @notice approves a user to spend component tokens on their behalf\r\n    /// @param _spender the account to allow to spend from msg.sender\r\n    /// @param _amount the amount to specify the spender can spend\r\n    /// @return success_ the success bool of this call\r\n    function approve (address _spender, uint _amount) public nonReentrant returns (bool success_) {\r\n\r\n        success_ = Components.approve(component, _spender, _amount);\r\n\r\n    }\r\n\r\n    /// @notice view the component token balance of a given account\r\n    /// @param _account the account to view the balance of  \r\n    /// @return balance_ the component token ballance of the given account\r\n    function balanceOf (\r\n        address _account\r\n    ) public view returns (\r\n        uint balance_\r\n    ) {\r\n\r\n        balance_ = component.balances[_account];\r\n\r\n    }\r\n\r\n    /// @notice views the total component supply of the pool\r\n    /// @return totalSupply_ the total supply of component tokens\r\n    function totalSupply () public view returns (uint totalSupply_) {\r\n\r\n        totalSupply_ = component.totalSupply;\r\n\r\n    }\r\n\r\n    /// @notice views the total allowance one address has to spend from another address\r\n    /// @param _owner the address of the owner \r\n    /// @param _spender the address of the spender\r\n    /// @return allowance_ the amount the owner has allotted the spender\r\n    function allowance (\r\n        address _owner,\r\n        address _spender\r\n    ) public view returns (\r\n        uint allowance_\r\n    ) {\r\n\r\n        allowance_ = component.allowances[_owner][_spender];\r\n\r\n    }\r\n\r\n    /// @notice views the total amount of liquidity in the component in numeraire value and format - 18 decimals\r\n    /// @return total_ the total value in the component\r\n    /// @return individual_ the individual values in the component\r\n    function liquidity () public view returns (\r\n        uint total_,\r\n        uint[] memory individual_\r\n    ) {\r\n\r\n        return ViewLiquidity.viewLiquidity(component);\r\n\r\n    }\r\n    \r\n    /// @notice view the assimilator address for a derivative\r\n    /// @return assimilator_ the assimilator address\r\n    function assimilator (\r\n        address _derivative\r\n    ) public view returns (\r\n        address assimilator_\r\n    ) {\r\n\r\n        assimilator_ = component.assimilators[_derivative].addr;\r\n\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PartitionRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"PoolPartitioned\",\"type\":\"event\"}]","ContractName":"PartitionedLiquidity","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://46817267216135dfb93234838efd26ca72f6d0587ac210c593d37ad9fa1dc437"}]}