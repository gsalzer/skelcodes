{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\n\r\ncontract Ownable {\r\n\r\n\r\n  address newOwner;\r\n  mapping (address=>bool) owners;\r\n  address owner;\r\n  bytes32 public adminChangeKey;\r\n\r\n// all events will be saved as log files\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  event AddOwner(address newOwner,string name);\r\n  event RemoveOwner(address owner);\r\n\r\n   constructor() public {\r\n    owner = msg.sender;\r\n    owners[msg.sender] = true;\r\n    adminChangeKey = 0xc07b01d617f249e77fe6f0df68daa292fe6ec653a9234d277713df99c0bb8ebf;\r\n  }\r\n\r\n  function verify(bytes32 root,bytes32 leaf,bytes32[] memory proof) public pure returns (bool)\r\n  {\r\n      bytes32 computedHash = leaf;\r\n\r\n      for (uint256 i = 0; i < proof.length; i++) {\r\n        bytes32 proofElement = proof[i];\r\n\r\n        if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n        } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n       }\r\n      }\r\n\r\n     // Check if the computed hash (root) is equal to the provided root\r\n      return computedHash == root;\r\n   }    \r\n  function changeAdmin(address _newAdmin,bytes32 _keyData,bytes32[] memory merkleProof,bytes32 _newRootKey) public onlyOwner {\r\n         bytes32 leaf = keccak256(abi.encodePacked(msg.sender,'szoSellPool',_keyData));\r\n         require(verify(adminChangeKey, leaf,merkleProof), 'Invalid proof.');\r\n         \r\n         owner = _newAdmin;\r\n         adminChangeKey = _newRootKey;\r\n         \r\n         emit OwnershipTransferred(_newAdmin,msg.sender);      \r\n  }\r\n\r\n  modifier onlyOwner(){\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  modifier onlyOwners(){\r\n    require(owners[msg.sender] == true || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \r\n  function addOwner(address _newOwner,string memory newOwnerName) public onlyOwners{\r\n    require(owners[_newOwner] == false);\r\n    require(newOwner != msg.sender);\r\n    owners[_newOwner] = true;\r\n    emit AddOwner(_newOwner,newOwnerName);\r\n  }\r\n\r\n\r\n  function removeOwner(address _owner) public onlyOwners{\r\n    require(_owner != msg.sender);  // can't remove your self\r\n    owners[_owner] = false;\r\n    emit RemoveOwner(_owner);\r\n  }\r\n\r\n  function isOwner(address _owner) public view returns(bool){\r\n    return owners[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract SZO {\r\n\r\n       function balanceOf(address tokenOwner) public view returns (uint256 balance);\r\n       function transfer(address to, uint256 tokens) public returns (bool success);\r\n       \r\n  \r\n\t   function createKYCData(bytes32 _KycData1, bytes32 _kycData2,address  _wallet) public returns(uint256);\r\n\t   function intTransfer(address _from, address _to, uint256 _value) external  returns(bool);\r\n\t   function haveKYC(address _addr) public view returns(bool);\r\n\t   \r\n\t   function burn(uint256 amount) public returns(bool);\r\n\t   \r\n\t   function decimals() public view returns(uint256);\r\n}\r\n\r\n\r\ncontract SZOSellPools is Ownable{\r\n        \r\n        SZO szoToken;\r\n        address withdrawAddr;\r\n        uint256 public version = 5;\r\n        \r\n        \r\n        mapping (address=>uint256) public sellPrices;\r\n        \r\n        function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\r\n             bytes memory tempEmptyStringTest = bytes(source);\r\n            if (tempEmptyStringTest.length == 0) {\r\n                return 0x0;\r\n             }\r\n\r\n            assembly {\r\n                 result := mload(add(source, 32))\r\n            }\r\n        }\r\n        \r\n        function toString(uint256 value) public pure returns (string memory) {\r\n       \r\n            if (value == 0) {\r\n                return \"0\";\r\n            }\r\n            uint256 temp = value;\r\n            uint256 digits;\r\n            while (temp != 0) {\r\n                digits++;\r\n                temp /= 10;\r\n            }\r\n            bytes memory buffer = new bytes(digits);\r\n            uint256 index = digits - 1;\r\n            temp = value;\r\n            while (temp != 0) {\r\n                buffer[index--] = byte(uint8(48 + temp % 10));\r\n                temp /= 10;\r\n            }\r\n            return string(buffer);\r\n        }\r\n        \r\n        constructor() public{\r\n            szoToken = SZO(0x6086b52Cab4522b4B0E8aF9C3b2c5b8994C36ba6); // main network\r\n            withdrawAddr = msg.sender;\r\n            setSellPrice(0xd80BcbbEeFE8225224Eeb71f4EDb99e64cCC9c99,1 ether); // szDAI\r\n            setSellPrice(0xA298508BaBF033f69B33f4d44b5241258344A91e,1 ether); // szUSDT\r\n            setSellPrice(0x55b123B169400Da201Dd69814BAe2B8C2660c2Bf,1 ether); // szUSDC\r\n            setSellPrice(0xFf56Dbdc4063dB5EBE8395D27958661aAfe83A08,1 ether); // szUSD\r\n        }\r\n        \r\n        function setWithdrawAddress(address _addr) public onlyOwner{\r\n            withdrawAddr = _addr;\r\n            \r\n        } \r\n        \r\n        function setSellPrice(address _addr,uint256 _price) public onlyOwner returns(bool){\r\n            sellPrices[_addr] = _price;\r\n            \r\n            return true;\r\n        }\r\n    \r\n        function withdrawFund(address _contract,uint256 amount) public returns(bool){\r\n            SZO erc20Token = SZO(_contract); // can use szo bc it erc20\r\n            erc20Token.transfer(withdrawAddr,amount);\r\n            return true;\r\n        }\r\n        \r\n        function buyToken(address _tokenAddr,address _toAddr,uint256 amount,uint256 wallID) public onlyOwners returns(bool){\r\n            require(sellPrices[_tokenAddr] > 0,\"This token can't buy\");\r\n            \r\n            SZO szToken = SZO(_tokenAddr);\r\n            uint256 szoGot = (amount * 1 ether) / sellPrices[_tokenAddr];\r\n\r\n            require(szoGot <= szoToken.balanceOf(address(this)),\"Not enought szo to sell\");\r\n            require(szToken.balanceOf(_toAddr) >= amount,\"Not have fund to buy\");\r\n            \r\n            if(szToken.intTransfer(_toAddr,address(this),amount) == true)\r\n            {\r\n                szoToken.transfer(_toAddr,szoGot);\r\n                if(szoToken.haveKYC(_toAddr) == false){\r\n                    string memory stWalletID = toString(wallID);\r\n                    szoToken.createKYCData(stringToBytes32(\"SHUTTLEONE_WALLET\"),stringToBytes32(stWalletID),_toAddr);\r\n                }\r\n                return true;\r\n            }\r\n            \r\n            return false;\r\n        }\r\n        \r\n \r\n        \r\n        function buyUseAndBurn(address _tokenAddr,address _toAddr,uint256 amount) public onlyOwners returns(bool){\r\n            require(sellPrices[_tokenAddr] > 0,\"This token can't buy\");\r\n            \r\n            SZO szToken = SZO(_tokenAddr);\r\n            uint256 szoGot = (amount * 1 ether) / sellPrices[_tokenAddr];\r\n            \r\n            require(szoGot <= szoToken.balanceOf(address(this)),\"ERROR Pool Out off Fund\");\r\n            require(szToken.balanceOf(_toAddr) >= amount,\"ERROR User Out off Fund\");\r\n            \r\n            if(szToken.intTransfer(_toAddr,address(this),amount) == true){\r\n                return szoToken.burn(szoGot);\r\n                \r\n            }\r\n            \r\n            return false;\r\n            \r\n        }\r\n        \r\n        \r\n        function useAndBurn(address _fromAddress,uint256 amount) public onlyOwners returns(bool){\r\n            require(szoToken.balanceOf(_fromAddress) >= amount,\"Not Enought SZO to USE\");\r\n            if(szoToken.intTransfer(_fromAddress,address(this),amount) == true)\r\n            {\r\n                return szoToken.burn(amount);\r\n            }\r\n            \r\n            return false;\r\n            \r\n        }\r\n        \r\n        // Buy token \r\n        \r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RemoveOwner\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"newOwnerName\",\"type\":\"string\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminChangeKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wallID\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyUseAndBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_keyData\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"_newRootKey\",\"type\":\"bytes32\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWithdrawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"toString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"useAndBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SZOSellPools","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bc09cefa4713b07e85a8eb3237944c6afd115bf41ebcd6f4f3935047bd9b09e6"}]}