{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4 .26;\r\n\r\ncontract ERC20 {\r\n    function transfer(address receiver, uint amount) public;\r\n\r\n    function balanceOf(address tokenOwner) public constant returns(uint balance);\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface IDSDS {\r\n    function epoch() external view returns(uint256);\r\n\r\n    function transferCoupons(address sender, address recipient, uint256 epoch, uint256 amount) external;\r\n\r\n    function balanceOfCoupons(address account, uint256 epoch) external view returns(uint256);\r\n\r\n    function allowanceCoupons(address owner, address spender) external view returns(uint256); //check address has enabled selling (>1)\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract TradeDSDCoupons is ReentrancyGuard {\r\n\r\n\r\n    using SafeMath\r\n    for uint;\r\n\r\n    IDSDS public DSDS = IDSDS(0x6Bf977ED1A09214E6209F4EA5f525261f1A2690a);\r\n\r\n\r\n\r\n\r\n    function DSDperUSDC() public view returns(uint) {\r\n        return ERC20(0xBD2F0Cd039E0BFcf88901C98c0bFAc5ab27566e3).balanceOf(0x66e33d2605c5fB25eBb7cd7528E7997b0afA55E8).div(ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(0x66e33d2605c5fB25eBb7cd7528E7997b0afA55E8)).div(1e9);\r\n    } //to 3 decimals\r\n\r\n    function USDCperETH() public view returns(uint) {\r\n        return ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).balanceOf(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc).mul(1e12).div(ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc));\r\n    } //zero decimals\r\n\r\n    function DSDperETH() public view returns(uint) {\r\n        return DSDperUSDC().mul(USDCperETH()).div(1000);\r\n    }\r\n\r\n\r\n\r\n    address[] addressList; //each time an initial sellRate is set, address is added here\r\n    mapping(address => uint) public sellRate;\r\n    mapping(address => uint256) public ETHbalances; // records amounts invested  \r\n\r\n    function setRate(uint rate) external nonReentrant {\r\n        uint numElements = addressList.length;\r\n        uint i;\r\n        if (sellRate[msg.sender] == 0 && rate > 10 && rate < 100) { //initial rate for an address\r\n            sellRate[msg.sender] = rate;\r\n            addressList.push(msg.sender);\r\n            numElements = addressList.length;\r\n            //sort addressList in ascending rate order\r\n            if (numElements > 1)\r\n                for (i = numElements - 1; i > 0; i--) {\r\n                    if (sellRate[addressList[i]] < sellRate[addressList[i - 1]]) {\r\n                        addressList[i] = addressList[i - 1];\r\n                        addressList[i - 1] = msg.sender;\r\n                    } else break;\r\n                }\r\n        } else\r\n            //update previous rate\r\n            if (rate > 10 && rate < 100) {\r\n                uint previousRate = sellRate[msg.sender];\r\n                uint addressListLocation = 0;\r\n                if (numElements > 1) {\r\n                    for (i = numElements - 1; i > 0; i--) {\r\n                        if (addressList[i] == msg.sender) {\r\n                            addressListLocation = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    sellRate[msg.sender] = rate;\r\n                    //sort addressList in ascending rate order  - case where previous rate was higher so shift down\r\n                    if (previousRate > rate) {\r\n                        for (i = addressListLocation; i > 0; i--) {\r\n                            if (sellRate[addressList[i]] < sellRate[addressList[i - 1]]) {\r\n                                addressList[i] = addressList[i - 1];\r\n                                addressList[i - 1] = msg.sender;\r\n                            } else break;\r\n                        }\r\n                    } else if (addressListLocation + 1 < numElements) //shift the other way\r\n                    {\r\n                        for (i = addressListLocation; i < numElements - 1; i++) {\r\n                            if (sellRate[addressList[i]] > sellRate[addressList[i + 1]]) {\r\n                                addressList[i] = addressList[i + 1];\r\n                                addressList[i + 1] = msg.sender;\r\n                            } else break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n    }\r\n\r\n\r\n\r\n    function uint2str(uint i) internal pure returns(string) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n\r\n\r\n\r\nfunction address2ShortString(address _address) public pure returns(string memory) {\r\n       bytes32 _bytes = bytes32(uint256(_address));\r\n       bytes memory HEX = \"0123456789abcdef\";\r\n       bytes memory _string = new bytes(42);\r\n       _string[0] = '0';\r\n       _string[1] = 'x';\r\n       for(uint i = 0; i < 20; i++) {\r\n           _string[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\r\n           _string[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\r\n       }\r\n\r\n       bytes memory strBytes = bytes(string(_string));\r\n       uint endIndex=4; uint startIndex=0;\r\n       bytes memory result = new bytes(endIndex-startIndex);\r\n       for(i = startIndex; i < endIndex; i++) {\r\n        result[i-startIndex] = strBytes[i];}\r\n       \r\n       return string(result);\r\n       \r\n    }\r\n\r\n\r\n    function showAvailableCoupons(uint maxPrice, uint addressListLocation) public view returns(string memory) { // 99999 location to show all addresses\r\n        address addressToShow; uint numAddresses = 1;\r\n        string memory couponList = \"The following coupons are available to purchase directly with ETH at current DSD rates:\";\r\n        if (addressListLocation != 99999) {\r\n            addressToShow = addressList[addressListLocation];\r\n        } else {\r\n            addressToShow = addressList[0];\r\n            numAddresses = addressList.length;\r\n        }\r\n        uint DSDepoch = currentEpoch();\r\n        for (uint i = 0; i < numAddresses; i++) {\r\n            //break out if over maxPrice\r\n            if (sellRate[addressToShow] > maxPrice) break;\r\n            //first check if allowanceCoupons/sell is enabled in this addressToShow\r\n            if (approvedToSell(addressToShow) > 1) { //loop through current epoch minus 360 to present\r\n                couponList = string(abi.encodePacked(couponList, '{', address2ShortString(addressToShow),'..  DSD/Coupon offer: 0.', uint2str(sellRate[addressToShow]), ' }:'));\r\n                for (uint ep = DSDepoch.sub(360); ep < DSDepoch; ep++) {\r\n                    uint couponBalance = DSDS.balanceOfCoupons(addressToShow, ep);\r\n                    if (couponBalance > 0) couponList = string(abi.encodePacked(couponList, '[', uint2str(ep), ': ', uint2str(couponBalance.div(1e18)), '] '));\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            if (i + 1 < numAddresses) addressToShow = addressList[i + 1];\r\n        }\r\n\r\n        return couponList;\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function buyCoupons(uint epoch, uint addressListLocation) payable external nonReentrant {\r\n        uint buyRate = sellRate[addressList[addressListLocation]];\r\n        address buyFrom = addressList[addressListLocation];\r\n        uint refund;\r\n        require(buyRate > 0, \"Invalid address\");\r\n        require(approvedToSell(buyFrom) > 1, 'Sale not approved'); //require seller to have approved sale\r\n        uint DSDETH = DSDperETH();\r\n        uint couponAmount = msg.value.mul(DSDETH).mul(1e2).div(buyRate);\r\n        uint couponBalance = DSDS.balanceOfCoupons(buyFrom, epoch);\r\n        if (couponAmount > couponBalance) {refund = (couponAmount - couponBalance).mul(buyRate).div(DSDETH).div(1e2); couponAmount = couponBalance;} \r\n        if (refund > msg.value) refund = msg.value;\r\n\r\n        ETHbalances[msg.sender] += refund;\r\n        ETHbalances[buyFrom] += msg.value.sub(refund);\r\n        DSDS.transferCoupons(buyFrom, msg.sender, epoch, couponAmount);\r\n\r\n    }\r\n    \r\n\r\n\r\n    function approvedToSell(address addressToCheck) public view returns (uint) {\r\n        return DSDS.allowanceCoupons(addressToCheck, address(this));  // anything over 1 means approved\r\n    }\r\n    \r\n     \r\n    function currentEpoch() public view returns (uint) {\r\n        return DSDS.epoch();\r\n    }\r\n\r\n    function claimETH() external nonReentrant {\r\n         uint claimFee=  ETHbalances[msg.sender].div(33)  ;   //small 3% claim fee eg. will get over 0.29 DSD if selling for 0.3 per coupon\r\n         \r\n        if (msg.sender.call.value(ETHbalances[msg.sender].sub(claimFee))())  {\r\n            ETHbalances[msg.sender] = 0;\r\n            ETHbalances[0x79E77ED9D3125117003DD592E58109398488f4Ca] += claimFee;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"name\":\"addressListLocation\",\"type\":\"uint256\"}],\"name\":\"showAvailableCoupons\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ETHbalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"approvedToSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DSDperETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"addressListLocation\",\"type\":\"uint256\"}],\"name\":\"buyCoupons\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DSDS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"address2ShortString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DSDperUSDC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDCperETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TradeDSDCoupons","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://77f25eda5a6715c1d211de2256ccf023d00ef2c516b5ca1ff1fdbc8fbd318a30"}]}