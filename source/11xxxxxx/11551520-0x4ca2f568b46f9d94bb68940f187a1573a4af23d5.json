{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src.sol/interfaces/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nstruct Balance {\\n    uint256[2] amount; // [alice, bob] in channel, [initiator, responder] in transfer\\n    address payable[2] to; // [alice, bob] in channel, [initiator, responder] in transfer\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ITransferDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITransferRegistry.sol\\\";\\nimport \\\"./Types.sol\\\";\\n\\ninterface ITransferDefinition {\\n    // Validates the initial state of the transfer.\\n    // Called by validator.ts during `create` updates.\\n    function create(bytes calldata encodedBalance, bytes calldata)\\n        external\\n        view\\n        returns (bool);\\n\\n    // Performs a state transition to resolve a transfer and returns final balances.\\n    // Called by validator.ts during `resolve` updates.\\n    function resolve(\\n        bytes calldata encodedBalance,\\n        bytes calldata,\\n        bytes calldata\\n    ) external view returns (Balance memory);\\n\\n    // Should also have the following properties:\\n    // string public constant override Name = \\\"...\\\";\\n    // string public constant override StateEncoding = \\\"...\\\";\\n    // string public constant override ResolverEncoding = \\\"...\\\";\\n    // These properties are included on the transfer specifically\\n    // to make it easier for implementers to add new transfers by\\n    // only include a `.sol` file\\n    function Name() external view returns (string memory);\\n\\n    function StateEncoding() external view returns (string memory);\\n\\n    function ResolverEncoding() external view returns (string memory);\\n\\n    function EncodedCancel() external view returns (bytes memory);\\n\\n    function getRegistryInformation()\\n        external\\n        view\\n        returns (RegisteredTransfer memory);\\n}\\n\"\r\n    },\r\n    \"src.sol/interfaces/ITransferRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental \\\"ABIEncoderV2\\\";\\n\\nstruct RegisteredTransfer {\\n    string name;\\n    address definition;\\n    string stateEncoding;\\n    string resolverEncoding;\\n    bytes encodedCancel;\\n}\\n\\ninterface ITransferRegistry {\\n    event TransferAdded(RegisteredTransfer transfer);\\n\\n    event TransferRemoved(RegisteredTransfer transfer);\\n\\n    // Should add a transfer definition to the registry\\n    // onlyOwner\\n    function addTransferDefinition(RegisteredTransfer memory transfer) external;\\n\\n    // Should remove a transfer definition to the registry\\n    // onlyOwner\\n    function removeTransferDefinition(string memory name) external;\\n\\n    // Should return all transfer defintions in registry\\n    function getTransferDefinitions()\\n        external\\n        view\\n        returns (RegisteredTransfer[] memory);\\n}\\n\"\r\n    },\r\n    \"src.sol/transferDefinitions/TransferDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/ITransferDefinition.sol\\\";\\nimport \\\"../interfaces/ITransferRegistry.sol\\\";\\n\\n/// @title TransferDefinition\\n/// @author Connext <support@connext.network>\\n/// @notice This contract helps reduce boilerplate needed when creating\\n///         new transfer definitions by providing an implementation of\\n///         the required getter\\n\\nabstract contract TransferDefinition is ITransferDefinition {\\n    function getRegistryInformation()\\n        external\\n        view\\n        override\\n        returns (RegisteredTransfer memory)\\n    {\\n        return\\n            RegisteredTransfer({\\n                name: this.Name(),\\n                stateEncoding: this.StateEncoding(),\\n                resolverEncoding: this.ResolverEncoding(),\\n                definition: address(this),\\n                encodedCancel: this.EncodedCancel()\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"src.sol/transferDefinitions/HashlockTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./TransferDefinition.sol\\\";\\n\\n/// @title HashlockTransfer\\n/// @author Connext <support@connext.network>\\n/// @notice This contract allows users to claim a payment locked in\\n///         the application if they provide the correct preImage. The payment is\\n///         reverted if not unlocked by the timelock if one is provided.\\n\\ncontract HashlockTransfer is TransferDefinition {\\n    struct TransferState {\\n        bytes32 lockHash;\\n        uint256 expiry; // If 0, then no timelock is enforced\\n    }\\n\\n    struct TransferResolver {\\n        bytes32 preImage;\\n    }\\n\\n    // Provide registry information\\n    string public constant override Name = \\\"HashlockTransfer\\\";\\n    string public constant override StateEncoding =\\n        \\\"tuple(bytes32 lockHash, uint256 expiry)\\\";\\n    string public constant override ResolverEncoding =\\n        \\\"tuple(bytes32 preImage)\\\";\\n\\n    function EncodedCancel() external pure override returns(bytes memory) {\\n      TransferResolver memory resolver;\\n      resolver.preImage = bytes32(0);\\n      return abi.encode(resolver);\\n    } \\n\\n    function create(bytes calldata encodedBalance, bytes calldata encodedState)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        // Decode parameters\\n        TransferState memory state = abi.decode(encodedState, (TransferState));\\n        Balance memory balance = abi.decode(encodedBalance, (Balance));\\n\\n        require(\\n            balance.amount[0] > 0,\\n            \\\"HashlockTransfer: ZER0_SENDER_BALANCE\\\"\\n        );\\n\\n        require(\\n            balance.amount[1] == 0,\\n            \\\"HashlockTransfer: NONZERO_RECIPIENT_BALANCE\\\"\\n        );\\n        require(\\n            state.lockHash != bytes32(0),\\n            \\\"HashlockTransfer: EMPTY_LOCKHASH\\\"\\n        );\\n        require(\\n            state.expiry == 0 || state.expiry > block.timestamp,\\n            \\\"HashlockTransfer: EXPIRED_TIMELOCK\\\"\\n        );\\n\\n        // Valid transfer state\\n        return true;\\n    }\\n\\n    function resolve(\\n        bytes calldata encodedBalance,\\n        bytes calldata encodedState,\\n        bytes calldata encodedResolver\\n    ) external view override returns (Balance memory) {\\n        TransferState memory state = abi.decode(encodedState, (TransferState));\\n        TransferResolver memory resolver =\\n            abi.decode(encodedResolver, (TransferResolver));\\n        Balance memory balance = abi.decode(encodedBalance, (Balance));\\n\\n        // If you pass in bytes32(0), payment is canceled\\n        // If timelock is nonzero and has expired, payment must be canceled\\n        // otherwise resolve will revert\\n        if (resolver.preImage != bytes32(0)) {\\n            // Payment must not be expired\\n            require(state.expiry == 0 || state.expiry > block.timestamp, \\\"HashlockTransfer: PAYMENT_EXPIRED\\\");\\n\\n            // Check hash for normal payment unlock\\n            bytes32 generatedHash = sha256(abi.encode(resolver.preImage));\\n            require(\\n                state.lockHash == generatedHash,\\n                \\\"HashlockTransfer: INVALID_PREIMAGE\\\"\\n            );\\n\\n            // Update state\\n            balance.amount[1] = balance.amount[0];\\n            balance.amount[0] = 0;\\n        }\\n        // To cancel, the preImage must be empty (not simply incorrect)\\n        // There are no additional state mutations, and the preImage is\\n        // asserted by the `if` statement\\n\\n        return balance;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"EncodedCancel\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ResolverEncoding\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StateEncoding\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedBalance\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedState\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistryInformation\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"definition\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"stateEncoding\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"resolverEncoding\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedCancel\",\"type\":\"bytes\"}],\"internalType\":\"struct RegisteredTransfer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedBalance\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedState\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedResolver\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"amount\",\"type\":\"uint256[2]\"},{\"internalType\":\"address payable[2]\",\"name\":\"to\",\"type\":\"address[2]\"}],\"internalType\":\"struct Balance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"HashlockTransfer","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f7a1aad5efbe0de5a92ccb20170dbe8d594d5a4ccb943cb48fbcd3fcbc98e24c"}]}