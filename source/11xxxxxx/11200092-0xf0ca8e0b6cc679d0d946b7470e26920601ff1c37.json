{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: none\r\n\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from,address indexed to,uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract YlFiStake is Context {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    struct periodList{\r\n        uint256 periodTime;\r\n        uint256 cooldownTime;\r\n        uint256 formulaParam1;\r\n        uint256 formulaParam2;\r\n        uint256 formulaPenalty1;\r\n        uint256 formulaPenalty2;\r\n    }\r\n    \r\n    struct userStaking{\r\n        bool activeStake;\r\n        uint periodChoosed;\r\n        address tokenWantStake;\r\n        uint256 amountStaked;\r\n        uint256 startStake;\r\n        uint256 claimStake;\r\n        uint256 endStake;\r\n        uint256 cooldownDate;\r\n        uint256 claimed;\r\n    }\r\n    \r\n    struct rewardDetail{\r\n        string symboltoken;\r\n        uint256 equalReward;\r\n    }\r\n    \r\n    mapping (uint => periodList) private period;\r\n    mapping (address => rewardDetail) private ERC20perYlFi;\r\n    mapping (address => userStaking) private stakerDetail;\r\n    \r\n    address private _owner;\r\n    address private _YlFitoken;\r\n    address[] private _tokenStakeList;\r\n    address[] private _stakerList;\r\n    uint[] private _periodList;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Stake(address indexed staker, address indexed tokenStakeTarget, uint256 indexed amountTokenStaked);\r\n    event Unstake(address indexed staker, address indexed tokenStakeTarget, uint256 indexed amountTokenStaked);\r\n    event Claim(address indexed staker, address indexed tokenStakeTarget, uint256 indexed amountReward);\r\n    \r\n    constructor(address YlFiAddress){\r\n        rewardDetail storage est = ERC20perYlFi[YlFiAddress];\r\n        rewardDetail storage nul = ERC20perYlFi[address(0)];\r\n        require(YlFiAddress.isContract() == true,\"This address is not Smartcontract\");\r\n        require(IERC20(YlFiAddress).totalSupply() != 0, \"This address is not ERC20 Token\");\r\n        address msgSender = _msgSender();\r\n        _YlFitoken = YlFiAddress;\r\n        _owner = msgSender;\r\n        _tokenStakeList.push(YlFiAddress);\r\n        est.equalReward = 10**18;\r\n        est.symboltoken = \"YlFi\";\r\n        nul.symboltoken = \"N/A\";\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    \r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    \r\n    function addTokenReward(address erc20Token, uint256 amountEqual, string memory symboltokens) public virtual onlyOwner{\r\n        require(erc20Token.isContract() == true,\"This address is not Smartcontract\");\r\n        require(IERC20(erc20Token).totalSupply() != 0, \"This address is not ERC20 Token\");\r\n        rewardDetail storage est = ERC20perYlFi[erc20Token];\r\n        est.equalReward = amountEqual;\r\n        est.symboltoken = symboltokens;\r\n        \r\n        _tokenStakeList.push(erc20Token);\r\n    }\r\n    \r\n    function editTokenReward(address erc20Token, uint256 amountEqual, string memory symboltokens) public virtual onlyOwner{\r\n        require(erc20Token.isContract() == true,\"This address is not Smartcontract\");\r\n        require(IERC20(erc20Token).totalSupply() != 0, \"This address is not ERC20 Token\");\r\n        \r\n        rewardDetail storage est = ERC20perYlFi[erc20Token];\r\n        est.equalReward = amountEqual;\r\n        est.symboltoken = symboltokens;\r\n    }\r\n    \r\n    function addPeriod(uint256 timePeriodStake, uint256 timeCooldownUnstake, uint256 formula1, uint256 formula2, uint256 fpel1, uint256 fpel2) public virtual onlyOwner{\r\n        uint newPeriod = _periodList.length;\r\n        if(newPeriod == 0){\r\n            newPeriod = 1;\r\n        }else{\r\n            newPeriod = newPeriod + 1;\r\n        }\r\n        \r\n        periodList storage sys = period[newPeriod];\r\n        sys.periodTime = timePeriodStake;\r\n        sys.cooldownTime = timeCooldownUnstake;\r\n        sys.formulaParam1 = formula1;\r\n        sys.formulaParam2 = formula2;\r\n        sys.formulaPenalty1 = fpel1;\r\n        sys.formulaPenalty2 = fpel2;\r\n        \r\n        _periodList.push(newPeriod);\r\n    }\r\n    \r\n    function editPeriod(uint periodEdit, uint256 timePeriodStake, uint256 timeCooldownUnstake, uint256 formula1, uint256 formula2, uint256 fpel1, uint256 fpel2) public virtual onlyOwner{\r\n        periodList storage sys = period[periodEdit];\r\n        sys.periodTime = timePeriodStake;\r\n        sys.cooldownTime = timeCooldownUnstake;\r\n        sys.formulaParam1 = formula1;\r\n        sys.formulaParam2 = formula2;\r\n        sys.formulaPenalty1 = fpel1;\r\n        sys.formulaPenalty2 = fpel2;\r\n    }\r\n    \r\n    function claimReward() public virtual{\r\n        address msgSender = _msgSender();\r\n        userStaking storage usr = stakerDetail[msgSender];\r\n        uint256 getrewardbalance = IERC20(usr.tokenWantStake).balanceOf(address(this));\r\n        uint256 getReward = getRewardClaimable(msgSender);\r\n        uint256 today = block.timestamp;\r\n        \r\n        require(getrewardbalance >= getReward, \"Please wait until reward pool filled, try again later.\");\r\n        require(usr.claimStake < block.timestamp, \"Please wait until wait time reached.\");\r\n        \r\n        usr.claimed = usr.claimed.add(getReward);\r\n        // usr.claimStake = today.add(7 days);\r\n        usr.claimStake = today.add(1 minutes);\r\n        IERC20(usr.tokenWantStake).safeTransfer(msgSender, getReward);\r\n        emit Claim(msgSender, usr.tokenWantStake, getReward);\r\n    }\r\n    \r\n    function stakeNow(address tokenTargetStake, uint256 amountWantStake, uint periodwant) public virtual{\r\n        address msgSender = _msgSender();\r\n        uint256 getallowance = IERC20(_YlFitoken).allowance(msgSender, address(this));\r\n        \r\n        if(getRewardClaimable(msgSender) > 0){\r\n            revert(\"Please claim your reward from previous staking\");\r\n        }\r\n        \r\n        require(amountWantStake >= 500000000000, \"Minimum staking 0.00005 YlFi\");\r\n        require(getallowance >= amountWantStake, \"Insufficient YlFi token approval balance, you must increase your allowance\" );\r\n        \r\n        uint256 today = block.timestamp;\r\n        userStaking storage usr = stakerDetail[msgSender];\r\n        periodList storage sys = period[periodwant];\r\n        \r\n        usr.activeStake = true;\r\n        usr.periodChoosed = periodwant;\r\n        usr.tokenWantStake = tokenTargetStake;\r\n        usr.amountStaked = amountWantStake;\r\n        usr.startStake = today;\r\n        // usr.claimStake = today.add(7 days);\r\n        usr.claimStake = today.add(1 minutes);\r\n        usr.cooldownDate = today.add(sys.cooldownTime);\r\n        usr.endStake = today.add(sys.periodTime);\r\n        usr.claimed = 0;\r\n        \r\n        bool checkregis = false;\r\n        for(uint i = 0; i < _stakerList.length; i++){\r\n            if(_stakerList[i] == msgSender){\r\n                checkregis = true;\r\n            }\r\n        }\r\n        \r\n        if(checkregis == false){\r\n            _stakerList.push(msgSender);\r\n        }\r\n        \r\n        IERC20(_YlFitoken).safeTransferFrom(msgSender, address(this), amountWantStake);\r\n        emit Stake(msgSender, tokenTargetStake, amountWantStake);\r\n    }\r\n    \r\n    function unstakeNow() public virtual{\r\n        address msgSender = _msgSender();\r\n        userStaking storage usr = stakerDetail[msgSender];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        \r\n        require(usr.activeStake == true, \"Stake not active yet\" );\r\n        \r\n        uint256 tokenUnstake;\r\n        if(block.timestamp < usr.cooldownDate){\r\n            uint256 penfee = usr.amountStaked.mul(sys.formulaPenalty1);\r\n            penfee = penfee.div(sys.formulaPenalty2);\r\n            penfee = penfee.div(100);\r\n            tokenUnstake = usr.amountStaked.sub(penfee);\r\n        }else{\r\n            tokenUnstake = usr.amountStaked;\r\n        }\r\n        \r\n        usr.activeStake = false;\r\n        if(block.timestamp < usr.endStake){\r\n            usr.endStake = block.timestamp;\r\n        }\r\n        \r\n        IERC20(_YlFitoken).safeTransfer(msgSender, tokenUnstake);\r\n        \r\n        emit Unstake(msgSender, usr.tokenWantStake, usr.amountStaked);\r\n    }\r\n    \r\n    function getEqualReward(address erc20Token) public view returns(uint256, string memory){\r\n        rewardDetail storage est = ERC20perYlFi[erc20Token];\r\n        return(\r\n            est.equalReward,\r\n            est.symboltoken\r\n        );\r\n    }\r\n    \r\n    function getTotalStaker() public view returns(uint256){\r\n        return _stakerList.length;\r\n    }\r\n    \r\n    function getActiveStaker() view public returns(uint256){\r\n        uint256 activeStake;\r\n        for(uint i = 0; i < _stakerList.length; i++){\r\n            userStaking memory l = stakerDetail[_stakerList[i]];\r\n            if(l.activeStake == true){\r\n                activeStake = activeStake + 1;\r\n            }\r\n        }\r\n        return activeStake;\r\n    }\r\n    \r\n    function getTokenList() public view returns(address[] memory){\r\n        return _tokenStakeList;\r\n    }\r\n    \r\n    function getPeriodList() public view returns(uint[] memory){\r\n        return _periodList;\r\n    }\r\n    \r\n    function getPeriodDetail(uint periodwant) public view returns(uint256, uint256, uint256, uint256, uint256, uint256){\r\n        periodList storage sys = period[periodwant];\r\n        return(\r\n            sys.periodTime,\r\n            sys.cooldownTime,\r\n            sys.formulaParam1,\r\n            sys.formulaParam2,\r\n            sys.formulaPenalty1,\r\n            sys.formulaPenalty2\r\n        );\r\n    }\r\n    \r\n    function getUserInfo(address stakerAddress) public view returns(bool, uint, address, string memory, uint256, uint256, uint256, uint256, uint256, uint256){\r\n        userStaking storage usr = stakerDetail[stakerAddress];\r\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\r\n        \r\n        uint256 amountTotalStaked;\r\n        if(usr.activeStake == false){\r\n            amountTotalStaked = 0;\r\n        }else{\r\n            amountTotalStaked = usr.amountStaked;\r\n        }\r\n        return(\r\n            usr.activeStake,\r\n            usr.periodChoosed,\r\n            usr.tokenWantStake,\r\n            est.symboltoken,\r\n            amountTotalStaked,\r\n            usr.startStake,\r\n            usr.claimStake,\r\n            usr.endStake,\r\n            usr.cooldownDate,\r\n            usr.claimed\r\n        );\r\n    }\r\n    \r\n    function getRewardClaimable(address stakerAddress) public view returns(uint256){\r\n        userStaking storage usr = stakerDetail[stakerAddress];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\r\n        \r\n        uint256 rewards;\r\n        \r\n        if(usr.amountStaked == 0 && usr.tokenWantStake == address(0)){\r\n            rewards = 0;\r\n        }else{\r\n            uint256 perSec = usr.amountStaked.mul(sys.formulaParam1);\r\n            perSec = perSec.div(sys.formulaParam2);\r\n            perSec = perSec.div(100);\r\n            \r\n            uint256 today = block.timestamp;\r\n            uint256 diffTime;\r\n            if(today > usr.endStake){\r\n                diffTime = usr.endStake.sub(usr.startStake);\r\n            }else{\r\n                diffTime = today.sub(usr.startStake);\r\n            }\r\n            rewards = perSec.mul(diffTime);\r\n            uint256 getTokenEqual = est.equalReward;\r\n            rewards = rewards.mul(getTokenEqual);\r\n            rewards = rewards.div(10**18);\r\n            rewards = rewards.sub(usr.claimed);\r\n        }\r\n        return rewards;\r\n    }\r\n    \r\n    function getRewardObtained(address stakerAddress) public view returns(uint256){\r\n        userStaking storage usr = stakerDetail[stakerAddress];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\r\n        uint256 rewards;\r\n        \r\n        if(usr.amountStaked == 0 && usr.tokenWantStake == address(0)){\r\n            rewards = 0;\r\n        }else{\r\n            uint256 perSec = usr.amountStaked.mul(sys.formulaParam1);\r\n            perSec = perSec.div(sys.formulaParam2);\r\n            perSec = perSec.div(100);\r\n            \r\n            uint256 today = block.timestamp;\r\n            uint256 diffTime;\r\n            if(today > usr.endStake){\r\n                diffTime = usr.endStake.sub(usr.startStake);\r\n            }else{\r\n                diffTime = today.sub(usr.startStake);\r\n            }\r\n            rewards = perSec.mul(diffTime);\r\n            uint256 getTokenEqual = est.equalReward;\r\n            rewards = rewards.mul(getTokenEqual);\r\n            rewards = rewards.div(10**18);\r\n        }\r\n        return rewards;\r\n    }\r\n    \r\n    function getRewardEstimator(address stakerAddress) public view returns(uint256,uint256,uint256,uint256,uint256,uint256){\r\n        userStaking storage usr = stakerDetail[stakerAddress];\r\n        periodList storage sys = period[usr.periodChoosed];\r\n        rewardDetail storage est = ERC20perYlFi[usr.tokenWantStake];\r\n        uint256 amountStakedNow;\r\n        \r\n        if(usr.activeStake == true){\r\n            amountStakedNow = usr.amountStaked;\r\n            uint256 perSec = amountStakedNow.mul(sys.formulaParam1);\r\n            uint256 getTokenEqual = est.equalReward;\r\n            perSec = perSec.div(sys.formulaParam2);\r\n            perSec = perSec.div(100);\r\n            perSec = perSec.mul(getTokenEqual);\r\n            perSec = perSec.div(10**18);\r\n            \r\n            return(\r\n                perSec,\r\n                perSec.mul(60),\r\n                perSec.mul(3600),\r\n                perSec.mul(86400),\r\n                perSec.mul(604800),\r\n                perSec.mul(2592000)\r\n            );\r\n        }else{\r\n            return(0,0,0,0,0,0);\r\n        }\r\n        \r\n    }\r\n    \r\n    function getRewardCalculator(address tokenWantStake, uint256 amountWantStake, uint periodwant) public view returns(uint256){\r\n        periodList storage sys = period[periodwant];\r\n        rewardDetail storage est = ERC20perYlFi[tokenWantStake];\r\n        \r\n        uint256 perSec = amountWantStake.mul(sys.formulaParam1);\r\n        perSec = perSec.div(sys.formulaParam2);\r\n        perSec = perSec.div(100);\r\n        \r\n        uint256 startDate = block.timestamp;\r\n        uint256 endDate = startDate.add(sys.periodTime);\r\n        uint256 diffTime = endDate.sub(startDate);\r\n        uint256 rewards = perSec.mul(diffTime);\r\n        uint256 getTokenEqual = est.equalReward;\r\n        rewards = rewards.mul(getTokenEqual);\r\n        rewards = rewards.div(10**18);\r\n        return rewards;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"YlFiAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenStakeTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountReward\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenStakeTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountTokenStaked\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenStakeTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountTokenStaked\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timePeriodStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCooldownUnstake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel2\",\"type\":\"uint256\"}],\"name\":\"addPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountEqual\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symboltokens\",\"type\":\"string\"}],\"name\":\"addTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodEdit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePeriodStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeCooldownUnstake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"formula2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fpel2\",\"type\":\"uint256\"}],\"name\":\"editPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountEqual\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symboltokens\",\"type\":\"string\"}],\"name\":\"editTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"getEqualReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"periodwant\",\"type\":\"uint256\"}],\"name\":\"getPeriodDetail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPeriodList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenWantStake\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWantStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodwant\",\"type\":\"uint256\"}],\"name\":\"getRewardCalculator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"getRewardClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"getRewardEstimator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"getRewardObtained\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenTargetStake\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountWantStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodwant\",\"type\":\"uint256\"}],\"name\":\"stakeNow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeNow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"YlFiStake","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000186af393bf9ceef31ce7eae2b468c46231163cc7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4ea72b78ce04392838d351274de0c4fc9e2dde85cf3bab2c4f511907912b8a2e"}]}