{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Arbrito.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\nimport \\\"./external/IBalancer.sol\\\";\\nimport \\\"./external/IUniswap.sol\\\";\\nimport \\\"./external/IERC20.sol\\\";\\nimport \\\"./external/IWeth.sol\\\";\\n\\ncontract Arbrito is IUniswapPairCallee {\\n  enum Borrow { Token0, Token1 }\\n\\n  address[] public tokens;\\n  mapping(address => uint256) public balances;\\n\\n  address immutable WETH_ADDRESS;\\n  address immutable UNISWAP_ROUTER_ADDRESS;\\n  address payable immutable OWNER;\\n\\n  constructor(address wethAddress, address uniswapRouterAddress) {\\n    UNISWAP_ROUTER_ADDRESS = uniswapRouterAddress;\\n    WETH_ADDRESS = wethAddress;\\n    OWNER = msg.sender;\\n  }\\n\\n  receive() external payable {}\\n\\n  function perform(\\n    Borrow borrow,\\n    uint256 amount,\\n    address uniswapPair,\\n    address balancerPool,\\n    address uniswapToken0,\\n    address uniswapToken1,\\n    uint256 uniswapReserve0,\\n    uint256 uniswapReserve1,\\n    uint256 balancerBalance0,\\n    uint256 balancerBalance1\\n  ) external {\\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapPair(uniswapPair).getReserves();\\n\\n    require(\\n      borrow == Borrow.Token0\\n        ? (reserve0 >= uniswapReserve0 && reserve1 <= uniswapReserve1)\\n        : (reserve0 <= uniswapReserve0 && reserve1 >= uniswapReserve1),\\n      \\\"Uniswap reserves mismatch\\\"\\n    );\\n\\n    {\\n      uint256 balance0 = IBalancerPool(balancerPool).getBalance(uniswapToken0);\\n      uint256 balance1 = IBalancerPool(balancerPool).getBalance(uniswapToken1);\\n\\n      require(\\n        borrow == Borrow.Token0\\n          ? balance0 <= balancerBalance0 && balance1 >= balancerBalance1\\n          : balance0 >= balancerBalance0 && balance1 <= balancerBalance1,\\n        \\\"Balancer balances mismatch\\\"\\n      );\\n    }\\n\\n    bytes memory payload =\\n      abi.encode(balancerPool, uniswapToken0, uniswapToken1, reserve0, reserve1);\\n\\n    if (borrow == Borrow.Token0) {\\n      IUniswapPair(uniswapPair).swap(amount, 0, address(this), payload);\\n    } else {\\n      IUniswapPair(uniswapPair).swap(0, amount, address(this), payload);\\n    }\\n  }\\n\\n  function uniswapV2Call(\\n    address sender,\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external override {\\n    (\\n      address balancerPoolAddress,\\n      address token0,\\n      address token1,\\n      uint256 reserve0,\\n      uint256 reserve1\\n    ) = abi.decode(data, (address, address, address, uint256, uint256));\\n\\n    uint256 amountTrade;\\n    uint256 amountPayback;\\n\\n    address tokenPayback;\\n    address tokenTrade;\\n\\n    if (amount0 != 0) {\\n      amountTrade = amount0;\\n      (tokenTrade, tokenPayback) = (token0, token1);\\n      amountPayback = calculateUniswapPayback(amountTrade, reserve1, reserve0);\\n    } else {\\n      amountTrade = amount1;\\n      (tokenPayback, tokenTrade) = (token0, token1);\\n      amountPayback = calculateUniswapPayback(amountTrade, reserve0, reserve1);\\n    }\\n\\n    allow(sender, balancerPoolAddress, tokenTrade, amountTrade);\\n\\n    (uint256 balancerAmountOut, ) =\\n      IBalancerPool(balancerPoolAddress).swapExactAmountIn(\\n        tokenTrade,\\n        amountTrade,\\n        tokenPayback,\\n        amountPayback,\\n        uint256(-1)\\n      );\\n\\n    require(IERC20(tokenPayback).transfer(msg.sender, amountPayback), \\\"Payback failed\\\");\\n\\n    if (balances[tokenPayback] == 0) {\\n      tokens.push(tokenPayback);\\n    }\\n\\n    balances[tokenPayback] += balancerAmountOut - amountPayback;\\n  }\\n\\n  function allow(\\n    address owner,\\n    address spender,\\n    address token,\\n    uint256 amount\\n  ) internal {\\n    if (IERC20(token).allowance(owner, spender) < amount) {\\n      IERC20(token).approve(spender, uint256(-1));\\n    }\\n  }\\n\\n  function calculateUniswapPayback(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) internal pure returns (uint256) {\\n    uint256 numerator = reserveIn * amountOut * 1000;\\n    uint256 denominator = (reserveOut - amountOut) * 997;\\n    return numerator / denominator + 1;\\n  }\\n\\n  function withdraw() external {\\n    address[] memory path = new address[](2);\\n    address me = address(this);\\n    path[1] = WETH_ADDRESS;\\n\\n    uint256 weth = 0;\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tokens[i];\\n\\n      if (token == WETH_ADDRESS) {\\n        weth += balances[token];\\n      } else {\\n        path[0] = token;\\n\\n        allow(me, UNISWAP_ROUTER_ADDRESS, token, balances[token]);\\n\\n        weth += IUniswapRouter(UNISWAP_ROUTER_ADDRESS).swapExactTokensForTokens(\\n          balances[token],\\n          0,\\n          path,\\n          me,\\n          block.timestamp\\n        )[1];\\n      }\\n\\n      delete balances[token];\\n    }\\n\\n    delete tokens;\\n\\n    IWeth(WETH_ADDRESS).withdraw(weth);\\n    OWNER.transfer(weth);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/IBalancer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IBalancerPool {\\n  function swapExactAmountIn(\\n    address tokenIn,\\n    uint256 tokenAmountIn,\\n    address tokenOut,\\n    uint256 minAmountOut,\\n    uint256 maxPrice\\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n  function getBalance(address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/IUniswap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IUniswapPairCallee {\\n  function uniswapV2Call(\\n    address sender,\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external;\\n}\\n\\ninterface IUniswapRouter {\\n  function swapExactTokensForTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapPair {\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/external/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IERC20 {\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/IWeth.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.7.5;\\n\\ninterface IWeth {\\n  function withdraw(uint256 wad) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouterAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Arbrito.Borrow\",\"name\":\"borrow\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balancerPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapToken0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapToken1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uniswapReserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniswapReserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancerBalance0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancerBalance1\",\"type\":\"uint256\"}],\"name\":\"perform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Arbrito","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}