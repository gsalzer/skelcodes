{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 { // brief interface for erc20 token tx\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n    \r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    \r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returnData) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returnData.length > 0) { // return data is optional\r\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // arithmetic wrapper for unit under/overflow check\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard { // call wrapper for reentrancy check\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract MYSTIC is ReentrancyGuard { \r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    address public depositToken; // deposit token contract reference - default = wETH\r\n    address public stakeToken; // stake token contract reference for guild voting shares \r\n    address public constant wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // canonical ether token wrapper contract reference \r\n    uint256 public proposalDeposit; // default = 10 deposit token \r\n    uint256 public processingReward; // default = 0.1 - amount of deposit token to give to whoever processes a proposal\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public summoningTime; // needed to determine the current period\r\n    bool private initialized; // internally tracks deployment under eip-1167 proxy pattern\r\n    \r\n    // HARD-CODED LIMITS\r\n    uint256 constant MAX_GUILD_BOUND = 10**36; // maximum bound for guild member accounting\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\r\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\r\n\r\n    // GUILD TOKEN DETAILS\r\n    uint8 public constant decimals = 18;\r\n    string public name; // set at summoning\r\n    string public constant symbol = \"DAO\";\r\n    \r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xdeaf);\r\n    address public constant TOTAL = address(0xdeed);\r\n    uint256 public proposalCount; // total proposals submitted\r\n    uint256 public totalShares; // total shares across all members\r\n    uint256 public totalLoot; // total loot across all members\r\n    uint256 public totalSupply; // total shares & loot across all members (total guild tokens)\r\n    uint256 public totalGuildBankTokens; // total tokens with non-zero balance in guild bank\r\n\r\n    mapping(address => uint256) public balanceOf; // guild token balances\r\n    mapping(address => mapping(address => uint256)) public allowance; // guild token (loot) allowances\r\n    mapping(address => mapping(address => uint256)) private userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n    \r\n    address[] public approvedTokens;\r\n    mapping(address => bool) public tokenWhitelist;\r\n    \r\n    uint256[] public proposalQueue;\r\n    mapping(uint256 => bytes) public actions; \r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    mapping(address => bool) public proposedToWhitelist;\r\n    mapping(address => bool) public proposedToKick;\r\n    \r\n    mapping(address => Member) public members;\r\n    mapping(address => address) public memberAddressByDelegateKey;\r\n\r\n    // **************\r\n    // EVENT TRACKING\r\n    // **************\r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, uint8[8] flags, bytes data, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessActionProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n    event ConvertSharesToLoot(address indexed memberAddress, uint256 amount);\r\n    event StakeTokenForShares(address indexed memberAddress, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount); // guild token (loot) allowance tracking\r\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount); // guild token mint, burn & loot transfer tracking\r\n    \r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n    \r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals & voting - defaults to member address unless updated\r\n        uint8 exists; // always true (1) once a member has been created\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragekick) - transferable by guild token\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on & sponsoring proposals\r\n    }\r\n    \r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as target for alt. proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        address tributeToken; // tribute token contract reference\r\n        address paymentToken; // payment token contract reference\r\n        uint8[8] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        bytes32 details; // proposal details to add context for members \r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n    \r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"!delegate\");\r\n        _;\r\n    }\r\n\r\n    function init(\r\n        address _depositToken,\r\n        address _stakeToken,\r\n        address[] memory _summoner,\r\n        uint256[] memory _summonerShares,\r\n        uint256 _summonerDeposit,\r\n        uint256 _proposalDeposit,\r\n        uint256 _processingReward,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _dilutionBound,\r\n        string memory _guildName\r\n    ) external {\r\n        require(!initialized, \"initialized\");\r\n        require(_depositToken != _stakeToken, \"depositToken = stakeToken\");\r\n        require(_summoner.length == _summonerShares.length, \"summoner != summonerShares\");\r\n        require(_proposalDeposit >= _processingReward, \"_processingReward > _proposalDeposit\");\r\n        \r\n        for (uint256 i = 0; i < _summoner.length; i++) {\r\n            growGuild(_summoner[i], _summonerShares[i], 0);\r\n        }\r\n        \r\n        require(totalShares <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        tokenWhitelist[_depositToken] = true;\r\n        approvedTokens.push(_depositToken);\r\n        \r\n        if (_summonerDeposit > 0) {\r\n            totalGuildBankTokens += 1;\r\n            unsafeAddToBalance(GUILD, _depositToken, _summonerDeposit);\r\n        }\r\n        \r\n        depositToken = _depositToken;\r\n        stakeToken = _stakeToken;\r\n        proposalDeposit = _proposalDeposit;\r\n        processingReward = _processingReward;\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        dilutionBound = _dilutionBound;\r\n        summoningTime = now;\r\n        name = _guildName;\r\n        initialized = true;\r\n    }\r\n    \r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details\r\n    ) external nonReentrant payable returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        require(tokenWhitelist[tributeToken], \"tributeToken != whitelist\");\r\n        require(tokenWhitelist[paymentToken], \"paymentToken != whitelist\");\r\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant unreservable\");\r\n        require(members[applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n        \r\n        // collect tribute from proposer & store it in MYSTIC until the proposal is processed - if ether, wrap into wETH\r\n        if (msg.value > 0) {\r\n            require(tributeToken == wETH && msg.value == tributeOffered, \"!ethBalance\");\r\n            (bool success, ) = wETH.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(wETH).safeTransfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(tributeToken).safeTransferFrom(msg.sender, address(this), tributeOffered);\r\n        }\r\n        \r\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n        \r\n        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\r\n        flags[7] = 1; // standard\r\n\r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, \"\");\r\n        \r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n    \r\n     function submitActionProposal( // stages arbitrary function calls for member vote - based on Raid Guild 'Minion'\r\n        address actionTo, // target account for action (e.g., address to receive ether, token, dao, etc.)\r\n        uint256 actionTokenAmount, // helps check outbound guild bank token amount does not exceed internal balance / amount to update bank if successful \r\n        uint256 actionValue, // ether value, if any, in call \r\n        bytes32 details, // details tx staged for member execution - as external, extra care should be applied in diligencing action \r\n        bytes calldata data // data for function call\r\n    ) external nonReentrant returns (uint256 proposalId) {\r\n        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\r\n        flags[6] = 1; // action\r\n        \r\n        _submitProposal(actionTo, 0, 0, actionValue, address(0), actionTokenAmount, address(0), details, flags, data);\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function submitGuildKickProposal(address memberToKick, bytes32 details) external nonReentrant returns (uint256 proposalId) {\r\n        Member memory member = members[memberToKick];\r\n        require(member.shares > 0 || member.loot > 0, \"!share||loot\");\r\n        require(members[memberToKick].jailed == 0, \"jailed\");\r\n        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\r\n        flags[5] = 1; // guildkick\r\n\r\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags, \"\");\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function submitWhitelistProposal(address tokenToWhitelist, bytes32 details) external nonReentrant returns (uint256 proposalId) {\r\n        require(tokenToWhitelist != address(0), \"!token\");\r\n        require(tokenToWhitelist != stakeToken, \"tokenToWhitelist = stakeToken\");\r\n        require(!tokenWhitelist[tokenToWhitelist], \"whitelisted\");\r\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\r\n        flags[4] = 1; // whitelist\r\n\r\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags, \"\");\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details,\r\n        uint8[8] memory flags,\r\n        bytes memory data\r\n    ) internal {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            tributeToken : tributeToken,\r\n            paymentToken : paymentToken,\r\n            flags : flags,\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            paymentRequested : paymentRequested,\r\n            tributeOffered : tributeOffered,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            maxTotalSharesAndLootAtYesVote : 0,\r\n            details : details\r\n        });\r\n        \r\n        if (proposal.flags[6] == 1) {\r\n            actions[proposalCount] = data;\r\n        }\r\n        \r\n        proposals[proposalCount] = proposal;\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, data, proposalCount, msg.sender, memberAddressByDelegateKey[msg.sender]);\r\n        \r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) external nonReentrant onlyDelegate {\r\n        // collect proposal deposit from sponsor & store it in MYSTIC until the proposal is processed\r\n        IERC20(depositToken).safeTransferFrom(msg.sender, address(this), proposalDeposit);\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.proposer != address(0), \"!proposed\");\r\n        require(proposal.flags[0] == 0, \"sponsored\");\r\n        require(proposal.flags[3] == 0, \"cancelled\");\r\n        require(members[proposal.applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n\r\n        // whitelist proposal\r\n        if (proposal.flags[4] == 1) {\r\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"whitelisted\");\r\n            require(!proposedToWhitelist[address(proposal.tributeToken)], \"whitelist proposed\");\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\r\n\r\n        // guild kick proposal\r\n        } else if (proposal.flags[5] == 1) {\r\n            require(!proposedToKick[proposal.applicant], \"kick proposed\");\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length - 1]].startingPeriod\r\n        ) + 1;\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n        proposal.sponsor = memberAddressByDelegateKey[msg.sender];\r\n        proposal.flags[0] = 1; // sponsored\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, proposal.sponsor, proposalId, proposalQueue.length - 1, startingPeriod);\r\n    }\r\n\r\n    // NOTE: In MYSTIC, proposalIndex != proposalId\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n        require(proposalIndex < proposalQueue.length, \"!proposed\");\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(uintVote < 3, \">2\");\r\n        Vote vote = Vote(uintVote);\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"pending\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"!Yes||No\");\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes += member.shares;\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalSupply > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalSupply;\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes += member.shares;\r\n        }\r\n     \r\n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set until it's been sponsored but proposal is created on submission\r\n        emit SubmitVote(proposalId, proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[7] == 1, \"!standard\");\r\n        proposal.flags[1] = 1; // processed\r\n        \r\n        bool didPass = _didPass(proposalIndex);\r\n        // Make the proposal fail if the new total number of shares & loot exceeds the limit\r\n        if (totalSupply.add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_GUILD_BOUND) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n\r\n            growGuild(proposal.applicant, proposal.sharesRequested, proposal.lootRequested);\r\n\r\n            // if the proposal tribute is the first token of its kind to make it into the guild bank, increment total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\r\n                totalGuildBankTokens += 1;\r\n            }\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n\r\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\r\n                totalGuildBankTokens -= 1;\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n    \r\n     function processActionProposal(uint256 proposalIndex) external nonReentrant returns (bool, bytes memory) {\r\n        _validateProposalForProcessing(proposalIndex);\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        bytes storage action = actions[proposalId];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[6] == 1, \"!action\");\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n        // Make the proposal fail if it is requesting more accounted tokens than the available guild bank balance\r\n        if (tokenWhitelist[proposal.applicant] && proposal.paymentRequested > userTokenBalances[GUILD][proposal.applicant]) {\r\n            didPass = false;\r\n        }\r\n        \r\n        // Make the proposal fail if it is requesting more ether than the available local balance\r\n        if (proposal.tributeOffered > address(this).balance) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n            (bool success, bytes memory returnData) = proposal.applicant.call{value: proposal.tributeOffered}(action);\r\n            if (tokenWhitelist[proposal.applicant]) {\r\n                unsafeSubtractFromBalance(GUILD, proposal.applicant, proposal.paymentRequested);\r\n                // if the action proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n                if (userTokenBalances[GUILD][proposal.applicant] == 0 && proposal.paymentRequested > 0) {totalGuildBankTokens -= 1;}\r\n            }\r\n            return (success, returnData);\r\n        }\r\n        \r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessActionProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[5] == 1, \"!kick\");\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed = proposalIndex;\r\n            // transfer shares to loot\r\n            member.loot = member.loot.add(member.shares);\r\n            totalShares = totalShares.sub(member.shares);\r\n            totalLoot = totalLoot.add(member.shares);\r\n            member.shares = 0; // revoke all shares\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n    \r\n    function processWhitelistProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[4] == 1, \"!whitelist\");\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n            tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            approvedTokens.push(proposal.tributeToken);\r\n        }\r\n\r\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n    \r\n    function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n        \r\n        if (proposal.yesVotes > proposal.noVotes) {\r\n            didPass = true;\r\n        }\r\n        \r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalSupply.mul(dilutionBound)) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed != 0) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\r\n        require(proposalIndex < proposalQueue.length, \"!proposal\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"!ready\");\r\n        require(proposal.flags[1] == 0, \"processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex - 1]].flags[1] == 1, \"prior !processed\");\r\n    }\r\n\r\n    function _returnDeposit(address sponsor) internal {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\r\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit - processingReward);\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) external nonReentrant {\r\n        require(members[msg.sender].exists == 1, \"!member\");\r\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\r\n        uint256 initialTotalSharesAndLoot = totalSupply;\r\n        Member storage member = members[memberAddress];\r\n        require(member.shares >= sharesToBurn, \"!shares\");\r\n        require(member.loot >= lootToBurn, \"!loot\");\r\n        require(canRagequit(member.highestIndexYesVote), \"!ragequit until highest index proposal member voted YES processes\");\r\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\r\n\r\n        // burn guild token, shares & loot\r\n        balanceOf[memberAddress] = balanceOf[memberAddress].sub(sharesAndLootToBurn);\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        member.loot = member.loot.sub(lootToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n        totalLoot = totalLoot.sub(lootToBurn);\r\n        totalSupply = totalShares.add(totalLoot);\r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\r\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n            }\r\n        }\r\n\r\n        emit Ragequit(memberAddress, sharesToBurn, lootToBurn);\r\n        emit Transfer(memberAddress, address(0), sharesAndLootToBurn);\r\n    }\r\n\r\n    function ragekick(address memberToKick) external nonReentrant onlyDelegate {\r\n        Member storage member = members[memberToKick];\r\n        require(member.jailed != 0, \"!jailed\");\r\n        require(member.loot > 0, \"!loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"!ragequit until highest index proposal member voted YES processes\");\r\n        _ragequit(memberToKick, 0, member.loot);\r\n    }\r\n    \r\n    function withdrawBalance(address token, uint256 amount) external nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n\r\n    function withdrawBalances(address[] calldata tokens, uint256[] calldata amounts, bool max) external nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens != amounts\");\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    function _withdrawBalance(address token, uint256 amount) internal {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"!balance\");\r\n        IERC20(token).safeTransfer(msg.sender, amount);\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    function collectTokens(address token) external nonReentrant onlyDelegate {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\r\n        // only collect if 1) there are tokens to collect & 2) token is whitelisted\r\n        require(amountToCollect > 0, \"!amount\");\r\n        require(tokenWhitelist[token], \"!whitelisted\");\r\n        \r\n        if (userTokenBalances[GUILD][token] == 0 && totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT) {totalGuildBankTokens += 1;}\r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n\r\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender = proposal.proposer\r\n    function cancelProposal(uint256 proposalId) external nonReentrant {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[0] == 0, \"sponsored\");\r\n        require(proposal.flags[3] == 0, \"cancelled\");\r\n        require(msg.sender == proposal.proposer, \"!proposer\");\r\n        proposal.flags[3] = 1; // cancelled\r\n       \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        \r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) external nonReentrant {\r\n        require(members[msg.sender].shares > 0, \"!shareholder\");\r\n        require(newDelegateKey != address(0), \"newDelegateKey = 0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(members[newDelegateKey].exists == 0, \"!overwrite members\");\r\n            require(members[memberAddressByDelegateKey[newDelegateKey]].exists == 0, \"!overwrite keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n    \r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"!proposal\");\r\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n    \r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n    \r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) external view returns (Vote) {\r\n        require(members[memberAddress].exists == 1, \"!member\");\r\n        require(proposalIndex < proposalQueue.length, \"!proposed\");\r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) external view returns (uint8[8] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n    \r\n    function getProposalQueueLength() external view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n    \r\n    function getTokenCount() external view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) external view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n    \r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    receive() external payable {}\r\n    \r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) internal pure returns (uint256) {\r\n        require(totalSharesAndLoot != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalSharesAndLoot;\r\n        }\r\n\r\n        return (balance / totalSharesAndLoot) * shares;\r\n    }\r\n    \r\n    function growGuild(address account, uint256 shares, uint256 loot) internal {\r\n        // if the account is already a member, add to their existing shares & loot\r\n        if (members[account].exists == 1) {\r\n            members[account].shares = members[account].shares.add(shares);\r\n            members[account].loot = members[account].loot.add(loot);\r\n\r\n        // if the account is a new member, create a new record for them\r\n        } else {\r\n            // if new member is already taken by a member's delegateKey, reset it to their member address\r\n            if (members[memberAddressByDelegateKey[account]].exists == 1) {\r\n                address memberToOverride = memberAddressByDelegateKey[account];\r\n                memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n                members[memberToOverride].delegateKey = memberToOverride;\r\n            }\r\n        \r\n            members[account] = Member({\r\n                delegateKey : account,\r\n                exists : 1, // 'true'\r\n                shares : shares,\r\n                loot : loot.add(members[account].loot), // take into account loot from pre-membership transfers\r\n                highestIndexYesVote : 0,\r\n                jailed : 0\r\n            });\r\n            memberAddressByDelegateKey[account] = account;\r\n        }\r\n        \r\n        uint256 sharesAndLoot = shares.add(loot);\r\n        // mint new guild token, update total shares & loot \r\n        balanceOf[account] = balanceOf[account].add(sharesAndLoot);\r\n        totalShares = totalShares.add(shares);\r\n        totalLoot = totalLoot.add(loot);\r\n        totalSupply = totalShares.add(totalLoot);\r\n        \r\n        emit Transfer(address(0), account, sharesAndLoot);\r\n    }\r\n    \r\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n    \r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n    \r\n    /********************\r\n    GUILD TOKEN FUNCTIONS\r\n    ********************/\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        require(amount == 0 || allowance[msg.sender][spender] == 0);\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function convertSharesToLoot(uint256 sharesToLoot) external nonReentrant {\r\n        members[msg.sender].shares = members[msg.sender].shares.sub(sharesToLoot);\r\n        members[msg.sender].loot = members[msg.sender].loot.add(sharesToLoot);\r\n        totalShares = totalShares.sub(sharesToLoot);\r\n        totalLoot = totalLoot.add(sharesToLoot);\r\n        emit ConvertSharesToLoot(msg.sender, sharesToLoot);\r\n    }\r\n    \r\n    function stakeTokenForShares(uint256 amount) external nonReentrant {\r\n        IERC20(stakeToken).safeTransferFrom(msg.sender, address(this), amount); // deposit stake token & claim shares (1:1)\r\n        growGuild(msg.sender, amount, 0);\r\n        require(totalSupply <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        emit StakeTokenForShares(msg.sender, amount);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 lootToTransfer) external returns (bool) {\r\n        members[msg.sender].loot = members[msg.sender].loot.sub(lootToTransfer);\r\n        members[recipient].loot = members[recipient].loot.add(lootToTransfer);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(lootToTransfer);\r\n        balanceOf[recipient] = balanceOf[recipient].add(lootToTransfer);\r\n        emit Transfer(msg.sender, recipient, lootToTransfer);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 lootToTransfer) external returns (bool) {\r\n        allowance[sender][msg.sender] = allowance[sender][msg.sender].sub(lootToTransfer);\r\n        members[sender].loot = members[sender].loot.sub(lootToTransfer);\r\n        members[recipient].loot = members[recipient].loot.add(lootToTransfer);\r\n        balanceOf[sender] = balanceOf[sender].sub(lootToTransfer);\r\n        balanceOf[recipient] = balanceOf[recipient].add(lootToTransfer);\r\n        emit Transfer(sender, recipient, lootToTransfer);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"applicantAddress\",\"type\":\"address\"}],\"name\":\"CancelProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConvertSharesToLoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessActionProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessGuildKickProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessWhitelistProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"Ragequit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"SponsorProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeTokenForShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8[8]\",\"name\":\"flags\",\"type\":\"uint8[8]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"SubmitProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"SubmitVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToCollect\",\"type\":\"uint256\"}],\"name\":\"TokensCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"UpdateDelegateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ESCROW\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUILD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"actions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"}],\"name\":\"canRagequit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancelProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"collectTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesToLoot\",\"type\":\"uint256\"}],\"name\":\"convertSharesToLoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dilutionBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"getMemberProposalVote\",\"outputs\":[{\"internalType\":\"enum MYSTIC.Vote\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalFlags\",\"outputs\":[{\"internalType\":\"uint8[8]\",\"name\":\"\",\"type\":\"uint8[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposalQueueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gracePeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"hasVotingPeriodExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_summoner\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_summonerShares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_summonerDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_guildName\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberAddressByDelegateKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"exists\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jailed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processActionProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processGuildKickProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processWhitelistProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalSharesAndLootAtYesVote\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToKick\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"}],\"name\":\"ragekick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"ragequit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"sponsorProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeTokenForShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actionTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actionTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actionValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitActionProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitGuildKickProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"submitVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToWhitelist\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"details\",\"type\":\"bytes32\"}],\"name\":\"submitWhitelistProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"summoningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGuildBankTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lootToTransfer\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lootToTransfer\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"updateDelegateKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"max\",\"type\":\"bool\"}],\"name\":\"withdrawBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MYSTIC","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b14b1d4cca6b0621f70db6cfef7d4a327f8c525cf12a7d41ad8ce20b063cf007"}]}