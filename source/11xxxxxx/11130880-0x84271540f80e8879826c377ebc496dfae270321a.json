{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath div 0\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath sub b > a\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath mod 0\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/schnorr/Bn128.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Bn128 {\r\n    using SafeMath for uint;\r\n    \r\n    uint256 constant gx = 0x1;\r\n    uint256 constant gy = 0x2;\r\n\r\n    /// @dev Order is the number of elements in both G₁ and G₂: 36u⁴+36u³+18u²+6u+1.\r\n    uint256 constant order = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n\r\n    function getGx() public pure returns (uint256) {\r\n        return gx;\r\n    }\r\n\r\n    function getGy() public pure returns (uint256) {\r\n        return gy;\r\n    }\r\n\r\n    function getOrder() public pure returns (uint256) {\r\n        return order;\r\n    }\r\n\r\n    function ecadd(\r\n        uint256 x1,\r\n        uint256 y1,\r\n        uint256 x2,\r\n        uint256 y2\r\n    ) public view returns (uint256 x3, uint256 y3) {\r\n        uint256[2] memory outValue;\r\n        uint256[4] memory input;\r\n        input[0] = x1;\r\n        input[1] = y1;\r\n        input[2] = x2;\r\n        input[3] = y2;\r\n\r\n        assembly {\r\n            if iszero(staticcall(gas, 0x06, input, 0x80, outValue, 0x40)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        x3 = outValue[0];\r\n        y3 = outValue[1];\r\n    }\r\n\r\n    function ecmul(\r\n        uint256 x1,\r\n        uint256 y1,\r\n        uint256 scalar\r\n    ) public view returns (uint256 x2, uint256 y2) {\r\n        uint256[2] memory outValue;\r\n        uint256[3] memory input;\r\n        input[0] = x1;\r\n        input[1] = y1;\r\n        input[2] = scalar;\r\n\r\n        assembly {\r\n            if iszero(staticcall(gas, 0x07, input, 0x60, outValue, 0x40)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        x2 = outValue[0];\r\n        y2 = outValue[1];\r\n    }\r\n}\r\n\r\n// File: contracts/schnorr/Bn128SchnorrVerifier.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Bn128SchnorrVerifier is Bn128 {\r\n    struct Point {\r\n        uint256 x; uint256 y;\r\n    }\r\n\r\n    struct Verification {\r\n        Point groupKey;\r\n        Point randomPoint;\r\n        uint256 signature;\r\n        bytes32 message;\r\n\r\n        uint256 _hash;\r\n        Point _left;\r\n        Point _right;\r\n    }\r\n\r\n    function h(bytes32 m, uint256 a, uint256 b) public pure returns (uint256) {\r\n        return uint256(sha256(abi.encodePacked(m, a, b)));\r\n    }\r\n\r\n    // function cmul(Point p, uint256 scalar) public pure returns (uint256, uint256) {\r\n    function cmul(uint256 x, uint256 y, uint256 scalar) public view returns (uint256, uint256) {\r\n        return ecmul(x, y, scalar);\r\n    }\r\n\r\n    function sg(uint256 sig_s) public view returns (uint256, uint256) {\r\n        return ecmul(getGx(), getGy(), sig_s);\r\n    }\r\n\r\n    // function cadd(Point a, Point b) public pure returns (uint256, uint256) {\r\n    function cadd(uint256 ax, uint256 ay, uint256 bx, uint256 by) public view returns (uint256, uint256) {\r\n        return ecadd(ax, ay, bx, by);\r\n    }\r\n\r\n    function verify(bytes32 signature, bytes32 groupKeyX, bytes32 groupKeyY, bytes32 randomPointX, bytes32 randomPointY, bytes32 message)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        bool flag = false;\r\n        Verification memory state;\r\n\r\n        state.signature = uint256(signature);\r\n        state.groupKey.x = uint256(groupKeyX);\r\n        state.groupKey.y = uint256(groupKeyY);\r\n        state.randomPoint.x = uint256(randomPointX);\r\n        state.randomPoint.y = uint256(randomPointY);\r\n        state.message = message;\r\n\r\n        state._hash = h(state.message, state.randomPoint.x, state.randomPoint.y);\r\n\r\n        /// change to bn256 range.\r\n        state._hash = uint256(state._hash).mod(getOrder());\r\n\r\n        (state._left.x, state._left.y) = sg(state.signature);\r\n        Point memory rightPart;\r\n        (rightPart.x, rightPart.y) = cmul(state.groupKey.x, state.groupKey.y, state._hash);\r\n        (state._right.x, state._right.y) = cadd(state.randomPoint.x, state.randomPoint.y, rightPart.x, rightPart.y);\r\n\r\n        flag = state._left.x == state._right.x && state._left.y == state._right.y;\r\n\r\n        return flag;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"signature\",\"type\":\"bytes32\"},{\"name\":\"groupKeyX\",\"type\":\"bytes32\"},{\"name\":\"groupKeyY\",\"type\":\"bytes32\"},{\"name\":\"randomPointX\",\"type\":\"bytes32\"},{\"name\":\"randomPointY\",\"type\":\"bytes32\"},{\"name\":\"message\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"cmul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ax\",\"type\":\"uint256\"},{\"name\":\"ay\",\"type\":\"uint256\"},{\"name\":\"bx\",\"type\":\"uint256\"},{\"name\":\"by\",\"type\":\"uint256\"}],\"name\":\"cadd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"ecmul\",\"outputs\":[{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"name\":\"ecadd\",\"outputs\":[{\"name\":\"x3\",\"type\":\"uint256\"},{\"name\":\"y3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sig_s\",\"type\":\"uint256\"}],\"name\":\"sg\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"m\",\"type\":\"bytes32\"},{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"h\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Bn128SchnorrVerifier","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://86040178da7cb4988207393a96c425631f05a566b0b5996c382681121394ecb0"}]}