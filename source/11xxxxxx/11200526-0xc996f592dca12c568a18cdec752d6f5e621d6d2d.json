{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/EIP20Interface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2018 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n// Common: Standard EIP20 Interface\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n// ----------------------------------------------------------------------------\r\n// Based on the 'final' EIP20 token standard as specified at:\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n * @title EIP20Interface.\r\n *\r\n * @notice Provides EIP20 token interface.\r\n */\r\ncontract EIP20Interface {\r\n\r\n    /* Events */\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n\r\n\r\n    /* Public functions */\r\n\r\n    /**\r\n     * @notice Public function to get the name of the token.\r\n     *\r\n     * @return tokenName_ Name of the token.\r\n     */\r\n    function name() public view returns (string memory tokenName_);\r\n\r\n    /**\r\n     * @notice Public function to get the symbol of the token.\r\n     *\r\n     * @return tokenSymbol_ Symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory tokenSymbol_);\r\n\r\n    /**\r\n     * @notice Public function to get the decimals of the token.\r\n     *\r\n     * @return tokenDecimals Decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8 tokenDecimals_);\r\n\r\n    /**\r\n     * @notice Public function to get the total supply of the tokens.\r\n     *\r\n     * @return totalTokenSupply_ Total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256 totalTokenSupply_);\r\n\r\n    /**\r\n     * @notice Get the balance of an account.\r\n     *\r\n     * @param _owner Address of the owner account.\r\n     *\r\n     * @return balance_ Account balance of the owner account.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance_);\r\n\r\n    /**\r\n     * @notice Public function to get the allowance.\r\n     *\r\n     * @param _owner Address of the owner account.\r\n     * @param _spender Address of the spender account.\r\n     *\r\n     * @return allowance_ Remaining allowance for the spender to spend from\r\n     *                    owner's account.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 allowance_);\r\n\r\n\r\n    /**\r\n     * @notice Public function to transfer the token.\r\n     *\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens to be transferred.\r\n     *\r\n     * @return success_ `true` for a successful transfer, `false` otherwise.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_);\r\n\r\n    /**\r\n     * @notice Public function transferFrom.\r\n     *\r\n     * @param _from Address from which tokens are transferred.\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens transferred.\r\n     *\r\n     * @return success_ `true` for a successful transfer, `false` otherwise.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_);\r\n\r\n    /**\r\n     * @notice Public function to approve an account for transfer.\r\n     *\r\n     * @param _spender Address authorized to spend from the function caller's\r\n     *                 address.\r\n     * @param _value Amount up to which spender is authorized to spend.\r\n     *\r\n     * @return bool `true` for a successful approval, `false` otherwise.\r\n     */\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_);\r\n\r\n}\r\n\r\n// File: contracts/GatewayInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2018 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n/**\r\n * @title GatewayInterface Contract\r\n *\r\n * @notice Provides interface for gateway contract.\r\n */\r\ninterface GatewayInterface {\r\n\r\n    /* External functions */\r\n\r\n    /**\r\n     * @notice Returns bounty amount.\r\n     *\r\n     * @return Amount of ERC20 which needs to be staked by facilitator.\r\n     */\r\n    function bounty()\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Initiates the stake process.  In order to stake the staker\r\n     *         needs to approve Gateway contract for stake amount.\r\n     *         Staked amount is transferred from staker address to\r\n     *         Gateway contract. Bounty amount is also transferred from staker.\r\n     *\r\n     * @param _amount Stake amount that will be transferred from the staker\r\n     *                account.\r\n     * @param _beneficiary The address in the auxiliary chain where the utility\r\n     *                     tokens will be minted.\r\n     * @param _gasPrice Gas price that staker is ready to pay to get the stake\r\n     *                  and mint process done.\r\n     * @param _gasLimit Gas limit that staker is ready to pay.\r\n     * @param _nonce Nonce of the staker address.\r\n     * @param _hashLock Hash Lock provided by the facilitator.\r\n     *\r\n     * @return messageHash_ Message hash is unique for each request.\r\n     */\r\n    function stake(\r\n        uint256 _amount,\r\n        address _beneficiary,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        uint256 _nonce,\r\n        bytes32 _hashLock\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_);\r\n\r\n    /**\r\n     * @notice Revert stake process and get the stake\r\n     *         amount back. Only staker can revert stake by providing\r\n     *         penalty i.e. 1.5 times of bounty amount. On progress revert stake\r\n     *         penalty and facilitator bounty will be burned.\r\n     *\r\n     * @dev To revert the the sender must sign the sha3(messageHash, nonce+1)\r\n     *\r\n     * @param _messageHash Message hash.\r\n     *\r\n     * @return staker_ Staker address\r\n     * @return stakerNonce_ Staker nonce\r\n     * @return amount_ Stake amount\r\n     */\r\n    function revertStake(\r\n        bytes32 _messageHash\r\n    )\r\n        external\r\n        returns\r\n    (\r\n        address staker_,\r\n        uint256 stakerNonce_,\r\n        uint256 amount_\r\n    );\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n// Common: SafeMath Library Implementation\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// Based on the SafeMath library by the OpenZeppelin team.\r\n// Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n// https://github.com/OpenZeppelin/zeppelin-solidity\r\n// The MIT License.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero,\r\n        // but the benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts\r\n     *      on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0.\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        // There is no case in which this doesn't hold\r\n        // assert(a == b * c + a % b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is\r\n     *      greater than minuend).\r\n     *\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder,\r\n     *      (unsigned integer modulo) reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/EIP20Token.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2018 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n\r\n\r\n/**\r\n *  @title EIP20Token contract which implements EIP20Interface.\r\n *\r\n *  @notice Implements EIP20 token.\r\n */\r\ncontract EIP20Token is EIP20Interface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* Storage */\r\n\r\n    string internal tokenName;\r\n    string internal tokenSymbol;\r\n    uint8  private tokenDecimals;\r\n    uint256 internal totalTokenSupply;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n\r\n    /* Special functions */\r\n\r\n    /**\r\n     *  @notice Contract constructor.\r\n     *\r\n     *  @param _symbol Symbol of the token.\r\n     *  @param _name Name of the token.\r\n     *  @param _decimals Decimal places of the token.\r\n     */\r\n    constructor(\r\n        string memory _symbol,\r\n        string memory _name,\r\n        uint8 _decimals\r\n    )\r\n        public\r\n    {\r\n        tokenSymbol = _symbol;\r\n        tokenName = _name;\r\n        tokenDecimals = _decimals;\r\n        totalTokenSupply = 0;\r\n    }\r\n\r\n\r\n    /* Public functions */\r\n\r\n    /**\r\n     *  @notice Public view function name.\r\n     *\r\n     *  @return Name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return tokenName;\r\n    }\r\n\r\n    /**\r\n     *  @notice Public view function symbol.\r\n     *\r\n     *  @return Symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    /**\r\n     *  @notice Public view function decimals.\r\n     *\r\n     *  @return Decimal places of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return tokenDecimals;\r\n    }\r\n\r\n    /**\r\n     *  @notice Public view function balanceOf.\r\n     *\r\n     *  @param _owner Address of the owner account.\r\n     *\r\n     *  @return Account balance of the owner account.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     *  @notice Public view function totalSupply.\r\n     *\r\n     *  @dev Get totalTokenSupply as view so that child cannot edit.\r\n     *\r\n     *  @return Total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalTokenSupply;\r\n    }\r\n\r\n    /**\r\n     *  @notice Public view function allowance.\r\n     *\r\n     *  @param _owner Address of the owner account.\r\n     *  @param _spender Address of the spender account.\r\n     *\r\n     *  @return Remaining allowance for the spender to spend from\r\n     *          owner's account.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     *  @notice Public function transfer.\r\n     *\r\n     *  @dev Fires the transfer event, throws if, _from account does not have\r\n     *       enough tokens to spend.\r\n     *\r\n     *  @param _to Address to which tokens are transferred.\r\n     *  @param _value Amount of tokens to be transferred.\r\n     *\r\n     *  @return success_ True for a successful transfer, false otherwise.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_)\r\n    {\r\n\r\n        // According to the EIP20 spec, \"transfers of 0 values MUST be treated\r\n        // as normal transfers and fire the Transfer event\".\r\n        // Also, should throw if not enough balance. This is taken care of by\r\n        // SafeMath.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @notice Public function transferFrom.\r\n     *\r\n     *  @dev Allows a contract to transfer tokens on behalf of _from address\r\n     *       to _to address, the function caller has to be pre-authorized\r\n     *       for multiple transfers up to the total of _value amount by\r\n     *       the _from address.\r\n     *\r\n     *  @param _from Address from which tokens are transferred.\r\n     *  @param _to Address to which tokens are transferred.\r\n     *  @param _value Amount of tokens transferred.\r\n     *\r\n     *  @return success_ True for a successful transfer, false otherwise.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_)\r\n    {\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @notice Public function approve.\r\n     *\r\n     *  @dev Allows _spender address to withdraw from function caller's\r\n     *       account, multiple times up to the _value amount, if this\r\n     *       function is called again it overwrites the current allowance\r\n     *       with _value.\r\n     *\r\n     *  @param _spender Address authorized to spend from the function caller's\r\n     *                  address.\r\n     *  @param _value Amount up to which spender is authorized to spend.\r\n     *\r\n     *  @return success_ True for a successful approval, false otherwise.\r\n     */\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool success_)\r\n    {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/OrganizationInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2018 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n *  @title OrganizationInterface provides methods to check if an address is\r\n *         currently registered as an active participant in the organization.\r\n */\r\ninterface OrganizationInterface {\r\n\r\n    /**\r\n     * @notice Checks if an address is currently registered as the organization.\r\n     *\r\n     * @param _organization Address to check.\r\n     *\r\n     * @return isOrganization_ True if the given address represents the\r\n     *                         organization. Returns false otherwise.\r\n     */\r\n    function isOrganization(\r\n        address _organization\r\n    )\r\n        external\r\n        view\r\n        returns (bool isOrganization_);\r\n\r\n    /**\r\n     * @notice Checks if an address is currently registered as an active worker.\r\n     *\r\n     * @param _worker Address to check.\r\n     *\r\n     * @return isWorker_ True if the given address is a registered, active\r\n     *                   worker. Returns false otherwise.\r\n     */\r\n    function isWorker(address _worker) external view returns (bool isWorker_);\r\n\r\n}\r\n\r\n// File: contracts/Organized.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2018 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * @title Organized contract.\r\n *\r\n * @notice The Organized contract facilitates integration of\r\n *         organization administration keys with different contracts.\r\n */\r\ncontract Organized {\r\n\r\n    /* Storage */\r\n\r\n    /** Organization which holds all the keys needed to administer the economy. */\r\n    OrganizationInterface public organization;\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyOrganization()\r\n    {\r\n        require(\r\n            organization.isOrganization(msg.sender),\r\n            \"Only the organization is allowed to call this method.\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyWorker()\r\n    {\r\n        require(\r\n            organization.isWorker(msg.sender),\r\n            \"Only whitelisted workers are allowed to call this method.\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n\r\n    /* Constructor */\r\n\r\n    /**\r\n     * @notice Sets the address of the organization contract.\r\n     *\r\n     * @param _organization A contract that manages worker keys.\r\n     */\r\n    constructor(OrganizationInterface _organization) public {\r\n        require(\r\n            address(_organization) != address(0),\r\n            \"Organization contract address must not be zero.\"\r\n        );\r\n\r\n        organization = _organization;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/BrandedToken.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Branded Token.\r\n *\r\n * @notice Branded tokens are minted by staking specified value tokens.\r\n */\r\ncontract BrandedToken is Organized, EIP20Token {\r\n\r\n    /* Usings */\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* Events */\r\n\r\n    event StakeRequested(\r\n        bytes32 indexed _stakeRequestHash,\r\n        address _staker,\r\n        uint256 _stake,\r\n        uint256 _nonce\r\n    );\r\n\r\n    event StakeRequestAccepted(\r\n        bytes32 indexed _stakeRequestHash,\r\n        address _staker,\r\n        uint256 _stake\r\n    );\r\n\r\n    event StakeRequestRevoked(\r\n        bytes32 indexed _stakeRequestHash,\r\n        address _staker,\r\n        uint256 _stake\r\n    );\r\n\r\n    event Redeemed(\r\n        address _redeemer,\r\n        uint256 _valueTokens\r\n    );\r\n\r\n    event StakeRequestRejected(\r\n        bytes32 indexed _stakeRequestHash,\r\n        address _staker,\r\n        uint256 _stake\r\n    );\r\n\r\n    event SymbolSet(string _symbol);\r\n\r\n    event NameSet(string _name);\r\n\r\n\r\n    /* Structs */\r\n\r\n    struct StakeRequest {\r\n        address staker;\r\n        uint256 stake;\r\n        uint256 nonce;\r\n    }\r\n\r\n\r\n    /* Storage */\r\n\r\n    /** Address for value tokens staked to mint branded tokens. */\r\n    EIP20Interface public valueToken;\r\n\r\n    /** Conversion rate from value tokens to branded tokens. */\r\n    uint256 public conversionRate;\r\n\r\n    /** Number of digits to the right of the decimal point in conversionRate. */\r\n    uint8 public conversionRateDecimals;\r\n\r\n    /** Global nonce for stake requests. */\r\n    uint256 public nonce;\r\n\r\n    /** Flag indicating whether restrictions have been lifted for all actors. */\r\n    bool public allRestrictionsLifted;\r\n\r\n    /** Domain separator encoding per EIP 712. */\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(address verifyingContract)\"\r\n    );\r\n\r\n    /** StakeRequest struct type encoding per EIP 712. */\r\n    bytes32 private constant BT_STAKE_REQUEST_TYPEHASH = keccak256(\r\n        \"StakeRequest(address staker,uint256 stake,uint256 nonce)\"\r\n    );\r\n\r\n    /** Domain separator per EIP 712. */\r\n    bytes32 private DOMAIN_SEPARATOR = keccak256(\r\n        abi.encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            address(this)\r\n        )\r\n    );\r\n\r\n    /** Maps staker to stakeRequestHashes. */\r\n    mapping(address => bytes32) public stakeRequestHashes;\r\n\r\n    /** Maps stakeRequestHash to StakeRequests. */\r\n    mapping(bytes32 => StakeRequest) public stakeRequests;\r\n\r\n    /** Maps actor to restriction status. */\r\n    mapping(address => bool) private unrestricted;\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyUnrestricted {\r\n        require(\r\n            allRestrictionsLifted || unrestricted[msg.sender],\r\n            \"Msg.sender is restricted.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    /* Constructor */\r\n\r\n    /**\r\n     * @dev Conversion parameters provide the conversion rate and its scale.\r\n     *      For example, if 1 value token is equivalent to 3.5 branded\r\n     *      tokens (1:3.5), _conversionRate == 35 and\r\n     *      _conversionRateDecimals == 1.\r\n     *\r\n     *      Constructor requires:\r\n     *          - valueToken address is not zero\r\n     *          - conversionRate is not zero\r\n     *          - conversionRateDecimals is not greater than 5\r\n     *\r\n     * @param _valueToken The value to which valueToken is set.\r\n     * @param _symbol The value to which tokenSymbol, defined in EIP20Token,\r\n     *                is set.\r\n     * @param _name The value to which tokenName, defined in EIP20Token,\r\n     *              is set.\r\n     * @param _decimals The value to which tokenDecimals, defined in EIP20Token,\r\n     *                  is set.\r\n     * @param _conversionRate The value to which conversionRate is set.\r\n     * @param _conversionRateDecimals The value to which\r\n     *                                conversionRateDecimals is set.\r\n     * @param _organization The value to which organization, defined in Organized,\r\n     *                      is set.\r\n     */\r\n    constructor(\r\n        EIP20Interface _valueToken,\r\n        string memory _symbol,\r\n        string memory _name,\r\n        uint8 _decimals,\r\n        uint256 _conversionRate,\r\n        uint8 _conversionRateDecimals,\r\n        OrganizationInterface _organization\r\n    )\r\n        EIP20Token(_symbol, _name, _decimals)\r\n        Organized(_organization)\r\n        public\r\n    {\r\n        require(\r\n            address(_valueToken) != address(0),\r\n            \"ValueToken is zero.\"\r\n        );\r\n        require(\r\n            _conversionRate != 0,\r\n            \"ConversionRate is zero.\"\r\n        );\r\n        require(\r\n            _conversionRateDecimals <= 5,\r\n            \"ConversionRateDecimals is greater than 5.\"\r\n        );\r\n\r\n        valueToken = _valueToken;\r\n        conversionRate = _conversionRate;\r\n        conversionRateDecimals = _conversionRateDecimals;\r\n    }\r\n\r\n\r\n    /* External Functions */\r\n\r\n    /**\r\n     * @notice Transfers value tokens from msg.sender to itself,\r\n     *         stores the amount of branded tokens to mint if request\r\n     *         is accepted, and emits stake request information.\r\n     *\r\n     * @dev It is expected that this contract will have a sufficientallowance\r\n     *      to transfer value tokens from the staker at the time this function\r\n     *      is executed.\r\n     *\r\n     *      Function requires:\r\n     *          - _mint is equivalent to _stake\r\n     *          - msg.sender does not have a stake request hash\r\n     *          - valueToken.transferFrom returns true\r\n     *\r\n     * @param _stake Amount of value tokens to stake.\r\n     * @param _mint Amount of branded tokens to mint.\r\n     *\r\n     * @return stakeRequestHash_ Hash of stake request information calculated per\r\n     *                           EIP 712.\r\n     */\r\n    function requestStake(\r\n        uint256 _stake,\r\n        uint256 _mint\r\n    )\r\n        external\r\n        returns (bytes32 stakeRequestHash_)\r\n    {\r\n        require(\r\n            _mint == convertToBrandedTokens(_stake),\r\n            \"Mint is not equivalent to stake.\"\r\n        );\r\n        require(\r\n            stakeRequestHashes[msg.sender] == bytes32(0),\r\n            \"Staker has a stake request hash.\"\r\n        );\r\n\r\n        StakeRequest memory stakeRequest = StakeRequest({\r\n            staker: msg.sender,\r\n            stake: _stake,\r\n            nonce: nonce\r\n        });\r\n        // Calculates hash per EIP 712\r\n        stakeRequestHash_ = hash(stakeRequest);\r\n        stakeRequestHashes[msg.sender] = stakeRequestHash_;\r\n        stakeRequests[stakeRequestHash_] = stakeRequest;\r\n\r\n        nonce += 1;\r\n\r\n        emit StakeRequested(\r\n            stakeRequestHash_,\r\n            stakeRequest.staker,\r\n            stakeRequest.stake,\r\n            stakeRequest.nonce\r\n        );\r\n\r\n        require(\r\n            valueToken.transferFrom(msg.sender, address(this), _stake),\r\n            \"ValueToken.transferFrom returned false.\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Mints and transfers branded tokens to a staker,\r\n     *         increases the total token supply, and\r\n     *         emits stake request acceptance and transfer information.\r\n     *\r\n     * @dev The function has no access controls, but will only accept\r\n     *      the signature of a worker, as defined in Organization.\r\n     *\r\n     *      Function requires:\r\n     *          - stake request exists\r\n     *          - signature is from a worker\r\n     *\r\n     * @param _stakeRequestHash Stake request hash.\r\n     * @param _r R of the signature.\r\n     * @param _s S of the signature.\r\n     * @param _v V of the signature.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function acceptStakeRequest(\r\n        bytes32 _stakeRequestHash,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _v\r\n    )\r\n        external\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            stakeRequests[_stakeRequestHash].staker != address(0),\r\n            \"Stake request not found.\"\r\n        );\r\n\r\n        // To prevent a reentrancy the stake request is copied into the memory\r\n        // and deleted from the storage.\r\n        StakeRequest memory stakeRequest = stakeRequests[_stakeRequestHash];\r\n        delete stakeRequestHashes[stakeRequest.staker];\r\n        delete stakeRequests[_stakeRequestHash];\r\n\r\n        require(\r\n            verifySigner(stakeRequest, _r, _s, _v),\r\n            \"Signer is not a worker.\"\r\n        );\r\n\r\n        emit StakeRequestAccepted(\r\n            _stakeRequestHash,\r\n            stakeRequest.staker,\r\n            stakeRequest.stake\r\n        );\r\n\r\n        uint256 mint = convertToBrandedTokens(stakeRequest.stake);\r\n        balances[stakeRequest.staker] = balances[stakeRequest.staker]\r\n            .add(mint);\r\n        totalTokenSupply = totalTokenSupply.add(mint);\r\n\r\n        // Mint branded tokens\r\n        emit Transfer(address(0), stakeRequest.staker, mint);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Maps addresses in _restrictionLifted to true in unrestricted.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is a worker\r\n     *\r\n     * @param _restrictionLifted Addresses for which to lift restrictions.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function liftRestriction(\r\n        address[] calldata _restrictionLifted\r\n    )\r\n        external\r\n        onlyWorker\r\n        returns (bool success_)\r\n    {\r\n        for (uint256 i = 0; i < _restrictionLifted.length; i++) {\r\n            unrestricted[_restrictionLifted[i]] = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates whether an actor is unrestricted.\r\n     *\r\n     * @param _actor Actor.\r\n     *\r\n     * @return isUnrestricted_ Whether unrestricted.\r\n     */\r\n    function isUnrestricted(address _actor)\r\n        external\r\n        view\r\n        returns (bool isUnrestricted_)\r\n    {\r\n        return unrestricted[_actor];\r\n    }\r\n\r\n    /**\r\n     * @notice Lifts restrictions from all actors.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is organization\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function liftAllRestrictions()\r\n        external\r\n        onlyOrganization\r\n        returns (bool success_)\r\n    {\r\n        allRestrictionsLifted = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes stake request by deleting its information and\r\n     *         transferring staked value tokens back to staker.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is staker\r\n     *          - valueToken.transfer returns true\r\n     *\r\n     * @param _stakeRequestHash Stake request hash.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function revokeStakeRequest(\r\n        bytes32 _stakeRequestHash\r\n    )\r\n        external\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            stakeRequests[_stakeRequestHash].staker == msg.sender,\r\n            \"Msg.sender is not staker.\"\r\n        );\r\n\r\n        uint256 stake = stakeRequests[_stakeRequestHash].stake;\r\n\r\n        delete stakeRequestHashes[msg.sender];\r\n        delete stakeRequests[_stakeRequestHash];\r\n\r\n        emit StakeRequestRevoked(\r\n            _stakeRequestHash,\r\n            msg.sender,\r\n            stake\r\n        );\r\n\r\n        require(\r\n            valueToken.transfer(msg.sender, stake),\r\n            \"ValueToken.transfer returned false.\"\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Reduces msg.sender's balance and the total supply by\r\n     *         _brandedTokens and transfers an equivalent amount of\r\n     *         value tokens to msg.sender.\r\n     *\r\n     * @dev Redemption may risk loss of branded tokens.\r\n     *      It is possible to redeem branded tokens for 0 value tokens.\r\n     *\r\n     *      Function requires:\r\n     *          - valueToken.transfer returns true\r\n     *\r\n     * @param _brandedTokens Amount of branded tokens to redeem.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function redeem(\r\n        uint256 _brandedTokens\r\n    )\r\n        external\r\n        returns (bool success_)\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].sub(_brandedTokens);\r\n        totalTokenSupply = totalTokenSupply.sub(_brandedTokens);\r\n        uint256 valueTokens = convertToValueTokens(_brandedTokens);\r\n\r\n        emit Redeemed(msg.sender, valueTokens);\r\n\r\n        // Burn redeemed branded tokens\r\n        emit Transfer(msg.sender, address(0), _brandedTokens);\r\n\r\n        require(\r\n            valueToken.transfer(msg.sender, valueTokens),\r\n            \"ValueToken.transfer returned false.\"\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Rejects stake request by deleting its information and\r\n     *         transferring staked value tokens back to staker.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is a worker\r\n     *          - stake request exists\r\n     *          - valueToken.transfer returns true\r\n     *\r\n     * @param _stakeRequestHash Stake request hash.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function rejectStakeRequest(\r\n        bytes32 _stakeRequestHash\r\n    )\r\n        external\r\n        onlyWorker\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            stakeRequests[_stakeRequestHash].staker != address(0),\r\n            \"Stake request not found.\"\r\n        );\r\n\r\n        StakeRequest memory stakeRequest = stakeRequests[_stakeRequestHash];\r\n\r\n        delete stakeRequestHashes[stakeRequest.staker];\r\n        delete stakeRequests[_stakeRequestHash];\r\n\r\n        emit StakeRequestRejected(\r\n            _stakeRequestHash,\r\n            stakeRequest.staker,\r\n            stakeRequest.stake\r\n        );\r\n\r\n        require(\r\n            valueToken.transfer(stakeRequest.staker, stakeRequest.stake),\r\n            \"ValueToken.transfer returned false.\"\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets symbol.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is a worker\r\n     *\r\n     * @param _symbol The value to which symbol is set.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function setSymbol(\r\n        string calldata _symbol\r\n    )\r\n        external\r\n        onlyWorker\r\n        returns (bool success_)\r\n    {\r\n        tokenSymbol = _symbol;\r\n\r\n        emit SymbolSet(tokenSymbol);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets name.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is a worker\r\n     *\r\n     * @param _name The value to which name is set.\r\n     *\r\n     * @return success_ True.\r\n     */\r\n    function setName(\r\n        string calldata _name\r\n    )\r\n        external\r\n        onlyWorker\r\n        returns (bool success_)\r\n    {\r\n        tokenName = _name;\r\n\r\n        emit NameSet(tokenName);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /* Public Functions */\r\n\r\n    /**\r\n     * @notice Overrides EIP20Token.transfer by additionally\r\n     *         requiring msg.sender to be unrestricted.\r\n     *\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens to be transferred.\r\n     *\r\n     * @return success_ Result from EIP20Token transfer.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        onlyUnrestricted\r\n        returns (bool success_)\r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Overrides EIP20Token.transferFrom by additionally\r\n     *         requiring msg.sender to be unrestricted.\r\n     *\r\n     * @param _from Address from which tokens are transferred.\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens transferred.\r\n     *\r\n     * @return success_ Result from EIP20Token transferFrom.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        onlyUnrestricted\r\n        returns (bool success_)\r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of branded tokens equivalent to a\r\n     *         given amount of value tokens.\r\n     *\r\n     * @dev Please note there may be a loss of up to 1 indivisible unit of\r\n     *      this token (i.e., assuming 1 value token is equivalent\r\n     *      to 3.5 branded tokens, convert(1) --> 3, not 3.5).\r\n     *\r\n     * @param _valueTokens Amount to convert.\r\n     *\r\n     * @return uint256 Converted amount.\r\n     */\r\n    function convertToBrandedTokens(\r\n        uint256 _valueTokens\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (\r\n            _valueTokens\r\n            .mul(conversionRate)\r\n            .div(10 ** uint256(conversionRateDecimals))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of value tokens equivalent to a\r\n     *         given amount of branded tokens.\r\n     *\r\n     * @dev Please note there may be a loss of up to 1 indivisible unit of\r\n     *      this token.\r\n     *\r\n     * @param _brandedTokens Amount to convert.\r\n     *\r\n     * @return uint256 Converted amount.\r\n     */\r\n    function convertToValueTokens(\r\n        uint256 _brandedTokens\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (\r\n            _brandedTokens\r\n            .mul(10 ** uint256(conversionRateDecimals))\r\n            .div(conversionRate)\r\n        );\r\n    }\r\n\r\n\r\n    /* Private Functions */\r\n\r\n    /**\r\n     * @notice Calculates stakeRequestHash according to EIP 712.\r\n     *\r\n     * @param _stakeRequest StakeRequest instance to hash.\r\n     *\r\n     * @return bytes32 EIP 712 hash of _stakeRequest.\r\n     */\r\n    function hash(\r\n        StakeRequest memory _stakeRequest\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encode(\r\n                BT_STAKE_REQUEST_TYPEHASH,\r\n                _stakeRequest.staker,\r\n                _stakeRequest.stake,\r\n                _stakeRequest.nonce\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Verifies whether signer of stakeRequestHash is a worker.\r\n     *\r\n     * @dev Signing the stakeRequestHash consistent with eth_signTypedData,\r\n     *      as specified by EIP 712, requires signing a hash of encoded data\r\n     *      comprising:\r\n     *          - an initial byte\r\n     *          - the version byte for structured data\r\n     *          - the domain separator\r\n     *          - the stakeRequestHash\r\n     *\r\n     *      See: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\r\n     *\r\n     * @param _stakeRequest Stake request.\r\n     * @param _r R of the signature.\r\n     * @param _s S of the signature.\r\n     * @param _v V of the signature.\r\n     *\r\n     * @return bool True if signer is a worker, false if not.\r\n     */\r\n    function verifySigner(\r\n        StakeRequest memory _stakeRequest,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _v\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        // See: https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.sol\r\n        bytes32 typedData = keccak256(\r\n            abi.encodePacked(\r\n                byte(0x19), // the initial 0x19 byte\r\n                byte(0x01), // the version byte for structured data\r\n                DOMAIN_SEPARATOR,\r\n                hash(_stakeRequest)\r\n            )\r\n        );\r\n\r\n        return organization.isWorker(ecrecover(typedData, _v, _r, _s));\r\n    }\r\n}\r\n\r\n// File: contracts/GatewayComposer.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title GatewayComposer contract.\r\n *\r\n * @notice GatewayComposer is a composition contract which can be used to\r\n *         optimise the UX flow of the user where the user intends to perform\r\n *         a single combined action.\r\n */\r\ncontract GatewayComposer {\r\n\r\n    /* Struct */\r\n\r\n    struct StakeRequest {\r\n        uint256 stakeVT;\r\n        address gateway;\r\n        address beneficiary;\r\n        uint256 gasPrice;\r\n        uint256 gasLimit;\r\n        uint256 nonce;\r\n    }\r\n\r\n\r\n    /* Storage */\r\n\r\n    address public owner;\r\n\r\n    /** EIP20Token value token which is staked on the value chain. */\r\n    EIP20Interface public valueToken;\r\n\r\n    /**\r\n     * A BrandedToken is an EIP20Token which allows a mainstream application\r\n     * to create a value-backed token designed specifically for its\r\n     * application's context.\r\n     */\r\n    BrandedToken public brandedToken;\r\n\r\n    mapping (bytes32 => StakeRequest) public stakeRequests;\r\n\r\n    /** Mutex lock status. */\r\n    bool private mutexAcquired;\r\n\r\n\r\n    /* Modifiers */\r\n\r\n    /** Checks that msg.sender is owner address. */\r\n    modifier onlyOwner() {\r\n        require(\r\n            owner == msg.sender,\r\n            \"Only owner can call the function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  Checks that mutex is acquired or not. If mutex is not acquired,\r\n     *  mutexAcquired is set to true. At the end of function execution,\r\n     *  mutexAcquired is set to false.\r\n     */\r\n    modifier mutex() {\r\n        require(\r\n            !mutexAcquired,\r\n            \"Mutex is already acquired.\"\r\n        );\r\n        mutexAcquired = true;\r\n        _;\r\n        mutexAcquired = false;\r\n    }\r\n\r\n\r\n    /* Special Functions */\r\n\r\n    /**\r\n     * @notice Contract constructor.\r\n     *\r\n     * @dev Function requires:\r\n     *          - owner address should not be zero\r\n     *          - ValueToken address should not be zero\r\n     *          - BrandedToken address should not be zero\r\n     *          - ValueToken address should not be equal to owner address\r\n     *          - BrandedToken address should not be equal to owner address\r\n     *          - ValueToken address should be equal to BrandedToken.valueToken()\r\n     *\r\n     * @param _owner Address of the staker on the value chain.\r\n     * @param _valueToken EIP20Token which is staked.\r\n     * @param _brandedToken It's a value backed minted EIP20Token.\r\n     */\r\n    constructor(\r\n        address _owner,\r\n        EIP20Interface _valueToken,\r\n        BrandedToken _brandedToken\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            _owner != address(0),\r\n            \"Owner address is zero.\"\r\n        );\r\n        require(\r\n            address(_valueToken) != address(0),\r\n            \"ValueToken address is zero.\"\r\n        );\r\n        require(\r\n            address(_brandedToken) != address(0),\r\n            \"BrandedToken address is zero.\"\r\n        );\r\n        require(\r\n            _owner != address(_valueToken),\r\n            \"ValueToken address is same as owner address.\"\r\n        );\r\n        require(\r\n            _owner != address(_brandedToken),\r\n            \"BrandedToken address is same as owner address.\"\r\n        );\r\n        require(\r\n            address(_valueToken) == address(_brandedToken.valueToken()),\r\n            \"ValueToken should match BrandedToken.valueToken.\"\r\n        );\r\n\r\n        owner = _owner;\r\n        valueToken = _valueToken;\r\n        brandedToken = _brandedToken;\r\n    }\r\n\r\n\r\n    /* External Functions */\r\n\r\n    /**\r\n     * @notice Transfers value tokens from msg.sender to itself after staker\r\n     *         approves GatewayComposer, approves BrandedToken for value tokens\r\n     *         and calls BrandedToken.requestStake function.\r\n     *\r\n     * @dev Function requires:\r\n     *          - stakeVT can't be 0\r\n     *          - mintBT amount and converted stakeVT amount should be equal\r\n     *          - gateway address can't be zero\r\n     *          - Gateway address should not be equal to owner address\r\n     *          - beneficiary address can't be zero\r\n     *          - successful execution of ValueToken transfer\r\n     *          - successful execution of ValueToken approve\r\n     *\r\n     *      stakeVT can't be 0 because gateway.stake also doesn't allow 0 stake\r\n     *      amount. This condition also helps in validation of in progress\r\n     *      stake requests. See acceptStakeRequest for details.\r\n     *\r\n     *      mintBT is not stored in StakeRequest struct as there was\r\n     *      significant gas cost difference between storage vs dynamic\r\n     *      evaluation from BrandedToken convert function.\r\n     *\r\n     * @param _stakeVT ValueToken amount which is staked.\r\n     * @param _mintBT Amount of BrandedToken amount which will be minted.\r\n     * @param _gateway Gateway contract address.\r\n     * @param _beneficiary The address in the auxiliary chain where the utility\r\n     *                     tokens will be minted.\r\n     * @param _gasPrice Gas price that staker is ready to pay to get the stake\r\n     *                  and mint process done.\r\n     * @param _gasLimit Gas limit that staker is ready to pay.\r\n     * @param _nonce Nonce of the staker address. It can be obtained from\r\n     *               Gateway.getNonce() method.\r\n     *\r\n     * @return stakeRequestHash_ Hash unique for each stake request.\r\n     */\r\n    function requestStake(\r\n        uint256 _stakeVT,\r\n        uint256 _mintBT,\r\n        address _gateway,\r\n        address _beneficiary,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        uint256 _nonce\r\n    )\r\n        external\r\n        onlyOwner\r\n        mutex\r\n        returns (bytes32 stakeRequestHash_)\r\n    {\r\n        require(\r\n            _stakeVT > uint256(0),\r\n            \"Stake amount is zero.\"\r\n        );\r\n        require(\r\n            _mintBT == brandedToken.convertToBrandedTokens(_stakeVT),\r\n            \"_mintBT should match converted _stakeVT.\"\r\n        );\r\n        require(\r\n            _gateway != address(0),\r\n            \"Gateway address is zero.\"\r\n        );\r\n        require(\r\n            owner != _gateway,\r\n            \"Gateway address is same as owner address.\"\r\n        );\r\n        require(\r\n            _beneficiary != address(0),\r\n            \"Beneficiary address is zero.\"\r\n        );\r\n        require(\r\n            valueToken.transferFrom(msg.sender, address(this), _stakeVT),\r\n            \"ValueToken transferFrom returned false.\"\r\n        );\r\n        require(\r\n            valueToken.approve(address(brandedToken), _stakeVT),\r\n            \"ValueToken approve returned false.\"\r\n        );\r\n\r\n        stakeRequestHash_ = brandedToken.requestStake(_stakeVT, _mintBT);\r\n\r\n        stakeRequests[stakeRequestHash_] = StakeRequest({\r\n            stakeVT: _stakeVT,\r\n            gateway: _gateway,\r\n            beneficiary: _beneficiary,\r\n            gasPrice: _gasPrice,\r\n            gasLimit: _gasLimit,\r\n            nonce: _nonce\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Approves Gateway for the minted BTs, calls Gateway.stake after\r\n     *         BrandedToken.acceptStakeRequest execution is successful.\r\n     *\r\n     * @dev Function requires:\r\n     *          - stake request hash is valid\r\n     *          - successful execution of ValueToken transferFrom\r\n     *          - successful execution of ValueToken approve\r\n     *          - BrandedToken.acceptStakeRequest execution is successful\r\n     *          - successful execution of BrandedToken approve\r\n     *\r\n     *      As per requirement bounty token currency is same as valueToken.\r\n     *      Bounty flow:\r\n     *          - facilitator approves GatewayComposer for base tokens as bounty\r\n     *          - GatewayComposer approves Gateway for the bounty\r\n     *\r\n     * @param _stakeRequestHash Unique hash for each stake request.\r\n     * @param _r R of the signature.\r\n     * @param _s S of the signature.\r\n     * @param _v V of the signature.\r\n     * @param _hashLock Hash lock provided by the facilitator.\r\n     *\r\n     * @return messageHash_ Message hash unique for each stake request.\r\n     */\r\n    function acceptStakeRequest(\r\n        bytes32 _stakeRequestHash,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _v,\r\n        bytes32 _hashLock\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        StakeRequest memory stakeRequest = stakeRequests[_stakeRequestHash];\r\n\r\n        delete stakeRequests[_stakeRequestHash];\r\n\r\n        require(\r\n            stakeRequest.stakeVT > uint256(0),\r\n            \"Stake request not found.\"\r\n        );\r\n\r\n        uint256 bounty = GatewayInterface(stakeRequest.gateway).bounty();\r\n        require(\r\n            valueToken.transferFrom(msg.sender, address(this), bounty),\r\n            \"ValueToken transferFrom returned false.\"\r\n        );\r\n        require(\r\n            valueToken.approve(stakeRequest.gateway, bounty),\r\n            \"ValueToken approve returned false.\"\r\n        );\r\n\r\n        require(\r\n            brandedToken.acceptStakeRequest(\r\n                _stakeRequestHash,\r\n                _r,\r\n                _s,\r\n                _v\r\n            ),\r\n            \"BrandedToken acceptStakeRequest returned false.\"\r\n        );\r\n\r\n        uint256 mintBT = brandedToken.convertToBrandedTokens(\r\n            stakeRequest.stakeVT\r\n        );\r\n\r\n        require(\r\n            brandedToken.approve(stakeRequest.gateway, mintBT),\r\n            \"BrandedToken approve returned false.\"\r\n        );\r\n\r\n        messageHash_ = GatewayInterface(stakeRequest.gateway).stake(\r\n            mintBT,\r\n            stakeRequest.beneficiary,\r\n            stakeRequest.gasPrice,\r\n            stakeRequest.gasLimit,\r\n            stakeRequest.nonce,\r\n            _hashLock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes stake request by calling BrandedToken.revokeStakeRequest()\r\n     *         and deleting information.\r\n     *\r\n     * @dev Function requires:\r\n     *          - stake request hash is valid\r\n     *          - BrandedToken.revokeStakeRequest() should return true\r\n     *          - ValueToken.transfer() should return true\r\n     *\r\n     *      The method is called after calling requestStake. In this flow\r\n     *      locked ValueToken is transferred to owner. Transfer is done for\r\n     *      convenience. This way extra step of calling transferToken is\r\n     *      avoided.\r\n     *\r\n     * @param _stakeRequestHash Stake request hash.\r\n     *\r\n     * @return success_ True on successful execution.\r\n     */\r\n    function revokeStakeRequest(\r\n        bytes32 _stakeRequestHash\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (bool success_)\r\n    {\r\n        StakeRequest memory stakeRequest = stakeRequests[_stakeRequestHash];\r\n\r\n        delete stakeRequests[_stakeRequestHash];\r\n\r\n        require(\r\n            stakeRequest.stakeVT > uint256(0),\r\n            \"Stake request not found.\"\r\n        );\r\n        require(\r\n            brandedToken.revokeStakeRequest(_stakeRequestHash),\r\n            \"BrandedToken revokeStakeRequest returned false.\"\r\n        );\r\n        require(\r\n            valueToken.transfer(owner, stakeRequest.stakeVT),\r\n            \"ValueToken transfer returned false.\"\r\n        );\r\n\r\n        success_ = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers EIP20 token to destination address.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender should be owner\r\n     *          - EIP20 token address should not be zero\r\n     *          - token.transfer() execution should be successful\r\n     *\r\n     * @param _token EIP20 token address.\r\n     * @param _to Address to which tokens are transferred.\r\n     * @param _value Amount of tokens to be transferred.\r\n     *\r\n     * @return success_ True on successful execution.\r\n     */\r\n    function transferToken(\r\n        EIP20Interface _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            address(_token) != address(0),\r\n            \"EIP20 token address is zero.\"\r\n        );\r\n        require(\r\n            _token.transfer(_to, _value),\r\n            \"EIP20Token transfer returned false.\"\r\n        );\r\n\r\n        success_ = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approves EIP20 token to spender address.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender should be owner\r\n     *          - EIP20 token address should not be zero\r\n     *          - token.approve() execution should be successful\r\n     *\r\n     * @param _token EIP20 token address.\r\n     * @param _spender Address authorized to spend from the function caller's\r\n     *                 address.\r\n     * @param _value Amount up to which spender is authorized to spend.\r\n     *\r\n     * @return success_ True on successful execution.\r\n     */\r\n    function approveToken(\r\n        EIP20Interface _token,\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            address(_token) != address(0),\r\n            \"EIP20 token address is zero.\"\r\n        );\r\n        require(\r\n            _token.approve(_spender, _value),\r\n            \"EIP20token approve returned false.\"\r\n        );\r\n\r\n        success_ = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove storage & code from blockchain.\r\n     *\r\n     * @dev Function requires:\r\n     *          - ValueToken balance should be 0\r\n     *          - BrandedToken balance should be 0\r\n     *          - There should not be any in progress stake requests\r\n     *\r\n     *      BrandedToken contract has mapping stakeRequestHashes which stores\r\n     *      staker vs stakeRequestHash data. In progress stake requests are\r\n     *      validated by doing lookup into the stakeRequestHashes mapping.\r\n     */\r\n    function destroy()\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            valueToken.balanceOf(address(this)) == 0,\r\n            \"ValueToken balance should be 0.\"\r\n        );\r\n        require(\r\n            brandedToken.balanceOf(address(this)) == 0,\r\n            \"BrandedToken balance should be 0.\"\r\n        );\r\n        require(\r\n            brandedToken.stakeRequestHashes(address(this)) == bytes32(0),\r\n            \"In progress stake requests are present.\"\r\n        );\r\n\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers value tokens to itself to pay the revert penalty,\r\n     *         approves Gateway to transfer the value tokens for the penalty,\r\n     *         and calls Gateway.revertStake.\r\n     *\r\n     * @dev Function requires:\r\n     *          - msg.sender is owner\r\n     *          - Gateway address can't be zero\r\n     *          - Gateway address should not be equal to owner address\r\n     *          - successful execution of ValueToken transferFrom\r\n     *          - successful execution of ValueToken approve\r\n     *\r\n     *      As per requirement, penalty is paid in valueToken.\r\n     *      Penalty flow:\r\n     *          - staker approves GatewayComposer for value tokens as penalty\r\n     *          - GatewayComposer approves Gateway for the penalty\r\n     *\r\n     * @param _gateway Gateway contract address.\r\n     * @param _penalty Amount to pay to revert stake.\r\n     * @param _messageHash Message hash unique for each stake request.\r\n     *\r\n     * @return success_ True on successful execution.\r\n     */\r\n    function revertStake(\r\n        address _gateway,\r\n        uint256 _penalty,\r\n        bytes32 _messageHash\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (bool success_)\r\n    {\r\n        require(\r\n            _gateway != address(0),\r\n            \"Gateway address is zero.\"\r\n        );\r\n        require(\r\n            owner != _gateway,\r\n            \"Gateway address is same as owner address.\"\r\n        );\r\n        require(\r\n            valueToken.transferFrom(msg.sender, address(this), _penalty),\r\n            \"ValueToken transferFrom returned false.\"\r\n        );\r\n        require(\r\n            valueToken.approve(_gateway, _penalty),\r\n            \"ValueToken approve returned false.\"\r\n        );\r\n\r\n        GatewayInterface(_gateway).revertStake(_messageHash);\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_gateway\",\"type\":\"address\"},{\"name\":\"_penalty\",\"type\":\"uint256\"},{\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"revertStake\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stakeRequests\",\"outputs\":[{\"name\":\"stakeVT\",\"type\":\"uint256\"},{\"name\":\"gateway\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeVT\",\"type\":\"uint256\"},{\"name\":\"_mintBT\",\"type\":\"uint256\"},{\"name\":\"_gateway\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"requestStake\",\"outputs\":[{\"name\":\"stakeRequestHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeRequestHash\",\"type\":\"bytes32\"}],\"name\":\"revokeStakeRequest\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"brandedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeRequestHash\",\"type\":\"bytes32\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_hashLock\",\"type\":\"bytes32\"}],\"name\":\"acceptStakeRequest\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"valueToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_valueToken\",\"type\":\"address\"},{\"name\":\"_brandedToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"GatewayComposer","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c988b2624755384bc1c3657ac743982c5d9dd104000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dc68f9ced517e3a5f6efe5f11f2a71be6e01ece1","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7377e57f69c00860d35c2e47715f3d7894e8978fbc2f82f45cb5dd277f0e2b25"}]}