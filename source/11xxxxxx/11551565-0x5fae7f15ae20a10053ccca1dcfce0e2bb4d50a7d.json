{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src.sol/interfaces/ITransferRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental \\\"ABIEncoderV2\\\";\\n\\nstruct RegisteredTransfer {\\n    string name;\\n    address definition;\\n    string stateEncoding;\\n    string resolverEncoding;\\n    bytes encodedCancel;\\n}\\n\\ninterface ITransferRegistry {\\n    event TransferAdded(RegisteredTransfer transfer);\\n\\n    event TransferRemoved(RegisteredTransfer transfer);\\n\\n    // Should add a transfer definition to the registry\\n    // onlyOwner\\n    function addTransferDefinition(RegisteredTransfer memory transfer) external;\\n\\n    // Should remove a transfer definition to the registry\\n    // onlyOwner\\n    function removeTransferDefinition(string memory name) external;\\n\\n    // Should return all transfer defintions in registry\\n    function getTransferDefinitions()\\n        external\\n        view\\n        returns (RegisteredTransfer[] memory);\\n}\\n\"\r\n    },\r\n    \"src.sol/TransferRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/ITransferRegistry.sol\\\";\\nimport \\\"./lib/LibIterableMapping.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title TransferRegistry\\n/// @author Connext <support@connext.network>\\n/// @notice The TransferRegistry maintains an onchain record of all\\n///         supported transfers (specifically holds the registry information\\n///         defined within the contracts). The offchain protocol uses\\n///         this information to get the correct encodings when generating\\n///         signatures. The information stored here can only be updated\\n///         by the owner of the contract\\n\\ncontract TransferRegistry is Ownable, ITransferRegistry {\\n    using LibIterableMapping for LibIterableMapping.IterableMapping;\\n\\n    LibIterableMapping.IterableMapping transfers;\\n\\n    /// @dev Should add a transfer definition to the registry\\n    function addTransferDefinition(RegisteredTransfer memory definition)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // Get index transfer will be added at\\n        uint256 idx = transfers.length();\\n        \\n        // Add registered transfer\\n        transfers.addTransferDefinition(definition);\\n\\n        // Emit event\\n        emit TransferAdded(transfers.getTransferDefinitionByIndex(idx));\\n    }\\n\\n    /// @dev Should remove a transfer definition from the registry\\n    function removeTransferDefinition(string memory name)\\n        external\\n        override\\n        onlyOwner\\n    {\\n        // Get transfer from library to remove for event\\n        RegisteredTransfer memory transfer = transfers.getTransferDefinitionByName(name);\\n\\n        // Remove transfer\\n        transfers.removeTransferDefinition(name);\\n\\n        // Emit event\\n        emit TransferRemoved(transfer);\\n    }\\n\\n    /// @dev Should return all transfer defintions in registry\\n    function getTransferDefinitions()\\n        external\\n        view\\n        override\\n        returns (RegisteredTransfer[] memory)\\n    {\\n        return transfers.getTransferDefinitions();\\n    }\\n}\\n\"\r\n    },\r\n    \"src.sol/lib/LibIterableMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/ITransferRegistry.sol\\\";\\n\\n/// @title LibIterableMapping\\n/// @author Connext <support@connext.network>\\n/// @notice This library provides an efficient way to store and retrieve\\n///         RegisteredTransfers. This contract is used to manage the transfers\\n///         stored by `TransferRegistry.sol`\\nlibrary LibIterableMapping {\\n    struct TransferDefinitionWithIndex {\\n        RegisteredTransfer transfer;\\n        uint256 index;\\n    }\\n\\n    struct IterableMapping {\\n        mapping(string => TransferDefinitionWithIndex) transfers;\\n        string[] names;\\n    }\\n\\n    function stringEqual(string memory s, string memory t)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return keccak256(abi.encodePacked(s)) == keccak256(abi.encodePacked(t));\\n    }\\n\\n    function isEmptyString(string memory s) internal pure returns (bool) {\\n        return stringEqual(s, \\\"\\\");\\n    }\\n\\n    function nameExists(IterableMapping storage self, string memory name)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return\\n            !isEmptyString(name) &&\\n            self.names.length != 0 &&\\n            stringEqual(self.names[self.transfers[name].index], name);\\n    }\\n\\n    function length(IterableMapping storage self)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return self.names.length;\\n    }\\n\\n    function getTransferDefinitionByName(\\n        IterableMapping storage self,\\n        string memory name\\n    ) internal view returns (RegisteredTransfer memory) {\\n        require(nameExists(self, name), \\\"LibIterableMapping: NAME_NOT_FOUND\\\");\\n        return self.transfers[name].transfer;\\n    }\\n\\n    function getTransferDefinitionByIndex(\\n        IterableMapping storage self,\\n        uint256 index\\n    ) internal view returns (RegisteredTransfer memory) {\\n        require(index < self.names.length, \\\"LibIterableMapping: INVALID_INDEX\\\");\\n        return self.transfers[self.names[index]].transfer;\\n    }\\n\\n    function getTransferDefinitions(IterableMapping storage self)\\n        internal\\n        view\\n        returns (RegisteredTransfer[] memory)\\n    {\\n        uint256 l = self.names.length;\\n        RegisteredTransfer[] memory transfers = new RegisteredTransfer[](l);\\n        for (uint256 i = 0; i < l; i++) {\\n            transfers[i] = self.transfers[self.names[i]].transfer;\\n        }\\n        return transfers;\\n    }\\n\\n    function addTransferDefinition(\\n        IterableMapping storage self,\\n        RegisteredTransfer memory transfer\\n    ) internal {\\n        string memory name = transfer.name;\\n        require(!isEmptyString(name), \\\"LibIterableMapping: EMPTY_NAME\\\");\\n        require(!nameExists(self, name), \\\"LibIterableMapping: NAME_ALREADY_ADDED\\\");\\n        self.transfers[name] = TransferDefinitionWithIndex({\\n            transfer: transfer,\\n            index: self.names.length\\n        });\\n        self.names.push(name);\\n    }\\n\\n    function removeTransferDefinition(\\n        IterableMapping storage self,\\n        string memory name\\n    ) internal {\\n        require(!isEmptyString(name), \\\"LibIterableMapping: EMPTY_NAME\\\");\\n        require(nameExists(self, name), \\\"LibIterableMapping: NAME_NOT_FOUND\\\");\\n        uint256 index = self.transfers[name].index;\\n        string memory lastName = self.names[self.names.length - 1];\\n        self.transfers[lastName].index = index;\\n        self.names[index] = lastName;\\n        delete self.transfers[name];\\n        self.names.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"definition\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"stateEncoding\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"resolverEncoding\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedCancel\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct RegisteredTransfer\",\"name\":\"transfer\",\"type\":\"tuple\"}],\"name\":\"TransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"definition\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"stateEncoding\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"resolverEncoding\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedCancel\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct RegisteredTransfer\",\"name\":\"transfer\",\"type\":\"tuple\"}],\"name\":\"TransferRemoved\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"definition\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"stateEncoding\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"resolverEncoding\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedCancel\",\"type\":\"bytes\"}],\"internalType\":\"struct RegisteredTransfer\",\"name\":\"definition\",\"type\":\"tuple\"}],\"name\":\"addTransferDefinition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransferDefinitions\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"definition\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"stateEncoding\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"resolverEncoding\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedCancel\",\"type\":\"bytes\"}],\"internalType\":\"struct RegisteredTransfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"removeTransferDefinition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TransferRegistry","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7ffce686b133899c962d2392c37d7cc417bfb49017cb433d19d525b065f0f46d"}]}