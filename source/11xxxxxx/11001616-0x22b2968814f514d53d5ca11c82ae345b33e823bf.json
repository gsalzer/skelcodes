{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\VampireAdapter.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ncontract Victim{}\r\n\r\nlibrary VampireAdapter {\r\n    // Victim info\r\n    function rewardToken(Victim victim) external view returns (IERC20) {\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"rewardToken()\"));\r\n        require(success, \"rewardToken() staticcall failed.\");\r\n        return abi.decode(result, (IERC20));\r\n    }\r\n\r\n    function poolCount(Victim victim) external view returns (uint256) {\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"poolCount()\"));\r\n        require(success, \"poolCount() staticcall failed.\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    function sellableRewardAmount(Victim victim) external view returns (uint256) {\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"sellableRewardAmount()\"));\r\n        require(success, \"sellableRewardAmount() staticcall failed.\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    // Victim actions\r\n    function sellRewardForWeth(Victim victim, uint256 rewardAmount, address to) external returns(uint256) {\r\n        (bool success, bytes memory result) = address(victim).delegatecall(abi.encodeWithSignature(\"sellRewardForWeth(address,uint256,address)\", address(victim), rewardAmount, to));\r\n        require(success, \"sellRewardForWeth(uint256 rewardAmount, address to) delegatecall failed.\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    // Pool info\r\n    function lockableToken(Victim victim, uint256 poolId) external view returns (IERC20) {\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"lockableToken(uint256)\", poolId));\r\n        require(success, \"lockableToken(uint256 poolId) staticcall failed.\");\r\n        return abi.decode(result, (IERC20));\r\n    }\r\n\r\n    function lockedAmount(Victim victim, uint256 poolId) external view returns (uint256) {\r\n        // note the impersonation\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"lockedAmount(address,uint256)\", address(this), poolId));\r\n        require(success, \"lockedAmount(uint256 poolId) staticcall failed.\");\r\n        return abi.decode(result, (uint256));\r\n    }\r\n\r\n    // Pool actions\r\n    function deposit(Victim victim, uint256 poolId, uint256 amount) external {\r\n        (bool success,) = address(victim).delegatecall(abi.encodeWithSignature(\"deposit(address,uint256,uint256)\", address(victim), poolId, amount));\r\n        require(success, \"deposit(uint256 poolId, uint256 amount) delegatecall failed.\");\r\n    }\r\n\r\n    function withdraw(Victim victim, uint256 poolId, uint256 amount) external {\r\n        (bool success,) = address(victim).delegatecall(abi.encodeWithSignature(\"withdraw(address,uint256,uint256)\", address(victim), poolId, amount));\r\n        require(success, \"withdraw(uint256 poolId, uint256 amount) delegatecall failed.\");\r\n    }\r\n    \r\n    function claimReward(Victim victim, uint256 poolId) external {\r\n        (bool success,) = address(victim).delegatecall(abi.encodeWithSignature(\"claimReward(address,uint256)\", address(victim), poolId));\r\n        require(success, \"claimReward(uint256 poolId) delegatecall failed.\");\r\n    }\r\n    \r\n    function emergencyWithdraw(Victim victim, uint256 poolId) external {\r\n        (bool success,) = address(victim).delegatecall(abi.encodeWithSignature(\"emergencyWithdraw(address,uint256)\", address(victim), poolId));\r\n        require(success, \"emergencyWithdraw(uint256 poolId) delegatecall failed.\");\r\n    }\r\n    \r\n    // Service methods\r\n    function poolAddress(Victim victim, uint256 poolId) external view returns (address) {\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"poolAddress(uint256)\", poolId));\r\n        require(success, \"poolAddress(uint256 poolId) staticcall failed.\");\r\n        return abi.decode(result, (address));\r\n    }\r\n\r\n    function rewardToWethPool(Victim victim) external view returns (address) {\r\n        (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature(\"rewardToWethPool()\"));\r\n        require(success, \"rewardToWethPool() staticcall failed.\");\r\n        return abi.decode(result, (address));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"lockableToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"IERC20\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"lockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"poolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"}],\"name\":\"poolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"}],\"name\":\"rewardToWethPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"}],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"IERC20\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Victim\",\"name\":\"victim\",\"type\":\"Victim\"}],\"name\":\"sellableRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VampireAdapter","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6202449af079f07c459e9ab41e2916d7d9d1d3d927a8a78f7180a7d42be09f10"}]}