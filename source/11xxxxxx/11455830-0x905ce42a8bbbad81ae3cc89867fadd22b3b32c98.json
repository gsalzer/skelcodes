{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.5;\r\n\r\n/**\r\n* @dev Worldwide OpenBazaar Resource Finder Naming Service(WorfNS)\r\n* A simple naming service to register handles on FCFS basis\r\n*/\r\ncontract WNS {\r\n\r\n    event NewHandle(string handle, bytes data, address indexed owner);\r\n\r\n    event NewDisplayName(string handle, string displayName);\r\n\r\n    event NewImageLocation(string handle, string imageLocation);\r\n\r\n    event NewPeerId(string handle, bytes data);\r\n\r\n    event OwnershipTransferred(string handle, address indexed newOwner);\r\n\r\n    event HandleRemoved(string handle);\r\n\r\n    struct Handle{\r\n        address handleOwner;//Owner of the handle\r\n        string handleName;//This should be unqiue in nature\r\n        string displayName;//Need not to be unqiue\r\n        string imageLocation;//Can be an URI or IPNS address\r\n        bytes data;//extra data\r\n    }\r\n\r\n    //Unique handle hash versus Handle\r\n    mapping(bytes32=>Handle) handleNameHashVsHandle;\r\n\r\n    //addresses who are allowed to handles on other user's behalf\r\n    mapping(address=>bool) public superUsers;\r\n\r\n    modifier onlyHandleOwner(string memory handle){\r\n        require(\r\n            handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner == msg.sender,\r\n            \"Unauthorized access to Handle\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier handleExists(string memory handle){\r\n        require(\r\n            handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner != address(0),\r\n            \"Handle does not exists\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier handleAvailable(string memory handle){\r\n        require(\r\n            handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner == address(0),\r\n            \"Handle is already taken\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address _address){\r\n        require(_address != address(0), \"0 address sent\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySuperUser(){\r\n        require(superUsers[msg.sender], \"Not a super user\");\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _superUsers)public {\r\n\r\n        for(uint i = 0;i<_superUsers.length;i++){\r\n\r\n            superUsers[_superUsers[i]] = true;\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows super user to add handle on other user's behalf\r\n    * @param owner The address of the owner\r\n    * @param handle Unique Handle\r\n    * @param _displayName Display name of the entity\r\n    * @param _imageLocation URI or IPNS of the image\r\n    * @param _data Extra data\r\n    */\r\n    function addHandle(\r\n        address owner,\r\n        string calldata handle,\r\n        string calldata _displayName,\r\n        string calldata _imageLocation,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        onlySuperUser\r\n        nonZeroAddress(owner)\r\n    {\r\n\r\n        _createHandle(\r\n            owner,\r\n            handle,\r\n            _displayName,\r\n            _imageLocation,\r\n            _data\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Method to create new handle\r\n    * @param handle Unique Handle\r\n    * @param _displayName Display name of the entity\r\n    * @param _imageLocation URI or IPNS of the image\r\n    * @param _data Extra data\r\n    */\r\n    function createHandle(\r\n        string calldata handle,\r\n        string calldata _displayName,\r\n        string calldata _imageLocation,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n    {\r\n\r\n        _createHandle(\r\n            msg.sender,\r\n            handle,\r\n            _displayName,\r\n            _imageLocation,\r\n            _data\r\n        );\r\n       \r\n    }\r\n\r\n    //helper method to add/create new handle in the contract\r\n    function _createHandle(\r\n        address owner,\r\n        string memory handle,\r\n        string memory _displayName,\r\n        string memory _imageLocation,\r\n        bytes memory data\r\n    )\r\n        private\r\n        handleAvailable(handle)\r\n    {\r\n\r\n        require(bytes(handle).length>0, \"Empty handle name provided\");\r\n\r\n        bytes32 handleHash = keccak256(abi.encodePacked(handle));\r\n\r\n        handleNameHashVsHandle[handleHash] = Handle({\r\n            handleOwner:owner,\r\n            handleName:handle,\r\n            displayName:_displayName,\r\n            imageLocation:_imageLocation,\r\n            data:data\r\n        });\r\n\r\n        emit NewHandle(handle, data, owner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer handle ownership to new address\r\n    * @param handle Handle whose ownership has to be changed\r\n    * @param newOwner Address of the new owner\r\n    */\r\n    function transferOwnership(\r\n        string calldata handle,\r\n        address newOwner\r\n    )\r\n        external\r\n        handleExists(handle)\r\n        onlyHandleOwner(handle)\r\n        nonZeroAddress(newOwner)\r\n    {\r\n\r\n        bytes32 handleHash = keccak256(abi.encodePacked(handle));\r\n\r\n        require(\r\n            newOwner != handleNameHashVsHandle[handleHash].handleOwner,\r\n            \"New owner is same as previous owner\"\r\n        );\r\n\r\n        handleNameHashVsHandle[handleHash].handleOwner = newOwner;\r\n\r\n        emit OwnershipTransferred(handle, newOwner);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Method to change display name of the entity\r\n    * @param handle Handle whose display name has to be changed\r\n    * @param newName New Display Name\r\n    */\r\n    function changeDisplayName(\r\n        string calldata handle,\r\n        string calldata newName\r\n    )\r\n        external\r\n        handleExists(handle)\r\n        onlyHandleOwner(handle)\r\n    {\r\n\r\n        require(bytes(newName).length>0, \"Empyt names not allowed\");\r\n\r\n        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].displayName = newName;\r\n\r\n        emit NewDisplayName(handle, newName);\r\n    }\r\n\r\n    /**\r\n    * @dev Method to change Location of Image\r\n    * @param handle Handle whose image location has to be changed\r\n    * @param newImageLocation New Image Location\r\n    */\r\n    function changeImageLocation(\r\n        string calldata handle,\r\n        string calldata newImageLocation\r\n    )\r\n        external\r\n        handleExists(handle)\r\n        onlyHandleOwner(handle)\r\n    {\r\n\r\n        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].imageLocation = newImageLocation;\r\n\r\n        emit NewImageLocation(handle, newImageLocation);\r\n    }\r\n\r\n    /**\r\n    * @dev Method to extra data\r\n    * @param handle Handle whose extra data has to be changed\r\n    * @param data change extra data\r\n    */\r\n    function changePeerId(\r\n        string calldata handle,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        handleExists(handle)\r\n        onlyHandleOwner(handle)\r\n    {\r\n\r\n        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].data = data;\r\n\r\n        emit NewPeerId(handle, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Method to get handle info about specific handle\r\n    * @param handleName The handle whose info has to be fetched\r\n    */\r\n    function getHandleInfo(\r\n        string calldata handleName\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            address owner,\r\n            string memory handle,\r\n            string memory displayName,\r\n            string memory imageLocation,\r\n            bytes memory data\r\n        )\r\n    {\r\n\r\n        bytes32 handleBytes = keccak256(abi.encodePacked(handleName));\r\n\r\n        owner = handleNameHashVsHandle[handleBytes].handleOwner;\r\n        handle = handleNameHashVsHandle[handleBytes].handleName;\r\n        displayName = handleNameHashVsHandle[handleBytes].displayName;\r\n        imageLocation = handleNameHashVsHandle[handleBytes].imageLocation;\r\n        data = handleNameHashVsHandle[handleBytes].data;\r\n    }\r\n\r\n    /**\r\n    * @dev Method to check availability of the handle\r\n    * @param handle Handle whose availability has to be checked\r\n    */\r\n    function isHandleAvailable(string calldata handle)external view returns(bool){\r\n        \r\n        return handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner == address(0);\r\n    }\r\n    \r\n    /** \r\n    * @dev Method to remove handleS\r\n    * @param handle Handle to be removed\r\n    */\r\n    function removeHandle(\r\n        string calldata handle\r\n    )\r\n        external\r\n        handleExists(handle)\r\n        onlyHandleOwner(handle)\r\n    {\r\n        \r\n        delete handleNameHashVsHandle[keccak256(abi.encodePacked(handle))];        \r\n        emit HandleRemoved(handle);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_superUsers\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"}],\"name\":\"HandleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"displayName\",\"type\":\"string\"}],\"name\":\"NewDisplayName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewHandle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"imageLocation\",\"type\":\"string\"}],\"name\":\"NewImageLocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"NewPeerId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_displayName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageLocation\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addHandle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeDisplayName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newImageLocation\",\"type\":\"string\"}],\"name\":\"changeImageLocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"changePeerId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_displayName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageLocation\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"createHandle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handleName\",\"type\":\"string\"}],\"name\":\"getHandleInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"displayName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"imageLocation\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"}],\"name\":\"isHandleAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"}],\"name\":\"removeHandle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"superUsers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WNS","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000006856495cadd72f24375dd42165f5d564b3c8b08a","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0f5d56670aa755bfdb19bdec22724389599d000e1b0f0e8cf790a27a4527beac"}]}