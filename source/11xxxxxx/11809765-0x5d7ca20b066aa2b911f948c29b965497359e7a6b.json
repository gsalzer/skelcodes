{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract CoreSwapLimitOrder is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    IUniswapV2Factory public immutable uniswapV2Factory;\r\n    \r\n    \r\n    enum OrderType {EthForTokens, TokensForEth, TokensForTokens}\r\n    enum OrderState {Created, Cancelled, Finished}\r\n    \r\n    uint public ordersNum = 0;\r\n    uint[] public orders;\r\n    struct Order {\r\n        OrderState orderState;\r\n        OrderType orderType;\r\n        address payable traderAddress;\r\n        address assetIn;\r\n        address assetOut;\r\n        uint assetInOffered;\r\n        uint assetOutExpected;\r\n        uint executorFee;\r\n        uint id;\r\n        uint ordersI;\r\n    }\r\n\r\n\r\n    uint public EXECUTOR_FEE = 500000000000000;\r\n\r\n    event orderCreatedLog(uint id, OrderState orderState, OrderType orderType, address payable traderAddress, address assetIn, address assetOut, uint assetInOffered, uint assetOutExpected, uint executorFee);\r\n    event orderExecutedLog(uint id, address executor, uint[] amounts);\r\n    event orderCancelledLog(uint id, address payable traderAddress, address assetIn, address assetOut, uint refundETH, uint refundToken);\r\n    mapping(address => uint[]) private ordersForAddress;\r\n    mapping(uint => Order) public orderBook;\r\n    \r\n    \r\n    constructor(IUniswapV2Router02 _uniswapV2Router) {\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\r\n    }\r\n    \r\n    function setNewExecutorFee(uint256 _EXECUTOR_FEE) external onlyOwner {\r\n        EXECUTOR_FEE = _EXECUTOR_FEE;\r\n    }\r\n    \r\n    function getPair(address tokenA, address tokenB) internal view returns (address) {\r\n        address _tokenPair = uniswapV2Factory.getPair(tokenA, tokenB);\r\n        require(_tokenPair != address(0), \"Unavailable token pair\");\r\n        return _tokenPair;\r\n    }\r\n    \r\n    function updateOrderState(Order memory order, OrderState newState) internal {\r\n        if(orders.length > 1) {\r\n            uint openId = order.ordersI;\r\n            uint lastId = orders[orders.length-1];\r\n            Order memory lastOrder = orderBook[lastId];\r\n            lastOrder.ordersI = openId;\r\n            orderBook[lastId] = lastOrder;\r\n            orders[openId] = lastId;\r\n        }\r\n        orders.pop();\r\n        order.orderState = newState;\r\n        orderBook[order.id] = order;        \r\n    }\r\n    \r\n    function createOrder(OrderType orderType, address assetIn, address assetOut, uint assetInOffered, uint assetOutExpected, uint executorFee) external payable {\r\n        \r\n        uint payment = msg.value;\r\n        \r\n        require(assetInOffered > 0, \"Asset in amount must be greater than 0\");\r\n        require(assetOutExpected > 0, \"Asset out amount must be greater than 0\");\r\n        require(executorFee >= EXECUTOR_FEE, \"Invalid fee\");\r\n        \r\n        if(orderType == OrderType.EthForTokens) {\r\n            require(assetIn == uniswapV2Router.WETH(), \"Use WETH as the assetIn\");\r\n            require(payment >= assetInOffered.add(executorFee), \"Payment = assetInOffered + executorFee\");\r\n        }\r\n        else {\r\n            require(payment >= executorFee, \"Transaction value must match executorFee\");\r\n            if (orderType == OrderType.TokensForEth) { require(assetOut == uniswapV2Router.WETH(), \"Use WETH as the assetOut\"); }\r\n            TransferHelper.safeTransferFrom(assetIn, msg.sender, address(this), assetInOffered);\r\n        }\r\n        \r\n        \r\n        uint orderId = ordersNum;\r\n        ordersNum++;\r\n        \r\n        orderBook[orderId] = Order(OrderState.Created, orderType, msg.sender, assetIn, assetOut, assetInOffered, \r\n        assetOutExpected, executorFee, orderId, orders.length);\r\n        \r\n        ordersForAddress[msg.sender].push(orderId);\r\n        orders.push(orderId);\r\n        \r\n        emit orderCreatedLog( orderId, OrderState.Created, orderType, msg.sender, assetIn, assetOut, assetInOffered, assetOutExpected, executorFee);\r\n    }\r\n        \r\n    function cancelOrder(uint orderId) external {\r\n        Order memory order = orderBook[orderId];  \r\n        require(order.traderAddress != address(0), \"Invalid order\");\r\n        require(msg.sender == order.traderAddress, 'This order is not yours');\r\n        require(order.orderState == OrderState.Created, 'Invalid order state');\r\n        \r\n        updateOrderState(order, OrderState.Cancelled);\r\n        \r\n        uint refundETH = 0;\r\n        uint refundToken = 0;\r\n        \r\n        if (order.orderType != OrderType.EthForTokens) {\r\n            refundETH = order.executorFee;\r\n            refundToken = order.assetInOffered;\r\n            TransferHelper.safeTransferETH(order.traderAddress, refundETH);\r\n            TransferHelper.safeTransfer(order.assetIn, order.traderAddress, refundToken);\r\n        }\r\n        else {\r\n            refundETH = order.assetInOffered.add(order.executorFee);\r\n            TransferHelper.safeTransferETH(order.traderAddress, refundETH);  \r\n        }\r\n        \r\n        emit orderCancelledLog(order.id, order.traderAddress, order.assetIn, order.assetOut, refundETH, refundToken);        \r\n    }\r\n    \r\n    function executeOrder(uint orderId) external onlyOwner returns (uint[] memory) {\r\n        Order memory order = orderBook[orderId];  \r\n        require(order.traderAddress != address(0), \"Invalid order\");\r\n        require(order.orderState == OrderState.Created, 'Invalid order state');\r\n        \r\n        updateOrderState(order, OrderState.Finished);\r\n    \r\n        address[] memory pair = new address[](2);\r\n        pair[0] = order.assetIn;\r\n        pair[1] = order.assetOut;\r\n\r\n        uint[] memory swapResult;\r\n        \r\n        if (order.orderType == OrderType.EthForTokens) {\r\n            swapResult = uniswapV2Router.swapExactETHForTokens{value:order.assetInOffered}(order.assetOutExpected, pair, order.traderAddress, block.timestamp);\r\n        } \r\n        else if (order.orderType == OrderType.TokensForEth) {\r\n            TransferHelper.safeApprove(order.assetIn, address(uniswapV2Router), order.assetInOffered);\r\n            swapResult = uniswapV2Router.swapExactTokensForETH(order.assetInOffered, order.assetOutExpected, pair, order.traderAddress, block.timestamp);\r\n        }\r\n        else if (order.orderType == OrderType.TokensForTokens) {\r\n            TransferHelper.safeApprove(order.assetIn, address(uniswapV2Router), order.assetInOffered);\r\n            swapResult = uniswapV2Router.swapExactTokensForTokens(order.assetInOffered, order.assetOutExpected, pair, order.traderAddress, block.timestamp);\r\n        }\r\n        \r\n        TransferHelper.safeTransferETH(msg.sender, order.executorFee);\r\n        emit orderExecutedLog(order.id, msg.sender, swapResult);\r\n        \r\n        return swapResult;\r\n    }\r\n    \r\n    function getOrdersLength() external view returns (uint) {\r\n        return orders.length;\r\n    }\r\n    \r\n    receive() external payable {}\r\n    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_uniswapV2Router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"traderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundToken\",\"type\":\"uint256\"}],\"name\":\"orderCancelledLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum CoreSwapLimitOrder.OrderState\",\"name\":\"orderState\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum CoreSwapLimitOrder.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"traderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetOutExpected\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executorFee\",\"type\":\"uint256\"}],\"name\":\"orderCreatedLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"orderExecutedLog\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EXECUTOR_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CoreSwapLimitOrder.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutExpected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executorFee\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"executeOrder\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrdersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderBook\",\"outputs\":[{\"internalType\":\"enum CoreSwapLimitOrder.OrderState\",\"name\":\"orderState\",\"type\":\"uint8\"},{\"internalType\":\"enum CoreSwapLimitOrder.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"traderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutExpected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executorFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ordersI\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ordersNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_EXECUTOR_FEE\",\"type\":\"uint256\"}],\"name\":\"setNewExecutorFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CoreSwapLimitOrder","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://78ec3b0033eeae88593786489f4355882cae2e5f2303656ff0a53db54e2c1c2d"}]}