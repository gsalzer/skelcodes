{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity^0.6.0;\r\n/*\r\n* Team Equitable Builds Inc presents..\r\n* ====================================*\r\n*        _____ ___ _______ ______     *\r\n*       |  _  |  ||  |  __|   __|     *\r\n*       |     |  |  |  __|   |__      *\r\n*       |__|__|_____|____|_____|      *\r\n*                                     *\r\n* ====================================*\r\n*/\r\ncontract AVEC{\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    //verify caller address members_ = true\r\n    modifier onlyMembers(address _customerAddress) {\r\n        require(\r\n                // is the customer in the member whitelist?\r\n                members_[_customerAddress] == true\r\n            );\r\n            // execute\r\n        _;\r\n    }\r\n    //verify caller address founderdevelopers_ = true\r\n    modifier onlyFounderDevelopers(address _customerAddress) {\r\n        require(\r\n                // is the customer in the Founder Developer whitelist?\r\n                founderdevelopers_[_customerAddress] == true\r\n            );\r\n            // execute\r\n        _;\r\n    }\r\n    //verify caller address ceva_ = true\r\n    modifier onlyCEVA(address _customerAddress) {\r\n        require(\r\n                // is the customer in the ceva whitelist?\r\n                ceva_[_customerAddress] == true\r\n            );\r\n            // execute\r\n        _;\r\n    }\r\n    modifier onlyAdministrator(address _customerAddress){\r\n        require(\r\n            administrators[_customerAddress] == true\r\n            );\r\n        _;\r\n    }\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 tokensWithdrawn\r\n    );\r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n    event Burn(\r\n        address indexed from,\r\n        uint256 tokens,\r\n        uint256 propertyValue\r\n    );\r\n    // ERC20\r\n    event Approval(\r\n        address indexed _owner, \r\n        address indexed _spender, \r\n        uint256 _value\r\n    );\r\n    event PropertyValuation(\r\n        address indexed from,\r\n        bytes32 _propertyUniqueID,\r\n        uint256 propertyValue\r\n    );\r\n    event PropertyWhitelisted(\r\n        address indexed from,\r\n        bytes32 _propertyUniqueID,\r\n        bool _trueFalse\r\n    );\r\n    event MemberWhitelisted(\r\n        address indexed from,\r\n        address indexed to,\r\n        bool _trueFalse\r\n    );\r\n    event FounderDeveloperWhitelisted(\r\n        address indexed from,\r\n        address indexed to,\r\n        bool _trueFalse\r\n    );\r\n    event CEVAWhitelisted(\r\n        address indexed from,\r\n        address indexed to,\r\n        bool _trueFalse\r\n    );\r\n    event AdminWhitelisted(\r\n        address indexed from,\r\n        address indexed to,\r\n        bool _trueFalse\r\n    );\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string private name = \"AlternateVirtualEquityCredits\";\r\n    string private symbol = \"AVEC\";\r\n    uint8 private decimals = 18;\r\n    address internal whoaaddress_ = 0x314d0ED76d866826C809fb6a51d63642b2E9eC3e;\r\n    address internal whoamaintenanceaddress_ = 0x2722B426B11978c29660e8395a423Ccb93AE0403;\r\n    address internal whoarewardsaddress_ = 0xA9d241b568DF9E8A7Ec9e44737f29a8Ee00bfF53;\r\n    address internal cevaaddress_ = 0xdE281c22976dE2E9b3f4F87bEB60aE9E67DFf5C4;\r\n    address internal credibleyouaddress_ = 0xc9c1Ffd6B4014232Ef474Daa4CA1506A6E39Be89;\r\n    address internal techaddress_ = 0xB6148C62e6A6d48f41241D01e3C4841139144ABa;\r\n    address internal existholdingsaddress_ = 0xac1B6580a175C1f2a4e3220A24e6f65fF3AB8A03;\r\n    address internal existcryptoaddress_ = 0xb8C098eE976f1162aD277936a5D1BCA7a8Fe61f5;\r\n    // founder developer address whitelist archive\r\n    mapping(address => bool) internal members_;\r\n    // members whitelist address archive\r\n    mapping(address => bool) internal founderdevelopers_;\r\n    // ceva whitelist address archive\r\n    mapping(address => bool) internal ceva_;\r\n    // administrator list (see above on what they can do)\r\n    mapping(address => bool) internal administrators;\r\n    // setting for allowance function determines amount of tokens address can spend from mapped address\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n    mapping (address => mapping(bytes32 => bool)) internal mintrequestwhitelist_;\r\n    mapping (address => mapping(bytes32 => bool)) internal burnrequestwhitelist_;\r\n    mapping (address => mapping(bytes32 => bool)) internal propertywhitelist_;\r\n    mapping (address => mapping(bytes32 => uint256)) internal propertyvalue_;\r\n    mapping(address => bytes32) workingPropertyid_;\r\n    mapping(address => bytes32) workingMintRequestid_;\r\n    mapping(address => bytes32) workingBurnRequestid_;\r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal tokenBalanceLedger_ ;\r\n    mapping(address => uint256) internal mintingDepositsOf_;\r\n    mapping(address => uint256) internal AmountCirculated_;\r\n    mapping(address => uint256) internal taxesFeeTotalWithdrawn_;\r\n    mapping(address => uint256) internal taxesPreviousWithdrawn_;\r\n    mapping(address => uint256) internal taxesFeeSharehold_;\r\n    mapping(address => uint256) internal insuranceFeeTotalWithdrawn_;\r\n    mapping(address => uint256) internal insurancePreviousWithdrawn_;\r\n    mapping(address => uint256) internal insuranceFeeSharehold_;\r\n    mapping(address => uint256) internal maintenanceFeeTotalWithdrawn_;\r\n    mapping(address => uint256) internal maintenancePreviousWithdrawn_;\r\n    mapping(address => uint256) internal maintenanceFeeSharehold_;\r\n    mapping(address => uint256) internal waECOFeeTotalWithdrawn_;\r\n    mapping(address => uint256) internal waECOPreviousWithdrawn_;\r\n    mapping(address => uint256) internal waECOFeeSharehold_;\r\n    mapping(address => uint256) internal holdoneTotalWithdrawn_;\r\n    mapping(address => uint256) internal holdonePreviousWithdrawn_;\r\n    mapping(address => uint256) internal holdoneSharehold_;\r\n    mapping(address => uint256) internal holdtwoTotalWithdrawn_;\r\n    mapping(address => uint256) internal holdtwoPreviousWithdrawn_;\r\n    mapping(address => uint256) internal holdtwoSharehold_;\r\n    mapping(address => uint256) internal holdthreeTotalWithdrawn_;\r\n    mapping(address => uint256) internal holdthreePreviousWithdrawn_;\r\n    mapping(address => uint256) internal holdthreeSharehold_;\r\n    mapping(address => uint256) internal rewardsTotalWithdrawn_;\r\n    mapping(address => uint256) internal rewardsPreviousWithdrawn_;\r\n    mapping(address => uint256) internal rewardsSharehold_;\r\n    mapping(address => uint256) internal techTotalWithdrawn_;\r\n    mapping(address => uint256) internal techPreviousWithdrawn_;\r\n    mapping(address => uint256) internal techSharehold_;\r\n    mapping(address => uint256) internal existholdingsTotalWithdrawn_;\r\n    mapping(address => uint256) internal existholdingsPreviousWithdrawn_;\r\n    mapping(address => uint256) internal existholdingsSharehold_;\r\n    mapping(address => uint256) internal existcryptoTotalWithdrawn_;\r\n    mapping(address => uint256) internal existcryptoPreviousWithdrawn_;\r\n    mapping(address => uint256) internal existcryptoSharehold_;\r\n    mapping(address => uint256) internal whoaTotalWithdrawn_;\r\n    mapping(address => uint256) internal whoaPreviousWithdrawn_;\r\n    mapping(address => uint256) internal whoaSharehold_;\r\n    mapping(address => uint256) internal credibleyouTotalWithdrawn_;\r\n    mapping(address => uint256) internal credibleyouPreviousWithdrawn_;\r\n    mapping(address => uint256) internal credibleyouSharehold_;\r\n    mapping(address => uint256) internal numberofmintingrequestswhitelisted_;\r\n    mapping(address => uint256) internal numberofpropertieswhitelisted_;\r\n    mapping(address => uint256) internal numberofburnrequestswhitelisted_;\r\n    mapping(address => uint256) internal transferingFromWallet_;\r\n    uint256 public tokenSupply_ = 0;\r\n    uint256 public feeTotalHolds_ = 0;\r\n    uint256 internal cevaBurnerStockpile_ = 0;\r\n    uint256 internal cevaBurnerStockpileWithdrawn_ = 0;\r\n    uint256 internal taxesfeeTotalHolds_ = 0;\r\n    uint256 internal taxesfeeBalanceLedger_ = 0;\r\n    uint256 internal insurancefeeTotalHolds_ = 0;\r\n    uint256 internal insurancefeeBalanceLedger_ = 0;\r\n    uint256 internal maintencancefeeTotalHolds_ = 0;\r\n    uint256 internal maintenancefeeBalanceLedger_ = 0;\r\n    uint256 internal waECOfeeTotalHolds_ = 0;\r\n    uint256 internal waECOfeeBalanceLedger_ = 0;\r\n    uint256 internal holdonefeeTotalHolds_ = 0;\r\n    uint256 internal holdonefeeBalanceLedger_ = 0;\r\n    uint256 internal holdtwofeeTotalHolds_ = 0;\r\n    uint256 internal holdtwofeeBalanceLedger_ = 0;\r\n    uint256 internal holdthreefeeTotalHolds_ = 0;\r\n    uint256 internal holdthreefeeBalanceLedger_ = 0;\r\n    uint256 internal RewardsfeeTotalHolds_ = 0;\r\n    uint256 internal RewardsfeeBalanceLedger_ = 0;\r\n    uint256 internal techfeeTotalHolds_ = 0;\r\n    uint256 internal techfeeBalanceLedger_ = 0;\r\n    uint256 internal existholdingsfeeTotalHolds_ = 0;\r\n    uint256 internal existholdingsfeeBalanceLedger_ = 0;\r\n    uint256 internal existcryptofeeTotalHolds_ = 0;\r\n    uint256 internal existcryptofeeBalanceLedger_ = 0;\r\n    uint256 internal whoafeeTotalHolds_ = 0;\r\n    uint256 internal whoafeeBalanceLedger_ = 0;\r\n    uint256 internal credibleyoufeeTotalHolds_ = 0;\r\n    uint256 internal credibleyoufeeBalanceLedger_ = 0;\r\n    /*=======================================\r\n    =            MEMBER FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS -- \r\n    */\r\n    constructor()\r\n        public\r\n    {\r\n    }\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS -- \r\n    */\r\n    function InitialSet()\r\n        public\r\n    {\r\n        // add the first users\r\n        //James Admin\r\n        administrators[0x27851761A8fBC03f57965b42528B39af07cdC42b] = true;\r\n        //Brenden Admin\r\n        administrators[0xA9873d93db3BCA9F68aDfEAb226Fa9189641069A] = true;\r\n        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] = true;\r\n        members_[0x2722B426B11978c29660e8395a423Ccb93AE0403] = true;\r\n        members_[0xdE281c22976dE2E9b3f4F87bEB60aE9E67DFf5C4] = true;\r\n        members_[0xc9c1Ffd6B4014232Ef474Daa4CA1506A6E39Be89] = true;\r\n        members_[0xac1B6580a175C1f2a4e3220A24e6f65fF3AB8A03] = true;\r\n        members_[0xb8C098eE976f1162aD277936a5D1BCA7a8Fe61f5] = true;\r\n        members_[0xB6148C62e6A6d48f41241D01e3C4841139144ABa] = true;\r\n        members_[0xA9d241b568DF9E8A7Ec9e44737f29a8Ee00bfF53] = true;\r\n        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] = true;\r\n        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] = true;\r\n        \r\n    }\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS -- \r\n    */\r\n    function genesis(address _existcryptoaddress, address _existhooldingsaddress, address _techaddress, \r\n        address _credibleyouaddress, address _cevaaddress, address _whoaddress, address _whoarewardsaddress, address _whoamaintenanceaddress)\r\n        public\r\n        onlyAdministrator(msg.sender)\r\n    {\r\n        require(administrators[msg.sender]);\r\n        // adds the first founder developer here.\r\n        founderdevelopers_[msg.sender] = true;\r\n        // adds the _whoaddress input as the current whoa address\r\n        whoaaddress_ = _whoaddress;\r\n        // adds the _whoamaintenanceaddress input as the current whoa maintenence address\r\n        whoamaintenanceaddress_ = _whoamaintenanceaddress;\r\n        // adds the _whoarewardsaddress input as the current whoa rewards address\r\n        whoarewardsaddress_ = _whoarewardsaddress;\r\n        // adds the )cevaaddress_ input as the current ceva address\r\n        cevaaddress_ = _cevaaddress;\r\n        // adds the _credibleyouaddress input as the current credible you address\r\n        credibleyouaddress_ = _credibleyouaddress;\r\n        // adds the _techaddress input as the current tech address\r\n        techaddress_ = _techaddress;\r\n        // adds the __existhooldingsaddress input as the current exist holdings address\r\n        existholdingsaddress_ = _existhooldingsaddress;\r\n        // adds the _existcryptoaddress input as the current exist crypto address\r\n        existcryptoaddress_ = _existcryptoaddress;\r\n        // adds the first ceva qualified founder developers here.\r\n        ceva_[msg.sender] = true;\r\n        numberofburnrequestswhitelisted_[msg.sender] = 0;\r\n        numberofpropertieswhitelisted_[msg.sender] = 0;\r\n        numberofmintingrequestswhitelisted_[msg.sender] = 0;\r\n        // adds the first member here.\r\n        members_[msg.sender] = true;\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function buyFounderDeveloperLicense(address _FounderDeveloperOne, address _FounderDeveloperTwo, address _CEVA)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool _success)\r\n    {\r\n        require(founderdevelopers_[_FounderDeveloperOne] == true && ceva_[_CEVA] == true && founderdevelopers_[_FounderDeveloperTwo] == true);\r\n        // setup data\r\n            address _customerAddress = msg.sender;\r\n            uint256 _licenseprice = (1000 * 1e18);\r\n            if(tokenBalanceLedger_[_customerAddress] > _licenseprice){\r\n                tokenBalanceLedger_[_CEVA] = (_licenseprice / 5) + tokenBalanceLedger_[_CEVA];\r\n                tokenBalanceLedger_[_FounderDeveloperOne] =  (_licenseprice / 5) + tokenBalanceLedger_[_FounderDeveloperOne];\r\n                tokenBalanceLedger_[_FounderDeveloperTwo] =  (_licenseprice / 10) + tokenBalanceLedger_[_FounderDeveloperTwo];\r\n                tokenBalanceLedger_[_customerAddress] =  tokenBalanceLedger_[_customerAddress] - _licenseprice;\r\n                founderdevelopers_[_customerAddress] = true;\r\n                return true;\r\n            } else {\r\n                return false;\r\n        }\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawTaxesdividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EtaxesdividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        taxesFeeTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawInsurancedividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EinsurancedividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        insuranceFeeTotalWithdrawn_[_customerAddress] += _dividends;\r\n        tokenBalanceLedger_[_customerAddress] += _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawMaintenancedividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EmaintenancedividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        maintenanceFeeTotalWithdrawn_[_customerAddress] += _dividends;\r\n        tokenBalanceLedger_[_customerAddress] += _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawwaECOdividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EwaECOdividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        maintenanceFeeTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        waECOFeeTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawHoldOnedividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EholdonedividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        holdoneTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawHoldTwodividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EholdtwodividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        holdtwoTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawHoldThreeedividends()\r\n        onlyMembers(msg.sender)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EholdthreedividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        holdthreeTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawRewardsdividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = ErewardsdividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        rewardsTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawTechdividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EtechdividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        techTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawExistHoldingsdividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = existholdingsdividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        existholdingsTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawExistCryptodividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = existcryptodividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        existcryptoTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawWHOAdividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EwhoadividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        whoaTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Withdraws all of the callers taxes earnings.\r\n     */\r\n    function withdrawCrediblelYoudividends()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = EcredibleyoudividendsOf(msg.sender);\r\n        // update dividend tracker\r\n        credibleyouTotalWithdrawn_[_customerAddress] +=  _dividends;\r\n        tokenBalanceLedger_[_customerAddress] +=  _dividends;\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Remember, there's a 2% fee here as well. members only\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amountOfTokens > 0){\r\n        // make sure we have the requested tokens\r\n            require(_amountOfTokens + (_amountOfTokens / 50) <= tokenBalanceLedger_[msg.sender] && \r\n            _amountOfTokens >= 0 && _toAddress != msg.sender && members_[_toAddress] == true);\r\n        //Exchange tokens\r\n            tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress] + _amountOfTokens;\r\n            tokenBalanceLedger_[msg.sender] -= _amountOfTokens + (_amountOfTokens / 50);\r\n        //Update Equity Rents\r\n            updateEquityRents(_amountOfTokens);\r\n            AmountCirculated_[msg.sender] += _amountOfTokens;\r\n            emit Transfer(msg.sender, _toAddress, (_amountOfTokens + (_amountOfTokens / 50)));\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Remember, there's a 2% fee here as well. members only\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokens)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(tokens >= 0){\r\n            require(members_[to] == true);\r\n            // setup\r\n            address _customerAddress = msg.sender;\r\n            // make sure we have the requested tokens\r\n            require(tokens + (tokens / 50) <= tokenBalanceLedger_[from] && tokens >= 0 && to != _customerAddress && from != to && \r\n            tokens + (tokens / 50) <= _allowed[from][msg.sender] && msg.sender != from && transferingFromWallet_[msg.sender] == 0);\r\n            transferingFromWallet_[msg.sender] = 1;\r\n            //Exchange tokens\r\n            tokenBalanceLedger_[to] = tokenBalanceLedger_[to] + tokens;\r\n            tokenBalanceLedger_[msg.sender] -= tokens + (tokens / 50);\r\n            //Reduce Approval Amount\r\n            _allowed[from][msg.sender] -= tokens + (tokens / 50);\r\n            emit Transfer(_customerAddress, to, (tokens + (tokens / 50)));\r\n            transferingFromWallet_[msg.sender] = 0;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return _allowed[tokenOwner][spender];\r\n    }\r\n     /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Remember, there's a 2% fee here as well. members only\r\n     */\r\n    function clearTitle(uint256 _propertyValue, uint256 _amountOfTokens, address _clearFrom)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if((_amountOfTokens / 1e18) * 100 <= _propertyValue){\r\n            require(burnrequestwhitelist_[_clearFrom][workingBurnRequestid_[msg.sender]] == true && propertywhitelist_[_clearFrom][workingPropertyid_[msg.sender]] == true && \r\n            _amountOfTokens <= tokenBalanceLedger_[_clearFrom] && _amountOfTokens >= 0);\r\n            //Burn Tokens\r\n            burnA(_propertyValue);\r\n            tokenSupply_ -= _amountOfTokens;\r\n            taxesfeeTotalHolds_ -= _propertyValue / 100;\r\n            insurancefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            maintencancefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            waECOfeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            holdonefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            holdtwofeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            holdthreefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100); \r\n            // take tokens out of stockpile\r\n            //Exchange tokens\r\n            cevaBurnerStockpile_ -= ((propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100) * 1e18) - _amountOfTokens;\r\n            tokenBalanceLedger_[msg.sender] -= _amountOfTokens;\r\n            //  burn fee shareholds\r\n            taxesFeeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            insuranceFeeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            maintenanceFeeSharehold_[whoamaintenanceaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            waECOFeeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            holdoneSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            holdtwoSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            holdthreeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            rewardsSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            techSharehold_[techaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            existholdingsSharehold_[existholdingsaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            existcryptoSharehold_[existcryptoaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            whoaSharehold_[whoaaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            credibleyouSharehold_[credibleyouaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\r\n            // returns bool true\r\n            emit Burn(msg.sender, _amountOfTokens, _propertyValue);\r\n            \r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellTaxesFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= taxesFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                taxesPreviousWithdrawn_[_toAddress] += (taxesFeeTotalWithdrawn_[_customerAddress] / taxesFeeSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                taxesFeeSharehold_[_toAddress] += _amount;\r\n                taxesFeeSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellInsuranceFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= insuranceFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                insurancePreviousWithdrawn_[_toAddress] += (insuranceFeeTotalWithdrawn_[_customerAddress] / insuranceFeeSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                insuranceFeeSharehold_[_toAddress] += _amount;\r\n                insuranceFeeSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellMaintenanceFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= maintenanceFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                maintenancePreviousWithdrawn_[_toAddress] += (maintenanceFeeTotalWithdrawn_[_customerAddress] / maintenanceFeeSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                maintenanceFeeSharehold_[_toAddress] += _amount;\r\n                maintenanceFeeSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellwaECOFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= waECOFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                waECOPreviousWithdrawn_[_toAddress] += (waECOFeeTotalWithdrawn_[_customerAddress] / waECOFeeSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                waECOFeeSharehold_[_toAddress] += _amount;\r\n                waECOFeeSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellHoldOneFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= holdoneSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                holdonePreviousWithdrawn_[_toAddress] += (holdoneTotalWithdrawn_[_customerAddress] / holdoneSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                holdoneSharehold_[_toAddress] += _amount;\r\n                holdoneSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellHoldTwoFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= holdtwoSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                holdtwoPreviousWithdrawn_[_toAddress] += (holdtwoTotalWithdrawn_[_customerAddress] / holdtwoSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                holdtwoSharehold_[_toAddress] += _amount;\r\n                holdtwoSharehold_[_customerAddress] -= _amount;\r\n            \r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellHoldThreeFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= holdthreeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                holdthreePreviousWithdrawn_[_toAddress] += (holdthreeTotalWithdrawn_[_customerAddress] / holdthreeSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                holdthreeSharehold_[_toAddress] += _amount;\r\n                holdthreeSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellRewardsFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= rewardsSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                rewardsPreviousWithdrawn_[_toAddress] += (rewardsTotalWithdrawn_[_customerAddress] / rewardsSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                rewardsSharehold_[_toAddress] += _amount;\r\n                rewardsSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellTechFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= techSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                techPreviousWithdrawn_[_toAddress] += (techTotalWithdrawn_[_customerAddress] / techSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                techSharehold_[_toAddress] += _amount;\r\n                techSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellExistHoldingsFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        onlyMembers(_toAddress)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            //require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= existholdingsSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                existholdingsPreviousWithdrawn_[_toAddress] += (existholdingsTotalWithdrawn_[_customerAddress] / existholdingsSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                existholdingsSharehold_[_toAddress] += _amount;\r\n                existholdingsSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellExistCryptoFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= existcryptoSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                existcryptoPreviousWithdrawn_[_toAddress] += (existcryptoTotalWithdrawn_[_customerAddress] / existcryptoSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                existcryptoSharehold_[_toAddress] += _amount;\r\n                existcryptoSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellWHOAFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n         address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= whoaSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                whoaPreviousWithdrawn_[_toAddress] += (whoaTotalWithdrawn_[_customerAddress] / whoaSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                whoaSharehold_[_toAddress] += _amount;\r\n                whoaSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Transfer fee sharehold from the caller to a new holder.\r\n     */\r\n    function sellCredibleYouFeeSharehold(address _toAddress, uint256 _amount)\r\n        onlyMembers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_amount > 0){\r\n            require(members_[_toAddress] == true);\r\n        // setup\r\n            address _customerAddress = msg.sender;\r\n        // make sure we have the requested sharehold\r\n            require(_amount <= credibleyouSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\r\n        //Update fee sharehold previous withdrawals    \r\n                credibleyouPreviousWithdrawn_[_toAddress] += (credibleyouTotalWithdrawn_[_customerAddress] / credibleyouSharehold_[_customerAddress]) * _amount;\r\n        //Exchange sharehold\r\n                credibleyouSharehold_[_toAddress] += _amount;\r\n                credibleyouSharehold_[_customerAddress] -= _amount;\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Check and address to see if it has CEVA privileges or not\r\n     */\r\n    function checkCEVA(address _identifier)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        if(ceva_[_identifier] == true){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Check and address to see if it has member privileges\r\n     */\r\n    function checkMember(address _identifier)\r\n        public\r\n        view\r\n        returns(bool) \r\n    {\r\n        if(members_[_identifier] == true){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Check and address to see is its got founder developer privileges\r\n     */\r\n    function checkFounderDeveloper(address _identifier)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        if(founderdevelopers_[_identifier] == true){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Check and address to see if it has admin privileges\r\n     */\r\n    function checkAdmin(address _identifier)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        if(administrators[_identifier] == true){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /**\r\n     * whitelist Admins admin only\r\n     */\r\n    function AwhitelistAdministrator(address _identifier, bool _status)\r\n        onlyAdministrator(msg.sender)\r\n        public\r\n    {\r\n        require(msg.sender != _identifier);\r\n            administrators[_identifier] = _status;\r\n            emit AdminWhitelisted(msg.sender, _identifier, _status);\r\n    }\r\n    /**\r\n     * Automation entrypoint to whitelist ceva_ admin only\r\n     */\r\n    function AwhitelistCEVA(address _identifier, bool _status)\r\n        onlyAdministrator(msg.sender)\r\n        public\r\n    {\r\n        require(msg.sender != _identifier);\r\n            ceva_[_identifier] = _status;\r\n            numberofburnrequestswhitelisted_[msg.sender] = 0;\r\n            numberofpropertieswhitelisted_[msg.sender] = 0;\r\n            numberofmintingrequestswhitelisted_[msg.sender] = 0;\r\n            emit CEVAWhitelisted(msg.sender, _identifier, _status);\r\n    }\r\n    function withdrawCEVABurnerStockpiledividends(uint256 _amountOfTokens)\r\n        onlyCEVA(msg.sender)\r\n        public\r\n    {\r\n        // setup data\r\n        require(_amountOfTokens <= cevaBurnerStockpile_);\r\n            // update dividend tracker\r\n            cevaBurnerStockpile_ -= _amountOfTokens;\r\n            cevaBurnerStockpileWithdrawn_ += _amountOfTokens;\r\n            tokenBalanceLedger_[cevaaddress_] += _amountOfTokens;\r\n            emit Transfer(msg.sender, msg.sender, _amountOfTokens);\r\n    }\r\n    /**\r\n     * Whitelist a Property that has been confirmed on the site.. ceva only\r\n     */\r\n    function AwhitelistMintRequest(address _OwnerAddress, bool _trueFalse, bytes32 _mintingRequestUniqueid)\r\n        onlyCEVA(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_mintingRequestUniqueid == workingMintRequestid_[msg.sender]){\r\n            require(msg.sender != _OwnerAddress);\r\n            mintrequestwhitelist_[_OwnerAddress][_mintingRequestUniqueid] = _trueFalse;\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Whitelist a Property that has been confirmed on the site.. ceva only\r\n     */\r\n    function AwhitelistBurnRequest(address _OwnerAddress, bool _trueFalse, bytes32 _burnrequestUniqueID)\r\n        onlyCEVA(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_burnrequestUniqueID == workingBurnRequestid_[msg.sender]){\r\n            require(msg.sender != _OwnerAddress);\r\n            burnrequestwhitelist_[_OwnerAddress][_burnrequestUniqueID] = _trueFalse;\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\r\n     */\r\n    function AwhitelistProperty(address _OwnerAddress, bool _trueFalse, bytes32 _propertyUniqueID)\r\n        onlyCEVA(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        if(_trueFalse = true){\r\n            require(workingPropertyid_[msg.sender] == _propertyUniqueID);\r\n            propertywhitelist_[_OwnerAddress][_propertyUniqueID] = _trueFalse;\r\n            emit PropertyWhitelisted(msg.sender, _propertyUniqueID, _trueFalse);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\r\n     */\r\n    function AsetWhitelistedPropertyValue(address _OwnerAddress, bytes32 _propertyUniqueID, uint256 _propertyValue)\r\n        onlyCEVA(msg.sender)\r\n        public\r\n        returns(uint256)\r\n    {\r\n        require(propertywhitelist_[_OwnerAddress][_propertyUniqueID] = true && _propertyValue >= 0);\r\n            if(_OwnerAddress != msg.sender){\r\n                address _customerAddress = msg.sender;\r\n                numberofmintingrequestswhitelisted_[msg.sender] += 1;\r\n                emit PropertyValuation(_customerAddress, _propertyUniqueID, _propertyValue);\r\n                return _propertyValue;\r\n            } else { \r\n                numberofmintingrequestswhitelisted_[msg.sender] -= 1;\r\n                _propertyValue = 0;\r\n                return _propertyValue;\r\n            }\r\n    }\r\n    /**\r\n     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\r\n     */\r\n    function AsetworkingPropertyid(address _OwnerAddress, bytes32 _propertyUniqueID)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(propertywhitelist_[_OwnerAddress][_propertyUniqueID] = true);\r\n            if(_OwnerAddress != msg.sender){\r\n                workingPropertyid_[_OwnerAddress] = _propertyUniqueID;\r\n                return true;\r\n            } else { \r\n                return false;\r\n            }\r\n    }\r\n    /**\r\n     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\r\n     */\r\n    function AsetworkingMintingRequest(address _OwnerAddress, bytes32 _mintingRequestUniqueid)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(mintrequestwhitelist_[_OwnerAddress][_mintingRequestUniqueid] = true);\r\n            if(_OwnerAddress != msg.sender){\r\n                workingMintRequestid_[_OwnerAddress] = _mintingRequestUniqueid;\r\n                return true;\r\n            } else { \r\n                return false;\r\n            }\r\n    }\r\n    /**\r\n     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\r\n     */\r\n    function Asetworkingburnrequestid(address _OwnerAddress, bytes32 _propertyUniqueID, uint256 _propertyValue)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n        returns(bytes32)\r\n    {\r\n        require(burnrequestwhitelist_[_OwnerAddress][_propertyUniqueID] = true);\r\n            if(_OwnerAddress != msg.sender){\r\n                workingPropertyid_[_OwnerAddress] = _propertyUniqueID;\r\n                numberofmintingrequestswhitelisted_[msg.sender] += 1;\r\n                emit PropertyValuation(msg.sender, _propertyUniqueID, _propertyValue);\r\n                return _propertyUniqueID;\r\n            } else { \r\n                numberofmintingrequestswhitelisted_[msg.sender] -= 1;\r\n                _propertyValue = 0;\r\n                return _propertyUniqueID;\r\n            }\r\n    }\r\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\r\n        uint8 i = 0;\r\n        while(i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n    function bStringToBytes32(string memory source) \r\n    public pure returns (bytes32 result) {\r\n    bytes memory tempEmptyStringTest = bytes(source);\r\n    if (tempEmptyStringTest.length == 0) {\r\n        return 0x0;\r\n    }\r\n\r\n    assembly {\r\n        result := mload(add(source, 32))\r\n    }\r\n}\r\n    /**\r\n     * Whitelist a Founder Developer ceva only\r\n     */\r\n    function AWhitelistFounderDeveloper(address _identifier, bool _status)\r\n        onlyCEVA(msg.sender)\r\n        public\r\n    {\r\n            founderdevelopers_[_identifier] = _status;\r\n            numberofburnrequestswhitelisted_[msg.sender] = 0;\r\n            numberofpropertieswhitelisted_[msg.sender] = 0;\r\n            numberofmintingrequestswhitelisted_[msg.sender] = 0;\r\n            emit FounderDeveloperWhitelisted(msg.sender, _identifier, _status);\r\n    }\r\n    /*----------  FOUNDER DEVELOPER ONLY FUNCTIONS  ----------*/\r\n    // Mint an amount of tokens to an address \r\n    // using a whitelisted minting request unique ID founder developer only\r\n    function _mint(uint256 _FounderDeveloperFee, address _toAddress, address _holdOne, address _holdTwo, address _holdThree, \r\n        uint256 _propertyValue, bytes32 _propertyUniqueID, bytes32 _mintingRequestUniqueid)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n    {\r\n        if(_propertyValue >= 100){\r\n        // data setup\r\n            uint256 _amountOfTokens = (_propertyValue * 1e18) / 100;\r\n            require(members_[_toAddress] == true && _FounderDeveloperFee >= 20001 && _FounderDeveloperFee <= 100000 && \r\n            (_amountOfTokens + tokenSupply_) > tokenSupply_ && msg.sender != _toAddress && _propertyUniqueID == workingPropertyid_[msg.sender]\r\n            && _mintingRequestUniqueid == workingMintRequestid_[msg.sender] && _propertyValue == propertyvalue_[_toAddress][_propertyUniqueID]);\r\n            // add tokens to the pool\r\n            tokenSupply_ = tokenSupply_ + _amountOfTokens;\r\n            updateHoldsandSupply(_amountOfTokens);\r\n            // add to burner stockpile\r\n            cevaBurnerStockpile_ += (_amountOfTokens / 16667) * 100;\r\n            // whoa fee\r\n            whoafeeBalanceLedger_ = whoafeeBalanceLedger_ + _amountOfTokens;\r\n            // credit founder developer fee\r\n            tokenBalanceLedger_[msg.sender] += (_amountOfTokens / _FounderDeveloperFee) * 1000;\r\n            //credit Envelope Fee Shareholds\r\n            creditFeeSharehold(_amountOfTokens, _toAddress, _holdOne, _holdTwo, _holdThree);\r\n            // credit tech feeSharehold_    ;\r\n            uint256 _TechFee = (_amountOfTokens / 25000) * 100;\r\n            techfeeBalanceLedger_ = techfeeBalanceLedger_ + _TechFee;\r\n            // fire event\r\n            // add tokens to the _toAddress \r\n            uint256 _cevabTransferfees = (_amountOfTokens / 333334) * 10000;\r\n            uint256 _Fee = (_amountOfTokens / _FounderDeveloperFee) * 1000;\r\n            tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress] + (_amountOfTokens - _cevabTransferfees);\r\n            tokenBalanceLedger_[_toAddress] -= _Fee;\r\n            tokenBalanceLedger_[_toAddress] -= _TechFee;\r\n            emit Transfer(msg.sender, _toAddress, _amountOfTokens);\r\n            mintingDepositsOf_[_toAddress] += _amountOfTokens;\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    function AworkingPropertyIDOf(address _user)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return workingPropertyid_[_user];\r\n    }\r\n    function AworkingBurnRequestIDOf(address _user)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return workingBurnRequestid_[_user];\r\n    }\r\n    function AworkingMintIDOf(address _user)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return workingMintRequestid_[_user];\r\n    }\r\n    /**\r\n     * whitelist a member founder developer only\r\n     */\r\n    function AWhitelistMember(address _identifier, bool _status)\r\n        onlyFounderDevelopers(msg.sender)\r\n        public\r\n    {\r\n        require(msg.sender != _identifier);\r\n            members_[_identifier] = _status;\r\n            emit MemberWhitelisted(msg.sender, _identifier, _status);\r\n    } \r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function TokensNoDecimals()\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens =  (balanceOf(_customerAddress) / 1e18);\r\n        if(_tokens >= 1){\r\n            return _tokens;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    function balanceOf(address _owner)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_owner];\r\n    }\r\n    function EtaxesdividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(taxesFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (taxesfeeBalanceLedger_ / taxesfeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * taxesFeeSharehold_[_customerAddress]) - \r\n            (taxesFeeTotalWithdrawn_[_customerAddress] + taxesPreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EtaxesShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        \r\n        if(taxesFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return taxesFeeSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  insurance dividend balance of any single address.\r\n     */\r\n    function EinsurancedividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(insuranceFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (insurancefeeBalanceLedger_ / insurancefeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * insuranceFeeSharehold_[_customerAddress]) - \r\n            (insuranceFeeTotalWithdrawn_[_customerAddress] + insurancePreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EinsuranceShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        \r\n        if(insuranceFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return insuranceFeeSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  maintenance dividend balance of any single address.\r\n     */\r\n    function EmaintenancedividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(maintenanceFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (maintenancefeeBalanceLedger_ / maintencancefeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * maintenanceFeeSharehold_[_customerAddress]) - \r\n            (maintenanceFeeTotalWithdrawn_[_customerAddress] + maintenancePreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EmaintenanceShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(maintenanceFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return maintenanceFeeSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  Wealth Architect ECO Register 1.2 dividend balance of any single address.\r\n     */\r\n    function EwaECOdividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(waECOFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (waECOfeeBalanceLedger_ / waECOfeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * waECOFeeSharehold_[_customerAddress]) - \r\n            (waECOFeeTotalWithdrawn_[_customerAddress] + waECOPreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n        }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EwaECOShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(waECOFeeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return waECOFeeSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the hold one dividend balance of any single address.\r\n     */\r\n    function EholdonedividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(holdoneSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (holdonefeeBalanceLedger_ / holdonefeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * holdoneSharehold_[_customerAddress]) - \r\n            (holdoneTotalWithdrawn_[_customerAddress] + holdonePreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EholdoneShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(holdoneSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return holdoneSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the hold two dividend balance of any single address.\r\n     */\r\n    function EholdtwodividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(holdtwoSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (holdtwofeeBalanceLedger_ / holdtwofeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * holdtwoSharehold_[_customerAddress]) -\r\n            (holdtwoTotalWithdrawn_[_customerAddress] + holdtwoPreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EholdtwoShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(holdtwoSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return holdtwoSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the hold three dividend balance of any single address.\r\n     */\r\n    function EholdthreedividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(holdthreeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (holdthreefeeBalanceLedger_ / holdthreefeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * holdthreeSharehold_[_customerAddress]) -\r\n            (holdthreeTotalWithdrawn_[_customerAddress] + holdthreePreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EholdthreeShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(holdthreeSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return holdthreeSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the rewards dividend balance of any single address.\r\n     */\r\n    function ErewardsdividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(rewardsSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (RewardsfeeBalanceLedger_ / RewardsfeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * rewardsSharehold_[_customerAddress]) -\r\n            (rewardsTotalWithdrawn_[_customerAddress] + rewardsPreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function ErewardsShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(rewardsSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return rewardsSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the tech dividend balance of any single address.\r\n     */\r\n    function EtechdividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(techfeeTotalHolds_ == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (techfeeBalanceLedger_ / techfeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * techSharehold_[_customerAddress]) -\r\n            (techTotalWithdrawn_[_customerAddress] + techPreviousWithdrawn_[_customerAddress])) /\r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EtechShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(techSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return techSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the exist holdings dividend balance of any single address.\r\n     */\r\n    function existholdingsdividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(existholdingsfeeTotalHolds_ == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (existholdingsfeeBalanceLedger_ / existholdingsfeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * existholdingsSharehold_[_customerAddress]) -\r\n            (existholdingsTotalWithdrawn_[_customerAddress] + existholdingsPreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function existholdingsShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        \r\n        if(existholdingsSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return existholdingsSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the exist crypto dividend balance of any single address.\r\n     */\r\n    function existcryptodividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(existcryptofeeTotalHolds_ == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (existcryptofeeBalanceLedger_ / existcryptofeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * existcryptoSharehold_[_customerAddress]) -\r\n            (existcryptoTotalWithdrawn_[_customerAddress] + existcryptoPreviousWithdrawn_[_customerAddress])) / \r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function existcryptoShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(existcryptoSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return existcryptoSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the Worldwide Home Owners Association dividend balance of any single address.\r\n     */\r\n    function EwhoadividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(whoafeeTotalHolds_ == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (whoafeeBalanceLedger_ / whoafeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * whoaSharehold_[_customerAddress]) -\r\n            (whoaTotalWithdrawn_[_customerAddress] + whoaPreviousWithdrawn_[_customerAddress])) /\r\n            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the WHOA dividend balance of any single address.\r\n     */\r\n    function EwhoaShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(whoaSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return whoaSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the Credible You dividend balance of any single address.\r\n     */\r\n    function EcredibleyoudividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        if(credibleyoufeeTotalHolds_ == 0){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = (credibleyoufeeBalanceLedger_ / credibleyoufeeTotalHolds_);\r\n            return (uint256) ((_dividendPershare * credibleyouSharehold_[_customerAddress]) -\r\n            (credibleyouTotalWithdrawn_[_customerAddress] + credibleyouPreviousWithdrawn_[_customerAddress]))\r\n            / calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\r\n            \r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the  taxes dividend balance of any single address.\r\n     */\r\n    function EcredibleyouShareholdOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        if(credibleyouSharehold_[_customerAddress] == 0){\r\n            return 0;\r\n        } else {\r\n            return credibleyouSharehold_[_customerAddress];\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the CEVA Burner Stockpile dividend balance using a CEVA whitelisted address.\r\n     */\r\n    function EcevaBurnerStockpileDividends()\r\n        onlyCEVA(msg.sender)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividendPershare;\r\n        address _customerAddress = msg.sender;\r\n        if(ceva_[_customerAddress] != true){\r\n            return 0;\r\n        } else {\r\n            _dividendPershare = cevaBurnerStockpile_;\r\n            return _dividendPershare;\r\n        }\r\n    }\r\n    \r\n    function totalSupply() \r\n        public \r\n        view\r\n        returns(uint256)\r\n    {\r\n            if(tokenSupply_ == 0){\r\n                return 0;\r\n            } else {\r\n            return tokenSupply_;}\r\n    }\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    /**\r\n     * Update token balance ledger of an address tokens from the caller to a new holder.\r\n     */\r\n    function updateHoldsandSupply(uint256 _amountOfTokens)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        tokenSupply_ = tokenSupply_ + _amountOfTokens;\r\n        taxesfeeTotalHolds_ = (_amountOfTokens / 1e18) + taxesfeeTotalHolds_;\r\n        insurancefeeTotalHolds_ = (_amountOfTokens / 1e18) + insurancefeeTotalHolds_;\r\n        maintencancefeeTotalHolds_ = (_amountOfTokens / 1e18) + maintencancefeeTotalHolds_;\r\n        waECOfeeTotalHolds_ = (_amountOfTokens / 1e18) + waECOfeeTotalHolds_;\r\n        holdonefeeTotalHolds_ = (_amountOfTokens / 1e18) + holdonefeeTotalHolds_;\r\n        holdtwofeeTotalHolds_ = (_amountOfTokens / 1e18) + holdtwofeeTotalHolds_;\r\n        holdthreefeeTotalHolds_ = (_amountOfTokens / 1e18) + holdthreefeeTotalHolds_;\r\n        RewardsfeeTotalHolds_ = (_amountOfTokens / 1e18) + RewardsfeeTotalHolds_;\r\n        techfeeTotalHolds_ = (_amountOfTokens / 1e18) + techfeeTotalHolds_;\r\n        existholdingsfeeTotalHolds_ = (_amountOfTokens / 1e18) + existholdingsfeeTotalHolds_;\r\n        existcryptofeeTotalHolds_ = (_amountOfTokens / 1e18) + existcryptofeeTotalHolds_;\r\n        whoafeeTotalHolds_ = (_amountOfTokens / 1e18) + whoafeeTotalHolds_;\r\n        credibleyoufeeTotalHolds_= (_amountOfTokens / 1e18) + credibleyoufeeTotalHolds_;\r\n        feeTotalHolds_ = ((_amountOfTokens / 1e18)* 13) + feeTotalHolds_;\r\n        return true;\r\n    }\r\n    /**\r\n     * Update token balance ledger of an address tokens from the caller to a new holder.\r\n     * Remember, there's a fee here as well.\r\n     */\r\n    function burnA(uint256 _amount)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint256 _pValue = _amount / 100;\r\n        if(_amount > 0){\r\n            RewardsfeeTotalHolds_ -= _pValue;\r\n            techfeeTotalHolds_ -= _pValue;\r\n            existholdingsfeeTotalHolds_ -= _pValue;\r\n            existcryptofeeTotalHolds_ -= _pValue;\r\n            whoafeeTotalHolds_-= _pValue;\r\n            credibleyoufeeTotalHolds_ -= _pValue;\r\n            feeTotalHolds_ -= _pValue;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        } \r\n    }\r\n    /**\r\n     * calculate 2% total transfer fee based on _amountOfTokens\r\n     */\r\n    function calulateAmountQualified(uint256 _TokenMintingDepositsOf, uint256 _AmountCirculated)\r\n        internal\r\n        pure\r\n        returns(uint256 _AmountQualified)\r\n    {\r\n        _AmountQualified = _TokenMintingDepositsOf / _AmountCirculated;\r\n        if(_AmountQualified <= 1){\r\n            _AmountQualified = 1;\r\n            return _AmountQualified;\r\n        } else {\r\n            return _AmountQualified;\r\n        }\r\n    }\r\n    function updateEquityRents(uint256 _amountOfTokens)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        if(_amountOfTokens < 0){\r\n            _amountOfTokens = 0;\r\n            return false;\r\n        } else {\r\n            taxesfeeBalanceLedger_ = taxesfeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            insurancefeeBalanceLedger_ = insurancefeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            maintenancefeeBalanceLedger_ = maintenancefeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            waECOfeeBalanceLedger_ = waECOfeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            holdonefeeBalanceLedger_ = holdonefeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            holdtwofeeBalanceLedger_ = holdtwofeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            holdthreefeeBalanceLedger_ = holdthreefeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            RewardsfeeBalanceLedger_ = RewardsfeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            techfeeBalanceLedger_ = techfeeBalanceLedger_ + ((_amountOfTokens / 25000) * 100);\r\n            existholdingsfeeBalanceLedger_ = existholdingsfeeBalanceLedger_ + (_amountOfTokens / 445);\r\n            existcryptofeeBalanceLedger_ = existcryptofeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            whoafeeBalanceLedger_ = whoafeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            credibleyoufeeBalanceLedger_ = credibleyoufeeBalanceLedger_ + (_amountOfTokens / 800);\r\n            return true;\r\n        } \r\n    }\r\n    /**\r\n     * Update taxes fee sharehold of an address..\r\n     */\r\n    function creditTaxesFeeSharehold(uint256 _amountOfTokens,  address _toAddress)\r\n        internal\r\n    {\r\n        taxesFeeSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update insurance fee sharehold of an address..\r\n     */\r\n    function creditInsuranceFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        insuranceFeeSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update maintenance fee sharehold of an address..\r\n     */\r\n    function creditMaintenanceFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        maintenanceFeeSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Wealth Architect fee sharehold of an address..\r\n     */\r\n    function creditwaECOFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        waECOFeeSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update hold one fee sharehold of an address..\r\n     */\r\n    function creditHoldOneFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        holdoneSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update hold two fee sharehold of an address..\r\n     */\r\n    function creditHoldTwoFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        holdtwoSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update hold three fee sharehold of an address..\r\n     */\r\n    function creditHoldThreeFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        holdthreeSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Rewards fee sharehold of an address..\r\n     */\r\n    function creditRewardsFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        rewardsSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Tech fee sharehold of an address..\r\n     */\r\n    function creditTechFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        techSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Exist Holdings fee sharehold of an address..\r\n     */\r\n    function creditExistHoldingsFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        existholdingsSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Exist Crypto fee sharehold of an address..\r\n     */\r\n    function creditExistCryptoFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        existcryptoSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update WHOA fee sharehold of an address..\r\n     */\r\n    function creditWHOAFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        whoaSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Credible You fee sharehold of an address..\r\n     */\r\n    function creditCredibleYouFeeSharehold(uint256 _amountOfTokens, address _toAddress)\r\n        internal\r\n    {\r\n        credibleyouSharehold_[_toAddress] += _amountOfTokens;\r\n    }\r\n    /**\r\n     * Update Exist Holdings fee sharehold of an address..\r\n     */\r\n    function creditFeeSharehold(uint256 _amountOfTokens, address _owner, address _toAddress, address _toAddresstwo, address _toAddressthree)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        creditTaxesFeeSharehold((_amountOfTokens / 1e18), _owner);\r\n        creditInsuranceFeeSharehold((_amountOfTokens / 1e18), _owner);\r\n        creditMaintenanceFeeSharehold((_amountOfTokens / 1e18), whoamaintenanceaddress_);\r\n        creditwaECOFeeSharehold((_amountOfTokens / 1e18), _owner);\r\n        creditHoldOneFeeSharehold((_amountOfTokens / 1e18), _toAddress);\r\n        creditHoldTwoFeeSharehold((_amountOfTokens / 1e18), _toAddresstwo);\r\n        creditHoldThreeFeeSharehold((_amountOfTokens / 1e18), _toAddressthree);\r\n        creditRewardsFeeSharehold((_amountOfTokens / 1e18), whoarewardsaddress_);\r\n        creditTechFeeSharehold((_amountOfTokens / 1e18), techaddress_);\r\n        creditExistHoldingsFeeSharehold((_amountOfTokens / 1e18), existholdingsaddress_);\r\n        creditExistCryptoFeeSharehold((_amountOfTokens / 1e18), existcryptoaddress_);\r\n        creditWHOAFeeSharehold((_amountOfTokens / 1e18), whoaaddress_);\r\n        creditCredibleYouFeeSharehold((_amountOfTokens / 1e18), credibleyouaddress_);\r\n        return true;\r\n    }\r\n    //This is where all your gas goes, sorry\r\n    //Not sorry, you probably only paid 1 gwei\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"}],\"name\":\"AdminWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"propertyValue\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"}],\"name\":\"CEVAWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"}],\"name\":\"FounderDeveloperWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"}],\"name\":\"MemberWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"propertyValue\",\"type\":\"uint256\"}],\"name\":\"PropertyValuation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"}],\"name\":\"PropertyWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"AWhitelistFounderDeveloper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"AWhitelistMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_propertyValue\",\"type\":\"uint256\"}],\"name\":\"AsetWhitelistedPropertyValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_mintingRequestUniqueid\",\"type\":\"bytes32\"}],\"name\":\"AsetworkingMintingRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"}],\"name\":\"AsetworkingPropertyid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_propertyValue\",\"type\":\"uint256\"}],\"name\":\"Asetworkingburnrequestid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"AwhitelistAdministrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_burnrequestUniqueID\",\"type\":\"bytes32\"}],\"name\":\"AwhitelistBurnRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"AwhitelistCEVA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_mintingRequestUniqueid\",\"type\":\"bytes32\"}],\"name\":\"AwhitelistMintRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_OwnerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_trueFalse\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"}],\"name\":\"AwhitelistProperty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AworkingBurnRequestIDOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AworkingMintIDOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AworkingPropertyIDOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EcevaBurnerStockpileDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EcredibleyouShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EcredibleyoudividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EholdoneShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EholdonedividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EholdthreeShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EholdthreedividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EholdtwoShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EholdtwodividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EinsuranceShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EinsurancedividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EmaintenanceShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EmaintenancedividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"ErewardsShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"ErewardsdividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EtaxesShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EtaxesdividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EtechShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EtechdividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EwaECOShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EwaECOdividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EwhoaShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"EwhoadividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokensNoDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_FounderDeveloperFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holdOne\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holdTwo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holdThree\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_propertyValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_propertyUniqueID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_mintingRequestUniqueid\",\"type\":\"bytes32\"}],\"name\":\"_mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"}],\"name\":\"bStringToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_FounderDeveloperOne\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_FounderDeveloperTwo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CEVA\",\"type\":\"address\"}],\"name\":\"buyFounderDeveloperLicense\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"}],\"name\":\"checkAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"}],\"name\":\"checkCEVA\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"}],\"name\":\"checkFounderDeveloper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"}],\"name\":\"checkMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_propertyValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_clearFrom\",\"type\":\"address\"}],\"name\":\"clearTitle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"existcryptoShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"existcryptodividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"existholdingsShareholdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"existholdingsdividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTotalHolds_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existcryptoaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_existhooldingsaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_techaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_credibleyouaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cevaaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whoaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whoarewardsaddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whoamaintenanceaddress\",\"type\":\"address\"}],\"name\":\"genesis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellCredibleYouFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellExistCryptoFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellExistHoldingsFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellHoldOneFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellHoldThreeFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellHoldTwoFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellInsuranceFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellMaintenanceFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellRewardsFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellTaxesFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellTechFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellWHOAFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellwaECOFeeSharehold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSupply_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawCEVABurnerStockpiledividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCrediblelYoudividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawExistCryptodividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawExistHoldingsdividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawHoldOnedividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawHoldThreeedividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawHoldTwodividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawInsurancedividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMaintenancedividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewardsdividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTaxesdividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTechdividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawWHOAdividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawwaECOdividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AVEC","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f0b1f68da5c60137f8337d539b8b3eaf45aef77c641e0f1eeccb185cefe6d191"}]}