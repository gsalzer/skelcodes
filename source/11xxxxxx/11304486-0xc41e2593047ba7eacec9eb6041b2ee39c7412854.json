{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n// this contract gives owner the ability to allow tokens. for pairs in which both tokens are allowed, fees may be\r\n// collected on that pair and send to feeRecipient, though only after burning all fees up to that point\r\ncontract EliteFeeTo {\r\n    address public owner;\r\n    address public feeRecipient;\r\n\r\n    struct TokenAllowState {\r\n        bool    allowed;\r\n        uint128 disallowCount;\r\n    }\r\n    mapping(address => TokenAllowState) public tokenAllowStates;\r\n\r\n    struct PairAllowState {\r\n        uint128 token0DisallowCount;\r\n        uint128 token1DisallowCount;\r\n    }\r\n    mapping(address => PairAllowState) public pairAllowStates;\r\n\r\n    constructor(address owner_) public {\r\n        owner = owner_;\r\n    }\r\n\r\n    function setOwner(address owner_) public {\r\n        require(msg.sender == owner, 'EliteFeeTo::setOwner: not allowed');\r\n        owner = owner_;\r\n    }\r\n\r\n    function setFeeRecipient(address feeRecipient_) public {\r\n        require(msg.sender == owner, 'EliteFeeTo::setFeeRecipient: not allowed');\r\n        feeRecipient = feeRecipient_;\r\n    }\r\n\r\n    function updateTokenAllowState(address token, bool allowed) public {\r\n        require(msg.sender == owner, 'EliteFeeTo::updateTokenAllowState: not allowed');\r\n        TokenAllowState storage tokenAllowState = tokenAllowStates[token];\r\n        // if allowed is not changing, the function is a no-op\r\n        if (allowed != tokenAllowState.allowed) {\r\n            tokenAllowState.allowed = allowed;\r\n            // this condition will only be true on the first call to this function (regardless of the value of allowed)\r\n            // by effectively initializing disallowCount to 1,\r\n            // we force renounce to be called for all pairs including newly allowed token\r\n            if (tokenAllowState.disallowCount == 0) {\r\n                tokenAllowState.disallowCount = 1;\r\n            } else if (allowed == false) {\r\n                tokenAllowState.disallowCount += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateTokenAllowStates(address[] memory tokens, bool allowed) public {\r\n        for (uint i; i < tokens.length; i++) {\r\n            updateTokenAllowState(tokens[i], allowed);\r\n        }\r\n    }\r\n\r\n    function renounce(address pair) public returns (uint value) {\r\n        PairAllowState storage pairAllowState = pairAllowStates[pair];\r\n        TokenAllowState storage token0AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token0()];\r\n        TokenAllowState storage token1AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token1()];\r\n\r\n        // we must renounce if any of the following four conditions are true:\r\n        // 1) token0 is currently disallowed\r\n        // 2) token1 is currently disallowed\r\n        // 3) token0 was disallowed at least once since the last time renounce was called\r\n        // 4) token1 was disallowed at least once since the last time renounce was called\r\n        if (\r\n            token0AllowState.allowed == false ||\r\n            token1AllowState.allowed == false ||\r\n            token0AllowState.disallowCount > pairAllowState.token0DisallowCount ||\r\n            token1AllowState.disallowCount > pairAllowState.token1DisallowCount\r\n        ) {\r\n            value = IEliteswapV2Pair(pair).balanceOf(address(this));\r\n            if (value > 0) {\r\n                // burn balance into the pair, effectively redistributing underlying tokens pro-rata back to LPs\r\n                // (assert because transfer cannot fail with value as balanceOf)\r\n                assert(IEliteswapV2Pair(pair).transfer(pair, value));\r\n                IEliteswapV2Pair(pair).burn(pair);\r\n            }\r\n\r\n            // if token0 is allowed, we can now update the pair's disallow count to match the token's\r\n            if (token0AllowState.allowed) {\r\n                pairAllowState.token0DisallowCount = token0AllowState.disallowCount;\r\n            }\r\n            // if token1 is allowed, we can now update the pair's disallow count to match the token's\r\n            if (token1AllowState.allowed) {\r\n                pairAllowState.token1DisallowCount = token1AllowState.disallowCount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function claim(address pair) public returns (uint value) {\r\n        PairAllowState storage pairAllowState = pairAllowStates[pair];\r\n        TokenAllowState storage token0AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token0()];\r\n        TokenAllowState storage token1AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token1()];\r\n\r\n        // we may claim only if each of the following five conditions are true:\r\n        // 1) token0 is currently allowed\r\n        // 2) token1 is currently allowed\r\n        // 3) renounce was not called since the last time token0 was disallowed\r\n        // 4) renounce was not called since the last time token1 was disallowed\r\n        // 5) feeHandler is not the 0 address\r\n        if (\r\n            token0AllowState.allowed &&\r\n            token1AllowState.allowed &&\r\n            token0AllowState.disallowCount == pairAllowState.token0DisallowCount &&\r\n            token1AllowState.disallowCount == pairAllowState.token1DisallowCount &&\r\n            feeRecipient != address(0)\r\n        ) {\r\n            value = IEliteswapV2Pair(pair).balanceOf(address(this));\r\n            if (value > 0) {\r\n                // transfer tokens to the handler (assert because transfer cannot fail with value as balanceOf)\r\n                assert(IEliteswapV2Pair(pair).transfer(feeRecipient, value));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IEliteswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairAllowStates\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"token0DisallowCount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"token1DisallowCount\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"renounce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient_\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAllowStates\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"disallowCount\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateTokenAllowState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateTokenAllowStates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EliteFeeTo","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000003ce6feac2dc11a8799dc2a4b9434c5943e1c69ee","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://293692b8b2d00bf119d9edb1f7ca6f35b1f0d8ea5e78709d56d23b2c8e925a26"}]}