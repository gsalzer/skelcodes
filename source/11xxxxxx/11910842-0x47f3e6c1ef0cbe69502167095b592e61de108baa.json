{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ONX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./modules/Configable.sol\\\";\\nimport \\\"./modules/ConfigNames.sol\\\";\\nimport \\\"./modules/BaseMintField.sol\\\";\\nimport \\\"./libraries/Configurable.sol\\\";\\n\\ninterface IONXStrategy {\\n\\tfunction invest(address user, uint256 amount) external;\\n\\tfunction withdraw(address user, uint256 amount) external;\\n\\tfunction liquidation(address user) external;\\n\\tfunction claim(address user, uint256 amount, uint256 total) external;\\n\\tfunction query() external view returns (uint256);\\n\\tfunction mint() external;\\n\\tfunction interestToken() external view returns (address);\\n\\tfunction farmToken() external view returns (address);\\n}\\n\\ncontract ONXPool is BaseMintField, Configurable {\\n\\tusing SafeMath for uint256;\\n\\n\\taddress public factory;\\n\\taddress public supplyToken;\\n\\taddress public collateralToken;\\n\\n\\t// SupplyStruct\\n\\tbytes32 constant _amountSupply_SS = \\\"SS#amountSupply\\\";\\n\\tbytes32 constant _interestSettled_SS = \\\"SS#interestSettled\\\";\\n\\tbytes32 constant _liquidationSettled_SS = \\\"SS#liquidationSettled\\\";\\n\\tbytes32 constant _interests_SS = \\\"SS#interests\\\";\\n\\tbytes32 constant _liquidation_SS = \\\"SS#liquidation\\\";\\n\\n\\t// BorrowStruct\\n\\tbytes32 constant _index_BS = \\\"BS#index\\\";\\n\\tbytes32 constant _amountCollateral_BS = \\\"BS#amountCollateral\\\";\\n\\tbytes32 constant _interestSettled_BS = \\\"BS#interestSettled\\\";\\n\\tbytes32 constant _amountBorrow_BS = \\\"BS#amountBorrow\\\";\\n\\tbytes32 constant _interests_BS = \\\"BS#interests\\\";\\n\\n\\t// LiquidationStruct\\n\\tbytes32 constant _amountCollateral_LS = \\\"LS#amountCollateral\\\";\\n\\tbytes32 constant _liquidationAmount_LS = \\\"LS#liquidationAmount\\\";\\n\\tbytes32 constant _timestamp_LS = \\\"LS#timestamp\\\";\\n\\tbytes32 constant _length_LS = \\\"LS#length\\\";\\n\\n\\taddress[] public borrowerList;\\n\\tuint256 public numberBorrowers;\\n\\n\\tmapping(address => uint256) public liquidationHistoryLength;\\n\\n\\tuint256 public interestPerSupply;\\n\\tuint256 public liquidationPerSupply;\\n\\tuint256 public interestPerBorrow;\\n\\n\\tuint256 public totalLiquidation;\\n\\tuint256 public totalLiquidationSupplyAmount;\\n\\n\\tuint256 public totalStake;\\n\\tuint256 public totalBorrow;\\n\\tuint256 public totalPledge;\\n\\n\\tuint256 public remainSupply;\\n\\n\\tuint256 public lastInterestUpdate;\\n\\n\\taddress public collateralStrategy;\\n\\taddress public supplyStrategy;\\n\\n\\tuint256 public payoutRatio;\\n\\n\\tevent Deposit(address indexed _user, uint256 _amount, uint256 _collateralAmount);\\n\\tevent Withdraw(address indexed _user, uint256 _supplyAmount, uint256 _collateralAmount, uint256 _interestAmount);\\n\\tevent Borrow(address indexed _user, uint256 _supplyAmount, uint256 _collateralAmount);\\n\\tevent Repay(address indexed _user, uint256 _supplyAmount, uint256 _collateralAmount, uint256 _interestAmount);\\n\\tevent Liquidation(\\n\\t\\taddress indexed _liquidator,\\n\\t\\taddress indexed _user,\\n\\t\\tuint256 _supplyAmount,\\n\\t\\tuint256 _collateralAmount\\n\\t);\\n\\tevent Reinvest(address indexed _user, uint256 _reinvestAmount);\\n\\n\\tfunction initialize(address _factory) external initializer\\n\\t{\\n\\t\\towner = _factory;\\n\\t\\tfactory = _factory;\\n\\t}\\n\\n\\tfunction setCollateralStrategy(address _collateralStrategy, address _supplyStrategy) external onlyPlatform\\n\\t{\\n\\t\\tcollateralStrategy = _collateralStrategy;\\n\\t\\tsupplyStrategy = _supplyStrategy;\\n\\t}\\n\\n\\tfunction init(address _supplyToken, address _collateralToken) external onlyFactory {\\n\\t\\tsupplyToken = _supplyToken;\\n\\t\\tcollateralToken = _collateralToken;\\n\\n\\t\\tlastInterestUpdate = block.number;\\n\\t}\\n\\n\\tfunction updateInterests(bool isPayout) internal {\\n\\t\\tuint256 totalSupply = totalBorrow + remainSupply;\\n\\t\\t(uint256 supplyInterestPerBlock, uint256 borrowInterestPerBlock) = getInterests();\\n\\n\\t\\tinterestPerSupply = interestPerSupply.add(\\n\\t\\t\\ttotalSupply == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: supplyInterestPerBlock.mul(block.number - lastInterestUpdate).mul(totalBorrow).div(totalSupply)\\n\\t\\t);\\n\\t\\tinterestPerBorrow = interestPerBorrow.add(borrowInterestPerBlock.mul(block.number - lastInterestUpdate));\\n\\t\\tlastInterestUpdate = block.number;\\n\\n\\t\\tif (isPayout == true) {\\n\\t\\t\\tpayoutRatio = borrowInterestPerBlock == 0\\n\\t\\t\\t\\t? 0\\n\\t\\t\\t\\t: (borrowInterestPerBlock.sub(supplyInterestPerBlock)).mul(1e18).div(borrowInterestPerBlock);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getInterests() public view returns (uint256 supplyInterestPerBlock, uint256 borrowInterestPerBlock) {\\n\\t\\tuint256 totalSupply = totalBorrow + remainSupply;\\n\\t\\tuint256 baseInterests = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_BASE_INTERESTS);\\n\\t\\tuint256 marketFrenzy = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MARKET_FRENZY);\\n\\t\\tuint256 aDay = IConfig(config).DAY();\\n\\t\\tborrowInterestPerBlock = totalSupply == 0\\n\\t\\t? 0\\n\\t\\t: baseInterests.add(totalBorrow.mul(marketFrenzy).div(totalSupply)).div(365 * aDay);\\n\\n\\t\\tif (supplyToken == IConfig(config).WETH()) {\\n\\t\\t\\tbaseInterests = 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsupplyInterestPerBlock = totalSupply == 0\\n\\t\\t? 0\\n\\t\\t: baseInterests.add(totalBorrow.mul(marketFrenzy).div(totalSupply)).div(365 * aDay);\\n\\t}\\n\\n\\tfunction updateLiquidation(uint256 _liquidation) internal {\\n\\t\\tuint256 totalSupply = totalBorrow + remainSupply;\\n\\t\\tliquidationPerSupply = liquidationPerSupply.add(totalSupply == 0 ? 0 : _liquidation.mul(1e18).div(totalSupply));\\n\\t}\\n\\n\\tfunction deposit(uint256 amountDeposit, address from) public onlyPlatform {\\n\\t\\trequire(amountDeposit > 0, \\\"ONX: INVALID AMOUNT\\\");\\n\\t\\tuint256 amountIn = IERC20(supplyToken).balanceOf(address(this)).sub(remainSupply);\\n\\t\\trequire(amountIn >= amountDeposit, \\\"ONX: INVALID AMOUNT\\\");\\n\\n\\t\\tupdateInterests(false);\\n\\n\\t\\tuint256 addLiquidation =\\n\\t\\tliquidationPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18).sub(getConfig(_liquidationSettled_SS, from));\\n\\n\\t\\t_setConfig(_interests_SS, from, getConfig(_interests_SS, from).add(\\n\\t\\t\\t\\tinterestPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18).sub(getConfig(_interestSettled_SS, from))\\n\\t\\t\\t));\\n\\n\\t\\t_setConfig(_liquidation_SS, from, getConfig(_liquidation_SS, from).add(addLiquidation));\\n\\n\\t\\t_setConfig(_amountSupply_SS, from, getConfig(_amountSupply_SS, from).add(amountDeposit));\\n\\t\\tremainSupply = remainSupply.add(amountDeposit);\\n\\n\\t\\ttotalStake = totalStake.add(amountDeposit);\\n\\n\\t\\tif(supplyStrategy != address(0) &&\\n\\t\\t\\taddress(IERC20(IONXStrategy(supplyStrategy).farmToken())) != address(0) &&\\n\\t\\t\\tamountDeposit > 0)\\n\\t\\t{\\n\\t\\t\\tIERC20(IONXStrategy(supplyStrategy).farmToken()).approve(supplyStrategy, amountDeposit);\\n\\t\\t\\tIONXStrategy(supplyStrategy).invest(from, amountDeposit);\\n\\t\\t}\\n\\n\\t\\t_increaseLenderProductivity(from, amountDeposit);\\n\\n\\t\\t_setConfig(_interestSettled_SS, from, interestPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18));\\n\\t\\t_setConfig(_liquidationSettled_SS, from, liquidationPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18));\\n\\t\\temit Deposit(from, amountDeposit, addLiquidation);\\n\\t}\\n\\n\\tfunction reinvest(address from) public onlyPlatform returns (uint256 reinvestAmount) {\\n\\t\\tupdateInterests(false);\\n\\n\\t\\tuint256 addLiquidation =\\n\\t\\tliquidationPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18).sub(getConfig(_liquidationSettled_SS, from));\\n\\n\\t\\t_setConfig(_interests_SS, from, getConfig(_interests_SS, from).add(\\n\\t\\t\\t\\tinterestPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18).sub(getConfig(_interestSettled_SS, from))\\n\\t\\t\\t));\\n\\n\\t\\t_setConfig(_liquidation_SS, from, getConfig(_liquidation_SS, from).add(addLiquidation));\\n\\n\\t\\treinvestAmount = getConfig(_interests_SS, from);\\n\\n\\t\\t_setConfig(_amountSupply_SS, from, getConfig(_amountSupply_SS, from).add(reinvestAmount));\\n\\n\\t\\ttotalStake = totalStake.add(reinvestAmount);\\n\\n\\t\\t_setConfig(_interests_SS, from, 0);\\n\\n\\t\\t_setConfig(_interestSettled_SS, from, getConfig(_amountSupply_SS, from) == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: interestPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18));\\n\\n\\t\\t_setConfig(_liquidationSettled_SS, from, getConfig(_amountSupply_SS, from) == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: liquidationPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18));\\n\\n\\t\\tif (reinvestAmount > 0) {\\n\\t\\t\\t_increaseLenderProductivity(from, reinvestAmount);\\n\\t\\t}\\n\\n\\t\\temit Reinvest(from, reinvestAmount);\\n\\t}\\n\\n\\tfunction withdraw(uint256 amountWithdraw, address from)\\n\\tpublic\\n\\tonlyPlatform\\n\\treturns (uint256 withdrawSupplyAmount, uint256 withdrawLiquidation)\\n\\t{\\n\\t\\trequire(amountWithdraw > 0, \\\"ONX: INVALID AMOUNT TO WITHDRAW\\\");\\n\\t\\trequire(amountWithdraw <= getConfig(_amountSupply_SS, from), \\\"ONX: NOT ENOUGH BALANCE\\\");\\n\\n\\t\\tupdateInterests(false);\\n\\n\\t\\tuint256 addLiquidation =\\n\\t\\tliquidationPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18).sub(getConfig(_liquidationSettled_SS, from));\\n\\n\\t\\t_setConfig(_interests_SS, from, getConfig(_interests_SS, from).add(\\n\\t\\t\\t\\tinterestPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18).sub(getConfig(_interestSettled_SS, from))\\n\\t\\t\\t));\\n\\n\\t\\t_setConfig(_liquidation_SS, from, getConfig(_liquidation_SS, from).add(addLiquidation));\\n\\n\\t\\twithdrawLiquidation = getConfig(_liquidation_SS, from).mul(amountWithdraw).div(getConfig(_amountSupply_SS, from));\\n\\t\\tuint256 withdrawInterest = getConfig(_interests_SS, from).mul(amountWithdraw).div(getConfig(_amountSupply_SS, from));\\n\\n\\t\\tuint256 withdrawLiquidationSupplyAmount =\\n\\t\\ttotalLiquidation == 0 ? 0 : withdrawLiquidation.mul(totalLiquidationSupplyAmount).div(totalLiquidation);\\n\\n\\t\\tif (withdrawLiquidationSupplyAmount < amountWithdraw.add(withdrawInterest))\\n\\t\\t\\twithdrawSupplyAmount = amountWithdraw.add(withdrawInterest).sub(withdrawLiquidationSupplyAmount);\\n\\n\\t\\trequire(withdrawSupplyAmount <= remainSupply, \\\"ONX: NOT ENOUGH POOL BALANCE\\\");\\n\\t\\trequire(withdrawLiquidation <= totalLiquidation, \\\"ONX: NOT ENOUGH LIQUIDATION\\\");\\n\\n\\t\\tremainSupply = remainSupply.sub(withdrawSupplyAmount);\\n\\t\\ttotalLiquidation = totalLiquidation.sub(withdrawLiquidation);\\n\\t\\ttotalLiquidationSupplyAmount = totalLiquidationSupplyAmount.sub(withdrawLiquidationSupplyAmount);\\n\\t\\ttotalPledge = totalPledge.sub(withdrawLiquidation);\\n\\n\\t\\tif(supplyStrategy != address(0) &&\\n\\t\\taddress(IERC20(IONXStrategy(supplyStrategy).farmToken())) != address(0) &&\\n\\t\\tamountWithdraw > 0)\\n\\t\\t{\\t\\t\\t\\n\\t\\t\\tIONXStrategy(supplyStrategy).withdraw(from, amountWithdraw);\\n\\t\\t\\tTransferHelper.safeTransfer(IONXStrategy(supplyStrategy).farmToken(), msg.sender, amountWithdraw);\\n\\t\\t}\\n\\n\\t\\t_setConfig(_interests_SS, from, getConfig(_interests_SS, from).sub(withdrawInterest));\\n\\t\\t_setConfig(_liquidation_SS, from, getConfig(_liquidation_SS, from).sub(withdrawLiquidation));\\n\\t\\t_setConfig(_amountSupply_SS, from, getConfig(_amountSupply_SS, from).sub(amountWithdraw));\\n\\n\\t\\ttotalStake = totalStake.sub(amountWithdraw);\\n\\n\\t\\t_setConfig(_interestSettled_SS, from, getConfig(_amountSupply_SS, from) == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: interestPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18));\\n\\n\\t\\t_setConfig(_liquidationSettled_SS, from, getConfig(_amountSupply_SS, from) == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: liquidationPerSupply.mul(getConfig(_amountSupply_SS, from)).div(1e18));\\n\\n\\t\\tif (withdrawSupplyAmount > 0) {\\n\\t\\t\\tTransferHelper.safeTransfer(supplyToken, msg.sender, withdrawSupplyAmount);\\n\\t\\t}\\n\\n\\t\\t_decreaseLenderProductivity(from, amountWithdraw);\\n\\n\\t\\tif (withdrawLiquidation > 0) {\\n\\t\\t\\tif(collateralStrategy != address(0))\\n\\t\\t\\t{\\n\\t\\t\\t\\tIONXStrategy(collateralStrategy).claim(from, withdrawLiquidation, totalLiquidation.add(withdrawLiquidation));\\n\\t\\t\\t}\\n\\t\\t\\tTransferHelper.safeTransfer(collateralToken, msg.sender, withdrawLiquidation);\\n\\t\\t}\\n\\n\\t\\temit Withdraw(from, withdrawSupplyAmount, withdrawLiquidation, withdrawInterest);\\n\\t}\\n\\n\\tfunction borrow(\\n\\t\\tuint256 amountCollateral,\\n\\t\\tuint256 repayAmount,\\n\\t\\tuint256 expectBorrow,\\n\\t\\taddress from\\n\\t) public onlyPlatform {\\n\\t\\tuint256 amountIn = IERC20(collateralToken).balanceOf(address(this));\\n\\t\\tif(collateralStrategy == address(0))\\n\\t\\t{\\n\\t\\t\\tamountIn = amountIn.sub(totalPledge);\\n\\t\\t}\\n\\n\\t\\trequire(amountCollateral <= amountIn , \\\"ONX: INVALID AMOUNT\\\");\\n\\n\\t\\tupdateInterests(false);\\n\\n\\t\\tuint256 pledgeRate = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_PLEDGE_RATE);\\n\\t\\tuint256 maxAmount =\\n\\t\\tIConfig(config).convertTokenAmount(\\n\\t\\t\\tcollateralToken,\\n\\t\\t\\tsupplyToken,\\n\\t\\t\\tgetConfig(_amountCollateral_BS, from).add(amountCollateral)\\n\\t\\t);\\n\\n\\t\\tuint256 maximumBorrow = maxAmount.mul(pledgeRate).div(1e18);\\n\\t\\t// uint repayAmount = getRepayAmount(getConfig(_amountCollateral_BS, from), from);\\n\\n\\t\\trequire(repayAmount + expectBorrow <= maximumBorrow, \\\"ONX: EXCEED MAX ALLOWED\\\");\\n\\t\\trequire(expectBorrow <= remainSupply, \\\"ONX: INVALID BORROW\\\");\\n\\n\\t\\ttotalBorrow = totalBorrow.add(expectBorrow);\\n\\t\\ttotalPledge = totalPledge.add(amountCollateral);\\n\\t\\tremainSupply = remainSupply.sub(expectBorrow);\\n\\n\\t\\tif(collateralStrategy != address(0) && amountCollateral > 0)\\n\\t\\t{\\n\\t\\t\\tIERC20(IONXStrategy(collateralStrategy).farmToken()).approve(collateralStrategy, amountCollateral);\\n\\t\\t\\tIONXStrategy(collateralStrategy).invest(from, amountCollateral);\\n\\t\\t}\\n\\n\\t\\tif (getConfig(_index_BS, from) == 0) {\\n\\t\\t\\tborrowerList.push(from);\\n\\t\\t\\t_setConfig(_index_BS, from, borrowerList.length);\\n\\t\\t\\tnumberBorrowers++;\\n\\t\\t}\\n\\n\\t\\t_setConfig(_interests_BS, from, getConfig(_interests_BS, from).add(\\n\\t\\t\\t\\tinterestPerBorrow.mul(getConfig(_amountBorrow_BS, from)).div(1e18).sub(getConfig(_interestSettled_BS, from))\\n\\t\\t\\t));\\n\\t\\t_setConfig(_amountCollateral_BS, from, getConfig(_amountCollateral_BS, from).add(amountCollateral));\\n\\t\\t_setConfig(_amountBorrow_BS, from, getConfig(_amountBorrow_BS, from).add(expectBorrow));\\n\\t\\t_setConfig(_interestSettled_BS, from, interestPerBorrow.mul(getConfig(_amountBorrow_BS, from)).div(1e18));\\n\\n\\t\\tif (expectBorrow > 0) {\\n\\t\\t\\tTransferHelper.safeTransfer(supplyToken, msg.sender, expectBorrow);\\n\\t\\t\\t_increaseBorrowerProductivity(from, expectBorrow);\\n\\t\\t}\\n\\n\\t\\temit Borrow(from, expectBorrow, amountCollateral);\\n\\t}\\n\\n\\tfunction repay(uint256 amountCollateral, address from)\\n\\tpublic\\n\\tonlyPlatform\\n\\treturns (uint256 repayAmount, uint256 payoutInterest)\\n\\t{\\n\\t\\trequire(amountCollateral <= getConfig(_amountCollateral_BS, from), \\\"ONX: NOT ENOUGH COLLATERAL\\\");\\n\\t\\trequire(amountCollateral > 0, \\\"ONX: INVALID AMOUNT TO REPAY\\\");\\n\\n\\t\\tuint256 amountIn = IERC20(supplyToken).balanceOf(address(this)).sub(remainSupply);\\n\\n\\t\\tupdateInterests(true);\\n\\n\\t\\t_setConfig(_interests_BS, from, getConfig(_interests_BS, from).add(\\n\\t\\t\\t\\tinterestPerBorrow.mul(getConfig(_amountBorrow_BS, from)).div(1e18).sub(getConfig(_interestSettled_BS, from))\\n\\t\\t\\t));\\n\\n\\t\\trepayAmount = getConfig(_amountBorrow_BS, from).mul(amountCollateral).div(getConfig(_amountCollateral_BS, from));\\n\\t\\tuint256 repayInterest = getConfig(_interests_BS, from).mul(amountCollateral).div(getConfig(_amountCollateral_BS, from));\\n\\n\\t\\tpayoutInterest = 0;\\n\\t\\tif (supplyToken == IConfig(config).WETH()) {\\n\\t\\t\\tpayoutInterest = repayInterest.mul(payoutRatio).div(1e18);\\n\\t\\t}\\t\\t\\n\\n\\t\\ttotalPledge = totalPledge.sub(amountCollateral);\\n\\t\\ttotalBorrow = totalBorrow.sub(repayAmount);\\n\\n\\t\\t_setConfig(_amountCollateral_BS, from, getConfig(_amountCollateral_BS, from).sub(amountCollateral));\\n\\t\\t_setConfig(_amountBorrow_BS, from, getConfig(_amountBorrow_BS, from).sub(repayAmount));\\n\\t\\t_setConfig(_interests_BS, from, getConfig(_interests_BS, from).sub(repayInterest));\\n\\t\\t_setConfig(_interestSettled_BS, from, getConfig(_amountBorrow_BS, from) == 0\\n\\t\\t\\t? 0\\n\\t\\t\\t: interestPerBorrow.mul(getConfig(_amountBorrow_BS, from)).div(1e18));\\n\\n\\t\\tremainSupply = remainSupply.add(repayAmount.add(repayInterest.sub(payoutInterest)));\\n\\n\\t\\tif(collateralStrategy != address(0))\\n\\t\\t{\\n\\t\\t\\tIONXStrategy(collateralStrategy).withdraw(from, amountCollateral);\\n\\t\\t}\\n\\t\\tTransferHelper.safeTransfer(collateralToken, msg.sender, amountCollateral);\\n\\t\\trequire(amountIn >= repayAmount.add(repayInterest), \\\"ONX: INVALID AMOUNT TO REPAY\\\");\\n\\n\\t\\tif (payoutInterest > 0) {\\n\\t\\t\\tTransferHelper.safeTransfer(supplyToken, msg.sender, payoutInterest);\\n\\t\\t}\\n\\n\\t\\tif (repayAmount > 0) {\\n\\t\\t\\t_decreaseBorrowerProductivity(from, repayAmount);\\n\\t\\t}\\n\\n\\t\\temit Repay(from, repayAmount, amountCollateral, repayInterest);\\n\\t}\\n\\n\\tfunction liquidation(address _user, address from) public onlyPlatform returns (uint256 borrowAmount) {\\n\\t\\trequire(getConfig(_amountSupply_SS, from) > 0, \\\"ONX: ONLY SUPPLIER\\\");\\n\\n\\t\\tupdateInterests(false);\\n\\n\\t\\t_setConfig(_interests_BS, _user, getConfig(_interests_BS, _user).add(\\n\\t\\t\\t\\tinterestPerBorrow.mul(getConfig(_amountBorrow_BS, _user)).div(1e18).sub(getConfig(_interestSettled_BS, _user))\\n\\t\\t\\t));\\n\\n\\t\\tuint256 liquidationRate = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_LIQUIDATION_RATE);\\n\\n\\t\\t////// Used pool price for liquidation limit check\\n\\t\\t////// uint pledgePrice = IConfig(config).getPoolValue(address(this), ConfigNames.POOL_PRICE);\\n\\t\\t////// uint collateralValue = getConfig(_amountCollateral_BS, _user).mul(pledgePrice).div(1e18);\\n\\n\\t\\t////// Need to set token price for liquidation\\n\\t\\tuint256 collateralValue =\\n\\t\\tIConfig(config).convertTokenAmount(collateralToken, supplyToken, getConfig(_amountCollateral_BS, _user));\\n\\n\\t\\tuint256 expectedRepay = getConfig(_amountBorrow_BS, _user).add(getConfig(_interests_BS, _user));\\n\\n\\t\\trequire(expectedRepay >= collateralValue.mul(liquidationRate).div(1e18), \\\"ONX: NOT LIQUIDABLE\\\");\\n\\n\\t\\tupdateLiquidation(getConfig(_amountCollateral_BS, _user));\\n\\n\\t\\ttotalLiquidation = totalLiquidation.add(getConfig(_amountCollateral_BS, _user));\\n\\t\\ttotalLiquidationSupplyAmount = totalLiquidationSupplyAmount.add(expectedRepay);\\n\\t\\ttotalBorrow = totalBorrow.sub(getConfig(_amountBorrow_BS, _user));\\n\\n\\t\\tborrowAmount = getConfig(_amountBorrow_BS, _user);\\n\\n\\t\\tuint256 length = getConfig(_length_LS, _user);\\n\\t\\tuint256 id = uint256(_user) ^ length;\\n\\n\\t\\t_setConfig(_amountCollateral_LS, id, getConfig(_amountCollateral_BS, _user));\\n\\t\\t_setConfig(_liquidationAmount_LS, id, expectedRepay);\\n\\t\\t_setConfig(_timestamp_LS, id, block.timestamp);\\n\\n\\t\\t_setConfig(_length_LS, _user, length + 1);\\n\\n\\t\\tliquidationHistoryLength[_user]++;\\n\\t\\tif(collateralStrategy != address(0))\\n\\t\\t{\\n\\t\\t\\tIONXStrategy(collateralStrategy).liquidation(_user);\\n\\t\\t}\\n\\n\\t\\temit Liquidation(from, _user, getConfig(_amountBorrow_BS, _user), getConfig(_amountCollateral_BS, _user));\\n\\n\\t\\t_setConfig(_amountCollateral_BS, _user, 0);\\n\\t\\t_setConfig(_amountBorrow_BS, _user, 0);\\n\\t\\t_setConfig(_interests_BS, _user, 0);\\n\\t\\t_setConfig(_interestSettled_BS, _user, 0);\\n\\n\\t\\tif (borrowAmount > 0) {\\n\\t\\t\\t_decreaseBorrowerProductivity(_user, borrowAmount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getPoolCapacity() external view returns (uint256) {\\n\\t\\treturn totalStake.add(totalBorrow);\\n\\t}\\n\\n\\tfunction supplys(address user) external view returns (\\n\\t\\tuint256 amountSupply,\\n\\t\\tuint256 interestSettled,\\n\\t\\tuint256 liquidationSettled,\\n\\t\\tuint256 interests,\\n\\t\\tuint256 _liquidation\\n\\t) {\\n\\t\\tamountSupply = getConfig(_amountSupply_SS, user);\\n\\t\\tinterestSettled = getConfig(_interestSettled_SS, user);\\n\\t\\tliquidationSettled = getConfig(_liquidationSettled_SS, user);\\n\\t\\tinterests = getConfig(_interests_SS, user);\\n\\t\\t_liquidation = getConfig(_liquidation_SS, user);\\n\\t}\\n\\n\\tfunction borrows(address user) external view returns(\\n\\t\\tuint256 index,\\n\\t\\tuint256 amountCollateral,\\n\\t\\tuint256 interestSettled,\\n\\t\\tuint256 amountBorrow,\\n\\t\\tuint256 interests\\n\\t) {\\n\\t\\tindex = getConfig(_index_BS, user);\\n\\t\\tamountCollateral = getConfig(_amountCollateral_BS, user);\\n\\t\\tinterestSettled = getConfig(_interestSettled_BS, user);\\n\\t\\tamountBorrow = getConfig(_amountBorrow_BS, user);\\n\\t\\tinterests = getConfig(_interests_BS, user);\\n\\t}\\n\\n\\tfunction liquidationHistory(address user, uint256 index) external view returns (\\n\\t\\tuint256 amountCollateral,\\n\\t\\tuint256 liquidationAmount,\\n\\t\\tuint256 timestamp\\n\\t) {\\n\\t\\tuint256 id = uint256(user) ^ index;\\n\\n\\t\\tamountCollateral = getConfig(_amountCollateral_LS, id);\\n\\t\\tliquidationAmount = getConfig(_liquidationAmount_LS, id);\\n\\t\\ttimestamp = getConfig(_timestamp_LS, id);\\n\\t}\\n\\n\\tfunction mint() external {\\n\\t\\t_mintLender();\\n\\t\\t_mintBorrower();\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nlibrary TransferHelper {\\n\\tfunction safeApprove(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t// bytes4(keccak256(bytes('approve(address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: APPROVE_FAILED\\\");\\n\\t}\\n\\n\\tfunction safeTransfer(\\n\\t\\taddress token,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FAILED\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(\\n\\t\\taddress token,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 value\\n\\t) internal {\\n\\t\\t// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n\\t\\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FROM_FAILED\\\");\\n\\t}\\n\\n\\tfunction safeTransferETH(address to, uint256 value) internal {\\n\\t\\t(bool success, ) = to.call{value: value}(new bytes(0));\\n\\t\\trequire(success, \\\"TransferHelper: ETH_TRANSFER_FAILED\\\");\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\n\\nlibrary SafeMath {\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b <= a, errorMessage);\\n\\t\\tuint256 c = a - b;\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers. Reverts on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn div(a, b, \\\"SafeMath: division by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b > 0, errorMessage);\\n\\t\\tuint256 c = a / b;\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * Reverts when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * Reverts with custom message when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(\\n\\t\\tuint256 a,\\n\\t\\tuint256 b,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (uint256) {\\n\\t\\trequire(b != 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Configable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\ninterface IConfig {\\n\\t\\tfunction owner() external view returns (address);\\n    function platform() external view returns (address);\\n    function factory() external view returns (address);\\n    function mint() external view returns (address);\\n    function token() external view returns (address);\\n    function developPercent() external view returns (uint);\\n    function share() external view returns (address);\\n    function base() external view returns (address); \\n    function governor() external view returns (address);\\n    function getPoolValue(address pool, bytes32 key) external view returns (uint);\\n    function getValue(bytes32 key) external view returns(uint);\\n    function getParams(bytes32 key) external view returns(uint, uint, uint); \\n    function getPoolParams(address pool, bytes32 key) external view returns(uint, uint, uint); \\n    function wallets(bytes32 key) external view returns(address);\\n    function setValue(bytes32 key, uint value) external;\\n    function setPoolValue(address pool, bytes32 key, uint value) external;\\n    function initPoolParams(address _pool) external;\\n    function isMintToken(address _token) external returns (bool);\\n    function prices(address _token) external returns (uint);\\n    function convertTokenAmount(address _fromToken, address _toToken, uint _fromAmount) external view returns (uint);\\n    function DAY() external view returns (uint);\\n    function WETH() external view returns (address);\\n}\\n\\ncontract Configable is Initializable {\\n\\taddress public config;\\n\\taddress public owner;\\n\\tevent OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\\n\\n\\tfunction __config_initialize() internal initializer {\\n\\t\\towner = msg.sender;\\n\\t}\\n\\n\\tfunction setupConfig(address _config) external onlyOwner {\\n\\t\\tconfig = _config;\\n\\t\\towner = IConfig(config).owner();\\n\\t}\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == owner, \\\"OWNER FORBIDDEN\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyPlatform() {\\n\\t\\trequire(msg.sender == IConfig(config).platform(), \\\"PLATFORM FORBIDDEN\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyFactory() {\\n\\t\\t\\trequire(msg.sender == IConfig(config).factory(), 'FACTORY FORBIDDEN');\\n\\t\\t\\t_;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/modules/ConfigNames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\n\\nlibrary ConfigNames {\\n\\t//GOVERNANCE\\n\\tbytes32 public constant STAKE_LOCK_TIME = bytes32(\\\"STAKE_LOCK_TIME\\\");\\n\\tbytes32 public constant CHANGE_PRICE_DURATION = bytes32(\\\"CHANGE_PRICE_DURATION\\\");\\n\\tbytes32 public constant CHANGE_PRICE_PERCENT = bytes32(\\\"CHANGE_PRICE_PERCENT\\\"); // POOL\\n\\tbytes32 public constant POOL_BASE_INTERESTS = bytes32(\\\"POOL_BASE_INTERESTS\\\");\\n\\tbytes32 public constant POOL_MARKET_FRENZY = bytes32(\\\"POOL_MARKET_FRENZY\\\");\\n\\tbytes32 public constant POOL_PLEDGE_RATE = bytes32(\\\"POOL_PLEDGE_RATE\\\");\\n\\tbytes32 public constant POOL_LIQUIDATION_RATE = bytes32(\\\"POOL_LIQUIDATION_RATE\\\");\\n\\tbytes32 public constant POOL_MINT_BORROW_PERCENT = bytes32(\\\"POOL_MINT_BORROW_PERCENT\\\");\\n\\tbytes32 public constant POOL_MINT_POWER = bytes32(\\\"POOL_MINT_POWER\\\");\\n\\tbytes32 public constant POOL_REWARD_RATE = bytes32(\\\"POOL_REWARD_RATE\\\");\\n\\tbytes32 public constant POOL_ARBITRARY_RATE = bytes32(\\\"POOL_ARBITRARY_RATE\\\");\\n\\n\\t//NOT GOVERNANCE\\n\\tbytes32 public constant DEPOSIT_ENABLE = bytes32(\\\"DEPOSIT_ENABLE\\\");\\n\\tbytes32 public constant WITHDRAW_ENABLE = bytes32(\\\"WITHDRAW_ENABLE\\\");\\n\\tbytes32 public constant BORROW_ENABLE = bytes32(\\\"BORROW_ENABLE\\\");\\n\\tbytes32 public constant REPAY_ENABLE = bytes32(\\\"REPAY_ENABLE\\\");\\n\\tbytes32 public constant LIQUIDATION_ENABLE = bytes32(\\\"LIQUIDATION_ENABLE\\\");\\n\\tbytes32 public constant REINVEST_ENABLE = bytes32(\\\"REINVEST_ENABLE\\\");\\n\\tbytes32 public constant POOL_PRICE = bytes32(\\\"POOL_PRICE\\\"); //wallet\\n}\\n\"\r\n    },\r\n    \"contracts/modules/BaseMintField.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../libraries/TransferHelper.sol\\\";\\nimport \\\"../modules/Configable.sol\\\";\\nimport \\\"../modules/ConfigNames.sol\\\";\\n\\ninterface IERC20 {\\n\\tfunction approve(address spender, uint256 value) external returns (bool);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256);\\n}\\n\\ncontract BaseMintField is Configable {\\n\\tusing SafeMath for uint256;\\n\\n\\tuint256 public mintCumulation;\\n\\n\\tuint256 public totalLendProductivity;\\n\\tuint256 public totalBorrowProducitivity;\\n\\tuint256 public accAmountPerLend;\\n\\tuint256 public accAmountPerBorrow;\\n\\n\\tuint256 public totalBorrowSupply;\\n\\tuint256 public totalLendSupply;\\n\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount; // How many tokens the user has provided.\\n\\t\\tuint256 rewardDebt; // Reward debt.\\n\\t\\tuint256 rewardEarn; // Reward earn and not minted\\n\\t\\tuint256 index;\\n\\t}\\n\\n\\tmapping(address => UserInfo) public lenders;\\n\\tmapping(address => UserInfo) public borrowers;\\n\\n\\tuint256 public totalShare;\\n\\tuint256 public mintedShare;\\n\\tevent BorrowPowerChange(uint256 oldValue, uint256 newValue);\\n\\tevent InterestRatePerBlockChanged(uint256 oldValue, uint256 newValue);\\n\\tevent BorrowerProductivityIncreased(address indexed user, uint256 value);\\n\\tevent BorrowerProductivityDecreased(address indexed user, uint256 value);\\n\\tevent LenderProductivityIncreased(address indexed user, uint256 value);\\n\\tevent LenderProductivityDecreased(address indexed user, uint256 value);\\n\\tevent MintLender(address indexed user, uint256 userAmount);\\n\\tevent MintBorrower(address indexed user, uint256 userAmount); // Update reward variables of the given pool to be up-to-date.\\n\\n\\tfunction _update() internal virtual {\\n\\t\\tuint256 reward = _currentReward();\\n\\t\\ttotalShare += reward;\\n\\t\\tif (totalLendProductivity.add(totalBorrowProducitivity) == 0 || reward == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tuint256 borrowReward =\\n\\t\\t\\treward.mul(IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MINT_BORROW_PERCENT)).div(10000);\\n\\t\\tuint256 lendReward = reward.sub(borrowReward);\\n\\n\\t\\tif (totalLendProductivity != 0 && lendReward > 0) {\\n\\t\\t\\ttotalLendSupply = totalLendSupply.add(lendReward);\\n\\t\\t\\taccAmountPerLend = accAmountPerLend.add(lendReward.mul(1e12).div(totalLendProductivity));\\n\\t\\t}\\n\\n\\t\\tif (totalBorrowProducitivity != 0 && borrowReward > 0) {\\n\\t\\t\\ttotalBorrowSupply = totalBorrowSupply.add(borrowReward);\\n\\t\\t\\taccAmountPerBorrow = accAmountPerBorrow.add(borrowReward.mul(1e12).div(totalBorrowProducitivity));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _currentReward() internal view virtual returns (uint256) {\\n\\t\\treturn mintedShare.add(IERC20(IConfig(config).token()).balanceOf(address(this))).sub(totalShare);\\n\\t}\\n\\n\\t// Audit borrowers's reward to be up-to-date\\n\\tfunction _auditBorrower(address user) internal {\\n\\t\\tUserInfo storage userInfo = borrowers[user];\\n\\t\\tif (userInfo.amount > 0) {\\n\\t\\t\\tuint256 pending = userInfo.amount.mul(accAmountPerBorrow).div(1e12).sub(userInfo.rewardDebt);\\n\\t\\t\\tuserInfo.rewardEarn = userInfo.rewardEarn.add(pending);\\n\\t\\t\\tmintCumulation = mintCumulation.add(pending);\\n\\t\\t\\tuserInfo.rewardDebt = userInfo.amount.mul(accAmountPerBorrow).div(1e12);\\n\\t\\t}\\n\\t}\\n\\n\\t// Audit lender's reward to be up-to-date\\n\\tfunction _auditLender(address user) internal {\\n\\t\\tUserInfo storage userInfo = lenders[user];\\n\\t\\tif (userInfo.amount > 0) {\\n\\t\\t\\tuint256 pending = userInfo.amount.mul(accAmountPerLend).div(1e12).sub(userInfo.rewardDebt);\\n\\t\\t\\tuserInfo.rewardEarn = userInfo.rewardEarn.add(pending);\\n\\t\\t\\tmintCumulation = mintCumulation.add(pending);\\n\\t\\t\\tuserInfo.rewardDebt = userInfo.amount.mul(accAmountPerLend).div(1e12);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _increaseBorrowerProductivity(address user, uint256 value) internal returns (bool) {\\n\\t\\trequire(value > 0, \\\"PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO\\\");\\n\\t\\tUserInfo storage userInfo = borrowers[user];\\n\\t\\t_update();\\n\\t\\t_auditBorrower(user);\\n\\t\\ttotalBorrowProducitivity = totalBorrowProducitivity.add(value);\\n\\t\\tuserInfo.amount = userInfo.amount.add(value);\\n\\t\\tuserInfo.rewardDebt = userInfo.amount.mul(accAmountPerBorrow).div(1e12);\\n\\t\\temit BorrowerProductivityIncreased(user, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _decreaseBorrowerProductivity(address user, uint256 value) internal returns (bool) {\\n\\t\\trequire(value > 0, \\\"INSUFFICIENT_PRODUCTIVITY\\\");\\n\\n\\t\\tUserInfo storage userInfo = borrowers[user];\\n\\t\\trequire(userInfo.amount >= value, \\\"FORBIDDEN\\\");\\n\\t\\t_update();\\n\\t\\t_auditBorrower(user);\\n\\n\\t\\tuserInfo.amount = userInfo.amount.sub(value);\\n\\t\\tuserInfo.rewardDebt = userInfo.amount.mul(accAmountPerBorrow).div(1e12);\\n\\t\\ttotalBorrowProducitivity = totalBorrowProducitivity.sub(value);\\n\\t\\temit BorrowerProductivityDecreased(user, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _increaseLenderProductivity(address user, uint256 value) internal returns (bool) {\\n\\t\\trequire(value > 0, \\\"PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO\\\");\\n\\t\\tUserInfo storage userInfo = lenders[user];\\n\\t\\t_update();\\n\\t\\t_auditLender(user);\\n\\t\\ttotalLendProductivity = totalLendProductivity.add(value);\\n\\t\\tuserInfo.amount = userInfo.amount.add(value);\\n\\t\\tuserInfo.rewardDebt = userInfo.amount.mul(accAmountPerLend).div(1e12);\\n\\t\\temit LenderProductivityIncreased(user, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// External function call\\n\\t// This function will decreases user's productivity by value, and updates the global productivity\\n\\t// it will record which block this is happenning and accumulates the area of (productivity * time)\\n\\tfunction _decreaseLenderProductivity(address user, uint256 value) internal returns (bool) {\\n\\t\\trequire(value > 0, \\\"INSUFFICIENT_PRODUCTIVITY\\\");\\n\\n\\t\\tUserInfo storage userInfo = lenders[user];\\n\\t\\trequire(userInfo.amount >= value, \\\"FORBIDDEN\\\");\\n\\t\\t_update();\\n\\t\\t_auditLender(user);\\n\\n\\t\\tuserInfo.amount = userInfo.amount.sub(value);\\n\\t\\tuserInfo.rewardDebt = userInfo.amount.mul(accAmountPerLend).div(1e12);\\n\\t\\ttotalLendProductivity = totalLendProductivity.sub(value);\\n\\t\\temit LenderProductivityDecreased(user, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction takeBorrowWithAddress(address user) public view returns (uint256) {\\n\\t\\tUserInfo storage userInfo = borrowers[user];\\n\\t\\tuint256 _accAmountPerBorrow = accAmountPerBorrow;\\n\\t\\tif (totalBorrowProducitivity != 0) {\\n\\t\\t\\tuint256 reward = _currentReward();\\n\\t\\t\\tuint256 borrowReward =\\n\\t\\t\\t\\treward.mul(IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MINT_BORROW_PERCENT)).div(10000);\\n\\n\\t\\t\\t_accAmountPerBorrow = accAmountPerBorrow.add(borrowReward.mul(1e12).div(totalBorrowProducitivity));\\n\\t\\t}\\n\\n\\t\\treturn userInfo.amount.mul(_accAmountPerBorrow).div(1e12).sub(userInfo.rewardDebt).add(userInfo.rewardEarn);\\n\\t}\\n\\n\\tfunction takeLendWithAddress(address user) public view returns (uint256) {\\n\\t\\tUserInfo storage userInfo = lenders[user];\\n\\t\\tuint256 _accAmountPerLend = accAmountPerLend;\\n\\t\\tif (totalLendProductivity != 0) {\\n\\t\\t\\tuint256 reward = _currentReward();\\n\\t\\t\\tuint256 lendReward =\\n\\t\\t\\t\\treward.sub(reward.mul(IConfig(config).getPoolValue(address(this), ConfigNames.POOL_MINT_BORROW_PERCENT)).div(10000));\\n\\t\\t\\t_accAmountPerLend = accAmountPerLend.add(lendReward.mul(1e12).div(totalLendProductivity));\\n\\t\\t}\\n\\t\\treturn userInfo.amount.mul(_accAmountPerLend).div(1e12).sub(userInfo.rewardDebt).add(userInfo.rewardEarn);\\n\\t}\\n\\n\\tfunction takeBorrowWithBlock() external view returns (uint256, uint256) {\\n\\t\\tuint256 earn = takeBorrowWithAddress(msg.sender);\\n\\t\\treturn (earn, block.number);\\n\\t}\\n\\n\\tfunction takeLendWithBlock() external view returns (uint256, uint256) {\\n\\t\\tuint256 earn = takeLendWithAddress(msg.sender);\\n\\t\\treturn (earn, block.number);\\n\\t}\\n\\n\\tfunction takeAll() public view returns (uint256) {\\n\\t\\treturn takeBorrowWithAddress(msg.sender).add(takeLendWithAddress(msg.sender));\\n\\t}\\n\\n\\tfunction takeAllWithBlock() external view returns (uint256, uint256) {\\n\\t\\treturn (takeAll(), block.number);\\n\\t}\\n\\n\\tfunction _mintBorrower() internal returns (uint256) {\\n\\t\\t_update();\\n\\t\\t_auditBorrower(msg.sender);\\n\\t\\tif (borrowers[msg.sender].rewardEarn > 0) {\\n\\t\\t\\tuint256 amount = borrowers[msg.sender].rewardEarn;\\n\\t\\t\\t_mintDistribution(msg.sender, amount);\\n\\t\\t\\tborrowers[msg.sender].rewardEarn = 0;\\n\\t\\t\\temit MintBorrower(msg.sender, amount);\\n\\t\\t\\treturn amount;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _mintLender() internal returns (uint256) {\\n\\t\\t_update();\\n\\t\\t_auditLender(msg.sender);\\n\\t\\tif (lenders[msg.sender].rewardEarn > 0) {\\n\\t\\t\\tuint256 amount = lenders[msg.sender].rewardEarn;\\n\\t\\t\\t_mintDistribution(msg.sender, amount);\\n\\t\\t\\tlenders[msg.sender].rewardEarn = 0;\\n\\t\\t\\temit MintLender(msg.sender, amount);\\n\\t\\t\\treturn amount;\\n\\t\\t}\\n\\t}\\n\\n\\t// Returns how many productivity a user has and global has.\\n\\tfunction getBorrowerProductivity(address user) external view returns (uint256, uint256) {\\n\\t\\treturn (borrowers[user].amount, totalBorrowProducitivity);\\n\\t}\\n\\n\\tfunction getLenderProductivity(address user) external view returns (uint256, uint256) {\\n\\t\\treturn (lenders[user].amount, totalLendProductivity);\\n\\t}\\n\\n\\t// Returns the current gorss product rate.\\n\\tfunction interestsPerBlock() external view returns (uint256, uint256) {\\n\\t\\treturn (accAmountPerBorrow, accAmountPerLend);\\n\\t}\\n\\n\\tfunction _mintDistribution(address user, uint256 amount) internal {\\n\\t\\tif (amount > 0) {\\n\\t\\t\\tmintedShare += amount;\\n\\t\\t\\tTransferHelper.safeTransfer(IConfig(config).token(), user, amount);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Configurable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.16;\\n\\ncontract Configurable {\\n    mapping (bytes32 => uint) internal _config;\\n\\n    function getConfig(bytes32 key) public view returns (uint) {\\n        return _config[key];\\n    }\\n    function getConfig(bytes32 key, uint index) public view returns (uint) {\\n        return _config[bytes32(uint(key) ^ index)];\\n    }\\n    function getConfig(bytes32 key, address addr) public view returns (uint) {\\n        return _config[bytes32(uint(key) ^ uint(addr))];\\n    }\\n\\n    function _setConfig(bytes32 key, uint value) internal {\\n        if(_config[key] != value)\\n            _config[key] = value;\\n    }\\n\\n    function _setConfig(bytes32 key, uint index, uint value) internal {\\n        _setConfig(bytes32(uint(key) ^ index), value);\\n    }\\n\\n    function _setConfig(bytes32 key, address addr, uint value) internal {\\n        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n * \\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n * \\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"BorrowPowerChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BorrowerProductivityDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BorrowerProductivityIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"InterestRatePerBlockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LenderProductivityDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LenderProductivityIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userAmount\",\"type\":\"uint256\"}],\"name\":\"MintBorrower\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userAmount\",\"type\":\"uint256\"}],\"name\":\"MintLender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reinvestAmount\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interestAmount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_supplyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_interestAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accAmountPerBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accAmountPerLend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectBorrow\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"borrowerList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEarn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"borrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSettled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interests\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDeposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBorrowerProductivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyInterestPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowInterestPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLenderProductivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_supplyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestPerBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestPerSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestsPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastInterestUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lenders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEarn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"liquidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"liquidationHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidationHistoryLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationPerSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCumulation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberBorrowers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"reinvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reinvestAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCollateral\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutInterest\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralStrategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_supplyStrategy\",\"type\":\"address\"}],\"name\":\"setCollateralStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"supplys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSettled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationSettled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interests\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidation\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeAllWithBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"takeBorrowWithAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeBorrowWithBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"takeLendWithAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeLendWithBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowProducitivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLendProductivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLendSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLiquidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLiquidationSupplyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPledge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawSupplyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawLiquidation\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ONXPool","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}