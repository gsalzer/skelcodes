{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/WhitelistAdminRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/WhitelistedRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(msg.sender);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/interface/IDPoS.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title DPoS interface\r\n */\r\ninterface IDPoS {\r\n    enum ValidatorChangeType { Add, Removal }\r\n\r\n    // functions\r\n    function contributeToMiningPool(uint _amount) external;\r\n\r\n    function redeemMiningReward(address _receiver, uint _cumulativeReward) external;\r\n\r\n    function registerSidechain(address _addr) external;\r\n\r\n    function initializeCandidate(uint _minSelfStake, uint _commissionRate, uint _rateLockEndTime) external;\r\n\r\n    function announceIncreaseCommissionRate(uint _newRate, uint _newLockEndTime) external;\r\n\r\n    function confirmIncreaseCommissionRate() external;\r\n\r\n    function nonIncreaseCommissionRate(uint _newRate, uint _newLockEndTime) external;\r\n\r\n    function updateMinSelfStake(uint256 _minSelfStake) external;\r\n\r\n    function delegate(address _candidateAddr, uint _amount) external;\r\n\r\n    function withdrawFromUnbondedCandidate(address _candidateAddr, uint _amount) external;\r\n\r\n    function intendWithdraw(address _candidateAddr, uint _amount) external;\r\n\r\n    function confirmWithdraw(address _candidateAddr) external;\r\n\r\n    function claimValidator() external;\r\n\r\n    function confirmUnbondedCandidate(address _candidateAddr) external;\r\n\r\n    function slash(bytes calldata _penaltyRequest) external;\r\n\r\n    function validateMultiSigMessage(bytes calldata _request) external returns(bool);\r\n\r\n    function isValidDPoS() external view returns (bool);\r\n\r\n    function isValidator(address _addr) external view returns (bool);\r\n\r\n    function getValidatorNum() external view returns (uint);\r\n\r\n    function getMinStakingPool() external view returns (uint);\r\n\r\n    function getCandidateInfo(address _candidateAddr) external view returns (bool, uint, uint, uint, uint, uint, uint);\r\n\r\n    function getDelegatorInfo(address _candidateAddr, address _delegatorAddr) external view returns (uint, uint, uint[] memory, uint[] memory);\r\n\r\n    function getMinQuorumStakingPool() external view returns(uint);\r\n\r\n    function getTotalValidatorStakingPool() external view returns(uint);\r\n\r\n    // TODO: interface can't be inherited, so VoteType is not declared here\r\n    // function voteParam(uint _proposalId, VoteType _vote) external;\r\n\r\n    // function confirmParamProposal(uint _proposalId) external;\r\n\r\n    // function voteSidechain(uint _proposalId, VoteType _vote) external;\r\n\r\n    // function confirmSidechainProposal(uint _proposalId) external;\r\n\r\n    // events\r\n    event InitializeCandidate(address indexed candidate, uint minSelfStake, uint commissionRate, uint rateLockEndTime);\r\n\r\n    event CommissionRateAnnouncement(address indexed candidate, uint announcedRate, uint announcedLockEndTime);\r\n\r\n    event UpdateCommissionRate(address indexed candidate, uint newRate, uint newLockEndTime);\r\n\r\n    event UpdateMinSelfStake(address indexed candidate, uint minSelfStake);\r\n\r\n    event Delegate(address indexed delegator, address indexed candidate, uint newStake, uint stakingPool);\r\n\r\n    event ValidatorChange(address indexed ethAddr, ValidatorChangeType indexed changeType);\r\n\r\n    event WithdrawFromUnbondedCandidate(address indexed delegator, address indexed candidate, uint amount);\r\n\r\n    event IntendWithdraw(address indexed delegator, address indexed candidate, uint withdrawAmount, uint proposedTime);\r\n\r\n    event ConfirmWithdraw(address indexed delegator, address indexed candidate, uint amount);\r\n\r\n    event Slash(address indexed validator, address indexed delegator, uint amount);\r\n\r\n    event UpdateDelegatedStake(address indexed delegator, address indexed candidate, uint delegatorStake, uint candidatePool);\r\n\r\n    event Compensate(address indexed indemnitee, uint amount);\r\n\r\n    event CandidateUnbonded(address indexed candidate);\r\n\r\n    event RedeemMiningReward(address indexed receiver, uint reward, uint miningPool);\r\n\r\n    event MiningPoolContribution(address indexed contributor, uint contribution, uint miningPoolSize);\r\n}\r\n\r\n// File: contracts/lib/data/Pb.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n// runtime proto sol library\r\nlibrary Pb {\r\n    enum WireType { Varint, Fixed64, LengthDelim, StartGroup, EndGroup, Fixed32 }\r\n\r\n    struct Buffer {\r\n        uint idx;  // the start index of next read. when idx=b.length, we're done\r\n        bytes b;   // hold serialized proto msg, readonly\r\n    }\r\n\r\n    // create a new in-memory Buffer object from raw msg bytes\r\n    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\r\n        buf.b = raw;\r\n        buf.idx = 0;\r\n    }\r\n\r\n    // whether there are unread bytes\r\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\r\n        return buf.idx < buf.b.length;\r\n    }\r\n\r\n    // decode current field number and wiretype\r\n    function decKey(Buffer memory buf) internal pure returns (uint tag, WireType wiretype) {\r\n        uint v = decVarint(buf);\r\n        tag = v / 8;\r\n        wiretype = WireType(v & 7);\r\n    }\r\n\r\n    // count tag occurrences, return an array due to no memory map support\r\n\t// have to create array for (maxtag+1) size. cnts[tag] = occurrences\r\n\t// should keep buf.idx unchanged because this is only a count function\r\n    function cntTags(Buffer memory buf, uint maxtag) internal pure returns (uint[] memory cnts) {\r\n        uint originalIdx = buf.idx;\r\n        cnts = new uint[](maxtag+1);  // protobuf's tags are from 1 rather than 0\r\n        uint tag;\r\n        WireType wire;\r\n        while (hasMore(buf)) {\r\n            (tag, wire) = decKey(buf);\r\n            cnts[tag] += 1;\r\n            skipValue(buf, wire);\r\n        }\r\n        buf.idx = originalIdx;\r\n    }\r\n\r\n    // read varint from current buf idx, move buf.idx to next read, return the int value\r\n    function decVarint(Buffer memory buf) internal pure returns (uint v) {\r\n        bytes10 tmp;  // proto int is at most 10 bytes (7 bits can be used per byte)\r\n        bytes memory bb = buf.b;  // get buf.b mem addr to use in assembly\r\n        v = buf.idx;  // use v to save one additional uint variable\r\n        assembly {\r\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\r\n        }\r\n        uint b; // store current byte content\r\n        v = 0; // reset to 0 for return value\r\n        for (uint i=0; i<10; i++) {\r\n            assembly {\r\n                b := byte(i, tmp)  // don't use tmp[i] because it does bound check and costs extra\r\n            }\r\n            v |= (b & 0x7F) << (i * 7);\r\n            if (b & 0x80 == 0) {\r\n                buf.idx += i + 1;\r\n                return v;\r\n            }\r\n        }\r\n        revert(); // i=10, invalid varint stream\r\n    }\r\n\r\n    // read length delimited field and return bytes\r\n    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        b = new bytes(len);\r\n        bytes memory bufB = buf.b;  // get buf.b mem addr to use in assembly\r\n        uint bStart;\r\n        uint bufBStart = buf.idx;\r\n        assembly {\r\n            bStart := add(b, 32)\r\n            bufBStart := add(add(bufB, 32), bufBStart)\r\n        }\r\n        for (uint i=0; i<len; i+=32) {\r\n            assembly{\r\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\r\n            }\r\n        }\r\n        buf.idx = end;\r\n    }\r\n\r\n    // return packed ints\r\n    function decPacked(Buffer memory buf) internal pure returns (uint[] memory t) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        // array in memory must be init w/ known length\r\n        // so we have to create a tmp array w/ max possible len first\r\n        uint[] memory tmp = new uint[](len);\r\n        uint i; // count how many ints are there\r\n        while (buf.idx < end) {\r\n            tmp[i] = decVarint(buf);\r\n            i++;\r\n        }\r\n        t = new uint[](i); // init t with correct length\r\n        for (uint j=0; j<i; j++) {\r\n            t[j] = tmp[j];\r\n        }\r\n        return t;\r\n    }\r\n\r\n    // move idx pass current value field, to beginning of next tag or msg end\r\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\r\n        if (wire == WireType.Varint) { decVarint(buf); }\r\n        else if (wire == WireType.LengthDelim) {\r\n            uint len = decVarint(buf);\r\n            buf.idx += len; // skip len bytes value data\r\n            require(buf.idx <= buf.b.length);  // avoid overflow\r\n        } else { revert(); }  // unsupported wiretype\r\n    }\r\n\r\n    // type conversion help utils\r\n    function _bool(uint x) internal pure returns (bool v) {\r\n        return x != 0;\r\n    }\r\n\r\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\r\n        require(b.length <= 32);  // b's length must be smaller than or equal to 32\r\n        assembly { v := mload(add(b, 32)) }  // load all 32bytes to v\r\n        v = v >> (8 * (32 - b.length));  // only first b.length is valid\r\n    }\r\n\r\n    function _address(bytes memory b) internal pure returns (address v) {\r\n        v = _addressPayable(b);\r\n    }\r\n\r\n    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\r\n        require(b.length == 20);\r\n        //load 32bytes then shift right 12 bytes\r\n        assembly { v := div(mload(add(b, 32)), 0x1000000000000000000000000) }\r\n    }\r\n\r\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\r\n        require(b.length == 32);\r\n        assembly { v := mload(add(b, 32)) }\r\n    }\r\n\r\n    // uint[] to uint8[]\r\n    function uint8s(uint[] memory arr) internal pure returns (uint8[] memory t) {\r\n        t = new uint8[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint8(arr[i]); }\r\n    }\r\n\r\n    function uint32s(uint[] memory arr) internal pure returns (uint32[] memory t) {\r\n        t = new uint32[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint32(arr[i]); }\r\n    }\r\n\r\n    function uint64s(uint[] memory arr) internal pure returns (uint64[] memory t) {\r\n        t = new uint64[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint64(arr[i]); }\r\n    }\r\n\r\n    function bools(uint[] memory arr) internal pure returns (bool[] memory t) {\r\n        t = new bool[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = arr[i]!=0; }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/data/PbSgn.sol\r\n\r\n// Code generated by protoc-gen-sol. DO NOT EDIT.\r\n// source: sgn.proto\r\npragma solidity 0.5.17;\r\n\r\n\r\nlibrary PbSgn {\r\n    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\r\n\r\n    struct MultiSigMessage {\r\n        bytes msg;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct MultiSigMessage\r\n\r\n    function decMultiSigMessage(bytes memory raw) internal pure returns (MultiSigMessage memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.msg = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder MultiSigMessage\r\n\r\n    struct PenaltyRequest {\r\n        bytes penalty;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct PenaltyRequest\r\n\r\n    function decPenaltyRequest(bytes memory raw) internal pure returns (PenaltyRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.penalty = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder PenaltyRequest\r\n\r\n    struct RewardRequest {\r\n        bytes reward;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct RewardRequest\r\n\r\n    function decRewardRequest(bytes memory raw) internal pure returns (RewardRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.reward = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder RewardRequest\r\n\r\n    struct Penalty {\r\n        uint64 nonce;   // tag: 1\r\n        uint64 expireTime;   // tag: 2\r\n        address validatorAddress;   // tag: 3\r\n        AccountAmtPair[] penalizedDelegators;   // tag: 4\r\n        AccountAmtPair[] beneficiaries;   // tag: 5\r\n    } // end struct Penalty\r\n\r\n    function decPenalty(bytes memory raw) internal pure returns (Penalty memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(5);\r\n        m.penalizedDelegators = new AccountAmtPair[](cnts[4]);\r\n        cnts[4] = 0;  // reset counter for later use\r\n        m.beneficiaries = new AccountAmtPair[](cnts[5]);\r\n        cnts[5] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.nonce = uint64(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.expireTime = uint64(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.validatorAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.penalizedDelegators[cnts[4]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[4]++;\r\n            }\r\n            else if (tag == 5) {\r\n                m.beneficiaries[cnts[5]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[5]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder Penalty\r\n\r\n    struct AccountAmtPair {\r\n        address account;   // tag: 1\r\n        uint256 amt;   // tag: 2\r\n    } // end struct AccountAmtPair\r\n\r\n    function decAccountAmtPair(bytes memory raw) internal pure returns (AccountAmtPair memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.account = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.amt = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder AccountAmtPair\r\n\r\n    struct Reward {\r\n        address receiver;   // tag: 1\r\n        uint256 cumulativeMiningReward;   // tag: 2\r\n        uint256 cumulativeServiceReward;   // tag: 3\r\n    } // end struct Reward\r\n\r\n    function decReward(bytes memory raw) internal pure returns (Reward memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.receiver = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.cumulativeMiningReward = Pb._uint256(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.cumulativeServiceReward = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder Reward\r\n\r\n}\r\n\r\n// File: contracts/lib/DPoSCommon.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title DPoS contract common Library\r\n * @notice Common items used in DPoS contract\r\n */\r\nlibrary DPoSCommon {\r\n    // Unbonded: not a validator and not responsible for previous validator behaviors if any.\r\n    //   Delegators now are free to withdraw stakes (directly).\r\n    // Bonded: active validator. Delegators have to wait for slashTimeout to withdraw stakes.\r\n    // Unbonding: transitional status from Bonded to Unbonded. Candidate has lost the right of\r\n    //   validator but is still responsible for any misbehaviour done during being validator.\r\n    //   Delegators should wait until candidate's unbondTime to freely withdraw stakes.\r\n    enum CandidateStatus { Unbonded, Bonded, Unbonding }\r\n}\r\n\r\n// File: contracts/lib/interface/IGovern.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title Govern interface\r\n */\r\ninterface IGovern {\r\n    enum ParamNames { ProposalDeposit, GovernVoteTimeout, SlashTimeout, MinValidatorNum, MaxValidatorNum, MinStakeInPool, AdvanceNoticePeriod, MigrationTime }\r\n\r\n    enum ProposalStatus { Uninitiated, Voting, Closed }\r\n\r\n    enum VoteType { Unvoted, Yes, No, Abstain }\r\n\r\n    // functions\r\n    function getUIntValue(uint _record) external view returns (uint);\r\n\r\n    function getParamProposalVote(uint _proposalId, address _voter) external view returns (VoteType);\r\n\r\n    function isSidechainRegistered(address _sidechainAddr) external view returns (bool);\r\n\r\n    function getSidechainProposalVote(uint _proposalId, address _voter) external view returns (VoteType);\r\n\r\n    function createParamProposal(uint _record, uint _value) external;\r\n\r\n    function registerSidechain(address _addr) external;\r\n\r\n    function createSidechainProposal(address _sidechainAddr, bool _registered) external;\r\n\r\n    // events\r\n    event CreateParamProposal(uint proposalId, address proposer, uint deposit, uint voteDeadline, uint record, uint newValue);\r\n\r\n    event VoteParam(uint proposalId, address voter, VoteType voteType);\r\n\r\n    event ConfirmParamProposal(uint proposalId, bool passed, uint record, uint newValue);\r\n\r\n    event CreateSidechainProposal(uint proposalId, address proposer, uint deposit, uint voteDeadline, address sidechainAddr, bool registered);\r\n\r\n    event VoteSidechain(uint proposalId, address voter, VoteType voteType);\r\n\r\n    event ConfirmSidechainProposal(uint proposalId, bool passed, address sidechainAddr, bool registered);\r\n}\r\n\r\n// File: contracts/lib/Govern.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Governance module for DPoS contract\r\n * @notice Govern contract implements the basic governance logic\r\n * @dev DPoS contract should inherit this contract\r\n * @dev Some specific functions of governance are defined in DPoS contract\r\n */\r\ncontract Govern is IGovern, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct ParamProposal {\r\n        address proposer;\r\n        uint256 deposit;\r\n        uint256 voteDeadline;\r\n        uint256 record;\r\n        uint256 newValue;\r\n        ProposalStatus status;\r\n        mapping(address => VoteType) votes;\r\n    }\r\n\r\n    struct SidechainProposal {\r\n        address proposer;\r\n        uint256 deposit;\r\n        uint256 voteDeadline;\r\n        address sidechainAddr;\r\n        bool registered;\r\n        ProposalStatus status;\r\n        mapping(address => VoteType) votes;\r\n    }\r\n\r\n    IERC20 public celerToken;\r\n    // parameters\r\n    mapping(uint256 => uint256) public UIntStorage;\r\n    mapping(uint256 => ParamProposal) public paramProposals;\r\n    uint256 public nextParamProposalId;\r\n    // registered sidechain addresses\r\n    mapping(address => bool) public registeredSidechains;\r\n    mapping(uint256 => SidechainProposal) public sidechainProposals;\r\n    uint256 public nextSidechainProposalId;\r\n\r\n    /**\r\n     * @notice Govern constructor\r\n     * @dev set celerToken and initialize all parameters\r\n     * @param _celerTokenAddress address of the governance token\r\n     * @param _governProposalDeposit required deposit amount for a governance proposal\r\n     * @param _governVoteTimeout voting timeout for a governance proposal\r\n     * @param _slashTimeout the locking time for funds to be potentially slashed\r\n     * @param _minValidatorNum the minimum number of validators\r\n     * @param _maxValidatorNum the maximum number of validators\r\n     * @param _minStakeInPool the global minimum requirement of staking pool for each validator\r\n     * @param _advanceNoticePeriod the time after the announcement and prior to the effective time of an update\r\n     */\r\n    constructor(\r\n        address _celerTokenAddress,\r\n        uint256 _governProposalDeposit,\r\n        uint256 _governVoteTimeout,\r\n        uint256 _slashTimeout,\r\n        uint256 _minValidatorNum,\r\n        uint256 _maxValidatorNum,\r\n        uint256 _minStakeInPool,\r\n        uint256 _advanceNoticePeriod\r\n    ) public {\r\n        celerToken = IERC20(_celerTokenAddress);\r\n\r\n        UIntStorage[uint256(ParamNames.ProposalDeposit)] = _governProposalDeposit;\r\n        UIntStorage[uint256(ParamNames.GovernVoteTimeout)] = _governVoteTimeout;\r\n        UIntStorage[uint256(ParamNames.SlashTimeout)] = _slashTimeout;\r\n        UIntStorage[uint256(ParamNames.MinValidatorNum)] = _minValidatorNum;\r\n        UIntStorage[uint256(ParamNames.MaxValidatorNum)] = _maxValidatorNum;\r\n        UIntStorage[uint256(ParamNames.MinStakeInPool)] = _minStakeInPool;\r\n        UIntStorage[uint256(ParamNames.AdvanceNoticePeriod)] = _advanceNoticePeriod;\r\n    }\r\n\r\n    /********** Get functions **********/\r\n    /**\r\n     * @notice Get the value of a specific uint parameter\r\n     * @param _record the key of this parameter\r\n     * @return the value of this parameter\r\n     */\r\n    function getUIntValue(uint256 _record) public view returns (uint256) {\r\n        return UIntStorage[_record];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the vote type of a voter on a parameter proposal\r\n     * @param _proposalId the proposal id\r\n     * @param _voter the voter address\r\n     * @return the vote type of the given voter on the given parameter proposal\r\n     */\r\n    function getParamProposalVote(uint256 _proposalId, address _voter)\r\n        public\r\n        view\r\n        returns (VoteType)\r\n    {\r\n        return paramProposals[_proposalId].votes[_voter];\r\n    }\r\n\r\n    /**\r\n     * @notice Get whether a sidechain is registered or not\r\n     * @param _sidechainAddr the sidechain contract address\r\n     * @return whether the given sidechain is registered or not\r\n     */\r\n    function isSidechainRegistered(address _sidechainAddr) public view returns (bool) {\r\n        return registeredSidechains[_sidechainAddr];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the vote type of a voter on a sidechain proposal\r\n     * @param _proposalId the proposal id\r\n     * @param _voter the voter address\r\n     * @return the vote type of the given voter on the given sidechain proposal\r\n     */\r\n    function getSidechainProposalVote(uint256 _proposalId, address _voter)\r\n        public\r\n        view\r\n        returns (VoteType)\r\n    {\r\n        return sidechainProposals[_proposalId].votes[_voter];\r\n    }\r\n\r\n    /********** Governance functions **********/\r\n    /**\r\n     * @notice Create a parameter proposal\r\n     * @param _record the key of this parameter\r\n     * @param _value the new proposed value of this parameter\r\n     */\r\n    function createParamProposal(uint256 _record, uint256 _value) external {\r\n        ParamProposal storage p = paramProposals[nextParamProposalId];\r\n        nextParamProposalId = nextParamProposalId + 1;\r\n        address msgSender = msg.sender;\r\n        uint256 deposit = UIntStorage[uint256(ParamNames.ProposalDeposit)];\r\n\r\n        p.proposer = msgSender;\r\n        p.deposit = deposit;\r\n        p.voteDeadline = block.number.add(UIntStorage[uint256(ParamNames.GovernVoteTimeout)]);\r\n        p.record = _record;\r\n        p.newValue = _value;\r\n        p.status = ProposalStatus.Voting;\r\n\r\n        celerToken.safeTransferFrom(msgSender, address(this), deposit);\r\n\r\n        emit CreateParamProposal(\r\n            nextParamProposalId - 1,\r\n            msgSender,\r\n            deposit,\r\n            p.voteDeadline,\r\n            _record,\r\n            _value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to vote for a parameter proposal\r\n     * @dev Must be used in DPoS contract\r\n     * @param _proposalId the proposal id\r\n     * @param _voter the voter address\r\n     * @param _vote the vote type\r\n     */\r\n    function internalVoteParam(\r\n        uint256 _proposalId,\r\n        address _voter,\r\n        VoteType _vote\r\n    ) internal {\r\n        ParamProposal storage p = paramProposals[_proposalId];\r\n        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\r\n        require(block.number < p.voteDeadline, 'Vote deadline reached');\r\n        require(p.votes[_voter] == VoteType.Unvoted, 'Voter has voted');\r\n\r\n        p.votes[_voter] = _vote;\r\n\r\n        emit VoteParam(_proposalId, _voter, _vote);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to confirm a parameter proposal\r\n     * @dev Must be used in DPoS contract\r\n     * @param _proposalId the proposal id\r\n     * @param _passed proposal passed or not\r\n     */\r\n    function internalConfirmParamProposal(uint256 _proposalId, bool _passed) internal {\r\n        ParamProposal storage p = paramProposals[_proposalId];\r\n        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\r\n        require(block.number >= p.voteDeadline, 'Vote deadline not reached');\r\n\r\n        p.status = ProposalStatus.Closed;\r\n        if (_passed) {\r\n            celerToken.safeTransfer(p.proposer, p.deposit);\r\n            UIntStorage[p.record] = p.newValue;\r\n        }\r\n\r\n        emit ConfirmParamProposal(_proposalId, _passed, p.record, p.newValue);\r\n    }\r\n\r\n    //\r\n    /**\r\n     * @notice Register a sidechain by contract owner\r\n     * @dev Owner can renounce Ownership if needed for this function\r\n     * @param _addr the sidechain contract address\r\n     */\r\n    function registerSidechain(address _addr) external onlyOwner {\r\n        registeredSidechains[_addr] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Create a sidechain proposal\r\n     * @param _sidechainAddr the sidechain contract address\r\n     * @param _registered the new proposed registration status\r\n     */\r\n    function createSidechainProposal(address _sidechainAddr, bool _registered) external {\r\n        SidechainProposal storage p = sidechainProposals[nextSidechainProposalId];\r\n        nextSidechainProposalId = nextSidechainProposalId + 1;\r\n        address msgSender = msg.sender;\r\n        uint256 deposit = UIntStorage[uint256(ParamNames.ProposalDeposit)];\r\n\r\n        p.proposer = msgSender;\r\n        p.deposit = deposit;\r\n        p.voteDeadline = block.number.add(UIntStorage[uint256(ParamNames.GovernVoteTimeout)]);\r\n        p.sidechainAddr = _sidechainAddr;\r\n        p.registered = _registered;\r\n        p.status = ProposalStatus.Voting;\r\n\r\n        celerToken.safeTransferFrom(msgSender, address(this), deposit);\r\n\r\n        emit CreateSidechainProposal(\r\n            nextSidechainProposalId - 1,\r\n            msgSender,\r\n            deposit,\r\n            p.voteDeadline,\r\n            _sidechainAddr,\r\n            _registered\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to vote for a sidechain proposal\r\n     * @dev Must be used in DPoS contract\r\n     * @param _proposalId the proposal id\r\n     * @param _voter the voter address\r\n     * @param _vote the vote type\r\n     */\r\n    function internalVoteSidechain(\r\n        uint256 _proposalId,\r\n        address _voter,\r\n        VoteType _vote\r\n    ) internal {\r\n        SidechainProposal storage p = sidechainProposals[_proposalId];\r\n        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\r\n        require(block.number < p.voteDeadline, 'Vote deadline reached');\r\n        require(p.votes[_voter] == VoteType.Unvoted, 'Voter has voted');\r\n\r\n        p.votes[_voter] = _vote;\r\n\r\n        emit VoteSidechain(_proposalId, _voter, _vote);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to confirm a sidechain proposal\r\n     * @dev Must be used in DPoS contract\r\n     * @param _proposalId the proposal id\r\n     * @param _passed proposal passed or not\r\n     */\r\n    function internalConfirmSidechainProposal(uint256 _proposalId, bool _passed) internal {\r\n        SidechainProposal storage p = sidechainProposals[_proposalId];\r\n        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\r\n        require(block.number >= p.voteDeadline, 'Vote deadline not reached');\r\n\r\n        p.status = ProposalStatus.Closed;\r\n        if (_passed) {\r\n            celerToken.safeTransfer(p.proposer, p.deposit);\r\n            registeredSidechains[p.sidechainAddr] = p.registered;\r\n        }\r\n\r\n        emit ConfirmSidechainProposal(_proposalId, _passed, p.sidechainAddr, p.registered);\r\n    }\r\n}\r\n\r\n// File: contracts/DPoS.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title A DPoS contract shared by every sidechain\r\n * @notice This contract holds the basic logic of DPoS in Celer's coherent sidechain system\r\n */\r\ncontract DPoS is IDPoS, Ownable, Pausable, WhitelistedRole, Govern {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using ECDSA for bytes32;\r\n\r\n    enum MathOperation { Add, Sub }\r\n\r\n    struct WithdrawIntent {\r\n        uint256 amount;\r\n        uint256 proposedTime;\r\n    }\r\n\r\n    struct Delegator {\r\n        uint256 delegatedStake;\r\n        uint256 undelegatingStake;\r\n        mapping(uint256 => WithdrawIntent) withdrawIntents;\r\n        // valid intent range is [intentStartIndex, intentEndIndex)\r\n        uint256 intentStartIndex;\r\n        uint256 intentEndIndex;\r\n    }\r\n\r\n    struct ValidatorCandidate {\r\n        bool initialized;\r\n        uint256 minSelfStake;\r\n        uint256 stakingPool; // sum of all delegations to this candidate\r\n        mapping(address => Delegator) delegatorProfiles;\r\n        DPoSCommon.CandidateStatus status;\r\n        uint256 unbondTime;\r\n        uint256 commissionRate; // equal to real commission rate * COMMISSION_RATE_BASE\r\n        uint256 rateLockEndTime; // must be monotonic increasing. Use block number\r\n        // for the announcement of increasing commission rate\r\n        uint256 announcedRate;\r\n        uint256 announcedLockEndTime;\r\n        uint256 announcementTime;\r\n        // for decreasing minSelfStake\r\n        uint256 earliestBondTime;\r\n    }\r\n\r\n    mapping(uint256 => address) public validatorSet;\r\n    mapping(uint256 => bool) public usedPenaltyNonce;\r\n    // used in checkValidatorSigs(). mapping has to be storage type.\r\n    mapping(address => bool) public checkedValidators;\r\n    // struct ValidatorCandidate includes a mapping and therefore candidateProfiles can't be public\r\n    mapping(address => ValidatorCandidate) private candidateProfiles;\r\n    mapping(address => uint256) public redeemedMiningReward;\r\n\r\n    /********** Constants **********/\r\n    uint256 constant DECIMALS_MULTIPLIER = 10**18;\r\n    uint256 public constant COMMISSION_RATE_BASE = 10000; // 1 commissionRate means 0.01%\r\n\r\n    uint256 public dposGoLiveTime; // used when bootstrapping initial validators\r\n    uint256 public miningPool;\r\n    bool public enableWhitelist;\r\n    bool public enableSlash;\r\n\r\n    /**\r\n     * @notice Throws if given address is zero address\r\n     * @param _addr address to be checked\r\n     */\r\n    modifier onlyNonZeroAddr(address _addr) {\r\n        require(_addr != address(0), '0 address');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if DPoS is not valid\r\n     * @dev Need to be checked before DPoS's operations\r\n     */\r\n    modifier onlyValidDPoS() {\r\n        require(isValidDPoS(), 'DPoS is not valid');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if msg.sender is not a registered sidechain\r\n     */\r\n    modifier onlyRegisteredSidechains() {\r\n        require(isSidechainRegistered(msg.sender), 'Sidechain not registered');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the sender is in the whitelist\r\n     */\r\n    modifier onlyWhitelist() {\r\n        if (enableWhitelist) {\r\n            require(\r\n                isWhitelisted(msg.sender),\r\n                'WhitelistedRole: caller does not have the Whitelisted role'\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if contract in migrating state\r\n     */\r\n    modifier onlyNotMigrating() {\r\n        require(!isMigrating(), 'contract migrating');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if amount is smaller than minimum\r\n     */\r\n    modifier minAmount(uint256 _amount, uint256 _min) {\r\n        require(_amount >= _min, 'Amount is smaller than minimum requirement');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if sender is not validator\r\n     */\r\n    modifier onlyValidator() {\r\n        require(isValidator(msg.sender), 'msg sender is not a validator');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if candidate is not initialized\r\n     */\r\n    modifier isCandidateInitialized() {\r\n        require(candidateProfiles[msg.sender].initialized, 'Candidate is not initialized');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice DPoS constructor\r\n     * @dev will initialize parent contract Govern first\r\n     * @param _celerTokenAddress address of Celer Token Contract\r\n     * @param _governProposalDeposit required deposit amount for a governance proposal\r\n     * @param _governVoteTimeout voting timeout for a governance proposal\r\n     * @param _slashTimeout the locking time for funds to be potentially slashed\r\n     * @param _minValidatorNum the minimum number of validators\r\n     * @param _maxValidatorNum the maximum number of validators\r\n     * @param _minStakeInPool the global minimum requirement of staking pool for each validator\r\n     * @param _advanceNoticePeriod the wait time after the announcement and prior to the effective date of an update\r\n     * @param _dposGoLiveTimeout the timeout for DPoS to go live after contract creation\r\n     */\r\n    constructor(\r\n        address _celerTokenAddress,\r\n        uint256 _governProposalDeposit,\r\n        uint256 _governVoteTimeout,\r\n        uint256 _slashTimeout,\r\n        uint256 _minValidatorNum,\r\n        uint256 _maxValidatorNum,\r\n        uint256 _minStakeInPool,\r\n        uint256 _advanceNoticePeriod,\r\n        uint256 _dposGoLiveTimeout\r\n    )\r\n        public\r\n        Govern(\r\n            _celerTokenAddress,\r\n            _governProposalDeposit,\r\n            _governVoteTimeout,\r\n            _slashTimeout,\r\n            _minValidatorNum,\r\n            _maxValidatorNum,\r\n            _minStakeInPool,\r\n            _advanceNoticePeriod\r\n        )\r\n    {\r\n        dposGoLiveTime = block.number.add(_dposGoLiveTimeout);\r\n        enableSlash = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Update enableWhitelist\r\n     * @param _enable enable whitelist flag\r\n     */\r\n    function updateEnableWhitelist(bool _enable) external onlyOwner {\r\n        enableWhitelist = _enable;\r\n    }\r\n\r\n    /**\r\n     * @notice Update enableSlash\r\n     * @param _enable enable slash flag\r\n     */\r\n    function updateEnableSlash(bool _enable) external onlyOwner {\r\n        enableSlash = _enable;\r\n    }\r\n\r\n    /**\r\n     * @notice Owner drains one type of tokens when the contract is paused\r\n     * @dev This is for emergency situations.\r\n     * @param _amount drained token amount\r\n     */\r\n    function drainToken(uint256 _amount) external whenPaused onlyOwner {\r\n        celerToken.safeTransfer(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Vote for a parameter proposal with a specific type of vote\r\n     * @param _proposalId the id of the parameter proposal\r\n     * @param _vote the type of vote\r\n     */\r\n    function voteParam(uint256 _proposalId, VoteType _vote) external onlyValidator {\r\n        internalVoteParam(_proposalId, msg.sender, _vote);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm a parameter proposal\r\n     * @param _proposalId the id of the parameter proposal\r\n     */\r\n    function confirmParamProposal(uint256 _proposalId) external {\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n\r\n        // check Yes votes only now\r\n        uint256 yesVoteStakes;\r\n        for (uint256 i = 0; i < maxValidatorNum; i++) {\r\n            if (getParamProposalVote(_proposalId, validatorSet[i]) == VoteType.Yes) {\r\n                yesVoteStakes = yesVoteStakes.add(candidateProfiles[validatorSet[i]].stakingPool);\r\n            }\r\n        }\r\n\r\n        bool passed = yesVoteStakes >= getMinQuorumStakingPool();\r\n        if (!passed) {\r\n            miningPool = miningPool.add(paramProposals[_proposalId].deposit);\r\n        }\r\n        internalConfirmParamProposal(_proposalId, passed);\r\n    }\r\n\r\n    /**\r\n     * @notice Vote for a sidechain proposal with a specific type of vote\r\n     * @param _proposalId the id of the sidechain proposal\r\n     * @param _vote the type of vote\r\n     */\r\n    function voteSidechain(uint256 _proposalId, VoteType _vote) external onlyValidator {\r\n        internalVoteSidechain(_proposalId, msg.sender, _vote);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm a sidechain proposal\r\n     * @param _proposalId the id of the sidechain proposal\r\n     */\r\n    function confirmSidechainProposal(uint256 _proposalId) external {\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n\r\n        // check Yes votes only now\r\n        uint256 yesVoteStakes;\r\n        for (uint256 i = 0; i < maxValidatorNum; i++) {\r\n            if (getSidechainProposalVote(_proposalId, validatorSet[i]) == VoteType.Yes) {\r\n                yesVoteStakes = yesVoteStakes.add(candidateProfiles[validatorSet[i]].stakingPool);\r\n            }\r\n        }\r\n\r\n        bool passed = yesVoteStakes >= getMinQuorumStakingPool();\r\n        if (!passed) {\r\n            miningPool = miningPool.add(sidechainProposals[_proposalId].deposit);\r\n        }\r\n        internalConfirmSidechainProposal(_proposalId, passed);\r\n    }\r\n\r\n    /**\r\n     * @notice Contribute CELR tokens to the mining pool\r\n     * @param _amount the amount of CELR tokens to contribute\r\n     */\r\n    function contributeToMiningPool(uint256 _amount) external whenNotPaused {\r\n        address msgSender = msg.sender;\r\n        miningPool = miningPool.add(_amount);\r\n        celerToken.safeTransferFrom(msgSender, address(this), _amount);\r\n\r\n        emit MiningPoolContribution(msgSender, _amount, miningPool);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem mining reward\r\n     * @dev The validation of this redeeming operation should be done by the caller, a registered sidechain contract\r\n     * @dev Here we use cumulative mining reward to simplify the logic in sidechain code\r\n     * @param _receiver the receiver of the redeemed mining reward\r\n     * @param _cumulativeReward the latest cumulative mining reward\r\n     */\r\n    function redeemMiningReward(address _receiver, uint256 _cumulativeReward)\r\n        external\r\n        whenNotPaused\r\n        onlyRegisteredSidechains\r\n    {\r\n        uint256 newReward = _cumulativeReward.sub(redeemedMiningReward[_receiver]);\r\n        require(miningPool >= newReward, 'Mining pool is smaller than new reward');\r\n\r\n        redeemedMiningReward[_receiver] = _cumulativeReward;\r\n        miningPool = miningPool.sub(newReward);\r\n        celerToken.safeTransfer(_receiver, newReward);\r\n\r\n        emit RedeemMiningReward(_receiver, newReward, miningPool);\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize a candidate profile for validator\r\n     * @dev every validator must become a candidate first\r\n     * @param _minSelfStake minimal amount of tokens staked by the validator itself\r\n     * @param _commissionRate the self-declaimed commission rate\r\n     * @param _rateLockEndTime the lock end time of initial commission rate\r\n     */\r\n    function initializeCandidate(\r\n        uint256 _minSelfStake,\r\n        uint256 _commissionRate,\r\n        uint256 _rateLockEndTime\r\n    ) external whenNotPaused onlyWhitelist {\r\n        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\r\n        require(!candidate.initialized, 'Candidate is initialized');\r\n        require(_commissionRate <= COMMISSION_RATE_BASE, 'Invalid commission rate');\r\n\r\n        candidate.initialized = true;\r\n        candidate.minSelfStake = _minSelfStake;\r\n        candidate.commissionRate = _commissionRate;\r\n        candidate.rateLockEndTime = _rateLockEndTime;\r\n\r\n        emit InitializeCandidate(msg.sender, _minSelfStake, _commissionRate, _rateLockEndTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Apply non-increase-commission-rate changes to commission rate or lock end time,\r\n     *   including decreasing commission rate and/or changing lock end time\r\n     * @dev It can increase lock end time immediately without waiting\r\n     * @param _newRate new commission rate\r\n     * @param _newLockEndTime new lock end time\r\n     */\r\n    function nonIncreaseCommissionRate(uint256 _newRate, uint256 _newLockEndTime)\r\n        external\r\n        isCandidateInitialized\r\n    {\r\n        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\r\n        require(_newRate <= candidate.commissionRate, 'Invalid new rate');\r\n\r\n        _updateCommissionRate(candidate, _newRate, _newLockEndTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Announce the intent of increasing the commission rate\r\n     * @param _newRate new commission rate\r\n     * @param _newLockEndTime new lock end time\r\n     */\r\n    function announceIncreaseCommissionRate(uint256 _newRate, uint256 _newLockEndTime)\r\n        external\r\n        isCandidateInitialized\r\n    {\r\n        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\r\n        require(candidate.commissionRate < _newRate, 'Invalid new rate');\r\n\r\n        candidate.announcedRate = _newRate;\r\n        candidate.announcedLockEndTime = _newLockEndTime;\r\n        candidate.announcementTime = block.number;\r\n\r\n        emit CommissionRateAnnouncement(msg.sender, _newRate, _newLockEndTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm the intent of increasing the commission rate\r\n     */\r\n    function confirmIncreaseCommissionRate() external isCandidateInitialized {\r\n        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\r\n        require(\r\n            block.number >\r\n                candidate.announcementTime.add(\r\n                    getUIntValue(uint256(ParamNames.AdvanceNoticePeriod))\r\n                ),\r\n            'Still in notice period'\r\n        );\r\n\r\n        _updateCommissionRate(candidate, candidate.announcedRate, candidate.announcedLockEndTime);\r\n\r\n        delete candidate.announcedRate;\r\n        delete candidate.announcedLockEndTime;\r\n        delete candidate.announcementTime;\r\n    }\r\n\r\n    /**\r\n     * @notice update minimal self stake value\r\n     * @param _minSelfStake minimal amount of tokens staked by the validator itself\r\n     */\r\n    function updateMinSelfStake(uint256 _minSelfStake) external isCandidateInitialized {\r\n        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\r\n        if (_minSelfStake < candidate.minSelfStake) {\r\n            require(candidate.status != DPoSCommon.CandidateStatus.Bonded, 'Candidate is bonded');\r\n            candidate.earliestBondTime = block.number.add(\r\n                getUIntValue(uint256(ParamNames.AdvanceNoticePeriod))\r\n            );\r\n        }\r\n        candidate.minSelfStake = _minSelfStake;\r\n        emit UpdateMinSelfStake(msg.sender, _minSelfStake);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate CELR tokens to a candidate\r\n     * @param _candidateAddr candidate to delegate\r\n     * @param _amount the amount of delegated CELR tokens\r\n     */\r\n    function delegate(address _candidateAddr, uint256 _amount)\r\n        external\r\n        whenNotPaused\r\n        onlyNonZeroAddr(_candidateAddr)\r\n        minAmount(_amount, 1 * DECIMALS_MULTIPLIER) // minimal amount per delegate operation is 1 CELR\r\n    {\r\n        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\r\n        require(candidate.initialized, 'Candidate is not initialized');\r\n\r\n        address msgSender = msg.sender;\r\n        _updateDelegatedStake(candidate, _candidateAddr, msgSender, _amount, MathOperation.Add);\r\n\r\n        celerToken.safeTransferFrom(msgSender, address(this), _amount);\r\n\r\n        emit Delegate(msgSender, _candidateAddr, _amount, candidate.stakingPool);\r\n    }\r\n\r\n    /**\r\n     * @notice Candidate claims to become a validator\r\n     */\r\n    function claimValidator() external isCandidateInitialized {\r\n        address msgSender = msg.sender;\r\n        ValidatorCandidate storage candidate = candidateProfiles[msgSender];\r\n        require(\r\n            candidate.status == DPoSCommon.CandidateStatus.Unbonded ||\r\n                candidate.status == DPoSCommon.CandidateStatus.Unbonding,\r\n            'Invalid candidate status'\r\n        );\r\n        require(block.number >= candidate.earliestBondTime, 'Not earliest bond time yet');\r\n        require(\r\n            candidate.stakingPool >= getUIntValue(uint256(ParamNames.MinStakeInPool)),\r\n            'Insufficient staking pool'\r\n        );\r\n        require(\r\n            candidate.delegatorProfiles[msgSender].delegatedStake >= candidate.minSelfStake,\r\n            'Not enough self stake'\r\n        );\r\n\r\n        uint256 minStakingPoolIndex;\r\n        uint256 minStakingPool = candidateProfiles[validatorSet[0]].stakingPool;\r\n        require(validatorSet[0] != msgSender, 'Already in validator set');\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n        for (uint256 i = 1; i < maxValidatorNum; i++) {\r\n            require(validatorSet[i] != msgSender, 'Already in validator set');\r\n            if (candidateProfiles[validatorSet[i]].stakingPool < minStakingPool) {\r\n                minStakingPoolIndex = i;\r\n                minStakingPool = candidateProfiles[validatorSet[i]].stakingPool;\r\n            }\r\n        }\r\n        require(candidate.stakingPool > minStakingPool, 'Not larger than smallest pool');\r\n\r\n        address removedValidator = validatorSet[minStakingPoolIndex];\r\n        if (removedValidator != address(0)) {\r\n            _removeValidator(minStakingPoolIndex);\r\n        }\r\n        _addValidator(msgSender, minStakingPoolIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm candidate status from Unbonding to Unbonded\r\n     * @param _candidateAddr the address of the candidate\r\n     */\r\n    function confirmUnbondedCandidate(address _candidateAddr) external {\r\n        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\r\n        require(\r\n            candidate.status == DPoSCommon.CandidateStatus.Unbonding,\r\n            'Candidate not unbonding'\r\n        );\r\n        require(block.number >= candidate.unbondTime, 'Unbonding time not reached');\r\n\r\n        candidate.status = DPoSCommon.CandidateStatus.Unbonded;\r\n        delete candidate.unbondTime;\r\n        emit CandidateUnbonded(_candidateAddr);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw delegated stakes from an unbonded candidate\r\n     * @dev note that the stakes are delegated by the msgSender to the candidate\r\n     * @param _candidateAddr the address of the candidate\r\n     * @param _amount withdrawn amount\r\n     */\r\n    function withdrawFromUnbondedCandidate(address _candidateAddr, uint256 _amount)\r\n        external\r\n        onlyNonZeroAddr(_candidateAddr)\r\n        minAmount(_amount, 1 * DECIMALS_MULTIPLIER)\r\n    {\r\n        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\r\n        require(\r\n            candidate.status == DPoSCommon.CandidateStatus.Unbonded || isMigrating(),\r\n            'invalid status'\r\n        );\r\n\r\n        address msgSender = msg.sender;\r\n        _updateDelegatedStake(candidate, _candidateAddr, msgSender, _amount, MathOperation.Sub);\r\n        celerToken.safeTransfer(msgSender, _amount);\r\n\r\n        emit WithdrawFromUnbondedCandidate(msgSender, _candidateAddr, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Intend to withdraw delegated stakes from a candidate\r\n     * @dev note that the stakes are delegated by the msgSender to the candidate\r\n     * @param _candidateAddr the address of the candidate\r\n     * @param _amount withdrawn amount\r\n     */\r\n    function intendWithdraw(address _candidateAddr, uint256 _amount)\r\n        external\r\n        onlyNonZeroAddr(_candidateAddr)\r\n        minAmount(_amount, 1 * DECIMALS_MULTIPLIER)\r\n    {\r\n        address msgSender = msg.sender;\r\n\r\n        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\r\n        Delegator storage delegator = candidate.delegatorProfiles[msgSender];\r\n\r\n        _updateDelegatedStake(candidate, _candidateAddr, msgSender, _amount, MathOperation.Sub);\r\n        delegator.undelegatingStake = delegator.undelegatingStake.add(_amount);\r\n        _validateValidator(_candidateAddr);\r\n\r\n        WithdrawIntent storage withdrawIntent = delegator.withdrawIntents[delegator.intentEndIndex];\r\n        withdrawIntent.amount = _amount;\r\n        withdrawIntent.proposedTime = block.number;\r\n        delegator.intentEndIndex++;\r\n\r\n        emit IntendWithdraw(msgSender, _candidateAddr, _amount, withdrawIntent.proposedTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm an intent of withdrawing delegated stakes from a candidate\r\n     * @dev note that the stakes are delegated by the msgSender to the candidate\r\n     * @param _candidateAddr the address of the candidate\r\n     */\r\n    function confirmWithdraw(address _candidateAddr) external onlyNonZeroAddr(_candidateAddr) {\r\n        address msgSender = msg.sender;\r\n        Delegator storage delegator = candidateProfiles[_candidateAddr]\r\n            .delegatorProfiles[msgSender];\r\n\r\n        uint256 slashTimeout = getUIntValue(uint256(ParamNames.SlashTimeout));\r\n        bool isUnbonded = candidateProfiles[_candidateAddr].status ==\r\n            DPoSCommon.CandidateStatus.Unbonded;\r\n        // for all undelegated withdraw intents\r\n        uint256 i;\r\n        for (i = delegator.intentStartIndex; i < delegator.intentEndIndex; i++) {\r\n            if (\r\n                isUnbonded ||\r\n                delegator.withdrawIntents[i].proposedTime.add(slashTimeout) <= block.number\r\n            ) {\r\n                // withdraw intent is undelegated when the validator becomes unbonded or\r\n                // the slashTimeout for the withdraw intent is up.\r\n                delete delegator.withdrawIntents[i];\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        delegator.intentStartIndex = i;\r\n        // for all undelegating withdraw intents\r\n        uint256 undelegatingStakeWithoutSlash;\r\n        for (; i < delegator.intentEndIndex; i++) {\r\n            undelegatingStakeWithoutSlash = undelegatingStakeWithoutSlash.add(\r\n                delegator.withdrawIntents[i].amount\r\n            );\r\n        }\r\n\r\n        uint256 withdrawAmt;\r\n        if (delegator.undelegatingStake > undelegatingStakeWithoutSlash) {\r\n            withdrawAmt = delegator.undelegatingStake.sub(undelegatingStakeWithoutSlash);\r\n            delegator.undelegatingStake = undelegatingStakeWithoutSlash;\r\n\r\n            celerToken.safeTransfer(msgSender, withdrawAmt);\r\n        }\r\n\r\n        emit ConfirmWithdraw(msgSender, _candidateAddr, withdrawAmt);\r\n    }\r\n\r\n    /**\r\n     * @notice Slash a validator and its delegators\r\n     * @param _penaltyRequest penalty request bytes coded in protobuf\r\n     */\r\n    function slash(bytes calldata _penaltyRequest)\r\n        external\r\n        whenNotPaused\r\n        onlyValidDPoS\r\n        onlyNotMigrating\r\n    {\r\n        require(enableSlash, 'Slash is disabled');\r\n        PbSgn.PenaltyRequest memory penaltyRequest = PbSgn.decPenaltyRequest(_penaltyRequest);\r\n        PbSgn.Penalty memory penalty = PbSgn.decPenalty(penaltyRequest.penalty);\r\n\r\n        ValidatorCandidate storage validator = candidateProfiles[penalty.validatorAddress];\r\n        require(validator.status != DPoSCommon.CandidateStatus.Unbonded, 'Validator unbounded');\r\n\r\n        bytes32 h = keccak256(penaltyRequest.penalty);\r\n        require(_checkValidatorSigs(h, penaltyRequest.sigs), 'Validator sigs verification failed');\r\n        require(block.number < penalty.expireTime, 'Penalty expired');\r\n        require(!usedPenaltyNonce[penalty.nonce], 'Used penalty nonce');\r\n        usedPenaltyNonce[penalty.nonce] = true;\r\n\r\n        uint256 totalSubAmt;\r\n        for (uint256 i = 0; i < penalty.penalizedDelegators.length; i++) {\r\n            PbSgn.AccountAmtPair memory penalizedDelegator = penalty.penalizedDelegators[i];\r\n            totalSubAmt = totalSubAmt.add(penalizedDelegator.amt);\r\n            emit Slash(\r\n                penalty.validatorAddress,\r\n                penalizedDelegator.account,\r\n                penalizedDelegator.amt\r\n            );\r\n\r\n            Delegator storage delegator = validator.delegatorProfiles[penalizedDelegator.account];\r\n            uint256 _amt;\r\n            if (delegator.delegatedStake >= penalizedDelegator.amt) {\r\n                _amt = penalizedDelegator.amt;\r\n            } else {\r\n                uint256 remainingAmt = penalizedDelegator.amt.sub(delegator.delegatedStake);\r\n                delegator.undelegatingStake = delegator.undelegatingStake.sub(remainingAmt);\r\n                _amt = delegator.delegatedStake;\r\n            }\r\n            _updateDelegatedStake(\r\n                validator,\r\n                penalty.validatorAddress,\r\n                penalizedDelegator.account,\r\n                _amt,\r\n                MathOperation.Sub\r\n            );\r\n        }\r\n        _validateValidator(penalty.validatorAddress);\r\n\r\n        uint256 totalAddAmt;\r\n        for (uint256 i = 0; i < penalty.beneficiaries.length; i++) {\r\n            PbSgn.AccountAmtPair memory beneficiary = penalty.beneficiaries[i];\r\n            totalAddAmt = totalAddAmt.add(beneficiary.amt);\r\n\r\n            if (beneficiary.account == address(0)) {\r\n                // address(0) stands for miningPool\r\n                miningPool = miningPool.add(beneficiary.amt);\r\n            } else if (beneficiary.account == address(1)) {\r\n                // address(1) means beneficiary is msg sender\r\n                celerToken.safeTransfer(msg.sender, beneficiary.amt);\r\n                emit Compensate(msg.sender, beneficiary.amt);\r\n            } else {\r\n                celerToken.safeTransfer(beneficiary.account, beneficiary.amt);\r\n                emit Compensate(beneficiary.account, beneficiary.amt);\r\n            }\r\n        }\r\n\r\n        require(totalSubAmt == totalAddAmt, 'Amount not match');\r\n    }\r\n\r\n    /**\r\n     * @notice Validate multi-signed message\r\n     * @dev Can't use view here because _checkValidatorSigs is not a view function\r\n     * @param _request a multi-signed message bytes coded in protobuf\r\n     * @return passed the validation or not\r\n     */\r\n    function validateMultiSigMessage(bytes calldata _request)\r\n        external\r\n        onlyRegisteredSidechains\r\n        returns (bool)\r\n    {\r\n        PbSgn.MultiSigMessage memory request = PbSgn.decMultiSigMessage(_request);\r\n        bytes32 h = keccak256(request.msg);\r\n\r\n        return _checkValidatorSigs(h, request.sigs);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the minimum staking pool of all validators\r\n     * @return the minimum staking pool of all validators\r\n     */\r\n    function getMinStakingPool() external view returns (uint256) {\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n\r\n        uint256 minStakingPool = candidateProfiles[validatorSet[0]].stakingPool;\r\n        for (uint256 i = 0; i < maxValidatorNum; i++) {\r\n            if (validatorSet[i] == address(0)) {\r\n                return 0;\r\n            }\r\n            if (candidateProfiles[validatorSet[i]].stakingPool < minStakingPool) {\r\n                minStakingPool = candidateProfiles[validatorSet[i]].stakingPool;\r\n            }\r\n        }\r\n\r\n        return minStakingPool;\r\n    }\r\n\r\n    /**\r\n     * @notice Get candidate info\r\n     * @param _candidateAddr the address of the candidate\r\n     * @return initialized whether initialized or not\r\n     * @return minSelfStake minimum self stakes\r\n     * @return stakingPool staking pool\r\n     * @return status candidate status\r\n     * @return unbondTime unbond time\r\n     * @return commissionRate commission rate\r\n     * @return rateLockEndTime commission rate lock end time\r\n     */\r\n    function getCandidateInfo(address _candidateAddr)\r\n        external\r\n        view\r\n        returns (\r\n            bool initialized,\r\n            uint256 minSelfStake,\r\n            uint256 stakingPool,\r\n            uint256 status,\r\n            uint256 unbondTime,\r\n            uint256 commissionRate,\r\n            uint256 rateLockEndTime\r\n        )\r\n    {\r\n        ValidatorCandidate memory c = candidateProfiles[_candidateAddr];\r\n\r\n        initialized = c.initialized;\r\n        minSelfStake = c.minSelfStake;\r\n        stakingPool = c.stakingPool;\r\n        status = uint256(c.status);\r\n        unbondTime = c.unbondTime;\r\n        commissionRate = c.commissionRate;\r\n        rateLockEndTime = c.rateLockEndTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the delegator info of a specific candidate\r\n     * @param _candidateAddr the address of the candidate\r\n     * @param _delegatorAddr the address of the delegator\r\n     * @return delegatedStake delegated stake to this candidate\r\n     * @return undelegatingStake undelegating stakes\r\n     * @return intentAmounts the amounts of withdraw intents\r\n     * @return intentProposedTimes the proposed times of withdraw intents\r\n     */\r\n    function getDelegatorInfo(address _candidateAddr, address _delegatorAddr)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 delegatedStake,\r\n            uint256 undelegatingStake,\r\n            uint256[] memory intentAmounts,\r\n            uint256[] memory intentProposedTimes\r\n        )\r\n    {\r\n        Delegator storage d = candidateProfiles[_candidateAddr].delegatorProfiles[_delegatorAddr];\r\n\r\n        uint256 len = d.intentEndIndex.sub(d.intentStartIndex);\r\n        intentAmounts = new uint256[](len);\r\n        intentProposedTimes = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            intentAmounts[i] = d.withdrawIntents[i + d.intentStartIndex].amount;\r\n            intentProposedTimes[i] = d.withdrawIntents[i + d.intentStartIndex].proposedTime;\r\n        }\r\n\r\n        delegatedStake = d.delegatedStake;\r\n        undelegatingStake = d.undelegatingStake;\r\n    }\r\n\r\n    /**\r\n     * @notice Check this DPoS contract is valid or not now\r\n     * @return DPoS is valid or not\r\n     */\r\n    function isValidDPoS() public view returns (bool) {\r\n        return\r\n            block.number >= dposGoLiveTime &&\r\n            getValidatorNum() >= getUIntValue(uint256(ParamNames.MinValidatorNum));\r\n    }\r\n\r\n    /**\r\n     * @notice Check the given address is a validator or not\r\n     * @param _addr the address to check\r\n     * @return the given address is a validator or not\r\n     */\r\n    function isValidator(address _addr) public view returns (bool) {\r\n        return candidateProfiles[_addr].status == DPoSCommon.CandidateStatus.Bonded;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the contract is in migrating state\r\n     * @return contract in migrating state or not\r\n     */\r\n    function isMigrating() public view returns (bool) {\r\n        uint256 migrationTime = getUIntValue(uint256(ParamNames.MigrationTime));\r\n        return migrationTime != 0 && block.number >= migrationTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of validators\r\n     * @return the number of validators\r\n     */\r\n    function getValidatorNum() public view returns (uint256) {\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n\r\n        uint256 num;\r\n        for (uint256 i = 0; i < maxValidatorNum; i++) {\r\n            if (validatorSet[i] != address(0)) {\r\n                num++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * @notice Get minimum amount of stakes for a quorum\r\n     * @return the minimum amount\r\n     */\r\n    function getMinQuorumStakingPool() public view returns (uint256) {\r\n        return getTotalValidatorStakingPool().mul(2).div(3).add(1);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of stakes in validators' staking pools\r\n     * @return the total amount\r\n     */\r\n    function getTotalValidatorStakingPool() public view returns (uint256) {\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n\r\n        uint256 totalValidatorStakingPool;\r\n        for (uint256 i = 0; i < maxValidatorNum; i++) {\r\n            totalValidatorStakingPool = totalValidatorStakingPool.add(\r\n                candidateProfiles[validatorSet[i]].stakingPool\r\n            );\r\n        }\r\n\r\n        return totalValidatorStakingPool;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the commission rate of a candidate\r\n     * @param _candidate the candidate to update\r\n     * @param _newRate new commission rate\r\n     * @param _newLockEndTime new lock end time\r\n     */\r\n    function _updateCommissionRate(\r\n        ValidatorCandidate storage _candidate,\r\n        uint256 _newRate,\r\n        uint256 _newLockEndTime\r\n    ) private {\r\n        require(_newRate <= COMMISSION_RATE_BASE, 'Invalid new rate');\r\n        require(_newLockEndTime >= block.number, 'Outdated new lock end time');\r\n\r\n        if (_newRate <= _candidate.commissionRate) {\r\n            require(_newLockEndTime >= _candidate.rateLockEndTime, 'Invalid new lock end time');\r\n        } else {\r\n            require(block.number > _candidate.rateLockEndTime, 'Commission rate is locked');\r\n        }\r\n\r\n        _candidate.commissionRate = _newRate;\r\n        _candidate.rateLockEndTime = _newLockEndTime;\r\n\r\n        emit UpdateCommissionRate(msg.sender, _newRate, _newLockEndTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the delegated stake of a delegator to an candidate\r\n     * @param _candidate the candidate\r\n     * @param _delegatorAddr the delegator address\r\n     * @param _amount update amount\r\n     * @param _op update operation\r\n     */\r\n    function _updateDelegatedStake(\r\n        ValidatorCandidate storage _candidate,\r\n        address _candidateAddr,\r\n        address _delegatorAddr,\r\n        uint256 _amount,\r\n        MathOperation _op\r\n    ) private {\r\n        Delegator storage delegator = _candidate.delegatorProfiles[_delegatorAddr];\r\n\r\n        if (_op == MathOperation.Add) {\r\n            _candidate.stakingPool = _candidate.stakingPool.add(_amount);\r\n            delegator.delegatedStake = delegator.delegatedStake.add(_amount);\r\n        } else if (_op == MathOperation.Sub) {\r\n            _candidate.stakingPool = _candidate.stakingPool.sub(_amount);\r\n            delegator.delegatedStake = delegator.delegatedStake.sub(_amount);\r\n        } else {\r\n            assert(false);\r\n        }\r\n        emit UpdateDelegatedStake(\r\n            _delegatorAddr,\r\n            _candidateAddr,\r\n            delegator.delegatedStake,\r\n            _candidate.stakingPool\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Add a validator\r\n     * @param _validatorAddr the address of the validator\r\n     * @param _setIndex the index to put the validator\r\n     */\r\n    function _addValidator(address _validatorAddr, uint256 _setIndex) private {\r\n        require(validatorSet[_setIndex] == address(0), 'Validator slot occupied');\r\n\r\n        validatorSet[_setIndex] = _validatorAddr;\r\n        candidateProfiles[_validatorAddr].status = DPoSCommon.CandidateStatus.Bonded;\r\n        delete candidateProfiles[_validatorAddr].unbondTime;\r\n        emit ValidatorChange(_validatorAddr, ValidatorChangeType.Add);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a validator\r\n     * @param _setIndex the index of the validator to be removed\r\n     */\r\n    function _removeValidator(uint256 _setIndex) private {\r\n        address removedValidator = validatorSet[_setIndex];\r\n        if (removedValidator == address(0)) {\r\n            return;\r\n        }\r\n\r\n        delete validatorSet[_setIndex];\r\n        candidateProfiles[removedValidator].status = DPoSCommon.CandidateStatus.Unbonding;\r\n        candidateProfiles[removedValidator].unbondTime = block.number.add(\r\n            getUIntValue(uint256(ParamNames.SlashTimeout))\r\n        );\r\n        emit ValidatorChange(removedValidator, ValidatorChangeType.Removal);\r\n    }\r\n\r\n    /**\r\n     * @notice Validate a validator status after stakes change\r\n     * @dev remove this validator if it doesn't meet the requirement of being a validator\r\n     * @param _validatorAddr the validator address\r\n     */\r\n    function _validateValidator(address _validatorAddr) private {\r\n        ValidatorCandidate storage v = candidateProfiles[_validatorAddr];\r\n        if (v.status != DPoSCommon.CandidateStatus.Bonded) {\r\n            // no need to validate the stake of a non-validator\r\n            return;\r\n        }\r\n\r\n        bool lowSelfStake = v.delegatorProfiles[_validatorAddr].delegatedStake < v.minSelfStake;\r\n        bool lowStakingPool = v.stakingPool < getUIntValue(uint256(ParamNames.MinStakeInPool));\r\n\r\n        if (lowSelfStake || lowStakingPool) {\r\n            _removeValidator(_getValidatorIdx(_validatorAddr));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether validators with more than 2/3 total stakes have signed this hash\r\n     * @param _h signed hash\r\n     * @param _sigs signatures\r\n     * @return whether the signatures are valid or not\r\n     */\r\n    function _checkValidatorSigs(bytes32 _h, bytes[] memory _sigs) private returns (bool) {\r\n        uint256 minQuorumStakingPool = getMinQuorumStakingPool();\r\n\r\n        bytes32 hash = _h.toEthSignedMessageHash();\r\n        address[] memory addrs = new address[](_sigs.length);\r\n        uint256 quorumStakingPool;\r\n        bool hasDuplicatedSig;\r\n        for (uint256 i = 0; i < _sigs.length; i++) {\r\n            addrs[i] = hash.recover(_sigs[i]);\r\n            if (checkedValidators[addrs[i]]) {\r\n                hasDuplicatedSig = true;\r\n                break;\r\n            }\r\n            if (candidateProfiles[addrs[i]].status != DPoSCommon.CandidateStatus.Bonded) {\r\n                continue;\r\n            }\r\n\r\n            quorumStakingPool = quorumStakingPool.add(candidateProfiles[addrs[i]].stakingPool);\r\n            checkedValidators[addrs[i]] = true;\r\n        }\r\n\r\n        for (uint256 i = 0; i < _sigs.length; i++) {\r\n            checkedValidators[addrs[i]] = false;\r\n        }\r\n\r\n        return !hasDuplicatedSig && quorumStakingPool >= minQuorumStakingPool;\r\n    }\r\n\r\n    /**\r\n     * @notice Get validator index\r\n     * @param _addr the validator address\r\n     * @return the index of the validator\r\n     */\r\n    function _getValidatorIdx(address _addr) private view returns (uint256) {\r\n        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\r\n\r\n        for (uint256 i = 0; i < maxValidatorNum; i++) {\r\n            if (validatorSet[i] == _addr) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        revert('No such a validator');\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_celerTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_governProposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_governVoteTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slashTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minValidatorNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxValidatorNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minStakeInPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_advanceNoticePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dposGoLiveTimeout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"CandidateUnbonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"announcedRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"announcedLockEndTime\",\"type\":\"uint256\"}],\"name\":\"CommissionRateAnnouncement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indemnitee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Compensate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"record\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"ConfirmParamProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sidechainAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"ConfirmSidechainProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConfirmWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteDeadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"record\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"CreateParamProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteDeadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sidechainAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"CreateSidechainProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingPool\",\"type\":\"uint256\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSelfStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateLockEndTime\",\"type\":\"uint256\"}],\"name\":\"InitializeCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposedTime\",\"type\":\"uint256\"}],\"name\":\"IntendWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"miningPoolSize\",\"type\":\"uint256\"}],\"name\":\"MiningPoolContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"miningPool\",\"type\":\"uint256\"}],\"name\":\"RedeemMiningReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Slash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockEndTime\",\"type\":\"uint256\"}],\"name\":\"UpdateCommissionRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegatorStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"candidatePool\",\"type\":\"uint256\"}],\"name\":\"UpdateDelegatedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSelfStake\",\"type\":\"uint256\"}],\"name\":\"UpdateMinSelfStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ethAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum IDPoS.ValidatorChangeType\",\"name\":\"changeType\",\"type\":\"uint8\"}],\"name\":\"ValidatorChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IGovern.VoteType\",\"name\":\"voteType\",\"type\":\"uint8\"}],\"name\":\"VoteParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IGovern.VoteType\",\"name\":\"voteType\",\"type\":\"uint8\"}],\"name\":\"VoteSidechain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromUnbondedCandidate\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION_RATE_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UIntStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newLockEndTime\",\"type\":\"uint256\"}],\"name\":\"announceIncreaseCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"celerToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"checkedValidators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmIncreaseCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"confirmParamProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"confirmSidechainProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"}],\"name\":\"confirmUnbondedCandidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"}],\"name\":\"confirmWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"contributeToMiningPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_record\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"createParamProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sidechainAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_registered\",\"type\":\"bool\"}],\"name\":\"createSidechainProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dposGoLiveTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"drainToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enableSlash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enableWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"}],\"name\":\"getCandidateInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minSelfStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unbondTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateLockEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegatorAddr\",\"type\":\"address\"}],\"name\":\"getDelegatorInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"undelegatingStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"intentAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"intentProposedTimes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinQuorumStakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinStakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"getParamProposalVote\",\"outputs\":[{\"internalType\":\"enum IGovern.VoteType\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"getSidechainProposalVote\",\"outputs\":[{\"internalType\":\"enum IGovern.VoteType\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalValidatorStakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_record\",\"type\":\"uint256\"}],\"name\":\"getUIntValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidatorNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minSelfStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rateLockEndTime\",\"type\":\"uint256\"}],\"name\":\"initializeCandidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"intendWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMigrating\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sidechainAddr\",\"type\":\"address\"}],\"name\":\"isSidechainRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isValidDPoS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextParamProposalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSidechainProposalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newLockEndTime\",\"type\":\"uint256\"}],\"name\":\"nonIncreaseCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paramProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"record\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"internalType\":\"enum IGovern.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cumulativeReward\",\"type\":\"uint256\"}],\"name\":\"redeemMiningReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemedMiningReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"registerSidechain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredSidechains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sidechainProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDeadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sidechainAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"enum IGovern.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_penaltyRequest\",\"type\":\"bytes\"}],\"name\":\"slash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"updateEnableSlash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"updateEnableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minSelfStake\",\"type\":\"uint256\"}],\"name\":\"updateMinSelfStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedPenaltyNonce\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"}],\"name\":\"validateMultiSigMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorSet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"enum IGovern.VoteType\",\"name\":\"_vote\",\"type\":\"uint8\"}],\"name\":\"voteParam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"enum IGovern.VoteType\",\"name\":\"_vote\",\"type\":\"uint8\"}],\"name\":\"voteSidechain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidateAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromUnbondedCandidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DPoS","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004f9254c83eb525f9fcf346490bbb3ed28a81c66700000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000b00000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000001680","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://aef2876c5e458ffc596a173850af199341a206374ae7650e2aa8d4ce15eec299"}]}