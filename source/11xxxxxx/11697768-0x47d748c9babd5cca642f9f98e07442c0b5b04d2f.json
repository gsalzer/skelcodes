{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/nicklatkovich/pixelplex/riochain/zenterest-price-feed/contracts/contracts/AttoDecimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\nstruct AttoDecimal {\\n    uint256 mantissa;\\n}\\n\\nlibrary AttoDecimalLib {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant BASE = 10;\\n    uint256 internal constant EXPONENTIATION = 18;\\n    uint256 internal constant ONE_MANTISSA = BASE**EXPONENTIATION;\\n    uint256 internal constant SQUARED_ONE_MANTISSA = ONE_MANTISSA * ONE_MANTISSA;\\n\\n    function convert(uint256 integer) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: integer.mul(ONE_MANTISSA)});\\n    }\\n\\n    function add(AttoDecimal memory a, AttoDecimal memory b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mantissa.add(b.mantissa)});\\n    }\\n\\n    function sub(AttoDecimal memory a, uint256 b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mantissa.sub(b.mul(ONE_MANTISSA))});\\n    }\\n\\n    function sub(AttoDecimal memory a, AttoDecimal memory b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mantissa.sub(b.mantissa)});\\n    }\\n\\n    function mul(AttoDecimal memory a, uint256 b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mantissa.mul(b)});\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mul(ONE_MANTISSA).div(b)});\\n    }\\n\\n    function div(uint256 a, AttoDecimal memory b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mul(SQUARED_ONE_MANTISSA).div(b.mantissa)});\\n    }\\n\\n    function div(AttoDecimal memory a, AttoDecimal memory b) internal pure returns (AttoDecimal memory) {\\n        return AttoDecimal({mantissa: a.mantissa.mul(ONE_MANTISSA).div(b.mantissa)});\\n    }\\n\\n    function ceil(AttoDecimal memory a) internal pure returns (uint256) {\\n        return a.mantissa.div(ONE_MANTISSA).add(a.mantissa % ONE_MANTISSA > 0 ? 1 : 0);\\n    }\\n\\n    function floor(AttoDecimal memory a) internal pure returns (uint256) {\\n        return a.mantissa.div(ONE_MANTISSA);\\n    }\\n\\n    function lte(AttoDecimal memory a, AttoDecimal memory b) internal pure returns (bool) {\\n        return a.mantissa <= b.mantissa;\\n    }\\n\\n    function toTuple(AttoDecimal memory a)\\n        internal\\n        pure\\n        returns (\\n            uint256 mantissa,\\n            uint256 base,\\n            uint256 exponentiation\\n        )\\n    {\\n        return (a.mantissa, BASE, EXPONENTIATION);\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/nicklatkovich/pixelplex/riochain/zenterest-price-feed/contracts/contracts/ICorroborativeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ICorroborativeToken is IERC20 {\\n    function decimals() external view returns (uint8);\\n    function underlying() external view returns (address);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"/home/nicklatkovich/pixelplex/riochain/zenterest-price-feed/contracts/contracts/TwoStageOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nabstract contract TwoStageOwnable {\\n    address public nominatedOwner;\\n    address public owner;\\n\\n    event OwnerChanged(address indexed newOwner);\\n    event OwnerNominated(address indexed nominatedOwner);\\n\\n    constructor(address owner_) internal {\\n        require(owner_ != address(0), \\\"Owner cannot be zero address\\\");\\n        _setOwner(owner_);\\n    }\\n\\n    function acceptOwnership() external returns (bool success) {\\n        require(msg.sender == nominatedOwner, \\\"Not nominated to ownership\\\");\\n        _setOwner(nominatedOwner);\\n        nominatedOwner = address(0);\\n        return true;\\n    }\\n\\n    function nominateNewOwner(address owner_) external onlyOwner returns (bool success) {\\n        _nominateNewOwner(owner_);\\n        return true;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Caller not owner\\\");\\n        _;\\n    }\\n\\n    function _nominateNewOwner(address owner_) internal {\\n        nominatedOwner = owner_;\\n        emit OwnerNominated(owner_);\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnerChanged(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/nicklatkovich/pixelplex/riochain/zenterest-price-feed/contracts/contracts/ZenterestPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./AttoDecimal.sol\\\";\\nimport \\\"./ICorroborativeToken.sol\\\";\\nimport \\\"./TwoStageOwnable.sol\\\";\\n\\ncontract ZenterestPriceFeed is TwoStageOwnable {\\n    using AttoDecimalLib for AttoDecimal;\\n\\n    bytes32 internal constant CORROBORATIVE_ETH_SYMBOL_COMPORATOR = keccak256(abi.encodePacked(\\\"zenETH\\\"));\\n\\n    struct Price {\\n        AttoDecimal value;\\n        uint256 updatedAt;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct PriceUpdate {\\n        address token;\\n        uint256 newPriceMantissa;\\n        uint256 updatedAt;\\n    }\\n\\n    struct DelegatedPriceUpdate {\\n        address token;\\n        uint256 newPriceMantissa;\\n        uint256 updatedAt;\\n        Signature signature;\\n    }\\n\\n    address private _reporter;\\n    mapping(address => Price) private _prices;\\n\\n    function reporter() public view returns (address) {\\n        return _reporter;\\n    }\\n\\n    function prices(address token) public view returns (Price memory price) {\\n        return _prices[token];\\n    }\\n\\n    function assetPrices(address token) public view returns (uint256 price) {\\n        return _prices[token].value.mantissa;\\n    }\\n\\n    function getUnderlyingPrice(ICorroborativeToken corroborative) public view returns (uint256) {\\n        if (keccak256(abi.encodePacked(corroborative.symbol())) == CORROBORATIVE_ETH_SYMBOL_COMPORATOR) {\\n            return AttoDecimalLib.ONE_MANTISSA;\\n        }\\n        return assetPrices(corroborative.underlying());\\n    }\\n\\n    event PriceDelegated(\\n        address indexed token,\\n        address indexed submittedBy,\\n        uint256 newPriceMantissa,\\n        uint256 updatedAt,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    );\\n\\n    event PriceUpdated(address indexed token, uint256 newPriceMantissa, uint256 updatedAt);\\n    event ReporterChanged(address reporter);\\n\\n    constructor(address owner_, address reporter_) public TwoStageOwnable(owner_) {\\n        _changeReporter(reporter_);\\n    }\\n\\n    function changeReporter(address newReporterAddress) external onlyOwner returns (bool success) {\\n        _changeReporter(newReporterAddress);\\n        return true;\\n    }\\n\\n    function updateDelegatedPrice(DelegatedPriceUpdate memory update)\\n        external\\n        UpdatingTimeInPast(update.updatedAt)\\n        returns (bool success)\\n    {\\n        _delegatedPriceUpdate(update);\\n        return true;\\n    }\\n\\n    function updateDelegatedPricesBatch(DelegatedPriceUpdate[] memory updates)\\n        external\\n        returns (uint256 updatedPricesCount)\\n    {\\n        uint256 updatesCount = updates.length;\\n        for (uint256 i = 0; i < updatesCount; i++) {\\n            DelegatedPriceUpdate memory update = updates[i];\\n            _checkUpdatingTime(update.updatedAt);\\n            Price storage actualPrice = _prices[update.token];\\n            if (actualPrice.updatedAt >= update.updatedAt) continue;\\n            _delegatedPriceUpdate(update);\\n            updatedPricesCount += 1;\\n        }\\n    }\\n\\n    function updateDelegatedPricesSet(PriceUpdate[] memory updates, Signature memory signature)\\n        external\\n        returns (uint256 updatedPricesCount)\\n    {\\n        uint256 updatesCount = updates.length;\\n        uint256[] memory splittedUpdates = new uint256[](updatesCount * 3);\\n        uint256 pointer = 0;\\n        for (uint256 updateIndex = 0; updateIndex < updatesCount; updateIndex++) {\\n            PriceUpdate memory update = updates[updateIndex];\\n            splittedUpdates[pointer] = uint256(update.token);\\n            splittedUpdates[pointer + 1] = update.newPriceMantissa;\\n            splittedUpdates[pointer + 2] = update.updatedAt;\\n            pointer += 3;\\n        }\\n        bytes memory encodedUpdates = abi.encodePacked(splittedUpdates);\\n        _checkSignerIsReporter(encodedUpdates, signature);\\n        return _updatePricesBatch(updates);\\n    }\\n\\n    function updatePrice(PriceUpdate memory update)\\n        external\\n        UpdatingTimeInPast(update.updatedAt)\\n        returns (bool success)\\n    {\\n        require(msg.sender == _reporter, \\\"Caller not reporter\\\");\\n        _updatePrice(update.token, update.newPriceMantissa, update.updatedAt);\\n        return true;\\n    }\\n\\n    function updatePricesBatch(PriceUpdate[] memory updates) external returns (uint256 updatedPricesCount) {\\n        require(msg.sender == _reporter, \\\"Caller not reporter\\\");\\n        return _updatePricesBatch(updates);\\n    }\\n\\n    function _checkSignerIsReporter(bytes memory data, Signature memory signature) internal view {\\n        bytes32 hash_ = keccak256(data);\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash_));\\n        address signer = ecrecover(prefixedHash, signature.v, signature.r, signature.s);\\n        require(signer == _reporter, \\\"Invalid signature\\\");\\n    }\\n\\n    function _checkUpdatingTime(uint256 updatingTime) internal view {\\n        require(updatingTime <= block.timestamp, \\\"Invalid updating time\\\");\\n    }\\n\\n    function _changeReporter(address newReporterAddress) internal {\\n        if (_reporter == newReporterAddress) return;\\n        _reporter = newReporterAddress;\\n        emit ReporterChanged(newReporterAddress);\\n    }\\n\\n    function _delegatedPriceUpdate(DelegatedPriceUpdate memory update) internal {\\n        bytes memory encodedUpdate = abi.encodePacked(update.token, update.newPriceMantissa, update.updatedAt);\\n        _checkSignerIsReporter(encodedUpdate, update.signature);\\n        emit PriceDelegated(\\n            update.token,\\n            msg.sender,\\n            update.newPriceMantissa,\\n            update.updatedAt,\\n            update.signature.v,\\n            update.signature.r,\\n            update.signature.s\\n        );\\n        _updatePrice(update.token, update.newPriceMantissa, update.updatedAt);\\n    }\\n\\n    function _updatePrice(\\n        address token,\\n        uint256 newPriceMantissa,\\n        uint256 updatedAt\\n    ) internal {\\n        Price storage actualPrice = _prices[token];\\n        uint256 lastUpdatedAt = actualPrice.updatedAt;\\n        require(lastUpdatedAt < updatedAt, \\\"Price already updated\\\");\\n        actualPrice.value = AttoDecimal({mantissa: newPriceMantissa});\\n        actualPrice.updatedAt = updatedAt;\\n        emit PriceUpdated(token, newPriceMantissa, updatedAt);\\n    }\\n\\n    function _updatePricesBatch(PriceUpdate[] memory updates) internal returns (uint256 updatedPricesCount) {\\n        uint256 updatesCount = updates.length;\\n        for (uint256 i = 0; i < updatesCount; i++) {\\n            PriceUpdate memory update = updates[i];\\n            _checkUpdatingTime(update.updatedAt);\\n            Price storage actualPrice = _prices[update.token];\\n            if (actualPrice.updatedAt >= update.updatedAt) continue;\\n            _updatePrice(update.token, update.newPriceMantissa, update.updatedAt);\\n            updatedPricesCount += 1;\\n        }\\n    }\\n\\n    modifier UpdatingTimeInPast(uint256 updatingTime) {\\n        _checkUpdatingTime(updatingTime);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reporter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"submittedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"PriceDelegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reporter\",\"type\":\"address\"}],\"name\":\"ReporterChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"assetPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReporterAddress\",\"type\":\"address\"}],\"name\":\"changeReporter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICorroborativeToken\",\"name\":\"corroborative\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"prices\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"internalType\":\"struct AttoDecimal\",\"name\":\"value\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct ZenterestPriceFeed.Price\",\"name\":\"price\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reporter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ZenterestPriceFeed.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct ZenterestPriceFeed.DelegatedPriceUpdate\",\"name\":\"update\",\"type\":\"tuple\"}],\"name\":\"updateDelegatedPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ZenterestPriceFeed.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct ZenterestPriceFeed.DelegatedPriceUpdate[]\",\"name\":\"updates\",\"type\":\"tuple[]\"}],\"name\":\"updateDelegatedPricesBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedPricesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct ZenterestPriceFeed.PriceUpdate[]\",\"name\":\"updates\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ZenterestPriceFeed.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"updateDelegatedPricesSet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedPricesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct ZenterestPriceFeed.PriceUpdate\",\"name\":\"update\",\"type\":\"tuple\"}],\"name\":\"updatePrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct ZenterestPriceFeed.PriceUpdate[]\",\"name\":\"updates\",\"type\":\"tuple[]\"}],\"name\":\"updatePricesBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedPricesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZenterestPriceFeed","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000401e6af3286d9ec18e82b4cb7aa7e5e2c74eb6d1000000000000000000000000c56bdec94546d9f324762259984356abfd2daee3","EVMVersion":"constantinople","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}