{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/**\\n * @title TRC20 interface\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IPledgeMining.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\ncontract IPledgeMining {\\n    event PledgeEvent(address indexed user, uint256 indexed amount, uint256 indexed day);\\n    event ReceiveIncomeEvent(address indexed user, uint256 indexed amount, uint256 indexed index);\\n    event RemovePledgeEvent(address indexed user, uint256 indexed amount, uint256 indexed index);\\n\\n\\n    function pledge(uint256 _amount, uint256 _type) public returns (uint256);\\n\\n    function calcReceiveIncome(address addr, uint256 _index) public view returns (uint256);\\n\\n    function receiveIncome(uint256 _index) public returns (uint256);\\n\\n    function removePledge(uint256 _index) public returns (uint256);\\n\\n    function closeRenewal(uint256 _index) public;\\n\\n    function openRenewal(uint256 _index) public;\\n\\n    function getUserRecords(address addr, uint256 offset, uint256 size) public view returns (\\n        uint256 [4] memory page,\\n        uint256 [] memory data\\n    );\\n\\n}\"},\"PledgeMining.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./IPledgeMining.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n    address public newOwner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\r\\n\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        newOwner = _newOwner;\\r\\n    }\\r\\n\\r\\n    function acceptOwnership() public {\\r\\n        require(msg.sender == newOwner);\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n        newOwner = address(0);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PledgeMining is IPledgeMining, ReentrancyGuard, Owned {\\r\\n\\r\\n    IERC20  _tokenA;\\r\\n    IERC20  _tokenB;\\r\\n    using TransferHelper for address;\\r\\n    using SafeMath for uint;\\r\\n    uint256 periodUnit = 1 days;\\r\\n    bool public mining_state;\\r\\n\\r\\n    struct Record {\\r\\n        uint256 id;\\r\\n        uint256 createTime;\\r\\n        uint256 stopTime;\\r\\n        uint256 heaven;\\r\\n        uint256 scale;\\r\\n        uint256 pledgeAmount;\\r\\n        uint256 releaseAmount;\\r\\n        uint256 over; // 1 processing 2 over\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e Record []) miningRecords;\\r\\n    mapping(uint256 =\\u003e uint256) public typeConfig;\\r\\n\\r\\n\\r\\n    constructor(address tokenA, address tokenB) public {\\r\\n        _tokenA = IERC20(tokenA);\\r\\n        _tokenB = IERC20(tokenB);\\r\\n\\r\\n        // pledge type config init\\r\\n        typeConfig[uint256(30)] = uint256(5);\\r\\n        typeConfig[uint256(60)] = uint256(12);\\r\\n        typeConfig[uint256(90)] = uint256(21);\\r\\n        typeConfig[uint256(120)] = uint256(32);\\r\\n        typeConfig[uint256(150)] = uint256(45);\\r\\n        typeConfig[uint256(180)] = uint256(60);\\r\\n        mining_state = true;\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Does not accept ETH\\r\\n    function() external payable {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n    modifier mining {\\r\\n        require(mining_state, \\\"PLEDGE:STOP_MINING\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    function stop_mining(uint256 tokenAAmount, uint256 tokenBAmount) public nonReentrant onlyOwner {\\r\\n        if (tokenAAmount \\u003e 0) {\\r\\n            require(address(_tokenA).safeTransfer(msg.sender, tokenAAmount), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n        }\\r\\n        if (tokenBAmount \\u003e 0) {\\r\\n            require(address(_tokenB).safeTransfer(msg.sender, tokenBAmount), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n        }\\r\\n        mining_state = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function pledge(uint256 _amount, uint256 _type) public mining nonReentrant returns (uint256){\\r\\n        require(_amount \\u003e= (10 ** uint(18)), \\\"PLEDGE:AMOUNT_ERROR\\\");\\r\\n        require(typeConfig[_type] != uint256(0), \\\"PLEDGE:TYPE_ERROR\\\");\\r\\n        require(address(_tokenA).safeTransferFrom(msg.sender, address(this), _amount), \\\"PLEDGE:SAFE_TRANSFER_FROM_ERROR\\\");\\r\\n\\r\\n        uint256 scale = typeConfig[_type];\\r\\n        Record [] storage records = miningRecords[msg.sender];\\r\\n        uint256 _id = records.length;\\r\\n        records.push(Record(_id, block.timestamp, 0, _type, scale, _amount, 0, 1));\\r\\n        emit PledgeEvent(msg.sender, _amount, _type);\\r\\n        return _id;\\r\\n    }\\r\\n\\r\\n\\r\\n    function receiveIncomeInternal(uint256 _index) internal returns (uint256){\\r\\n        uint256 income = calcReceiveIncome(msg.sender, _index);\\r\\n        if (income \\u003e 0) {\\r\\n            Record storage r = miningRecords[msg.sender][_index];\\r\\n            r.releaseAmount = r.releaseAmount.add(income);\\r\\n            require(address(_tokenB).safeTransfer(msg.sender, income), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n            emit ReceiveIncomeEvent(msg.sender, income, _index);\\r\\n        }\\r\\n        return (income);\\r\\n    }\\r\\n\\r\\n    function closeRenewal(uint256 _index) public nonReentrant {\\r\\n        Record storage r = miningRecords[msg.sender][_index];\\r\\n        require(r.over == uint256(1) \\u0026\\u0026 r.stopTime == uint256(0), \\\"PLEDGE:UNABLE_TO_CLOSE_RENEWAL\\\");\\r\\n        r.stopTime = block.timestamp.sub(r.createTime)\\r\\n        .div(r.heaven.mul(periodUnit)).add(1)\\r\\n        .mul(r.heaven.mul(periodUnit)).add(r.createTime);\\r\\n    }\\r\\n\\r\\n    function openRenewal(uint256 _index) public nonReentrant {\\r\\n        Record storage r = miningRecords[msg.sender][_index];\\r\\n        require(r.over == uint256(1) \\u0026\\u0026 r.stopTime \\u003e 0 \\u0026\\u0026 block.timestamp \\u003c r.stopTime, \\\"PLEDGE:UNABLE_TO_OPEN_RENEWAL\\\");\\r\\n        r.stopTime = uint256(0);\\r\\n    }\\r\\n\\r\\n\\r\\n    function receiveIncome(uint256 _index) public nonReentrant returns (uint256){\\r\\n        uint256 income = receiveIncomeInternal(_index);\\r\\n        require(income \\u003e 0, \\\"PLEDGE:NO_EXTRA_INCOME\\\");\\r\\n        return (income);\\r\\n    }\\r\\n\\r\\n    function removePledge(uint256 _index) public nonReentrant returns (uint256){\\r\\n        Record storage r = miningRecords[msg.sender][_index];\\r\\n        require(r.over == uint256(1) \\u0026\\u0026 r.stopTime \\u003e 0 \\u0026\\u0026 block.timestamp \\u003e= r.stopTime, \\\"PLEDGE:NOT_EXPIRED\\\");\\r\\n        uint256 income = receiveIncomeInternal(_index);\\r\\n        require(address(_tokenA).safeTransfer(msg.sender, r.pledgeAmount), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n        r.over = uint256(2);\\r\\n        emit RemovePledgeEvent(msg.sender, r.pledgeAmount, _index);\\r\\n        return (income);\\r\\n    }\\r\\n\\r\\n\\r\\n    function calcReceiveIncome(address addr, uint256 _index) public view returns (uint256){\\r\\n        Record storage r = miningRecords[addr][_index];\\r\\n        require(r.over == uint256(1), \\\"PLEDGE:RECORD_OVER\\\");\\r\\n\\r\\n        uint256 oneTotal = r.pledgeAmount.mul(r.scale).div(uint256(1000));\\r\\n        uint256 _income = oneTotal.mul(block.timestamp.sub(r.createTime)).div(r.heaven.mul(periodUnit));\\r\\n        if (r.stopTime \\u003e 0) {\\r\\n            uint256 _total = oneTotal\\r\\n            .mul(r.stopTime.sub(r.createTime).div(r.heaven.mul(periodUnit)));\\r\\n            if (_income \\u003e _total) {\\r\\n                _income = _total;\\r\\n            }\\r\\n        }\\r\\n        _income = _income.sub(r.releaseAmount);\\r\\n\\r\\n\\r\\n        uint256 _balance = _tokenB.balanceOf(address(this));\\r\\n        if (_income \\u003e 0 \\u0026\\u0026 _income \\u003e _balance) {\\r\\n            _income = _balance;\\r\\n        }\\r\\n\\r\\n        return (_income);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getTokens() public view returns (address, address){\\r\\n        return (address(_tokenA), address(_tokenB));\\r\\n    }\\r\\n\\r\\n\\r\\n    function getUserRecords(address addr, uint256 offset, uint256 size) public view returns (\\r\\n        uint256 [4] memory page,\\r\\n        uint256 [] memory data\\r\\n    ){\\r\\n        require(offset \\u003e= 0);\\r\\n        require(size \\u003e 0);\\r\\n        Record [] storage records = miningRecords[addr];\\r\\n        uint256 lrSize = records.length;\\r\\n        uint256 len = 0;\\r\\n        uint256 prop_count = 8;\\r\\n        if (size \\u003e lrSize) {\\r\\n            size = lrSize;\\r\\n        }\\r\\n        data = new uint256[](size * prop_count);\\r\\n        if (lrSize == 0 || offset \\u003e (lrSize - 1)) {\\r\\n            return ([len, block.timestamp, lrSize, prop_count], data);\\r\\n        }\\r\\n        uint256 i = lrSize - 1 - offset;\\r\\n        uint256 iMax = 0;\\r\\n        if (offset \\u003c= (lrSize - size)) {\\r\\n            iMax = lrSize - size - offset;\\r\\n        }\\r\\n        while (i \\u003e= 0 \\u0026\\u0026 i \\u003e= iMax) {\\r\\n            Record memory r = records[i];\\r\\n            data[len * prop_count + 0] = r.id;\\r\\n            data[len * prop_count + 1] = r.createTime;\\r\\n            data[len * prop_count + 2] = r.stopTime;\\r\\n            data[len * prop_count + 3] = r.heaven;\\r\\n            data[len * prop_count + 4] = r.scale;\\r\\n            data[len * prop_count + 5] = r.pledgeAmount;\\r\\n            data[len * prop_count + 6] = r.releaseAmount;\\r\\n            data[len * prop_count + 7] = r.over;\\r\\n            len = len + 1;\\r\\n            if (i == 0) {\\r\\n                break;\\r\\n            }\\r\\n            i--;\\r\\n        }\\r\\n        return ([len, block.timestamp, lrSize, prop_count], data);\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction\\u0027s gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        _notEntered = true;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath#mul: OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"SafeMath#div: DIVISION_BY_ZERO\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath#sub: UNDERFLOW\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath#add: OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n     * reverts when dividing by zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath#mod: DIVISION_BY_ZERO\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"TransferHelper.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\nlibrary TransferHelper {\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal returns (bool){\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        return (success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal returns (bool){\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        return (success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"PledgeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ReceiveIncomeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"RemovePledgeEvent\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"calcReceiveIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"closeRenewal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRecords\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"page\",\"type\":\"uint256[4]\"},{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mining_state\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"openRenewal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"pledge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"receiveIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removePledge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"name\":\"stop_mining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"typeConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PledgeMining","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000071fbc1d795fcfbca43a3ebf6de0101952f31a41000000000000000000000000056aa2f35ad4bf936a144d193b43fcc0f27b16f5b","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f62d09a1f76891f655985e0d6ecc6c64c98e1aa72207d4b8fc6021c1b82b5a01"}]}