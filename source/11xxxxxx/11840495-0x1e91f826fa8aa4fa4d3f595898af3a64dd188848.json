{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.0;\r\npragma abicoder v2;\r\n\r\n\r\ninterface IPlatformIntegration {\r\n    /**\r\n     * @dev Deposit the given bAsset to Lending platform\r\n     * @param _bAsset bAsset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool isTokenFeeCharged\r\n    ) external returns (uint256 quantityDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        uint256 _totalAmount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from the cache\r\n     */\r\n    function withdrawRaw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given bAsset\r\n     */\r\n    function checkBalance(address _bAsset) external returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the pToken\r\n     */\r\n    function bAssetToPToken(address _bAsset) external returns (address pToken);\r\n}\r\n\r\ninterface MassetStructs {\r\n    struct BassetPersonal {\r\n        // Address of the bAsset\r\n        address addr;\r\n        // Address of the bAsset\r\n        address integrator;\r\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n        bool hasTxFee; // takes a byte in storage\r\n        // Status of the bAsset\r\n        BassetStatus status;\r\n    }\r\n\r\n    struct BassetData {\r\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n        uint128 ratio;\r\n        // Amount of the Basset that is held in Collateral\r\n        uint128 vaultBalance;\r\n    }\r\n\r\n    // Status of the Basset - has it broken its peg?\r\n    enum BassetStatus {\r\n        Default,\r\n        Normal,\r\n        BrokenBelowPeg,\r\n        BrokenAbovePeg,\r\n        Blacklisted,\r\n        Liquidating,\r\n        Liquidated,\r\n        Failed\r\n    }\r\n\r\n    struct BasketState {\r\n        bool undergoingRecol;\r\n        bool failed;\r\n    }\r\n\r\n    struct InvariantConfig {\r\n        uint256 a;\r\n        WeightLimits limits;\r\n    }\r\n\r\n    struct WeightLimits {\r\n        uint128 min;\r\n        uint128 max;\r\n    }\r\n\r\n    struct AmpData {\r\n        uint64 initialA;\r\n        uint64 targetA;\r\n        uint64 rampStartTime;\r\n        uint64 rampEndTime;\r\n    }\r\n}\r\n\r\nabstract contract IInvariantValidator is MassetStructs {\r\n    // Mint\r\n    function computeMint(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _rawInput,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    function computeMintMulti(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawInputs,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    // Swap\r\n    function computeSwap(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint8 _o,\r\n        uint256 _rawInput,\r\n        uint256 _feeRate,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256, uint256);\r\n\r\n    // Redeem\r\n    function computeRedeem(\r\n        BassetData[] calldata _bAssets,\r\n        uint8 _i,\r\n        uint256 _mAssetQuantity,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n\r\n    function computeRedeemExact(\r\n        BassetData[] calldata _bAssets,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _rawOutputs,\r\n        InvariantConfig memory _config\r\n    ) external view virtual returns (uint256);\r\n}\r\n\r\ninterface IBasicToken {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e38 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x * ratio;\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled + RATIO_SCALE - 1;\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil / RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        // return 1e22 / 1e12 = 1e10\r\n        return (x * RATIO_SCALE) / ratio;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\nlibrary MassetHelpers {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function transferReturnBalance(\r\n        address _sender,\r\n        address _recipient,\r\n        address _bAsset,\r\n        uint256 _qty\r\n    ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\r\n        uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\r\n        IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\r\n        recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\r\n        receivedQty = recipientBalance - balBefore;\r\n    }\r\n\r\n    function safeInfiniteApprove(address _asset, address _spender) internal {\r\n        IERC20(_asset).safeApprove(_spender, 0);\r\n        IERC20(_asset).safeApprove(_spender, 2**256 - 1);\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n// External\r\n// Internal\r\n// Libs\r\n/**\r\n * @title   Manager\r\n * @author  mStable\r\n * @notice  Simply contains logic to perform Basket Manager duties for an mAsset.\r\n *          Allowing logic can be abstracted here to avoid bytecode inflation.\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2021-01-22\r\n */\r\nlibrary Manager {\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\r\n    event TransferFeeEnabled(address indexed bAsset, bool enabled);\r\n    event BassetAdded(address indexed bAsset, address integrator);\r\n    event BassetStatusChanged(address indexed bAsset, MassetStructs.BassetStatus status);\r\n    event BasketStatusChanged();\r\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    uint256 private constant MIN_RAMP_TIME = 1 days;\r\n    uint256 private constant MAX_A = 1e6;\r\n\r\n    /**\r\n     * @notice Adds a bAsset to the given personal, data and mapping, provided it is valid\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssetData       Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _maxBassets       Max size of the basket\r\n     * @param _bAsset           Address of the ERC20 token to add to the Basket\r\n     * @param _integration      Address of the Platform Integration\r\n     * @param _mm               Base 1e8 var to determine measurement ratio\r\n     * @param _hasTxFee         Are transfer fees charged on this bAsset (e.g. USDT)\r\n     */\r\n    function addBasset(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        MassetStructs.BassetData[] storage _bAssetData,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        uint8 _maxBassets,\r\n        address _bAsset,\r\n        address _integration,\r\n        uint256 _mm,\r\n        bool _hasTxFee\r\n    ) external {\r\n        require(_bAsset != address(0), \"bAsset address must be valid\");\r\n        uint8 bAssetCount = uint8(_bAssetPersonal.length);\r\n        require(bAssetCount < _maxBassets, \"Max bAssets in Basket\");\r\n\r\n        uint8 idx = _bAssetIndexes[_bAsset];\r\n        require(\r\n            bAssetCount == 0 || _bAssetPersonal[idx].addr != _bAsset,\r\n            \"bAsset already exists in Basket\"\r\n        );\r\n\r\n        // Should fail if bAsset is not added to integration\r\n        // Programmatic enforcement of bAsset validity should service through decentralised feed\r\n        if (_integration != address(0)) {\r\n            IPlatformIntegration(_integration).checkBalance(_bAsset);\r\n        }\r\n\r\n        uint256 bAssetDecimals = IBasicToken(_bAsset).decimals();\r\n        require(\r\n            bAssetDecimals >= 4 && bAssetDecimals <= 18,\r\n            \"Token must have sufficient decimal places\"\r\n        );\r\n\r\n        uint256 delta = uint256(18) - bAssetDecimals;\r\n        uint256 ratio = _mm * (10**delta);\r\n\r\n        _bAssetIndexes[_bAsset] = bAssetCount;\r\n\r\n        _bAssetPersonal.push(\r\n            MassetStructs.BassetPersonal({\r\n                addr: _bAsset,\r\n                integrator: _integration,\r\n                hasTxFee: _hasTxFee,\r\n                status: MassetStructs.BassetStatus.Normal\r\n            })\r\n        );\r\n        _bAssetData.push(\r\n            MassetStructs.BassetData({ ratio: SafeCast.toUint128(ratio), vaultBalance: 0 })\r\n        );\r\n\r\n        emit BassetAdded(_bAsset, _integration);\r\n    }\r\n\r\n    /**\r\n     * @dev Collects the interest generated from the Basket, minting a relative\r\n     *      amount of mAsset and sending it over to the SavingsManager.\r\n     * @param _bAssetPersonal   Basset personal storage array\r\n     * @param _bAssetData       Basset data storage array\r\n     * @param _forgeValidator   Link to the current InvariantValidator\r\n     * @return mintAmount       Lending market interest collected\r\n     * @return rawGains         Raw increases in vault Balance\r\n     */\r\n    function collectPlatformInterest(\r\n        MassetStructs.BassetPersonal[] memory _bAssetPersonal,\r\n        MassetStructs.BassetData[] storage _bAssetData,\r\n        IInvariantValidator _forgeValidator,\r\n        MassetStructs.InvariantConfig memory _config\r\n    ) external returns (uint256 mintAmount, uint256[] memory rawGains) {\r\n        // Get basket details\r\n        MassetStructs.BassetData[] memory bAssetData_ = _bAssetData;\r\n        uint256 count = bAssetData_.length;\r\n        uint8[] memory indices = new uint8[](count);\r\n        rawGains = new uint256[](count);\r\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\r\n        for (uint256 i = 0; i < count; i++) {\r\n            indices[i] = uint8(i);\r\n            MassetStructs.BassetPersonal memory bPersonal = _bAssetPersonal[i];\r\n            MassetStructs.BassetData memory bData = bAssetData_[i];\r\n            // If there is no integration, then nothing can have accrued\r\n            if (bPersonal.integrator == address(0)) continue;\r\n            uint256 lending =\r\n                IPlatformIntegration(bPersonal.integrator).checkBalance(bPersonal.addr);\r\n            uint256 cache = 0;\r\n            if (!bPersonal.hasTxFee) {\r\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\r\n            }\r\n            uint256 balance = lending + cache;\r\n            uint256 oldVaultBalance = bData.vaultBalance;\r\n            if (\r\n                balance > oldVaultBalance && bPersonal.status == MassetStructs.BassetStatus.Normal\r\n            ) {\r\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\r\n                uint256 interestDelta = balance - oldVaultBalance;\r\n                rawGains[i] = interestDelta;\r\n            } else {\r\n                rawGains[i] = 0;\r\n            }\r\n        }\r\n        mintAmount = _forgeValidator.computeMintMulti(bAssetData_, indices, rawGains, _config);\r\n    }\r\n\r\n    /**\r\n     * @dev Update transfer fee flag for a given bAsset, should it change its fee practice\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _bAsset   bAsset address\r\n     * @param _flag         Charge transfer fee when its set to 'true', otherwise 'false'\r\n     */\r\n    function setTransferFeesFlag(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _bAsset,\r\n        bool _flag\r\n    ) external {\r\n        uint256 index = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\r\n        _bAssetPersonal[index].hasTxFee = _flag;\r\n\r\n        if (_flag) {\r\n            // if token has tx fees, it can no longer operate with a cache\r\n            address integration = _bAssetPersonal[index].integrator;\r\n            if (integration != address(0)) {\r\n                uint256 bal = IERC20(_bAsset).balanceOf(integration);\r\n                if (bal > 0) {\r\n                    IPlatformIntegration(integration).deposit(_bAsset, bal, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        emit TransferFeeEnabled(_bAsset, _flag);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers all collateral from one lending market to another - used initially\r\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\r\n     *      tx fee enabled assets. Supports going from no integration to integration, but\r\n     *      not the other way around.\r\n     * @param _bAssetPersonal   Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _bAssets          Array of basket assets to migrate\r\n     * @param _newIntegration   Address of the new platform integration\r\n     */\r\n    function migrateBassets(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address[] calldata _bAssets,\r\n        address _newIntegration\r\n    ) external {\r\n        uint256 len = _bAssets.length;\r\n        require(len > 0, \"Must migrate some bAssets\");\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // 1. Check that the bAsset is in the basket\r\n            address bAsset = _bAssets[i];\r\n            uint256 index = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, bAsset);\r\n            require(!_bAssetPersonal[index].hasTxFee, \"A bAsset has a transfer fee\");\r\n\r\n            // 2. Withdraw everything from the old platform integration\r\n            address oldAddress = _bAssetPersonal[index].integrator;\r\n            require(oldAddress != _newIntegration, \"Must transfer to new integrator\");\r\n            (uint256 cache, uint256 lendingBal) = (0, 0);\r\n            if (oldAddress == address(0)) {\r\n                cache = IERC20(bAsset).balanceOf(address(this));\r\n            } else {\r\n                IPlatformIntegration oldIntegration = IPlatformIntegration(oldAddress);\r\n                cache = IERC20(bAsset).balanceOf(address(oldIntegration));\r\n                // 2.1. Withdraw from the lending market\r\n                lendingBal = oldIntegration.checkBalance(bAsset);\r\n                if (lendingBal > 0) {\r\n                    oldIntegration.withdraw(address(this), bAsset, lendingBal, false);\r\n                }\r\n                // 2.2. Withdraw from the cache, if any\r\n                if (cache > 0) {\r\n                    oldIntegration.withdrawRaw(address(this), bAsset, cache);\r\n                }\r\n            }\r\n            uint256 sum = lendingBal + cache;\r\n\r\n            // 3. Update the integration address for this bAsset\r\n            _bAssetPersonal[index].integrator = _newIntegration;\r\n\r\n            // 4. Deposit everything into the new\r\n            //    This should fail if we did not receive the full amount from the platform withdrawal\r\n            // 4.1. Deposit all bAsset\r\n            IERC20(bAsset).safeTransfer(_newIntegration, sum);\r\n            IPlatformIntegration newIntegration = IPlatformIntegration(_newIntegration);\r\n            if (lendingBal > 0) {\r\n                newIntegration.deposit(bAsset, lendingBal, false);\r\n            }\r\n            // 4.2. Check balances\r\n            uint256 newLendingBal = newIntegration.checkBalance(bAsset);\r\n            uint256 newCache = IERC20(bAsset).balanceOf(address(newIntegration));\r\n            uint256 upperMargin = 10001e14;\r\n            uint256 lowerMargin = 9999e14;\r\n\r\n            require(\r\n                newLendingBal >= lendingBal.mulTruncate(lowerMargin) &&\r\n                    newLendingBal <= lendingBal.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n            require(\r\n                newCache >= cache.mulTruncate(lowerMargin) &&\r\n                    newCache <= cache.mulTruncate(upperMargin),\r\n                \"Must transfer full amount\"\r\n            );\r\n        }\r\n\r\n        emit BassetsMigrated(_bAssets, _newIntegration);\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the Auto Redistribution event by isolating the bAsset from the Basket\r\n     * @param _basket          Struct containing core basket info\r\n     * @param _bAssetPersonal  Basset data storage array\r\n     * @param _bAsset          Address of the ERC20 token to isolate\r\n     * @param _belowPeg        Bool to describe whether the bAsset deviated below peg (t)\r\n     *                         or above (f)\r\n     */\r\n    function handlePegLoss(\r\n        MassetStructs.BasketState storage _basket,\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _bAsset,\r\n        bool _belowPeg\r\n    ) external {\r\n        require(!_basket.failed, \"Basket must be alive\");\r\n\r\n        uint256 i = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\r\n\r\n        MassetStructs.BassetStatus newStatus =\r\n            _belowPeg\r\n                ? MassetStructs.BassetStatus.BrokenBelowPeg\r\n                : MassetStructs.BassetStatus.BrokenAbovePeg;\r\n        _bAssetPersonal[i].status = newStatus;\r\n\r\n        _basket.undergoingRecol = true;\r\n\r\n        emit BassetStatusChanged(_bAsset, newStatus);\r\n    }\r\n\r\n    /**\r\n     * @dev Negates the isolation of a given bAsset\r\n     * @param _basket          Struct containing core basket info\r\n     * @param _bAssetPersonal  Basset data storage array\r\n     * @param _bAssetIndexes    Mapping of bAsset address to their index\r\n     * @param _bAsset Address of the bAsset\r\n     */\r\n    function negateIsolation(\r\n        MassetStructs.BasketState storage _basket,\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _bAsset\r\n    ) external {\r\n        uint256 i = _getAssetIndex(_bAssetPersonal, _bAssetIndexes, _bAsset);\r\n\r\n        _bAssetPersonal[i].status = MassetStructs.BassetStatus.Normal;\r\n\r\n        bool undergoingRecol = false;\r\n        for (uint256 j = 0; j < _bAssetPersonal.length; j++) {\r\n            if (_bAssetPersonal[j].status != MassetStructs.BassetStatus.Normal) {\r\n                undergoingRecol = true;\r\n                break;\r\n            }\r\n        }\r\n        _basket.undergoingRecol = undergoingRecol;\r\n\r\n        emit BassetStatusChanged(_bAsset, MassetStructs.BassetStatus.Normal);\r\n    }\r\n\r\n    /**\r\n     * @dev Starts changing of the amplification var A\r\n     * @param _targetA      Target A value\r\n     * @param _rampEndTime  Time at which A will arrive at _targetA\r\n     */\r\n    function startRampA(\r\n        MassetStructs.AmpData storage _ampData,\r\n        uint256 _targetA,\r\n        uint256 _rampEndTime,\r\n        uint256 _currentA,\r\n        uint256 _precision\r\n    ) external {\r\n        require(\r\n            block.timestamp >= (_ampData.rampStartTime + MIN_RAMP_TIME),\r\n            \"Sufficient period of previous ramp has not elapsed\"\r\n        );\r\n        require(_rampEndTime >= (block.timestamp + MIN_RAMP_TIME), \"Ramp time too short\");\r\n        require(_targetA > 0 && _targetA < MAX_A, \"A target out of bounds\");\r\n\r\n        uint256 preciseTargetA = _targetA * _precision;\r\n\r\n        if (preciseTargetA > _currentA) {\r\n            require(preciseTargetA <= _currentA * 10, \"A target increase too big\");\r\n        } else {\r\n            require(preciseTargetA >= _currentA / 10, \"A target decrease too big\");\r\n        }\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(preciseTargetA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(_rampEndTime);\r\n\r\n        emit StartRampA(_currentA, preciseTargetA, block.timestamp, _rampEndTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Stops the changing of the amplification var A, setting\r\n     * it to whatever the current value is.\r\n     */\r\n    function stopRampA(MassetStructs.AmpData storage _ampData, uint256 _currentA) external {\r\n        require(block.timestamp < _ampData.rampEndTime, \"Amplification not changing\");\r\n\r\n        _ampData.initialA = SafeCast.toUint64(_currentA);\r\n        _ampData.targetA = SafeCast.toUint64(_currentA);\r\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\r\n        _ampData.rampEndTime = SafeCast.toUint64(block.timestamp);\r\n\r\n        emit StopRampA(_currentA, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets a bAsset index from storage\r\n     * @param _asset      Address of the asset\r\n     * @return idx        Index of the asset\r\n     */\r\n    function _getAssetIndex(\r\n        MassetStructs.BassetPersonal[] storage _bAssetPersonal,\r\n        mapping(address => uint8) storage _bAssetIndexes,\r\n        address _asset\r\n    ) internal view returns (uint8 idx) {\r\n        idx = _bAssetIndexes[_asset];\r\n        require(_bAssetPersonal[idx].addr == _asset, \"Invalid asset input\");\r\n    }\r\n\r\n    /***************************************\r\n                    FORGING\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Deposits a given asset to the system. If there is sufficient room for the asset\r\n     * in the cache, then just transfer, otherwise reset the cache to the desired mid level by\r\n     * depositing the delta in the platform\r\n     */\r\n    function depositTokens(\r\n        MassetStructs.BassetPersonal memory _bAsset,\r\n        uint256 _bAssetRatio,\r\n        uint256 _quantity,\r\n        uint256 _maxCache\r\n    ) external returns (uint256 quantityDeposited) {\r\n        // 0. If integration is 0, short circuit\r\n        if (_bAsset.integrator == address(0)) {\r\n            (uint256 received, ) =\r\n                MassetHelpers.transferReturnBalance(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _bAsset.addr,\r\n                    _quantity\r\n                );\r\n            return received;\r\n        }\r\n\r\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\r\n        uint256 cacheBal;\r\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\r\n            msg.sender,\r\n            _bAsset.integrator,\r\n            _bAsset.addr,\r\n            _quantity\r\n        );\r\n\r\n        // 2 - Deposit X if necessary\r\n        // 2.1 - Deposit if xfer fees\r\n        if (_bAsset.hasTxFee) {\r\n            uint256 deposited =\r\n                IPlatformIntegration(_bAsset.integrator).deposit(\r\n                    _bAsset.addr,\r\n                    quantityDeposited,\r\n                    true\r\n                );\r\n\r\n            return StableMath.min(deposited, quantityDeposited);\r\n        }\r\n        // 2.2 - Else Deposit X if Cache > %\r\n        // This check is in place to ensure that any token with a txFee is rejected\r\n        require(quantityDeposited == _quantity, \"Asset not fully transferred\");\r\n\r\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\r\n\r\n        if (cacheBal > relativeMaxCache) {\r\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\r\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws a given asset from its platformIntegration. If there is sufficient liquidity\r\n     * in the cache, then withdraw from there, otherwise withdraw from the lending market and reset the\r\n     * cache to the mid level.\r\n     */\r\n    function withdrawTokens(\r\n        uint256 _quantity,\r\n        MassetStructs.BassetPersonal memory _personal,\r\n        MassetStructs.BassetData memory _data,\r\n        address _recipient,\r\n        uint256 _maxCache\r\n    ) external {\r\n        if (_quantity == 0) return;\r\n\r\n        // 1.0 If there is no integrator, send from here\r\n        if (_personal.integrator == address(0)) {\r\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\r\n        }\r\n        // 1.1 If txFee then short circuit - there is no cache\r\n        else if (_personal.hasTxFee) {\r\n            IPlatformIntegration(_personal.integrator).withdraw(\r\n                _recipient,\r\n                _personal.addr,\r\n                _quantity,\r\n                _quantity,\r\n                true\r\n            );\r\n        }\r\n        // 1.2. Else, withdraw from either cache or main vault\r\n        else {\r\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\r\n            // 2.1 - If balance b in cache, simply withdraw\r\n            if (cacheBal >= _quantity) {\r\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity\r\n                );\r\n            }\r\n            // 2.2 - Else reset the cache to X, or as far as possible\r\n            //       - Withdraw X+b from platform\r\n            //       - Send b to user\r\n            else {\r\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\r\n                uint256 totalWithdrawal =\r\n                    StableMath.min(\r\n                        relativeMidCache + _quantity - cacheBal,\r\n                        _data.vaultBalance - SafeCast.toUint128(cacheBal)\r\n                    );\r\n\r\n                IPlatformIntegration(_personal.integrator).withdraw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity,\r\n                    totalWithdrawal,\r\n                    false\r\n                );\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[],\"name\":\"BasketStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"}],\"name\":\"BassetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum MassetStructs.BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"BassetStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"bAssets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newIntegrator\",\"type\":\"address\"}],\"name\":\"BassetsMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rampEndTime\",\"type\":\"uint256\"}],\"name\":\"StartRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TransferFeeEnabled\",\"type\":\"event\"}]","ContractName":"Manager","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6b29cc07d32594531dfd598a183a66cd2905cfe646691e3e0c2899e605f8c189"}]}