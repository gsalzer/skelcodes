{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/stack/work/unioption/contracts/OptionChef.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IOptions.sol\\\";\\nimport \\\"./interfaces/IUniOption.sol\\\";\\n\\n/**\\n * @author ivan@district0x\\n * @title Option factory aka Mighty Option Chef\\n * @notice Option Chef has the monopoly to mint and destroy NFT UniOptions\\n */\\ncontract OptionChef is Ownable {\\n\\n    //storage\\n\\n    IHegicOptions public hegicOption;\\n    IUniOption public uniOption;\\n\\n    //ideally this should've been a mapping/arr of id->Struct {owner, id}\\n    //there are a few EVM gotchas for this (afaik one can't peek into\\n    //mapped structs from another contracts, happy to restructure if I'm wrong though)\\n    uint256[] uIds;\\n    uint256[] ids;\\n\\n    //events\\n\\n    event Wrapped(address account, uint optionId);\\n    event Unwrapped(address account, uint tokenId);\\n\\n\\n    //utility functions\\n\\n    function updateHegicOption(IHegicOptions _hegicOption)\\n        external\\n        onlyOwner {\\n        hegicOption = _hegicOption ;\\n    }\\n\\n    function updateUniOption(IUniOption _uniOption)\\n        external\\n        onlyOwner {\\n        uniOption = _uniOption;\\n    }\\n\\n    constructor(IHegicOptions _hegicOption) public {\\n        hegicOption = _hegicOption ;\\n    }\\n\\n\\n    //core (un)wrap functionality\\n\\n\\n    /**\\n     * @notice UniOption wrapper adapter for Hegic\\n     */\\n    function wrapHegic(uint _uId) public returns (uint newTokenId) {\\n        require(ids[_uId] == 0 , \\\"UOPT:exists\\\");\\n        (, address holder, , , , , , ) = hegicOption.options(_uId);\\n        //auth is a bit unintuitive for wrapping, see NFT.sol:isApprovedOrOwner()\\n        require(holder == msg.sender, \\\"UOPT:ownership\\\");\\n        newTokenId = uniOption.mintUniOption(msg.sender);\\n        uIds[newTokenId] = _uId;\\n        ids[_uId] = newTokenId;\\n        emit Wrapped(msg.sender, _uId);\\n    }\\n\\n    /**\\n     * @notice UniOption unwrapper adapter for Hegic\\n     * @notice check burning logic, do we really want to burn it (vs meta)\\n     * @notice TODO recheck escrow mechanism on 0x relay to prevent unwrapping when locked\\n     */\\n    function unwrapHegic(uint _tokenId) external onlyTokenOwner(_tokenId) {\\n        // checks if hegicOption will allow to transfer option ownership\\n        (IHegicOptions.State state, , , , , , uint expiration , ) = getUnderlyingOptionParams(_tokenId);\\n        if (state == IHegicOptions.State.Active || expiration >= block.timestamp) {\\n            hegicOption.transfer(uIds[_tokenId], msg.sender);\\n        }\\n        //burns anyway if token is expired\\n        uniOption.burnUniOption(_tokenId);\\n        ids[uIds[_tokenId]] = 0;\\n        uIds[_tokenId] = 0;\\n        emit Unwrapped(msg.sender, _tokenId);\\n    }\\n\\n    function getUnderlyingOptionId(uint _tokenId) external view returns (uint) {\\n        return uIds[_tokenId];\\n    }\\n\\n    function getUnderlyingOptionParams(uint _tokenId)\\n        public\\n        view\\n        returns (\\n        IHegicOptions.State state,\\n        address payable holder,\\n        uint256 strike,\\n        uint256 amount,\\n        uint256 lockedAmount,\\n        uint256 premium,\\n        uint256 expiration,\\n        IHegicOptions.OptionType optionType)\\n    {\\n        (state,\\n         holder,\\n         strike,\\n         amount,\\n         lockedAmount,\\n         premium,\\n         expiration,\\n         optionType) = hegicOption.options(uIds[_tokenId]);\\n    }\\n\\n    /**\\n     * @notice check whether Chef has underlying option locked\\n     */\\n    function isDelegated(uint _tokenId) public view returns (bool) {\\n        ( , address holder, , , , , , ) = hegicOption.options(uIds[_tokenId]);\\n        return holder == address(this);\\n    }\\n\\n    function createHegic(\\n        uint _period,\\n        uint _amount,\\n        uint _strike,\\n        IHegicOptions.OptionType _optionType\\n    )\\n        payable\\n        external\\n        returns (uint)\\n    {\\n        uint optionId = hegicOption.create{value: msg.value}(_period, _amount, _strike, _optionType);\\n        // return eth excess\\n        payable(msg.sender).transfer(address(this).balance);\\n        return wrapHegic(optionId);\\n    }\\n\\n    modifier onlyTokenOwner(uint _itemId) {\\n        require(msg.sender == uniOption.ownerOf(_itemId), \\\"UOPT:ownership/exchange\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/stack/work/unioption/contracts/interfaces/IOptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IHegicOptions {\\n    event Create(\\n        uint256 indexed id,\\n        address indexed account,\\n        uint256 settlementFee,\\n        uint256 totalFee\\n    );\\n\\n    event Exercise(uint256 indexed id, uint256 profit);\\n    event Expire(uint256 indexed id, uint256 premium);\\n    enum State {Inactive, Active, Exercised, Expired}\\n    enum OptionType {Invalid, Put, Call}\\n\\n    struct Option {\\n        State state;\\n        address payable holder;\\n        uint256 strike;\\n        uint256 amount;\\n        uint256 lockedAmount;\\n        uint256 premium;\\n        uint256 expiration;\\n        OptionType optionType;\\n    }\\n\\n    function create(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionType optionType\\n    )\\n        external\\n        payable\\n        returns (uint256 optionID);\\n\\n    function transfer(uint256 optionID, address payable newHolder) external;\\n\\n    function exercise(uint256 optionID) external;\\n\\n    function options(uint) external view returns (\\n        State state,\\n        address payable holder,\\n        uint256 strike,\\n        uint256 amount,\\n        uint256 lockedAmount,\\n        uint256 premium,\\n        uint256 expiration,\\n        OptionType optionType\\n    );\\n\\n    function unlock(uint256 optionID) external;\\n}\\n\\ninterface IHegicETHOptions is IHegicOptions {\\n        function fees(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionType optionType\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 settlementFee,\\n            uint256 strikeFee,\\n            uint256 periodFee\\n        );\\n}\\n\\ninterface IHegicERC20Options is IHegicOptions {\\n    function fees(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionType optionType\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 totalETH,\\n            uint256 settlementFee,\\n            uint256 strikeFee,\\n            uint256 periodFee\\n        );\\n}\\n\\n\"\r\n    },\r\n    \"/home/stack/work/unioption/contracts/interfaces/IUniOption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\ninterface IUniOption {\\n    //custom functions in use\\n    function burnUniOption(uint _id) external;\\n    function mintUniOption(address _to) external returns (uint256);\\n    //IERC721 functions in use\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"_hegicOption\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Unwrapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"}],\"name\":\"Wrapped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_strike\",\"type\":\"uint256\"},{\"internalType\":\"enum IHegicOptions.OptionType\",\"name\":\"_optionType\",\"type\":\"uint8\"}],\"name\":\"createHegic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnderlyingOptionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnderlyingOptionParams\",\"outputs\":[{\"internalType\":\"enum IHegicOptions.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strike\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"enum IHegicOptions.OptionType\",\"name\":\"optionType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hegicOption\",\"outputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isDelegated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniOption\",\"outputs\":[{\"internalType\":\"contract IUniOption\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unwrapHegic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IHegicOptions\",\"name\":\"_hegicOption\",\"type\":\"address\"}],\"name\":\"updateHegicOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniOption\",\"name\":\"_uniOption\",\"type\":\"address\"}],\"name\":\"updateUniOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uId\",\"type\":\"uint256\"}],\"name\":\"wrapHegic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OptionChef","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000efc0eeadc1132a12c9487d800112693bf49ecfa2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}