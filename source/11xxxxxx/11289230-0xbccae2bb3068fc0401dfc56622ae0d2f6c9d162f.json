{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\n\\ninterface IERC20 {\\n\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address tokenOwner) external view returns (uint balance);\\n  function allowance(address tokenOwner, address spender) external view returns (uint remaining);\\n  function transfer(address to, uint tokens) external returns (bool success);\\n  function approve(address spender, uint tokens) external returns (bool success);\\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\\n\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\n\\ncontract Ownable {\\n\\n  address public owner;\\n  address public transactionFee;\\n  address public buyBack;\\n\\n  event OwnershipTransferred(address newOwner);\\n  event TransactionFeeTransferred(address newTransactionFee);\\n  event BuyBackTransferred(address newBuyBack);\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\u0027You are not the owner!\\u0027);\\n    _;\\n  }\\n\\n  function transferOwnership(address newOwner) onlyOwner internal {\\n    owner = newOwner;\\n  }\\n\\n  function transferTransactionFee(address newTransactionFee) onlyOwner internal {\\n    transactionFee = newTransactionFee;\\n  }\\n\\n  function transferBuyBack(address newBuyBack) onlyOwner internal {\\n    buyBack = newBuyBack;\\n  }\\n\\n}\"},\"SafeMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\n\\nlibrary SafeMath {\\n\\n  function add(uint a, uint b) internal pure returns(uint) {\\n    uint c = a + b;\\n    require(c \\u003e= a, \\\"Sum overflow!\\\");\\n    return c;\\n  }\\n\\n  function sub(uint a, uint b) internal pure returns(uint) {\\n    uint c = a - b;\\n    require(c \\u003c= a, \\\"Sub underflow!\\\");\\n    return c;\\n  }\\n\\n  function mul(uint a, uint b) internal pure returns(uint) {\\n    if(a == 0) {\\n      return 0;\\n    }\\n    uint c = a * b;\\n    require(c / a == b, \\\"Mul overflow!\\\");\\n    return c;\\n  }\\n  \\n  function div(uint a, uint b) internal pure returns(uint) {\\n    uint c = a / b;\\n    return c;\\n  }\\n\\n}\"},\"TreasuryBondsPlus.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.0;\\npragma experimental ABIEncoderV2;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\nimport \\u0027./SafeMathLib.sol\\u0027;\\n\\ncontract TreasuryBondsPlus is Ownable, IERC20 {\\n\\n  using SafeMath for uint;\\n\\n  string public constant name = \\u0027Treasury Bonds Plus\\u0027;\\n  string public constant symbol = \\u0027TB+\\u0027;\\n  uint8 public constant decimals = 2;\\n\\n  uint private _totalSupply;\\n  uint public tokenPrice;\\n\\n  struct PurchaseRecord {\\n    uint date;\\n    uint quantity;\\n  }\\n\\n  mapping(address =\\u003e uint) private _balances;\\n  mapping(address =\\u003e mapping(address =\\u003e uint)) private _allowed;\\n  mapping(address =\\u003e PurchaseRecord[]) private _purchaseRecords;\\n  mapping(address =\\u003e bool) private _approvedKYC;\\n  mapping(uint8 =\\u003e uint8) public yieldPerMonth;\\n\\n  event Mint(address indexed to, uint tokens);\\n  event Burn(address indexed account, uint tokens);\\n  event Repurchase(address indexed tokenOwner, uint tokens);\\n\\n  constructor(address _transactionFee, address _buyBack) {\\n    _totalSupply = 200000 * 10 **uint(decimals);\\n    tokenPrice = 1; // 1 Dollar\\n    transactionFee = _transactionFee;\\n    buyBack = _buyBack;\\n\\n    for (uint8 i=12; i \\u003c= 120; i++) {\\n      uint8 mpy;\\n      if (i \\u003c= 23) mpy = 50; // 0,50 %\\n      else if (i \\u003c= 35) mpy = 60; // 0,60 %\\n      else if (i \\u003c= 47) mpy = 70; // 0,70 %\\n      else if (i \\u003c= 59) mpy = 80; // 0,80 %\\n      else if (i \\u003c= 71) mpy = 90; // 0,90 %\\n      else if (i \\u003c= 83) mpy = 100; // 1,00 %\\n      else if (i \\u003c= 95) mpy = 120; // 1,20 %\\n      else if (i \\u003c= 107) mpy = 140; // 1,40 %\\n      else if (i \\u003c= 119) mpy = 160; // 1,60 %\\n      else mpy = 180; // 1,80 %\\n      yieldPerMonth[i] = mpy;\\n    }\\n\\n    _balances[owner] = _totalSupply;\\n    emit Transfer(address(0), owner, _totalSupply);\\n  }\\n\\n  function totalSupply() public override view returns (uint) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\\n    return _balances[tokenOwner];\\n  }\\n\\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\\n    return _allowed[tokenOwner][spender];\\n  }\\n\\n  function transfer(address to, uint tokens) public override returns (bool success) {  \\n    uint tax = 0;\\n    if (msg.sender != owner) {\\n      require(tokens \\u003e= 100 * 10 **uint(decimals), \\u0027The minimum token quantity is 100.\\u0027);\\n      tax = _setTax(tokens);\\n    } else require(tokens \\u003e= 1 * 10 ** uint(decimals), \\u0027The minimum that can be sold is 1.\\u0027);\\n\\n    _transfer(msg.sender, to, tokens, tax);\\n    return true;\\n  }\\n\\n  function approve(address spender, uint tokens) public override returns (bool success) {\\n    require(msg.sender != address(0), \\u0027Invalid address!\\u0027);\\n    require(spender != address(0), \\u0027Invalid address!\\u0027);\\n\\n    _allowed[msg.sender][spender] = tokens;\\n    emit Approval(msg.sender, spender, tokens);\\n    return true;\\n  }\\n\\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\\n    require(tokens \\u003e= 100 * 10 **uint(decimals), \\u0027The minimum quantity of tokens that can be transferred is 100.\\u0027);\\n    require(_allowed[from][msg.sender] \\u003e= tokens, \\u0027Quantity of tokens allowed is insufficient!\\u0027);\\n    require(to == msg.sender, \\u0027The receiving address must be the same as the one calling the function!\\u0027);\\n\\n    uint tax = _setTax(tokens);\\n    _transfer(from, to, tokens, tax);\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\\n    return true;\\n  }\\n\\n  function mint(address to, uint tokens) public onlyOwner {\\n    require(to != address(0), \\u0027Invalid address!\\u0027);\\n\\n    _balances[to] = _balances[to].add(tokens);\\n    _totalSupply = _totalSupply.add(tokens);\\n    emit Mint(to, tokens);\\n  }\\n\\n  function burn(address account, uint tokens) public onlyOwner {\\n    require(account != address(0), \\u0027Invalid address!\\u0027);\\n    require(_balances[account] \\u003e= tokens, \\u0027Account balance is less than the number of tokens\\u0027);\\n\\n    _balances[account] = _balances[account].sub(tokens);\\n    _totalSupply = _totalSupply.sub(tokens);\\n    emit Burn(account, tokens);\\n  }\\n\\n  function repurchase(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\\n    require(_balances[tokenOwner] \\u003e= tokens, \\u0027Insufficient tokens!\\u0027);\\n\\n    _balances[tokenOwner] = _balances[tokenOwner].sub(tokens);\\n    _balances[buyBack] = _balances[buyBack].add(tokens);\\n    \\n    emit Repurchase(tokenOwner, tokens);\\n    return true;\\n  }\\n\\n  function purchaseRecords(address tokenOwner) public view onlyOwner returns (PurchaseRecord[] memory) {\\n    return _purchaseRecords[tokenOwner];\\n  }\\n\\n  function approveKYC(address account) public onlyOwner returns (bool success) {\\n    require(!(_approvedKYC[account]), \\u0027The address already exists!\\u0027);\\n\\n    _approvedKYC[account] = true;\\n    return true;\\n  }\\n\\n  function getApprovedKYC(address account) public view onlyOwner returns (bool status) {\\n    return _approvedKYC[account];\\n  }\\n\\n  function newOwner(address account) public onlyOwner returns (bool success) {\\n    require(account != owner, \\u0027The address of the new owner must be different from the current one.\\u0027);\\n\\n    address oldOwner = owner;\\n    transferOwnership(account);\\n    _balances[account] = _balances[oldOwner];\\n    _balances[oldOwner] = 0;\\n    OwnershipTransferred(account);\\n    return true;\\n  }\\n\\n  function newTransactionFee(address account) public onlyOwner returns (bool success) {\\n    require(account != transactionFee, \\u0027The address of the new transaction_fee must be different from the current one.\\u0027);\\n\\n    address oldTransactionFee = transactionFee;\\n    transferTransactionFee(account);\\n    _balances[account] = _balances[oldTransactionFee];\\n    _balances[oldTransactionFee] = 0;\\n    TransactionFeeTransferred(account);\\n    return true;\\n  }\\n\\n  function newBuyBack(address account) public onlyOwner returns (bool success) {\\n    require(account != buyBack, \\u0027the address of the new buy_back must be different from the current one.\\u0027);\\n\\n    address oldBuyBack = buyBack;\\n    transferBuyBack(account);\\n    _balances[account] = _balances[oldBuyBack];\\n    _balances[oldBuyBack] = 0;\\n    BuyBackTransferred(account);\\n    return true;\\n  }\\n\\n  function _setTax(uint tokens) private pure returns (uint) {\\n    uint tokensInPercentage = tokens / 100;\\n    uint tax;\\n\\n    if (tokens \\u003c= 10000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 2; // 0,50%\\n    else if (tokens \\u003c= 50000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 20; // 0,35%\\n    else if (tokens \\u003c= 100000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 4; // 0,25%\\n    else if (tokens \\u003c= 1000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 5; // 0,20%\\n    else if (tokens \\u003c= 10000000 * 10 **uint(decimals)) tax = tokensInPercentage * 9 / 50; // 0,18%\\n    else if (tokens \\u003c= 50000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 20; // 0,15%\\n    else if (tokens \\u003c= 100000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 10; // 0,10%\\n    else if (tokens \\u003c= 300000000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 100; // 0,07%\\n    else if (tokens \\u003c= 500000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 50; // 0,06%\\n    else if (tokens \\u003c= 1000000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 20; // 0,05%\\n    else tax = tokensInPercentage * 1 / 25; // 0,04%\\n\\n    return tax;\\n  }\\n\\n  function _transfer(address sender, address recipient, uint tokens, uint tax) private {\\n    require(sender != address(0), \\u0027Invalid address!\\u0027);\\n    require(recipient != address(0), \\u0027Invalid address!\\u0027);\\n    require(sender != recipient, \\u0027Addresses must be different!\\u0027);\\n    require(_balances[sender] \\u003e= tokens, \\u0027Insufficient tokens!\\u0027);\\n\\n    uint tokensWithTax = tokens;\\n    if (tax \\u003e 0) {\\n      tokensWithTax = tokens - tax;\\n      _balances[transactionFee] = _balances[transactionFee].add(tax);\\n    }\\n    \\n    _balances[sender] = _balances[sender].sub(tokens);\\n    _balances[recipient] = _balances[recipient].add(tokensWithTax);\\n      \\n    _purchaseRecords[recipient].push(PurchaseRecord({\\n      date: block.timestamp,\\n      quantity: tokensWithTax\\n    }));\\n\\n    emit Transfer(sender, recipient, tokens);\\n  }\\n\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transactionFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyBack\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBuyBack\",\"type\":\"address\"}],\"name\":\"BuyBackTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Repurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTransactionFee\",\"type\":\"address\"}],\"name\":\"TransactionFeeTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"approveKYC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBack\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getApprovedKYC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"newBuyBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"newTransactionFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"purchaseRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct TreasuryBondsPlus.PurchaseRecord[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"repurchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"yieldPerMonth\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TreasuryBondsPlus","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fd2f357491f6cc553e9181d1f07e2391252f4a3700000000000000000000000020159d6e895b3afe3a570a296a8d6b568ed6744c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://343ec15c34431f5e4cf1af275381f6230607121750bfd84b8ead3b62d648b478"}]}