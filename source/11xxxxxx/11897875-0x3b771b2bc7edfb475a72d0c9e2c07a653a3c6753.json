{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\nimport { ITokenManager, IERC20, ISafeMath } from \\u0027./Interfaces.sol\\u0027;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Implementation of ERC20 Standard\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract ERC20 is IERC20 {\\r\\n    string public _symbol;\\r\\n    string public _name;\\r\\n    uint8 public _decimals;\\r\\n    uint public _totalSupply;\\r\\n\\r\\n    // For each person map between their address and the number of tokens they have\\r\\n    mapping(address =\\u003e uint) balances;\\r\\n    // To transfer erc20 token, give contract permission to transfer. Maps from your address to address of transfer target and amount to transfer.\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\r\\n\\r\\n    ISafeMath immutable public safemath;\\r\\n\\r\\n    constructor(string memory symbol, string memory name, uint8 decimals, uint total_supply, ISafeMath safemath_contract) {\\r\\n        _symbol = symbol;\\r\\n        _name = name;\\r\\n        _decimals = decimals;\\r\\n        _totalSupply = total_supply;\\r\\n        safemath = safemath_contract;\\r\\n    }\\r\\n\\r\\n    //Returns decimals that this token uses.\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n\\r\\n    //Returns the token name\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n\\r\\n    //Returns the symbol\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Return total supply\\r\\n    function totalSupply() public override view returns (uint) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Return the token balance for account tokenOwner\\r\\n    function balanceOf(address _token_owner) public override view returns (uint balance) {\\r\\n        return balances[_token_owner];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer the balance from token owner\\u0027s account to to account\\r\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transfer(address _to, uint _num_tokens) public override returns (bool success) {\\r\\n        require(_num_tokens \\u003c= balances[msg.sender], \\\"You are trying to transfer more tokens than you have\\\");\\r\\n\\r\\n        balances[msg.sender] = safemath.sub(balances[msg.sender], _num_tokens);\\r\\n        balances[_to] = safemath.add(balances[_to], _num_tokens);\\r\\n        emit Transfer(msg.sender, _to, _num_tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for spender to transferFrom(...) tokens\\r\\n    // from the token owner\\u0027s account\\r\\n    //\\r\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n    // recommends that there are no checks for the approval double-spend attack\\r\\n    // as this should be implemented in user interfaces\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approve(address spender, uint tokens) public override returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Non-standard approval function that takes care of the potential double-spend issue\\r\\n    // If a user wants to ensure that the double spend issue doesn\\u0027t become a problem, they can choose\\r\\n    // to use this function instead of the standard approve function.\\r\\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool success) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        allowed[msg.sender][_spender] = safemath.add(oldValue, _addedValue);\\r\\n        emit Approval(msg.sender, _spender, safemath.add(oldValue, _addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Non-standard approval function that takes care of the potential double-spend issue\\r\\n    // If a user wants to ensure that the double spend issue doesn\\u0027t become a problem, they can choose\\r\\n    // to use this function instead of the standard approve function.\\r\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool success) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        allowed[msg.sender][_spender] = safemath.sub(oldValue, _subtractedValue);\\r\\n        emit Approval(msg.sender, _spender, safemath.sub(oldValue, _subtractedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer tokens from the from account to the to account\\r\\n    //\\r\\n    // The calling account must already have sufficient tokens approve(...)-d\\r\\n    // for spending from the from account and\\r\\n    // - From account must have sufficient balance to transfer\\r\\n    // - Spender must have sufficient allowance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\\r\\n        balances[from] = safemath.sub(balances[from], tokens);\\r\\n        allowed[from][msg.sender] = safemath.sub(allowed[from][msg.sender], tokens);\\r\\n        balances[to] = safemath.add(balances[to], tokens);\\r\\n        emit Transfer(from, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Returns the amount of tokens approved by the owner that can be\\r\\n    // transferred to the spender\\u0027s account\\r\\n    // ------------------------------------------------------------------------\\r\\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\\r\\n        return allowed[tokenOwner][spender];\\r\\n    }\\r\\n\\r\\n}\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\n\\r\\ninterface ITokenManager {\\r\\n    function payout(string calldata quarter, address recipient, uint amount) external returns (bool success);\\r\\n}\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// ERC Token Standard #20 Interface\\r\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n// ----------------------------------------------------------------------------\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface ISafeMath {\\r\\n    function add(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function sub(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function mul(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function div(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function min(uint256 a, uint256 b) external pure returns (uint256);\\r\\n    function mod(uint256 a, uint256 b) external pure returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IKladeDiffToken {\\r\\n    function set_payout(uint payout) external;\\r\\n    function mint_tokens(address token_recipient, uint256 numToMint) external returns (bool success);\\r\\n}\\r\\n\\r\\ninterface IChainlinkOracle {\\r\\n    function latestRoundData() external view returns (\\r\\n          uint80,\\r\\n          int256,\\r\\n          uint256,\\r\\n          uint256,\\r\\n          uint80\\r\\n    );\\r\\n}\"},\"KladeAlphaTokenQ32021.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.3;\\r\\nimport { ITokenManager, ISafeMath } from \\u0027./Interfaces.sol\\u0027;\\r\\nimport { ERC20 } from \\u0027./ERC20.sol\\u0027;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Klade Alpha Tokens-Difficulty Derivative\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract KladeAlphaTokenQ32021 is ERC20 {\\r\\n    uint public constant expiration = 1632960000;\\r\\n    uint public constant required_collateral = 127000;\\r\\n\\r\\n    uint public alpha_token_payout;\\r\\n    bool public payout_set;\\r\\n    \\r\\n    address immutable public KladeAddress1;\\r\\n    address immutable public KladeAddress2;\\r\\n    address immutable public ChainlinkReceiverAddress;\\r\\n    address immutable public TokenManagerAddress;\\r\\n\\r\\n    constructor(address klade_address1, address klade_address2, ISafeMath safemath_contract, address receiver_address, address manager_address)\\r\\n        ERC20(\\\"KATQ32021\\\", \\\"KAlphaQ32021\\\", 18, 0, safemath_contract) public {\\r\\n        KladeAddress1 = klade_address1;\\r\\n        KladeAddress2 = klade_address2;\\r\\n\\r\\n        ChainlinkReceiverAddress = receiver_address;\\r\\n        TokenManagerAddress = manager_address;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Mint Klade Alpha tokens\\r\\n     * @param alpha_token_recipient address - The owner of the newly minted alpha token(s)\\r\\n     * @param numToMint uint256 - The number of alpha tokens minted in this transactions in base units(_decimals)\\r\\n     */\\r\\n    function mint_tokens(address alpha_token_recipient, uint256 numToMint) external returns (bool success) {\\r\\n        require(msg.sender == TokenManagerAddress, \\\"Only the tokenmanager contract can mint Klade tokens\\\");\\r\\n        _totalSupply = safemath.add(numToMint, _totalSupply);\\r\\n        balances[alpha_token_recipient] = safemath.add(balances[alpha_token_recipient], numToMint);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * If an address owns alpha tokens, after expiry that address can\\r\\n     * call this function to claim the WBTC payout it is entitled to for these tokens.\\r\\n     * The alpha tokens for which payout is claimed are burned afterward.\\r\\n     * @param payout_recipient address - The recipient of the WBTC payout\\r\\n     * @param num uint - Number of tokens to burn and get payout for\\r\\n     */\\r\\n    function payout(address payout_recipient, uint num) external {\\r\\n        require(block.timestamp \\u003e expiration, \\\"Tokens have not reached expiration, please wait until after expiration for payouts\\\");\\r\\n        require(payout_set, \\\"Payouts have not been set\\\");\\r\\n\\r\\n        balances[msg.sender] = safemath.sub(balances[msg.sender], num); // reverts if msg.sender does not own at least num tokens\\r\\n        _totalSupply = safemath.sub(_totalSupply, num);\\r\\n\\r\\n        emit Transfer(msg.sender, address(0), num); // Burn tokens\\r\\n         // TODO: Write tests to double check receiving correct payout from owning fractional amounts.\\r\\n        uint payout_amount = safemath.div(safemath.mul(num, alpha_token_payout), 10**18);\\r\\n        require(ITokenManager(TokenManagerAddress).payout(\\\"Q32021\\\", payout_recipient, payout_amount));\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * set_payout should be called by the chainlink receiver\\r\\n     * when the quarter is over and the payout has been calculated\\r\\n     * @param payout_amount uint - The payout amount in WBTC base units for a single alpha token\\r\\n     */\\r\\n    function set_payout(uint payout_amount) external {\\r\\n        require(msg.sender == ChainlinkReceiverAddress, \\\"Only the ChainlinkReceiver can set the payouts\\\");\\r\\n        require(!payout_set, \\\"Payouts have already been set\\\");\\r\\n        require(required_collateral \\u003e= payout_amount, \\\"1 token\\u0027s payout is higher than 1 token pair\\u0027s required collateral\\\");\\r\\n        require(block.timestamp \\u003e expiration, \\\"Tokens have not reached expiration, please wait until after expiration to set payouts\\\");\\r\\n        \\r\\n        alpha_token_payout = payout_amount;\\r\\n        payout_set = true;\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Don\\u0027t accept ETH\\r\\n    // ------------------------------------------------------------------------\\r\\n    fallback () external payable {\\r\\n        revert();\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"total_supply\",\"type\":\"uint256\"},{\"internalType\":\"contract ISafeMath\",\"name\":\"safemath_contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safemath\",\"outputs\":[{\"internalType\":\"contract ISafeMath\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_num_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20","CompilerVersion":"v0.7.3+commit.9bfce1f6","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fd629b1fbc77644b23287f8acd0aea58ac695c3500000000000000000000000000000000000000000000000000000000000000094b41545133323032310000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c4b416c7068615133323032310000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ded20e247984534ed0f549fee0ccb5412d722dafd059a575c51676987a73e271"}]}