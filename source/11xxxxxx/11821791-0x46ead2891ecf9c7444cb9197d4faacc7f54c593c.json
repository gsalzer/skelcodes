{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\interfaces\\IAvnValidatorsManager.sol\n\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnValidatorsManager {\r\n  event LogValidatorDepositUpdated(uint256 validatorDeposit);\r\n  event LogValidatorChallengeWindowUpdated(uint256 challengeWindowInSeconds);\r\n  event LogQuorumUpdated(uint256[2] quorum);\r\n  event LogValidatorRegistered(bytes32 indexed t1PublicKeyLHS, bytes32 indexed t1PublicKeyRHS, bytes32 indexed t2PublicKey,\r\n      uint256 validatorId);\r\n  event LogValidatorActivated(address indexed t1Address, bytes32 indexed t2PublicKey, uint256 indexed t2TransactionId,\r\n      uint256 validatorId);\r\n  event LogValidatorDeregistered(address indexed t1Address, bytes32 indexed t2PublicKey, uint256 indexed t2TransactionId,\r\n      uint256 validatorId);\r\n  event LogValidatorSlashed(address indexed t1Address, bytes32 indexed t2PublicKey, uint256 indexed t2TransactionId,\r\n      uint256 slashedAmount);\r\n  event LogValidatorDepositClaimed(address indexed t1Address);\r\n  event LogRootPublished(bytes32 indexed rootHash, uint256 indexed t2TransactionId);\r\n\r\n  function disableValidatorFunctions(bool _isDisabled) external;\r\n  function setValidatorDeposit(uint256 validatorDeposit) external;\r\n  function setValidatorChallengeWindow(uint256 challengeWindowInSeconds) external;\r\n  function setQuorum(uint256[2] calldata quorum) external;\r\n  function initialiseAvn(address[] calldata t1Address, bytes32[] calldata t1PublicKeyLHS, bytes32[] calldata t1PublicKeyRHS,\r\n      bytes32[] calldata t2PublicKey) external;\r\n  function registerValidator(bytes calldata t1PublicKey, bytes32 t2PublicKey) external;\r\n  function activateValidator(bytes32 targetT2PublicKey, uint256 t2TransactionId, bytes calldata confirmations) external;\r\n  function deregisterValidator(bytes32 targetT2PublicKey, uint256 t2TransactionId, bytes calldata confirmations) external;\r\n  function claimValidatorDeposit(bytes32 t2PublicKey) external;\r\n  function slashValidator(bytes32 targetT2PublicKey, uint256 t2TransactionId, bytes calldata confirmations) external;\r\n  function publishRoot(bytes32 rootHash, uint256 t2TransactionId, bytes calldata confirmations) external;\r\n  function retire() external;\r\n}\n\n// File: contracts\\interfaces\\IAvnStorage.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnStorage {\r\n  event LogStoragePermissionUpdated(address indexed publisher, bool status);\r\n\r\n  function setStoragePermission(address publisher, bool status) external;\r\n  function storeT2TransactionId(uint256 _t2TransactionId) external;\r\n  function storeT2TransactionIdAndRoot(uint256 _t2TransactionId, bytes32 rootHash) external;\r\n  function confirmLeaf(bytes32 leafHash, bytes32[] memory merklePath) external view returns (bool);\r\n}\n\n// File: contracts\\interfaces\\IAvnFTTreasury.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnFTTreasury {\r\n  event LogFTTreasuryPermissionUpdated(address indexed treasurer, bool status);\r\n\r\n  function setTreasurerPermission(address treasurer, bool status) external;\r\n  function getTreasurers() external view returns(address[] memory);\r\n  function unlockERC777Tokens(address token, uint256 amount, bytes calldata data) external;\r\n  function unlockERC20Tokens(address token, uint256 amount) external;\r\n}\n\n// File: contracts\\interfaces\\IERC20.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\n// As described in https://eips.ethereum.org/EIPS/eip-20\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function name() external view returns (string memory); // optional method - see eip spec\r\n  function symbol() external view returns (string memory); // optional method - see eip spec\r\n  function decimals() external view returns (uint8); // optional method - see eip spec\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\n\n// File: contracts\\Owned.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ncontract Owned {\r\n\r\n  address public owner = msg.sender;\r\n\r\n  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner, \"Only owner\");\r\n    _;\r\n  }\r\n\r\n  function setOwner(address _owner)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_owner != address(0), \"Owner cannot be zero address\");\r\n    emit LogOwnershipTransferred(owner, _owner);\r\n    owner = _owner;\r\n  }\r\n}\n\n// File: ..\\contracts\\AvnValidatorsManager.sol\n\n\r\npragma solidity 0.7.5;\r\r\r\r\r\r\n\r\ncontract AvnValidatorsManager is IAvnValidatorsManager, Owned {\r\n\r\n  uint256 constant internal SIGNATURE_LENGTH = 65;\r\n\r\n  IERC20 immutable public avt;\r\n  IAvnStorage immutable public avnStorage;\r\n  IAvnFTTreasury immutable public avnFTTreasury;\r\n\r\n  uint256 public validatorDeposit;\r\n  uint256 public validatorChallengeWindowInSeconds;\r\n  uint256[2] public quorum;\r\n\r\n  uint256 public numActiveValidators;\r\n  uint256 public validatorIdNum;\r\n  bool public validatorFunctionsDisabled;\r\n  bool public avnInitialised;\r\n\r\n  // Validator data\r\n  mapping (uint256 => address) public t1Address;\r\n  mapping (uint256 => bytes32) public t2PublicKey;\r\n  mapping (uint256 => uint256) public deposit;\r\n  mapping (uint256 => bool) public isRegistered;\r\n  mapping (uint256 => bool) public isActive;\r\n  mapping (uint256 => bool) public isDeregistered;\r\n  mapping (uint256 => uint256) public challengeEnd;\r\n  mapping (address => uint256) public idByT1Address;\r\n  mapping (bytes32 => uint256) public idByT2PublicKey;\r\n\r\n  constructor(IERC20 _avt, IAvnStorage _avnStorage, IAvnFTTreasury _avnFTTreasury, uint256 _validatorDeposit,\r\n      uint256 _validatorChallengeWindowInSeconds, uint256[2] memory _quorum)\r\n  {\r\n    avt = _avt;\r\n    avnStorage = _avnStorage;\r\n    avnFTTreasury = _avnFTTreasury;\r\n    validatorDeposit = _validatorDeposit;\r\n    validatorChallengeWindowInSeconds = _validatorChallengeWindowInSeconds;\r\n    setQuorum(_quorum);\r\n    validatorIdNum = 1;\r\n  }\r\n\r\n  modifier onlyWhenValidatorFunctionsEnabled() {\r\n    require(!validatorFunctionsDisabled && avnInitialised, \"Function currently disabled\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyUniqueTransaction(uint256 _t2TransactionId) {\r\n    avnStorage.storeT2TransactionId(_t2TransactionId);\r\n    _;\r\n  }\r\n\r\n  function disableValidatorFunctions(bool _isDisabled)\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    validatorFunctionsDisabled = _isDisabled;\r\n  }\r\n\r\n  function setValidatorDeposit(uint256 _validatorDeposit)\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    validatorDeposit = _validatorDeposit;\r\n    emit LogValidatorDepositUpdated(validatorDeposit);\r\n  }\r\n\r\n  function setValidatorChallengeWindow(uint256 _validatorChallengeWindowInSeconds)\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    validatorChallengeWindowInSeconds = _validatorChallengeWindowInSeconds;\r\n    emit LogValidatorChallengeWindowUpdated(_validatorChallengeWindowInSeconds);\r\n  }\r\n\r\n  function initialiseAvn(address[] calldata _t1Address, bytes32[] calldata _t1PublicKeyLHS, bytes32[] calldata _t1PublicKeyRHS,\r\n      bytes32[] calldata _t2PublicKey)\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    require(!avnInitialised, \"AVN already initialised\");\r\n    require(_t1Address.length == _t1PublicKeyLHS.length && _t1PublicKeyLHS.length == _t1PublicKeyRHS.length\r\n        && _t1PublicKeyRHS.length == _t2PublicKey.length, \"Validator keys missing\");\r\n\r\n    uint256 targetId;\r\n    bytes memory t1PublicKey;\r\n\r\n    for (uint256 i; i < _t1Address.length; i++) {\r\n      t1PublicKey = abi.encodePacked(_t1PublicKeyLHS[i], _t1PublicKeyRHS[i]);\r\n      doRegisterValidator(_t1Address[i], t1PublicKey, _t2PublicKey[i]);\r\n      targetId = idByT1Address[_t1Address[i]];\r\n      isActive[targetId] = true;\r\n      numActiveValidators++;\r\n      emit LogValidatorActivated(_t1Address[i], _t2PublicKey[i], 0, targetId);\r\n    }\r\n\r\n    avnInitialised = true;\r\n  }\r\n\r\n  function registerValidator(bytes calldata _t1PublicKey, bytes32 _t2PublicKey)\r\n    onlyWhenValidatorFunctionsEnabled\r\n    external\r\n    override\r\n  {\r\n    doRegisterValidator(msg.sender, _t1PublicKey, _t2PublicKey);\r\n  }\r\n\r\n  function activateValidator(bytes32 _targetT2PublicKey, uint256 _t2TransactionId, bytes calldata _confirmations)\r\n    onlyWhenValidatorFunctionsEnabled\r\n    onlyUniqueTransaction(_t2TransactionId)\r\n    external\r\n    override\r\n  {\r\n    uint256 targetId = idByT2PublicKey[_targetT2PublicKey];\r\n    require(!isActive[targetId], \"Target already active\");\r\n    require(isRegistered[targetId], \"Target must be registered\");\r\n    verifyConfirmations(toConfirmationHash(_targetT2PublicKey, _t2TransactionId), _confirmations);\r\n    isActive[targetId] = true;\r\n    numActiveValidators++;\r\n    emit LogValidatorActivated(t1Address[targetId], _targetT2PublicKey, _t2TransactionId, targetId);\r\n  }\r\n\r\n  function deregisterValidator(bytes32 _targetT2PublicKey, uint256 _t2TransactionId, bytes calldata _confirmations)\r\n    onlyWhenValidatorFunctionsEnabled\r\n    onlyUniqueTransaction(_t2TransactionId)\r\n    external\r\n    override\r\n  {\r\n    uint256 targetId = idByT2PublicKey[_targetT2PublicKey];\r\n    require(isRegistered[targetId], \"Target not currently registered\");\r\n    deregisterAndDeactivateValidator(targetId);\r\n    verifyConfirmations(toConfirmationHash(_targetT2PublicKey, _t2TransactionId), _confirmations);\r\n    challengeEnd[targetId] = block.timestamp + validatorChallengeWindowInSeconds;\r\n    emit LogValidatorDeregistered(t1Address[targetId], _targetT2PublicKey, _t2TransactionId, targetId);\r\n  }\r\n\r\n  function claimValidatorDeposit(bytes32 _t2PublicKey)\r\n    onlyWhenValidatorFunctionsEnabled\r\n    external\r\n    override\r\n  {\r\n    uint256 id = idByT2PublicKey[_t2PublicKey];\r\n    uint256 lockedDeposit = deposit[id];\r\n\r\n    require(lockedDeposit != 0, \"Has no deposit\");\r\n    require(isDeregistered[id] == true, 'Must be deregistered first');\r\n    require(challengeEnd[id] <= block.timestamp, \"Cannot withdraw yet\");\r\n    deposit[id] = 0;\r\n    challengeEnd[id] = 0;\r\n    unlockAVTFromTreasuryAndTransfer(t1Address[id], lockedDeposit);\r\n    emit LogValidatorDepositClaimed(t1Address[id]);\r\n  }\r\n\r\n  function slashValidator(bytes32 _targetT2PublicKey, uint256 _t2TransactionId, bytes calldata _confirmations)\r\n    onlyWhenValidatorFunctionsEnabled\r\n    onlyUniqueTransaction(_t2TransactionId)\r\n    external\r\n    override\r\n  {\r\n    uint256 targetId = idByT2PublicKey[_targetT2PublicKey];\r\n    require(targetId != 0, \"Validator does not exist\");\r\n\r\n    deregisterAndDeactivateValidator(targetId);\r\n    verifyConfirmations(toConfirmationHash(_targetT2PublicKey, _t2TransactionId), _confirmations);\r\n    uint256 lockedDeposit = deposit[targetId];\r\n    deposit[targetId] = 0;\r\n    challengeEnd[targetId] = 0;\r\n    unlockAVTFromTreasuryAndTransfer(owner, lockedDeposit);\r\n    emit LogValidatorSlashed(t1Address[targetId], _targetT2PublicKey, _t2TransactionId, lockedDeposit);\r\n  }\r\n\r\n  function publishRoot(bytes32 _rootHash, uint256 _t2TransactionId, bytes calldata _confirmations)\r\n    onlyWhenValidatorFunctionsEnabled\r\n    external\r\n    override\r\n  {\r\n    avnStorage.storeT2TransactionIdAndRoot(_t2TransactionId, _rootHash);\r\n    verifyConfirmations(toConfirmationHash(_rootHash, _t2TransactionId), _confirmations);\r\n    emit LogRootPublished(_rootHash, _t2TransactionId);\r\n  }\r\n\r\n  function retire()\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    selfdestruct(payable(owner));\r\n  }\r\n\r\n  function setQuorum(uint256[2] memory _quorum)\r\n    onlyOwner\r\n    public\r\n    override\r\n  {\r\n    require(_quorum[1] != 0, \"Invalid: div by zero\");\r\n    require(_quorum[0] <= _quorum[1], \"Invalid: above 100%\");\r\n    quorum = _quorum;\r\n    emit LogQuorumUpdated(quorum);\r\n  }\r\n\r\n  function doRegisterValidator(address _t1Address, bytes memory _t1PublicKey, bytes32 _t2PublicKey)\r\n    private\r\n  {\r\n    uint256 id = idByT1Address[_t1Address];\r\n    require(!isRegistered[id], \"Already registered\");\r\n    checkT1PublicKey(_t1Address, _t1PublicKey);\r\n\r\n    if (isDeregistered[id]) {\r\n      require(t2PublicKey[id] == _t2PublicKey, \"Cannot change T2 public key\");\r\n      uint256 existingDeposit = deposit[id];\r\n      deposit[id] = validatorDeposit;\r\n      isRegistered[id] = true;\r\n      isDeregistered[id] = false;\r\n      challengeEnd[id] = 0;\r\n      if (existingDeposit > validatorDeposit) {\r\n        unlockAVTFromTreasuryAndTransfer(_t1Address, existingDeposit - validatorDeposit);\r\n      } else if (existingDeposit < validatorDeposit) {\r\n        lockAVTInTreasury(_t1Address, validatorDeposit - existingDeposit);\r\n      }\r\n    } else {\r\n      require(idByT2PublicKey[_t2PublicKey] == 0, \"T2 public key already associated\");\r\n      lockAVTInTreasury(_t1Address, validatorDeposit);\r\n      id = validatorIdNum;\r\n      idByT1Address[_t1Address] = id;\r\n      isRegistered[id] = true;\r\n      t1Address[id] = _t1Address;\r\n      t2PublicKey[id] = _t2PublicKey;\r\n      deposit[id] = validatorDeposit;\r\n      idByT2PublicKey[_t2PublicKey] = id;\r\n      validatorIdNum++;\r\n    }\r\n\r\n    bytes memory t1PublicKey = _t1PublicKey;\r\n    bytes32 t1PublicKeyLHS;\r\n    bytes32 t1PublicKeyRHS;\r\n\r\n    assembly {\r\n      t1PublicKeyLHS := mload(add(t1PublicKey, 0x20))\r\n      t1PublicKeyRHS := mload(add(t1PublicKey, 0x40))\r\n    }\r\n\r\n    emit LogValidatorRegistered(t1PublicKeyLHS, t1PublicKeyRHS, _t2PublicKey, id);\r\n  }\r\n\r\n  function unlockAVTFromTreasuryAndTransfer(address _recipient, uint256 _amount)\r\n    private\r\n  {\r\n    avnFTTreasury.unlockERC20Tokens(address(avt), _amount);\r\n    assert(avt.transfer(_recipient, _amount));\r\n  }\r\n\r\n  function lockAVTInTreasury(address _t1Address, uint256 _amount)\r\n    private\r\n  {\r\n    require(avt.balanceOf(_t1Address) >= _amount, 'Insufficient AVT funds');\r\n    require(avt.allowance(_t1Address, address(this)) >= _amount, 'AVT amount requires approval');\r\n    assert(avt.transferFrom(_t1Address, address(this), _amount));\r\n    // locks the AVT in the treasury\r\n    assert(avt.transfer(address(avnFTTreasury), _amount));\r\n  }\r\n\r\n  function toConfirmationHash(bytes32 _data, uint256 _t2TransactionId)\r\n    private\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encode(_data, _t2TransactionId, t2PublicKey[idByT1Address[msg.sender]]));\r\n  }\r\n\r\n  function verifyConfirmations(bytes32 _msgHash, bytes memory _confirmations)\r\n    private\r\n    view\r\n  {\r\n    require(isActive[idByT1Address[msg.sender]], \"Must be an active validator\");\r\n    bytes32 ethSignedPrefixMsgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _msgHash));\r\n    uint256 numConfirmations = _confirmations.length / SIGNATURE_LENGTH;\r\n    uint256 requiredConfirmations = numActiveValidators * quorum[0] / quorum[1] + 1;\r\n    uint256 validConfirmations;\r\n    uint256 id;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    bool[] memory confirmed = new bool[](validatorIdNum);\r\n\r\n    for (uint256 i; i < numConfirmations; i++) {\r\n      assembly {\r\n        let offset := mul(i, SIGNATURE_LENGTH)\r\n        r := mload(add(_confirmations, add(0x20, offset)))\r\n        s := mload(add(_confirmations, add(0x40, offset)))\r\n        v := byte(0, mload(add(_confirmations, add(0x60, offset))))\r\n      }\r\n      if (v < 27) v += 27;\r\n      if (v != 27 && v != 28 || uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0)\r\n        continue;\r\n      else {\r\n        id = idByT1Address[ecrecover(ethSignedPrefixMsgHash, v, r, s)];\r\n        if (isActive[id] && !confirmed[id]) {\r\n          if (++validConfirmations == requiredConfirmations) break;\r\n          confirmed[id] = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    require(validConfirmations == requiredConfirmations, \"Invalid confirmations\");\r\n  }\r\n\r\n  function checkT1PublicKey(address _t1Address, bytes memory _t1PublicKey)\r\n    private\r\n    pure\r\n  {\r\n    require(_t1PublicKey.length == 64, \"T1 public key must be 64 bytes\");\r\n    require(address(bytes20(uint160(uint256(keccak256(abi.encodePacked(_t1PublicKey)))))) == _t1Address, \"Bad T1 public key\");\r\n  }\r\n\r\n  function deregisterAndDeactivateValidator(uint256 _targetId)\r\n    private\r\n  {\r\n    isRegistered[_targetId] = false;\r\n    isDeregistered[_targetId] = true;\r\n    if (isActive[_targetId]) {\r\n      isActive[_targetId] = false;\r\n      numActiveValidators--;\r\n    }\r\n  }\r\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_avt\",\"type\":\"address\"},{\"internalType\":\"contract IAvnStorage\",\"name\":\"_avnStorage\",\"type\":\"address\"},{\"internalType\":\"contract IAvnFTTreasury\",\"name\":\"_avnFTTreasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_validatorDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validatorChallengeWindowInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_quorum\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"quorum\",\"type\":\"uint256[2]\"}],\"name\":\"LogQuorumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"}],\"name\":\"LogRootPublished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"LogValidatorActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeWindowInSeconds\",\"type\":\"uint256\"}],\"name\":\"LogValidatorChallengeWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"}],\"name\":\"LogValidatorDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorDeposit\",\"type\":\"uint256\"}],\"name\":\"LogValidatorDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"LogValidatorDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t1PublicKeyLHS\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t1PublicKeyRHS\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"LogValidatorRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"t1Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"t2PublicKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"t2TransactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashedAmount\",\"type\":\"uint256\"}],\"name\":\"LogValidatorSlashed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_targetT2PublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_confirmations\",\"type\":\"bytes\"}],\"name\":\"activateValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avnFTTreasury\",\"outputs\":[{\"internalType\":\"contract IAvnFTTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avnInitialised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avnStorage\",\"outputs\":[{\"internalType\":\"contract IAvnStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challengeEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_t2PublicKey\",\"type\":\"bytes32\"}],\"name\":\"claimValidatorDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_targetT2PublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_confirmations\",\"type\":\"bytes\"}],\"name\":\"deregisterValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isDisabled\",\"type\":\"bool\"}],\"name\":\"disableValidatorFunctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"idByT1Address\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"idByT2PublicKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_t1Address\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_t1PublicKeyLHS\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_t1PublicKeyRHS\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_t2PublicKey\",\"type\":\"bytes32[]\"}],\"name\":\"initialiseAvn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isDeregistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numActiveValidators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_confirmations\",\"type\":\"bytes\"}],\"name\":\"publishRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_t1PublicKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_t2PublicKey\",\"type\":\"bytes32\"}],\"name\":\"registerValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"_quorum\",\"type\":\"uint256[2]\"}],\"name\":\"setQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validatorChallengeWindowInSeconds\",\"type\":\"uint256\"}],\"name\":\"setValidatorChallengeWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validatorDeposit\",\"type\":\"uint256\"}],\"name\":\"setValidatorDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_targetT2PublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_t2TransactionId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_confirmations\",\"type\":\"bytes\"}],\"name\":\"slashValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"t1Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"t2PublicKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorChallengeWindowInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorFunctionsDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorIdNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AvnValidatorsManager","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000000d88ed6e74bbfd96b831231638b66c05571e824f000000000000000000000000aa0304f6e2426119bbe10870df3edb867d5ec10100000000000000000000000073fe91d082b3604b8261de321086333e78ab11120000000000000000000000000000000000000000000034f086f3b33b684000000000000000000000000000000000000000000000000000000000000000278d0000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}