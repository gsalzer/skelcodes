{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\weth\\IWETH.sol\r\n\r\n\r\n\r\n/**\r\n * @title IIdeaToken\r\n * @author Alexander Schlindwein\r\n *\r\n * @dev Simplified interface for WETH\r\n */\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n// File: contracts\\uniswap\\IUniswapV2Factory.sol\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address);\r\n}\r\n\r\n// File: contracts\\uniswap\\IUniswapV2Router01.sol\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts\\uniswap\\IUniswapV2Router02.sol\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\core\\interfaces\\IIdeaToken.sol\r\n\r\n\r\n\r\n/**\r\n * @title IIdeaToken\r\n * @author Alexander Schlindwein\r\n */\r\ninterface IIdeaToken is IERC20 {\r\n    function initialize(string calldata __name, address owner) external;\r\n    function mint(address account, uint256 amount) external;\r\n    function burn(address account, uint256 amount) external;\r\n}\r\n\r\n// File: contracts\\core\\nameVerifiers\\IIdeaTokenNameVerifier.sol\r\n\r\n\r\n/**\r\n * @title IIdeaTokenNameVerifier\r\n * @author Alexander Schlindwein\r\n *\r\n * Interface for token name verifiers\r\n */\r\ninterface IIdeaTokenNameVerifier {\r\n    function verifyTokenName(string calldata name) external pure returns (bool);\r\n}\r\n\r\n// File: contracts\\core\\interfaces\\IIdeaTokenFactory.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IIdeaTokenFactory\r\n * @author Alexander Schlindwein\r\n */\r\n\r\nstruct IDPair {\r\n    bool exists;\r\n    uint marketID;\r\n    uint tokenID;\r\n}\r\n\r\nstruct TokenInfo {\r\n    bool exists;\r\n    uint id;\r\n    string name;\r\n    IIdeaToken ideaToken;\r\n}\r\n\r\nstruct MarketDetails {\r\n    bool exists;\r\n    uint id;\r\n    string name;\r\n\r\n    IIdeaTokenNameVerifier nameVerifier;\r\n    uint numTokens;\r\n\r\n    uint baseCost;\r\n    uint priceRise;\r\n    uint hatchTokens;\r\n    uint tradingFeeRate;\r\n    uint platformFeeRate;\r\n\r\n    bool allInterestToPlatform;\r\n}\r\n\r\ninterface IIdeaTokenFactory {\r\n    function addMarket(string calldata marketName, address nameVerifier,\r\n                       uint baseCost, uint priceRise, uint hatchTokens,\r\n                       uint tradingFeeRate, uint platformFeeRate, bool allInterestToPlatform) external;\r\n\r\n    function addToken(string calldata tokenName, uint marketID, address lister) external;\r\n\r\n    function isValidTokenName(string calldata tokenName, uint marketID) external view returns (bool);\r\n    function getMarketIDByName(string calldata marketName) external view returns (uint);\r\n    function getMarketDetailsByID(uint marketID) external view returns (MarketDetails memory);\r\n    function getMarketDetailsByName(string calldata marketName) external view returns (MarketDetails memory);\r\n    function getMarketDetailsByTokenAddress(address ideaToken) external view returns (MarketDetails memory);\r\n    function getNumMarkets() external view returns (uint);\r\n    function getTokenIDByName(string calldata tokenName, uint marketID) external view returns (uint);\r\n    function getTokenInfo(uint marketID, uint tokenID) external view returns (TokenInfo memory);\r\n    function getTokenIDPair(address token) external view returns (IDPair memory);\r\n    function setTradingFee(uint marketID, uint tradingFeeRate) external;\r\n    function setPlatformFee(uint marketID, uint platformFeeRate) external;\r\n    function setNameVerifier(uint marketID, address nameVerifier) external;\r\n}\r\n\r\n// File: contracts\\core\\interfaces\\IIdeaTokenExchange.sol\r\n\r\n\r\n\r\n/**\r\n * @title IIdeaTokenExchange\r\n * @author Alexander Schlindwein\r\n */\r\n\r\nstruct CostAndPriceAmounts {\r\n    uint total;\r\n    uint raw;\r\n    uint tradingFee;\r\n    uint platformFee;\r\n}\r\n\r\ninterface IIdeaTokenExchange {\r\n    function sellTokens(address ideaToken, uint amount, uint minPrice, address recipient) external;\r\n    function getPriceForSellingTokens(address ideaToken, uint amount) external view returns (uint);\r\n    function getPricesForSellingTokens(MarketDetails memory marketDetails, uint supply, uint amount, bool feesDisabled) external pure returns (CostAndPriceAmounts memory);\r\n    function buyTokens(address ideaToken, uint amount, uint fallbackAmount, uint cost, address recipient) external;\r\n    function getCostForBuyingTokens(address ideaToken, uint amount) external view returns (uint);\r\n    function getCostsForBuyingTokens(MarketDetails memory marketDetails, uint supply, uint amount, bool feesDisabled) external pure returns (CostAndPriceAmounts memory);\r\n    function setTokenOwner(address ideaToken, address owner) external;\r\n    function setPlatformOwner(uint marketID, address owner) external;\r\n    function withdrawTradingFee() external;\r\n    function withdrawTokenInterest(address token) external;\r\n    function withdrawPlatformInterest(uint marketID) external;\r\n    function withdrawPlatformFee(uint marketID) external;\r\n    function getInterestPayable(address token) external view returns (uint);\r\n    function getPlatformInterestPayable(uint marketID) external view returns (uint);\r\n    function getPlatformFeePayable(uint marketID) external view returns (uint);\r\n    function getTradingFeePayable() external view returns (uint);\r\n    function setAuthorizer(address authorizer) external;\r\n    function isTokenFeeDisabled(address ideaToken) external view returns (bool);\r\n    function setTokenFeeKillswitch(address ideaToken, bool set) external;\r\n}\r\n\r\n// File: contracts\\core\\interfaces\\IIdeaTokenVault.sol\r\n\r\n\r\n/**\r\n * @title IIdeaTokenVault\r\n * @author Alexander Schlindwein\r\n */\r\n\r\nstruct LockedEntry {\r\n    uint lockedUntil;\r\n    uint lockedAmount;\r\n}\r\n    \r\ninterface IIdeaTokenVault {\r\n    function lock(address ideaToken, uint amount, uint duration, address recipient) external;\r\n    function withdraw(address ideaToken, uint[] calldata untils, address recipient) external;\r\n    function getLockedEntries(address ideaToken, address user, uint maxEntries) external view returns (LockedEntry[] memory);\r\n}\r\n\r\n// File: contracts\\core\\MultiAction.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @title MultiAction\r\n * @author Alexander Schlindwein\r\n *\r\n * Allows to bundle multiple actions into one tx\r\n */\r\ncontract MultiAction {\r\n\r\n    // IdeaTokenExchange contract\r\n    IIdeaTokenExchange _ideaTokenExchange;\r\n    // IdeaTokenFactory contract\r\n    IIdeaTokenFactory _ideaTokenFactory;\r\n    // IdeaTokenVault contract\r\n    IIdeaTokenVault _ideaTokenVault;\r\n    // Dai contract\r\n    IERC20 public _dai;\r\n    // IUniswapV2Factory contract\r\n    IUniswapV2Factory public _uniswapV2Factory;\r\n    // IUniswapV2Router02 contract\r\n    IUniswapV2Router02 public _uniswapV2Router02;\r\n    // WETH contract\r\n    IWETH public _weth;\r\n\r\n    /**\r\n     * @param ideaTokenExchange The address of the IdeaTokenExchange contract\r\n     * @param ideaTokenFactory The address of the IdeaTokenFactory contract\r\n     * @param ideaTokenVault The address of the IdeaTokenVault contract\r\n     * @param dai The address of the Dai token\r\n     * @param uniswapV2Router02 The address of the UniswapV2Router02 contract\r\n     * @param weth The address of the WETH token\r\n     */\r\n    constructor(address ideaTokenExchange,\r\n                address ideaTokenFactory,\r\n                address ideaTokenVault,\r\n                address dai,\r\n                address uniswapV2Router02,\r\n                address weth) public {\r\n\r\n        require(ideaTokenExchange != address(0) &&\r\n                ideaTokenFactory != address(0) &&\r\n                ideaTokenVault != address(0) &&\r\n                dai != address(0) &&\r\n                uniswapV2Router02 != address(0) &&\r\n                weth != address(0),\r\n                \"invalid-params\");\r\n\r\n        _ideaTokenExchange = IIdeaTokenExchange(ideaTokenExchange);\r\n        _ideaTokenFactory = IIdeaTokenFactory(ideaTokenFactory);\r\n        _ideaTokenVault = IIdeaTokenVault(ideaTokenVault);\r\n        _dai = IERC20(dai);\r\n        _uniswapV2Router02 = IUniswapV2Router02(uniswapV2Router02);\r\n        _uniswapV2Factory = IUniswapV2Factory(IUniswapV2Router02(uniswapV2Router02).factory());\r\n        _weth = IWETH(weth);\r\n    }\r\n\r\n    /**\r\n     * Converts inputCurrency to Dai on Uniswap and buys IdeaTokens\r\n     *\r\n     * @param inputCurrency The input currency\r\n     * @param ideaToken The IdeaToken to buy\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param fallbackAmount The amount of IdeaTokens to buy if the original amount cannot be bought\r\n     * @param cost The maximum cost in input currency\r\n     * @param lockDuration The duration in seconds to lock the tokens\r\n     * @param recipient The recipient of the IdeaTokens\r\n     */\r\n    function convertAndBuy(address inputCurrency,\r\n                           address ideaToken,\r\n                           uint amount,\r\n                           uint fallbackAmount,\r\n                           uint cost,\r\n                           uint lockDuration,\r\n                           address recipient) external payable {\r\n\r\n        IIdeaTokenExchange exchange = _ideaTokenExchange;\r\n\r\n        uint buyAmount = amount;\r\n        uint buyCost = exchange.getCostForBuyingTokens(ideaToken, amount);\r\n        uint requiredInput = getInputForOutputInternal(inputCurrency, address(_dai), buyCost);\r\n\r\n        if(requiredInput > cost) {\r\n            buyCost = exchange.getCostForBuyingTokens(ideaToken, fallbackAmount);\r\n            requiredInput = getInputForOutputInternal(inputCurrency, address(_dai), buyCost);\r\n            require(requiredInput <= cost, \"slippage\");\r\n            buyAmount = fallbackAmount;\r\n        }\r\n\r\n        convertAndBuyInternal(inputCurrency, ideaToken, requiredInput, buyAmount, buyCost, lockDuration, recipient);\r\n    }\r\n\r\n    /**\r\n     * Sells IdeaTokens and converts Dai to outputCurrency\r\n     *\r\n     * @param outputCurrency The output currency\r\n     * @param ideaToken The IdeaToken to sell\r\n     * @param amount The amount of IdeaTokens to sell\r\n     * @param minPrice The minimum price to receive for selling in outputCurrency\r\n     * @param recipient The recipient of the funds\r\n     */\r\n    function sellAndConvert(address outputCurrency,\r\n                            address ideaToken,\r\n                            uint amount,\r\n                            uint minPrice,\r\n                            address payable recipient) external {\r\n        \r\n        IIdeaTokenExchange exchange = _ideaTokenExchange;\r\n        IERC20 dai = _dai;\r\n\r\n        uint sellPrice = exchange.getPriceForSellingTokens(ideaToken, amount);\r\n        uint output = getOutputForInputInternal(address(dai), outputCurrency, sellPrice);\r\n        require(output >= minPrice, \"slippage\");\r\n\r\n        pullERC20Internal(ideaToken, msg.sender, amount);\r\n        exchange.sellTokens(ideaToken, amount, sellPrice, address(this));\r\n\r\n        convertInternal(address(dai), outputCurrency, sellPrice, output);\r\n        if(outputCurrency == address(0)) {\r\n            recipient.transfer(output);\r\n        } else {\r\n            require(IERC20(outputCurrency).transfer(recipient, output), \"transfer\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts `inputCurrency` to Dai, adds a token and buys the added token\r\n     * \r\n     * @param tokenName The name for the new IdeaToken\r\n     * @param marketID The ID of the market where the new token will be added\r\n     * @param inputCurrency The input currency to use for the purchase of the added token\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param fallbackAmount The amount of IdeaTokens to buy if the original amount cannot be bought\r\n     * @param cost The maximum cost in input currency\r\n     * @param lockDuration The duration in seconds to lock the tokens\r\n     * @param recipient The recipient of the IdeaTokens\r\n     */\r\n    function convertAddAndBuy(string calldata tokenName,\r\n                              uint marketID,\r\n                              address inputCurrency,\r\n                              uint amount,\r\n                              uint fallbackAmount,\r\n                              uint cost,\r\n                              uint lockDuration,\r\n                              address recipient) external payable {\r\n\r\n        IERC20 dai = _dai;\r\n\r\n        uint buyAmount = amount;\r\n        uint buyCost = getBuyCostFromZeroSupplyInternal(marketID, buyAmount);\r\n        uint requiredInput = getInputForOutputInternal(inputCurrency, address(dai), buyCost);\r\n\r\n        if(requiredInput > cost) {\r\n            buyCost = getBuyCostFromZeroSupplyInternal(marketID, fallbackAmount);\r\n            requiredInput = getInputForOutputInternal(inputCurrency, address(dai), buyCost);\r\n            require(requiredInput <= cost, \"slippage\");\r\n            buyAmount = fallbackAmount;\r\n        }\r\n\r\n        address ideaToken = addTokenInternal(tokenName, marketID);\r\n        convertAndBuyInternal(inputCurrency, ideaToken, requiredInput, buyAmount, buyCost, lockDuration, recipient);\r\n    }\r\n\r\n    /**\r\n     * Adds a token and buys it\r\n     * \r\n     * @param tokenName The name for the new IdeaToken\r\n     * @param marketID The ID of the market where the new token will be added\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param lockDuration The duration in seconds to lock the tokens\r\n     * @param recipient The recipient of the IdeaTokens\r\n     */\r\n    function addAndBuy(string calldata tokenName, uint marketID, uint amount, uint lockDuration, address recipient) external {\r\n        uint cost = getBuyCostFromZeroSupplyInternal(marketID, amount);\r\n        pullERC20Internal(address(_dai), msg.sender, cost);\r\n\r\n        address ideaToken = addTokenInternal(tokenName, marketID);\r\n        \r\n        if(lockDuration > 0) {\r\n            buyAndLockInternal(ideaToken, amount, cost, lockDuration, recipient);\r\n        } else {\r\n            buyInternal(ideaToken, amount, cost, recipient);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Buys a IdeaToken and locks it in the IdeaTokenVault\r\n     *\r\n     * @param ideaToken The IdeaToken to buy\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param fallbackAmount The amount of IdeaTokens to buy if the original amount cannot be bought\r\n     * @param cost The maximum cost in input currency\r\n     * @param recipient The recipient of the IdeaTokens\r\n     */\r\n    function buyAndLock(address ideaToken, uint amount, uint fallbackAmount, uint cost, uint lockDuration, address recipient) external {\r\n\r\n        IIdeaTokenExchange exchange = _ideaTokenExchange;\r\n\r\n        uint buyAmount = amount;\r\n        uint buyCost = exchange.getCostForBuyingTokens(ideaToken, amount);\r\n        if(buyCost > cost) {\r\n            buyCost = exchange.getCostForBuyingTokens(ideaToken, fallbackAmount);\r\n            require(buyCost <= cost, \"slippage\");\r\n            buyAmount = fallbackAmount;\r\n        }\r\n\r\n        pullERC20Internal(address(_dai), msg.sender, buyCost);\r\n        buyAndLockInternal(ideaToken, buyAmount, buyCost, lockDuration, recipient);\r\n    }\r\n\r\n    /**\r\n     * Converts `inputCurrency` to Dai on Uniswap and buys an IdeaToken, optionally locking it in the IdeaTokenVault\r\n     *\r\n     * @param inputCurrency The input currency to use\r\n     * @param ideaToken The IdeaToken to buy\r\n     * @param input The amount of `inputCurrency` to sell\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param cost The cost in Dai for purchasing `amount` IdeaTokens\r\n     * @param lockDuration The duration in seconds to lock the tokens\r\n     * @param recipient The recipient of the IdeaTokens\r\n     */\r\n    function convertAndBuyInternal(address inputCurrency, address ideaToken, uint input, uint amount, uint cost, uint lockDuration, address recipient) internal {\r\n        if(inputCurrency != address(0)) {\r\n            pullERC20Internal(inputCurrency, msg.sender, input);\r\n        }\r\n\r\n        convertInternal(inputCurrency, address(_dai), input, cost);\r\n\r\n        if(lockDuration > 0) {\r\n            buyAndLockInternal(ideaToken, amount, cost, lockDuration, recipient);\r\n        } else {\r\n            buyInternal(ideaToken, amount, cost, recipient);\r\n        }\r\n\r\n        /*\r\n            If the user has paid with ETH and we had to fallback there will be ETH left.\r\n            Refund the remaining ETH to the user.\r\n        */\r\n        if(address(this).balance > 0) {\r\n            msg.sender.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Buys and locks an IdeaToken in the IdeaTokenVault\r\n     *\r\n     * @param ideaToken The IdeaToken to buy\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param cost The cost in Dai for the purchase of `amount` IdeaTokens\r\n     * @param recipient The recipient of the locked IdeaTokens\r\n     */\r\n    function buyAndLockInternal(address ideaToken, uint amount, uint cost, uint lockDuration, address recipient) internal {\r\n\r\n        IIdeaTokenVault vault = _ideaTokenVault;\r\n    \r\n        buyInternal(ideaToken, amount, cost, address(this));\r\n        require(IERC20(ideaToken).approve(address(vault), amount), \"approve\");\r\n        vault.lock(ideaToken, amount, lockDuration, recipient);\r\n    }\r\n\r\n    /**\r\n     * Buys an IdeaToken\r\n     *\r\n     * @param ideaToken The IdeaToken to buy\r\n     * @param amount The amount of IdeaTokens to buy\r\n     * @param cost The cost in Dai for the purchase of `amount` IdeaTokens\r\n     * @param recipient The recipient of the bought IdeaTokens \r\n     */\r\n    function buyInternal(address ideaToken, uint amount, uint cost, address recipient) internal {\r\n\r\n        IIdeaTokenExchange exchange = _ideaTokenExchange;\r\n\r\n        require(_dai.approve(address(exchange), cost), \"approve\");\r\n        exchange.buyTokens(ideaToken, amount, amount, cost, recipient);\r\n    }\r\n\r\n    /**\r\n     * Adds a new IdeaToken\r\n     *\r\n     * @param tokenName The name of the new token\r\n     * @param marketID The ID of the market where the new token will be added\r\n     *\r\n     * @return The address of the new IdeaToken\r\n     */\r\n    function addTokenInternal(string memory tokenName, uint marketID) internal returns (address) {\r\n\r\n        IIdeaTokenFactory factory = _ideaTokenFactory;\r\n\r\n        factory.addToken(tokenName, marketID, msg.sender);\r\n        return address(factory.getTokenInfo(marketID, factory.getTokenIDByName(tokenName, marketID) ).ideaToken);\r\n    }\r\n\r\n    /**\r\n     * Transfers ERC20 from an address to this contract\r\n     *\r\n     * @param token The ERC20 token to transfer\r\n     * @param from The address to transfer from\r\n     * @param amount The amount of tokens to transfer\r\n     */\r\n    function pullERC20Internal(address token, address from, uint amount) internal {\r\n        require(IERC20(token).allowance(from, address(this)) >= amount, \"insufficient-allowance\");\r\n        require(IERC20(token).transferFrom(from, address(this), amount), \"transfer\");\r\n    }\r\n\r\n    /**\r\n     * Returns the cost for buying IdeaTokens on a given market from zero supply\r\n     *\r\n     * @param marketID The ID of the market on which the IdeaToken is listed\r\n     * @param amount The amount of IdeaTokens to buy\r\n     *\r\n     * @return The cost for buying IdeaTokens on a given market from zero supply\r\n     */\r\n    function getBuyCostFromZeroSupplyInternal(uint marketID, uint amount) internal view returns (uint) {\r\n        MarketDetails memory marketDetails = _ideaTokenFactory.getMarketDetailsByID(marketID);\r\n        require(marketDetails.exists, \"invalid-market\");\r\n\r\n        return _ideaTokenExchange.getCostsForBuyingTokens(marketDetails, 0, amount, false).total;\r\n    }\r\n\r\n    /**\r\n     * Returns the required input to get a given output from an Uniswap swap\r\n     *\r\n     * @param inputCurrency The input currency\r\n     * @param outputCurrency The output currency\r\n     * @param outputAmount The desired output amount \r\n     *\r\n     * @return The required input to get a `outputAmount` from an Uniswap swap\r\n     */\r\n    function getInputForOutputInternal(address inputCurrency, address outputCurrency, uint outputAmount) internal view returns (uint) {\r\n        address[] memory path = getPathInternal(inputCurrency, outputCurrency);\r\n        return _uniswapV2Router02.getAmountsIn(outputAmount, path)[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the output for a given input for an Uniswap swap\r\n     *\r\n     * @param inputCurrency The input currency\r\n     * @param outputCurrency The output currency\r\n     * @param inputAmount The desired input amount \r\n     *\r\n     * @return The output for `inputAmount` for an Uniswap swap\r\n     */\r\n    function getOutputForInputInternal(address inputCurrency, address outputCurrency, uint inputAmount) internal view returns (uint) {\r\n        address[] memory path = getPathInternal(inputCurrency, outputCurrency);\r\n        uint[] memory amountsOut = _uniswapV2Router02.getAmountsOut(inputAmount, path);\r\n        return amountsOut[amountsOut.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns the Uniswap path from `inputCurrency` to `outputCurrency`\r\n     *\r\n     * @param inputCurrency The input currency\r\n     * @param outputCurrency The output currency\r\n     *\r\n     * @return The Uniswap path from `inputCurrency` to `outputCurrency`\r\n     */\r\n    function getPathInternal(address inputCurrency, address outputCurrency) internal view returns (address[] memory) {\r\n\r\n        address wethAddress = address(_weth);\r\n        address updatedInputCurrency = inputCurrency == address(0) ? wethAddress : inputCurrency;\r\n        address updatedOutputCurrency = outputCurrency == address(0) ? wethAddress : outputCurrency;\r\n\r\n        IUniswapV2Factory uniswapFactory = _uniswapV2Factory;\r\n        if(uniswapFactory.getPair(updatedInputCurrency, updatedOutputCurrency) != address(0)) {\r\n            // Direct path exists\r\n             address[] memory path = new address[](2);\r\n             path[0] = updatedInputCurrency;\r\n             path[1] = updatedOutputCurrency;\r\n             return path;\r\n        }\r\n\r\n        // Direct path does not exist\r\n        // Check for 3-hop path: input -> weth -> output\r\n\r\n        require(uniswapFactory.getPair(updatedInputCurrency, wethAddress) != address(0) &&\r\n                uniswapFactory.getPair(wethAddress, updatedOutputCurrency) != address(0),\r\n                \"no-path\");\r\n\r\n\r\n        // 3-hop path exists\r\n        address[] memory path = new address[](3);\r\n        path[0] = updatedInputCurrency;\r\n        path[1] = wethAddress;\r\n        path[2] = updatedOutputCurrency;\r\n\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Converts from `inputCurrency` to `outputCurrency` using Uniswap\r\n     *\r\n     * @param inputCurrency The input currency\r\n     * @param outputCurrency The output currency\r\n     * @param inputAmount The input amount\r\n     * @param outputAmount The output amount\r\n     */\r\n    function convertInternal(address inputCurrency, address outputCurrency, uint inputAmount, uint outputAmount) internal {\r\n        \r\n        IWETH weth = _weth;\r\n        IUniswapV2Router02 router = _uniswapV2Router02;\r\n\r\n        address[] memory path = getPathInternal(inputCurrency, outputCurrency);\r\n    \r\n        IERC20 inputERC20;\r\n        if(inputCurrency == address(0)) {\r\n            // If the input is ETH we convert to WETH\r\n            weth.deposit{value: inputAmount}();\r\n            inputERC20 = IERC20(address(weth));\r\n        } else {\r\n            inputERC20 = IERC20(inputCurrency);\r\n        }\r\n\r\n        require(inputERC20.approve(address(router), inputAmount), \"router-approve\");\r\n\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(inputAmount,\r\n                                                                     outputAmount,\r\n                                                                     path,\r\n                                                                     address(this),\r\n                                                                     now + 1);\r\n\r\n        if(outputCurrency == address(0)) {\r\n            // If the output is ETH we withdraw from WETH\r\n            weth.withdraw(outputAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fallback required for WETH withdraw. Fails if sender is not WETH contract\r\n     */\r\n    receive() external payable {\r\n        require(msg.sender == address(_weth));\r\n    } \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ideaTokenExchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ideaTokenFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ideaTokenVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapV2Router02\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_dai\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Router02\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"marketID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"addAndBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ideaToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buyAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"marketID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inputCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"convertAddAndBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputCurrency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ideaToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"convertAndBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outputCurrency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ideaToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sellAndConvert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MultiAction","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000be7e6a7cd3bebc1776e64e988bd1518aa3ad29a40000000000000000000000004bc73348b49f8794fb8b4bdee17b1825e5805dbc000000000000000000000000e4f2a4df3722be05abcd49ab734d303b2bbbcd650000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1d0165e1bc26a85eab189e8c4aa27f5389f4c2379e92b8112a1b5d9f83472ef6"}]}