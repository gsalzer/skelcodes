{"status":"1","message":"OK","result":[{"SourceCode":"#@version 0.2.7\r\n\"\"\"\r\n@title Yearn Token Vault\r\n@license GNU AGPLv3\r\n@author yearn.finance\r\n@notice\r\n    Yearn Token Vault. Holds an underlying token, and allows users to interact\r\n    with the Yearn ecosystem through Strategies connected to the Vault.\r\n    Vaults are not limited to a single Strategy, they can have as many Strategies\r\n    as can be designed (however the withdrawal queue is capped at 20.)\r\n\r\n    Deposited funds are moved into the most impactful strategy that has not\r\n    already reached its limit for assets under management, regardless of which\r\n    Strategy a user's funds end up in, they receive their portion of yields\r\n    generated across all Strategies.\r\n\r\n    When a user withdraws, if there are no funds sitting undeployed in the\r\n    Vault, the Vault withdraws funds from Strategies in the order of least\r\n    impact. (Funds are taken from the Strategy that will disturb everyone's\r\n    gains the least, then the next least, etc.) In order to achieve this, the\r\n    withdrawal queue's order must be properly set and managed by the community\r\n    (through governance).\r\n\r\n    Vault Strategies are parameterized to pursue the highest risk-adjusted yield.\r\n\r\n    There is an \"Emergency Shutdown\" mode. When the Vault is put into emergency\r\n    shutdown, assets will be recalled from the Strategies as quickly as is\r\n    practical (given on-chain conditions), minimizing loss. Deposits are\r\n    halted, new Strategies may not be added, and each Strategy exits with the\r\n    minimum possible damage to position, while opening up deposits to be\r\n    withdrawn by users. There are no restrictions on withdrawals above what is\r\n    expected under Normal Operation.\r\n\r\n    For further details, please refer to the specification:\r\n    https://github.com/iearn-finance/yearn-vaults/blob/master/SPECIFICATION.md\r\n\"\"\"\r\n\r\nAPI_VERSION: constant(String[28]) = \"0.1.3\"\r\n\r\n# TODO: Add ETH Configuration\r\n# TODO: Add Delegated Configuration\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\ninterface DetailedERC20:\r\n    def name() -> String[42]: view\r\n    def symbol() -> String[20]: view\r\n    def decimals() -> uint256: view\r\n\r\ninterface Strategy:\r\n    def distributeRewards(_shares: uint256): nonpayable\r\n    def estimatedTotalAssets() -> uint256: view\r\n    def withdraw(_amount: uint256): nonpayable\r\n    def migrate(_newStrategy: address): nonpayable\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\ntotalSupply: public(uint256)\r\n\r\ntoken: public(ERC20)\r\ngovernance: public(address)\r\nguardian: public(address)\r\npendingGovernance: address\r\n\r\nstruct StrategyParams:\r\n    performanceFee: uint256  # Strategist's fee (basis points)\r\n    activation: uint256  # Activation block.number\r\n    debtLimit: uint256  # Maximum borrow amount\r\n    rateLimit: uint256  # Increase/decrease per block\r\n    lastReport: uint256  # block.number of the last time a report occured\r\n    totalDebt: uint256  # Total outstanding debt that Strategy has\r\n    totalReturns: uint256  # Total returns that Strategy has realized for Vault\r\n\r\nevent StrategyAdded:\r\n    strategy: indexed(address)\r\n    debtLimit: uint256  # Maximum borrow amount\r\n    rateLimit: uint256  # Increase/decrease per block\r\n    performanceFee: uint256  # Strategist's fee (basis points)\r\n\r\nevent StrategyReported:\r\n    strategy: indexed(address)\r\n    returnAdded: uint256\r\n    debtAdded: uint256\r\n    totalReturn: uint256\r\n    totalDebt: uint256\r\n    debtLimit: uint256\r\n\r\n# NOTE: Track the total for overhead targeting purposes\r\nstrategies: public(HashMap[address, StrategyParams])\r\nMAXIMUM_STRATEGIES: constant(uint256) = 20\r\n\r\n# Ordering that `withdraw` uses to determine which strategies to pull funds from\r\n# NOTE: Does *NOT* have to match the ordering of all the current strategies that\r\n#       exist, but it is recommended that it does or else withdrawal depth is\r\n#       limited to only those inside the queue.\r\n# NOTE: Ordering is determined by governance, and should be balanced according\r\n#       to risk, slippage, and/or volatility. Can also be ordered to increase the\r\n#       withdrawal speed of a particular Strategy.\r\n# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\r\nwithdrawalQueue: public(address[MAXIMUM_STRATEGIES])\r\n\r\nemergencyShutdown: public(bool)\r\n\r\ndepositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\r\ndebtLimit: public(uint256)  # Debt limit for the Vault across all strategies\r\ntotalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\r\nlastReport: public(uint256)  # Number of blocks since last report\r\n\r\nrewards: public(address)  # Rewards contract where Governance fees are sent to\r\nmanagementFee: public(uint256)  # Governance Fee for management of Vault (given to `rewards`)\r\nperformanceFee: public(uint256)  # Governance Fee for performance of Vault (given to `rewards`)\r\nFEE_MAX: constant(uint256) = 10_000  # 100%, or 10k basis points\r\nBLOCKS_PER_YEAR: constant(uint256) = 2_300_000\r\n\r\n@external\r\ndef __init__(\r\n    _token: address,\r\n    _governance: address,\r\n    _rewards: address,\r\n    _nameOverride: String[64],\r\n    _symbolOverride: String[32]\r\n):\r\n    \"\"\"\r\n    @notice\r\n        Initializes the Vault, this is called only once, when the contract is\r\n        deployed.\r\n        The performance fee is set to 4.5% of yield, per Strategy.\r\n        The management fee is set to 2%, per year.\r\n        There is no initial deposit limit.\r\n    @dev\r\n        If `_nameOverride` is not specified, the name will be 'yearn'\r\n        combined with the name of _token.\r\n\r\n        If `_symbolOverride` is not specified, the symbol will be 'y'\r\n        combined with the symbol of _token.\r\n    @param _token The token that may be deposited into this Vault.\r\n    @param _governance The address authorized for governance interactions.\r\n    @param _rewards The address to distribute rewards to.\r\n    @param _nameOverride Specify a custom Vault name. Leave empty for default choice.\r\n    @param _symbolOverride Specify a custom Vault symbol name. Leave empty for default choice.\r\n    \"\"\"\r\n    # TODO: Non-detailed Configuration?\r\n    self.token = ERC20(_token)\r\n    if _nameOverride == \"\":\r\n        self.name = concat(DetailedERC20(_token).symbol(), \" yVault\")\r\n    else:\r\n        self.name = _nameOverride\r\n    if _symbolOverride == \"\":\r\n        self.symbol = concat(\"yv\", DetailedERC20(_token).symbol())\r\n    else:\r\n        self.symbol = _symbolOverride\r\n    self.decimals = DetailedERC20(_token).decimals()\r\n    self.governance = _governance\r\n    self.rewards = _rewards\r\n    self.guardian = msg.sender\r\n    self.performanceFee = 450  # 4.5% of yield (per Strategy)\r\n    self.managementFee = 200  # 2% per year\r\n    self.depositLimit = MAX_UINT256  # Start unlimited\r\n    self.lastReport = block.number\r\n\r\n\r\n@pure\r\n@external\r\ndef apiVersion() -> String[28]:\r\n    \"\"\"\r\n    @notice\r\n        Used to track the deployed version of this contract. In practice you\r\n        can use this version number to compare with yEarn's GitHub and\r\n        determine which version of the source matches this deployed contract.\r\n    @return API_VERSION which holds the current version of this contract.\r\n    \"\"\"\r\n    return API_VERSION\r\n\r\n\r\n@external\r\ndef setName(_name: String[42]):\r\n    assert msg.sender == self.governance\r\n    self.name = _name\r\n\r\n\r\n@external\r\ndef setSymbol(_symbol: String[20]):\r\n    assert msg.sender == self.governance\r\n    self.symbol = _symbol\r\n\r\n\r\n# 2-phase commit for a change in governance\r\n@external\r\ndef setGovernance(_governance: address):\r\n    \"\"\"\r\n    @notice\r\n        Nominate a new address to use as governance.\r\n\r\n        The change does not go into effect immediately. This function sets a\r\n        pending change, and the governance address is not updated until\r\n        the proposed governance address has accepted the responsibility.\r\n\r\n        This may only be called by the current governance address.\r\n    @param _governance The address requested to take over Vault governance.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    self.pendingGovernance = _governance\r\n\r\n\r\n@external\r\ndef acceptGovernance():\r\n    \"\"\"\r\n    @notice\r\n        Once a new governance address has been proposed using setGovernance(),\r\n        this function may be called by the proposed address to accept the\r\n        responsibility of taking over governance for this contract.\r\n\r\n        This may only be called by the proposed governance address.\r\n    @dev\r\n        setGovernance() should be called by the existing governance address,\r\n        prior to calling this function.\r\n    \"\"\"\r\n    assert msg.sender == self.pendingGovernance\r\n    self.governance = msg.sender\r\n\r\n\r\n@external\r\ndef setRewards(_rewards: address):\r\n    \"\"\"\r\n    @notice\r\n        Changes the rewards address. Any distributed rewards\r\n        will cease flowing to the old address and begin flowing\r\n        to this address once the change is in effect.\r\n\r\n        This will not change any Strategy reports in progress, only\r\n        new reports made after this change goes into effect.\r\n\r\n        This may only be called by governance.\r\n    @param _rewards The address to use for collecting rewards.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    self.rewards = _rewards\r\n\r\n\r\n@external\r\ndef setDepositLimit(_limit: uint256):\r\n    \"\"\"\r\n    @notice\r\n        Changes the maximum amount of tokens that can be deposited in this Vault.\r\n\r\n        Note, this is not how much may be deposited by a single depositor,\r\n        but the maximum amount that may be deposited across all depositors.\r\n\r\n        This may only be called by governance.\r\n    @param _limit The new deposit limit to use.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    self.depositLimit = _limit\r\n\r\n\r\n@external\r\ndef setPerformanceFee(_fee: uint256):\r\n    \"\"\"\r\n    @notice\r\n        Used to change the value of `performanceFee`.\r\n\r\n        This may only be called by governance.\r\n    @param _fee The new performance fee to use.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    self.performanceFee = _fee\r\n\r\n\r\n@external\r\ndef setManagementFee(_fee: uint256):\r\n    \"\"\"\r\n    @notice\r\n        Used to change the value of `managementFee`.\r\n\r\n        This may only be called by governance.\r\n    @param _fee The new management fee to use.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    self.managementFee = _fee\r\n\r\n\r\n@external\r\ndef setGuardian(_guardian: address):\r\n    \"\"\"\r\n    @notice\r\n        Used to change the address of `guardian`.\r\n\r\n        This may only be called by governance or the existing guardian.\r\n    @param _guardian The new guardian address to use.\r\n    \"\"\"\r\n    assert msg.sender in [self.guardian, self.governance]\r\n    self.guardian = _guardian\r\n\r\n\r\n@external\r\ndef setEmergencyShutdown(_active: bool):\r\n    \"\"\"\r\n    @notice\r\n        Activates or deactivates Vault mode where all Strategies go into full\r\n        withdrawal.\r\n\r\n        During Emergency Shutdown:\r\n        1. No Users may deposit into the Vault (but may withdraw as usual.)\r\n        2. Governance may not add new Strategies.\r\n        3. Each Strategy must pay back their debt as quickly as reasonable to\r\n            minimally affect their position.\r\n        4. Only Governance may undo Emergency Shutdown.\r\n\r\n        See contract level note for further details.\r\n\r\n        This may only be called by governance or the guardian.\r\n    @param _active\r\n        If true, the Vault goes into Emergency Shutdown. If false, the Vault\r\n        goes back into Normal Operation.\r\n    \"\"\"\r\n    assert msg.sender in [self.guardian, self.governance]\r\n    self.emergencyShutdown = _active\r\n\r\n\r\n@external\r\ndef setWithdrawalQueue(_queue: address[MAXIMUM_STRATEGIES]):\r\n    \"\"\"\r\n    @notice\r\n        Updates the withdrawalQueue to match the addresses and order specified\r\n        by `_queue`.\r\n\r\n        There can be fewer strategies than the maximum, as well as fewer than\r\n        the total number of strategies active in the vault. `withdrawalQueue`\r\n        will be updated in a gas-efficient manner, assuming the input is well-\r\n        ordered with 0x0 only at the end.\r\n\r\n        This may only be called by governance.\r\n    @dev\r\n        This is order sensitive, specify the addresses in the order in which\r\n        funds should be withdrawn (so `_queue`[0] is the first Strategy withdrawn\r\n        from, `_queue`[1] is the second, etc.)\r\n\r\n        This means that the least impactful Strategy (the Strategy that will have\r\n        its core positions impacted the least by having funds removed) should be\r\n        at `_queue`[0], then the next least impactful at `_queue`[1], and so on.\r\n    @param _queue\r\n        The array of addresses to use as the new withdrawal queue. This is\r\n        order sensitive.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    # HACK: Temporary until Vyper adds support for Dynamic arrays\r\n    for i in range(MAXIMUM_STRATEGIES):\r\n        if _queue[i] == ZERO_ADDRESS and self.withdrawalQueue[i] == ZERO_ADDRESS:\r\n            break\r\n        assert self.strategies[_queue[i]].activation > 0\r\n        self.withdrawalQueue[i] = _queue[i]\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    # See note on `transfer()`.\r\n\r\n    # Protect people from accidentally sending their shares to bad places\r\n    assert not (_to in [self, ZERO_ADDRESS])\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@external\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice\r\n        Transfers shares from the caller's address to `_to`. This function\r\n        will always return true, unless the user is attempting to transfer\r\n        shares to this contract's address, or to 0x0.\r\n    @param _to\r\n        The address shares are being transferred to. Must not be this contract's\r\n        address, must not be 0x0.\r\n    @param _value The quantity of shares to transfer.\r\n    @return\r\n        True if transfer is sent to an address other than this contract's or\r\n        0x0, otherwise the transaction will fail.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice\r\n        Transfers `_value` shares from `_from` to `_to`. This operation will\r\n        always return true, unless the user is attempting to transfer shares\r\n        to this contract's address, or to 0x0.\r\n\r\n        Unless the caller has given this contract unlimited approval,\r\n        transfering shares will decrement the caller's `allowance` by `_value`.\r\n    @param _from The address shares are being transferred from.\r\n    @param _to\r\n        The address shares are being transferred to. Must not be this contract's\r\n        address, must not be 0x0.\r\n    @param _value The quantity of shares to transfer.\r\n    @return\r\n        True if transfer is sent to an address other than this contract's or\r\n        0x0, otherwise the transaction will fail.\r\n    \"\"\"\r\n    if self.allowance[_from][msg.sender] < MAX_UINT256:  # Unlimited approval (saves an SSTORE)\r\n       self.allowance[_from][msg.sender] -= _value\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of\r\n         `msg.sender`. Beware that changing an allowance with this method brings the risk\r\n         that someone may use both the old and the new allowance by unfortunate transaction\r\n         ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Increase the allowance of the passed address to spend the total amount of tokens\r\n         on behalf of msg.sender. This method mitigates the risk that someone may use both\r\n         the old and the new allowance by unfortunate transaction ordering.\r\n         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to increase the allowance by.\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] += _value\r\n    log Approval(msg.sender, _spender, self.allowance[msg.sender][_spender])\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Decrease the allowance of the passed address to spend the total amount of tokens\r\n         on behalf of msg.sender. This method mitigates the risk that someone may use both\r\n         the old and the new allowance by unfortunate transaction ordering.\r\n         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds.\r\n    @param _value The amount of tokens to decrease the allowance by.\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] -= _value\r\n    log Approval(msg.sender, _spender, self.allowance[msg.sender][_spender])\r\n    return True\r\n\r\n\r\n@view\r\n@internal\r\ndef _totalAssets() -> uint256:\r\n    # See note on `totalAssets()`.\r\n    return self.token.balanceOf(self) + self.totalDebt\r\n\r\n\r\n@view\r\n@external\r\ndef totalAssets() -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Returns the total quantity of all assets under control of this\r\n        Vault, whether they're loaned out to a Strategy, or currently held in\r\n        the Vault.\r\n    @return The total assets under control of this Vault.\r\n    \"\"\"\r\n    return self._totalAssets()\r\n\r\n\r\n@view\r\n@internal\r\ndef _balanceSheetOfStrategy(_strategy: address) -> uint256:\r\n    # See note on `balanceSheetOfStrategy()`.\r\n    return Strategy(_strategy).estimatedTotalAssets()\r\n\r\n\r\n@view\r\n@external\r\ndef balanceSheetOfStrategy(_strategy: address) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Provide an accurate estimate for the total amount of assets\r\n        (principle + return) that `_strategy` is currently managing,\r\n        denominated in terms of `_token`.\r\n\r\n        This total is the total realizable value that could *actually* be\r\n        obtained from this Strategy if it were to divest its entire position\r\n        based on current on-chain conditions.\r\n    @param _strategy The Strategy to estimate the realizable assets of.\r\n    @return An estimate of the total realizable assets in `_strategy`.\r\n    \"\"\"\r\n    return self._balanceSheetOfStrategy(_strategy)\r\n\r\n\r\n@view\r\n@external\r\ndef totalBalanceSheet(_strategies: address[2 * MAXIMUM_STRATEGIES]) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Measure the total balance sheet of this Vault, using the list of\r\n        strategies given above.\r\n        (2x the expected maximum is used to ensure completeness.)\r\n        NOTE: The safety of this function depends *entirely* on the list of\r\n            strategies given as the function argument. Care should be taken to\r\n            choose this list to ensure that the estimate is accurate. No\r\n            additional checking is used.\r\n        NOTE: Guardian should use this value vs. `totalAssets()` to determine\r\n            if a condition exists where the Vault is experiencing a dangerous\r\n            'balance sheet' attack, leading Vault shares to be worth less than\r\n            what their price on paper is (based on their debt)\r\n    @param _strategies\r\n        A list of strategies managed by this Vault, which will be included in\r\n        the balance sheet calculation.\r\n    @return The total balance sheet of this Vault.\r\n    \"\"\"\r\n    balanceSheet: uint256 = self.token.balanceOf(self)\r\n\r\n    for strategy in _strategies:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n        balanceSheet += self._balanceSheetOfStrategy(strategy)\r\n\r\n    return balanceSheet\r\n\r\n\r\n@internal\r\ndef _issueSharesForAmount(_to: address, _amount: uint256) -> uint256:\r\n    # Issues `_amount` Vault shares to `_to`.\r\n    # Shares must be issued prior to taking on new collateral, or\r\n    # calculation will be wrong. This means that only *trusted* tokens\r\n    # (with no capability for exploitive behavior) can be used.\r\n    shares: uint256 = 0\r\n    # HACK: Saves 2 SLOADs (~4000 gas)\r\n    totalSupply: uint256 = self.totalSupply\r\n    if totalSupply > 0:\r\n        # Mint amount of shares based on what the Vault is managing overall\r\n        shares = _amount * totalSupply / self._totalAssets()\r\n    else:\r\n        # No existing shares, so mint 1:1\r\n        shares = _amount\r\n\r\n    # Mint new shares\r\n    self.totalSupply = totalSupply + shares\r\n    self.balanceOf[_to] += shares\r\n    log Transfer(ZERO_ADDRESS, _to, shares)\r\n\r\n    return shares\r\n\r\n\r\n@external\r\ndef deposit(_amount: uint256 = MAX_UINT256, _recipient: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Deposits `_amount` `token`, issuing shares to `_recipient`. If the\r\n        Vault is in Emergency Shutdown, deposits will not be accepted and this\r\n        call will fail.\r\n    @dev\r\n        Measuring quantity of shares to issues is based on the total\r\n        outstanding debt that this contract has (\"expected value\") instead\r\n        of the total balance sheet it has (\"estimated value\") has important\r\n        security considerations, and is done intentionally. If this value were\r\n        measured against external systems, it could be purposely manipulated by\r\n        an attacker to withdraw more assets than they otherwise should be able\r\n        to claim by redeeming their shares.\r\n\r\n        On deposit, this means that shares are issued against the total amount\r\n        that the deposited capital can be given in service of the debt that\r\n        Strategies assume. If that number were to be lower than the \"expected\r\n        value\" at some future point, depositing shares via this method could\r\n        entitle the depositor to *less* than the deposited value once the\r\n        \"realized value\" is updated from further reports by the Strategies\r\n        to the Vaults.\r\n\r\n        Care should be taken by integrators to account for this discrepancy,\r\n        by using the view-only methods of this contract (both off-chain and\r\n        on-chain) to determine if depositing into the Vault is a \"good idea\".\r\n    @param _amount The quantity of tokens to deposit, defaults to all.\r\n    @param _recipient\r\n        The address to issue the shares in this Vault to. Defaults to the\r\n        caller's address.\r\n    @return The issued Vault shares.\r\n    \"\"\"\r\n    assert not self.emergencyShutdown  # Deposits are locked out\r\n\r\n    amount: uint256 = _amount\r\n\r\n    # If _amount not specified, transfer the full token balance\r\n    if amount == MAX_UINT256:\r\n        amount = self.token.balanceOf(msg.sender)\r\n\r\n    # Ensure we are depositing something\r\n    assert amount > 0\r\n\r\n    # Ensure deposit limit is respected\r\n    assert self._totalAssets() + amount <= self.depositLimit\r\n\r\n    # Issue new shares (needs to be done before taking deposit to be accurate)\r\n    # Shares are issued to recipient (may be different from msg.sender)\r\n    # See @dev note, above.\r\n    shares: uint256 = self._issueSharesForAmount(_recipient, amount)\r\n\r\n    # Get new collateral\r\n    reserve: uint256 = self.token.balanceOf(self)\r\n    # Tokens are transferred from msg.sender (may be different from _recipient)\r\n    self.token.transferFrom(msg.sender, self, amount)\r\n    # TODO: `Deflationary` configuration only\r\n    assert self.token.balanceOf(self) - reserve == amount  # Deflationary token check\r\n\r\n    return shares  # Just in case someone wants them\r\n\r\n\r\n@view\r\n@internal\r\ndef _shareValue(_shares: uint256) -> uint256:\r\n    # Determines the current value of `_shares`.\r\n    return (_shares * (self._totalAssets())) / self.totalSupply\r\n\r\n\r\n@view\r\n@internal\r\ndef _sharesForAmount(_amount: uint256) -> uint256:\r\n    # Determines how many shares `_amount` of token would receive.\r\n    # See dev note on `deposit`.\r\n    if self._totalAssets() > 0:\r\n        return (_amount * self.totalSupply) / self._totalAssets()\r\n    else:\r\n        return 0\r\n\r\n\r\n@view\r\n@external\r\ndef maxAvailableShares() -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Determines the total quantity of shares this Vault can provide,\r\n        factoring in assets currently residing in the Vault, as well as\r\n        those deployed to strategies.\r\n    @dev Regarding how shares are calculated, see dev note on `deposit`.\r\n    @return The total quantity of shares this Vault can provide.\r\n    \"\"\"\r\n    shares: uint256 = self._sharesForAmount(self.token.balanceOf(self))\r\n\r\n    for strategy in self.withdrawalQueue:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n        shares += self._sharesForAmount(self.strategies[strategy].totalDebt)\r\n\r\n    return shares\r\n\r\n\r\n@external\r\ndef withdraw(_shares: uint256 = MAX_UINT256, _recipient: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Withdraws the calling account's tokens from this Vault, redeeming\r\n        amount `_shares` for an appropriate amount of tokens.\r\n\r\n        See note on `setWithdrawalQueue` for further details of withdrawal\r\n        ordering and behavior.\r\n    @dev\r\n        Measuring the value of shares is based on the total outstanding debt\r\n        that this contract has (\"expected value\") instead of the total balance\r\n        sheet it has (\"estimated value\") has important security considerations,\r\n        and is done intentionally. If this value were measured against external\r\n        systems, it could be purposely manipulated by an attacker to withdraw\r\n        more assets than they otherwise should be able to claim by redeeming\r\n        their shares.\r\n\r\n        On withdrawal, this means that shares are redeemed against the total\r\n        amount that the deposited capital had \"realized\" since the point it\r\n        was deposited, up until the point it was withdrawn. If that number\r\n        were to be higher than the \"expected value\" at some future point,\r\n        withdrawing shares via this method could entitle the depositor to\r\n        *more* than the expected value once the \"realized value\" is updated\r\n        from further reports by the Strategies to the Vaults.\r\n\r\n        Under exceptional scenarios, this could cause earlier withdrawals to\r\n        earn \"more\" of the underlying assets than Users might otherwise be\r\n        entitled to, if the Vault's estimated value were otherwise measured\r\n        through external means, accounting for whatever exceptional scenarios\r\n        exist for the Vault (that aren't covered by the Vault's own design.)\r\n    @param _shares How many shares to redeem for tokens, defaults to all.\r\n    @param _recipient\r\n        The address to issue the shares in this Vault to. Defaults to the\r\n        caller's address.\r\n    @return The quantity of tokens redeemable for `_shares`.\r\n    \"\"\"\r\n    shares: uint256 = _shares  # May reduce this number below\r\n\r\n    # If _shares not specified, transfer full share balance\r\n    if shares == MAX_UINT256:\r\n        shares = self.balanceOf[msg.sender]\r\n\r\n    # Limit to only the shares they own\r\n    assert shares <= self.balanceOf[msg.sender]\r\n\r\n    # See @dev note, above.\r\n    value: uint256 = self._shareValue(shares)\r\n\r\n    if value > self.token.balanceOf(self):\r\n        # We need to go get some from our strategies in the withdrawal queue\r\n        # NOTE: This performs forced withdrawals from each Strategy. There is\r\n        #       a 0.5% withdrawal fee assessed on each forced withdrawal (<= 0.5% total)\r\n        for strategy in self.withdrawalQueue:\r\n            if strategy == ZERO_ADDRESS:\r\n                break  # We've exhausted the queue\r\n\r\n            amountNeeded: uint256 = value - self.token.balanceOf(self)\r\n\r\n            if amountNeeded == 0:\r\n                break  # We're done withdrawing\r\n\r\n            # NOTE: Don't withdraw more than the debt so that Strategy can still\r\n            #       continue to work based on the profits it has\r\n            # NOTE: This means that user will lose out on any profits that each\r\n            #       Strategy in the queue would return on next harvest, benefiting others\r\n            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\r\n            if amountNeeded == 0:\r\n                continue  # Nothing to withdraw from this Strategy, try the next one\r\n\r\n            # Force withdraw amount from each Strategy in the order set by governance\r\n            before: uint256 = self.token.balanceOf(self)\r\n            Strategy(strategy).withdraw(amountNeeded)\r\n            withdrawn: uint256 = self.token.balanceOf(self) - before\r\n\r\n            # Reduce the Strategy's debt by the amount withdrawn (\"realized returns\")\r\n            # NOTE: This doesn't add to returns as it's not earned by \"normal means\"\r\n            self.strategies[strategy].totalDebt -= withdrawn\r\n            self.totalDebt -= withdrawn\r\n\r\n    # NOTE: We have withdrawn everything possible out of the withdrawal queue\r\n    #       but we still don't have enough to fully pay them back, so adjust\r\n    #       to the total amount we've freed up through forced withdrawals\r\n    if value > self.token.balanceOf(self):\r\n        value = self.token.balanceOf(self)\r\n        shares = self._sharesForAmount(value)\r\n\r\n    # Burn shares (full value of what is being withdrawn)\r\n    self.totalSupply -= shares\r\n    self.balanceOf[msg.sender] -= shares\r\n    log Transfer(msg.sender, ZERO_ADDRESS, shares)\r\n\r\n    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\r\n    self.token.transfer(_recipient, value)\r\n\r\n    return value\r\n\r\n\r\n@view\r\n@external\r\ndef pricePerShare() -> uint256:\r\n    \"\"\"\r\n    @notice Gives the price for a single Vault share.\r\n    @dev See dev note on `withdraw`.\r\n    @return The value of a single share.\r\n    \"\"\"\r\n    return self._shareValue(10 ** self.decimals)\r\n\r\n\r\n@internal\r\ndef _organizeWithdrawalQueue():\r\n    # Reorganize `withdrawalQueue` based on premise that if there is an\r\n    # empty value between two actual values, then the empty value should be\r\n    # replaced by the later value.\r\n    # NOTE: Relative ordering of non-zero values is maintained.\r\n    offset: uint256 = 0\r\n    for idx in range(MAXIMUM_STRATEGIES):\r\n        strategy: address = self.withdrawalQueue[idx]\r\n        if strategy == ZERO_ADDRESS:\r\n            offset += 1  # how many values we need to shift, always `<= idx`\r\n        elif offset > 0:\r\n            self.withdrawalQueue[idx-offset] = strategy\r\n            self.withdrawalQueue[idx] = ZERO_ADDRESS\r\n\r\n\r\n@external\r\ndef addStrategy(\r\n    _strategy: address,\r\n    _debtLimit: uint256,\r\n    _rateLimit: uint256,\r\n    _performanceFee: uint256,\r\n):\r\n    \"\"\"\r\n    @notice\r\n        Add a Strategy to the Vault.\r\n\r\n        This may only be called by governance.\r\n    @dev\r\n        The Strategy will be appended to `withdrawalQueue`, call\r\n        `setWithdrawalQueue` to change the order.\r\n    @param _strategy The address of the Strategy to add.\r\n    @param _debtLimit The quantity of assets `_strategy` can manage.\r\n    @param _rateLimit\r\n        How many assets per block this Vault may deposit to or withdraw from\r\n        `_strategy`.\r\n    @param _performanceFee\r\n        The fee the strategist will receive based on this Vault's performance.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation == 0\r\n    self.strategies[_strategy] = StrategyParams({\r\n        performanceFee: _performanceFee,\r\n        activation: block.number,\r\n        debtLimit: _debtLimit,\r\n        rateLimit: _rateLimit,\r\n        lastReport: block.number,\r\n        totalDebt: 0,\r\n        totalReturns: 0,\r\n    })\r\n    self.debtLimit += _debtLimit\r\n    log StrategyAdded(_strategy, _debtLimit, _rateLimit, _performanceFee)\r\n\r\n    # queue is full\r\n    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\r\n    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\r\n    self._organizeWithdrawalQueue()\r\n\r\n\r\n@external\r\ndef updateStrategyDebtLimit(\r\n    _strategy: address,\r\n    _debtLimit: uint256,\r\n):\r\n    \"\"\"\r\n    @notice\r\n        Change the quantity of assets `_strategy` may manage.\r\n\r\n        This may only be called by governance.\r\n    @param _strategy The Strategy to update.\r\n    @param _debtLimit The quantity of assets `_strategy` may now manage.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation > 0\r\n    self.debtLimit -= self.strategies[_strategy].debtLimit\r\n    self.strategies[_strategy].debtLimit = _debtLimit\r\n    self.debtLimit += _debtLimit\r\n\r\n\r\n@external\r\ndef updateStrategyRateLimit(\r\n    _strategy: address,\r\n    _rateLimit: uint256,\r\n):\r\n    \"\"\"\r\n    @notice\r\n        Change the quantity assets per block this Vault may deposit to or\r\n        withdraw from `_strategy`.\r\n\r\n        This may only be called by governance.\r\n    @param _strategy The Strategy to update.\r\n    @param _rateLimit The quantity of assets `_strategy` may now manage.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation > 0\r\n    self.strategies[_strategy].rateLimit = _rateLimit\r\n\r\n\r\n@external\r\ndef updateStrategyPerformanceFee(\r\n    _strategy: address,\r\n    _performanceFee: uint256,\r\n):\r\n    \"\"\"\r\n    @notice\r\n        Change the fee the strategist will receive based on this Vault's\r\n        performance.\r\n\r\n        This may only be called by governance.\r\n    @param _strategy The Strategy to update.\r\n    @param _performanceFee The new fee the strategist will receive.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    assert self.strategies[_strategy].activation > 0\r\n    self.strategies[_strategy].performanceFee = _performanceFee\r\n\r\n\r\n@external\r\ndef migrateStrategy(_oldVersion: address, _newVersion: address):\r\n    \"\"\"\r\n    @notice\r\n        Migrates a Strategy, including all assets from `_oldVersion` to\r\n        `_newVersion`.\r\n\r\n        This may only be called by governance.\r\n    @dev\r\n        Strategy must successfully migrate all capital and positions to new\r\n        Strategy, or else this will upset the balance of the Vault.\r\n\r\n        The new Strategy should be \"empty\" e.g. have no prior commitments to\r\n        this Vault, otherwise it could have issues.\r\n    @param _oldVersion The existing Strategy to migrate from.\r\n    @param _newVersion The new Strategy to migrate to.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n\r\n    assert self.strategies[_oldVersion].activation > 0\r\n    assert self.strategies[_newVersion].activation == 0\r\n\r\n    strategy: StrategyParams = self.strategies[_oldVersion]\r\n    self.strategies[_oldVersion] = empty(StrategyParams)\r\n    self.strategies[_newVersion] = strategy\r\n\r\n    Strategy(_oldVersion).migrate(_newVersion)\r\n    # TODO: Ensure a smooth transition in terms of  Strategy return\r\n\r\n    for idx in range(MAXIMUM_STRATEGIES):\r\n        if self.withdrawalQueue[idx] == _oldVersion:\r\n            self.withdrawalQueue[idx] = _newVersion\r\n            return  # Don't need to reorder anything because we swapped\r\n\r\n\r\n@external\r\ndef revokeStrategy(_strategy: address = msg.sender):\r\n    \"\"\"\r\n    @notice\r\n        Revoke a Strategy, setting its debt limit to 0 and preventing any\r\n        future deposits.\r\n\r\n        This function should only be used in the scenario where the Strategy is\r\n        being retired but no migration of the positions are possible, or in the\r\n        extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\r\n        mode in order for it to exit as quickly as possible. The latter scenario\r\n        could be for any reason that is considered \"critical\" that the Strategy\r\n        exits its position as fast as possible, such as a sudden change in market\r\n        conditions leading to losses, or an imminent failure in an external\r\n        dependency.\r\n\r\n        This may only be called by governance, the guardian, or the Strategy\r\n        itself. Note that a Strategy will only revoke itself during emergency\r\n        shutdown.\r\n    @param _strategy The Strategy to revoke.\r\n    \"\"\"\r\n    assert msg.sender in [_strategy, self.governance, self.guardian]\r\n    self.debtLimit -= self.strategies[_strategy].debtLimit\r\n    self.strategies[_strategy].debtLimit = 0\r\n\r\n\r\n@external\r\ndef addStrategyToQueue(_strategy: address):\r\n    \"\"\"\r\n    @notice\r\n        Adds `_strategy` to `withdrawalQueue`.\r\n\r\n        This may only be called by governance.\r\n    @dev\r\n        The Strategy will be appended to `withdrawalQueue`, call\r\n        `setWithdrawalQueue` to change the order.\r\n    @param _strategy The Strategy to add.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    # Must be a current Strategy\r\n    assert self.strategies[_strategy].activation > 0 and self.strategies[_strategy].totalDebt > 0\r\n    # Check if queue is full\r\n    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\r\n    # Can't already be in the queue\r\n    for strategy in self.withdrawalQueue:\r\n        if strategy == ZERO_ADDRESS:\r\n            break\r\n        assert strategy != _strategy\r\n    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\r\n    self._organizeWithdrawalQueue()\r\n\r\n\r\n@external\r\ndef removeStrategyFromQueue(_strategy: address):\r\n    \"\"\"\r\n    @notice\r\n        Remove `_strategy` from `withdrawalQueue`.\r\n\r\n        This may only be called by governance.\r\n    @dev\r\n        We don't do this with revokeStrategy because it should still\r\n        be possible to withdraw from the Strategy if it's unwinding.\r\n    @param _strategy The Strategy to add.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    for idx in range(MAXIMUM_STRATEGIES):\r\n        if self.withdrawalQueue[idx] == _strategy:\r\n            self.withdrawalQueue[idx] = ZERO_ADDRESS\r\n            self._organizeWithdrawalQueue()\r\n            return  # We found the right location and cleared it\r\n    raise  # We didn't find the Strategy in the queue\r\n\r\n\r\n@view\r\n@internal\r\ndef _debtOutstanding(_strategy: address) -> uint256:\r\n    # See note on `debtOutstanding()`.\r\n    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\r\n    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\r\n\r\n    if self.emergencyShutdown:\r\n        return strategy_totalDebt\r\n    elif strategy_totalDebt <= strategy_debtLimit:\r\n        return 0\r\n    else:\r\n        return strategy_totalDebt - strategy_debtLimit\r\n\r\n\r\n@view\r\n@external\r\ndef debtOutstanding(_strategy: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Determines if `_strategy` is past its debt limit and if any tokens\r\n        should be withdrawn to the Vault.\r\n    @param _strategy The Strategy to check. Defaults to the caller.\r\n    @return The quantity of tokens to withdraw.\r\n    \"\"\"\r\n    return self._debtOutstanding(_strategy)\r\n\r\n\r\n@view\r\n@internal\r\ndef _creditAvailable(_strategy: address) -> uint256:\r\n    # See note on `creditAvailable()`.\r\n    if self.emergencyShutdown:\r\n        return 0\r\n\r\n    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\r\n    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\r\n    strategy_rateLimit: uint256 = self.strategies[_strategy].rateLimit\r\n    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\r\n\r\n    # Exhausted credit line\r\n    if strategy_debtLimit <= strategy_totalDebt or self.debtLimit <= self.totalDebt:\r\n        return 0\r\n\r\n    # Start with debt limit left for the Strategy\r\n    available: uint256 = strategy_debtLimit - strategy_totalDebt\r\n\r\n    # Adjust by the global debt limit left\r\n    available = min(available, self.debtLimit - self.totalDebt)\r\n\r\n    # Adjust by the rate limit algorithm (limits the step size per reporting period)\r\n    blockDelta: uint256 = block.number - strategy_lastReport\r\n    # NOTE: Protect against unnecessary overflow faults here\r\n    # NOTE: Set `strategy_rateLimit` to a really high number to disable the rate limit\r\n    # NOTE: *NEVER* set `strategy_rateLimit` to 0 or else this will always throw\r\n    if available / strategy_rateLimit >= blockDelta:\r\n        available = min(available, strategy_rateLimit * blockDelta)\r\n\r\n    # Can only borrow up to what the contract has in reserve\r\n    # NOTE: Running near 100% is discouraged\r\n    return min(available, self.token.balanceOf(self))\r\n\r\n\r\n@view\r\n@external\r\ndef creditAvailable(_strategy: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Amount of tokens in Vault a Strategy has access to as a credit line.\r\n\r\n        This will check the Strategy's debt limit, as well as the tokens\r\n        available in the Vault, and determine the maximum amount of tokens\r\n        (if any) the Strategy may draw on.\r\n\r\n        In the rare case the Vault is in emergency shutdown this will return 0.\r\n    @param _strategy The Strategy to check. Defaults to caller.\r\n    @return The quantity of tokens available for the Strategy to draw on.\r\n    \"\"\"\r\n    return self._creditAvailable(_strategy)\r\n\r\n\r\n@view\r\n@internal\r\ndef _expectedReturn(_strategy: address) -> uint256:\r\n    # See note on `expectedReturn()`.\r\n    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\r\n    strategy_totalReturns: uint256 = self.strategies[_strategy].totalReturns\r\n    strategy_activation: uint256 = self.strategies[_strategy].activation\r\n\r\n    blockDelta: uint256 = (block.number - strategy_lastReport)\r\n    if blockDelta > 0:\r\n        return (strategy_totalReturns * blockDelta) / (block.number - strategy_activation)\r\n    else:\r\n        return 0  # Covers the scenario when block.number == strategy_activation\r\n\r\n\r\n@view\r\n@external\r\ndef expectedReturn(_strategy: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Provide an accurate expected value for the return this `_strategy`\r\n        would provide to the Vault the next time `report()` is called\r\n        (since the last time it was called).\r\n    @param _strategy The Strategy to determine the expected return for. Defaults to caller.\r\n    @return\r\n        The anticipated amount `_strategy` should make on its investment\r\n        since its last report.\r\n    \"\"\"\r\n    return self._expectedReturn(_strategy)\r\n\r\n\r\n@external\r\ndef report(_return: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice\r\n        Reports the amount of assets the calling Strategy has free (usually in\r\n        terms of ROI).\r\n\r\n        This may only be called by a Strategy managed by this Vault.\r\n    @dev\r\n        For approved strategies, this is the most efficient behavior.\r\n        The Strategy reports back what it has free, then Vault \"decides\"\r\n        whether to take some back or give it more. Note that the most it can\r\n        take is `_return`, and the most it can give is all of the remaining\r\n        reserves. Anything outside of those bounds is abnormal behavior.\r\n\r\n        All approved strategies must have increased diligence around\r\n        calling this function, as abnormal behavior could become catastrophic.\r\n    @param _return\r\n        Amount Strategy has made on it's investment since its last report,\r\n        and is free to be given back to Vault as earnings\r\n    @return Amount of debt outstanding (iff totalDebt > debtLimit).\r\n    \"\"\"\r\n\r\n    # Only approved strategies can call this function\r\n    assert self.strategies[msg.sender].activation > 0\r\n\r\n    # Outstanding debt the Vault wants to take back from the Strategy (if any)\r\n    debt: uint256 = self._debtOutstanding(msg.sender)\r\n\r\n    # Issue new shares to cover fees\r\n    # NOTE: In effect, this reduces overall share price by the combined fee\r\n    governance_fee: uint256 = (\r\n        self._totalAssets() * (block.number - self.lastReport) * self.managementFee\r\n    ) / FEE_MAX / BLOCKS_PER_YEAR\r\n    self.lastReport = block.number\r\n    strategist_fee: uint256 = 0  # Only applies in certain conditions\r\n\r\n    # NOTE: Applies if Strategy is not shutting down, or it is but all debt paid off\r\n    # NOTE: No fee is taken when a Strategy is unwinding it's position, until all debt is paid\r\n    if  _return > debt:\r\n        strategist_fee = (\r\n            (_return - debt) * self.strategies[msg.sender].performanceFee\r\n        ) / FEE_MAX\r\n        governance_fee += (_return - debt) * self.performanceFee / FEE_MAX\r\n\r\n    # NOTE: This must be called prior to taking new collateral,\r\n    #       or the calculation will be wrong!\r\n    # NOTE: This must be done at the same time, to ensure the relative\r\n    #       ratio of governance_fee : strategist_fee is kept intact\r\n    total_fee: uint256 = governance_fee + strategist_fee\r\n    reward: uint256 = self._issueSharesForAmount(self, total_fee)\r\n\r\n    # Send the rewards out as new shares in this Vault\r\n    if strategist_fee > 0:\r\n        strategist_reward: uint256 = (strategist_fee * reward) / total_fee\r\n        self._transfer(self, msg.sender, strategist_reward)\r\n        Strategy(msg.sender).distributeRewards(strategist_reward)\r\n    # NOTE: Governance earns any dust leftover from flooring math above\r\n    self._transfer(self, self.rewards, self.balanceOf[self])\r\n\r\n    # Compute the line of credit the Vault is able to offer the Strategy (if any)\r\n    credit: uint256 = self._creditAvailable(msg.sender)\r\n\r\n    # Give/take balance to Strategy, based on the difference between the return and\r\n    # the credit increase we are offering (if any)\r\n    # NOTE: This is just used to adjust the balance of tokens between the Strategy and\r\n    #       the Vault based on the Strategy's debt limit (as well as the Vault's).\r\n    if _return < credit:  # credit surplus, give to Strategy\r\n        self.token.transfer(msg.sender, credit - _return)\r\n    elif _return > credit:  # credit deficit, take from Strategy\r\n        self.token.transferFrom(msg.sender, self, _return - credit)\r\n\r\n    # else, don't do anything because it is performing well as is\r\n\r\n    # Update the actual debt based on the full credit we are extending to the Strategy\r\n    # or the returns if we are taking funds back\r\n    # NOTE: credit + self.strategies[msg.sender].totalDebt is always < self.debtLimit\r\n    # NOTE: At least one of `credit` or `debt` is always 0 (both can be 0)\r\n    if credit > 0:\r\n        self.strategies[msg.sender].totalDebt += credit\r\n        self.totalDebt += credit\r\n\r\n        # Returns are always \"realized gains\"\r\n        self.strategies[msg.sender].totalReturns += _return\r\n\r\n    elif debt > 0:  # We're repaying debt now, so there are no gains\r\n        if _return <= debt:\r\n            # Pay down our debt with profit\r\n            # NOTE: Cannot return more than you borrowed\r\n            self.strategies[msg.sender].totalDebt -= _return\r\n            self.totalDebt -= _return\r\n            debt -= _return  # Debt payment complete (to report back to Strategy)\r\n\r\n        else:\r\n            # Finish off our debt payments here\r\n            self.totalDebt -= debt\r\n            self.strategies[msg.sender].totalDebt -= debt\r\n\r\n            # Returns are always \"realized gains\" (after we have paid off our debt)\r\n            self.strategies[msg.sender].totalReturns += _return - debt\r\n            debt = 0  # All debts paid off (to report back to Strategy)\r\n\r\n    elif _return > 0:  # No debt to pay, nor credit to expand with, add to profit!\r\n        self.strategies[msg.sender].totalReturns += _return\r\n\r\n    # else, no credit/debt to manage, nor returns to report. Nothing really happened!\r\n\r\n    # Update reporting time\r\n    self.strategies[msg.sender].lastReport = block.number\r\n\r\n    log StrategyReported(\r\n        msg.sender,\r\n        _return,\r\n        credit,\r\n        self.strategies[msg.sender].totalReturns,\r\n        self.strategies[msg.sender].totalDebt,\r\n        self.strategies[msg.sender].debtLimit,\r\n    )\r\n\r\n    if self.strategies[msg.sender].totalDebt == 0 or self.emergencyShutdown:\r\n        # Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\r\n        # NOTE: This is different than `debt` in order to extract *all* of the returns\r\n        return self._balanceSheetOfStrategy(msg.sender)\r\n    else:\r\n        # Otherwise, just return what we have as debt outstanding\r\n        return debt\r\n\r\n\r\n@internal\r\ndef erc20_safe_transfer(_token: address, _to: address, _value: uint256):\r\n    # Used only to send tokens that are not the type managed by this Vault.\r\n    # HACK: Used to handle non-compliant tokens like USDT\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_to, bytes32),\r\n            convert(_value, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"Transfer failed!\"\r\n\r\n\r\n@external\r\ndef sweep(_token: address):\r\n    \"\"\"\r\n    @notice\r\n        Removes tokens from this Vault that are not the type of token managed\r\n        by this Vault. This may be used in case of accidentally sending the\r\n        wrong kind of token to this Vault.\r\n\r\n        Tokens will be sent to `governance`.\r\n\r\n        This will fail if an attempt is made to sweep the tokens that this\r\n        Vault manages.\r\n\r\n        This may only be called by governance.\r\n    @param _token The token to transfer out of this vault.\r\n    \"\"\"\r\n    assert msg.sender == self.governance\r\n    # Can't be used to steal what this Vault is protecting\r\n    assert _token != self.token.address\r\n    self.erc20_safe_transfer(_token, self.governance, ERC20(_token).balanceOf(self))","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"sender\",\"indexed\":true},{\"type\":\"address\",\"name\":\"receiver\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StrategyAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"strategy\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"debtLimit\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"rateLimit\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"performanceFee\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StrategyReported\",\"inputs\":[{\"type\":\"address\",\"name\":\"strategy\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"returnAdded\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"debtAdded\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"totalReturn\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"totalDebt\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"debtLimit\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"},{\"type\":\"address\",\"name\":\"_governance\"},{\"type\":\"address\",\"name\":\"_rewards\"},{\"type\":\"string\",\"name\":\"_nameOverride\"},{\"type\":\"string\",\"name\":\"_symbolOverride\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"apiVersion\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\",\"gas\":4489},{\"name\":\"setName\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":106987},{\"name\":\"setSymbol\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_symbol\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":71837},{\"name\":\"setGovernance\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_governance\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36308},{\"name\":\"acceptGovernance\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36234},{\"name\":\"setRewards\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_rewards\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36368},{\"name\":\"setDepositLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_limit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36298},{\"name\":\"setPerformanceFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_fee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36328},{\"name\":\"setManagementFee\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_fee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36358},{\"name\":\"setGuardian\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_guardian\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37715},{\"name\":\"setEmergencyShutdown\",\"outputs\":[],\"inputs\":[{\"type\":\"bool\",\"name\":\"_active\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37745},{\"name\":\"setWithdrawalQueue\",\"outputs\":[],\"inputs\":[{\"type\":\"address[20]\",\"name\":\"_queue\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":750014},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":76559},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":113994},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38154},{\"name\":\"increaseAllowance\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":40195},{\"name\":\"decreaseAllowance\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":40219},{\"name\":\"totalAssets\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3883},{\"name\":\"balanceSheetOfStrategy\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2388},{\"name\":\"totalBalanceSheet\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address[40]\",\"name\":\"_strategies\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":74606},{\"name\":\"deposit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"deposit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"deposit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_amount\"},{\"type\":\"address\",\"name\":\"_recipient\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"maxAvailableShares\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":353431},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_shares\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_shares\"},{\"type\":\"address\",\"name\":\"_recipient\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"pricePerShare\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":11271},{\"name\":\"addStrategy\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_debtLimit\"},{\"type\":\"uint256\",\"name\":\"_rateLimit\"},{\"type\":\"uint256\",\"name\":\"_performanceFee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1425523},{\"name\":\"updateStrategyDebtLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_debtLimit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":111436},{\"name\":\"updateStrategyRateLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_rateLimit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38488},{\"name\":\"updateStrategyPerformanceFee\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"},{\"type\":\"uint256\",\"name\":\"_performanceFee\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38512},{\"name\":\"migrateStrategy\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_oldVersion\"},{\"type\":\"address\",\"name\":\"_newVersion\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1122429},{\"name\":\"revokeStrategy\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"revokeStrategy\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"addStrategyToQueue\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1195482},{\"name\":\"removeStrategyFromQueue\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":23066988},{\"name\":\"debtOutstanding\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"debtOutstanding\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"creditAvailable\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"creditAvailable\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"expectedReturn\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"expectedReturn\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_strategy\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"name\":\"report\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_return\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":457379},{\"name\":\"sweep\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_token\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":10734},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8903},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7956},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2561},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2806},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3051},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2651},{\"name\":\"token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2681},{\"name\":\"governance\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2711},{\"name\":\"guardian\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2741},{\"name\":\"strategies\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"performanceFee\"},{\"type\":\"uint256\",\"name\":\"activation\"},{\"type\":\"uint256\",\"name\":\"debtLimit\"},{\"type\":\"uint256\",\"name\":\"rateLimit\"},{\"type\":\"uint256\",\"name\":\"lastReport\"},{\"type\":\"uint256\",\"name\":\"totalDebt\"},{\"type\":\"uint256\",\"name\":\"totalReturns\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":9130},{\"name\":\"withdrawalQueue\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2910},{\"name\":\"emergencyShutdown\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2831},{\"name\":\"depositLimit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2861},{\"name\":\"debtLimit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2891},{\"name\":\"totalDebt\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2921},{\"name\":\"lastReport\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2951},{\"name\":\"rewards\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2981},{\"name\":\"managementFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3011},{\"name\":\"performanceFee\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":3041}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.7","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000584bc13c7d411c00c01a62e8019472de6876843000000000000000000000000073f2f3a4ff97b6a6d7afc03c449f0e9a0c0d90ab00000000000000000000000073f2f3a4ff97b6a6d7afc03c449f0e9a0c0d90ab00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}