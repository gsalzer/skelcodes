{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin \r\n   **/\r\n  function getAdmin() external view returns (address);\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin \r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period \r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\n\r\n/**\r\n * @title Time Locked Executor Contract, inherited by Aave Governance Executors\r\n * @dev Contract that can queue, execute, cancel transactions voted by Governance\r\n * Queued transactions can be executed after a delay and until\r\n * Grace period is not over.\r\n * @author Aave\r\n **/\r\ncontract ExecutorWithTimelock is IExecutorWithTimelock {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public immutable override GRACE_PERIOD;\r\n  uint256 public immutable override MINIMUM_DELAY;\r\n  uint256 public immutable override MAXIMUM_DELAY;\r\n\r\n  address private _admin;\r\n  address private _pendingAdmin;\r\n  uint256 private _delay;\r\n\r\n  mapping(bytes32 => bool) private _queuedTransactions;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   * @param admin admin address, that can call the main functions, (Governance)\r\n   * @param delay minimum time between queueing and execution of proposal\r\n   * @param gracePeriod time after `delay` while a proposal can be executed\r\n   * @param minimumDelay lower threshold of `delay`, in seconds\r\n   * @param maximumDelay upper threhold of `delay`, in seconds\r\n   **/\r\n  constructor(\r\n    address admin,\r\n    uint256 delay,\r\n    uint256 gracePeriod,\r\n    uint256 minimumDelay,\r\n    uint256 maximumDelay\r\n  ) {\r\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\r\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\r\n    _delay = delay;\r\n    _admin = admin;\r\n\r\n    GRACE_PERIOD = gracePeriod;\r\n    MINIMUM_DELAY = minimumDelay;\r\n    MAXIMUM_DELAY = maximumDelay;\r\n\r\n    emit NewDelay(delay);\r\n    emit NewAdmin(admin);\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == _admin, 'ONLY_BY_ADMIN');\r\n    _;\r\n  }\r\n\r\n  modifier onlyTimelock() {\r\n    require(msg.sender == address(this), 'ONLY_BY_THIS_TIMELOCK');\r\n    _;\r\n  }\r\n\r\n  modifier onlyPendingAdmin() {\r\n    require(msg.sender == _pendingAdmin, 'ONLY_BY_PENDING_ADMIN');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Set the delay\r\n   * @param delay delay between queue and execution of proposal\r\n   **/\r\n  function setDelay(uint256 delay) public onlyTimelock {\r\n    _validateDelay(delay);\r\n    _delay = delay;\r\n\r\n    emit NewDelay(delay);\r\n  }\r\n\r\n  /**\r\n   * @dev Function enabling pending admin to become admin\r\n   **/\r\n  function acceptAdmin() public onlyPendingAdmin {\r\n    _admin = msg.sender;\r\n    _pendingAdmin = address(0);\r\n\r\n    emit NewAdmin(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Setting a new pending admin (that can then become admin)\r\n   * Can only be called by this executor (i.e via proposal)\r\n   * @param newPendingAdmin address of the new admin\r\n   **/\r\n  function setPendingAdmin(address newPendingAdmin) public onlyTimelock {\r\n    _pendingAdmin = newPendingAdmin;\r\n\r\n    emit NewPendingAdmin(newPendingAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @return the action Hash\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) public override onlyAdmin returns (bytes32) {\r\n    require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\r\n\r\n    bytes32 actionHash = keccak256(\r\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\r\n    );\r\n    _queuedTransactions[actionHash] = true;\r\n\r\n    emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\r\n    return actionHash;\r\n  }\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @return the action Hash of the canceled tx\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) public override onlyAdmin returns (bytes32) {\r\n    bytes32 actionHash = keccak256(\r\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\r\n    );\r\n    _queuedTransactions[actionHash] = false;\r\n\r\n    emit CancelledAction(\r\n      actionHash,\r\n      target,\r\n      value,\r\n      signature,\r\n      data,\r\n      executionTime,\r\n      withDelegatecall\r\n    );\r\n    return actionHash;\r\n  }\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @return the callData executed as memory bytes\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) public payable override onlyAdmin returns (bytes memory) {\r\n    bytes32 actionHash = keccak256(\r\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\r\n    );\r\n    require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\r\n    require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\r\n    require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\r\n\r\n    _queuedTransactions[actionHash] = false;\r\n\r\n    bytes memory callData;\r\n\r\n    if (bytes(signature).length == 0) {\r\n      callData = data;\r\n    } else {\r\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n    }\r\n\r\n    bool success;\r\n    bytes memory resultData;\r\n    if (withDelegatecall) {\r\n      require(msg.value >= value, 'NOT_ENOUGH_MSG_VALUE');\r\n      // solium-disable-next-line security/no-call-value\r\n      (success, resultData) = target.delegatecall(callData);\r\n    } else {\r\n      // solium-disable-next-line security/no-call-value\r\n      (success, resultData) = target.call{value: value}(callData);\r\n    }\r\n\r\n    require(success, 'FAILED_ACTION_EXECUTION');\r\n\r\n    emit ExecutedAction(\r\n      actionHash,\r\n      target,\r\n      value,\r\n      signature,\r\n      data,\r\n      executionTime,\r\n      withDelegatecall,\r\n      resultData\r\n    );\r\n\r\n    return resultData;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view override returns (address) {\r\n    return _admin;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view override returns (address) {\r\n    return _pendingAdmin;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view override returns (uint256) {\r\n    return _delay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view override returns (bool) {\r\n    return _queuedTransactions[actionHash];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    IAaveGovernanceV2.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\r\n\r\n    return (block.timestamp > proposal.executionTime.add(GRACE_PERIOD));\r\n  }\r\n\r\n  function _validateDelay(uint256 delay) internal view {\r\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\r\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\r\n  }\r\n\r\n  receive() external payable {}\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Proposal Validator Contract, inherited by  Aave Governance Executors\r\n * @dev Validates/Invalidations propositions state modifications.\r\n * Proposition Power functions: Validates proposition creations/ cancellation\r\n * Voting Power functions: Validates success of propositions.\r\n * @author Aave\r\n **/\r\ncontract ProposalValidator is IProposalValidator {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public immutable override PROPOSITION_THRESHOLD;\r\n  uint256 public immutable override VOTING_DURATION;\r\n  uint256 public immutable override VOTE_DIFFERENTIAL;\r\n  uint256 public immutable override MINIMUM_QUORUM;\r\n  uint256 public constant override ONE_HUNDRED_WITH_PRECISION = 10000; // Equivalent to 100%, but scaled for precision\r\n\r\n  /**\r\n   * @dev Constructor\r\n   * @param propositionThreshold minimum percentage of supply needed to submit a proposal\r\n   * - In ONE_HUNDRED_WITH_PRECISION units\r\n   * @param votingDuration duration in blocks of the voting period\r\n   * @param voteDifferential percentage of supply that `for` votes need to be over `against`\r\n   *   in order for the proposal to pass\r\n   * - In ONE_HUNDRED_WITH_PRECISION units\r\n   * @param minimumQuorum minimum percentage of the supply in FOR-voting-power need for a proposal to pass\r\n   * - In ONE_HUNDRED_WITH_PRECISION units\r\n   **/\r\n  constructor(\r\n    uint256 propositionThreshold,\r\n    uint256 votingDuration,\r\n    uint256 voteDifferential,\r\n    uint256 minimumQuorum\r\n  ) {\r\n    PROPOSITION_THRESHOLD = propositionThreshold;\r\n    VOTING_DURATION = votingDuration;\r\n    VOTE_DIFFERENTIAL = voteDifferential;\r\n    MINIMUM_QUORUM = minimumQuorum;\r\n  }\r\n\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view override returns (bool) {\r\n    return isPropositionPowerEnough(governance, user, blockNumber);\r\n  }\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * Needs to creator to have lost proposition power threashold\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view override returns (bool) {\r\n    return !isPropositionPowerEnough(governance, user, blockNumber);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) public view override returns (bool) {\r\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\r\n      governance.getGovernanceStrategy()\r\n    );\r\n    return\r\n      currentGovernanceStrategy.getPropositionPowerAt(user, blockNumber) >=\r\n      getMinimumPropositionPowerNeeded(governance, blockNumber);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    IGovernanceStrategy currentGovernanceStrategy = IGovernanceStrategy(\r\n      governance.getGovernanceStrategy()\r\n    );\r\n    return\r\n      currentGovernanceStrategy\r\n        .getTotalPropositionSupplyAt(blockNumber)\r\n        .mul(PROPOSITION_THRESHOLD)\r\n        .div(ONE_HUNDRED_WITH_PRECISION);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    return (isQuorumValid(governance, proposalId) &&\r\n      isVoteDifferentialValid(governance, proposalId));\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return votingSupply.mul(MINIMUM_QUORUM).div(ONE_HUNDRED_WITH_PRECISION);\r\n  }\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    public\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    IAaveGovernanceV2.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\r\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\r\n      proposal.startBlock\r\n    );\r\n\r\n    return proposal.forVotes >= getMinimumVotingPowerNeeded(votingSupply);\r\n  }\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    public\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    IAaveGovernanceV2.ProposalWithoutVotes memory proposal = governance.getProposalById(proposalId);\r\n    uint256 votingSupply = IGovernanceStrategy(proposal.strategy).getTotalVotingSupplyAt(\r\n      proposal.startBlock\r\n    );\r\n\r\n    return (proposal.forVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply) >\r\n      proposal.againstVotes.mul(ONE_HUNDRED_WITH_PRECISION).div(votingSupply).add(\r\n        VOTE_DIFFERENTIAL\r\n      ));\r\n  }\r\n}\r\n\r\n/**\r\n * @title Time Locked, Validator, Executor Contract\r\n * @dev Contract\r\n * - Validate Proposal creations/ cancellation\r\n * - Validate Vote Quorum and Vote success on proposal\r\n * - Queue, Execute, Cancel, successful proposals' transactions.\r\n * @author Aave\r\n **/\r\ncontract Executor is ExecutorWithTimelock, ProposalValidator {\r\n  constructor(\r\n    address admin,\r\n    uint256 delay,\r\n    uint256 gracePeriod,\r\n    uint256 minimumDelay,\r\n    uint256 maximumDelay,\r\n    uint256 propositionThreshold,\r\n    uint256 voteDuration,\r\n    uint256 voteDifferential,\r\n    uint256 minimumQuorum\r\n  )\r\n    ExecutorWithTimelock(admin, delay, gracePeriod, minimumDelay, maximumDelay)\r\n    ProposalValidator(propositionThreshold, voteDuration, voteDifferential, minimumQuorum)\r\n  {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"propositionThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteDifferential\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumQuorum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"CancelledAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"resultData\",\"type\":\"bytes\"}],\"name\":\"ExecutedAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"NewDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"QueuedAction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_QUORUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED_WITH_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROPOSITION_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_DIFFERENTIAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTING_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"cancelTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getMinimumPropositionPowerNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"votingSupply\",\"type\":\"uint256\"}],\"name\":\"getMinimumVotingPowerNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"}],\"name\":\"isActionQueued\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalOverGracePeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalPassed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"isPropositionPowerEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isQuorumValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isVoteDifferentialValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withDelegatecall\",\"type\":\"bool\"}],\"name\":\"queueTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"validateCreatorOfProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"validateProposalCancellation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Executor","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ec568fffba86c094cf06b22134b23074dfe2252c00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000069780000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000000d2f0000000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000004b00000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000c8","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7d7b66ba28d046d4d656e4df247be53975f44c25e262124502e75f5724164379"}]}