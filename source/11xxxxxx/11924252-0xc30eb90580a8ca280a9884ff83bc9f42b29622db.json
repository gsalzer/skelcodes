{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.7.1;\r\n\r\n// File: contracts/oracle/RegularIntervalOracleInterface.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the regular interval price oracle.\r\n */\r\ninterface RegularIntervalOracleInterface {\r\n  function setPrice(uint256 roundId) external returns (bool);\r\n\r\n  function setOptimizedParameters(uint16 lambdaE4) external returns (bool);\r\n\r\n  function updateQuantsAddress(address quantsAddress) external returns (bool);\r\n\r\n  function getNormalizedTimeStamp(uint256 timestamp)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function getDecimals() external view returns (uint8);\r\n\r\n  function getInterval() external view returns (uint256);\r\n\r\n  function getLatestTimestamp() external view returns (uint256);\r\n\r\n  function getOldestTimestamp() external view returns (uint256);\r\n\r\n  function getVolatility() external view returns (uint256 volE8);\r\n\r\n  function getInfo() external view returns (address chainlink, address quants);\r\n\r\n  function getPrice() external view returns (uint256);\r\n\r\n  function setSequentialPrices(uint256[] calldata roundIds)\r\n    external\r\n    returns (bool);\r\n\r\n  function getPriceTimeOf(uint256 unixtime) external view returns (uint256);\r\n\r\n  function getVolatilityTimeOf(uint256 unixtime)\r\n    external\r\n    view\r\n    returns (uint256 volE8);\r\n\r\n  function getCurrentParameters()\r\n    external\r\n    view\r\n    returns (uint16 lambdaE4, uint16 dataNum);\r\n\r\n  function getVolatility(uint64 untilMaturity)\r\n    external\r\n    view\r\n    returns (uint64 volatilityE8);\r\n}\r\n\r\n// File: contracts/ChainLinkAggregator/ChainLinkAggregatorInterface.sol\r\n\r\n\r\n\r\n\r\n// https://github.com/smartcontractkit/chainlink/blob/feature/whitelisted-interface/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\r\n// https://github.com/smartcontractkit/chainlink/blob/feature/whitelisted-interface/evm-contracts/src/v0.6/interfaces/AggregatorInterface.sol\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n\r\n  function latestTimestamp() external view returns (uint256);\r\n\r\n  function latestRound() external view returns (uint256);\r\n\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint256 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint256 answeredInRound\r\n    );\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/oracle/RegularIntervalOracle.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Record chainlink price once a day\r\n */\r\ncontract RegularIntervalOracle is RegularIntervalOracleInterface {\r\n  using SafeCast for uint16;\r\n  using SafeCast for uint32;\r\n  using SafeCast for uint256;\r\n  using SafeMath for uint256;\r\n\r\n  struct PriceData {\r\n    uint64 priceE8;\r\n    uint64 ewmaVolatilityE8;\r\n  }\r\n\r\n  // Max ETH Price = $1 million per ETH\r\n  int256 constant MAX_VALID_ETHPRICE = 10**14;\r\n\r\n  /* ========== CONSTANT VARIABLES ========== */\r\n  AggregatorInterface immutable internal _chainlinkOracle;\r\n  uint256 immutable internal _interval;\r\n  uint8 immutable internal _decimals;\r\n  uint128 immutable internal _timeCorrectionFactor;\r\n  uint128 immutable internal _oldestTimestamp;\r\n  uint16 immutable internal _dataNum;\r\n\r\n  /* ========== STATE VARIABLES ========== */\r\n  address internal _quantsAddress;\r\n  uint256 internal _latestTimestamp;\r\n  mapping(uint256 => PriceData) internal _regularIntervalPriceData;\r\n  uint16 internal lambdaE4;\r\n\r\n  event LambdaChanged(uint16 newLambda);\r\n  event QuantsChanged(address newQuantsAddress);\r\n\r\n  /* ========== CONSTRUCTOR ========== */\r\n\r\n  /**\r\n   * @param quantsAddress can set optimized parameters\r\n   * @param chainlinkOracleAddress Chainlink price oracle\r\n   * @param startTimestamp Recording timestamp is startTimestamp +- n * interval\r\n   * @param interval Daily record = 3600*24\r\n   * @param decimals Decimals of price\r\n   */\r\n  constructor(\r\n    uint8 decimals,\r\n    uint16 initialLambdaE4,\r\n    uint16 initialDataNum,\r\n    uint32 initialVolE4,\r\n    address quantsAddress,\r\n    address chainlinkOracleAddress,\r\n    uint256 startTimestamp,\r\n    uint256 interval,\r\n    uint256 initialRoundId\r\n  ) {\r\n    _dataNum = initialDataNum;\r\n    lambdaE4 = initialLambdaE4;\r\n    _quantsAddress = quantsAddress;\r\n    _chainlinkOracle = AggregatorInterface(chainlinkOracleAddress);\r\n    _interval = interval;\r\n    _decimals = decimals;\r\n    _timeCorrectionFactor = uint128(startTimestamp % interval);\r\n    initialRoundId = _getValidRoundIDWithAggregator(initialRoundId, startTimestamp, AggregatorInterface(chainlinkOracleAddress));\r\n    int256 priceE8 = _getPriceFromChainlinkWithAggregator(initialRoundId, AggregatorInterface(chainlinkOracleAddress));\r\n    _regularIntervalPriceData[startTimestamp] = PriceData(\r\n      uint256(priceE8).toUint64(),\r\n      uint64(initialVolE4)\r\n    );\r\n    _latestTimestamp = uint128(startTimestamp);\r\n    _oldestTimestamp = uint128(startTimestamp);\r\n    require(initialDataNum > 1, \"Error: Decimals should be more than 0\");\r\n    require(quantsAddress != address(0), \"Error: Invalid initial quant address\");\r\n    require(chainlinkOracleAddress != address(0), \"Error: Invalid chainlink address\");\r\n    require(interval != 0, \"Error: Interval should be more than 0\");\r\n  }\r\n\r\n  /* ========== MUTABLE FUNCTIONS ========== */\r\n\r\n  /**\r\n   * @notice Set new price\r\n   * @dev Prices must be updated by regular interval\r\n   * @param roundId is chainlink roundId\r\n   */\r\n  function setPrice(uint256 roundId) public override returns (bool) {\r\n    _latestTimestamp += _interval;\r\n    require(_latestTimestamp <= block.timestamp, \"Error: This function should be after interval\");\r\n    //If next oldestTimestamp == _latestTimestamp\r\n\r\n    roundId = _getValidRoundID(roundId, _latestTimestamp);\r\n    _setPrice(roundId, _latestTimestamp);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set sequential prices\r\n   * @param roundIds Array of roundIds which contain the first timestamp after the regular interval timestamp\r\n   */\r\n  function setSequentialPrices(uint256[] calldata roundIds)\r\n    external\r\n    override\r\n    returns (bool)\r\n  {\r\n    uint256 roundIdsLength = roundIds.length;\r\n    uint256 normalizedCurrentTimestamp =\r\n      getNormalizedTimeStamp(block.timestamp);\r\n    require(_latestTimestamp <= normalizedCurrentTimestamp, \"Error: This function should be after interval\");\r\n    // If length of roundIds is too short or too long, return false\r\n    if (\r\n      (normalizedCurrentTimestamp - _latestTimestamp) / _interval <\r\n      roundIdsLength ||\r\n      roundIdsLength < 2\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    for (uint256 i = 0; i < roundIdsLength; i++) {\r\n      setPrice(roundIds[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Set optimized parameters for EWMA only by quants address\r\n   * Recalculate latest Volatility with new lambda\r\n   * Recalculation starts from price at `latestTimestamp - _dataNum * _interval`\r\n   */\r\n  function setOptimizedParameters(uint16 newLambdaE4)\r\n    external\r\n    override\r\n    onlyQuants\r\n    returns (bool)\r\n  {\r\n    \r\n    require(\r\n      newLambdaE4 > 9000 && newLambdaE4 < 10000,\r\n      \"new lambda is out of valid range\"\r\n    );\r\n    require(\r\n      (_latestTimestamp - _oldestTimestamp) / _interval > _dataNum,\r\n      \"Error: Insufficient number of data registered\"\r\n    );\r\n    lambdaE4 = newLambdaE4;\r\n    uint256 oldTimestamp = _latestTimestamp - _dataNum * _interval;\r\n    uint256 pNew = _getPrice(oldTimestamp + _interval);\r\n    uint256 updatedVol = _getVolatility(oldTimestamp);\r\n    for (uint256 i = 0; i < _dataNum; i++) {\r\n      updatedVol = _getEwmaVolatility(oldTimestamp, pNew, updatedVol);\r\n      oldTimestamp += _interval;\r\n      pNew = _getPrice(oldTimestamp + _interval);\r\n    }\r\n\r\n    _regularIntervalPriceData[_latestTimestamp].ewmaVolatilityE8 = updatedVol\r\n      .toUint64();\r\n    emit LambdaChanged(newLambdaE4);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Update quants address only by quants address\r\n   */\r\n  function updateQuantsAddress(address quantsAddress)\r\n    external\r\n    override\r\n    onlyQuants\r\n    returns (bool)\r\n  {\r\n    _quantsAddress = quantsAddress;\r\n    require(quantsAddress != address(0), \"Error: Invalid new quant address\");\r\n    emit QuantsChanged(quantsAddress);\r\n  }\r\n\r\n  /* ========== MODIFIERS ========== */\r\n\r\n  modifier onlyQuants() {\r\n    require(msg.sender == _quantsAddress, \"only quants address can call\");\r\n    _;\r\n  }\r\n\r\n  /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n  /**\r\n   * @return price at the `unixtime`\r\n   */\r\n  function _getPrice(uint256 unixtime) internal view returns (uint256) {\r\n    return _regularIntervalPriceData[unixtime].priceE8;\r\n  }\r\n\r\n  /**\r\n   * @return Volatility at the `unixtime`\r\n   */\r\n  function _getVolatility(uint256 unixtime) internal view returns (uint256) {\r\n    return _regularIntervalPriceData[unixtime].ewmaVolatilityE8;\r\n  }\r\n\r\n  /**\r\n   * @notice Get annualized ewma volatility.\r\n   * @param oldTimestamp is the previous term to calculate volatility\r\n   */\r\n  function _getEwmaVolatility(\r\n    uint256 oldTimestamp,\r\n    uint256 pNew,\r\n    uint256 oldVolE8\r\n  ) internal view returns (uint256 volE8) {\r\n    uint256 pOld = _getPrice(oldTimestamp);\r\n    uint256 rrE8 =\r\n      pNew >= pOld\r\n        ? ((pNew * (10**4)) / pOld - (10**4))**2\r\n        : ((10**4) - (pNew * (10**4)) / pOld)**2;\r\n    uint256 vol_2E16 =\r\n      (oldVolE8**2 * lambdaE4) / 10**4 + (10**4 - lambdaE4) * rrE8 * 10**4;\r\n    volE8 = _sqrt(vol_2E16);\r\n  }\r\n\r\n  /**\r\n   * @dev Calcurate an approximation of the square root of x by Babylonian method.\r\n   */\r\n  function _sqrt(uint256 x) internal pure returns (uint256 y) { \r\n    if (x > 3) {\r\n      uint z = x / 2 + 1; y = x;\r\n      while (z < y) {\r\n        y = z;\r\n        z = (x / z + z) / 2; \r\n      }\r\n    } else if (x != 0) { \r\n      y = 1;\r\n    } \r\n  }\r\n\r\n  function _getValidRoundID(uint256 hintID, uint256 targetTimeStamp)\r\n    internal\r\n    view\r\n    returns (uint256 roundID)\r\n  {\r\n    return _getValidRoundIDWithAggregator(hintID, targetTimeStamp, _chainlinkOracle);\r\n  }\r\n\r\n  function _getValidRoundIDWithAggregator(uint256 hintID, uint256 targetTimeStamp, AggregatorInterface _chainlinkAggregator)\r\n    internal\r\n    view\r\n    returns (uint256 roundID)\r\n  {\r\n    if (hintID == 0) {\r\n      hintID = _chainlinkAggregator.latestRound();\r\n    }\r\n    uint256 timeStampOfHintID = _chainlinkAggregator.getTimestamp(hintID);\r\n    require(\r\n      timeStampOfHintID >= targetTimeStamp,\r\n      \"Hint round or Latest round should be registered after target time\"\r\n    );\r\n    require(hintID != 0, \"Invalid hint ID\");\r\n    for (uint256 index = hintID - 1; index > 0; index--) {\r\n      uint256 timestamp = _chainlinkAggregator.getTimestamp(index);\r\n      if (timestamp != 0 && timestamp <= targetTimeStamp) {\r\n        return index + 1;\r\n      }\r\n    }\r\n    require(false, \"No valid round ID found\");\r\n  }\r\n\r\n  function _setPrice(uint256 roundId, uint256 timeStamp) internal {\r\n    int256 priceE8 = _getPriceFromChainlink(roundId);\r\n    require(priceE8 > 0, \"Should return valid price\");\r\n    uint256 ewmaVolatilityE8 =\r\n      _getEwmaVolatility(\r\n        timeStamp - _interval,\r\n        uint256(priceE8),\r\n        _getVolatility(timeStamp - _interval)\r\n      );\r\n    _regularIntervalPriceData[timeStamp] = PriceData(\r\n      uint256(priceE8).toUint64(),\r\n      ewmaVolatilityE8.toUint64()\r\n    );\r\n  }\r\n\r\n   function _getPriceFromChainlink(uint256 roundId)\r\n    internal\r\n    view\r\n    returns (int256 priceE8) {\r\n      return _getPriceFromChainlinkWithAggregator(roundId, _chainlinkOracle);\r\n    }\r\n\r\n\r\n  function _getPriceFromChainlinkWithAggregator(uint256 roundId, AggregatorInterface _chainlinkAggregator)\r\n    internal\r\n    view\r\n    returns (int256 priceE8)\r\n  {\r\n    while (true) {\r\n      priceE8 = _chainlinkAggregator.getAnswer(roundId);\r\n      if (priceE8 > 0 &&  priceE8 < MAX_VALID_ETHPRICE ) {\r\n        break;\r\n      }\r\n      roundId -= 1;\r\n    }\r\n  }\r\n\r\n  /* ========== CALL FUNCTIONS ========== */\r\n\r\n  /**\r\n   * @notice Calculate normalized timestamp to get valid value\r\n   */\r\n  function getNormalizedTimeStamp(uint256 timestamp)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return\r\n      ((timestamp.sub(_timeCorrectionFactor)) / _interval) *\r\n      _interval +\r\n      _timeCorrectionFactor;\r\n  }\r\n\r\n  function getInfo()\r\n    external\r\n    view\r\n    override\r\n    returns (address chainlink, address quants)\r\n  {\r\n    return (address(_chainlinkOracle), _quantsAddress);\r\n  }\r\n\r\n  /**\r\n   * @return Decimals of price\r\n   */\r\n  function getDecimals() external view override returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n   * @return Interval of historical data\r\n   */\r\n  function getInterval() external view override returns (uint256) {\r\n    return _interval;\r\n  }\r\n\r\n  /**\r\n   * @return Latest timestamp in this oracle\r\n   */\r\n  function getLatestTimestamp() external view override returns (uint256) {\r\n    return _latestTimestamp;\r\n  }\r\n\r\n  /**\r\n   * @return Oldest timestamp in this oracle\r\n   */\r\n  function getOldestTimestamp() external view override returns (uint256) {\r\n    return _oldestTimestamp;\r\n  }\r\n\r\n  function getPrice() external view override returns (uint256) {\r\n    return _getPrice(_latestTimestamp);\r\n  }\r\n\r\n  function getCurrentParameters()\r\n    external\r\n    view\r\n    override\r\n    returns (uint16 lambda, uint16 dataNum)\r\n  {\r\n    return (lambdaE4, _dataNum);\r\n  }\r\n\r\n  function getPriceTimeOf(uint256 unixtime)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 normalizedUnixtime = getNormalizedTimeStamp(unixtime);\r\n    return _getPrice(normalizedUnixtime);\r\n  }\r\n\r\n  function _getCurrentVolatility() internal view returns (uint256 volE8) {\r\n    uint256 latestRound = _chainlinkOracle.latestRound();\r\n    uint256 latestVolatility = _getVolatility(_latestTimestamp);\r\n    uint256 currentVolatility =\r\n      _getEwmaVolatility(\r\n        _latestTimestamp,\r\n        uint256(_getPriceFromChainlink(latestRound)),\r\n        _getVolatility(_latestTimestamp)\r\n      );\r\n    volE8 = latestVolatility >= currentVolatility\r\n      ? latestVolatility\r\n      : currentVolatility;\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate lastest ewmaVolatility\r\n   * @dev Calculate new volatility with chainlink price at latest round\r\n   * @param volE8 Return the larger of `latestVolatility` and `currentVolatility`\r\n   */\r\n  function getVolatility() external view override returns (uint256 volE8) {\r\n    volE8 = _getCurrentVolatility();\r\n  }\r\n\r\n  /**\r\n   * @notice This function has the same interface with Lien Volatility Oracle\r\n   */\r\n  function getVolatility(uint64)\r\n    external\r\n    view\r\n    override\r\n    returns (uint64 volatilityE8)\r\n  {\r\n    uint256 volE8 = _getCurrentVolatility();\r\n    return volE8.toUint64();\r\n  }\r\n\r\n  /**\r\n   * @notice Get registered ewmaVolatility of given timestamp\r\n   */\r\n  function getVolatilityTimeOf(uint256 unixtime)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256 volE8)\r\n  {\r\n    uint256 normalizedUnixtime = getNormalizedTimeStamp(unixtime);\r\n    return _regularIntervalPriceData[normalizedUnixtime].ewmaVolatilityE8;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"initialLambdaE4\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"initialDataNum\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"initialVolE4\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"quantsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chainlinkOracleAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRoundId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newLambda\",\"type\":\"uint16\"}],\"name\":\"LambdaChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newQuantsAddress\",\"type\":\"address\"}],\"name\":\"QuantsChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getCurrentParameters\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"lambda\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"dataNum\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"chainlink\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quants\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getNormalizedTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOldestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unixtime\",\"type\":\"uint256\"}],\"name\":\"getPriceTimeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVolatility\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"volE8\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"getVolatility\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"volatilityE8\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unixtime\",\"type\":\"uint256\"}],\"name\":\"getVolatilityTimeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"volE8\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newLambdaE4\",\"type\":\"uint16\"}],\"name\":\"setOptimizedParameters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"roundIds\",\"type\":\"uint256[]\"}],\"name\":\"setSequentialPrices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quantsAddress\",\"type\":\"address\"}],\"name\":\"updateQuantsAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RegularIntervalOracle","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000251c00000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000a961684a3a654fb2cca8f8991226c0cefc514d800000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419000000000000000000000000000000000000000000000000000000006017448000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000030000000000004349","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9d8f52bfe53a8863179843e6d2d6548ac10ea3ee0e94c21a4561cc41ce49fc6a"}]}