{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/optimistic-ethereum/OVM/chain/OVM_ChainStorageContainer.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n/* Library Imports */\\nimport { Lib_RingBuffer } from \\\"../../libraries/utils/Lib_RingBuffer.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_ChainStorageContainer } from \\\"../../iOVM/chain/iOVM_ChainStorageContainer.sol\\\";\\n\\n/**\\n * @title OVM_ChainStorageContainer\\n */\\ncontract OVM_ChainStorageContainer is iOVM_ChainStorageContainer, Lib_AddressResolver {\\n\\n    /*************\\n     * Libraries *\\n     *************/\\n\\n    using Lib_RingBuffer for Lib_RingBuffer.RingBuffer;\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    string public owner;\\n    Lib_RingBuffer.RingBuffer internal buffer;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n    \\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     * @param _owner Name of the contract that owns this container (will be resolved later).\\n     */\\n    constructor(\\n        address _libAddressManager,\\n        string memory _owner\\n    )\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        owner = _owner;\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n    \\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == resolve(owner),\\n            \\\"OVM_ChainStorageContainer: Function can only be called by the owner.\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function setGlobalMetadata(\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        return buffer.setExtraData(_globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function getGlobalMetadata()\\n        override\\n        public\\n        view\\n        returns (\\n            bytes27\\n        )\\n    {\\n        return buffer.getExtraData();\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function length()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(buffer.getLength());\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function push(\\n        bytes32 _object\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.push(_object);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function push(\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.push(_object, _globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function push2(\\n        bytes32 _objectA,\\n        bytes32 _objectB\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.push2(_objectA, _objectB);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function push2(\\n        bytes32 _objectA,\\n        bytes32 _objectB,\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.push2(_objectA, _objectB, _globalMetadata);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function get(\\n        uint256 _index\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return buffer.get(uint40(_index));\\n    }\\n    \\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.deleteElementsAfterInclusive(\\n            uint40(_index)\\n        );\\n    }\\n    \\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.deleteElementsAfterInclusive(\\n            uint40(_index),\\n            _globalMetadata\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_ChainStorageContainer\\n     */\\n    function setNextOverwritableIndex(\\n        uint256 _index\\n    )\\n        override\\n        public\\n        onlyOwner\\n    {\\n        buffer.nextOverwritableIndex = _index;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/utils/Lib_RingBuffer.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\nlibrary Lib_RingBuffer {\\n    using Lib_RingBuffer for RingBuffer;\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Buffer {\\n        uint256 length;\\n        mapping (uint256 => bytes32) buf;\\n    }\\n\\n    struct RingBuffer {\\n        bytes32 contextA;\\n        bytes32 contextB;\\n        Buffer bufferA;\\n        Buffer bufferB;\\n        uint256 nextOverwritableIndex;\\n    }\\n\\n    struct RingBufferContext {\\n        // contextA\\n        uint40 globalIndex;\\n        bytes27 extraData;\\n\\n        // contextB\\n        uint64 currBufferIndex;\\n        uint40 prevResetIndex;\\n        uint40 currResetIndex;\\n    }\\n\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant MIN_CAPACITY = 16;\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Pushes a single element to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _value Value to push to the buffer.\\n     * @param _extraData Optional global extra data.\\n     */\\n    function push(\\n        RingBuffer storage _self,\\n        bytes32 _value,\\n        bytes27 _extraData\\n    )\\n        internal\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n        Buffer storage currBuffer = _self.getBuffer(ctx.currBufferIndex);\\n\\n        // Set a minimum capacity.\\n        if (currBuffer.length == 0) {\\n            currBuffer.length = MIN_CAPACITY;\\n        }\\n\\n        // Check if we need to expand the buffer.\\n        if (ctx.globalIndex - ctx.currResetIndex >= currBuffer.length) {\\n            if (ctx.currResetIndex < _self.nextOverwritableIndex) {\\n                // We're going to overwrite the inactive buffer.\\n                // Bump the buffer index, reset the delete offset, and set our reset indices.\\n                ctx.currBufferIndex++;\\n                ctx.prevResetIndex = ctx.currResetIndex;\\n                ctx.currResetIndex = ctx.globalIndex;\\n\\n                // Swap over to the next buffer.\\n                currBuffer = _self.getBuffer(ctx.currBufferIndex);\\n            } else {\\n                // We're not overwriting yet, double the length of the current buffer.\\n                currBuffer.length *= 2;\\n            }\\n        }\\n\\n        // Index to write to is the difference of the global and reset indices.\\n        uint256 writeHead = ctx.globalIndex - ctx.currResetIndex;\\n        currBuffer.buf[writeHead] = _value;\\n\\n        // Bump the global index and insert our extra data, then save the context.\\n        ctx.globalIndex++;\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Pushes a single element to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _value Value to push to the buffer.\\n     */\\n    function push(\\n        RingBuffer storage _self,\\n        bytes32 _value\\n    )\\n        internal\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n        \\n        _self.push(\\n            _value,\\n            ctx.extraData\\n        );\\n    }\\n\\n    /**\\n     * Pushes a two elements to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _valueA First value to push to the buffer.\\n     * @param _valueA Second value to push to the buffer.\\n     * @param _extraData Optional global extra data.\\n     */\\n    function push2(\\n        RingBuffer storage _self,\\n        bytes32 _valueA,\\n        bytes32 _valueB,\\n        bytes27 _extraData\\n    )\\n        internal\\n    {\\n        _self.push(_valueA, _extraData);\\n        _self.push(_valueB, _extraData);\\n    }\\n\\n    /**\\n     * Pushes a two elements to the buffer.\\n     * @param _self Buffer to access.\\n     * @param _valueA First value to push to the buffer.\\n     * @param _valueA Second value to push to the buffer.\\n     */\\n    function push2(\\n        RingBuffer storage _self,\\n        bytes32 _valueA,\\n        bytes32 _valueB\\n    )\\n        internal\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n\\n        _self.push2(\\n            _valueA,\\n            _valueB,\\n            ctx.extraData\\n        );\\n    }\\n\\n    /**\\n     * Retrieves an element from the buffer.\\n     * @param _self Buffer to access.\\n     * @param _index Element index to retrieve.\\n     * @return Value of the element at the given index.\\n     */\\n    function get(\\n        RingBuffer storage _self,\\n        uint256 _index\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32    \\n        )\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n\\n        require(\\n            _index < ctx.globalIndex,\\n            \\\"Index out of bounds.\\\"\\n        );\\n\\n        Buffer storage currBuffer = _self.getBuffer(ctx.currBufferIndex);\\n        Buffer storage prevBuffer = _self.getBuffer(ctx.currBufferIndex + 1);\\n\\n        if (_index >= ctx.currResetIndex) {\\n            // We're trying to load an element from the current buffer.\\n            // Relative index is just the difference from the reset index.\\n            uint256 relativeIndex = _index - ctx.currResetIndex;\\n\\n            // Shouldn't happen but why not check.\\n            require(\\n                relativeIndex < currBuffer.length,\\n                \\\"Index out of bounds.\\\"\\n            );\\n\\n            return currBuffer.buf[relativeIndex];\\n        } else {\\n            // We're trying to load an element from the previous buffer.\\n            // Relative index is the difference from the reset index in the other direction.\\n            uint256 relativeIndex = ctx.currResetIndex - _index;\\n\\n            // Condition only fails in the case that we deleted and flipped buffers.\\n            require(\\n                ctx.currResetIndex > ctx.prevResetIndex,\\n                \\\"Index out of bounds.\\\"\\n            );\\n\\n            // Make sure we're not trying to read beyond the array.\\n            require(\\n                relativeIndex <= prevBuffer.length,\\n                \\\"Index out of bounds.\\\"\\n            );\\n\\n            return prevBuffer.buf[prevBuffer.length - relativeIndex];\\n        }\\n    }\\n\\n    /**\\n     * Deletes all elements after (and including) a given index.\\n     * @param _self Buffer to access.\\n     * @param _index Index of the element to delete from (inclusive).\\n     * @param _extraData Optional global extra data.\\n     */\\n    function deleteElementsAfterInclusive(\\n        RingBuffer storage _self,\\n        uint40 _index,\\n        bytes27 _extraData\\n    )\\n        internal\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n\\n        require(\\n            _index < ctx.globalIndex && _index >= ctx.prevResetIndex,\\n            \\\"Index out of bounds.\\\"\\n        );\\n\\n        Buffer storage currBuffer = _self.getBuffer(ctx.currBufferIndex);\\n        Buffer storage prevBuffer = _self.getBuffer(ctx.currBufferIndex + 1);\\n\\n        if (_index < ctx.currResetIndex) {\\n            // We're switching back to the previous buffer.\\n            // Reduce the buffer index, set the current reset index back to match the previous one.\\n            // We use the equality of these two values to prevent reading beyond this buffer.\\n            ctx.currBufferIndex--;\\n            ctx.currResetIndex = ctx.prevResetIndex;\\n        }\\n\\n        // Set our global index and extra data, save the context.\\n        ctx.globalIndex = _index;\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Deletes all elements after (and including) a given index.\\n     * @param _self Buffer to access.\\n     * @param _index Index of the element to delete from (inclusive).\\n     */\\n    function deleteElementsAfterInclusive(\\n        RingBuffer storage _self,\\n        uint40 _index\\n    )\\n        internal\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n        _self.deleteElementsAfterInclusive(\\n            _index,\\n            ctx.extraData\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the current global index.\\n     * @param _self Buffer to access.\\n     * @return Current global index.\\n     */\\n    function getLength(\\n        RingBuffer storage _self\\n    )\\n        internal\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n        return ctx.globalIndex;\\n    }\\n\\n    /**\\n     * Changes current global extra data.\\n     * @param _self Buffer to access.\\n     * @param _extraData New global extra data.\\n     */\\n    function setExtraData(\\n        RingBuffer storage _self,\\n        bytes27 _extraData\\n    )\\n        internal\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n        ctx.extraData = _extraData;\\n        _self.setContext(ctx);\\n    }\\n\\n    /**\\n     * Retrieves the current global extra data.\\n     * @param _self Buffer to access.\\n     * @return Current global extra data.\\n     */\\n    function getExtraData(\\n        RingBuffer storage _self\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes27\\n        )\\n    {\\n        RingBufferContext memory ctx = _self.getContext();\\n        return ctx.extraData;\\n    }\\n\\n    /**\\n     * Sets the current ring buffer context.\\n     * @param _self Buffer to access.\\n     * @param _ctx Current ring buffer context.\\n     */\\n    function setContext(\\n        RingBuffer storage _self,\\n        RingBufferContext memory _ctx\\n    )\\n        internal\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes32 contextA;\\n        bytes32 contextB;\\n\\n        uint40 globalIndex = _ctx.globalIndex;\\n        bytes27 extraData = _ctx.extraData;\\n        assembly {\\n            contextA := globalIndex\\n            contextA := or(contextA, extraData)\\n        }\\n\\n        uint64 currBufferIndex = _ctx.currBufferIndex;\\n        uint40 prevResetIndex = _ctx.prevResetIndex;\\n        uint40 currResetIndex = _ctx.currResetIndex;\\n        assembly {\\n            contextB := currBufferIndex\\n            contextB := or(contextB, shl(64, prevResetIndex))\\n            contextB := or(contextB, shl(104, currResetIndex))\\n        }\\n\\n        if (_self.contextA != contextA) {\\n            _self.contextA = contextA;\\n        }\\n\\n        if (_self.contextB != contextB) {\\n            _self.contextB = contextB;\\n        }\\n    }\\n\\n    /**\\n     * Retrieves the current ring buffer context.\\n     * @param _self Buffer to access.\\n     * @return Current ring buffer context.\\n     */\\n    function getContext(\\n        RingBuffer storage _self\\n    )\\n        internal\\n        view\\n        returns (\\n            RingBufferContext memory\\n        )\\n    {\\n        bytes32 contextA = _self.contextA;\\n        bytes32 contextB = _self.contextB;\\n\\n        uint40 globalIndex;\\n        bytes27 extraData;\\n        assembly {\\n            globalIndex := and(contextA, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\\n            extraData   := and(contextA, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000)\\n        }\\n\\n        uint64 currBufferIndex;\\n        uint40 prevResetIndex;\\n        uint40 currResetIndex;\\n        assembly {\\n            currBufferIndex :=          and(contextB, 0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF)\\n            prevResetIndex  := shr(64,  and(contextB, 0x00000000000000000000000000000000000000FFFFFFFFFF0000000000000000))\\n            currResetIndex  := shr(104, and(contextB, 0x0000000000000000000000000000FFFFFFFFFF00000000000000000000000000))\\n        }\\n\\n        return RingBufferContext({\\n            globalIndex: globalIndex,\\n            extraData: extraData,\\n            currBufferIndex: currBufferIndex,\\n            prevResetIndex: prevResetIndex,\\n            currResetIndex: currResetIndex\\n        });\\n    }\\n\\n    /**\\n     * Retrieves the a buffer from the ring buffer by index.\\n     * @param _self Buffer to access.\\n     * @param _which Index of the sub buffer to access.\\n     * @return Sub buffer for the index.\\n     */\\n    function getBuffer(\\n        RingBuffer storage _self,\\n        uint256 _which\\n    )\\n        internal\\n        view\\n        returns (\\n            Buffer storage\\n        )\\n    {\\n        return _which % 2 == 0 ? _self.bufferA : _self.bufferB;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// +build ovm\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\ncontract Lib_AddressResolver {\\n\\n    /*******************************************\\n     * Contract Variables: Contract References *\\n     *******************************************/\\n\\n    Lib_AddressManager internal libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    ) public {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address _contract\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/iOVM/chain/iOVM_ChainStorageContainer.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n/**\\n * @title iOVM_ChainStorageContainer\\n */\\ninterface iOVM_ChainStorageContainer {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata()\\n        external\\n        view\\n        returns (\\n            bytes27\\n        );\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length()\\n        external\\n        view\\n        returns (\\n            uint256\\n        );\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(\\n        bytes32 _object\\n    )\\n        external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Pushes two objects into the container at the same time. A useful optimization.\\n     * @param _objectA First 32 byte value to insert into the container.\\n     * @param _objectB Second 32 byte value to insert into the container.\\n     */\\n    function push2(\\n        bytes32 _objectA,\\n        bytes32 _objectB\\n    )\\n        external;\\n\\n    /**\\n     * Pushes two objects into the container at the same time. Also allows setting the global\\n     * metadata field.\\n     * @param _objectA First 32 byte value to insert into the container.\\n     * @param _objectB Second 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push2(\\n        bytes32 _objectA,\\n        bytes32 _objectB,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32\\n        );\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index\\n    )\\n        external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Marks an index as overwritable, meaing the underlying buffer can start to write values over\\n     * any objects before and including the given index.\\n     */\\n    function setNextOverwritableIndex(\\n        uint256 _index\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// +build ovm\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Contract Imports */\\nimport { Ownable } from \\\"./Lib_Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string _name,\\n        address _newAddress\\n    );\\n\\n    /*******************************************\\n     * Contract Variables: Internal Accounting *\\n     *******************************************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        public\\n        onlyOwner\\n    {\\n        emit AddressSet(_name, _address);\\n        addresses[_getNameHash(_name)] = _address;\\n    }\\n\\n    function getAddress(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/optimistic-ethereum/libraries/resolver/Lib_Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// +build ovm\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Ownable\\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\nabstract contract Ownable {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    address public owner;\\n\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor() internal {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyOwner() {\\n        require(\\n            owner == msg.sender,\\n            \\\"Ownable: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function renounceOwnership()\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    function transferOwnership(address _newOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        require(\\n            _newOwner != address(0),\\n            \\\"Ownable: new owner cannot be the zero address\\\"\\n        );\\n\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_owner\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"deleteElementsAfterInclusive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"deleteElementsAfterInclusive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalMetadata\",\"outputs\":[{\"internalType\":\"bytes27\",\"name\":\"\",\"type\":\"bytes27\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"}],\"name\":\"push\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_objectA\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_objectB\",\"type\":\"bytes32\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"push2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_objectA\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_objectB\",\"type\":\"bytes32\"}],\"name\":\"push2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"setGlobalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"setNextOverwritableIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OVM_ChainStorageContainer","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001de8cfd4c1a486200286073ae91de6e8099519f10000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001d4f564d5f43616e6f6e6963616c5472616e73616374696f6e436861696e000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}