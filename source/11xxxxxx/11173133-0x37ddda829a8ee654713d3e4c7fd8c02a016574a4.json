{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/spec_interfaces/IMigratableFeesWallet.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title An interface for Fee wallets that support bucket migration.\r\ninterface IMigratableFeesWallet {\r\n\r\n    /// Accepts a bucket fees from a old fees wallet as part of a migration\r\n    /// @dev Called by the old FeesWallet contract.\r\n    /// @dev Part of the IMigratableFeesWallet interface.\r\n    /// @dev assumes the caller approved the transfer of the amount prior to calling\r\n    /// @param bucketStartTime is the start time of the bucket to migration, must be a bucket's valid start time\r\n    /// @param amount is the amount to migrate (transfer) to the bucket\r\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/spec_interfaces/IFeesWallet.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/// @title Fees Wallet contract interface, manages the fee buckets\r\ninterface IFeesWallet {\r\n\r\n    event FeesWithdrawnFromBucket(uint256 bucketId, uint256 withdrawn, uint256 total);\r\n    event FeesAddedToBucket(uint256 bucketId, uint256 added, uint256 total);\r\n\r\n    /*\r\n     *   External methods\r\n     */\r\n\r\n    /// Top-ups the fee pool with the given amount at the given rate\r\n    /// @dev Called by: subscriptions contract. (not enforced)\r\n    /// @dev fills the rewards in 30 days buckets based on the monthlyRate\r\n    /// @param amount is the amount to fill\r\n    /// @param monthlyRate is the monthly rate\r\n    /// @param fromTimestamp is the to start fill the buckets, determines the first bucket to fill and the amount filled in the first bucket.\r\n    function fillFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external;\r\n\r\n    /// Collect fees from the buckets since the last call and transfers the amount back.\r\n    /// @dev Called by: only FeesAndBootstrapRewards contract\r\n    /// @dev The amount to collect may be queried before collect by calling getOutstandingFees\r\n    /// @return collectedFees the amount of fees collected and transferred\r\n    function collectFees() external returns (uint256 collectedFees) /* onlyRewardsContract */;\r\n\r\n    /// Returns the amount of fees that are currently available for withdrawal\r\n    /// @param currentTime is the time to check the pending fees for\r\n    /// @return outstandingFees is the amount of pending fees to collect at time currentTime\r\n    function getOutstandingFees(uint256 currentTime) external view returns (uint256 outstandingFees);\r\n\r\n    /*\r\n     * General governance\r\n     */\r\n\r\n    event EmergencyWithdrawal(address addr, address token);\r\n\r\n    /// Migrates the fees of bucket starting at startTimestamp.\r\n\t/// @dev governance function called only by the migration manager\r\n    /// @dev Calls acceptBucketMigration in the destination contract.\r\n    /// @param destination is the address of the new FeesWallet contract\r\n    /// @param bucketStartTime is the start time of the bucket to migration, must be a bucket's valid start time\r\n    function migrateBucket(IMigratableFeesWallet destination, uint256 bucketStartTime) external /* onlyMigrationManager */;\r\n\r\n    /// Accepts a bucket fees from a old fees wallet as part of a migration\r\n    /// @dev Called by the old FeesWallet contract.\r\n    /// @dev Part of the IMigratableFeesWallet interface.\r\n    /// @dev assumes the caller approved the amount prior to calling\r\n    /// @param bucketStartTime is the start time of the bucket to migration, must be a bucket's valid start time\r\n    /// @param amount is the amount to migrate (transfer) to the bucket\r\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\r\n\r\n    /// Emergency withdraw the contract funds\r\n\t/// @dev governance function called only by the migration manager\r\n    /// @dev used in emergencies only, where migrateBucket is not a suitable solution\r\n    /// @param token is the erc20 address of the token to withdraw\r\n    function emergencyWithdraw(address token) external /* onlyMigrationManager */;\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title Contract registry contract interface\r\n/// The contract registry holds Orbs PoS contracts and managers lists\r\n/// @dev The contract registry updates the managed contracts on changes in the contract list\r\n/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \r\n/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \r\n/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \r\ninterface IContractRegistry {\r\n\r\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\r\n\tevent ManagerChanged(string role, address newManager);\r\n\tevent ContractRegistryUpdated(address newContractRegistry);\r\n\r\n\t/*\r\n\t* External functions\r\n\t*/\r\n\r\n\t/// Updates the contracts address and emits a corresponding event\r\n\t/// @dev governance function called only by the migrationManager or registryAdmin\r\n\t/// @param contractName is the contract name, used to identify it\r\n\t/// @param addr is the contract updated address\r\n\t/// @param managedContract indicates whether the contract is managed by the registry and notified on changes\r\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdminOrMigrationManager */;\r\n\r\n\t/// Returns the current address of the given contracts\r\n\t/// @param contractName is the contract name, used to identify it\r\n\t/// @return addr is the contract updated address\r\n\tfunction getContract(string calldata contractName) external view returns (address);\r\n\r\n\t/// Returns the list of contract addresses managed by the registry\r\n\t/// @dev Managed contracts are updated on changes in the registry contracts addresses \r\n\t/// @return addrs is the list of managed contracts\r\n\tfunction getManagedContracts() external view returns (address[] memory);\r\n\r\n\t/// Updates a manager address and emits a corresponding event\r\n\t/// @dev governance function called only by the registryAdmin\r\n\t/// @dev the managers list is a flexible list of role to the manager's address\r\n\t/// @param role is the managers' role name, for example \"functionalManager\"\r\n\t/// @param manager is the manager updated address\r\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\r\n\r\n\t/// Returns the current address of the given manager\r\n\t/// @param role is the manager name, used to identify it\r\n\t/// @return addr is the manager updated address\r\n\tfunction getManager(string calldata role) external view returns (address);\r\n\r\n\t/// Locks all the managed contracts \r\n\t/// @dev governance function called only by the migrationManager or registryAdmin\r\n\t/// @dev When set all onlyWhenActive functions will revert\r\n\tfunction lockContracts() external /* onlyAdminOrMigrationManager */;\r\n\r\n\t/// Unlocks all the managed contracts \r\n\t/// @dev governance function called only by the migrationManager or registryAdmin\r\n\tfunction unlockContracts() external /* onlyAdminOrMigrationManager */;\r\n\r\n\t/// Sets a new contract registry to migrate to\r\n\t/// @dev governance function called only by the registryAdmin\r\n\t/// @dev updates the registry address record in all the managed contracts\r\n\t/// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\r\n\t/// @param newRegistry is the new registry contract \r\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\r\n\r\n\t/// Returns the previous contract registry address \r\n\t/// @dev used when the setting the contract as a new registry to assure a valid registry\r\n\t/// @return previousContractRegistry is the previous contract registry\r\n\tfunction getPreviousContractRegistry() external view returns (address);\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/WithClaimableRegistryManagement.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract WithClaimableRegistryManagement is Context {\r\n    address private _registryAdmin;\r\n    address private _pendingRegistryAdmin;\r\n\r\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _registryAdmin = msgSender;\r\n        emit RegistryManagementTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current registryAdmin.\r\n     */\r\n    function registryAdmin() public view returns (address) {\r\n        return _registryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the registryAdmin.\r\n     */\r\n    modifier onlyRegistryAdmin() {\r\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current registryAdmin.\r\n     */\r\n    function isRegistryAdmin() public view returns (bool) {\r\n        return _msgSender() == _registryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\r\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\r\n     *\r\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\r\n     * thereby removing any functionality that is only available to the registryAdmin.\r\n     */\r\n    function renounceRegistryManagement() public onlyRegistryAdmin {\r\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\r\n        _registryAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\r\n     */\r\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\r\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\r\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\r\n        _registryAdmin = newRegistryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingManager.\r\n     */\r\n    modifier onlyPendingRegistryAdmin() {\r\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev Allows the current registryAdmin to set the pendingManager address.\r\n     * @param newRegistryAdmin The address to transfer registryManagement to.\r\n     */\r\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\r\n        _pendingRegistryAdmin = newRegistryAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\r\n     */\r\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\r\n        _transferRegistryManagement(_pendingRegistryAdmin);\r\n        _pendingRegistryAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current pendingRegistryAdmin\r\n    */\r\n    function pendingRegistryAdmin() public view returns (address) {\r\n       return _pendingRegistryAdmin;  \r\n    }\r\n}\r\n\r\n// File: contracts/Initializable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Initializable {\r\n\r\n    address private _initializationAdmin;\r\n\r\n    event InitializationComplete();\r\n\r\n    constructor() public{\r\n        _initializationAdmin = msg.sender;\r\n    }\r\n\r\n    modifier onlyInitializationAdmin() {\r\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * External functions\r\n    */\r\n\r\n    function initializationAdmin() public view returns (address) {\r\n        return _initializationAdmin;\r\n    }\r\n\r\n    function initializationComplete() external onlyInitializationAdmin {\r\n        _initializationAdmin = address(0);\r\n        emit InitializationComplete();\r\n    }\r\n\r\n    function isInitializationComplete() public view returns (bool) {\r\n        return _initializationAdmin == address(0);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ContractRegistryAccessor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\r\n\r\n    IContractRegistry private contractRegistry;\r\n\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\r\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\r\n        setContractRegistry(_contractRegistry);\r\n        _transferRegistryManagement(_registryAdmin);\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationManager {\r\n        require(isMigrationManager(), \"sender is not the migration manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyFunctionalManager {\r\n        require(isFunctionalManager(), \"sender is not the functional manager\");\r\n\r\n        _;\r\n    }\r\n\r\n    function isAdmin() internal view returns (bool) {\r\n        return msg.sender == address(contractRegistry) || msg.sender == registryAdmin() || msg.sender == initializationAdmin();\r\n    }\r\n\r\n    function isManager(string memory role) internal view returns (bool) {\r\n        IContractRegistry _contractRegistry = contractRegistry;\r\n        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;\r\n    }\r\n\r\n    function isMigrationManager() internal view returns (bool) {\r\n        return isManager('migrationManager');\r\n    }\r\n\r\n    function isFunctionalManager() internal view returns (bool) {\r\n        return isManager('functionalManager');\r\n    }\r\n\r\n    function getProtocolContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"protocol\");\r\n    }\r\n\r\n    function getStakingRewardsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingRewards\");\r\n    }\r\n\r\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\r\n    }\r\n\r\n    function getCommitteeContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"committee\");\r\n    }\r\n\r\n    function getElectionsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"elections\");\r\n    }\r\n\r\n    function getDelegationsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"delegations\");\r\n    }\r\n\r\n    function getGuardiansRegistrationContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"guardiansRegistration\");\r\n    }\r\n\r\n    function getCertificationContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"certification\");\r\n    }\r\n\r\n    function getStakingContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"staking\");\r\n    }\r\n\r\n    function getSubscriptionsContract() internal view returns (address) {\r\n        return contractRegistry.getContract(\"subscriptions\");\r\n    }\r\n\r\n    function getStakingRewardsWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\r\n    }\r\n\r\n    function getBootstrapRewardsWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\r\n    }\r\n\r\n    function getGeneralFeesWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"generalFeesWallet\");\r\n    }\r\n\r\n    function getCertifiedFeesWallet() internal view returns (address) {\r\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\r\n    }\r\n\r\n    function getStakingContractHandler() internal view returns (address) {\r\n        return contractRegistry.getContract(\"stakingContractHandler\");\r\n    }\r\n\r\n    /*\r\n    * Governance functions\r\n    */\r\n\r\n    event ContractRegistryAddressUpdated(address addr);\r\n\r\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\r\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\r\n        contractRegistry = newContractRegistry;\r\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\r\n    }\r\n\r\n    function getContractRegistry() public view returns (IContractRegistry) {\r\n        return contractRegistry;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/spec_interfaces/ILockable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/// @title lockable contract interface, allows to lock a contract\r\ninterface ILockable {\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    /// Locks the contract to external non-governance function calls\r\n\t/// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon locking all managed contracts\r\n    /// @dev getters and migration functions remain active also for locked contracts\r\n    /// @dev checked by the onlyWhenActive modifier\r\n    function lock() external /* onlyMigrationManager */;\r\n\r\n    /// Unlocks the contract \r\n\t/// @dev governance function called only by the migration manager or an admin\r\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\r\n    function unlock() external /* onlyMigrationManager */;\r\n\r\n    /// Returns the contract locking status\r\n    /// @return isLocked is a bool indicating the contract is locked \r\n    function isLocked() view external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/Lockable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\ncontract Lockable is ILockable, ContractRegistryAccessor {\r\n\r\n    bool public locked;\r\n\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\r\n\r\n    function lock() external override onlyMigrationManager {\r\n        locked = true;\r\n        emit Locked();\r\n    }\r\n\r\n    function unlock() external override onlyMigrationManager {\r\n        locked = false;\r\n        emit Unlocked();\r\n    }\r\n\r\n    function isLocked() external override view returns (bool) {\r\n        return locked;\r\n    }\r\n\r\n    modifier onlyWhenActive() {\r\n        require(!locked, \"contract is locked for this operation\");\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/ManagedContract.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ncontract ManagedContract is Lockable {\r\n\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\r\n\r\n    function refreshContracts() virtual external {}\r\n\r\n}\r\n\r\n// File: contracts/FeesWallet.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Fees Wallet contract interface, manages the fee buckets\r\ncontract FeesWallet is IFeesWallet, ManagedContract {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant BUCKET_TIME_PERIOD = 30 days;\r\n    uint constant MAX_FEE_BUCKET_ITERATIONS = 24;\r\n\r\n    IERC20 public token;\r\n    mapping(uint256 => uint256) public buckets;\r\n    uint256 public lastCollectedAt;\r\n\r\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin, IERC20 _token) ManagedContract(_contractRegistry, _registryAdmin) public {\r\n        token = _token;\r\n        lastCollectedAt = block.timestamp;\r\n    }\r\n\r\n    modifier onlyRewardsContract() {\r\n        require(msg.sender == rewardsContract, \"caller is not the rewards contract\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *   External methods\r\n     */\r\n\r\n    /// @dev collect fees from the buckets since the last call and transfers the amount back.\r\n    /// Called by: only Rewards contract.\r\n    function collectFees() external override onlyRewardsContract returns (uint256 collectedFees)  {\r\n        (uint256 _collectedFees, uint[] memory bucketsWithdrawn, uint[] memory amountsWithdrawn, uint[] memory newTotals) = _getOutstandingFees(block.timestamp);\r\n\r\n        for (uint i = 0; i < bucketsWithdrawn.length; i++) {\r\n            buckets[bucketsWithdrawn[i]] = newTotals[i];\r\n            emit FeesWithdrawnFromBucket(bucketsWithdrawn[i], amountsWithdrawn[i], newTotals[i]);\r\n        }\r\n\r\n        lastCollectedAt = block.timestamp;\r\n\r\n        require(token.transfer(msg.sender, _collectedFees), \"FeesWallet::failed to transfer collected fees to rewards\"); // TODO in that case, transfer the remaining balance?\r\n        return _collectedFees;\r\n    }\r\n\r\n    function getOutstandingFees(uint256 currentTime) external override view returns (uint256 outstandingFees)  {\r\n        require(currentTime >= block.timestamp, \"currentTime must not be in the past\");\r\n        (outstandingFees,,,) = _getOutstandingFees(currentTime);\r\n    }\r\n\r\n    /// @dev Called by: subscriptions contract.\r\n    /// Top-ups the fee pool with the given amount at the given rate (typically called by the subscriptions contract).\r\n    function fillFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external override onlyWhenActive {\r\n        uint256 bucket = _bucketTime(fromTimestamp);\r\n        require(bucket >= _bucketTime(block.timestamp), \"FeeWallet::cannot fill bucket from the past\");\r\n\r\n        uint256 _amount = amount;\r\n\r\n        // add the partial amount to the first bucket\r\n        uint256 bucketAmount = Math.min(amount, monthlyRate.mul(BUCKET_TIME_PERIOD.sub(fromTimestamp % BUCKET_TIME_PERIOD)).div(BUCKET_TIME_PERIOD));\r\n        fillFeeBucket(bucket, bucketAmount);\r\n        _amount = _amount.sub(bucketAmount);\r\n\r\n        // following buckets are added with the monthly rate\r\n        while (_amount > 0) {\r\n            bucket = bucket.add(BUCKET_TIME_PERIOD);\r\n            bucketAmount = Math.min(monthlyRate, _amount);\r\n            fillFeeBucket(bucket, bucketAmount);\r\n\r\n            _amount = _amount.sub(bucketAmount);\r\n        }\r\n\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"failed to transfer fees into fee wallet\");\r\n    }\r\n\r\n    /*\r\n     * Governance functions\r\n     */\r\n\r\n    /// @dev migrates the fees of bucket starting at startTimestamp.\r\n    /// bucketStartTime must be a bucket's start time.\r\n    /// Calls acceptBucketMigration in the destination contract.\r\n    function migrateBucket(IMigratableFeesWallet destination, uint256 bucketStartTime) external override onlyMigrationManager {\r\n        require(_bucketTime(bucketStartTime) == bucketStartTime,  \"bucketStartTime must be the  start time of a bucket\");\r\n\r\n        uint bucketAmount = buckets[bucketStartTime];\r\n        if (bucketAmount == 0) return;\r\n\r\n        buckets[bucketStartTime] = 0;\r\n        emit FeesWithdrawnFromBucket(bucketStartTime, bucketAmount, 0);\r\n\r\n        token.approve(address(destination), bucketAmount);\r\n        destination.acceptBucketMigration(bucketStartTime, bucketAmount);\r\n    }\r\n\r\n    /// @dev Called by the old FeesWallet contract.\r\n    /// Part of the IMigratableFeesWallet interface.\r\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external override {\r\n        require(_bucketTime(bucketStartTime) == bucketStartTime,  \"bucketStartTime must be the  start time of a bucket\");\r\n        fillFeeBucket(bucketStartTime, amount);\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"failed to transfer fees into fee wallet on bucket migration\");\r\n    }\r\n\r\n    /// @dev an emergency withdrawal enables withdrawal of all funds to an escrow account. To be use in emergencies only.\r\n    function emergencyWithdraw(address erc20) external override onlyMigrationManager {\r\n        IERC20 _token = IERC20(erc20);\r\n        emit EmergencyWithdrawal(msg.sender, address(_token));\r\n        require(_token.transfer(msg.sender, _token.balanceOf(address(this))), \"FeesWallet::emergencyWithdraw - transfer failed\");\r\n    }\r\n\r\n    /*\r\n    * Private methods\r\n    */\r\n\r\n    function fillFeeBucket(uint256 bucketId, uint256 amount) private {\r\n        uint256 bucketTotal = buckets[bucketId].add(amount);\r\n        buckets[bucketId] = bucketTotal;\r\n        emit FeesAddedToBucket(bucketId, amount, bucketTotal);\r\n    }\r\n\r\n    function _getOutstandingFees(uint256 currentTime) private view returns (uint256 outstandingFees, uint[] memory bucketsWithdrawn, uint[] memory withdrawnAmounts, uint[] memory newTotals)  {\r\n        // TODO we often do integer division for rate related calculation, which floors the result. Do we need to address this?\r\n        // TODO for an empty committee or a committee with 0 total stake the divided amounts will be locked in the contract FOREVER\r\n\r\n        // Fee pool\r\n        uint _lastCollectedAt = lastCollectedAt;\r\n        uint nUpdatedBuckets = _bucketTime(currentTime).sub(_bucketTime(_lastCollectedAt)).div(BUCKET_TIME_PERIOD).add(1);\r\n        bucketsWithdrawn = new uint[](nUpdatedBuckets);\r\n        withdrawnAmounts = new uint[](nUpdatedBuckets);\r\n        newTotals = new uint[](nUpdatedBuckets);\r\n        uint bucketsPayed = 0;\r\n        while (bucketsPayed < MAX_FEE_BUCKET_ITERATIONS && _lastCollectedAt < currentTime) {\r\n            uint256 bucketStart = _bucketTime(_lastCollectedAt);\r\n            uint256 bucketEnd = bucketStart.add(BUCKET_TIME_PERIOD);\r\n            uint256 payUntil = Math.min(bucketEnd, currentTime);\r\n            uint256 bucketDuration = payUntil.sub(_lastCollectedAt);\r\n            uint256 remainingBucketTime = bucketEnd.sub(_lastCollectedAt);\r\n\r\n            uint256 bucketTotal = buckets[bucketStart];\r\n            uint256 amount = bucketTotal.mul(bucketDuration).div(remainingBucketTime);\r\n            outstandingFees = outstandingFees.add(amount);\r\n            bucketTotal = bucketTotal.sub(amount);\r\n\r\n            bucketsWithdrawn[bucketsPayed] = bucketStart;\r\n            withdrawnAmounts[bucketsPayed] = amount;\r\n            newTotals[bucketsPayed] = bucketTotal;\r\n\r\n            _lastCollectedAt = payUntil;\r\n            bucketsPayed++;\r\n        }\r\n    }\r\n\r\n    function _bucketTime(uint256 time) private pure returns (uint256) {\r\n        return time.sub(time % BUCKET_TIME_PERIOD);\r\n    }\r\n\r\n    /*\r\n     * Contracts topology / registry interface\r\n     */\r\n\r\n    address rewardsContract;\r\n    function refreshContracts() external override {\r\n        rewardsContract = getFeesAndBootstrapRewardsContract();\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EmergencyWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bucketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"added\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"FeesAddedToBucket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bucketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"FeesWithdrawnFromBucket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitializationComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRegistryAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"RegistryManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlocked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bucketStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acceptBucketMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collectedFees\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthlyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"}],\"name\":\"fillFeeBuckets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractRegistry\",\"outputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"getOutstandingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outstandingFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitializationComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRegistryAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCollectedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratableFeesWallet\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bucketStartTime\",\"type\":\"uint256\"}],\"name\":\"migrateBucket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRegistryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"newContractRegistry\",\"type\":\"address\"}],\"name\":\"setContractRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"transferRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FeesWallet","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000005454223e3078db87e55a15be541cc925f3702eb0000000000000000000000000628e8c4d1611ed5b748f59f5ce694809af2f91d4000000000000000000000000ff56cc6b1e6ded347aa0b7676c85ab0b3d08b0fa","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://449903eb10df86e7466631e40167c5cddcd6e40ef2c860a5513df62ed943fe95"}]}