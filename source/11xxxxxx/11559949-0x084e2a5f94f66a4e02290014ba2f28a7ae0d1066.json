{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"},\"DistributeRewards.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./Withdrawable.sol\\\";\\n\\n\\ninterface GasToken {\\n    function freeFromUpTo(address from, uint256 value) external returns (uint256);\\n}\\n\\ncontract DistributeRewards is Withdrawable {\\n    using SafeERC20 for IERC20;\\n\\n    modifier discountGasToken(GasToken gasToken) {\\n        uint256 gasStart = gasleft();\\n        _;\\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\\n        gasToken.freeFromUpTo(address(this), (gasSpent + 14154) / 41947);\\n    }\\n\\n    constructor(address _admin) public Withdrawable(_admin) {}\\n\\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n    );\\n\\n    receive() external payable {}\\n\\n    function distributeSingle(\\n        address payable winner,\\n        IERC20 token,\\n        uint256 amount,\\n        GasToken gasToken\\n    ) public onlyOperator {\\n        require(winner != address(0), \\\"winner cannot be zero address\\\");\\n        require(address(token) != address(0), \\\"token cannot be zero address\\\");\\n        require(amount \\u003e 0, \\\"amount is 0\\\");\\n\\n        if (address(gasToken) == address(0)) {\\n            _distributeWithoutGasToken(winner, token, amount);\\n        } else {\\n            _distributeWithGasToken(winner, token, amount, gasToken);\\n        }\\n    }\\n\\n    function distributeMany(\\n        address[] memory winners,\\n        IERC20 token,\\n        uint256 amount,\\n        GasToken gasToken\\n    ) public onlyOperator {\\n        for (uint256 i = 0; i \\u003c winners.length; i++) {\\n            distributeSingle(payable(winners[i]), token, amount, gasToken);\\n        }\\n    }\\n\\n    function _distributeWithGasToken(\\n        address payable winner,\\n        IERC20 token,\\n        uint256 amount,\\n        GasToken gasToken\\n    ) private discountGasToken(gasToken) {\\n        _distribute(winner, token, amount);\\n    }\\n\\n    function _distributeWithoutGasToken(\\n        address payable winner,\\n        IERC20 token,\\n        uint256 amount\\n    ) private {\\n        _distribute(winner, token, amount);\\n    }\\n\\n    function _distribute(\\n        address payable winner,\\n        IERC20 token,\\n        uint256 amount\\n    ) private {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            require(address(this).balance \\u003e= amount, \\\"eth amount required \\u003e balance\\\");\\n            (bool success, ) = winner.call{value: amount}(\\\"\\\");\\n            require(success, \\\"send to winner failed\\\");\\n        } else {\\n            require(token.balanceOf(address(this)) \\u003e= amount, \\\"token amount required \\u003e balance\\\");\\n            token.safeTransfer(winner, amount);\\n        }\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\n\\ninterface IERC20 {\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function decimals() external view returns (uint8 digits);\\n\\n    function totalSupply() external view returns (uint256 supply);\\n}\\n\\n\\n// to support backward compatible contract name -- so function signature remains same\\nabstract contract ERC20 is IERC20 {\\n\\n}\\n\"},\"PermissionGroups.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\n\\ncontract PermissionGroups {\\n    address public admin;\\n    address public pendingAdmin;\\n    mapping(address =\\u003e bool) internal operators;\\n    mapping(address =\\u003e bool) internal alerters;\\n    address[] internal operatorsGroup;\\n    address[] internal alertersGroup;\\n    uint256 internal constant MAX_GROUP_SIZE = 50;\\n\\n    constructor(address _admin) public {\\n        require(_admin != address(0), \\\"Admin 0\\\");\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Only admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender], \\\"Only operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyAlerter() {\\n        require(alerters[msg.sender], \\\"Only alerter\\\");\\n        _;\\n    }\\n\\n    function getOperators() external view returns (address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function getAlerters() external view returns (address[] memory) {\\n        return alertersGroup;\\n    }\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"New admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"Admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    event AdminClaimed(address newAdmin, address previousAdmin);\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender, \\\"not pending\\\");\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    event AlerterAdded(address newAlerter, bool isAdd);\\n\\n    function addAlerter(address newAlerter) public onlyAdmin {\\n        require(!alerters[newAlerter], \\\"Alerter exists\\\"); // prevent duplicates.\\n        require(alertersGroup.length \\u003c MAX_GROUP_SIZE, \\\"Max alerters\\\");\\n\\n        emit AlerterAdded(newAlerter, true);\\n        alerters[newAlerter] = true;\\n        alertersGroup.push(newAlerter);\\n    }\\n\\n    function removeAlerter(address alerter) public onlyAdmin {\\n        require(alerters[alerter], \\\"Not alerter\\\");\\n        alerters[alerter] = false;\\n\\n        for (uint256 i = 0; i \\u003c alertersGroup.length; ++i) {\\n            if (alertersGroup[i] == alerter) {\\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\\n                alertersGroup.pop();\\n                emit AlerterAdded(alerter, false);\\n                break;\\n            }\\n        }\\n    }\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator], \\\"Operator exists\\\"); // prevent duplicates.\\n        require(operatorsGroup.length \\u003c MAX_GROUP_SIZE, \\\"Max operators\\\");\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator(address operator) public onlyAdmin {\\n        require(operators[operator], \\\"Not operator\\\");\\n        operators[operator] = false;\\n\\n        for (uint256 i = 0; i \\u003c operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.pop();\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            \\\"SafeERC20: decreased allowance below zero\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\\n     * relaxing the requirement on the return value: the return value is optional\\n     * (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s\\n        // return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n}\\n\"},\"Withdrawable.sol\":{\"content\":\"pragma solidity 0.6.6;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./PermissionGroups.sol\\\";\\n\\ncontract Withdrawable is PermissionGroups {\\n    constructor(address _admin) public PermissionGroups(_admin) {}\\n\\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw all IERC20 compatible tokens\\n     * @param token IERC20 The address of the token contract\\n     */\\n    function withdrawToken(\\n        IERC20 token,\\n        uint256 amount,\\n        address sendTo\\n    ) external onlyAdmin {\\n        token.transfer(sendTo, amount);\\n        emit TokenWithdraw(token, amount, sendTo);\\n    }\\n\\n    event EtherWithdraw(uint256 amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw Ethers\\n     */\\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyAdmin {\\n        (bool success, ) = sendTo.call{value: amount}(\\\"\\\");\\n        require(success);\\n        emit EtherWithdraw(amount, sendTo);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract GasToken\",\"name\":\"gasToken\",\"type\":\"address\"}],\"name\":\"distributeMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract GasToken\",\"name\":\"gasToken\",\"type\":\"address\"}],\"name\":\"distributeSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DistributeRewards","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"0000000000000000000000002f02532c5608b5ebf536d852499be3146c1e3c3a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2fb8071081a2f35052e7026aa061883c822d0a051dbdfb457ff10ee9b45dd504"}]}