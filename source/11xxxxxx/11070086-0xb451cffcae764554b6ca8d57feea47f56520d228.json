{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 { // brief interface for erc20 token tx\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWETH { // brief interface for canonical ether token wrapper \r\n    function deposit() external payable;\r\n    \r\n    function transfer(address dst, uint wad) external returns (bool);\r\n}\r\n\r\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n   function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        (bool success, bytes memory returnData) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returnData.length > 0) { // return data is optional\r\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // arithmetic wrapper for unit under/overflow check\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard { // call wrapper for reentrancy check\r\n    bool private _notEntered;\r\n\r\n    function _initReentrancyGuard () internal {\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"reentrant\");\r\n\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\ncontract Mystic is ReentrancyGuard { \r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    address public depositToken; // deposit token contract reference - default = wETH\r\n    address public stakeToken; // stake token contract reference for guild voting shares \r\n    address public constant wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // canonical ether token wrapper contract reference \r\n    \r\n    uint256 public proposalDeposit; // default = 10 deposit token \r\n    uint256 public processingReward; // default = 0.1 - amount of deposit token to give to whoever processes a proposal\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public summoningTime; // needed to determine the current period\r\n    bool private initialized; // internally tracks token deployment under eip-1167 proxy pattern\r\n    \r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_GUILD_BOUND = 10**36; // maximum bound for guild accounting\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\r\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\r\n\r\n    // GUILD TOKEN DETAILS\r\n    uint8 public constant decimals = 18;\r\n    string public constant name = \"MYSTIC DAO\";\r\n    string public constant symbol = \"MXDAO\";\r\n\r\n    // **************\r\n    // EVENT TRACKING\r\n    // **************\r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, uint8[7] flags, bytes data, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessActionProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount); // guild token (loot) allowance tracking\r\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount); // guild token mint, burn & (loot) transfer tracking\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n    event ClaimShares(address indexed memberAddress, uint256 amount);\r\n    event ConvertSharesToLoot(address indexed memberAddress, uint256 amount);\r\n    \r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xdeaf);\r\n    address public constant TOTAL = address(0xdeed);\r\n    \r\n    uint256 public proposalCount; // total proposals submitted\r\n    uint256 public totalShares; // total shares across all members\r\n    uint256 public totalLoot; // total loot across all members\r\n    uint256 public totalGuildBankTokens; // total tokens with non-zero balance in guild bank\r\n\r\n    mapping(uint256 => bytes) public actions; // proposalId => action data\r\n    mapping(address => uint256) public balanceOf; // guild token balances\r\n    mapping(address => mapping(address => uint256)) public allowance; // guild token (loot) allowances\r\n    mapping(address => mapping(address => uint256)) private userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n    \r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals & voting - defaults to member address unless updated\r\n        uint8 exists; // always true (1) once a member has been created\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragekick) - transferable by guild token\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on & sponsoring proposals\r\n    }\r\n    \r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as target for alt. proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        address tributeToken; // tribute token contract reference\r\n        address paymentToken; // payment token contract reference\r\n        uint8[7] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        bytes32 details; // proposal details to add context for members \r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n    \r\n    address[] public approvedTokens;\r\n    mapping(address => bool) public tokenWhitelist;\r\n    \r\n    uint256[] public proposalQueue;\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    mapping(address => bool) public proposedToWhitelist;\r\n    mapping(address => bool) public proposedToKick;\r\n    \r\n    mapping(address => Member) public members;\r\n    mapping(address => address) public memberAddressByDelegateKey;\r\n    \r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"!delegate\");\r\n        _;\r\n    }\r\n\r\n    function init(\r\n        address _depositToken,\r\n        address _stakeToken,\r\n        address[] calldata _summoner,\r\n        uint256[] calldata _summonerShares,\r\n        uint256 _summonerDeposit,\r\n        uint256 _proposalDeposit,\r\n        uint256 _processingReward,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _dilutionBound\r\n    ) external {\r\n        require(!initialized, \"initialized\");\r\n        require(_depositToken != _stakeToken, \"depositToken = stakeToken\");\r\n        require(_summoner.length == _summonerShares.length, \"summoner != summonerShares\");\r\n        require(_proposalDeposit >= _processingReward, \"_processingReward > _proposalDeposit\");\r\n        \r\n        for (uint256 i = 0; i < _summoner.length; i++) {\r\n            registerMember(_summoner[i], _summonerShares[i]);\r\n            mintGuildToken(_summoner[i], _summonerShares[i]);\r\n            totalShares = totalShares.add(_summonerShares[i]);\r\n        }\r\n        \r\n        require(totalShares <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        \r\n        tokenWhitelist[_depositToken] = true;\r\n        approvedTokens.push(_depositToken);\r\n        \r\n        if (_summonerDeposit > 0) {\r\n            totalGuildBankTokens += 1;\r\n            unsafeAddToBalance(GUILD, _depositToken, _summonerDeposit);\r\n        }\r\n        \r\n        depositToken = _depositToken;\r\n        stakeToken = _stakeToken;\r\n        proposalDeposit = _proposalDeposit;\r\n        processingReward = _processingReward;\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        dilutionBound = _dilutionBound;\r\n        summoningTime = now;\r\n        initialized = true;\r\n        _initReentrancyGuard();\r\n    }\r\n    \r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details\r\n    ) external nonReentrant payable returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        require(tokenWhitelist[tributeToken], \"tributeToken != whitelist\");\r\n        require(tokenWhitelist[paymentToken], \"paymentToken != whitelist\");\r\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant unreservable\");\r\n        require(members[applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n        \r\n        // collect tribute from proposer & store it in the Mystic until the proposal is processed - if ether, wrap into wETH\r\n        if (tributeToken == wETH && msg.value > 0) {\r\n            require(msg.value == tributeOffered, \"!ethBalance\");\r\n            IWETH(wETH).deposit();\r\n            (bool success, ) = wETH.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IWETH(wETH).transfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(tributeToken).safeTransferFrom(msg.sender, address(this), tributeOffered);\r\n        }\r\n        \r\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n\r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n\r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, \"\");\r\n        \r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n    \r\n    function submitActionProposal( // stages arbitrary function calls for member vote - based on Raid Guild 'Minion'\r\n        address actionTo,\r\n        address actionToken,\r\n        uint256 actionTokenAmount,\r\n        uint256 actionValue,\r\n        bytes32 details,\r\n        bytes calldata data\r\n    ) external returns (uint256 proposalId) {\r\n        \r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        flags[6] = 1; // guild action\r\n        \r\n        _submitProposal(actionTo, 0, 0, actionValue, address(0), actionTokenAmount, actionToken, details, flags, data);\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function submitWhitelistProposal(address tokenToWhitelist, bytes32 details) external returns (uint256 proposalId) {\r\n        require(tokenToWhitelist != address(0), \"!token\");\r\n        require(tokenToWhitelist != stakeToken, \"tokenToWhitelist = stakeToken\");\r\n        require(!tokenWhitelist[tokenToWhitelist], \"whitelisted\");\r\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n\r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        flags[4] = 1; // whitelist\r\n\r\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags, \"\");\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function submitGuildKickProposal(address memberToKick, bytes32 details) external returns (uint256 proposalId) {\r\n        Member memory member = members[memberToKick];\r\n\r\n        require(member.shares > 0 || member.loot > 0, \"!share||loot\");\r\n        require(members[memberToKick].jailed == 0, \"jailed\");\r\n\r\n        uint8[7] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action]\r\n        flags[5] = 1; // guild kick\r\n\r\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags, \"\");\r\n        \r\n        return proposalCount - 1;\r\n    }\r\n    \r\n    function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details,\r\n        uint8[7] memory flags,\r\n        bytes memory data\r\n    ) internal {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            tributeToken : tributeToken,\r\n            paymentToken : paymentToken,\r\n            flags : flags,\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            paymentRequested : paymentRequested,\r\n            tributeOffered : tributeOffered,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            maxTotalSharesAndLootAtYesVote : 0,\r\n            details : details\r\n        });\r\n        \r\n        if (proposal.flags[6] == 1) {\r\n            actions[proposalCount] = data;\r\n        }\r\n        \r\n        proposals[proposalCount] = proposal;\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, data, proposalCount, msg.sender, memberAddress);\r\n        \r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) external nonReentrant onlyDelegate {\r\n        // collect proposal deposit from sponsor & store it in the Mystic until the proposal is processed\r\n        IERC20(depositToken).safeTransferFrom(msg.sender, address(this), proposalDeposit);\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.proposer != address(0), \"!proposed\");\r\n        require(proposal.flags[0] == 0, \"sponsored\");\r\n        require(proposal.flags[3] == 0, \"cancelled\");\r\n        require(members[proposal.applicant].jailed == 0, \"applicant jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, \"guildbank maxed\");\r\n        }\r\n\r\n        // whitelist proposal\r\n        if (proposal.flags[4] == 1) {\r\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"whitelisted\");\r\n            require(!proposedToWhitelist[address(proposal.tributeToken)], \"whitelist proposed\");\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"whitelist maxed\");\r\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\r\n\r\n        // guild kick proposal\r\n        } else if (proposal.flags[5] == 1) {\r\n            require(!proposedToKick[proposal.applicant], \"kick proposed\");\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length - 1]].startingPeriod\r\n        ) + 1;\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        proposal.sponsor = memberAddress;\r\n\r\n        proposal.flags[0] = 1; // sponsored\r\n\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length - 1, startingPeriod);\r\n    }\r\n\r\n    // NOTE: In Mystic, proposalIndex != proposalId\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"!proposed\");\r\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(uintVote < 3, \"!<3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"pending\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"!Yes||No\");\r\n\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes += member.shares;\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalSupply() > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalSupply();\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes += member.shares;\r\n        }\r\n     \r\n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set until it's been sponsored but proposal is created on submission\r\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4] == 0 && proposal.flags[5] == 0 && proposal.flags[6] == 0, \"!standard\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        // Make the proposal fail if the new total number of shares & loot exceeds the limit\r\n        if (totalSupply().add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_GUILD_BOUND) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n\r\n            // if the applicant is already a member, add to their existing shares & loot\r\n            if (members[proposal.applicant].exists == 1) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\r\n\r\n            // if the applicant is a new member, create a new record for them\r\n            } else {\r\n                registerMember(proposal.applicant, proposal.sharesRequested);\r\n            }\r\n\r\n            // mint new guild token, shares & loot \r\n            mintGuildToken(proposal.applicant, proposal.sharesRequested.add(proposal.lootRequested));\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n            totalLoot = totalLoot.add(proposal.lootRequested);\r\n\r\n            // if the proposal tribute is the first token of its kind to make it into the guild bank, increment total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\r\n                totalGuildBankTokens += 1;\r\n            }\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n\r\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\r\n                totalGuildBankTokens -= 1;\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n    \r\n    function processActionProposal(uint256 proposalIndex) external nonReentrant returns (bool, bytes memory) {\r\n        _validateProposalForProcessing(proposalIndex);\r\n        \r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        bytes storage action = actions[proposalId];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        require(proposal.flags[6] == 1, \"!action\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n        \r\n        // Make the proposal fail if it is requesting more stake tokens than the available local balance\r\n        if (proposal.paymentToken == stakeToken && proposal.paymentRequested > IERC20(stakeToken).balanceOf(address(this))) {\r\n            didPass = false;\r\n        }\r\n        \r\n        // Make the proposal fail if it is requesting more tokens than the available guild bank balance\r\n        if (tokenWhitelist[proposal.paymentToken] && proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n        \r\n        // Make the proposal fail if it is requesting more ether than the available local balance\r\n        if (proposal.tributeOffered > address(this).balance) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n            (bool success, bytes memory returnData) = proposal.applicant.call{value: proposal.tributeOffered}(action);\r\n            if (tokenWhitelist[proposal.paymentToken]) {\r\n                unsafeSubtractFromBalance(GUILD, proposal.paymentToken, proposal.paymentRequested);\r\n                // if the action proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n                if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {totalGuildBankTokens -= 1;}\r\n            }\r\n            return (success, returnData);\r\n        }\r\n        \r\n        emit ProcessActionProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processWhitelistProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4] == 1, \"!whitelist\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n            tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            approvedTokens.push(proposal.tributeToken);\r\n        }\r\n\r\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[5] == 1, \"!kick\");\r\n\r\n        proposal.flags[1] = 1; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = 1; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed = proposalIndex;\r\n\r\n            // transfer shares to loot\r\n            member.loot = member.loot.add(member.shares);\r\n            totalShares = totalShares.sub(member.shares);\r\n            totalLoot = totalLoot.add(member.shares);\r\n            member.shares = 0; // revoke all shares\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n        \r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n        \r\n        if (proposal.yesVotes > proposal.noVotes) {\r\n            didPass = true;\r\n        }\r\n        \r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalSupply().mul(dilutionBound)) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed != 0) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\r\n        require(proposalIndex < proposalQueue.length, \"!proposal\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"!ready\");\r\n        require(proposal.flags[1] == 0, \"processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex - 1]].flags[1] == 1, \"prior !processed\");\r\n    }\r\n\r\n    function _returnDeposit(address sponsor) internal {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\r\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit - processingReward);\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) external nonReentrant {\r\n        require(members[msg.sender].exists == 1, \"!member\");\r\n        \r\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\r\n        uint256 initialTotalSharesAndLoot = totalSupply();\r\n\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(member.shares >= sharesToBurn, \"!shares\");\r\n        require(member.loot >= lootToBurn, \"!loot\");\r\n        require(canRagequit(member.highestIndexYesVote), \"!ragequit until highest index proposal member voted YES processes\");\r\n\r\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\r\n\r\n        // burn guild token, shares & loot\r\n        burnGuildToken(memberAddress, sharesAndLootToBurn);\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        member.loot = member.loot.sub(lootToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n        totalLoot = totalLoot.sub(lootToBurn);\r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\r\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n            }\r\n        }\r\n\r\n        emit Ragequit(memberAddress, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function ragekick(address memberToKick) external nonReentrant onlyDelegate {\r\n        Member storage member = members[memberToKick];\r\n\r\n        require(member.jailed != 0, \"!jailed\");\r\n        require(member.loot > 0, \"!loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"!ragequit until highest index proposal member voted YES processes\");\r\n\r\n        _ragequit(memberToKick, 0, member.loot);\r\n    }\r\n    \r\n    function withdrawBalance(address token, uint256 amount) external nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n\r\n    function withdrawBalances(address[] calldata tokens, uint256[] calldata amounts, bool max) external nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens != amounts\");\r\n\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    function _withdrawBalance(address token, uint256 amount) internal {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"!balance\");\r\n        \r\n        IERC20(token).safeTransfer(msg.sender, amount);\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        \r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    function collectTokens(address token) external nonReentrant onlyDelegate {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\r\n        // only collect if 1) there are tokens to collect & 2) token is whitelisted\r\n        require(amountToCollect > 0, \"!amount\");\r\n        require(tokenWhitelist[token], \"!whitelisted\");\r\n        \r\n        if (userTokenBalances[GUILD][token] == 0 && totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT) {totalGuildBankTokens += 1;}\r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n\r\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender = proposal.proposer\r\n    function cancelProposal(uint256 proposalId) external nonReentrant {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.flags[0] == 0, \"sponsored\");\r\n        require(proposal.flags[3] == 0, \"cancelled\");\r\n        require(msg.sender == proposal.proposer, \"!proposer\");\r\n\r\n        proposal.flags[3] = 1; // cancelled\r\n        \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        \r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) external nonReentrant {\r\n        require(members[msg.sender].shares > 0, \"caller !shareholder\");\r\n        require(newDelegateKey != address(0), \"newDelegateKey = 0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(members[newDelegateKey].exists == 0, \"!overwrite members\");\r\n            require(members[memberAddressByDelegateKey[newDelegateKey]].exists == 0, \"!overwrite keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n    \r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"!proposal\");\r\n        \r\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n    \r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n    \r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) external view returns (Vote) {\r\n        require(members[memberAddress].exists == 1, \"!member\");\r\n        require(proposalIndex < proposalQueue.length, \"!proposed\");\r\n        \r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) external view returns (uint8[7] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n    \r\n    function getProposalQueueLength() external view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n    \r\n    function getTokenCount() external view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) external view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n    \r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    receive() external payable {}\r\n    \r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) internal pure returns (uint256) {\r\n        require(totalSharesAndLoot != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalSharesAndLoot;\r\n        }\r\n\r\n        return (balance / totalSharesAndLoot) * shares;\r\n    }\r\n    \r\n    function registerMember(address newMember, uint256 shares) internal {\r\n        // if new member is already taken by a member's delegateKey, reset it to their member address\r\n        if (members[memberAddressByDelegateKey[newMember]].exists == 1) {\r\n            address memberToOverride = memberAddressByDelegateKey[newMember];\r\n            memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n            members[memberToOverride].delegateKey = memberToOverride;\r\n        }\r\n        \r\n        members[newMember] = Member({\r\n            delegateKey : newMember,\r\n            exists : 1, // 'true'\r\n            shares : shares,\r\n            loot : 0,\r\n            highestIndexYesVote : 0,\r\n            jailed : 0\r\n        });\r\n\r\n        memberAddressByDelegateKey[newMember] = newMember;\r\n    }\r\n    \r\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n    \r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n    \r\n    /********************\r\n    GUILD TOKEN FUNCTIONS\r\n    ********************/\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        require(amount == 0 || allowance[msg.sender][spender] == 0);\r\n        \r\n        allowance[msg.sender][spender] = amount;\r\n        \r\n        emit Approval(msg.sender, spender, amount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function burnGuildToken(address memberAddress, uint256 amount) internal {\r\n        balanceOf[memberAddress] = balanceOf[memberAddress].sub(amount);\r\n        emit Transfer(memberAddress, address(0), amount);\r\n    }\r\n    \r\n    function claimShares(uint256 amount) external nonReentrant {\r\n        IERC20(stakeToken).safeTransferFrom(msg.sender, address(this), amount); // deposit stake token & claim shares (1:1)\r\n        \r\n        // if the sender is already a member, add to their existing shares \r\n        if (members[msg.sender].exists == 1) {\r\n            members[msg.sender].shares = members[msg.sender].shares.add(amount);\r\n\r\n        // if the sender is a new member, create a new record for them\r\n        } else {\r\n            registerMember(msg.sender, amount);\r\n        }\r\n\r\n        // mint new guild token & shares \r\n        mintGuildToken(msg.sender, amount);\r\n        totalShares = totalShares.add(amount);\r\n            \r\n        require(totalShares <= MAX_GUILD_BOUND, \"guild maxed\");\r\n        \r\n        emit ClaimShares(msg.sender, amount);\r\n    }\r\n    \r\n    function convertSharesToLoot(uint256 sharesToLoot) external nonReentrant {\r\n        members[msg.sender].shares = members[msg.sender].shares.sub(sharesToLoot);\r\n        members[msg.sender].loot = members[msg.sender].loot.add(sharesToLoot);\r\n        \r\n        totalShares = totalShares.sub(sharesToLoot);\r\n        totalLoot = totalLoot.add(sharesToLoot);\r\n        \r\n        emit ConvertSharesToLoot(msg.sender, sharesToLoot);\r\n    }\r\n    \r\n    function mintGuildToken(address memberAddress, uint256 amount) internal {\r\n        balanceOf[memberAddress] = balanceOf[memberAddress].add(amount);\r\n        emit Transfer(address(0), memberAddress, amount);\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) { \r\n        return totalShares.add(totalLoot);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 lootToTransfer) external returns (bool) {\r\n        members[msg.sender].loot = members[msg.sender].loot.sub(lootToTransfer);\r\n        members[recipient].loot = members[recipient].loot.add(lootToTransfer);\r\n        \r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(lootToTransfer);\r\n        balanceOf[recipient] = balanceOf[recipient].add(lootToTransfer);\r\n        \r\n        emit Transfer(msg.sender, recipient, lootToTransfer);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 lootToTransfer) external returns (bool) {\r\n        allowance[sender][msg.sender] = allowance[sender][msg.sender].sub(lootToTransfer);\r\n        members[sender].loot = members[sender].loot.sub(lootToTransfer);\r\n        members[recipient].loot = members[recipient].loot.add(lootToTransfer);\r\n        \r\n        balanceOf[sender] = balanceOf[sender].sub(lootToTransfer);\r\n        balanceOf[recipient] = balanceOf[recipient].add(lootToTransfer);\r\n        \r\n        emit Transfer(sender, recipient, lootToTransfer);\r\n        \r\n        return true;\r\n    }\r\n}\r\n\r\n/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2018 Murray Software, LLC.\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\ncontract CloneFactory { // Mystic implementation of eip-1167 - see https://eips.ethereum.org/EIPS/eip-1167\r\n    function createClone(address payable target) internal returns (address payable result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\n\r\ncontract MysticSummoner is CloneFactory { \r\n    address payable public immutable template;\r\n    \r\n    constructor (address payable _template) public {\r\n        template = _template;\r\n    }\r\n\r\n    event SummonMystic(address indexed myst, address depositToken, address stakeToken, address[] summoner, uint256[] summonerShares, uint256 summoningDeposit, uint256 proposalDeposit, uint256 processingReward, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 dilutionBound, uint256 summoningTime);\r\n \r\n    function summonMystic(\r\n        address _depositToken,\r\n        address _stakeToken,\r\n        address[] memory _summoner,\r\n        uint256[] memory _summonerShares,\r\n        uint256 _summonerDeposit,\r\n        uint256 _proposalDeposit,\r\n        uint256 _processingReward,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _dilutionBound\r\n    ) external returns (address) {\r\n        Mystic myst = Mystic(createClone(template));\r\n        \r\n        myst.init(\r\n            _depositToken,\r\n            _stakeToken,\r\n            _summoner,\r\n            _summonerShares,\r\n            _summonerDeposit,\r\n            _proposalDeposit,\r\n            _processingReward,\r\n            _periodDuration,\r\n            _votingPeriodLength,\r\n            _gracePeriodLength,\r\n            _dilutionBound\r\n        );\r\n        \r\n        require(IERC20(_depositToken).transferFrom(msg.sender, address(myst), _summonerDeposit), \"!transfer\"); // transfer summoner deposit to new Mystic\r\n        \r\n        emit SummonMystic(address(myst), _depositToken, _stakeToken, _summoner, _summonerShares, _summonerDeposit, _proposalDeposit, _processingReward, _periodDuration, _votingPeriodLength, _gracePeriodLength, _dilutionBound, now);\r\n        \r\n        return address(myst);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_template\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"myst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"summoner\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"summonerShares\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"processingReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingPeriodLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gracePeriodLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dilutionBound\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningTime\",\"type\":\"uint256\"}],\"name\":\"SummonMystic\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_summoner\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_summonerShares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_summonerDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processingReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"}],\"name\":\"summonMystic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"template\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MysticSummoner","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c06926e80a7bf49b1363b93c88d70cacb1f8cec9","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3fa953c4fb0eb34530e04352707a62f2da6a1016de36d43c77e31b1577e20176"}]}